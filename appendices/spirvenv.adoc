// Copyright 2015-2025 The Khronos Group Inc.
//
// SPDX-License-Identifier: CC-BY-4.0

[appendix]
[[spirvenv]]
= Vulkan Environment for SPIR-V

Shaders for Vulkan are defined by the <<spirv-spec,Khronos SPIR-V
Specification>> as well as the <<spirv-extended,Khronos SPIR-V Extended
Instructions for GLSL>> Specification.
This appendix defines additional SPIR-V requirements applying to Vulkan
shaders.


== Versions and Formats

// The fallthrough logic here defines {spirv-versions} according to the
// highest Vulkan version supported, and simplifies the markup.

ifdef::VK_VERSION_1_0[]
:spirv-versions: 1.0 version
:api-version: 1.0
endif::VK_VERSION_1_0[]
ifdef::VK_VERSION_1_1[]
:spirv-versions: 1.0, 1.1, 1.2, and 1.3 versions
:api-version: 1.1
endif::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_2[]
:spirv-versions: 1.0, 1.1, 1.2, 1.3, 1.4, and 1.5 versions
:api-version: 1.2
endif::VK_VERSION_1_2[]
ifdef::VK_VERSION_1_3[]
:spirv-versions: 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, and 1.6 versions
:api-version: 1.3
endif::VK_VERSION_1_3[]
ifdef::VK_VERSION_1_4[]
:spirv-versions: 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, and 1.6 versions
:api-version: 1.4
endif::VK_VERSION_1_4[]

A Vulkan {api-version} implementation must: support the {spirv-versions} of
SPIR-V and the 1.0 version of the SPIR-V Extended Instructions for GLSL.
ifndef::VK_VERSION_1_2[]
ifdef::VK_KHR_spirv_1_4[]
If the `apiext:VK_KHR_spirv_1_4` extension is enabled, the implementation
must: additionally support the 1.4 version of SPIR-V.
endif::VK_KHR_spirv_1_4[]
endif::VK_VERSION_1_2[]

A SPIR-V module
ifndef::VKSC_VERSION_1_0[]
passed into flink:vkCreateShaderModule
endif::VKSC_VERSION_1_0[]
is interpreted as a series of 32-bit words in host endianness, with literal
strings packed as described in section 2.2 of the SPIR-V Specification.
The first few words of the SPIR-V module must: be a magic number and a
SPIR-V version number, as described in section 2.3 of the SPIR-V
Specification.


[[spirvenv-capabilities]]
== Capabilities

The <<spirvenv-capabilities-table, table below>> lists the set of SPIR-V
capabilities that may: be supported in Vulkan implementations.
ifndef::VKSC_VERSION_1_0[]
The application must: not use any of these capabilities in SPIR-V passed to
flink:vkCreateShaderModule unless one of the following conditions is met for
the slink:VkDevice specified in the pname:device parameter of
flink:vkCreateShaderModule:
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
The application must: not select a pipeline cache entry, which was created
by passing a SPIR-V module using any of these capabilities to the
<<pipelines-offline-compilation, offline pipeline cache compiler>>, in a
ftext:vkCreate*Pipelines command unless one of the following conditions is
met for the slink:VkDevice specified in the pname:device parameter of the
ftext:vkCreate*Pipelines command:
endif::VKSC_VERSION_1_0[]

  * The corresponding field in the table is blank.
  * Any corresponding Vulkan feature is enabled.
  * Any corresponding Vulkan extension is enabled.
  * Any corresponding Vulkan property is supported.
  * The corresponding core version is supported (as returned by
    slink:VkPhysicalDeviceProperties::pname:apiVersion).

:captableindent: {nbsp} {nbsp} {nbsp} {nbsp} {nbsp} {nbsp} {nbsp} {nbsp}
[[spirvenv-capabilities-table]]
.List of SPIR-V Capabilities and Corresponding Vulkan Features, Extensions, or Core Version
[options="header"]
|====
| SPIR-V code:OpCapability +
  {captableindent} Vulkan feature, extension, or core version
include::{generated}/spirvcap/captable.adoc[]
|====

ifndef::VKSC_VERSION_1_0[]
The application must: not pass a SPIR-V module containing any of the
following to flink:vkCreateShaderModule:
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
The application must: not select a pipeline cache entry, which was created
by passing a SPIR-V module containing any of the following to the
<<pipelines-offline-compilation, offline pipeline cache compiler>>,
containing any of the following in a ftext:vkCreate*Pipelines command:
endif::VKSC_VERSION_1_0[]

  * any code:OpCapability not listed above,
  * an unsupported capability, or
  * a capability which corresponds to a Vulkan feature or extension which
    has not been enabled.


[[spirvenv-extensions]]
=== SPIR-V Extensions

The <<spirvenv-extensions-table,following table>> lists SPIR-V extensions
that implementations may: support.
ifndef::VKSC_VERSION_1_0[]
The application must: not pass a SPIR-V module to flink:vkCreateShaderModule
that uses the following SPIR-V extensions unless one of the following
conditions is met for the slink:VkDevice specified in the pname:device
parameter of flink:vkCreateShaderModule:
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
The application must: not select a pipeline cache entry, which was created
by passing a SPIR-V module using any of the following SPIR-V extensions to
the <<pipelines-offline-compilation, offline pipeline cache compiler>>, in a
ftext:vkCreate*Pipelines command unless one of the following conditions is
met for the slink:VkDevice specified in the pname:device parameter of the
ftext:vkCreate*Pipelines command:
endif::VKSC_VERSION_1_0[]

  * Any corresponding Vulkan extension is enabled.
  * The corresponding core version is supported (as returned by
    slink:VkPhysicalDeviceProperties::pname:apiVersion).

[[spirvenv-extensions-table]]
.List of SPIR-V Extensions and Corresponding Vulkan Extensions or Core Version
[options="header"]
|====
| SPIR-V code:OpExtension +
  {captableindent} Vulkan extension or core version
include::{generated}/spirvcap/exttable.adoc[]
|====


[[spirvenv-module-validation]]
== Validation Rules Within a Module

ifndef::VKSC_VERSION_1_0[]
A SPIR-V module passed to flink:vkCreateShaderModule must: conform to the
following rules:
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
Pipeline cache entries must: have been compiled with the
<<pipelines-offline-compilation, offline pipeline cache compiler>> using
SPIR-V modules that conform to the following rules:
endif::VKSC_VERSION_1_0[]


[[spirvenv-module-validation-standalone]]
=== Standalone SPIR-V Validation

[open,refpage='StandaloneSpirv',desc='Standalone SPIR-V Validation',type='spirv']
--
:refpage: StandaloneSpirv

The following rules can: be validated with only the SPIR-V module itself.
They do not depend on knowledge of the implementation and its capabilities
or knowledge of runtime information, such as enabled features.

.Valid Usage
****
// NOTE: Do not conditionalize the "standalone" VUs.
// Write as though all extensions were enabled.
// Add any needed conditional logic to the runtime section if needed.
  * [[VUID-{refpage}-None-04633]]
    Every entry point must: have no return value and accept no arguments
  * [[VUID-{refpage}-None-04634]]
    The static function-call graph for an entry point must: not contain
    cycles; that is, static recursion is not allowed
  * [[VUID-{refpage}-None-04635]]
    The code:Logical or code:PhysicalStorageBuffer64 addressing model must:
    be selected
  * [[VUID-{refpage}-None-04636]]
    code:Scope for execution must: be limited to code:Workgroup or
    code:Subgroup
  * [[VUID-{refpage}-None-04637]]
    If the code:Scope for execution is code:Workgroup, then it must: only be
    used in the task, mesh, tessellation control, or compute
    {ExecutionModel}
  * [[VUID-{refpage}-None-04638]]
    code:Scope for memory must: be limited to code:Device, code:QueueFamily,
    code:Workgroup, code:ShaderCallKHR, code:Subgroup, or code:Invocation
  * [[VUID-{refpage}-ExecutionModel-07320]]
    If the {ExecutionModel} is code:TessellationControl, and the
    code:MemoryModel is code:GLSL450, the code:Scope for memory must: not be
    code:Workgroup
  * [[VUID-{refpage}-None-07321]]
    If the code:Scope for memory is code:Workgroup, then it must: only be
    used in the task, mesh, tessellation control, or compute
    {ExecutionModel}
  * [[VUID-{refpage}-None-04640]]
    If the code:Scope for memory is code:ShaderCallKHR, then it must: only
    be used in ray generation, intersection, closest hit, any-hit, miss, and
    callable {ExecutionModel}
  * [[VUID-{refpage}-None-04641]]
    If the code:Scope for memory is code:Invocation, then
    code:MemorySemantics must: use code:Relaxed memory order
  * [[VUID-{refpage}-None-04642]]
    code:Scope for <<shaders-group-operations,group operations>> must: be
    limited to code:Subgroup
  * [[VUID-{refpage}-SubgroupVoteKHR-07951]]
    If none of the code:SubgroupVoteKHR, code:GroupNonUniform, or
    code:SubgroupBallotKHR capabilities are declared, code:Scope for memory
    must: not be code:Subgroup
  * [[VUID-{refpage}-None-04643]]
    {StorageClass} must: be limited to code:UniformConstant, code:Input,
    code:Uniform, code:Output, code:Workgroup, code:Private, code:Function,
    code:PushConstant, code:Image, code:StorageBuffer, code:RayPayloadKHR,
    code:IncomingRayPayloadKHR, code:HitAttributeKHR, code:CallableDataKHR,
    code:IncomingCallableDataKHR, code:ShaderRecordBufferKHR,
    code:PhysicalStorageBuffer, or code:TileImageEXT
  * [[VUID-{refpage}-None-04644]]
    If the {StorageClass} is code:Output, then it must: not be used in the
    code:GlCompute, code:RayGenerationKHR, code:IntersectionKHR,
    code:AnyHitKHR, code:ClosestHitKHR, code:MissKHR, or code:CallableKHR
    {ExecutionModel}
  * [[VUID-{refpage}-None-04645]]
    If the {StorageClass} is code:Workgroup, then it must: only be used in
    the task, mesh, or compute {ExecutionModel}
  * [[VUID-{refpage}-None-08720]]
    If the {StorageClass} is code:TileImageEXT, then it must: only be used
    in the fragment execution model
  * [[VUID-{refpage}-MemorySemantics-10865]]
    code:MemorySemantics must: have at most one non-relaxed memory order bit
    set (code:Acquire, code:Release, or code:AcquireRelease)
  * [[VUID-{refpage}-MemorySemantics-10866]]
    code:MemorySemantics with code:SequentiallyConsistent memory order must:
    not be used in the Vulkan API
  * [[VUID-{refpage}-MemorySemantics-10867]]
    code:MemorySemantics must: not use code:Acquire or code:AcquireRelease
    memory order with code:OpAtomicStore
  * [[VUID-{refpage}-MemorySemantics-10868]]
    code:MemorySemantics must: not use code:Release or code:AcquireRelease
    memory order with code:OpAtomicLoad
  * [[VUID-{refpage}-MemorySemantics-10869]]
    code:MemorySemantics must: not use code:Relaxed memory order with
    code:OpMemoryBarrier
  * [[VUID-{refpage}-MemorySemantics-10870]]
    code:MemorySemantics with a non-relaxed memory order (code:Acquire,
    code:Release, or code:AcquireRelease) must: have at least one
    Vulkan-supported storage class semantics bit set (code:UniformMemory,
    code:WorkgroupMemory, code:ImageMemory, or code:OutputMemory)
  * [[VUID-{refpage}-MemorySemantics-10871]]
    code:MemorySemantics with at least one Vulkan-supported storage class
    semantics bit set (code:UniformMemory, code:WorkgroupMemory,
    code:ImageMemory, or code:OutputMemory) must: use a non-relaxed memory
    order (code:Acquire, code:Release, or code:AcquireRelease)
  * [[VUID-{refpage}-MemorySemantics-10872]]
    code:MemorySemantics with code:MakeAvailable bit set must: use
    code:Release or code:AcquireRelease memory order
  * [[VUID-{refpage}-MemorySemantics-10873]]
    code:MemorySemantics with code:MakeVisible bit set must: use
    code:Acquire or code:AcquireRelease memory order
  * [[VUID-{refpage}-MemorySemantics-10874]]
    code:MemorySemantics with code:Volatile bit set must: not be used with
    barrier instructions (code:OpControlBarrier or code:OpMemoryBarrier)
  * [[VUID-{refpage}-UnequalMemorySemantics-10875]]
    code:UnequalMemorySemantics of code:OpAtomicCompareExchange must: not
    use code:Release or code:AcquireRelease memory order
  * [[VUID-{refpage}-UnequalMemorySemantics-10876]]
    code:UnequalMemorySemantics of code:OpAtomicCompareExchange must: not
    use a stronger memory order than the corresponding
    code:EqualMemorySemantics
  * [[VUID-{refpage}-UnequalMemorySemantics-10877]]
    code:UnequalMemorySemantics of code:OpAtomicCompareExchange must: not
    have any Vulkan-supported storage class semantics bit set
    (code:UniformMemory, code:WorkgroupMemory, code:ImageMemory, or
    code:OutputMemory) unless this bit is also set in the corresponding
    code:EqualMemorySemantics
  * [[VUID-{refpage}-UnequalMemorySemantics-10878]]
    code:UnequalMemorySemantics of code:OpAtomicCompareExchange must: not
    have code:MakeVisible bit set unless this bit is also set in the
    corresponding code:EqualMemorySemantics
  * [[VUID-{refpage}-UnequalMemorySemantics-10879]]
    code:UnequalMemorySemantics of code:OpAtomicCompareExchange must: have
    code:Volatile bit set if and only if this bit is also set in the
    corresponding code:EqualMemorySemantics
  * [[VUID-{refpage}-OpVariable-04651]]
    Any variable with an code:Initializer operand must: have code:Output,
    code:Private, code:Function, or code:Workgroup as its {StorageClass}
    operand
  * [[VUID-{refpage}-OpVariable-04734]]
    Any variable with an code:Initializer operand and code:Workgroup as its
    {StorageClass} operand must: use code:OpConstantNull as the initializer
  * [[VUID-{refpage}-OpReadClockKHR-04652]]
    code:Scope for code:OpReadClockKHR must: be limited to code:Subgroup or
    code:Device
  * [[VUID-{refpage}-OriginLowerLeft-04653]]
    The code:OriginLowerLeft {ExecutionMode} must: not be used; fragment
    entry points must: declare code:OriginUpperLeft
  * [[VUID-{refpage}-PixelCenterInteger-04654]]
    The code:PixelCenterInteger {ExecutionMode} must: not be used (pixels
    are always centered at half-integer coordinates)
  * [[VUID-{refpage}-UniformConstant-04655]]
    Any variable in the code:UniformConstant {StorageClass} must: be typed
    as either code:OpTypeImage, code:OpTypeSampler, code:OpTypeSampledImage,
    code:OpTypeAccelerationStructureKHR, code:OpTypeTensorARM or an array of
    one of these types
  * [[VUID-{refpage}-Uniform-06807]]
    Any variable in the code:Uniform or code:StorageBuffer {StorageClass}
    must: be typed as code:OpTypeStruct or an array of this type
  * [[VUID-{refpage}-PushConstant-06808]]
    Any variable in the code:PushConstant {StorageClass} must: be typed as
    code:OpTypeStruct
  * [[VUID-{refpage}-OpTypeImage-04656]]
    code:OpTypeImage must: declare a scalar 32-bit float, 64-bit integer, or
    32-bit integer type for the "`Sampled Type`" (code:RelaxedPrecision can:
    be applied to a sampling instruction and to the variable holding the
    result of a sampling instruction)
  * [[VUID-{refpage}-OpTypeImage-04657]]
    code:OpTypeImage must: have a "`Sampled`" operand of 1 (sampled image)
    or 2 (storage image)
  * [[VUID-{refpage}-OpTypeSampledImage-06671]]
    code:OpTypeSampledImage must: have a code:OpTypeImage with a "`Sampled`"
    operand of 1 (sampled image)
  * [[VUID-{refpage}-Image-04965]]
    The <<spirv-type,SPIR-V Type>> of the code:Image code:Format operand of
    an code:OpTypeImage must: match the code:Sampled code:Type, as defined
    in <<spirvenv-format-type-matching>>
  * [[VUID-{refpage}-OpImageTexelPointer-04658]]
    If an code:OpImageTexelPointer is used in an atomic operation, the image
    type of the code:image parameter to code:OpImageTexelPointer must: have
    an image format of code:R64i, code:R64ui, code:R32f, code:R32i, or
    code:R32ui
  * [[VUID-{refpage}-OpImageQuerySizeLod-04659]]
    code:OpImageQuerySizeLod, code:OpImageQueryLod, and
    code:OpImageQueryLevels must: only consume an "`Image`" operand whose
    type has its "`Sampled`" operand set to 1
  * [[VUID-{refpage}-OpTypeImage-09638]]
    An code:OpTypeImage must: not have a "`Dim`" operand of code:Rect
  * [[VUID-{refpage}-OpTypeImage-06214]]
    An code:OpTypeImage with a "`Dim`" operand of code:SubpassData must:
    have an "`Arrayed`" operand of 0 (non-arrayed) and a "`Sampled`" operand
    of 2 (storage image)
  * [[VUID-{refpage}-SubpassData-04660]]
    The [eq]#(u,v)# coordinates used for a code:SubpassData must: be the
    <id> of a constant vector [eq]#(0,0)#
  * [[VUID-{refpage}-OpTypeImage-06924]]
    Objects of types code:OpTypeImage, code:OpTypeSampler,
    code:OpTypeSampledImage, code:OpTypeAccelerationStructureKHR,
    code:OpTypeTensorARM, and arrays of these types must: not be stored to
    or modified
  * [[VUID-{refpage}-Uniform-06925]]
    Any variable in the code:Uniform {StorageClass} decorated as code:Block
    must: not be stored to or modified
  * [[VUID-{refpage}-Offset-04865]]
    Any image instruction which uses an code:Offset, code:ConstOffset, or
    code:ConstOffsets image operand, must: only consume a "`Sampled Image`"
    operand whose type has its "`Sampled`" operand set to 1
  * [[VUID-{refpage}-OpImageGather-04664]]
    The "`Component`" operand of code:OpImageGather, and
    code:OpImageSparseGather must: be the <id> of a constant instruction
  * [[VUID-{refpage}-OpImage-04777]]
    code:OpImage*Dref* instructions must: not consume an image whose `Dim`
    is 3D
  * [[VUID-{refpage}-None-04667]]
    Structure types must: not contain opaque types
  * [[VUID-{refpage}-BuiltIn-04668]]
    Any code:BuiltIn decoration not listed in
    <<interfaces-builtin-variables>> must: not be used
  * [[VUID-{refpage}-OpEntryPoint-09658]]
    For a given code:OpEntryPoint, any code:BuiltIn decoration must: not be
    used more than once by the code:Input interface
  * [[VUID-{refpage}-OpEntryPoint-09659]]
    For a given code:OpEntryPoint, any code:BuiltIn decoration must: not be
    used more than once by the code:Output interface
  * [[VUID-{refpage}-Location-06672]]
    The code:Location or code:Component decorations must: only be used with
    the code:Input, code:Output, code:RayPayloadKHR,
    code:IncomingRayPayloadKHR, code:HitAttributeKHR,
    code:HitObjectAttributeNV, code:CallableDataKHR,
    code:IncomingCallableDataKHR, or code:ShaderRecordBufferKHR storage
    classes
  * [[VUID-{refpage}-Location-04915]]
    The code:Location or code:Component decorations must: not be used with
    code:BuiltIn
  * [[VUID-{refpage}-Location-04916]]
    The code:Location decorations must: be used on
    <<interfaces-iointerfaces-user,user-defined variables>>
  * [[VUID-{refpage}-Location-04917]]
    If a <<interfaces-iointerfaces-user,user-defined variable>> is not a
    pointer to a code:Block decorated code:OpTypeStruct, then the variable
    must: have a code:Location decoration
  * [[VUID-{refpage}-Location-04918]]
    If a <<interfaces-iointerfaces-user,user-defined variable>> has a
    code:Location decoration, and the variable is a pointer to a
    code:OpTypeStruct, then the members of that structure must: not have
    code:Location decorations
  * [[VUID-{refpage}-Location-04919]]
    If a <<interfaces-iointerfaces-user,user-defined variable>> does not
    have a code:Location decoration, and the variable is a pointer to a
    code:Block decorated code:OpTypeStruct, then each member of the struct
    must: have a code:Location decoration
  * [[VUID-{refpage}-Component-04920]]
    The code:Component decoration value must: not be greater than 3
  * [[VUID-{refpage}-Component-04921]]
    If the code:Component decoration is used on a variable that has a
    code:OpTypeVector type with a code:Component code:Type with a code:Width
    that is less than or equal to 32, the sum of its code:Component
    code:Count and the code:Component decoration value must: be less than or
    equal to 4
  * [[VUID-{refpage}-Component-04922]]
    If the code:Component decoration is used on a variable that has a
    code:OpTypeVector type with a code:Component code:Type with a code:Width
    that is equal to 64, the sum of two times its code:Component code:Count
    and the code:Component decoration value must: be less than or equal to 4
  * [[VUID-{refpage}-Component-04923]]
    The code:Component decorations value must: not be 1 or 3 for scalar or
    two-component 64-bit data types
  * [[VUID-{refpage}-Component-07703]]
    The code:Component decorations must: not be used for a 64-bit vector
    type with more than two components
  * [[VUID-{refpage}-Component-10583]]
    The code:Component decorations must: not be used with any type that is
    not a scalar, vector, array of scalars or vectors, or an array of arrays
    of scalars or vectors
  * [[VUID-{refpage}-Execution-10584]]
    If the code:Execution code:Model of an entry point is not
    code:TessellationControl or code:Geometry, its interface definition
    must: not include any variables in the code:Input storage class
    decorated with code:Component that are arrays of arrays of scalars or
    vectors
  * [[VUID-{refpage}-Execution-10585]]
    If the code:Execution code:Model of an entry point is not code:MeshNV,
    its interface definition must: not include any variables in the
    code:Output storage class decorated with code:Component that are arrays
    of arrays of scalars or vectors
  * [[VUID-{refpage}-Output-10586]]
    Variables in the code:Output storage class in the code:Vertex,
    code:TessellationControl, code:TessellationEvaluation, or code:Geometry
    execution model must: not have overlapping code:Component and
    code:Location decorations as defined by
    <<interfaces-iointerfaces-locations,Location and Component Assignment>>
  * [[VUID-{refpage}-Output-10587]]
    Variables in the code:Output storage class in the code:Fragment
    execution model must: not have both identical code:Index decorations and
    overlapping code:Component and code:Location decorations as defined by
    <<interfaces-iointerfaces-locations,Location and Component Assignment>>
  * [[VUID-{refpage}-Input-10588]]
    Variables in the code:Input storage class in the
    code:TessellationControl, code:TessellationEvaluation, code:Geometry, or
    code:Fragment execution model must: not have overlapping code:Component
    and code:Location decorations as defined by
    <<interfaces-iointerfaces-locations,Location and Component Assignment>>
  * [[VUID-{refpage}-Input-10604]]
    Any variable in the code:Input storage class in the code:Fragment
    execution model must: not have an assigned code:Location shared with
    another variable with different decorations for code:PerVertexKHR,
    code:Flat, code:NoPerspective, code:Sample, or code:Centroid
  * [[VUID-{refpage}-Input-09557]]
    The pointers of any code:Input or code:Output
    <<interfaces-iointerfaces-user,Interface user-defined variables>> must:
    not contain any code:PhysicalStorageBuffer {StorageClass} pointers
  * [[VUID-{refpage}-None-10684]]
    All variables must: have valid explicit layout decorations
    <<interfaces-explicit-layout-decorations,as described in Shader
    Interfaces>>
  * [[VUID-{refpage}-GLSLShared-04669]]
    The code:GLSLShared and code:GLSLPacked decorations must: not be used
  * [[VUID-{refpage}-TessLevelInner-10880]]
    Any variable decorated with code:TessLevelInner or code:TessLevelOuter
    must: also be decorated with code:Patch
  * [[VUID-{refpage}-Flat-04670]]
    The code:Flat, code:NoPerspective, code:Sample, and code:Centroid
    decorations must: only be used on variables with the code:Output or
    code:Input {StorageClass}
  * [[VUID-{refpage}-Flat-06201]]
    The code:Flat, code:NoPerspective, code:Sample, and code:Centroid
    decorations must: not be used on variables with the code:Output storage
    class in a fragment shader
  * [[VUID-{refpage}-Flat-06202]]
    The code:Flat, code:NoPerspective, code:Sample, and code:Centroid
    decorations must: not be used on variables with the code:Input storage
    class in a vertex shader
  * [[VUID-{refpage}-PerVertexKHR-06777]]
    The code:PerVertexKHR decoration must: only be used on variables with
    the code:Input {StorageClass} in a fragment shader
  * [[VUID-{refpage}-Flat-04744]]
    Any variable with integer or double-precision floating-point type and
    with code:Input {StorageClass} in a fragment shader, must: be decorated
    code:Flat
  * [[VUID-{refpage}-ViewportRelativeNV-04672]]
    The code:ViewportRelativeNV decoration must: only be used on a variable
    decorated with code:Layer in the vertex, tessellation evaluation, or
    geometry shader stages
  * [[VUID-{refpage}-ViewportRelativeNV-04673]]
    The code:ViewportRelativeNV decoration must: not be used unless a
    variable decorated with one of code:ViewportIndex or code:ViewportMaskNV
    is also statically used by the same code:OpEntryPoint
  * [[VUID-{refpage}-ViewportMaskNV-04674]]
    The code:ViewportMaskNV and code:ViewportIndex decorations must: not
    both be statically used by one or more code:OpEntryPoint's that form the
    <<pipelines-graphics-subsets-pre-rasterization,pre-rasterization shader
    stages>> of a graphics pipeline
  * [[VUID-{refpage}-FPRoundingMode-04675]]
    Rounding modes other than round-to-nearest-even and round-towards-zero
    must: not be used for the code:FPRoundingMode decoration
  * [[VUID-{refpage}-Invariant-04677]]
    Variables decorated with code:Invariant and variables with structure
    types that have any members decorated with code:Invariant must: be in
    the code:Output or code:Input {StorageClass}, code:Invariant used on an
    code:Input {StorageClass} variable or structure member has no effect
  * [[VUID-{refpage}-VulkanMemoryModel-04678]]
    [[builtin-volatile-semantics]] If the code:VulkanMemoryModel capability
    is not declared, the code:Volatile decoration must: be used on any
    variable declaration that includes one of the code:SMIDNV,
    code:WarpIDNV, code:SubgroupSize, code:SubgroupLocalInvocationId,
    code:SubgroupEqMask, code:SubgroupGeMask, code:SubgroupGtMask,
    code:SubgroupLeMask, or code:SubgroupLtMask code:BuiltIn decorations
    when used in the ray generation, closest hit, miss, intersection, or
    callable shaders, or with the code:RayTmaxKHR code:Builtin decoration
    when used in an intersection shader
  * [[VUID-{refpage}-VulkanMemoryModel-04679]]
    If the code:VulkanMemoryModel capability is declared, the code:OpLoad
    instruction must: use code:MemorySemantics with the code:Volatile flag
    when it accesses into any variable that includes one of the code:SMIDNV,
    code:WarpIDNV, code:SubgroupSize, code:SubgroupLocalInvocationId,
    code:SubgroupEqMask, code:SubgroupGeMask, code:SubgroupGtMask,
    code:SubgroupLeMask, or code:SubgroupLtMask code:BuiltIn decorations
    when used in the ray generation, closest hit, miss, intersection, or
    callable shaders, or with the code:RayTmaxKHR code:Builtin decoration
    when used in an intersection shader
  * [[VUID-{refpage}-OpTypeRuntimeArray-04680]]
    code:OpTypeRuntimeArray must: only be instantiated by a variable as:
  ** the last member of a code:Block-decorated code:OpTypeStruct in
     code:StorageBuffer or code:PhysicalStorageBuffer storage {StorageClass}
  ** code:BufferBlock-decorated code:OpTypeStruct in the code:Uniform
     storage {StorageClass}
  ** the outermost dimension of an arrayed variable in the
     code:StorageBuffer, code:Uniform, or code:UniformConstant storage
     {StorageClass}
  ** the code:NodePayloadAMDX storage {StorageClass} when the
     code:CoalescingAMDX {ExecutionMode} is specified
  * [[VUID-{refpage}-Function-04681]]
    A type _T_ that is an array sized with a specialization constant must:
    neither be, nor be contained in, the type _T2_ of a variable _V_, unless
    either: a) _T_ is equal to _T2_, b) _V_ is declared in the
    code:Function, or code:Private {StorageClass}, c) _V_ is a non-Block
    variable in the code:Workgroup {StorageClass}, or d) _V_ is an interface
    variable with an additional level of arrayness,
    <<interfaces-iointerfaces-matching, as described in interface
    matching>>, and _T_ is the member type of the array type _T2_
  * [[VUID-{refpage}-OpControlBarrier-04682]]
    If code:OpControlBarrier is used in ray generation, intersection,
    any-hit, closest hit, miss, fragment, vertex, tessellation evaluation,
    or geometry shaders, the execution Scope must: be code:Subgroup
  * [[VUID-{refpage}-None-10685]]
    For each compute shader entry point, either a code:TileShadingRateQCOM,
    code:LocalSize, or code:LocalSizeId {ExecutionMode}, or an object
    decorated with the code:WorkgroupSize decoration must: be specified
  * [[VUID-{refpage}-DerivativeGroupQuadsNV-04684]]
    For compute shaders using the code:DerivativeGroupQuadsNV execution
    mode, the first two dimensions of the local workgroup size must: be a
    multiple of two
  * [[VUID-{refpage}-DerivativeGroupLinearNV-04778]]
    For compute shaders using the code:DerivativeGroupLinearNV execution
    mode, the product of the dimensions of the local workgroup size must: be
    a multiple of four
  * [[VUID-{refpage}-DerivativeGroupQuadsKHR-10151]]
    For compute, mesh, or task shaders using the
    code:DerivativeGroupQuadsKHR execution mode, the first two dimensions of
    the local workgroup size must: be a multiple of two
  * [[VUID-{refpage}-DerivativeGroupLinearKHR-10152]]
    For compute, mesh, or task shaders using the
    code:DerivativeGroupLinearKHR execution mode, the product of the
    dimensions of the local workgroup size must: be a multiple of four
  * [[VUID-{refpage}-OpGroupNonUniformBallotBitCount-04685]]
    If code:OpGroupNonUniformBallotBitCount is used, the group operation
    must: be limited to code:Reduce, code:InclusiveScan, or
    code:ExclusiveScan
  * [[VUID-{refpage}-None-04686]]
    The _Pointer_ operand of all atomic instructions must: have a
    {StorageClass} limited to code:Uniform, code:Workgroup, code:Image,
    code:StorageBuffer, code:PhysicalStorageBuffer, or
    code:TaskPayloadWorkgroupEXT
  * [[VUID-{refpage}-Offset-04687]]
    Output variables or block members decorated with code:Offset that have a
    64-bit type, or a composite type containing a 64-bit type, must: specify
    an code:Offset value aligned to a 8 byte boundary
  * [[VUID-{refpage}-Offset-04689]]
    The size of any output block containing any member decorated with
    code:Offset that is a 64-bit type must: be a multiple of 8
  * [[VUID-{refpage}-Offset-04690]]
    The first member of an output block specifying a code:Offset decoration
    must: specify a code:Offset value that is aligned to an 8 byte boundary
    if that block contains any member decorated with code:Offset and is a
    64-bit type
  * [[VUID-{refpage}-Offset-04691]]
    Output variables or block members decorated with code:Offset that have a
    32-bit type, or a composite type contains a 32-bit type, must: specify
    an code:Offset value aligned to a 4 byte boundary
  * [[VUID-{refpage}-Offset-04692]]
    Output variables, blocks or block members decorated with code:Offset
    must: only contain base types that have components that are either
    32-bit or 64-bit in size
  * [[VUID-{refpage}-Offset-04716]]
    Only variables or block members in the output interface decorated with
    code:Offset can: be captured for transform feedback, and those variables
    or block members must: also be decorated with code:XfbBuffer and
    code:XfbStride, or inherit code:XfbBuffer and code:XfbStride decorations
    from a block containing them
  * [[VUID-{refpage}-XfbBuffer-04693]]
    All variables or block members in the output interface of the entry
    point being compiled decorated with a specific code:XfbBuffer value
    must: all be decorated with identical code:XfbStride values
  * [[VUID-{refpage}-Stream-04694]]
    If any variables or block members in the output interface of the entry
    point being compiled are decorated with code:Stream, then all variables
    belonging to the same code:XfbBuffer must: specify the same code:Stream
    value
  * [[VUID-{refpage}-XfbBuffer-04696]]
    For any two variables or block members in the output interface of the
    entry point being compiled with the same code:XfbBuffer value, the
    ranges determined by the code:Offset decoration and the size of the type
    must: not overlap
  * [[VUID-{refpage}-XfbBuffer-04697]]
    All block members in the output interface of the entry point being
    compiled that are in the same block and have a declared or inherited
    code:XfbBuffer decoration must: specify the same code:XfbBuffer value
  * [[VUID-{refpage}-RayPayloadKHR-04698]]
    code:RayPayloadKHR {StorageClass} must: only be used in ray generation,
    closest hit or miss shaders
  * [[VUID-{refpage}-IncomingRayPayloadKHR-04699]]
    code:IncomingRayPayloadKHR {StorageClass} must: only be used in closest
    hit, any-hit, or miss shaders
  * [[VUID-{refpage}-IncomingRayPayloadKHR-04700]]
    There must: be at most one variable with the code:IncomingRayPayloadKHR
    {StorageClass} in the input interface of an entry point
  * [[VUID-{refpage}-HitAttributeKHR-04701]]
    code:HitAttributeKHR {StorageClass} must: only be used in intersection,
    any-hit, or closest hit shaders
  * [[VUID-{refpage}-HitAttributeKHR-04702]]
    There must: be at most one variable with the code:HitAttributeKHR
    {StorageClass} in the input interface of an entry point
  * [[VUID-{refpage}-HitAttributeKHR-04703]]
    A variable with code:HitAttributeKHR {StorageClass} must: only be
    written to in an intersection shader
  * [[VUID-{refpage}-CallableDataKHR-04704]]
    code:CallableDataKHR {StorageClass} must: only be used in ray
    generation, closest hit, miss, and callable shaders
  * [[VUID-{refpage}-IncomingCallableDataKHR-04705]]
    code:IncomingCallableDataKHR {StorageClass} must: only be used in
    callable shaders
  * [[VUID-{refpage}-IncomingCallableDataKHR-04706]]
    There must: be at most one variable with the
    code:IncomingCallableDataKHR {StorageClass} in the input interface of an
    entry point
  * [[VUID-{refpage}-ShaderRecordBufferKHR-07119]]
    code:ShaderRecordBufferKHR {StorageClass} must: only be used in ray
    generation, intersection, any-hit, closest hit, callable, or miss
    shaders
  * [[VUID-{refpage}-Base-07650]]
    The code:Base operand of code:OpPtrAccessChain or
    code:OpUntypedPtrAccessChainKHR must: have a storage class of
    code:Workgroup, code:StorageBuffer, or code:PhysicalStorageBuffer
  * [[VUID-{refpage}-Base-07651]]
    If the code:Base operand of code:OpPtrAccessChain or
    code:OpUntypedPtrAccessChainKHR has a code:Workgroup {StorageClass},
    then the code:VariablePointers capability must: be declared
  * [[VUID-{refpage}-Base-07652]]
    If the code:Base operand of code:OpPtrAccessChain or
    code:OpUntypedPtrAccessChainKHR has a code:StorageBuffer {StorageClass},
    then the code:VariablePointers or code:VariablePointersStorageBuffer
    capability must: be declared
  * [[VUID-{refpage}-OpUntypedVariableKHR-11167]]
    Any code:OpUntypedVariableKHR must: have a code:Data code:Type operand
    specified
  * [[VUID-{refpage}-PhysicalStorageBuffer64-04708]]
    If the code:PhysicalStorageBuffer64 addressing model is enabled, all
    instructions that support memory access operands and that use a physical
    pointer must: include the code:Aligned operand
  * [[VUID-{refpage}-PhysicalStorageBuffer64-04709]]
    If the code:PhysicalStorageBuffer64 addressing model is enabled, any
    access chain instruction that accesses into a code:RowMajor matrix must:
    only be used as the code:Pointer operand to code:OpLoad or code:OpStore
  * [[VUID-{refpage}-PhysicalStorageBuffer64-04710]]
    If the code:PhysicalStorageBuffer64 addressing model is enabled,
    code:OpConvertUToPtr and code:OpConvertPtrToU must: use an integer type
    whose code:Width is 64
  * [[VUID-{refpage}-PhysicalStorageBuffer64-06314]]
    If the code:PhysicalStorageBuffer64 addressing model is enabled any load
    or store through a physical pointer type must: have an code:Aligned
    operand which is a multiple of the size of the largest scalar type in
    the pointed-to type
  * [[VUID-{refpage}-OpTypeForwardPointer-04711]]
    code:OpTypeForwardPointer must: have a {StorageClass} of
    code:PhysicalStorageBuffer
  * [[VUID-{refpage}-None-04745]]
    All block members in a variable with a {StorageClass} of
    code:PushConstant declared as an array must: only be accessed by
    dynamically uniform indices
  * [[VUID-{refpage}-OpVariable-06673]]
    There must: not be more than one variable in the code:PushConstant
    {StorageClass} listed in the code:Interface for each code:OpEntryPoint
  * [[VUID-{refpage}-OpEntryPoint-06674]]
    Each code:OpEntryPoint must: not statically use more than one variable
    in the code:PushConstant {StorageClass}
  * [[VUID-{refpage}-OpEntryPoint-08721]]
    Each code:OpEntryPoint must: not have more than one code:Input variable
    assigned the same code:Component word inside a code:Location slot,
    either explicitly or implicitly
  * [[VUID-{refpage}-OpEntryPoint-08722]]
    Each code:OpEntryPoint must: not have more than one code:Output variable
    assigned the same code:Component word inside a code:Location slot,
    either explicitly or implicitly
  * [[VUID-{refpage}-Result-04780]]
    The code:Result code:Type operand of any code:OpImageRead or
    code:OpImageSparseRead instruction must: be a vector of four components
  * [[VUID-{refpage}-PushConstant-06675]]
    Any variable in the code:PushConstant or code:StorageBuffer storage
    class must: be decorated as code:Block
  * [[VUID-{refpage}-Uniform-06676]]
    Any variable in the code:Uniform {StorageClass} must: be decorated as
    code:Block or code:BufferBlock
  * [[VUID-{refpage}-UniformConstant-06677]]
    Any variable in the code:UniformConstant, code:StorageBuffer, or
    code:Uniform {StorageClass} must: be decorated with code:DescriptorSet
    and code:Binding
  * [[VUID-{refpage}-InputAttachmentIndex-06678]]
    Variables decorated with code:InputAttachmentIndex must: be in the
    code:UniformConstant {StorageClass}
  * [[VUID-{refpage}-DescriptorSet-06491]]
    If a variable is decorated by code:DescriptorSet or code:Binding, the
    {StorageClass} must: correspond to an entry in
    <<interfaces-resources-storage-class-correspondence, Shader Resource and
    Storage Class Correspondence>>
  * [[VUID-{refpage}-Input-06778]]
    Variables with a {StorageClass} of code:Input in a fragment shader stage
    that are decorated with code:PerVertexKHR must: be declared as arrays
  * [[VUID-{refpage}-MeshEXT-07102]]
    The module must: not contain both an entry point that uses the
    code:TaskEXT or code:MeshEXT {ExecutionModel} and an entry point that
    uses the code:TaskNV or code:MeshNV {ExecutionModel}
  * [[VUID-{refpage}-MeshEXT-07106]]
    In mesh shaders using the code:MeshEXT {ExecutionModel}
    code:OpSetMeshOutputsEXT must: be called before any outputs are written
  * [[VUID-{refpage}-MeshEXT-07107]]
    In mesh shaders using the code:MeshEXT {ExecutionModel} all variables
    declared as output must: not be read from
  * [[VUID-{refpage}-MeshEXT-07108]]
    In mesh shaders using the code:MeshEXT {ExecutionModel} for
    code:OpSetMeshOutputsEXT instructions, the "`Vertex Count`" and
    "`Primitive Count`" operands must: not depend on code:ViewIndex
  * [[VUID-{refpage}-MeshEXT-07109]]
    In mesh shaders using the code:MeshEXT {ExecutionModel} variables
    decorated with code:PrimitivePointIndicesEXT,
    code:PrimitiveLineIndicesEXT, or code:PrimitiveTriangleIndicesEXT
    declared as an array must: not be accessed by indices that depend on
    code:ViewIndex
  * [[VUID-{refpage}-MeshEXT-07110]]
    In mesh shaders using the code:MeshEXT {ExecutionModel} any values
    stored in variables decorated with code:PrimitivePointIndicesEXT,
    code:PrimitiveLineIndicesEXT, or code:PrimitiveTriangleIndicesEXT must:
    not depend on code:ViewIndex
  * [[VUID-{refpage}-MeshEXT-07111]]
    In mesh shaders using the code:MeshEXT {ExecutionModel} variables in
    workgroup or private {StorageClass} declared as or containing a
    composite type must: not be accessed by indices that depend on
    code:ViewIndex
  * [[VUID-{refpage}-MeshEXT-07330]]
    In mesh shaders using the code:MeshEXT {ExecutionModel} the
    code:OutputVertices {ExecutionMode} must: be greater than 0
  * [[VUID-{refpage}-MeshEXT-07331]]
    In mesh shaders using the code:MeshEXT {ExecutionModel} the
    code:OutputPrimitivesEXT {ExecutionMode} must: be greater than 0
  * [[VUID-{refpage}-Input-07290]]
    Variables with a {StorageClass} of code:Input or code:Output and a type
    of code:OpTypeBool must: be decorated with the code:BuiltIn decoration
  * [[VUID-{refpage}-TileImageEXT-08723]]
    The tile image variable declarations must: obey the constraints on the
    code:TileImageEXT {StorageClass} and the code:Location decoration
    described in <<interfaces-fragmenttileimage, Fragment Tile Image
    Interface>>
  * [[VUID-{refpage}-None-08724]]
    The code:TileImageEXT {StorageClass} must: only be used for declaring
    tile image variables
  * [[VUID-{refpage}-Pointer-08973]]
    The {StorageClass} of the code:Pointer operand to
    code:OpCooperativeMatrixLoadKHR or code:OpCooperativeMatrixStoreKHR
    must: be limited to code:Workgroup, code:StorageBuffer, or
    code:PhysicalStorageBuffer
  * [[VUID-{refpage}-OpTypeFloat-10370]]
    Variables with a type of code:OpTypeFloat and an encoding of
    code:BFloat16KHR must: not be declared with a code:Storage code:Class of
    code:Input or code:Output
  * [[VUID-{refpage}-UniformBufferArrayDynamicIndexing-10127]]
    If the code:UniformBufferArrayDynamicIndexing capability is not
    declared, and an instruction accesses memory through a uniform buffer,
    the uniform buffer through which that memory is accessed must: be
    determined by <<glossary-constant-integral-expression, constant integral
    expressions>>
  * [[VUID-{refpage}-SampledImageArrayDynamicIndexing-10128]]
    If the code:SampledImageArrayDynamicIndexing capability is not declared,
    and an instruction accesses memory through a sampled image or sampler,
    the sampled image or sampler through which that memory is accessed must:
    be determined by <<glossary-constant-integral-expression, constant
    integral expressions>>
  * [[VUID-{refpage}-StorageBufferArrayDynamicIndexing-10129]]
    If the code:StorageBufferArrayDynamicIndexing capability is not
    declared, and an instruction accesses memory through a storage buffer,
    the storage buffer through which that memory is accessed must: be
    determined by <<glossary-constant-integral-expression, constant integral
    expressions>>
  * [[VUID-{refpage}-StorageImageArrayDynamicIndexing-10130]]
    If the code:StorageImageArrayDynamicIndexing capability is not declared,
    and an instruction accesses memory through a storage image, the storage
    image through which that memory is accessed must: be determined by
    <<glossary-constant-integral-expression, constant integral expressions>>
  * [[VUID-{refpage}-InputAttachmentArrayDynamicIndexing-10131]]
    If the code:InputAttachmentArrayDynamicIndexing capability is not
    declared, and an instruction accesses memory through an input
    attachment, the input attachmnet through which that memory is accessed
    must: be determined by <<glossary-constant-integral-expression, constant
    integral expressions>>
  * [[VUID-{refpage}-UniformTexelBufferArrayDynamicIndexing-10132]]
    If the code:UniformTexelBufferArrayDynamicIndexing capability is not
    declared, and an instruction accesses memory through a uniform texel
    buffer, the uniform texel buffer through which that memory is accessed
    must: be determined by <<glossary-constant-integral-expression, constant
    integral expressions>>
  * [[VUID-{refpage}-StorageTexelBufferArrayDynamicIndexing-10133]]
    If the code:StorageTexelBufferArrayDynamicIndexing capability is not
    declared, and an instruction accesses memory through a storage texel
    buffer, the storage texel buffer through which that memory is accessed
    must: be determined by <<glossary-constant-integral-expression, constant
    integral expressions>>
  * [[VUID-{refpage}-TileShadingQCOM-10686]]
    code:TileShadingQCOM capability must: not be enabled in any stage other
    than compute or fragment
  * [[VUID-{refpage}-Execution-10687]]
    code:Execution code:Mode code:NonCoherentTileAttachmentReadQCOM must:
    not be used in any stage other than fragment
  * [[VUID-{refpage}-Execution-10688]]
    code:Execution code:Mode code:TileShadingRateQCOM must: not be used in
    any stage other than compute
  * [[VUID-{refpage}-TileAttachmentQCOM-10689]]
    If the code:TileAttachmentQCOM code:Storage code:Class is used, the
    code:TileShadingQCOM capability must: be enabled
  * [[VUID-{refpage}-NonCoherentTileAttachmentReadQCOM-10690]]
    If the code:NonCoherentTileAttachmentReadQCOM code:Execution code:Mode
    is used, the code:TileShadingQCOM capability must: be enabled
  * [[VUID-{refpage}-TileShadingRateQCOM-10691]]
    If the code:TileShadingRateQCOM code:Execution code:Mode is used, the
    code:TileShadingQCOM capability must: be enabled
  * [[VUID-{refpage}-TileShadingRateQCOM-10692]]
    If the code:TileShadingRateQCOM code:Execution code:Mode is used,
    code:LocalSize and code:LocalSizeId {ExecutionMode} must: not be
    specified
  * [[VUID-{refpage}-OpTypeImage-10693]]
    code:OpTypeImage variables in the code:TileAttachmentQCOM code:Storage
    code:Class must: have code:Dim equal to `2D`
  * [[VUID-{refpage}-OpTypeImage-10694]]
    code:OpTypeImage variables in the code:TileAttachmentQCOM code:Storage
    code:Class must: code:Sampled equal to `1` or `2`
  * [[VUID-{refpage}-TileAttachmentQCOM-10695]]
    Any variable in the code:TileAttachmentQCOM code:Storage code:Class
    must: be decorated with code:DescriptorSet and code:Binding
  * [[VUID-{refpage}-TileAttachmentQCOM-10696]]
    Any variable in the code:TileAttachmentQCOM code:Storage code:Class
    must: not be decorated with code:Component decoration
  * [[VUID-{refpage}-TileAttachmentQCOM-10697]]
    An OpTypeImage variables in the code:TileAttachmentQCOM code:Storage
    code:Class must: not be consumed by an code:OpImageQuery* instruction
  * [[VUID-{refpage}-OpTypeFloat-10823]]
    Variables with a type of code:OpTypeFloat and an encoding of
    code:Float8E4M3EXT or code:Float8E5M2EXT must: not be declared with a
    code:Storage code:Class of code:Input or code:Output
  * [[VUID-{refpage}-OpGraphInputARM-09931]]
    The code:InputIndex and code:ElementIndex operands to
    code:OpGraphInputARM must: be the <id> of a constant instruction
  * [[VUID-{refpage}-OpGraphSetOutputARM-09932]]
    The code:OutputIndex and code:ElementIndex operands to
    code:OpGraphSetOutputARM must: be the <id> of a constant instruction
****
--


[[spirvenv-module-validation-runtime]]
=== Runtime SPIR-V Validation

[open,refpage='RuntimeSpirv',desc='Runtime SPIR-V Validation',type='spirv']
--
:refpage: RuntimeSpirv

The following rules must: be validated at runtime.
These rules depend on knowledge of the implementation and its capabilities
and knowledge of runtime information, such as enabled features.

.Valid Usage
****
ifdef::VK_VERSION_1_2,VK_KHR_vulkan_memory_model[]
  * [[VUID-{refpage}-vulkanMemoryModel-06265]]
    If the <<features-vulkanMemoryModel, pname:vulkanMemoryModel>> feature
    is enabled and the <<features-vulkanMemoryModelDeviceScope,
    pname:vulkanMemoryModelDeviceScope>> feature is not enabled, code:Device
    memory scope must: not be used
  * [[VUID-{refpage}-vulkanMemoryModel-06266]]
    If the <<features-vulkanMemoryModel, pname:vulkanMemoryModel>> feature
    is not enabled, code:QueueFamily memory scope must: not be used
endif::VK_VERSION_1_2,VK_KHR_vulkan_memory_model[]
ifdef::VK_KHR_shader_clock[]
  * [[VUID-{refpage}-shaderSubgroupClock-06267]]
    If the <<features-shaderSubgroupClock, pname:shaderSubgroupClock>>
    feature is not enabled, the code:Subgroup scope must: not be used for
    code:OpReadClockKHR
  * [[VUID-{refpage}-shaderDeviceClock-06268]]
    If the <<features-shaderDeviceClock, pname:shaderDeviceClock>> feature
    is not enabled, the code:Device scope must: not be used for
    code:OpReadClockKHR
endif::VK_KHR_shader_clock[]
ifdef::VK_KHR_shader_relaxed_extended_instruction[]
  * [[VUID-{refpage}-shaderRelaxedExtendedInstruction-10773]]
    If the <<features-shaderRelaxedExtendedInstruction,
    pname:shaderRelaxedExtendedInstruction>> feature is not enabled, the
    code:OpExtInstWithForwardRefsKHR must: not be used
endif::VK_KHR_shader_relaxed_extended_instruction[]
ifndef::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
  * [[VUID-{refpage}-OpTypeImage-06269]]
    If the <<features-shaderStorageImageWriteWithoutFormat,
    pname:shaderStorageImageWriteWithoutFormat>> feature is not enabled, any
    variable created with a "`Type`" of code:OpTypeImage that has a
    "`Sampled`" operand of 2 and an "`Image Format`" operand of code:Unknown
    must: be decorated with code:NonWritable
  * [[VUID-{refpage}-OpTypeImage-06270]]
    If the <<features-shaderStorageImageReadWithoutFormat,
    pname:shaderStorageImageReadWithoutFormat>> feature is not enabled, any
    variable created with a "`Type`" of code:OpTypeImage that has a
    "`Sampled`" operand of 2 and an "`Image Format`" operand of code:Unknown
    must: be decorated with code:NonReadable
endif::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
  * [[VUID-{refpage}-None-09558]]
    {empty}
ifdef::VK_VERSION_1_4,VK_KHR_dynamic_rendering_local_read[]
    If the <<features-dynamicRenderingLocalRead,
    pname:dynamicRenderingLocalRead>> feature is not enabled, any
endif::VK_VERSION_1_4,VK_KHR_dynamic_rendering_local_read[]
ifndef::VK_VERSION_1_4,VK_KHR_dynamic_rendering_local_read[Any]
    variable created with a "`Type`" of code:OpTypeImage that has a "`Dim`"
    operand of code:SubpassData must: be decorated with
    code:InputAttachmentIndex
ifdef::VK_VERSION_1_4,VK_KHR_dynamic_rendering_local_read[]
  * [[VUID-{refpage}-OpTypeImage-09644]]
    Any variable declared as an code:OpTypeArray where the code:Element
    code:Type is an code:OpTypeImage with a "`Dim`" operand of
    code:SubpassData must: be decorated with code:InputAttachmentIndex
endif::VK_VERSION_1_4,VK_KHR_dynamic_rendering_local_read[]
ifdef::VK_VERSION_1_3[]
ifndef::VK_KHR_format_feature_flags2[]
  * [[VUID-{refpage}-apiVersion-07952]]
    If slink:VkPhysicalDeviceProperties::pname:apiVersion is less than
    Vulkan 1.3, and the <<features-shaderStorageImageWriteWithoutFormat,
    pname:shaderStorageImageWriteWithoutFormat>> feature is not enabled, any
    variable created with a "`Type`" of code:OpTypeImage that has a
    "`Sampled`" operand of 2 and an "`Image Format`" operand of code:Unknown
    must: be decorated with code:NonWritable
  * [[VUID-{refpage}-apiVersion-07953]]
    If slink:VkPhysicalDeviceProperties::pname:apiVersion is less than
    Vulkan 1.3, and the <<features-shaderStorageImageReadWithoutFormat,
    pname:shaderStorageImageReadWithoutFormat>> feature is not enabled, any
    variable created with a "`Type`" of code:OpTypeImage that has a
    "`Sampled`" operand of 2 and an "`Image Format`" operand of code:Unknown
    must: be decorated with code:NonReadable
endif::VK_KHR_format_feature_flags2[]
ifdef::VK_KHR_format_feature_flags2[]
  * [[VUID-{refpage}-apiVersion-07954]]
    If slink:VkPhysicalDeviceProperties::pname:apiVersion is less than
    Vulkan 1.3, the apiext:VK_KHR_format_feature_flags2 extension is not
    supported, and the <<features-shaderStorageImageWriteWithoutFormat,
    pname:shaderStorageImageWriteWithoutFormat>> feature is not enabled, any
    variable created with a "`Type`" of code:OpTypeImage that has a
    "`Sampled`" operand of 2 and an "`Image Format`" operand of code:Unknown
    must: be decorated with code:NonWritable
  * [[VUID-{refpage}-apiVersion-07955]]
    If slink:VkPhysicalDeviceProperties::pname:apiVersion is less than
    Vulkan 1.3, the apiext:VK_KHR_format_feature_flags2 extension is not
    supported, and the <<features-shaderStorageImageReadWithoutFormat,
    pname:shaderStorageImageReadWithoutFormat>> feature is not enabled, any
    variable created with a "`Type`" of code:OpTypeImage that has a
    "`Sampled`" operand of 2 and an "`Image Format`" operand of code:Unknown
    must: be decorated with code:NonReadable
endif::VK_KHR_format_feature_flags2[]
endif::VK_VERSION_1_3[]
ifdef::VK_KHR_format_feature_flags2[]
ifndef::VK_VERSION_1_3[]
  * [[VUID-{refpage}-shaderStorageImageWriteWithoutFormat-07956]]
    If the apiext:VK_KHR_format_feature_flags2 extension is not enabled, and
    the <<features-shaderStorageImageWriteWithoutFormat,
    pname:shaderStorageImageWriteWithoutFormat>> feature is not enabled, any
    variable created with a "`Type`" of code:OpTypeImage that has a
    "`Sampled`" operand of 2 and an "`Image Format`" operand of code:Unknown
    must: be decorated with code:NonWritable
  * [[VUID-{refpage}-shaderStorageImageReadWithoutFormat-07957]]
    If the apiext:VK_KHR_format_feature_flags2 extension is not enabled, and
    the <<features-shaderStorageImageReadWithoutFormat,
    pname:shaderStorageImageReadWithoutFormat>> feature is not enabled, any
    variable created with a "`Type`" of code:OpTypeImage that has a
    "`Sampled`" operand of 2 and an "`Image Format`" operand of code:Unknown
    must: be decorated with code:NonReadable
endif::VK_VERSION_1_3[]
endif::VK_KHR_format_feature_flags2[]
  * [[VUID-{refpage}-OpImageWrite-07112]]
    code:OpImageWrite to any code:Image whose code:Image code:Format is not
    code:Unknown must: have the code:Texel operand contain at least as many
    components as the corresponding elink:VkFormat as given in the
    <<spirvenv-image-formats,SPIR-V Image Format compatibility table>>
  * [[VUID-{refpage}-Location-06272]]
    The sum of code:Location and the number of locations the variable it
    decorates consumes must: be less than or equal to the value for the
    matching {ExecutionModel} defined in <<interfaces-iointerfaces-limits>>
  * [[VUID-{refpage}-Location-06428]]
    The maximum number of storage buffers, storage images, and output
    code:Location decorated color attachments written to in the
    code:Fragment {ExecutionModel} must: be less than or equal to
    <<limits-maxFragmentCombinedOutputResources,
    pname:maxFragmentCombinedOutputResources>>
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  * [[VUID-{refpage}-UniformBufferArrayNonUniformIndexing-10134]]
    If the code:UniformBufferArrayNonUniformIndexing capability is not
    declared, and an instruction accesses memory through a uniform buffer,
    the uniform buffer through which that memory is accessed must: be
    dynamically uniform within the invocation group
ifdef::VK_VERSION_1_1[]
    or subgroup
endif::VK_VERSION_1_1[]
  * [[VUID-{refpage}-SampledImageArrayNonUniformIndexing-10135]]
    If the code:SampledImageArrayNonUniformIndexing capability is not
    declared, and an instruction accesses memory through a sampled image or
    sampler, the sampled image or sampler through which that memory is
    accessed must: be dynamically uniform within the invocation group
ifdef::VK_VERSION_1_1[]
    or subgroup
endif::VK_VERSION_1_1[]
  * [[VUID-{refpage}-StorageBufferArrayNonUniformIndexing-10136]]
    If the code:StorageBufferArrayNonUniformIndexing capability is not
    declared, and an instruction accesses memory through a storage buffer,
    the storage buffer through which that memory is accessed must: be
    dynamically uniform within the invocation group
ifdef::VK_VERSION_1_1[]
    or subgroup
endif::VK_VERSION_1_1[]
  * [[VUID-{refpage}-StorageImageArrayNonUniformIndexing-10137]]
    If the code:StorageImageArrayNonUniformIndexing capability is not
    declared, and an instruction accesses memory through a storage image,
    the storage image through which that memory is accessed must: be
    dynamically uniform within the invocation group
ifdef::VK_VERSION_1_1[]
    or subgroup
endif::VK_VERSION_1_1[]
  * [[VUID-{refpage}-InputAttachmentArrayNonUniformIndexing-10138]]
    If the code:InputAttachmentArrayNonUniformIndexing capability is not
    declared, and an instruction accesses memory through an input
    attachment, the input attachment through which that memory is accessed
    must: be dynamically uniform within the invocation group
ifdef::VK_VERSION_1_1[]
    or subgroup
endif::VK_VERSION_1_1[]
  * [[VUID-{refpage}-UniformTexelBufferArrayNonUniformIndexing-10139]]
    If the code:UniformTexelBufferArrayNonUniformIndexing capability is not
    declared, and an instruction accesses memory through a uniform texel
    buffer, the uniform texel buffer through which that memory is accessed
    must: be dynamically uniform within the invocation group
ifdef::VK_VERSION_1_1[]
    or subgroup
endif::VK_VERSION_1_1[]
  * [[VUID-{refpage}-StorageTexelBufferArrayNonUniformIndexing-10140]]
    If the code:StorageTexelBufferArrayNonUniformIndexing capability is not
    declared, and an instruction accesses memory through a storage texel
    buffer, the storage texel buffer through which that memory is accessed
    must: be dynamically uniform within the invocation group
ifdef::VK_VERSION_1_1[]
    or subgroup
endif::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-{refpage}-subgroupSize-10141]]
    If the <<interfaces-builtin-variables-sgs,effective subgroup size>> is
    1, the code:UniformBufferArrayNonUniformIndexing capability is not
    declared, and an instruction accesses memory through a uniform buffer,
    the uniform buffer through which that memory is accessed must: be
    dynamically uniform within the invocation group
  * [[VUID-{refpage}-subgroupSize-10142]]
    If the <<interfaces-builtin-variables-sgs,effective subgroup size>> is
    1, the code:SampledImageArrayNonUniformIndexing capability is not
    declared, and an instruction accesses memory through a sampled image or
    sampler, the sampled image or sampler through which that memory is
    accessed must: be dynamically uniform within the invocation group
  * [[VUID-{refpage}-subgroupSize-10143]]
    If the <<interfaces-builtin-variables-sgs,effective subgroup size>> is
    1, the code:StorageBufferArrayNonUniformIndexing capability is not
    declared, and an instruction accesses memory through a storage buffer,
    the storage buffer through which that memory is accessed must: be
    dynamically uniform within the invocation group
  * [[VUID-{refpage}-subgroupSize-10144]]
    If the <<interfaces-builtin-variables-sgs,effective subgroup size>> is
    1, the code:StorageImageArrayNonUniformIndexing capability is not
    declared, and an instruction accesses memory through a storage image,
    the storage image through which that memory is accessed must: be
    dynamically uniform within the invocation group
  * [[VUID-{refpage}-subgroupSize-10145]]
    If the <<interfaces-builtin-variables-sgs,effective subgroup size>> is
    1, the code:InputAttachmentArrayNonUniformIndexing capability is not
    declared, and an instruction accesses memory through an input
    attachment, the input attachment through which that memory is accessed
    must: be dynamically uniform within the invocation group
  * [[VUID-{refpage}-subgroupSize-10146]]
    If the <<interfaces-builtin-variables-sgs,effective subgroup size>> is
    1, the code:UniformTexelBufferArrayNonUniformIndexing capability is not
    declared, and an instruction accesses memory through a uniform texel
    buffer, the uniform texel buffer through which that memory is accessed
    must: be dynamically uniform within the invocation group
  * [[VUID-{refpage}-subgroupSize-10147]]
    If the <<interfaces-builtin-variables-sgs,effective subgroup size>> is
    1, the code:StorageTexelBufferArrayNonUniformIndexing capability is not
    is not declared, and an instruction accesses memory through a storage
    texel buffer, the storage texel buffer through which that memory is
    accessed must: be dynamically uniform within the invocation group
endif::VK_VERSION_1_1[]
  * [[VUID-{refpage}-None-10148]]
    If an instruction accesses memory through any resource,
ifdef::VK_VERSION_1_1[]
    the <<interfaces-builtin-variables-sgs,effective subgroup size>> is 1,
endif::VK_VERSION_1_1[]
    and the resource through which that memory is accessed is not uniform
    within the invocation group, then the operand corresponding to that
    resource (e.g. the pointer or sampled image operand) must: be decorated
    with code:NonUniform
ifdef::VK_VERSION_1_1[]
  * [[VUID-{refpage}-subgroupSize-10149]]
    If an instruction accesses memory through any resource, the
    <<interfaces-builtin-variables-sgs, effective subgroup size>> is greater
    than 1, and the resource through which that memory is accessed is not
    uniform within the invocation group, and not uniform within the
    subgroup, then the operand corresponding to that resource (e.g. the
    pointer or sampled image operand) must: be decorated with
    code:NonUniform
endif::VK_VERSION_1_1[]
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
ifdef::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]
  * [[VUID-{refpage}-None-06275]]
    <<features-shaderSubgroupExtendedTypes,
    pname:shaderSubgroupExtendedTypes>> must: be enabled for
    <<shaders-group-operations,group operations>> to use 8-bit integer,
    16-bit integer, 64-bit integer, 16-bit floating-point, and vectors of
    these types
endif::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]
endif::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_2[]
  * [[VUID-{refpage}-subgroupBroadcastDynamicId-06276]]
    If <<features-subgroupBroadcastDynamicId,
    pname:subgroupBroadcastDynamicId>> is ename:VK_TRUE, and the shader
    module version is 1.5 or higher, the "`Index`" for
    code:OpGroupNonUniformQuadBroadcast must: be dynamically uniform within
    the derivative group.
    Otherwise, "`Index`" must: be a constant
  * [[VUID-{refpage}-subgroupBroadcastDynamicId-06277]]
    If <<features-subgroupBroadcastDynamicId,
    pname:subgroupBroadcastDynamicId>> is ename:VK_TRUE, and the shader
    module version is 1.5 or higher, the "`Id`" for
    code:OpGroupNonUniformBroadcast must: be dynamically uniform within the
    subgroup.
    Otherwise, "`Id`" must: be a constant
endif::VK_VERSION_1_2[]
ifdef::VK_KHR_shader_atomic_int64[]
  * [[VUID-{refpage}-None-06278]]
    <<features-shaderBufferInt64Atomics, pname:shaderBufferInt64Atomics>>
    must: be enabled for 64-bit integer atomic operations to be supported on
    a _Pointer_ with a {StorageClass} of code:StorageBuffer or code:Uniform
  * [[VUID-{refpage}-None-06279]]
    <<features-shaderSharedInt64Atomics, pname:shaderSharedInt64Atomics>>
    must: be enabled for 64-bit integer atomic operations to be supported on
    a _Pointer_ with a {StorageClass} of code:Workgroup
endif::VK_KHR_shader_atomic_int64[]
ifdef::VK_EXT_shader_atomic_float,VK_EXT_shader_atomic_float2[]
  * [[VUID-{refpage}-None-06284]]
    <<features-shaderBufferFloat32Atomics,
    pname:shaderBufferFloat32Atomics>>, or
    <<features-shaderBufferFloat32AtomicAdd,
    pname:shaderBufferFloat32AtomicAdd>>, or
    <<features-shaderBufferFloat64Atomics,
    pname:shaderBufferFloat64Atomics>>, or
    <<features-shaderBufferFloat64AtomicAdd,
    pname:shaderBufferFloat64AtomicAdd>>,
ifdef::VK_EXT_shader_atomic_float2[]
    or <<features-shaderBufferFloat16AtomicMinMax,
    pname:shaderBufferFloat16Atomics>>, or
    <<features-shaderBufferFloat16AtomicMinMax,
    pname:shaderBufferFloat16AtomicAdd>>, or
    <<features-shaderBufferFloat16AtomicMinMax,
    pname:shaderBufferFloat16AtomicMinMax>>, or
    <<features-shaderBufferFloat32AtomicMinMax,
    pname:shaderBufferFloat32AtomicMinMax>>, or
    <<features-shaderBufferFloat64AtomicMinMax,
    pname:shaderBufferFloat64AtomicMinMax>>,
endif::VK_EXT_shader_atomic_float2[]
ifdef::VK_NV_shader_atomic_float16_vector[]
    or <<features-shaderFloat16VectorAtomics,
    pname:shaderFloat16VectorAtomics>>
endif::VK_NV_shader_atomic_float16_vector[]
    must: be enabled for floating-point atomic operations to be supported on
    a _Pointer_ with a {StorageClass} of code:StorageBuffer
  * [[VUID-{refpage}-None-06285]]
    <<features-shaderSharedFloat32Atomics,
    pname:shaderSharedFloat32Atomics>>, or
    <<features-shaderSharedFloat32AtomicAdd,
    pname:shaderSharedFloat32AtomicAdd>>, or
    <<features-shaderSharedFloat64Atomics,
    pname:shaderSharedFloat64Atomics>>, or
    <<features-shaderSharedFloat64AtomicAdd,
    pname:shaderSharedFloat64AtomicAdd>>,
ifdef::VK_EXT_shader_atomic_float2[]
    or <<features-shaderBufferFloat16AtomicMinMax,
    pname:shaderSharedFloat16Atomics>>, or
    <<features-shaderBufferFloat16AtomicMinMax,
    pname:shaderSharedFloat16AtomicAdd>>, or
    <<features-shaderBufferFloat16AtomicMinMax,
    pname:shaderSharedFloat16AtomicMinMax>>, or
    <<features-shaderSharedFloat32AtomicMinMax,
    pname:shaderSharedFloat32AtomicMinMax>>, or
    <<features-shaderSharedFloat64AtomicMinMax,
    pname:shaderSharedFloat64AtomicMinMax>>,
endif::VK_EXT_shader_atomic_float2[]
ifdef::VK_NV_shader_atomic_float16_vector[]
    or <<features-shaderFloat16VectorAtomics,
    pname:shaderFloat16VectorAtomics>>,
endif::VK_NV_shader_atomic_float16_vector[]
    must: be enabled for floating-point atomic operations to be supported on
    a _Pointer_ with a {StorageClass} of code:Workgroup
  * [[VUID-{refpage}-None-06286]]
    <<features-shaderImageFloat32Atomics, pname:shaderImageFloat32Atomics>>,
    or <<features-shaderImageFloat32AtomicAdd,
    pname:shaderImageFloat32AtomicAdd>>,
ifdef::VK_EXT_shader_atomic_float2[]
    or <<features-shaderImageFloat32AtomicMinMax,
    pname:shaderImageFloat32AtomicMinMax>>,
endif::VK_EXT_shader_atomic_float2[]
    must: be enabled for 32-bit floating-point atomic operations to be
    supported on a _Pointer_ with a {StorageClass} of code:Image
  * [[VUID-{refpage}-None-06287]]
    <<features-sparseImageFloat32Atomics, pname:sparseImageFloat32Atomics>>,
    or <<features-sparseImageFloat32AtomicAdd,
    pname:sparseImageFloat32AtomicAdd>>,
ifdef::VK_EXT_shader_atomic_float2[]
    or <<features-sparseImageFloat32AtomicMinMax,
    pname:sparseImageFloat32AtomicMinMax>>,
endif::VK_EXT_shader_atomic_float2[]
    must: be enabled for 32-bit floating-point atomics to be supported on
    sparse images
endif::VK_EXT_shader_atomic_float,VK_EXT_shader_atomic_float2[]
ifdef::VK_EXT_shader_image_atomic_int64[]
  * [[VUID-{refpage}-None-06288]]
    <<features-shaderImageInt64Atomics, pname:shaderImageInt64Atomics>>
    must: be enabled for 64-bit integer atomic operations to be supported on
    a _Pointer_ with a {StorageClass} of code:Image
endif::VK_EXT_shader_image_atomic_int64[]
ifdef::VK_VERSION_1_2,VK_KHR_shader_float_controls[]
  * [[VUID-{refpage}-denormBehaviorIndependence-06289]]
    If <<features-denormBehaviorIndependence,
    pname:denormBehaviorIndependence>> is
    ename:VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY, then the entry
    point must: use the same denormals {ExecutionMode} for both 16-bit and
    64-bit floating-point types
  * [[VUID-{refpage}-denormBehaviorIndependence-06290]]
    If <<features-denormBehaviorIndependence,
    pname:denormBehaviorIndependence>> is
    ename:VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE, then the entry point
    must: use the same denormals {ExecutionMode} for all floating-point
    types
  * [[VUID-{refpage}-roundingModeIndependence-06291]]
    If <<features-roundingModeIndependence, pname:roundingModeIndependence>>
    is ename:VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY, then the
    entry point must: use the same rounding {ExecutionMode} for both 16-bit
    and 64-bit floating-point types
  * [[VUID-{refpage}-roundingModeIndependence-06292]]
    If <<features-roundingModeIndependence, pname:roundingModeIndependence>>
    is ename:VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE, then the entry
    point must: use the same rounding {ExecutionMode} for all floating-point
    types
  * [[VUID-{refpage}-shaderSignedZeroInfNanPreserveFloat16-06293]]
    If <<limits-shaderSignedZeroInfNanPreserveFloat16,
    pname:shaderSignedZeroInfNanPreserveFloat16>> is ename:VK_FALSE, then
    code:SignedZeroInfNanPreserve for 16-bit floating-point type must: not
    be used
  * [[VUID-{refpage}-shaderSignedZeroInfNanPreserveFloat32-06294]]
    If <<limits-shaderSignedZeroInfNanPreserveFloat32,
    pname:shaderSignedZeroInfNanPreserveFloat32>> is ename:VK_FALSE, then
    code:SignedZeroInfNanPreserve for 32-bit floating-point type must: not
    be used
  * [[VUID-{refpage}-shaderSignedZeroInfNanPreserveFloat64-06295]]
    If <<limits-shaderSignedZeroInfNanPreserveFloat64,
    pname:shaderSignedZeroInfNanPreserveFloat64>> is ename:VK_FALSE, then
    code:SignedZeroInfNanPreserve for 64-bit floating-point type must: not
    be used
  * [[VUID-{refpage}-shaderDenormPreserveFloat16-06296]]
    If <<limits-shaderDenormPreserveFloat16,
    pname:shaderDenormPreserveFloat16>> is ename:VK_FALSE, then
    code:DenormPreserve for 16-bit floating-point type must: not be used
  * [[VUID-{refpage}-shaderDenormPreserveFloat32-06297]]
    If <<limits-shaderDenormPreserveFloat32,
    pname:shaderDenormPreserveFloat32>> is ename:VK_FALSE, then
    code:DenormPreserve for 32-bit floating-point type must: not be used
  * [[VUID-{refpage}-shaderDenormPreserveFloat64-06298]]
    If <<limits-shaderDenormPreserveFloat64,
    pname:shaderDenormPreserveFloat64>> is ename:VK_FALSE, then
    code:DenormPreserve for 64-bit floating-point type must: not be used
  * [[VUID-{refpage}-shaderDenormFlushToZeroFloat16-06299]]
    If <<limits-shaderDenormFlushToZeroFloat16,
    pname:shaderDenormFlushToZeroFloat16>> is ename:VK_FALSE, then
    code:DenormFlushToZero for 16-bit floating-point type must: not be used
  * [[VUID-{refpage}-shaderDenormFlushToZeroFloat32-06300]]
    If <<limits-shaderDenormFlushToZeroFloat32,
    pname:shaderDenormFlushToZeroFloat32>> is ename:VK_FALSE, then
    code:DenormFlushToZero for 32-bit floating-point type must: not be used
  * [[VUID-{refpage}-shaderDenormFlushToZeroFloat64-06301]]
    If <<limits-shaderDenormFlushToZeroFloat64,
    pname:shaderDenormFlushToZeroFloat64>> is ename:VK_FALSE, then
    code:DenormFlushToZero for 64-bit floating-point type must: not be used
  * [[VUID-{refpage}-shaderRoundingModeRTEFloat16-06302]]
    If <<limits-shaderRoundingModeRTEFloat16,
    pname:shaderRoundingModeRTEFloat16>> is ename:VK_FALSE, then
    code:RoundingModeRTE for 16-bit floating-point type must: not be used
  * [[VUID-{refpage}-shaderRoundingModeRTEFloat32-06303]]
    If <<limits-shaderRoundingModeRTEFloat32,
    pname:shaderRoundingModeRTEFloat32>> is ename:VK_FALSE, then
    code:RoundingModeRTE for 32-bit floating-point type must: not be used
  * [[VUID-{refpage}-shaderRoundingModeRTEFloat64-06304]]
    If <<limits-shaderRoundingModeRTEFloat64,
    pname:shaderRoundingModeRTEFloat64>> is ename:VK_FALSE, then
    code:RoundingModeRTE for 64-bit floating-point type must: not be used
  * [[VUID-{refpage}-shaderRoundingModeRTZFloat16-06305]]
    If <<limits-shaderRoundingModeRTZFloat16,
    pname:shaderRoundingModeRTZFloat16>> is ename:VK_FALSE, then
    code:RoundingModeRTZ for 16-bit floating-point type must: not be used
  * [[VUID-{refpage}-shaderRoundingModeRTZFloat32-06306]]
    If <<limits-shaderRoundingModeRTZFloat32,
    pname:shaderRoundingModeRTZFloat32>> is ename:VK_FALSE, then
    code:RoundingModeRTZ for 32-bit floating-point type must: not be used
  * [[VUID-{refpage}-shaderRoundingModeRTZFloat64-06307]]
    If <<limits-shaderRoundingModeRTZFloat64,
    pname:shaderRoundingModeRTZFloat64>> is ename:VK_FALSE, then
    code:RoundingModeRTZ for 64-bit floating-point type must: not be used
endif::VK_VERSION_1_2,VK_KHR_shader_float_controls[]
ifdef::VK_VERSION_1_4,VK_KHR_shader_float_controls2[]
  * [[VUID-{refpage}-shaderSignedZeroInfNanPreserveFloat16-09559]]
    If <<limits-shaderSignedZeroInfNanPreserveFloat16,
    pname:shaderSignedZeroInfNanPreserveFloat16>> is ename:VK_FALSE then any
    code:FPFastMathDefault execution mode with a type of 16-bit float must:
    include the code:NSZ, code:NotInf, and code:NotNaN flags
  * [[VUID-{refpage}-shaderSignedZeroInfNanPreserveFloat16-09560]]
    If <<limits-shaderSignedZeroInfNanPreserveFloat16,
    pname:shaderSignedZeroInfNanPreserveFloat16>> is ename:VK_FALSE then any
    code:FPFastMathMode decoration on an instruction with result type or any
    operand type that includes a 16-bit float must: include the code:NSZ,
    code:NotInf, and code:NotNaN flags
  * [[VUID-{refpage}-shaderSignedZeroInfNanPreserveFloat32-09561]]
    If <<limits-shaderSignedZeroInfNanPreserveFloat32,
    pname:shaderSignedZeroInfNanPreserveFloat32>> is ename:VK_FALSE then any
    code:FPFastMathDefault execution mode with a type of 32-bit float must:
    include the code:NSZ, code:NotInf, and code:NotNaN flags
  * [[VUID-{refpage}-shaderSignedZeroInfNanPreserveFloat32-09562]]
    If <<limits-shaderSignedZeroInfNanPreserveFloat32,
    pname:shaderSignedZeroInfNanPreserveFloat32>> is ename:VK_FALSE then any
    code:FPFastMathMode decoration on an instruction with result type or any
    operand type that includes a 32-bit float must: include the code:NSZ,
    code:NotInf, and code:NotNaN flags
  * [[VUID-{refpage}-shaderSignedZeroInfNanPreserveFloat64-09563]]
    If <<limits-shaderSignedZeroInfNanPreserveFloat64,
    pname:shaderSignedZeroInfNanPreserveFloat64>> is ename:VK_FALSE then any
    code:FPFastMathDefault execution mode with a type of 64-bit float must:
    include the code:NSZ, code:NotInf, and code:NotNaN flags
  * [[VUID-{refpage}-shaderSignedZeroInfNanPreserveFloat64-09564]]
    If <<limits-shaderSignedZeroInfNanPreserveFloat64,
    pname:shaderSignedZeroInfNanPreserveFloat64>> is ename:VK_FALSE then any
    code:FPFastMathMode decoration on an instruction with result type or any
    operand type that includes a 64-bit float must: include the code:NSZ,
    code:NotInf, and code:NotNaN flags
endif::VK_VERSION_1_4,VK_KHR_shader_float_controls2[]
ifdef::VK_EXT_transform_feedback[]
  * [[VUID-{refpage}-Offset-06308]]
    The code:Offset plus size of the type of each variable, in the output
    interface of the entry point being compiled, decorated with
    code:XfbBuffer must: not be greater than
    slink:VkPhysicalDeviceTransformFeedbackPropertiesEXT::pname:maxTransformFeedbackBufferDataSize
  * [[VUID-{refpage}-XfbBuffer-06309]]
    For any given code:XfbBuffer value, define the buffer data size to be
    smallest number of bytes such that, for all outputs decorated with the
    same code:XfbBuffer value, the size of the output interface variable
    plus the code:Offset is less than or equal to the buffer data size.
    For a given code:Stream, the sum of all the buffer data sizes for all
    buffers writing to that stream the must: not exceed
    slink:VkPhysicalDeviceTransformFeedbackPropertiesEXT::pname:maxTransformFeedbackStreamDataSize
  * [[VUID-{refpage}-OpEmitStreamVertex-06310]]
    The Stream value to code:OpEmitStreamVertex and
    code:OpEndStreamPrimitive must: be less than
    slink:VkPhysicalDeviceTransformFeedbackPropertiesEXT::pname:maxTransformFeedbackStreams
  * [[VUID-{refpage}-transformFeedbackStreamsLinesTriangles-06311]]
    If the geometry shader emits to more than one vertex stream and
    slink:VkPhysicalDeviceTransformFeedbackPropertiesEXT::pname:transformFeedbackStreamsLinesTriangles
    is ename:VK_FALSE, then {ExecutionMode} must: be code:OutputPoints
  * [[VUID-{refpage}-Stream-06312]]
    The stream number value to code:Stream must: be less than
    slink:VkPhysicalDeviceTransformFeedbackPropertiesEXT::pname:maxTransformFeedbackStreams
  * [[VUID-{refpage}-XfbStride-06313]]
    The XFB Stride value to code:XfbStride must: be less than or equal to
    slink:VkPhysicalDeviceTransformFeedbackPropertiesEXT::pname:maxTransformFeedbackBufferDataStride
endif::VK_EXT_transform_feedback[]
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
  * [[VUID-{refpage}-PhysicalStorageBuffer64-06315]]
    If the code:PhysicalStorageBuffer64 addressing model is enabled the
    pointer value of a memory access instruction must: be at least as
    aligned as specified by the code:Aligned memory access operand
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
ifdef::VK_NV_cooperative_matrix[]
  * [[VUID-{refpage}-OpTypeCooperativeMatrixNV-06316]]
    For code:OpTypeCooperativeMatrixNV, the component type, scope, number of
    rows, and number of columns must: match one of the matrices in any of
    the supported slink:VkCooperativeMatrixPropertiesNV
  * [[VUID-{refpage}-OpTypeCooperativeMatrixMulAddNV-10059]]
    For code:OpTypeCooperativeMatrixMulAddNV, the operands must: match a
    supported slink:VkCooperativeMatrixPropertiesNV, such that:
  ** The type of code:A must: have code:Rows match
     slink:VkCooperativeMatrixPropertiesNV::pname:MSize, code:Columns match
     slink:VkCooperativeMatrixPropertiesNV::pname:KSize, and
     code:ComponentType match
     slink:VkCooperativeMatrixPropertiesNV::pname:AType.
  ** The type of code:B must: have code:Rows match
     slink:VkCooperativeMatrixPropertiesNV::pname:KSize, code:Columns match
     slink:VkCooperativeMatrixPropertiesNV::pname:NSize, and
     code:ComponentType match
     slink:VkCooperativeMatrixPropertiesNV::pname:BType.
  ** The type of code:C must: have code:Rows match
     slink:VkCooperativeMatrixPropertiesNV::pname:MSize, code:Columns match
     slink:VkCooperativeMatrixPropertiesNV::pname:NSize, and
     code:ComponentType match
     slink:VkCooperativeMatrixPropertiesNV::pname:CType.
  ** The type of code:Result must: have code:Rows match
     slink:VkCooperativeMatrixPropertiesNV::pname:MSize, code:Columns match
     slink:VkCooperativeMatrixPropertiesNV::pname:NSize, and
     code:ComponentType match
     slink:VkCooperativeMatrixPropertiesNV::pname:DType.
  ** The scope of all cooperative matrix operands must: be
     elink:VkScopeNV::ename:VK_SCOPE_SUBGROUP_NV.
  ** If code:ComponentType of code:A, code:B, code:C, or code:Result is a
     signed integral type, the code:Signedness operand of the code:OpTypeInt
     must be 1.
  ** If code:ComponentType of code:A, code:B, code:C, or code:Result is an
     unsigned integral type, the code:Signedness operand of the
     code:OpTypeInt must be 0
  * [[VUID-{refpage}-OpTypeCooperativeMatrixNV-06322]]
    code:OpTypeCooperativeMatrixNV and code:OpCooperativeMatrix*
    instructions must: not be used in shader stages not included in
    slink:VkPhysicalDeviceCooperativeMatrixPropertiesNV::pname:cooperativeMatrixSupportedStages
endif::VK_NV_cooperative_matrix[]
ifdef::VK_KHR_cooperative_matrix[]
  * [[VUID-{refpage}-OpTypeCooperativeMatrixKHR-10163]]
    For code:OpTypeCooperativeMatrixKHR,
ifdef::VK_NV_cooperative_matrix2[]
    if the <<features-cooperativeMatrixFlexibleDimensions,
    pname:cooperativeMatrixFlexibleDimensions>> feature is not enabled,
endif::VK_NV_cooperative_matrix2[]
    the component type, scope, number of rows, and number of columns must:
    match one of the matrices in any of the supported
    slink:VkCooperativeMatrixPropertiesKHR, where
  ** for code:Use of code:MatrixA, the number of rows must match
     slink:VkCooperativeMatrixPropertiesKHR::pname:MSize and the number of
     columns must match slink:VkCooperativeMatrixPropertiesKHR::pname:KSize
     and the type must: match
     slink:VkCooperativeMatrixPropertiesKHR::pname:AType
  ** for code:Use of code:MatrixB, the number of rows must match
     slink:VkCooperativeMatrixPropertiesKHR::pname:KSize and the number of
     columns must match slink:VkCooperativeMatrixPropertiesKHR::pname:NSize
     and the type must: match
     slink:VkCooperativeMatrixPropertiesKHR::pname:BType
  ** for code:Use of code:MatrixAccumulator, the number of rows must match
     slink:VkCooperativeMatrixPropertiesKHR::pname:MSize and the number of
     columns must match slink:VkCooperativeMatrixPropertiesKHR::pname:NSize
     and the type must: match
     slink:VkCooperativeMatrixPropertiesKHR::pname:CType or
     slink:VkCooperativeMatrixPropertiesKHR::pname:ResultType
  * [[VUID-{refpage}-OpCooperativeMatrixMulAddKHR-10060]]
    For code:OpCooperativeMatrixMulAddKHR,
ifdef::VK_NV_cooperative_matrix2[]
    if the <<features-cooperativeMatrixFlexibleDimensions,
    pname:cooperativeMatrixFlexibleDimensions>> feature is not enabled,
endif::VK_NV_cooperative_matrix2[]
    the operands must: match a supported
    slink:VkCooperativeMatrixPropertiesKHR, such that:
  ** The type of code:A must: have code:Rows match
     slink:VkCooperativeMatrixPropertiesKHR::pname:MSize, code:Columns match
     slink:VkCooperativeMatrixPropertiesKHR::pname:KSize, code:Use be
     code:MatrixAKHR, and code:ComponentType match
     slink:VkCooperativeMatrixPropertiesKHR::pname:AType.
  ** The type of code:B must: have code:Rows match
     slink:VkCooperativeMatrixPropertiesKHR::pname:KSize, code:Columns match
     slink:VkCooperativeMatrixPropertiesKHR::pname:NSize, code:Use be
     code:MatrixBKHR, and code:ComponentType match
     slink:VkCooperativeMatrixPropertiesKHR::pname:BType.
  ** The type of code:C must: have code:Rows match
     slink:VkCooperativeMatrixPropertiesKHR::pname:MSize, code:Columns match
     slink:VkCooperativeMatrixPropertiesKHR::pname:NSize, code:Use be
     code:MatrixAccumulatorKHR, and code:ComponentType match
     slink:VkCooperativeMatrixPropertiesKHR::pname:CType.
  ** The type of code:Result must: have code:Rows match
     slink:VkCooperativeMatrixPropertiesKHR::pname:MSize, code:Columns match
     slink:VkCooperativeMatrixPropertiesKHR::pname:NSize, code:Use be
     code:MatrixAccumulatorKHR, and code:ComponentType match
     slink:VkCooperativeMatrixPropertiesKHR::pname:ResultType.
  ** If and only if slink:VkCooperativeMatrixPropertiesKHR::pname:AType is a
     signed integer type, code:MatrixASignedComponents must: be used.
  ** If and only if slink:VkCooperativeMatrixPropertiesKHR::pname:BType is a
     signed integer type, code:MatrixBSignedComponents must: be used.
  ** If and only if slink:VkCooperativeMatrixPropertiesKHR::pname:CType is a
     signed integer type, code:MatrixCSignedComponents must: be used.
  ** If and only if slink:VkCooperativeMatrixPropertiesKHR::pname:ResultType
     is a signed integer type, code:MatrixResultSignedComponents must: be
     used.
  ** If and only if
     slink:VkCooperativeMatrixPropertiesKHR::pname:saturatingAccumulation is
     ename:VK_TRUE, code:SaturatingAccumulationKHR must: be used.
  ** If and only if
     slink:VkCooperativeMatrixPropertiesKHR::pname:saturatingAccumulation is
     ename:VK_FALSE, code:SaturatingAccumulationKHR must: not be used.
  ** The scope of all cooperative matrix operands must: match
     slink:VkCooperativeMatrixPropertiesKHR::pname:scope.
ifdef::VK_NV_cooperative_matrix2[]
  * [[VUID-{refpage}-cooperativeMatrixWorkgroupScope-10164]]
    If the <<features-cooperativeMatrixWorkgroupScope,
    pname:cooperativeMatrixWorkgroupScope>> feature is not enabled, the
    scope of all code:OpTypeCooperativeMatrixKHR must: not be
    elink:VkScopeKHR::ename:VK_SCOPE_WORKGROUP_KHR
  * [[VUID-{refpage}-cooperativeMatrixFlexibleDimensions-10165]]
    For code:OpTypeCooperativeMatrixKHR, if the
    <<features-cooperativeMatrixFlexibleDimensions,
    pname:cooperativeMatrixFlexibleDimensions>> feature is enabled, the
    component type, scope, number of rows, and number of columns must: match
    either one of the matrices in one of the supported
    slink:VkCooperativeMatrixPropertiesKHR as described above, or one of the
    supported slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV, where
  ** for code:MatrixA, the number of rows must be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:MGranularity
     and the number of columns must be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:KGranularity
     and the type must: match
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:AType
  ** for code:MatrixB, the number of rows must be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:KGranularity
     and the number of columns must be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:NGranularity
     and the type must: match
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:BType
  ** for code:MatrixAccumulator, the number of rows must be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:MGranularity
     and the number of columns must be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:NGranularity
     and the type must: match
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:CType or
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:ResultType
  ** if the scope is ename:VK_SCOPE_WORKGROUP_KHR, the number of invocations
     in the local workgroup must: match
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:workgroupInvocations
  * [[VUID-{refpage}-cooperativeMatrixFlexibleDimensions-10166]]
    For code:OpCooperativeMatrixMulAddKHR, if the
    <<features-cooperativeMatrixFlexibleDimensions,
    pname:cooperativeMatrixFlexibleDimensions>> feature is enabled, the
    operands must: match either one of the supported
    slink:VkCooperativeMatrixPropertiesKHR as described above, or one of the
    supported slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV, such
    that:
  ** The type of code:A must: have code:Rows be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:MGranularity,
     code:Columns be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:KGranularity,
     code:Use be code:MatrixAKHR, and code:ComponentType match
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:AType.
  ** The type of code:B must: have code:Rows be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:KGranularity,
     code:Columns be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:NGranularity,
     code:Use be code:MatrixBKHR, and code:ComponentType match
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:BType.
  ** The type of code:C must: have code:Rows be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:MGranularity,
     code:Columns be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:NGranularity,
     code:Use be code:MatrixAccumulatorKHR, and code:ComponentType match
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:CType.
  ** The type of code:Result must: have code:Rows be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:MGranularity,
     code:Columns be a multiple of
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:NGranularity,
     code:Use be code:MatrixAccumulatorKHR, and code:ComponentType match
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:ResultType.
  ** If and only if
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:AType is
     a signed integer type, code:MatrixASignedComponents must: be used.
  ** If and only if
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:BType is
     a signed integer type, code:MatrixBSignedComponents must: be used.
  ** If and only if
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:CType is
     a signed integer type, code:MatrixCSignedComponents must: be used.
  ** If and only if
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:ResultType
     is a signed integer type, code:MatrixResultSignedComponents must: be
     used.
  ** If and only if
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:saturatingAccumulation
     is ename:VK_TRUE, code:SaturatingAccumulationKHR must: be used.
  ** If and only if
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:saturatingAccumulation
     is ename:VK_FALSE, code:SaturatingAccumulationKHR must: not be used.
  ** The scope of all cooperative matrix operands must: match
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:scope.
  ** If the scope is ename:VK_SCOPE_WORKGROUP_KHR, the number of invocations
     in the local workgroup must: match
     slink:VkCooperativeMatrixFlexibleDimensionsPropertiesNV::pname:workgroupInvocations
  * [[VUID-{refpage}-cooperativeMatrixFlexibleDimensionsMaxDimension-10167]]
    All code:OpTypeCooperativeMatrixKHR dimensions must: be less than or
    equal to
    <<limits-cooperativeMatrixFlexibleDimensionsMaxDimension,pname:cooperativeMatrixFlexibleDimensionsMaxDimension>>
  * [[VUID-{refpage}-maxComputeSharedMemorySize-10168]]
    If the module uses code:OpTypeCooperativeMatrixKHR with code:Scope equal
    to code:Workgroup, the sum of size in bytes for variables and
    <<workgroup-padding, padding>> in the code:Workgroup {StorageClass} in
    the code:GLCompute {ExecutionModel} must: be less than or equal to
    <<limits-maxComputeSharedMemorySize, pname:maxComputeSharedMemorySize>>
    minus
    <<limits-cooperativeMatrixWorkgroupScopeReservedSharedMemory,pname:cooperativeMatrixWorkgroupScopeReservedSharedMemory>>
endif::VK_NV_cooperative_matrix2[]
  * [[VUID-{refpage}-cooperativeMatrixSupportedStages-08985]]
    code:OpTypeCooperativeMatrixKHR and code:OpCooperativeMatrix*
    instructions must: not be used in shader stages not included in
    slink:VkPhysicalDeviceCooperativeMatrixPropertiesKHR::pname:cooperativeMatrixSupportedStages
  * [[VUID-{refpage}-OpTypeCooperativeMatrixKHR-10770]]
    Any pipeline containing a shader with code:OpTypeCooperativeMatrixKHR or
    code:OpCooperativeMatrix*KHR instructions must: be created with the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT flag or
    the shader module must be version 1.6 or greater
  * [[VUID-{refpage}-OpTypeCooperativeMatrixKHR-10771]]
    Any shader object containing code:OpTypeCooperativeMatrixKHR or
    code:OpCooperativeMatrix*KHR instructions must: be created with the
    ename:VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT flag or the shader
    module must be version 1.6 or greater
endif::VK_KHR_cooperative_matrix[]
ifdef::VK_NV_cooperative_matrix[]
  * [[VUID-{refpage}-OpCooperativeMatrixLoadNV-06324]]
    For code:OpCooperativeMatrixLoadNV and code:OpCooperativeMatrixStoreNV
    instructions, the code:Pointer and code:Stride operands must: be aligned
    to at least the lesser of 16 bytes or the natural alignment of a row or
    column (depending on code:ColumnMajor) of the matrix (where the natural
    alignment is the number of columns/rows multiplied by the component
    size)
endif::VK_NV_cooperative_matrix[]
ifdef::VK_NV_cooperative_vector[]
  * [[VUID-{refpage}-OpCooperativeVectorMatrixMulNV-10089]]
    For code:OpCooperativeVectorMatrixMulNV and
    code:OpCooperativeVectorMatrixMulAddNV, the following must: be satisfied
    by the same entry in the slink:VkCooperativeVectorPropertiesNV array
    returned by flink:vkGetPhysicalDeviceCooperativeVectorPropertiesNV:
  ** The component type of code:Input must: match
     slink:VkCooperativeVectorPropertiesNV::pname:inputType
  ** The code:InputInterpretation must: match
     slink:VkCooperativeVectorPropertiesNV::pname:inputInterpretation
  ** The code:MatrixInterpretation must: match
     slink:VkCooperativeVectorPropertiesNV::pname:matrixInterpretation
  ** For code:OpCooperativeVectorMatrixMulAddNV, the code:BiasInterpretation
     must: match
     slink:VkCooperativeVectorPropertiesNV::pname:biasInterpretation
  ** The code:Result code:Type must: match
     slink:VkCooperativeVectorPropertiesNV::pname:resultType
  ** If code:Transpose is true,
     slink:VkCooperativeVectorPropertiesNV::pname:transpose must: be
     ename:VK_TRUE
  * [[VUID-{refpage}-OpCooperativeVectorMatrixMulNV-10090]]
    For code:OpCooperativeVectorMatrixMulNV and
    code:OpCooperativeVectorMatrixMulAddNV, if code:MatrixInterpretation is
    either ename:VK_COMPONENT_TYPE_FLOAT_E4M3_NV or
    ename:VK_COMPONENT_TYPE_FLOAT_E5M2_NV then code:MemoryLayout must: be
    either ename:VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV
    or ename:VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV
  * [[VUID-{refpage}-cooperativeVectorSupportedStages-10091]]
    code:OpTypeCooperativeVectorNV and code:OpCooperativeVector*
    instructions must: not be used in shader stages not included in
    slink:VkPhysicalDeviceCooperativeVectorPropertiesNV::pname:cooperativeVectorSupportedStages
  * [[VUID-{refpage}-OpCooperativeVectorReduceSumAccumulateNV-10092]]
    For code:OpCooperativeVectorReduceSumAccumulateNV:
  ** The component type of code:V must: be either 16- or 32-bit
     floating-point
  ** If the component type of code:V is 16-bit floating-point,
     <<limits-cooperativeVectorTrainingFloat16Accumulation,
     pname:cooperativeVectorTrainingFloat16Accumulation>> must: be supported
  ** If the component type of code:V is 32-bit floating-point,
     <<limits-cooperativeVectorTrainingFloat32Accumulation,
     pname:cooperativeVectorTrainingFloat32Accumulation>> must: be supported
  ** The pointer's storage class must: be code:StorageBuffer or
     code:PhysicalStorageBuffer
  * [[VUID-{refpage}-OpCooperativeVectorOuterProductAccumulateNV-10093]]
    For code:OpCooperativeVectorOuterProductAccumulateNV:
  ** code:MatrixInterpretation must be ename:VK_COMPONENT_TYPE_FLOAT16_KHR
     or ename:VK_COMPONENT_TYPE_FLOAT32_KHR
  ** If code:MatrixInterpretation is ename:VK_COMPONENT_TYPE_FLOAT16_KHR,
     <<limits-cooperativeVectorTrainingFloat16Accumulation,
     pname:cooperativeVectorTrainingFloat16Accumulation>> must: be supported
  ** If code:MatrixInterpretation is ename:VK_COMPONENT_TYPE_FLOAT32_KHR,
     <<limits-cooperativeVectorTrainingFloat32Accumulation,
     pname:cooperativeVectorTrainingFloat32Accumulation>> must: be supported
  ** The component types of code:A and code:B must: be 16-bit floating-point
  ** The matrix layout must: be training-optimal
  ** The pointer's storage class must: be code:StorageBuffer or
     code:PhysicalStorageBuffer
  * [[VUID-{refpage}-maxCooperativeVectorComponents-10094]]
    code:OpTypeCooperativeVector instructions must: have code:Component
    code:Count less than or equal to
    <<limits-maxCooperativeVectorComponents,
    pname:maxCooperativeVectorComponents>>
  * [[VUID-{refpage}-OpTypeCooperativeVector-10095]]
    code:OpTypeCooperativeVector instructions must: have code:Component
    code:Type that is any supported type reported by
    flink:vkGetPhysicalDeviceCooperativeVectorPropertiesNV
endif::VK_NV_cooperative_vector[]
ifdef::VK_NV_mesh_shader[]
  * [[VUID-{refpage}-MeshNV-07113]]
    For mesh shaders using the code:MeshNV {ExecutionModel} the
    code:OutputVertices code:OpExecutionMode must: be less than or equal to
    slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshOutputVertices
  * [[VUID-{refpage}-MeshNV-07114]]
    For mesh shaders using the code:MeshNV {ExecutionModel} the
    code:OutputPrimitivesNV code:OpExecutionMode must: be less than or equal
    to
    slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshOutputPrimitives
endif::VK_NV_mesh_shader[]
ifdef::VK_EXT_mesh_shader[]
  * [[VUID-{refpage}-MeshEXT-07115]]
    For mesh shaders using the code:MeshEXT {ExecutionModel} the
    code:OutputVertices code:OpExecutionMode must: be less than or equal to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshOutputVertices
  * [[VUID-{refpage}-MeshEXT-07332]]
    For mesh shaders using the code:MeshEXT {ExecutionModel} the "`Vertex
    Count`" operand of code:OpSetMeshOutputsEXT must: be less than or equal
    to code:OutputVertices code:OpExecutionMode
  * [[VUID-{refpage}-MeshEXT-07116]]
    For mesh shaders using the code:MeshEXT {ExecutionModel} the
    code:OutputPrimitivesEXT code:OpExecutionMode must: be less than or
    equal to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshOutputPrimitives
  * [[VUID-{refpage}-MeshEXT-07333]]
    For mesh shaders using the code:MeshEXT {ExecutionModel} the "`Primitive
    Count`" operand of code:OpSetMeshOutputsEXT must: be less than or equal
    to code:OutputPrimitivesEXT code:OpExecutionMode
  * [[VUID-{refpage}-TaskEXT-07117]]
    In task shaders using the code:TaskEXT {ExecutionModel}
    code:OpEmitMeshTasksEXT must: be called exactly once under dynamically
    uniform conditions
  * [[VUID-{refpage}-MeshEXT-07118]]
    In mesh shaders using the code:MeshEXT {ExecutionModel}
    code:OpSetMeshOutputsEXT must: be called at most once under dynamically
    uniform conditions
  * [[VUID-{refpage}-TaskEXT-07291]]
    In task shaders using the code:TaskEXT {ExecutionModel} the pname:x size
    in code:LocalSize or code:LocalSizeId must: be less than or equal to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskWorkGroupSize[0]
  * [[VUID-{refpage}-TaskEXT-07292]]
    In task shaders using the code:TaskEXT {ExecutionModel} the pname:y size
    in code:LocalSize or code:LocalSizeId must: be less than or equal to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskWorkGroupSize[1]
  * [[VUID-{refpage}-TaskEXT-07293]]
    In task shaders using the code:TaskEXT {ExecutionModel} the pname:z size
    in code:LocalSize or code:LocalSizeId must: be less than or equal to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskWorkGroupSize[2]
  * [[VUID-{refpage}-TaskEXT-07294]]
    In task shaders using the code:TaskEXT {ExecutionModel} the product of
    pname:x size, pname:y size, and pname:z size in code:LocalSize or
    code:LocalSizeId must: be less than or equal to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskWorkGroupInvocations
  * [[VUID-{refpage}-MeshEXT-07295]]
    For mesh shaders using the code:MeshEXT {ExecutionModel} the pname:x
    size in code:LocalSize or code:LocalSizeId must: be less than or equal
    to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupSize[0]
  * [[VUID-{refpage}-MeshEXT-07296]]
    For mesh shaders using the code:MeshEXT {ExecutionModel} the pname:y
    size in code:LocalSize or code:LocalSizeId must: be less than or equal
    to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupSize[1]
  * [[VUID-{refpage}-MeshEXT-07297]]
    For mesh shaders using the code:MeshEXT {ExecutionModel} the pname:z
    size in code:LocalSize or code:LocalSizeId must: be less than or equal
    to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupSize[2]
  * [[VUID-{refpage}-MeshEXT-07298]]
    For mesh shaders using the code:MeshEXT {ExecutionModel} the product of
    pname:x size, pname:y size, and pname:z size in code:LocalSize or
    code:LocalSizeId must: be less than or equal to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupInvocations
  * [[VUID-{refpage}-TaskEXT-07299]]
    In task shaders using the code:TaskEXT {ExecutionModel} the value of the
    "`Group Count X`" operand of code:OpEmitMeshTasksEXT must: be less than
    or equal to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupCount[0]
  * [[VUID-{refpage}-TaskEXT-07300]]
    In task shaders using the code:TaskEXT {ExecutionModel} the value of the
    "`Group Count Y`" operand of code:OpEmitMeshTasksEXT must: be less than
    or equal to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupCount[1]
  * [[VUID-{refpage}-TaskEXT-07301]]
    In task shaders using the code:TaskEXT {ExecutionModel} the value of the
    "`Group Count Z`" operand of code:OpEmitMeshTasksEXT must: be less than
    or equal to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupCount[2]
  * [[VUID-{refpage}-TaskEXT-07302]]
    In task shaders using the code:TaskEXT {ExecutionModel} the product of
    the "`Group Count`" operands of code:OpEmitMeshTasksEXT must: be less
    than or equal to
    slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupTotalCount
  * [[VUID-{refpage}-maxMeshSharedMemorySize-08754]]
    The sum of size in bytes for variables and <<workgroup-padding,
    padding>> in the code:Workgroup {StorageClass} in the code:MeshEXT
    {ExecutionModel} must: be less than or equal to
    <<limits-maxMeshSharedMemorySize, pname:maxMeshSharedMemorySize>>
  * [[VUID-{refpage}-maxMeshPayloadAndSharedMemorySize-08755]]
    The sum of size in bytes for variables and <<workgroup-padding,
    padding>> in the code:TaskPayloadWorkgroupEXT or code:Workgroup
    {StorageClass} in the code:MeshEXT {ExecutionModel} must: be less than
    or equal to <<limits-maxMeshPayloadAndSharedMemorySize,
    pname:maxMeshPayloadAndSharedMemorySize>>
  * [[VUID-{refpage}-maxMeshOutputMemorySize-08756]]
    The sum of size in bytes for variables in the code:Output {StorageClass}
    in the code:MeshEXT {ExecutionModel} must: be less than or equal to
    <<limits-maxMeshOutputMemorySize, pname:maxMeshOutputMemorySize>>
    according to the formula in <<mesh-output, Mesh Shader Output>>
  * [[VUID-{refpage}-maxMeshPayloadAndOutputMemorySize-08757]]
    The sum of size in bytes for variables and in the
    code:TaskPayloadWorkgroupEXT or code:Output {StorageClass} in the
    code:MeshEXT {ExecutionModel} must: be less than or equal to
    <<limits-maxMeshPayloadAndOutputMemorySize,
    pname:maxMeshPayloadAndOutputMemorySize>> according to the formula in
    <<mesh-output, Mesh Shader Output>>
  * [[VUID-{refpage}-maxTaskPayloadSize-08758]]
    The sum of size in bytes for variables and in the
    code:TaskPayloadWorkgroupEXT {StorageClass} in the code:TaskEXT
    {ExecutionModel} must: be less than or equal to
    <<limits-maxTaskPayloadSize, pname:maxTaskPayloadSize>>
  * [[VUID-{refpage}-maxTaskSharedMemorySize-08759]]
    The sum of size in bytes for variables and <<workgroup-padding,
    padding>> in the code:Workgroup {StorageClass} in the code:TaskEXT
    {ExecutionModel} must: be less than or equal to
    <<limits-maxTaskSharedMemorySize, pname:maxTaskSharedMemorySize>>
  * [[VUID-{refpage}-maxTaskPayloadAndSharedMemorySize-08760]]
    The sum of size in bytes for variables and <<workgroup-padding,
    padding>> in the code:TaskPayloadWorkgroupEXT or code:Workgroup
    {StorageClass} in the code:TaskEXT {ExecutionModel} must: be less than
    or equal to <<limits-maxTaskPayloadAndSharedMemorySize,
    pname:maxTaskPayloadAndSharedMemorySize>>
  * [[VUID-{refpage}-MeshEXT-10883]]
    If the code:MeshEXT {ExecutionModel} declares a variable with the
    code:TaskPayloadWorkgroupEXT {StorageClass} in the entry point, there
    must be a matching code:TaskPayloadWorkgroupEXT {StorageClass} variable
    in the code:TaskEXT {ExecutionModel} passed as an argument to
    code:OpEmitMeshTasksEXT
endif::VK_EXT_mesh_shader[]
ifdef::VK_KHR_cooperative_matrix[]
  * [[VUID-{refpage}-OpCooperativeMatrixLoadKHR-08986]]
    For code:OpCooperativeMatrixLoadKHR and code:OpCooperativeMatrixStoreKHR
    instructions, the code:Pointer and code:Stride operands must: be aligned
    to at least the lesser of 16 bytes or the natural alignment of a row or
    column (depending on code:ColumnMajor) of the matrix (where the natural
    alignment is the number of columns/rows multiplied by the component
    size)
endif::VK_KHR_cooperative_matrix[]
ifdef::VK_NV_cooperative_vector[]
  * [[VUID-{refpage}-OpCooperativeVectorMatrixMulNV-10096]]
    For code:OpCooperativeVectorMatrixMulNV and
    code:OpCooperativeVectorMatrixMulAddNV instructions using non-optimal
    layouts, the code:Stride operand must: be aligned to 16 bytes
  * [[VUID-{refpage}-OpCooperativeVectorMatrixMulNV-10097]]
    For code:OpCooperativeVectorMatrixMulNV and
    code:OpCooperativeVectorMatrixMulAddNV instructions, the code:Matrix and
    code:MatrixOffset must: be aligned to 64 bytes
  * [[VUID-{refpage}-OpCooperativeVectorMatrixMulAddNV-10098]]
    For code:OpCooperativeVectorMatrixMulAddNV instructions, the code:Bias
    and code:BiasOffset must: be aligned to 16 bytes
  * [[VUID-{refpage}-OpCooperativeVectorLoadNV-10099]]
    For code:OpCooperativeVectorLoadNV and code:OpCooperativeVectorStoreNV
    instructions, the code:Pointer and code:Offset must: be aligned to 16
    bytes
  * [[VUID-{refpage}-OpCooperativeVectorReduceSumAccumulateNV-10100]]
    For code:OpCooperativeVectorReduceSumAccumulateNV instructions, the
    code:Pointer and code:Offset must: be aligned to 16 bytes
  * [[VUID-{refpage}-OpCooperativeVectorOuterProductAccumulateNV-10101]]
    For code:OpCooperativeVectorOuterProductAccumulateNV instructions, the
    code:Pointer and code:Offset must: be aligned to 64 bytes
endif::VK_NV_cooperative_vector[]
ifdef::VK_KHR_portability_subset[]
  * [[VUID-{refpage}-shaderSampleRateInterpolationFunctions-06325]]
    If the `apiext:VK_KHR_portability_subset` extension is enabled, and
    slink:VkPhysicalDevicePortabilitySubsetFeaturesKHR::pname:shaderSampleRateInterpolationFunctions
    is ename:VK_FALSE, then `GLSL.std.450` fragment interpolation functions
    are not supported by the implementation and code:OpCapability must: not
    be code:InterpolationFunction
  * [[VUID-{refpage}-tessellationShader-06326]]
    If the <<features-tessellationShader, pname:tessellationShader>> feature
    is enabled, and the `apiext:VK_KHR_portability_subset` extension is
    enabled, and
    slink:VkPhysicalDevicePortabilitySubsetFeaturesKHR::pname:tessellationIsolines
    is ename:VK_FALSE, then code:OpExecutionMode must: not be code:IsoLines
  * [[VUID-{refpage}-tessellationShader-06327]]
    If the <<features-tessellationShader, pname:tessellationShader>> feature
    is enabled, and the `apiext:VK_KHR_portability_subset` extension is
    enabled, and
    slink:VkPhysicalDevicePortabilitySubsetFeaturesKHR::pname:tessellationPointMode
    is ename:VK_FALSE, then code:OpExecutionMode must: not be code:PointMode
endif::VK_KHR_portability_subset[]
ifdef::VK_KHR_8bit_storage[]
  * [[VUID-{refpage}-storageBuffer8BitAccess-06328]]
    If <<features-storageBuffer8BitAccess, pname:storageBuffer8BitAccess>>
    is ename:VK_FALSE, then objects containing an 8-bit integer element
    must: not have {StorageClass} of code:StorageBuffer,
    code:ShaderRecordBufferKHR, or code:PhysicalStorageBuffer
ifdef::VK_KHR_shader_untyped_pointers[]
    unless <<features-shaderUntypedPointers, pname:shaderUntypedPointers>>
    is ename:VK_TRUE and they are accessed in:
  ** 32-bit multiples, or
  ** 16-bit multiples if <<features-storageBuffer16BitAccess,
  pname:storageBuffer16BitAccess>> is ename:VK_TRUE.
endif::VK_KHR_shader_untyped_pointers[]
  * [[VUID-{refpage}-uniformAndStorageBuffer8BitAccess-06329]]
    If <<features-uniformAndStorageBuffer8BitAccess,
    pname:uniformAndStorageBuffer8BitAccess>> is ename:VK_FALSE, then
    objects in the code:Uniform {StorageClass} with the code:Block
    decoration must: not have an 8-bit integer member
ifdef::VK_KHR_shader_untyped_pointers[]
    unless <<features-shaderUntypedPointers, pname:shaderUntypedPointers>>
    is ename:VK_TRUE and they are accessed in:
  ** 32-bit multiples, or
  ** 16-bit multiples if <<features-uniformAndStorageBuffer16BitAccess,
  pname:uniformAndStorageBuffer16BitAccess>> is ename:VK_TRUE.
endif::VK_KHR_shader_untyped_pointers[]
  * [[VUID-{refpage}-storagePushConstant8-06330]]
    If <<features-storagePushConstant8, pname:storagePushConstant8>> is
    ename:VK_FALSE, then objects containing an 8-bit integer element must:
    not have {StorageClass} of code:PushConstant
ifdef::VK_KHR_shader_untyped_pointers[]
    unless <<features-shaderUntypedPointers, pname:shaderUntypedPointers>>
    is ename:VK_TRUE and they are accessed in:
  ** 32-bit multiples, or
  ** 16-bit multiples if <<features-storagePushConstant16,
  pname:storagePushConstant16>> is ename:VK_TRUE.
endif::VK_KHR_shader_untyped_pointers[]

endif::VK_KHR_8bit_storage[]
ifdef::VK_KHR_workgroup_memory_explicit_layout[]
  * [[VUID-{refpage}-workgroupMemoryExplicitLayout8BitAccess-10756]]
    If <<features-workgroupMemoryExplicitLayout8BitAccess,
    pname:workgroupMemoryExplicitLayout8BitAccess>> is ename:VK_FALSE, then
    objects in the code:Workgroup {StorageClass} with the code:Block
    decoration must: not have an 8-bit integer element
ifdef::VK_KHR_shader_untyped_pointers[]
    unless <<features-shaderUntypedPointers, pname:shaderUntypedPointers>>
    is ename:VK_TRUE and they are accessed in:
  ** 32-bit multiples, or
  ** 16-bit multiples if
    <<features-workgroupMemoryExplicitLayout16BitAccess,
    pname:workgroupMemoryExplicitLayout16BitAccess>> is ename:VK_TRUE
endif::VK_KHR_shader_untyped_pointers[]
endif::VK_KHR_workgroup_memory_explicit_layout[]
ifdef::VK_KHR_16bit_storage[]
  * [[VUID-{refpage}-storageBuffer16BitAccess-11161]]
    If <<features-storageBuffer16BitAccess,pname:storageBuffer16BitAccess>>
    is ename:VK_FALSE, then objects containing 16-bit integer or 16-bit
    floating-point elements must: not have {StorageClass} of
    code:StorageBuffer, code:ShaderRecordBufferKHR, or
    code:PhysicalStorageBuffer
ifdef::VK_KHR_shader_untyped_pointers[]
    unless:
  ** <<features-storageBuffer8BitAccess, pname:storageBuffer8BitAccess>> is
  ename:VK_TRUE, or
  ** the elements are accessed in 32-bit multiples if
  <<features-shaderUntypedPointers, pname:shaderUntypedPointers>> is
  ename:VK_TRUE.
endif::VK_KHR_shader_untyped_pointers[]
  * [[VUID-{refpage}-uniformAndStorageBuffer16BitAccess-06332]]
    If <<features-uniformAndStorageBuffer16BitAccess,
    pname:uniformAndStorageBuffer16BitAccess>> is ename:VK_FALSE, then
    objects in the code:Uniform {StorageClass} with the code:Block
    decoration must: not have 16-bit integer or 16-bit floating-point
    members
ifdef::VK_KHR_shader_untyped_pointers[]
    unless:
  ** <<features-uniformAndStorageBuffer8BitAccess,
  pname:uniformAndStorageBuffer8BitAccess>> is ename:VK_TRUE, or
  ** members are accessed in 32-bit multiples and
  <<features-shaderUntypedPointers, pname:shaderUntypedPointers>> is
  ename:VK_TRUE.
endif::VK_KHR_shader_untyped_pointers[]
  * [[VUID-{refpage}-storagePushConstant16-06333]]
    If <<features-storagePushConstant16, pname:storagePushConstant16>> is
    ename:VK_FALSE, then objects containing 16-bit integer or 16-bit
    floating-point elements must: not have {StorageClass} of
    code:PushConstant
ifdef::VK_KHR_shader_untyped_pointers[]
    unless:
  ** <<features-storagePushConstant8, pname:StoragePushConstant8>> is
  ename:VK_TRUE, or
  ** elements are accessed in 32-bit multiples if
  <<features-shaderUntypedPointers, pname:shaderUntypedPointers>> is
  ename:VK_TRUE.
endif::VK_KHR_shader_untyped_pointers[]

  * [[VUID-{refpage}-storageInputOutput16-11162]]
    If <<features-storageInputOutput16,pname:storageInputOutput16>> is
    ename:VK_FALSE, then objects containing 16-bit integer or 16-bit
    floating-point elements must: not have storage class of *Input* or
    *Output*.
endif::VK_KHR_16bit_storage[]
ifdef::VK_KHR_workgroup_memory_explicit_layout[]
  * [[VUID-{refpage}-workgroupMemoryExplicitLayout16BitAccess-10757]]
    If <<features-workgroupMemoryExplicitLayout16BitAccess,
    pname:workgroupMemoryExplicitLayout16BitAccess>> is ename:VK_FALSE, then
    objects in the code:Workgroup {StorageClass} with the code:Block
    decoration must: not have an 16-bit integer or 16-bit floating-point
    elements
ifdef::VK_KHR_shader_untyped_pointers[]
    unless:
  ** <<features-workgroupMemoryExplicitLayout8BitAccess,
     pname:workgroupMemoryExplicitLayout8BitAccess>> is ename:VK_TRUE, or
  ** elements are accessed in 32-bit multiples if
     <<features-shaderUntypedPointers, pname:shaderUntypedPointers>> is
     ename:VK_TRUE
endif::VK_KHR_shader_untyped_pointers[]
endif::VK_KHR_workgroup_memory_explicit_layout[]
ifdef::VK_EXT_shader_atomic_float[]
ifndef::VK_EXT_shader_atomic_float2[]
  * [[VUID-{refpage}-None-06335]]
    <<features-shaderBufferFloat32Atomics,
    pname:shaderBufferFloat32Atomics>>, or
    <<features-shaderBufferFloat32AtomicAdd,
    pname:shaderBufferFloat32AtomicAdd>>, or
    <<features-shaderSharedFloat32Atomics,
    pname:shaderSharedFloat32Atomics>>, or
    <<features-shaderSharedFloat32AtomicAdd,
    pname:shaderSharedFloat32AtomicAdd>>, or
    <<features-shaderImageFloat32Atomics, pname:shaderImageFloat32Atomics>>,
    or <<features-shaderImageFloat32AtomicAdd,
    pname:shaderImageFloat32AtomicAdd>> must: be enabled for 32-bit
    floating-point atomic operations
  * [[VUID-{refpage}-None-06336]]
    <<features-shaderBufferFloat64Atomics,
    pname:shaderBufferFloat64Atomics>>, or
    <<features-shaderBufferFloat64AtomicAdd,
    pname:shaderBufferFloat64AtomicAdd>>, or
    <<features-shaderSharedFloat64Atomics,
    pname:shaderSharedFloat64Atomics>>, or
    <<features-shaderSharedFloat64AtomicAdd,
    pname:shaderSharedFloat64AtomicAdd>> must: be enabled for 64-bit
    floating-point atomic operations
endif::VK_EXT_shader_atomic_float2[]
endif::VK_EXT_shader_atomic_float[]
ifdef::VK_EXT_shader_atomic_float2[]
  * [[VUID-{refpage}-None-06337]]
    <<features-shaderBufferFloat16Atomics,
    pname:shaderBufferFloat16Atomics>>, or
    <<features-shaderBufferFloat16AtomicAdd,
    pname:shaderBufferFloat16AtomicAdd>>, or
    <<features-shaderBufferFloat16AtomicMinMax,
    pname:shaderBufferFloat16AtomicMinMax>>, or
    <<features-shaderSharedFloat16Atomics,
    pname:shaderSharedFloat16Atomics>>, or
    <<features-shaderSharedFloat16AtomicAdd,
    pname:shaderSharedFloat16AtomicAdd>>, or
    <<features-shaderSharedFloat16AtomicMinMax,
    pname:shaderSharedFloat16AtomicMinMax>> must: be enabled for 16-bit
    floating-point atomic operations
  * [[VUID-{refpage}-None-06338]]
    <<features-shaderBufferFloat32Atomics,
    pname:shaderBufferFloat32Atomics>>, or
    <<features-shaderBufferFloat32AtomicAdd,
    pname:shaderBufferFloat32AtomicAdd>>, or
    <<features-shaderSharedFloat32Atomics,
    pname:shaderSharedFloat32Atomics>>, or
    <<features-shaderSharedFloat32AtomicAdd,
    pname:shaderSharedFloat32AtomicAdd>>, or
    <<features-shaderImageFloat32Atomics, pname:shaderImageFloat32Atomics>>,
    or <<features-shaderImageFloat32AtomicAdd,
    pname:shaderImageFloat32AtomicAdd>> or
    <<features-shaderBufferFloat32AtomicMinMax,
    pname:shaderBufferFloat32AtomicMinMax>>, or
    <<features-shaderSharedFloat32AtomicMinMax,
    pname:shaderSharedFloat32AtomicMinMax>>, or
    <<features-shaderImageFloat32AtomicMinMax,
    pname:shaderImageFloat32AtomicMinMax>> must: be enabled for 32-bit
    floating-point atomic operations
  * [[VUID-{refpage}-None-06339]]
    <<features-shaderBufferFloat64Atomics,
    pname:shaderBufferFloat64Atomics>>, or
    <<features-shaderBufferFloat64AtomicAdd,
    pname:shaderBufferFloat64AtomicAdd>>, or
    <<features-shaderSharedFloat64Atomics,
    pname:shaderSharedFloat64Atomics>>, or
    <<features-shaderSharedFloat64AtomicAdd,
    pname:shaderSharedFloat64AtomicAdd>>, or
    <<features-shaderBufferFloat64AtomicMinMax,
    pname:shaderBufferFloat64AtomicMinMax>>, or
    <<features-shaderSharedFloat64AtomicMinMax,
    pname:shaderSharedFloat64AtomicMinMax>>, must: be enabled for 64-bit
    floating-point atomic operations
endif::VK_EXT_shader_atomic_float2[]
ifdef::VK_NV_shader_atomic_float16_vector[]
  * [[VUID-{refpage}-shaderFloat16VectorAtomics-09581]]
    <<features-shaderFloat16VectorAtomics,pname:shaderFloat16VectorAtomics>>,
    must: be enabled for 16-bit floating-point, 2- and 4-component vector
    atomic operations to be supported
endif::VK_NV_shader_atomic_float16_vector[]
  * [[VUID-{refpage}-NonWritable-06340]]
    If the <<features-fragmentStoresAndAtomics,
    pname:fragmentStoresAndAtomics>> feature is not enabled, then all
    storage image, storage texel buffer, and storage buffer variables in the
    fragment stage must: be decorated with the code:NonWritable decoration
  * [[VUID-{refpage}-NonWritable-06341]]
    If the <<features-vertexPipelineStoresAndAtomics,
    pname:vertexPipelineStoresAndAtomics>> feature is not enabled, then all
    storage image, storage texel buffer, and storage buffer variables in the
    vertex, tessellation, and geometry stages must: be decorated with the
    code:NonWritable decoration
ifdef::VKSC_VERSION_1_0[]
  * [[VUID-{refpage}-OpAtomic-05091]]
    If the <<features-shaderAtomicInstructions, shaderAtomicInstructions>>
    feature is not enabled, the SPIR-V Atomic Instructions listed in 3.37.18
    (code:OpAtomic*) must: not be used <<SCID-1>>
endif::VKSC_VERSION_1_0[]
  * [[VUID-{refpage}-None-06342]]
    If <<limits-subgroupQuadOperationsInAllStages,
    pname:subgroupQuadOperationsInAllStages>> is ename:VK_FALSE, then
    <<features-subgroup-quad, quad subgroup operations>> must: not be used
    except for in fragment and compute stages
ifdef::VK_VERSION_1_1[]
  * [[VUID-{refpage}-None-06343]]
    <<shaders-group-operations, Group operations>> with
    <<shaders-scope-subgroup, subgroup scope>> must: not be used if the
    shader stage is not in <<limits-subgroupSupportedStages,
    pname:subgroupSupportedStages>>
endif::VK_VERSION_1_1[]
  * [[VUID-{refpage}-Offset-06344]]
    The first element of the code:Offset operand of code:InterpolateAtOffset
    must: be greater than or equal to: +
    [eq]#frag~width~ {times} <<limits-minInterpolationOffset,
    pname:minInterpolationOffset>># +
    where [eq]#frag~width~# is the width of the current fragment in pixels
  * [[VUID-{refpage}-Offset-06345]]
    The first element of the code:Offset operand of code:InterpolateAtOffset
    must: be less than or equal to +
    [eq]#frag~width~ {times} (<<limits-maxInterpolationOffset,
    pname:maxInterpolationOffset>> {plus} ULP ) - ULP# +
    where [eq]#frag~width~# is the width of the current fragment in pixels
    and [eq]#ULP = 1 / 2^<<limits-subPixelInterpolationOffsetBits,
    pname:subPixelInterpolationOffsetBits>>^#
  * [[VUID-{refpage}-Offset-06346]]
    The second element of the code:Offset operand of
    code:InterpolateAtOffset must: be greater than or equal to +
    [eq]#frag~height~ {times} <<limits-minInterpolationOffset,
    pname:minInterpolationOffset>># +
    where [eq]#frag~height~# is the height of the current fragment in pixels
  * [[VUID-{refpage}-Offset-06347]]
    The second element of the code:Offset operand of
    code:InterpolateAtOffset must: be less than or equal to +
    [eq]#frag~height~ {times} (<<limits-maxInterpolationOffset,
    pname:maxInterpolationOffset>> {plus} ULP ) - ULP# +
    where [eq]#frag~height~# is the height of the current fragment in pixels
    and [eq]#ULP = 1 / 2^<<limits-subPixelInterpolationOffsetBits,
    pname:subPixelInterpolationOffsetBits>>^#

ifdef::VK_KHR_ray_query[]
  * [[VUID-{refpage}-OpRayQueryInitializeKHR-06348]]
    For code:OpRayQueryInitializeKHR instructions, all components of the
    code:RayOrigin and code:RayDirection operands must: be finite
    floating-point values
  * [[VUID-{refpage}-OpRayQueryInitializeKHR-06349]]
    For code:OpRayQueryInitializeKHR instructions, the code:RayTmin and
    code:RayTmax operands must: be non-negative floating-point values
  * [[VUID-{refpage}-OpRayQueryInitializeKHR-06350]]
    For code:OpRayQueryInitializeKHR instructions, the code:RayTmin operand
    must: be less than or equal to the code:RayTmax operand
  * [[VUID-{refpage}-OpRayQueryInitializeKHR-06351]]
    For code:OpRayQueryInitializeKHR instructions, code:RayOrigin,
    code:RayDirection, code:RayTmin, and code:RayTmax operands must: not
    contain NaNs
  * [[VUID-{refpage}-OpRayQueryInitializeKHR-06352]]
    For code:OpRayQueryInitializeKHR instructions, code:Acceleration
    code:Structure must: be an acceleration structure built as a
    <<acceleration-structure-top-level, top-level acceleration structure>>
  * [[VUID-{refpage}-OpRayQueryInitializeKHR-06889]]
    For code:OpRayQueryInitializeKHR instructions, the code:Rayflags operand
    must: not contain both code:SkipTrianglesKHR and code:SkipAABBsKHR
  * [[VUID-{refpage}-OpRayQueryInitializeKHR-06890]]
    For code:OpRayQueryInitializeKHR instructions, the code:Rayflags operand
    must: not contain more than one of code:SkipTrianglesKHR,
    code:CullBackFacingTrianglesKHR, and code:CullFrontFacingTrianglesKHR
  * [[VUID-{refpage}-OpRayQueryInitializeKHR-06891]]
    For code:OpRayQueryInitializeKHR instructions, the code:Rayflags operand
    must: not contain more than one of code:OpaqueKHR, code:NoOpaqueKHR,
    code:CullOpaqueKHR, and code:CullNoOpaqueKHR
  * [[VUID-{refpage}-OpRayQueryGenerateIntersectionKHR-06353]]
    For code:OpRayQueryGenerateIntersectionKHR instructions, code:Hit code:T
    must: satisfy the condition [eq]##code:RayTmin {leq} code:Hit code:T
    {leq} code:RayTmax##, where code:RayTmin is equal to the value returned
    by code:OpRayQueryGetRayTMinKHR with the same ray query object, and
    code:RayTmax is equal to the value of code:OpRayQueryGetIntersectionTKHR
    for the current committed intersection with the same ray query object
ifdef::VK_NV_ray_tracing_motion_blur[]
  * [[VUID-{refpage}-OpRayQueryGenerateIntersectionKHR-06354]]
    For code:OpRayQueryGenerateIntersectionKHR instructions,
    code:Acceleration code:Structure must: not be built with
    ename:VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV in pname:flags
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_KHR_ray_tracing_position_fetch[]
  * [[VUID-{refpage}-flags-08761]]
    For code:OpRayQueryGetIntersectionTriangleVertexPositionsKHR
    instructions, code:Acceleration code:Structure must: have been built
    with ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR in
    pname:flags
endif::VK_KHR_ray_tracing_position_fetch[]
endif::VK_KHR_ray_query[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * [[VUID-{refpage}-OpTraceRayKHR-06355]]
    For code:OpTraceRayKHR instructions, all components of the
    code:RayOrigin and code:RayDirection operands must: be finite
    floating-point values
  * [[VUID-{refpage}-OpTraceRayKHR-06356]]
    For code:OpTraceRayKHR instructions, the code:RayTmin and code:RayTmax
    operands must: be non-negative floating-point values
  * [[VUID-{refpage}-OpTraceRayKHR-06552]]
    For code:OpTraceRayKHR instructions, the code:Rayflags operand must: not
    contain both code:SkipTrianglesKHR and code:SkipAABBsKHR
  * [[VUID-{refpage}-OpTraceRayKHR-06892]]
    For code:OpTraceRayKHR instructions, the code:Rayflags operand must: not
    contain more than one of code:SkipTrianglesKHR,
    code:CullBackFacingTrianglesKHR, and code:CullFrontFacingTrianglesKHR
  * [[VUID-{refpage}-OpTraceRayKHR-06893]]
    For code:OpTraceRayKHR instructions, the code:Rayflags operand must: not
    contain more than one of code:OpaqueKHR, code:NoOpaqueKHR,
    code:CullOpaqueKHR, and code:CullNoOpaqueKHR
  * [[VUID-{refpage}-OpTraceRayKHR-06553]]
    For code:OpTraceRayKHR instructions, if the code:Rayflags operand
    contains code:SkipTrianglesKHR, the pipeline must: not have been created
    with ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR set
  * [[VUID-{refpage}-OpTraceRayKHR-06554]]
    For code:OpTraceRayKHR instructions, if the code:Rayflags operand
    contains code:SkipAABBsKHR, the pipeline must: not have been created
    with ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR set
  * [[VUID-{refpage}-OpTraceRayKHR-06357]]
    For code:OpTraceRayKHR instructions, the code:RayTmin operand must: be
    less than or equal to the code:RayTmax operand
  * [[VUID-{refpage}-OpTraceRayKHR-06358]]
    For code:OpTraceRayKHR instructions, code:RayOrigin, code:RayDirection,
    code:RayTmin, and code:RayTmax operands must: not contain NaNs
  * [[VUID-{refpage}-OpTraceRayKHR-06359]]
    For code:OpTraceRayKHR instructions, code:Acceleration code:Structure
    must: be an acceleration structure built as a
    <<acceleration-structure-top-level, top-level acceleration structure>>
  * [[VUID-{refpage}-OpReportIntersectionKHR-06998]]
    The value of the "`Hit Kind`" operand of code:OpReportIntersectionKHR
    must: be in the range [eq]#[0,127]#
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_ray_tracing_motion_blur[]
  * [[VUID-{refpage}-OpTraceRayKHR-06360]]
    For code:OpTraceRayKHR instructions, if code:Acceleration code:Structure
    was built with ename:VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV in
    pname:flags, the pipeline must: have been created with
    ename:VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV set
  * [[VUID-{refpage}-OpTraceRayMotionNV-06361]]
    For code:OpTraceRayMotionNV instructions, all components of the
    code:RayOrigin and code:RayDirection operands must: be finite
    floating-point values
  * [[VUID-{refpage}-OpTraceRayMotionNV-06362]]
    For code:OpTraceRayMotionNV instructions, the code:RayTmin and
    code:RayTmax operands must: be non-negative floating-point values
  * [[VUID-{refpage}-OpTraceRayMotionNV-06363]]
    For code:OpTraceRayMotionNV instructions, the code:RayTmin operand must:
    be less than or equal to the code:RayTmax operand
  * [[VUID-{refpage}-OpTraceRayMotionNV-06364]]
    For code:OpTraceRayMotionNV instructions, code:RayOrigin,
    code:RayDirection, code:RayTmin, and code:RayTmax operands must: not
    contain NaNs
  * [[VUID-{refpage}-OpTraceRayMotionNV-06365]]
    For code:OpTraceRayMotionNV instructions, code:Acceleration
    code:Structure must: be an acceleration structure built as a
    <<acceleration-structure-top-level, top-level acceleration structure>>
    with ename:VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV in pname:flags
  * [[VUID-{refpage}-OpTraceRayMotionNV-06366]]
    For code:OpTraceRayMotionNV instructions the code:time operand must: be
    between 0.0 and 1.0
  * [[VUID-{refpage}-OpTraceRayMotionNV-06367]]
    For code:OpTraceRayMotionNV instructions the pipeline must: have been
    created with ename:VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV
    set
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_NV_ray_tracing_invocation_reorder[]
  * [[VUID-{refpage}-OpHitObjectTraceRayMotionNV-07704]]
    For code:OpHitObjectTraceRayMotionNV instructions, if code:Acceleration
    code:Structure was built with
    ename:VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV in pname:flags, the
    pipeline must: have been created with
    ename:VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV set
  * [[VUID-{refpage}-OpHitObjectTraceRayNV-07705]]
    For code:OpHitObjectTraceRayNV and code:OpHitObjectTraceRayMotionNV
    instructions, all components of the code:RayOrigin and code:RayDirection
    operands must: be finite floating-point values
  * [[VUID-{refpage}-OpHitObjectTraceRayNV-07706]]
    For code:OpHitObjectTraceRayNV and code:OpHitObjectTraceRayMotionNV
    instructions, the code:RayTmin and code:RayTmax operands must: be
    non-negative floating-point values
  * [[VUID-{refpage}-OpHitObjectTraceRayNV-07707]]
    For code:OpHitObjectTraceRayNV and code:OpHitObjectTraceRayMotionNV
    instructions, the code:RayTmin operand must: be less than or equal to
    the code:RayTmax operand
  * [[VUID-{refpage}-OpHitObjectTraceRayNV-07708]]
    For code:OpHitObjectTraceRayNV and code:OpHitObjectTraceRayMotionNV
    instructions, code:RayOrigin, code:RayDirection, code:RayTmin, and
    code:RayTmax operands must: not contain NaNs
  * [[VUID-{refpage}-OpHitObjectTraceRayMotionNV-07709]]
    For code:OpHitObjectTraceRayMotionNV instructions, code:Acceleration
    code:Structure must: be an acceleration structure built as a
    <<acceleration-structure-top-level, top-level acceleration structure>>
    with ename:VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV in pname:flags
  * [[VUID-{refpage}-OpHitObjectTraceRayNV-07710]]
    For code:OpHitObjectTraceRayNV and code:OpHitObjectTraceRayMotionNV
    instructions the code:time operand must: be between 0.0 and 1.0
  * [[VUID-{refpage}-OpHitObjectTraceRayMotionNV-07711]]
    For code:OpHitObjectTraceRayMotionNV instructions the pipeline must:
    have been created with
    ename:VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV set
  * [[VUID-{refpage}-OpHitObjectTraceRayNV-07712]]
    For code:OpHitObjectTraceRayNV and code:OpHitObjectTraceRayMotionNV
    instructions, the code:Rayflags operand must: not contain both
    code:SkipTrianglesKHR and code:SkipAABBsKHR
  * [[VUID-{refpage}-OpHitObjectTraceRayNV-07713]]
    For code:OpHitObjectTraceRayNV and code:OpHitObjectTraceRayMotionNV
    instructions, the code:Rayflags operand must: not contain more than one
    of code:SkipTrianglesKHR, code:CullBackFacingTrianglesKHR, and
    code:CullFrontFacingTrianglesKHR
  * [[VUID-{refpage}-OpHitObjectTraceRayNV-07714]]
    For code:OpHitObjectTraceRayNV and code:OpHitObjectTraceRayMotionNV
    instructions, the code:Rayflags operand must: not contain more than one
    of code:OpaqueKHR, code:NoOpaqueKHR, code:CullOpaqueKHR, and
    code:CullNoOpaqueKHR
  * [[VUID-{refpage}-OpHitObjectTraceRayNV-07715]]
    For code:OpHitObjectTraceRayNV and code:OpHitObjectTraceRayMotionNV
    instructions, if the code:Rayflags operand contains
    code:SkipTrianglesKHR, the pipeline must: not have been created with
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR set
  * [[VUID-{refpage}-OpHitObjectTraceRayNV-07716]]
    For code:OpHitObjectTraceRayNV and code:OpHitObjectTraceRayMotionNV
    instructions, if the code:Rayflags operand contains code:SkipAABBsKHR,
    the pipeline must: not have been created with
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR set
endif::VK_NV_ray_tracing_invocation_reorder[]
  * [[VUID-{refpage}-x-06429]]
    In compute shaders using the code:GLCompute {ExecutionModel} the pname:x
    size in code:LocalSize or code:LocalSizeId must: be less than or equal
    to slink:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupSize[0]
  * [[VUID-{refpage}-y-06430]]
    In compute shaders using the code:GLCompute {ExecutionModel} the pname:y
    size in code:LocalSize or code:LocalSizeId must: be less than or equal
    to slink:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupSize[1]
  * [[VUID-{refpage}-z-06431]]
    In compute shaders using the code:GLCompute {ExecutionModel} the pname:z
    size in code:LocalSize or code:LocalSizeId must: be less than or equal
    to slink:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupSize[2]
  * [[VUID-{refpage}-x-06432]]
    In compute shaders using the code:GLCompute {ExecutionModel} the product
    of pname:x size, pname:y size, and pname:z size in code:LocalSize or
    code:LocalSizeId must: be less than or equal to
    slink:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupInvocations
ifndef::VK_VERSION_1_3,VK_KHR_maintenance4[]
  * [[VUID-{refpage}-LocalSizeId-06433]]
    The {ExecutionMode} code:LocalSizeId must: not be used
  * [[VUID-{refpage}-OpTypeVector-06816]]
    Any code:OpTypeVector output interface variables must: not have a higher
    code:Component code:Count than a matching code:OpTypeVector input
    interface variable
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
  * [[VUID-{refpage}-LocalSizeId-06434]]
    If {ExecutionMode} code:LocalSizeId is used, <<features-maintenance4,
    pname:maintenance4>> must: be enabled
  * [[VUID-{refpage}-maintenance4-06817]]
    If the <<features-maintenance4, pname:maintenance4>> feature is not
    enabled, any code:OpTypeVector output interface variables must: not have
    a higher code:Component code:Count than a matching code:OpTypeVector
    input interface variable
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]
  * [[VUID-{refpage}-OpEntryPoint-08743]]
    Any <<interfaces-iointerfaces-user,user-defined variables>> shared
    between the code:OpEntryPoint of two shader stages, and declared with
    code:Input as its {StorageClass} for the subsequent shader stage, must:
    have all code:Location slots and code:Component words declared in the
    preceding shader stage's code:OpEntryPoint with code:Output as the
    {StorageClass}
  * [[VUID-{refpage}-OpEntryPoint-07754]]
    Any <<interfaces-iointerfaces-user,user-defined variables>> between the
    code:OpEntryPoint of two shader stages must: have the same type and
    width for each code:Component
  * [[VUID-{refpage}-OpVariable-08746]]
    Any variable, code:Block-decorated code:OpTypeStruct, or
    code:Block-decorated code:OpTypeStruct members shared between the
    code:OpEntryPoint of two shader stages must: have matching decorations
    as defined in <<interfaces-iointerfaces-matching,interface matching>>
  * [[VUID-{refpage}-Workgroup-06530]]
    The sum of size in bytes for variables and <<workgroup-padding,
    padding>> in the code:Workgroup {StorageClass} in the code:GLCompute
    {ExecutionModel} must: be less than or equal to
    <<limits-maxComputeSharedMemorySize, pname:maxComputeSharedMemorySize>>
ifdef::VK_VERSION_1_3,VK_KHR_zero_initialize_workgroup_memory[]
  * [[VUID-{refpage}-shaderZeroInitializeWorkgroupMemory-06372]]
    If the <<features-shaderZeroInitializeWorkgroupMemory,
    pname:shaderZeroInitializeWorkgroupMemory>> feature is not enabled, any
    variable with code:Workgroup as its {StorageClass} must: not have an
    code:Initializer operand
endif::VK_VERSION_1_3,VK_KHR_zero_initialize_workgroup_memory[]
ifndef::VK_VERSION_1_3,VK_KHR_zero_initialize_workgroup_memory[]
  * [[VUID-{refpage}-OpVariable-06373]]
    Any variable with code:Workgroup as its {StorageClass} must: not have an
    code:Initializer operand
endif::VK_VERSION_1_3,VK_KHR_zero_initialize_workgroup_memory[]
  * [[VUID-{refpage}-Offset-10213]]
    {empty}
ifdef::VK_KHR_maintenance8[]
    If the <<features-maintenance8,pname:maintenance8>> feature is not
    enabled, image
endif::VK_KHR_maintenance8[]
ifndef::VK_KHR_maintenance8[Image]
    operand code:Offset must: only be used with code:OpImage*Gather
    instructions
ifdef::VK_KHR_shader_untyped_pointers[]
  * [[VUID-{refpage}-Size-11165]]
    The code:Size operand of code:OpCopyMemorySized must: be a multiple of 4
  ** If 16-bit storage is enabled for the storage classes of both the
  code:Target and code:Source operands the code:Size operand may instead be
  a multiple of 2
  ** If 8-bit storage is enabled for the storage classes of both the
  code:Target and code:Source operands the code:Size operand may instead be
  any value
  * [[VUID-{refpage}-OpTypeUntypedPointerKHR-11166]]
    Any memory access made using an code:OpTypeUntypedPointerKHR must have
    an alignment that satisfies <<interfaces-resources-layout,Offset and
    Stride Assignment>>
endif::VK_KHR_shader_untyped_pointers[]
  * [[VUID-{refpage}-OpImage-06376]]
    If an code:OpImage*Gather operation has an image operand of code:Offset,
    code:ConstOffset, or code:ConstOffsets the offset value must: be greater
    than or equal to <<limits-minTexelGatherOffset,
    pname:minTexelGatherOffset>>
  * [[VUID-{refpage}-OpImage-06377]]
    If an code:OpImage*Gather operation has an image operand of code:Offset,
    code:ConstOffset, or code:ConstOffsets the offset value must: be less
    than or equal to <<limits-maxTexelGatherOffset,
    pname:maxTexelGatherOffset>>
  * [[VUID-{refpage}-OpImageSample-06435]]
    If an code:OpImageSample* or code:OpImageFetch* operation has an image
    operand of
ifdef::VK_KHR_maintenance8[code:Offset or]
    code:ConstOffset then the offset value must: be greater than or equal to
    <<limits-minTexelOffset, pname:minTexelOffset>>
  * [[VUID-{refpage}-OpImageSample-06436]]
    If an code:OpImageSample* or code:OpImageFetch* operation has an image
    operand of
ifdef::VK_KHR_maintenance8[code:Offset or]
    code:ConstOffset then the offset value must: be less than or equal to
    <<limits-maxTexelOffset, pname:maxTexelOffset>>
  * [[VUID-{refpage}-samples-08725]]
    If an code:OpTypeImage has an code:MS operand 0, its bound image must:
    have been created with slink:VkImageCreateInfo::pname:samples as
    ename:VK_SAMPLE_COUNT_1_BIT
  * [[VUID-{refpage}-samples-08726]]
    If an code:OpTypeImage has an code:MS operand 1, its bound image must:
    not have been created with slink:VkImageCreateInfo::pname:samples as
    ename:VK_SAMPLE_COUNT_1_BIT
ifdef::VK_QCOM_render_pass_shader_resolve[]
  * [[VUID-{refpage}-SampleRateShading-06378]]
    If the subpass description contains
    ename:VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM, then the SPIR-V
    fragment shader Capability code:SampleRateShading must: not be enabled
endif::VK_QCOM_render_pass_shader_resolve[]
ifdef::VK_KHR_shader_subgroup_uniform_control_flow[]
  * [[VUID-{refpage}-SubgroupUniformControlFlowKHR-06379]]
    The {ExecutionMode} code:SubgroupUniformControlFlowKHR must: not be
    applied to an entry point unless the
    <<features-shaderSubgroupUniformControlFlow,
    pname:shaderSubgroupUniformControlFlow>> feature is enabled, the
    corresponding shader stage bit is set in
    <<limits-subgroupSupportedStages, pname:subgroupSupportedStages>>, and
    the entry point does not execute any <<ray-tracing-repack,_invocation
    repack instructions_>>
endif::VK_KHR_shader_subgroup_uniform_control_flow[]
ifdef::VK_AMD_shader_early_and_late_fragment_tests[]
  * [[VUID-{refpage}-shaderEarlyAndLateFragmentTests-06767]]
    If the <<features-shaderEarlyAndLateFragmentTests,
    pname:shaderEarlyAndLateFragmentTests>> feature is not enabled, the
    code:EarlyAndLateFragmentTestsEXT {ExecutionMode} must: not be used
  * [[VUID-{refpage}-shaderEarlyAndLateFragmentTests-06768]]
    If the <<features-shaderEarlyAndLateFragmentTests,
    pname:shaderEarlyAndLateFragmentTests>> feature is not enabled, the
    code:StencilRefUnchangedFrontEXT {ExecutionMode} must: not be used
  * [[VUID-{refpage}-shaderEarlyAndLateFragmentTests-06769]]
    If the <<features-shaderEarlyAndLateFragmentTests,
    pname:shaderEarlyAndLateFragmentTests>> feature is not enabled, the
    code:StencilRefUnchangedBackEXT {ExecutionMode} must: not be used
  * [[VUID-{refpage}-shaderEarlyAndLateFragmentTests-06770]]
    If the <<features-shaderEarlyAndLateFragmentTests,
    pname:shaderEarlyAndLateFragmentTests>> feature is not enabled, the
    code:StencilRefGreaterFrontEXT {ExecutionMode} must: not be used
  * [[VUID-{refpage}-shaderEarlyAndLateFragmentTests-06771]]
    If the <<features-shaderEarlyAndLateFragmentTests,
    pname:shaderEarlyAndLateFragmentTests>> feature is not enabled, the
    code:StencilRefGreaterBackEXT {ExecutionMode} must: not be used
  * [[VUID-{refpage}-shaderEarlyAndLateFragmentTests-06772]]
    If the <<features-shaderEarlyAndLateFragmentTests,
    pname:shaderEarlyAndLateFragmentTests>> feature is not enabled, the
    code:StencilRefLessFrontEXT {ExecutionMode} must: not be used
  * [[VUID-{refpage}-shaderEarlyAndLateFragmentTests-06773]]
    If the <<features-shaderEarlyAndLateFragmentTests,
    pname:shaderEarlyAndLateFragmentTests>> feature is not enabled, the
    code:StencilRefLessBackEXT {ExecutionMode} must: not be used
endif::VK_AMD_shader_early_and_late_fragment_tests[]
ifdef::VK_QCOM_image_processing[]
  * [[VUID-{refpage}-OpImageWeightedSampleQCOM-06979]]
    If an code:OpImageWeightedSampleQCOM operation is used, then the
    code:Texture code:Sampled code:Image and code:Weight code:Image
    parameters must: both be _dynamically uniform_ for the quad
  * [[VUID-{refpage}-OpImageWeightedSampleQCOM-06980]]
    If an code:OpImageWeightedSampleQCOM operation is used, then the
    code:Weight code:Image parameter must: be of {StorageClass}
    code:UniformConstant and type code:OpTypeImage with code:Depth=0,
    code:Dim=code:2D, code:Arrayed=1, code:MS=0, and code:Sampled=1
  * [[VUID-{refpage}-OpImageWeightedSampleQCOM-06981]]
    If an code:OpImageWeightedSampleQCOM operation is used, then the
    code:Weight code:Image parameter must: be decorated with
    code:WeightTextureQCOM
  * [[VUID-{refpage}-OpImageBlockMatchSADQCOM-06982]]
    If an code:OpImageBlockMatchSADQCOM or code:OpImageBlockMatchSSDQCOM
    operation is used, then the code:target code:sampled code:image,
    code:reference code:sampled code:image, and code:Block code:Size
    parameters must: both be _dynamically uniform_ for the quad
  * [[VUID-{refpage}-OpImageBlockMatchSSDQCOM-06983]]
    If an code:OpImageBlockMatchSSDQCOM or code:OpImageBlockMatchSADQCOM
    operation is used, then code:target code:sampled code:image and
    code:reference code:sampled code:image parameters must: be of storage
    class code:UniformConstant and type code:OpTypeImage with code:Depth=0,
    code:Dim=code:2D, code:Arrayed=0, code:MS=0, and code:Sampled=1
  * [[VUID-{refpage}-OpImageBlockMatchSSDQCOM-06984]]
    If an code:OpImageBlockMatchSSDQCOM or code:OpImageBlockMatchSADQCOM
    operation is used, then the code:target code:sampled code:image and
    code:reference code:sampled code:image parameters must: be decorated
    with code:BlockMatchTextureQCOM
  * [[VUID-{refpage}-OpImageBlockMatchSSDQCOM-06985]]
    If an code:OpImageBlockMatchSSDQCOM or code:OpImageBlockMatchSADQCOM
    operation is used, then code:target code:sampled code:image and
    code:reference code:sampled code:image parameters must: have been
    created using an identical sampler object
  * [[VUID-{refpage}-OpImageBlockMatchSSDQCOM-06986]]
    If an code:OpImageBlockMatchSSDQCOM or code:OpImageBlockMatchSADQCOM
    operation is used, then code:target code:sampled code:image and
    code:reference code:sampled code:image parameters must: have been
    created with a sampler object with pname:unnormalizedCoordinates equal
    to ename:VK_TRUE
  * [[VUID-{refpage}-OpImageBlockMatchSSDQCOM-06987]]
    If an code:OpImageBlockMatchSSDQCOM or code:OpImageBlockMatchSADQCOM
    operation is used, then code:target code:sampled code:image and
    code:reference code:sampled code:image parameters must: have been
    created with a sampler object with pname:unnormalizedCoordinates equal
    to ename:VK_TRUE
  * [[VUID-{refpage}-OpImageBlockMatchSSDQCOM-06988]]
    If an code:OpImageBlockMatchSSDQCOM or code:OpImageBlockMatchSADQCOM
    operation is used, then code:Block code:Size less than or equal to
    <<limits-blockmatch-maxblocksize, pname:maxBlockMatchRegion>>
  * [[VUID-{refpage}-OpImageBoxFilterQCOM-06989]]
    If an code:OpImageBoxFilterQCOM operation is used, then code:Box
    code:Size.y must: be equal to or greater than 1.0 and less than or equal
    to <<limits-boxfilter-maxblocksize,
    pname:maxBoxFilterBlockSize>>.code:height
  * [[VUID-{refpage}-OpImageBoxFilterQCOM-06990]]
    If an code:OpImageBoxFilterQCOM operation is used, then code:Sampled
    code:Texture code:Image and code:Box code:Size parameters must: be
    _dynamically uniform_
endif::VK_QCOM_image_processing[]
  * [[VUID-{refpage}-OpEntryPoint-08727]]
    Each code:OpEntryPoint must: not have more than one variable decorated
    with code:InputAttachmentIndex per image aspect of the attachment image
    bound to it, either explicitly or implicitly as described by
    <<interfaces-inputattachment, input attachment interface>>
ifdef::VK_EXT_shader_tile_image[]
  * [[VUID-{refpage}-minSampleShading-08731]]
    If <<primsrast-sampleshading, sample shading>> is enabled and
    pname:minSampleShading is 1.0, the code:sample operand of any
    code:OpColorAttachmentReadEXT, code:OpDepthAttachmentReadEXT, or
    code:OpStencilAttachmentReadEXT operation must: evaluate to the value of
    the <<primsrast-multisampling-coverage-mask, coverage index>> for any
    given fragment invocation
  * [[VUID-{refpage}-minSampleShading-08732]]
    If <<primsrast-sampleshading, sample shading>> is enabled and any of the
    code:OpColorAttachmentReadEXT, code:OpDepthAttachmentReadEXT, or
    code:OpStencilAttachmentReadEXT operations are used, then
    pname:minSampleShading must: be 1.0
endif::VK_EXT_shader_tile_image[]
  * [[VUID-{refpage}-MeshEXT-09218]]
    In mesh shaders using the code:MeshEXT or code:MeshNV {ExecutionModel}
    and the code:OutputPoints {ExecutionMode},
ifdef::VK_VERSION_1_4,VK_KHR_maintenance5[]
    if the <<features-maintenance5, pname:maintenance5>> feature is not
    enabled, and
endif::VK_VERSION_1_4,VK_KHR_maintenance5[]
    if the number of output points is greater than 0, a code:PointSize
    decorated variable must: be written to for each output point
ifdef::VK_VERSION_1_4,VK_KHR_maintenance5[]
  * [[VUID-{refpage}-maintenance5-09190]]
    If the <<features-maintenance5, pname:maintenance5>> feature is enabled
    and a code:PointSize decorated variable is written to, all execution
    paths must: write to a code:PointSize decorated variable
endif::VK_VERSION_1_4,VK_KHR_maintenance5[]
ifdef::VK_AMDX_shader_enqueue[]
  * [[VUID-{refpage}-ShaderEnqueueAMDX-09191]]
    The code:ShaderEnqueueAMDX capability must: only be used in shaders with
    the code:GLCompute
ifdef::VK_EXT_mesh_shader[]
    or code:MeshEXT
endif::VK_EXT_mesh_shader[]
    execution model
  * [[VUID-{refpage}-NodePayloadAMDX-09192]]
    Variables in the code:NodePayloadAMDX storage class must: only be
    declared in the code:GLCompute
ifdef::VK_EXT_mesh_shader[]
    or code:MeshEXT
endif::VK_EXT_mesh_shader[]
    execution model
  * [[VUID-{refpage}-maxExecutionGraphShaderPayloadSize-09193]]
    Variables declared in the code:NodePayloadAMDX storage class must: not
    be larger than the <<limits-maxExecutionGraphShaderPayloadSize,
    pname:maxExecutionGraphShaderPayloadSize>> limit
  * [[VUID-{refpage}-maxExecutionGraphShaderPayloadSize-09194]]
    Variables declared in the code:NodeOutputPayloadAMDX storage class must:
    not be larger than the <<limits-maxExecutionGraphShaderPayloadSize,
    pname:maxExecutionGraphShaderPayloadSize>> limit
  * [[VUID-{refpage}-maxExecutionGraphShaderPayloadSize-09195]]
    For a given entry point, the sum of the size of any variable in the
    code:NodePayloadAMDX storage class, and the combined size of all
    statically initialized variables in the code:NodeOutputPayloadAMDX
    storage class must: not be greater than
    <<limits-maxExecutionGraphShaderPayloadSize,
    pname:maxExecutionGraphShaderPayloadSize>>
  * [[VUID-{refpage}-maxExecutionGraphShaderPayloadCount-09196]]
    Shaders must: not statically initialize more than
    <<limits-maxExecutionGraphShaderPayloadCount,
    pname:maxExecutionGraphShaderPayloadCount>> variables in the
    code:NodeOutputPayloadAMDX storage class
  * [[VUID-{refpage}-maxExecutionGraphShaderOutputNodes-09197]]
    Shaders must: not include more than
    <<limits-maxExecutionGraphShaderOutputNodes,
    pname:maxExecutionGraphShaderOutputNodes>> instances of
    code:OpInitializeNodePayloadsAMDX
endif::VK_AMDX_shader_enqueue[]
ifdef::VK_QCOM_image_processing2[]
  * [[VUID-{refpage}-OpImageBlockMatchWindow-09219]]
    If a code:OpImageBlockMatchWindow*QCOM or
    code:OpImageBlockMatchGather*QCOM operation is used, then the
    code:target code:sampled code:image, code:reference code:sampled
    code:image, and code:Block code:Size parameters must: both be
    _dynamically uniform_ for the quad
  * [[VUID-{refpage}-OpImageBlockMatchWindow-09220]]
    If a code:OpImageBlockMatchWindow*QCOM or
    code:OpImageBlockMatchGather*QCOM operation is used, then code:target
    code:sampled code:image and code:reference code:sampled code:image
    parameters must: be of storage class code:UniformConstant and type
    code:OpTypeImage with code:Depth=0, code:Dim=code:2D, code:Arrayed=0,
    code:MS=0, and code:Sampled=1
  * [[VUID-{refpage}-OpImageBlockMatchWindow-09221]]
    If a code:OpImageBlockMatchWindow*QCOM or
    code:OpImageBlockMatchGather*QCOM operation is used, then the
    code:target code:sampled code:image and code:reference code:sampled
    code:image parameters must: be decorated with code:BlockMatchTextureQCOM
  * [[VUID-{refpage}-OpImageBlockMatchWindow-09222]]
    If a code:OpImageBlockMatchWindow*QCOM or
    code:OpImageBlockMatchGather*QCOM operation is used, then code:target
    code:sampled code:image and code:reference code:sampled code:image
    parameters must: have been created using an identical sampler object
  * [[VUID-{refpage}-OpImageBlockMatchWindow-09223]]
    If a code:OpImageBlockMatchWindow*QCOM or
    code:OpImageBlockMatchGather*QCOM operation is used, then code:target
    code:sampled code:image and code:reference code:sampled code:image
    parameters must: have been created with a sampler object with
    pname:unnormalizedCoordinates equal to ename:VK_TRUE
  * [[VUID-{refpage}-OpImageBlockMatchWindow-09224]]
    If a code:OpImageBlockMatchWindow*QCOM or
    code:OpImageBlockMatchGather*QCOM operation is used, then code:target
    code:sampled code:image and code:reference code:sampled code:image
    parameters must: have been created with sampler object with
    pname:unnormalizedCoordinates equal to ename:VK_TRUE
  * [[VUID-{refpage}-maxBlockMatchRegion-09225]]
    If a code:OpImageBlockMatchWindow*QCOM or
    code:OpImageBlockMatchGather*QCOM operation is used, then code:Block
    code:Size less than or equal to <<limits-blockmatch-maxblocksize,
    pname:maxBlockMatchRegion>>
  * [[VUID-{refpage}-pNext-09226]]
    If a code:OpImageBlockMatchWindow*QCOM operation is used, then
    code:target code:sampled code:image must: have been created using
    asampler object that included
    slink:VkSamplerBlockMatchWindowCreateInfoQCOM in the pname:pNext chain
endif::VK_QCOM_image_processing2[]
ifdef::VK_KHR_shader_maximal_reconvergence[]
  * [[VUID-{refpage}-MaximallyReconvergesKHR-09565]]
    The execution mode code:MaximallyReconvergesKHR must: not be applied to
    an entry point unless the entry point does not execute any
    <<ray-tracing-repack,_invocation repack instructions_>>
endif::VK_KHR_shader_maximal_reconvergence[]
ifdef::VK_VERSION_1_4,VK_KHR_shader_subgroup_rotate[]
  * [[VUID-{refpage}-shaderSubgroupRotateClustered-09566]]
    If <<features-shaderSubgroupRotateClustered,
    pname:shaderSubgroupRotateClustered>> is ename:VK_FALSE, then the
    code:ClusterSize operand to code:OpGroupNonUniformRotateKHR must: not be
    used
endif::VK_VERSION_1_4,VK_KHR_shader_subgroup_rotate[]
  * [[VUID-{refpage}-protectedNoFault-09645]]
    If <<limits-protectedNoFault, pname:protectedNoFault>> is not supported,
    the {StorageClass} of the code:PhysicalStorageBuffer must: not be used
    if the buffer being accessed is <<memory-protected-memory,protected>>
ifdef::VK_KHR_compute_shader_derivatives[]
  * [[VUID-{refpage}-meshAndTaskShaderDerivatives-10153]]
    If <<limits-meshAndTaskShaderDerivatives,
    pname:meshAndTaskShaderDerivatives>> is ename:VK_FALSE, the
    code:DerivativeGroupLinearKHR and code:DerivativeGroupQuadsKHR execution
    modes must: not be used in the code:MeshEXT, code:MeshNV, code:TaskEXT,
    or code:TaskNV {ExecutionModel}
endif::VK_KHR_compute_shader_derivatives[]
ifdef::VK_QCOM_tile_shading[]
  * [[VUID-{refpage}-TileShadingQCOM-10698]]
    code:TileShadingQCOM capability must: not be declared in the compute
    stage unless the <<features-tileShading,tileShading>> feature is enabled
  * [[VUID-{refpage}-TileShadingQCOM-10699]]
    The code:TileShadingQCOM capability must: not be declared in the
    fragment stage unless the
    <<features-tileShadingFragmentStage,tileShadingFragmentStage>> feature
    is enabled
  * [[VUID-{refpage}-TileShadingQCOM-10700]]
    A shader that enables SPIR-V capability code:TileShadingQCOM must: not
    be invoked outside a <<renderpass-tile-shading,tile shading render
    pass>>
  * [[VUID-{refpage}-TileShadingQCOM-10701]]
    A compute shader that enables SPIR-V capability code:TileShadingQCOM
    must: only be invoked inside those portions of a command buffer where
    <<renderpass-per-tile-execution-model,per-tile execution model>> is
    enabled
  * [[VUID-{refpage}-x-10702]]
    In compute shaders that enables SPIR-V capability code:TileShadingQCOM,
    the pname:x size in code:TileShadingRateQCOM must: be less than or equal
    to slink:VkPhysicalDeviceTileShadingPropertiesQCOM.maxTileShadingRate.x
  * [[VUID-{refpage}-y-10703]]
    In compute shaders that enables SPIR-V capability code:TileShadingQCOM,
    the pname:y size in code:TileShadingRateQCOM must: be less than or equal
    to slink:VkPhysicalDeviceTileShadingPropertiesQCOM.maxTileShadingRate.y
  * [[VUID-{refpage}-z-10704]]
    In compute shaders that enables SPIR-V capability code:TileShadingQCOM,
    the pname:z size in code:TileShadingRateQCOM must: be less than or equal
    to slink:VkTilePropertiesQCOM.tileSize.z
  * [[VUID-{refpage}-tileSize-10705]]
    In compute shaders that enables SPIR-V capability code:TileShadingQCOM,
    [eq]#slink:VkTilePropertiesQCOM.tileSize.z %
    code:TileShadingRateQCOM::pname:z# must: equal `0`
  * [[VUID-{refpage}-OpImage-10706]]
    An code:OpImage with code:Storage code:Class code:TileAttachmentQCOM
    must: not be consumed by code:OpImageTexelPointer unless the
    <<features-tileShadingFragmentStage,tileShadingAtomicOps>> feature is
    enabled
  * [[VUID-{refpage}-OpTypeImage-10707]]
    An code:OpTypeImage with code:Storage code:Class code:TileAttachmentQCOM
    must: not be backed by a view equivalent to the color attachment of the
    current subpass instance unless the
    <<features-tileShadingColorAttachments,tileShadingColorAttachments>>
    feature is enabled
  * [[VUID-{refpage}-OpTypeImage-10708]]
    An code:OpTypeImage with code:Storage code:Class code:TileAttachmentQCOM
    must: not be backed by a view equivalent to the depth aspect of the
    depth/stencil attachment of the current subpass instance unless the
    <<features-tileShadingDepthAttachments,tileShadingDepthAttachments>>
  * [[VUID-{refpage}-OpTypeImage-10709]]
    An code:OpTypeImage with code:Storage code:Class code:TileAttachmentQCOM
    must: not be backed by a view equivalent to the stencil aspect of the
    depth/stencil attachment of the current subpass instance unless the
    <<features-tileShadingStencilAttachments,tileShadingStencilAttachments>>
    feature is enabled
  * [[VUID-{refpage}-OpTypeImage-10710]]
    An code:OpTypeImage with code:Storage code:Class code:TileAttachmentQCOM
    must: not be backed by a view equivalent to the input attachment of the
    current subpass instance unless the
    <<features-tileShadingInputAttachments,tileShadingInputAttachments>>
    feature is enabled
  * [[VUID-{refpage}-OpTypeSampledImage-10711]]
    An code:OpTypeSampledImage with code:Storage code:Class
    code:TileAttachmentQCOM must: not be backed by a view equivalent to an
    attachment of the current subpass instance unless the
    <<features-tileShadingSampledAttachments,tileShadingSampledAttachments>>
    feature is enabled
ifdef::VK_QCOM_image_processing,VK_QCOM_image_processing2[]
  * [[VUID-{refpage}-tileShadingImageProcessing-10712]]
    If an code:OpTypeSampledImage with code:Storage code:Class
    code:TileAttachmentQCOM is consumed by any argument of the following
    operations,
    <<features-tileShadingImageProcessing,pname:tileShadingImageProcessing>>
    must: be enabled:
  ** code:OpImageSampleWeightedQCOM
  ** code:OpImageBoxFilterQCOM
  ** code:OpImageBlockMatch*QCOM
endif::VK_QCOM_image_processing,VK_QCOM_image_processing2[]
  * [[VUID-{refpage}-Coordinate-10713]]
    The code:Coordinate operand of any code:OpImageRead,
    code:OpImageSparseRead, code:OpImageWrite, or code:OpImageTexelPointer
    instruction that consumes an code:OpTypeImage with an image code:Storage
    code:Class code:TileAttachmentQCOM must: not result in any texels
    accessed outside the boundaries of the current tile, computed as
    described in <<renderpass-tile-shading-offset-validation,Tile
    Attachments>>
  * [[VUID-{refpage}-Coordinate-10714]]
    The code:Coordinate operand(s) of any of the following instructions that
    consumes an code:OpTypeSampledImage with an image of code:Storage
    code:Class code:TileAttachmentQCOM must: not result in any texels
    accessed outside boundaries of the current tile, computed as described
    in <<renderpass-tile-shading-offset-validation,Tile Attachments>>:
  ** code:OpImageSample*
  ** code:OpImageSparseSample*
  ** code:OpImageFetch
  ** code:OpImageSparseFetch
  ** code:OpImage*Gather
  ** code:OpImageSparse*Gather
ifdef::VK_QCOM_image_processing[]
  ** code:OpImageSampleWeightedQCOM
  ** code:OpImageBoxFilterQCOM
  ** code:OpImageBlockMatch*QCOM
endif::VK_QCOM_image_processing[]
endif::VK_QCOM_tile_shading[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-{refpage}-None-10715]]
    If a slink:VkSampler object that enables
    <<samplers-YCbCr-conversion,sampler {YCbCr} conversion>> is accessed in
    a shader, both the sampler and image accessed must: be determined by
    <<glossary-constant-integral-expression, constant integral expressions>>
  * [[VUID-{refpage}-None-10716]]
    If a slink:VkSampler object that enables
    <<samplers-YCbCr-conversion,sampler {YCbCr} conversion>> is statically
    used, it must: only be used with `OpImageSample*` or
    `OpImageSparseSample*` instructions
  * [[VUID-{refpage}-OpImage-10717]]
    An code:OpImage instruction must: not be used on a slink:VkSampler
    object that enables <<samplers-YCbCr-conversion,sampler {YCbCr}
    conversion>>
  * [[VUID-{refpage}-ConstOffset-10718]]
    If a slink:VkSampler object that enables
    <<samplers-YCbCr-conversion,sampler {YCbCr} conversion>> is statically
    used, it must: not use the code:ConstOffset or code:Offset operands
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_ARM_tensors[]
  * [[VUID-{refpage}-shaderTensorSupportedStages-09901]]
    code:OpTypeTensorARM, code:OpTensorReadARM, code:OpTensorWriteARM, or
    code:OpTensorQuerySizeARM must: not be used in shader stages not in
    <<limits-shaderTensorSupportedStages,pname:shaderTensorSupportedStages>>
  * [[VUID-{refpage}-OpTypeTensorARM-09902]]
    code:OpTypeTensorARM with a code:Shape must: not be used in shader
    stages
  * [[VUID-{refpage}-OpTypeTensorARM-09907]]
    code:OpTypeTensorARM without a code:Rank must: not be used in shader
    stages
  * [[VUID-{refpage}-maxTensorShaderAccessArrayLength-09903]]
    The length of an array returned by code:OpTensorReadARM or passed as the
    code:Object operand to code:OpTensorWriteARM must: be less than or equal
    to <<limits-maxTensorShaderAccessArrayLength,
    pname:maxTensorShaderAccessArrayLength>>
  * [[VUID-{refpage}-maxTensorShaderAccessSize-09904]]
    The total size of the data (number of tensor elements {times} size of an
    element) read or written by one code:OpTensorReadARM, or
    code:OpTensorWriteARM instruction, respectively, must: be less than or
    equal to <<limits-maxTensorShaderAccessSize,
    pname:maxTensorShaderAccessSize>>
endif::VK_ARM_tensors[]
  * [[VUID-{refpage}-None-10824]]
    {empty}
ifdef::VK_KHR_maintenance9[]
    If the <<features-maintenance9,pname:maintenance9>> feature is not
    enabled, the
endif::VK_KHR_maintenance9[]
ifndef::VK_KHR_maintenance9[]
    The
endif::VK_KHR_maintenance9[]
    code:Base operand of any code:OpBitCount, code:OpBitReverse,
    code:OpBitFieldInsert, code:OpBitFieldSExtract, or
    code:OpBitFieldUExtract instruction must: be a 32-bit integer scalar or
    a vector of 32-bit integers

ifdef::VK_ARM_data_graph[]
  * [[VUID-{refpage}-GraphARM-09922]]
    The code:GraphARM capability must: not be declared in modules used to
    create a shader stage
  * [[VUID-{refpage}-pNext-09919]]
    For each <<graphs-pipelines,data graph pipeline>> created with a
    slink:VkDataGraphPipelineShaderModuleCreateInfoARM structure included in
    the pname:pNext chain of slink:VkDataGraphPipelineCreateInfoARM, the
    code:OpGraph that is used by the code:OpGraphEntryPointARM the pipeline
    is being created for must: have an code:OpTypeGraphARM that only uses
    code:OpTypeTensorARM with code:Shape present
  * [[VUID-{refpage}-pNext-09920]]
    For each <<graphs-pipelines,data graph pipeline>> created with a
    slink:VkDataGraphPipelineShaderModuleCreateInfoARM structure included in
    the pname:pNext chain of slink:VkDataGraphPipelineCreateInfoARM, all the
    code:OpGraphConstantARM with code:OpTypeTensorARM type used by the
    code:OpGraph that is used by the code:OpGraphEntryPointARM the pipeline
    is being created for must: have an code:OpTypeTensorARM with code:Shape
    present
  * [[VUID-{refpage}-pNext-09921]]
    For each <<graphs-pipelines,data graph pipeline>> created with a
    slink:VkDataGraphPipelineShaderModuleCreateInfoARM structure included in
    the pname:pNext chain of slink:VkDataGraphPipelineCreateInfoARM, one and
    only one slink:VkDataGraphPipelineConstantARM structure that satisfies
    all the following constraints must: be present in
    slink:VkDataGraphPipelineShaderModuleCreateInfoARM::pname:pConstants for
    each code:OpGraphConstantARM used by the code:OpGraph that has a
    code:OpTypeTensorARM type and is used by the code:OpGraphEntryPointARM
    the pipeline is being created for:
  ** its pname:id member must: match the code:GraphConstantID of the
     code:OpGraphConstantARM
  ** its pname:pNext chain must: include a slink:VkTensorDescriptionARM
     structure
  *** whose pname:dimensionCount is equal to the code:Rank of the
      code:OpTypeTensorARM of the code:OpGraphConstantARM
  *** whose pname:pDimensions array elements are individually and in order
      equal to the elements of the array that defines the code:Shape of the
      code:OpTypeTensorARM of the code:OpGraphConstantARM
  *** whose pname:format <<spirvenv-tensor-formats,is compatible>> with the
      code:ElementType of the code:OpTypeTensorARM of the
      code:OpGraphConstantARM
  * [[VUID-{refpage}-pNext-09923]]
    For each <<graphs-pipelines,data graph pipeline>> created with a
    slink:VkDataGraphPipelineShaderModuleCreateInfoARM structure included in
    the pname:pNext chain of slink:VkDataGraphPipelineCreateInfoARM, one and
    only one slink:VkDataGraphPipelineResourceInfoARM structure that
    satisfies all the following constraints must: be present in
    slink:VkDataGraphPipelineCreateInfoARM::pname:pResourceInfos for each
    code:OpVariable with a code:OpTypeTensorARM type that is part of the
    code:Interface of the code:OpGraphEntryPointARM the pipeline is being
    created for:
  ** its pname:descriptorSet member must: match the code:DescriptorSet
     decoration applied to the code:OpVariable
  ** its pname:binding member must: match the code:Binding decoration
     applied to the code:OpVariable
  ** its pname:arrayElement member must: be zero if code:OpVariable is not a
     code:OpTypeArray or if code:OpVariable is a code:OpTypeArray of
     code:OpTypeTensorARM with code:Shape present
  ** its pname:pNext chain must: include a slink:VkTensorDescriptionARM
     structure
  *** whose pname:dimensionCount is equal to the code:Rank of the
      code:OpTypeTensorARM of the code:OpVariable or its elements
  *** whose pname:pDimensions array elements are individually and in order
      equal to the elements of the array that defines the code:Shape of the
      code:OpTypeTensorARM of the code:OpVariable or its elements
  *** whose pname:format <<spirvenv-tensor-formats,is compatible>> with the
      code:ElementType of the code:OpTypeTensorARM of the code:OpVariable
endif::VK_ARM_data_graph[]
  * [[VUID-{refpage}-None-10834]]
    <<spirvenv-buffer-indexing,Buffer indexing calculations>> must: not wrap
    32 bits
****
--


[[spirvenv-precision-operation]]
== Precision and Operation of SPIR-V Instructions

The following rules apply to operations on all floating-point values:

  * Positive and negative infinities and positive and negative zeros are
    generated as dictated by <<ieee-754,IEEE 754>> for the specified
    encoding, but subject to the precisions allowed by each operation for a
    given encoding, as specified in <<spirvenv-op-prec,Precision of
    Individual Operations>>.
  * Signaling [eq]##NaN##s are not required to be generated and exceptions
    are never raised.
    Signaling [eq]##NaN## may: be converted to quiet [eq]##NaN##s values by
    any floating-point instruction.
  * The set of operations code:OpPhi, code:OpSelect, code:OpFunctionCall,
    code:OpReturnValue, code:OpVectorExtractDynamic,
    code:OpVectorInsertDynamic, code:OpVectorShuffle,
    code:OpCompositeConstruct, code:OpCompositeExtract,
    code:OpCompositeInsert, code:OpTranspose, code:OpCopyObject,
    code:OpCopyLogical, code:OpCopyMemory,
ifdef::VK_VERSION_1_1[]
    code:OpGroupNonUniformBroadcast, code:OpGroupNonUniformBroadcastFirst,
    code:OpGroupNonUniformShuffle, code:OpGroupNonUniformShuffleXor,
    code:OpGroupNonUniformShuffleUp, code:OpGroupNonUniformShuffleDown,
    code:OpGroupNonUniformQuadBroadcast, code:OpGroupNonUniformQuadSwap,
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_shader_subgroup_ballot[]
    code:OpSubgroupReadInvocationKHR, code:OpSubgroupFirstInvocationKHR,
endif::VK_EXT_shader_subgroup_ballot[]
ifdef::VK_KHR_shader_subgroup_rotate[]
    code:OpGroupNonUniformRotateKHR,
endif::VK_KHR_shader_subgroup_rotate[]
ifdef::VK_KHR_cooperative_matrix[]
    code:OpCooperativeMatrixLoadKHR, code:OpCooperativeMatrixStoreKHR,
endif::VK_KHR_cooperative_matrix[]
ifdef::VK_NV_cooperative_matrix[]
    code:OpCooperativeMatrixLoadNV, code:OpCooperativeMatrixStoreNV,
endif::VK_NV_cooperative_matrix[]
ifdef::VK_NV_cooperative_matrix2[]
    code:OpCooperativeMatrixLoadTensorNV,
    code:OpCooperativeMatrixStoreTensorNV,
endif::VK_NV_cooperative_matrix2[]
    code:OpAtomicLoad, code:OpAtomicStore, code:OpAtomicExchange,
    code:OpStore, and code:OpLoad are referred to as _bit-preserving
    operations_.
ifdef::VK_VERSION_1_4,VK_KHR_shader_float_controls2[]
  * The floating-point environment used for an instruction can be determined
    as follows:
  ** If the SPIR-V specifies it explicitly using the code:FPFastMath
     decoration or code:FPFastMathDefault {ExecutionMode} then that is used.
  ** If the environment is not specified in the SPIR-V then it is determined
     as follows:
  *** If the operation is not decorated code:NoContraction then the flags
      code:AllowContract, code:AllowReassoc, code:AllowRecip, and
      code:AllowTransform are assumed.
  *** If any of the following conditions are true then the flags code:NSZ,
      code:NotInf, and code:NotNaN are assumed:
  **** The entry point does not use the {ExecutionMode}
       code:SignedZeroInfNanPreserve with a bit-width corresponding to one
       of the operands or to the result type.
  **** The operation is not a bit-preserving operation and is not one of
       code:OpFConvert, code:OpFNegate, code:OpFAdd, code:OpFSub,
       code:OpFMul, code:OpFDiv, code:OpIsNan, code:OpIsInf,
       code:OpVectorTimesScalar, code:OpMatrixTimesScalar,
       code:OpVectorTimesMatrix, code:OpMatrixTimesVector,
       code:OpMatrixTimesMatrix, code:OpOuterProduct, code:OpDot,
       code:OpFOrdEqual, code:OpFUnordEqual, code:OpFOrdNotEqual,
       code:OpFUnordNotEqual, code:OpFOrdLessThan, code:OpFUnordLessThan,
       code:OpFOrdGreaterThan, code:OpFUnordGreaterThan,
       code:OpFOrdLessThanEqual, code:OpFUnordLessThanEqual,
       code:OpFOrdGreaterThanEqual, code:OpFUnordGreaterThanEqual,
       code:OpGroupNonUniformAllEqual,
ifdef::VK_EXT_shader_subgroup_vote[code:OpSubgroupAllEqualKHR,]
       code:OpGroupNonUniformFMin, code:OpGroupNonUniformFMax,
       code:OpAtomicCompareExchange, code:OpAtomicCompareExchangeWeak,
ifdef::VK_EXT_shader_float_atomic[code:OpAtomicFAddEXT,]
ifdef::VK_EXT_shader_float_atomic[code:OpAtomicFMinEXT,]
ifdef::VK_EXT_shader_float_atomic[code:OpAtomicFMaxEXT,]
       code:OpDPdx, code:OpDPdy, code:OpFwidth, code:OpDPdxFine,
       code:OpDPdyFine, code:OpFwidthFine, code:OpDPdxCoarse,
       code:OpDPdyCoarse, or code:OpFwidthCoarse.
  **** The operation is an code:OpLoad from the code:Input {StorageClass} in
       the fragment shader stage.
endif::VK_VERSION_1_4,VK_KHR_shader_float_controls2[]
ifndef::VK_VERSION_1_4,VK_KHR_shader_float_controls2[]
  * By default, the implementation may: perform optimizations on half,
    single, or double-precision floating-point instructions that ignore sign
    of a zero, or assume that arguments and results are not NaNs or
    infinities.
ifdef::VK_VERSION_1_2,VK_KHR_shader_float_controls[]
    If the entry point is declared with the code:SignedZeroInfNanPreserve
    {ExecutionMode}, then NaNs, infinities, and the sign of zero must: not
    be ignored.
  ** All bit-preserving operations except code:OpLoad from the code:Input
     {StorageClass} in the fragment shader stage must: respect the
     code:SignedZeroInfNanPreserve {ExecutionMode}.
  ** The following core SPIR-V instructions must: respect the
     code:SignedZeroInfNanPreserve {ExecutionMode}: code:OpFConvert,
     code:OpFNegate, code:OpFAdd, code:OpFSub, code:OpFMul, code:OpFDiv,
     code:OpIsNan, code:OpIsInf, code:OpVectorTimesScalar,
     code:OpMatrixTimesScalar, code:OpVectorTimesMatrix,
     code:OpMatrixTimesVector, code:OpMatrixTimesMatrix,
     code:OpOuterProduct, code:OpDot, code:OpFOrdEqual, code:OpFUnordEqual,
     code:OpFOrdNotEqual, code:OpFUnordNotEqual, code:OpFOrdLessThan,
     code:OpFUnordLessThan, code:OpFOrdGreaterThan,
     code:OpFUnordGreaterThan, code:OpFOrdLessThanEqual,
     code:OpFUnordLessThanEqual, code:OpFOrdGreaterThanEqual,
     code:OpFUnordGreaterThanEqual, code:OpGroupNonUniformAllEqual,
ifdef::VK_EXT_shader_subgroup_vote[code:OpSubgroupAllEqualKHR,]
     code:OpGroupNonUniformFMin, code:OpGroupNonUniformFMax,
     code:OpAtomicCompareExchange, code:OpAtomicCompareExchangeWeak,
ifdef::VK_EXT_shader_float_atomic[code:OpAtomicFAddEXT,]
ifdef::VK_EXT_shader_float_atomic[code:OpAtomicFMinEXT,]
ifdef::VK_EXT_shader_float_atomic[code:OpAtomicFMaxEXT,]
     code:OpDPdx, code:OpDPdy, code:OpFwidth, code:OpDPdxFine,
     code:OpDPdyFine, code:OpFwidthFine, code:OpDPdxCoarse,
     code:OpDPdyCoarse, and code:OpFwidthCoarse.
endif::VK_VERSION_1_2,VK_KHR_shader_float_controls[]
endif::VK_VERSION_1_4,VK_KHR_shader_float_controls2[]
  * All bit-preserving operations and the following instructions must: not
    flush denormalized values: code:OpConstant, code:OpConstantComposite,
    code:OpSpecConstant, code:OpSpecConstantComposite, and code:OpBitcast.
ifndef::VK_VERSION_1_2,VK_KHR_shader_float_controls[]
  * Any denormalized value input into a shader or potentially generated by
    any instruction in a shader (except those listed above) may: be flushed
    to 0.
  * The rounding mode cannot: be set, and results will be
    <<spirvenv-correctly-rounded, correctly rounded>>, as described below.
  * [eq]##NaN##s may: not be generated.
    Instructions that operate on a [eq]#NaN# may: not result in a [eq]#NaN#.
endif::VK_VERSION_1_2,VK_KHR_shader_float_controls[]
ifdef::VK_VERSION_1_2,VK_KHR_shader_float_controls[]
  * Denormalized values are supported.
  ** By default any denormalized floating-point value input into a shader or
     potentially generated by any instruction (except those listed above) or
     any extended instructions for GLSL in a shader may: be flushed to zero.
ifdef::VK_EXT_shader_float8[]
  ** Denormalized floating-point values whose type use the
     code:Float8E4M3EXT or code:Float8E5M2EXT FP Encoding must: be preserved
     during conversions to IEEE 754 binary 16 floating-point values.
endif::VK_EXT_shader_float8[]
  ** If the entry point is declared with the code:DenormFlushToZero
     {ExecutionMode} then for the affected instructions the denormalized
     result must: be flushed to zero and the denormalized operands may: be
     flushed to zero.
     Denormalized values obtained via unpacking an integer into a vector of
     values with smaller bit width and interpreting those values as
     floating-point numbers must: be flushed to zero.
  ** When denormal values are being flushed, the result of an operation may:
     be considered denormal whenever the infinitely precise result is
     non-zero and of smaller magnitude than the smallest normal value, even
     if rounding would otherwise give a normal result.
  ** The following core SPIR-V instructions must: respect the
     code:DenormFlushToZero {ExecutionMode}: code:OpSpecConstantOp (with
     opcode code:OpFConvert), code:OpFConvert, code:OpFNegate, code:OpFAdd,
     code:OpFSub, code:OpFMul, code:OpFDiv, code:OpFRem, code:OpFMod,
     code:OpVectorTimesScalar, code:OpMatrixTimesScalar,
     code:OpVectorTimesMatrix, code:OpMatrixTimesVector,
     code:OpMatrixTimesMatrix, code:OpOuterProduct, code:OpDot,
     code:OpGroupNonUniformFMin, code:OpGroupNonUniformFMax,
ifdef::VK_EXT_shader_atomic_float[code:OpAtomicFAddEXT,]
ifdef::VK_EXT_shader_atomic_float2[code:OpAtomicFMinEXT,]
ifdef::VK_EXT_shader_atomic_float2[code:OpAtomicFMaxEXT,]
     code:OpDPdx, code:OpDPdy, code:OpFwidth, code:OpDPdxFine,
     code:OpDPdyFine code:OpFwidthFine, code:OpDPdxCoarse,
     code:OpDPdyCoarse, code:OpFwidthCoarse; and the following extended
     instructions for GLSL: code:Round, code:RoundEven, code:Trunc,
     code:FAbs, code:Floor, code:Ceil, code:Fract, code:Radians,
     code:Degrees, code:Sin, code:Cos, code:Tan, code:Asin, code:Acos,
     code:Atan, code:Sinh, code:Cosh, code:Tanh, code:Asinh, code:Acosh,
     code:Atanh, code:Atan2, code:Pow, code:Exp, code:Log, code:Exp2,
     code:Log2, code:Sqrt, code:InverseSqrt, code:Determinant,
     code:MatrixInverse, code:Modf, code:ModfStruct, code:FMin, code:FMax,
     code:FClamp, code:FMix, code:Step, code:SmoothStep, code:Fma,
     code:UnpackHalf2x16, code:Length, code:Distance, code:Cross,
     code:Normalize, code:FaceForward, code:Reflect, code:Refract,
     code:NMin, code:NMax, and code:NClamp.
  ** The following core SPIR-V instructions must: respect the
     code:DenormPreserve {ExecutionMode} for floating-point values with an
     <<ieee-754,IEEE 754>> encoding: code:OpSpecConstantOp, code:OpFConvert,
     code:OpFNegate, code:OpFAdd, code:OpFSub, code:OpFMul,
     code:OpVectorTimesScalar, code:OpMatrixTimesScalar,
     code:OpVectorTimesMatrix, code:OpMatrixTimesVector,
     code:OpMatrixTimesMatrix, code:OpOuterProduct, code:OpDot,
     code:OpFOrdEqual, code:OpFUnordEqual, code:OpFOrdNotEqual,
     code:OpFUnordNotEqual, code:OpFOrdLessThan, code:OpFUnordLessThan,
     code:OpFOrdGreaterThan, code:OpFUnordGreaterThan,
     code:OpFOrdLessThanEqual, code:OpFUnordLessThanEqual,
     code:OpFOrdGreaterThanEqual, code:OpFUnordGreaterThanEqual,
ifdef::VK_EXT_shader_subgroup_vote[]
     code:OpSubgroupAllEqualKHR,
endif::VK_EXT_shader_subgroup_vote[]
     code:OpGroupNonUniformAllEqual, code:OpGroupNonUniformFMin,
     code:OpGroupNonUniformFMax, code:OpAtomicCompareExchange,
     code:OpAtomicCompareExchangeWeak,
ifdef::VK_EXT_shader_atomic_float[code:OpAtomicFAddEXT,]
ifdef::VK_EXT_shader_atomic_float2[code:OpAtomicFMinEXT,]
ifdef::VK_EXT_shader_atomic_float2[code:OpAtomicFMaxEXT,]
     code:OpDPdx, code:OpDPdy, code:OpFwidth, code:OpDPdxFine,
     code:OpDPdyFine code:OpFwidthFine, code:OpDPdxCoarse,
     code:OpDPdyCoarse, code:OpFwidthCoarse; and the following extended
     instructions for GLSL: code:FAbs, code:FSign, code:Radians,
     code:Degrees, code:FMin, code:FMax, code:FClamp, code:FMix, code:Fma,
     code:PackHalf2x16, code:PackDouble2x32, code:UnpackHalf2x16,
     code:UnpackDouble2x32, code:NMin, code:NMax, and code:NClamp.
endif::VK_VERSION_1_2,VK_KHR_shader_float_controls[]

The precision of double-precision instructions is at least that of single
precision.

The precision of individual operations is defined in
<<spirvenv-op-prec,Precision of Individual Operations>>.
Subject to the constraints below, however, implementations may: reorder or
combine operations, resulting in expressions exhibiting different precisions
than might be expected from the constituent operations.


[[spirvenv-evaluation-expressions]]
=== Evaluation of Expressions

Implementations may: rearrange floating-point operations using any of the
mathematical properties governing the expressions in precise arithmetic,
even where the floating- point operations do not share these properties.
This includes, but is not limited to, associativity and distributivity, and
may: involve a different number of rounding steps than would occur if the
operations were not rearranged.
In shaders that use the code:SignedZeroInfNanPreserve {ExecutionMode} the
values must: be preserved if they are generated after any rearrangement but
the {ExecutionMode} does not change which rearrangements are valid.
This rearrangement can: be prevented for particular operations by using the
code:NoContraction decoration.

ifdef::VK_VERSION_1_2,VK_KHR_shader_float_controls[]
[NOTE]
====
For example, in the absence of the code:NoContraction decoration
implementations are allowed to implement [eq]#a + b - a# and latexmath:[{a
\times b}\over{a}] as [eq]#b#.
The code:SignedZeroInfNanPreserve does not prevent these transformations,
even though they may overflow to infinity or NaN when evaluated in
floating-point.

If the code:NoContraction decoration is applied then operations may not be
rearranged, so, for example, [eq]#a + a - a# must account for possible
overflow to infinity.
If infinities are not preserved then the expression may be replaced with
[eq]#a#, since the replacement is exact when overflow does not occur and
infinities may be replaced with undefined: values.
If both code:NoContraction and code:SignedZeroInfNanPreserve are used then
the result must be infinity for sufficiently large [eq]#a#.
====
endif::VK_VERSION_1_2,VK_KHR_shader_float_controls[]


[[spirvenv-op-prec]]
=== Precision of Individual Operations

The precision of individual operations is defined either in terms of
rounding (correctly rounded), as an error bound in ULP, or as inherited from
a formula as follows:

[[spirvenv-correct-result]]
.Correct Result
Operations that are described as returning the "`correct result`" will
return the infinitely precise result which, due to the nature of the
operation, will not need rounding.

[[spirvenv-correctly-rounded]]
.Correctly Rounded
Operations described as "`correctly rounded`" will return the infinitely
precise result, [eq]#x#, rounded so as to be representable in
floating-point.
ifdef::VK_VERSION_1_2,VK_KHR_shader_float_controls[]
If the entry point is declared with the code:RoundingModeRTE or the
code:RoundingModeRTZ {ExecutionMode} then this is done according to
<<ieee-754,IEEE 754>> "`roundTiesToEven`" or "`roundTowardZero`" rounding
directions, respectively.
ifdef::VK_KHR_shader_bfloat16,VK_EXT_shader_float8[]
These execution modes do not affect operations on floating-point values with
the following encodings:

ifdef::VK_KHR_shader_bfloat16[]
  * code:BFloat16KHR
endif::VK_KHR_shader_bfloat16[]
ifdef::VK_EXT_shader_float8[]
  * code:Float8E4M3EXT
  * code:Float8E5M2EXT
endif::VK_EXT_shader_float8[]
endif::VK_KHR_shader_bfloat16,VK_EXT_shader_float8[]

Otherwise, they are rounded with
<<spirvenv-correctly-rounded-impl-defined,implementation-defined rounding
mode>>.
endif::VK_VERSION_1_2,VK_KHR_shader_float_controls[]
ifndef::VK_VERSION_1_2,VK_KHR_shader_float_controls[]
The rounding mode used is not defined, so this is equivalent to "`correctly
rounded with implementation-defined rounding mode`".
endif::VK_VERSION_1_2,VK_KHR_shader_float_controls[]

[[spirvenv-correctly-rounded-impl-defined]]
.Correctly Rounded with Implementation-Defined Rounding Mode
Operations described as "`correctly rounded with implementation-defined
rounding mode`" will return the infinitely precise result, [eq]#x#, rounded
so as to be representable in floating-point.
If [eq]#x# is exactly representable then [eq]#x# will be returned.
Otherwise, either the floating-point value closest to and no less than
[eq]#x# or the value closest to and no greater than [eq]#x# will be
returned.
Which value is chosen is implementation-defined.

[[spirvenv-ulp]]
.ULP
Where an error bound of [eq]#n# ULP (units in the last place) is given, for
an operation with infinitely precise result #x# the value returned must: be
in the range [eq]#[x - n {times} ulp(x), x {plus} n {times} ulp(x)]#.
The function [eq]#ulp(x)# is defined as follows:

  {empty}:: If there exist non-equal, finite floating-point numbers #a# and
    #b# such that [eq]#a {leq} x {leq} b# then [eq]#ulp(x)# is the minimum
    possible distance between such numbers, latexmath:[ulp(x) =
    \mathrm{min}_{a,b} | b - a |].
    If such numbers do not exist then [eq]#ulp(x)# is defined to be the
    difference between the two non-equal, finite floating-point numbers
    nearest to [eq]#x#.

Where the range of allowed return values includes any value of magnitude
larger than that of the largest representable finite floating-point number,
operations may:, additionally, return either an infinity of the appropriate
sign or the finite number with the largest magnitude of the appropriate
sign.
If the infinitely precise result of the operation is not mathematically
defined then the value returned is undefined:.

.Inherited From ...
Where an operation's precision is described as being inherited from a
formula, the result returned must: be at least as accurate as the result of
computing an approximation to [eq]#x# using a formula equivalent to the
given formula applied to the supplied inputs.
Specifically, the formula given may be transformed using the mathematical
associativity, commutativity and distributivity of the operators involved to
yield an equivalent formula.
The SPIR-V precision rules, when applied to each such formula and the given
input values, define a range of permitted values.
If [eq]#NaN# is one of the permitted values then the operation may return
any result, otherwise let the largest permitted value in any of the ranges
be [eq]#F~max~# and the smallest be [eq]#F~min~#.
The operation must: return a value in the range [eq]#[x - E, x {plus} E]#
where latexmath:[E = \mathrm{max} \left( | x - F_{\mathrm{min}} |, | x -
F_{\mathrm{max}} | \right) ].
ifdef::VK_VERSION_1_2,VK_KHR_shader_float_controls[]
If the entry point is declared with the code:DenormPreserve {ExecutionMode},
then denormals must: be preserved throughout the formula.
Otherwise, any intermediate denormal value(s) while evaluating the formula
may: be flushed to zero.
If the entry point is declared with the code:DenormFlushToZero execution
mode, then denormal final results must: be flushed to zero.
endif::VK_VERSION_1_2,VK_KHR_shader_float_controls[]

ifdef::VK_KHR_shader_bfloat16[]
The precision of all instructions on float values with the code:BFloat16KHR
encoding is required to be
<<spirvenv-correctly-rounded-impl-defined,correctly rounded with
implementation defined rounding mode>>.
endif::VK_KHR_shader_bfloat16[]

ifdef::VK_VERSION_1_2,VK_KHR_shader_float16_int8[]
For IEEE754 half- (16 bit) and single- (32 bit) precision instructions,
precisions are required: to be at least as follows:
endif::VK_VERSION_1_2,VK_KHR_shader_float16_int8[]

ifndef::VK_VERSION_1_2,VK_KHR_shader_float16_int8[]
For IEEE754 single precision (32 bit) instructions, precisions are required:
to be at least as follows:
endif::VK_VERSION_1_2,VK_KHR_shader_float16_int8[]

[[spirvenv-precision-core-table]]
.Precision of Core SPIR-V Instructions
[options="header", cols=",,"]
|====
| Instruction
 | Single precision, unless decorated with RelaxedPrecision | Half precision
| code:OpFNegate
2+| Correct result.
| code:OpFAdd
2+| Correctly rounded.
| code:OpFSub
2+| Correctly rounded.
| code:OpFMul, code:OpVectorTimesScalar, code:OpMatrixTimesScalar
2+| Correctly rounded.
| code:OpMatrixTimesVector
2+a| Inherited from latexmath:[\sum_{j = 0}^{n - 1} M_{ij} \times v_{j}].
| code:OpVectorTimesMatrix
2+a| Inherited from latexmath:[\sum_{j = 0}^{n - 1} v_{j} \times M_{ji}].
| code:OpMatrixTimesMatrix
2+a| Inherited from latexmath:[\sum_{k = 0}^{n - 1} M_{ik} \times N_{kj}].
| code:OpOuterProduct
2+| Correctly rounded.
| code:OpDot(x, y)
2+a| Inherited from latexmath:[\sum_{i = 0}^{n - 1} x_{i} \times y_{i}].
| code:OpIsNan, code:OpIsInf
2+| Correct result.
| code:OpFOrdEqual, code:OpFUnordEqual
2+| Correct result.
| code:OpFOrdNotEqual, code:OpFUnordNotEqual
2+| Correct result.
| code:OpFOrdLessThan, code:OpFUnordLessThan
2+| Correct result.
| code:OpFOrdGreaterThan, code:OpFUnordGreaterThan
2+| Correct result.
| code:OpFOrdLessThanEqual, code:OpFUnordLessThanEqual
2+| Correct result.
| code:OpFOrdGreaterThanEqual, code:OpFUnordGreaterThanEqual
2+| Correct result.
ifdef::VK_EXT_shader_subgroup_vote[]
| code:OpSubgroupAllEqualKHR
2+| Correct result.
endif::VK_EXT_shader_subgroup_vote[]
ifdef::VK_VERSION_1_1[]
| code:OpGroupNonUniformAllEqual
2+| Correct result.
| code:OpGroupNonUniformFMin, code:OpGroupNonUniformFMax
2+| Correct result.
endif::VK_VERSION_1_1[]
| code:OpFDiv(x,y)
 | 2.5 ULP for [eq]#{vert}y{vert} = 0# or [eq]#{vert}y{vert}# in the range [2^-126^, 2^126^].   | 2.5 ULP for [eq]#{vert}y{vert} = 0# or [eq]#{vert}y{vert}# in the range [2^-14^, 2^14^].
| code:OpFRem(x,y)
2+| Inherited from [eq]#x - y {times} trunc(x/y)#.
| code:OpFMod(x,y)
2+| Inherited from [eq]#x - y {times} floor(x/y)#.
| code:OpQuantizeToF16
2+| Correctly rounded with implementation defined rounding mode.
| conversions between types
2+| Correctly rounded.
| code:OpAtomicCompareExchange, code:OpAtomicCompareExchangeWeak
2+| Correct result.
ifdef::VK_EXT_shader_atomic_float[]
| code:OpAtomicFAddEXT
2+| Return value correct result, value in memory correctly rounded.
endif::VK_EXT_shader_atomic_float[]
ifdef::VK_EXT_shader_atomic_float2[]
| code:OpAtomicFMinEXT, code:OpAtomicFMaxEXT
2+| Correct result.
endif::VK_EXT_shader_atomic_float2[]
| code:OpDPdx, code:OpDPdy, code:OpFwidth
2+| Correctly rounded.
| code:OpDPdxCoarse, code:OpDPdyCoarse, code:OpFwidthCoarse
2+| Correctly rounded.
| code:OpDPdxFine, code:OpDPdyFine, code:OpFwidthFine
2+| Correctly rounded.
|====

[NOTE]
====
The code:OpFRem and code:OpFMod instructions use cheap approximations of
remainder, and the error can be large due to the discontinuity in trunc()
and floor().
This can produce mathematically unexpected results in some cases, such as
FMod(x,x) computing x rather than 0, and can also cause the result to have a
different sign than the infinitely precise result.
====

[[precision-of-glsl-std-450-instructions]]
.Precision of GLSL.std.450 Instructions
[options="header", cols=",,"]
|====
|Instruction
  | Single precision, unless decorated with RelaxedPrecision | Half precision
| code:fma()
2+| Inherited from code:OpFMul followed by code:OpFAdd.
| code:exp(x),  code:exp2(x)
 a| latexmath:[3 + 2 \times \vert x \vert] ULP.             a| latexmath:[1 + 2 \times \vert x \vert] ULP.
| code:log(),  code:log2()
 a| 3 ULP outside the range latexmath:[[0.5, 2.0\]]. Absolute error < latexmath:[2^{-21}] inside the range latexmath:[[0.5, 2.0\]].
 a| 3 ULP outside the range latexmath:[[0.5, 2.0\]]. Absolute error < latexmath:[2^{-7}] inside the range latexmath:[[0.5, 2.0\]].
| code:pow(x, y)
2+| Inherited from code:exp2(y {times} code:log2(x)).
| code:sqrt()
2+| Inherited from 1.0 / code:inversesqrt().
| code:inversesqrt()
2+| 2 ULP.
| code:radians(x)
2+a| Inherited from latexmath:[x \times C_{\pi\_180}], where latexmath:[C_{\pi\_180}] is a correctly rounded approximation to latexmath:[\frac{\pi}{180}].
| code:degrees(x)
2+a| Inherited from latexmath:[x \times C_{180\_\pi}], where latexmath:[C_{180\_\pi}] is a correctly rounded approximation to latexmath:[\frac{180}{\pi}].
| code:sin()
  a| Absolute error latexmath:[\leq 2^{-11}] inside the range latexmath:[[-\pi, \pi\]]. a| Absolute error latexmath:[\leq 2^{-7}] inside the range latexmath:[[-\pi, \pi\]].
| code:cos()
  a| Absolute error latexmath:[\leq 2^{-11}] inside the range latexmath:[[-\pi, \pi\]]. a| Absolute error latexmath:[\leq 2^{-7}] inside the range latexmath:[[-\pi, \pi\]].
| code:tan()
2+a| Inherited from latexmath:[\frac{\sin()}{\cos()}].
| code:asin(x)
2+a| Inherited from latexmath:[\mathrm{atan2}(x, sqrt(1.0 - x \times x))].
| code:acos(x)
2+a| Inherited from latexmath:[\mathrm{atan2}(sqrt(1.0 - x \times x), x)].
| code:atan(), code:atan2()
   | 4096 ULP                                                      | 5 ULP.
| code:sinh(x)
2+a| Inherited from latexmath:[(\exp(x) - \exp(-x)) \times 0.5].
| code:cosh(x)
2+a| Inherited from latexmath:[(\exp(x) + \exp(-x)) \times 0.5].
| code:tanh()
2+a| Inherited from latexmath:[\frac{\sinh()}{\cosh()}].
| code:asinh(x)
2+a| Inherited from latexmath:[\log(x + sqrt(x \times x + 1.0))].
| code:acosh(x)
2+a| Inherited from latexmath:[\log(x + sqrt(x \times x - 1.0))].
| code:atanh(x)
2+a| Inherited from latexmath:[\log(\frac{1.0 + x}{1.0 - x}) \times 0.5].
| code:frexp()
2+| Correct result.
| code:ldexp()
2+| Correctly rounded.
| code:length(x)
2+a| Inherited from latexmath:[sqrt(dot(x, x))].
| code:distance(x, y)
2+a| Inherited from latexmath:[length(x - y)].
| code:cross()
2+| Inherited from [eq]#code:OpFSub(code:OpFMul, code:OpFMul)#.
| code:normalize(x)
2+a| Inherited from latexmath:[x \times inversesqrt(dot(x, x))].
| code:faceforward(N, I, NRef)
2+| Inherited from [eq]#code:dot(NRef, I) < 0.0 ? N : -N#.
| code:reflect(x, y)
2+| Inherited from [eq]#x - 2.0 {times} code:dot(y, x) {times} y#.
| code:refract(I, N, eta)
2+| Inherited from [eq]#k < 0.0 ? 0.0 : eta {times} I - (eta {times} code:dot(N, I) {plus} code:sqrt(k)) {times} N#, where [eq]#k = 1 - eta {times} eta {times} (1.0 - code:dot(N, I) {times} code:dot(N, I))#.
| code:round
2+| Correctly rounded.
| code:roundEven
2+| Correctly rounded.
| code:trunc
2+| Correctly rounded.
| code:fabs
2+| Correct result.
| code:fsign
2+| Correct result.
| code:floor
2+| Correctly rounded.
| code:ceil
2+| Correctly rounded.
| code:fract
2+| Correctly rounded.
| code:modf
2+| Correctly rounded.
| code:fmin
2+| Correct result.
| code:fmax
2+| Correct result.
| code:fclamp
2+| Correct result.
| code:fmix(x, y, a)
2+a| Inherited from latexmath:[x \times (1.0 - a) + y \times a].
| code:step
2+| Correctly rounded.
| code:smoothStep(edge0, edge1, x)
2+a| Inherited from latexmath:[t \times t \times (3.0 - 2.0 \times t)],
where latexmath:[t = clamp(\frac{x - edge0}{edge1 - edge0}, 0.0, 1.0)].
| code:nmin
2+| Correct result.
| code:nmax
2+| Correct result.
| code:nclamp
2+| Correct result.
| code:packHalf2x16
2+| Correctly rounded with implementation defined rounding mode.
|====


GLSL.std.450 extended instructions specifically defined in terms of the
above instructions inherit the above errors.
GLSL.std.450 extended instructions not listed above and not defined in terms
of the above have undefined: precision.

ifdef::VK_KHR_maintenance8[]
If the <<features-maintenance8,pname:maintenance8>> feature is not enabled
and if
endif::VK_KHR_maintenance8[]
ifndef::VK_KHR_maintenance8[If]
either operand to code:OpSRem and code:OpSMod instructions is negative the
result is undefined:.

[NOTE]
====
While the code:OpSRem and code:OpSMod instructions are supported by the
Vulkan environment,
ifdef::VK_KHR_maintenance8[]
If the <<features-maintenance8,pname:maintenance8>> feature is not enabled,
endif::VK_KHR_maintenance8[]
they require non-negative values and thus do not enable additional
functionality beyond what code:OpUMod provides.
====

ifdef::VK_NV_cooperative_matrix[]
code:OpCooperativeMatrixMulAddNV performs its operations in an
implementation-dependent order and internal precision.
endif::VK_NV_cooperative_matrix[]

ifdef::VK_KHR_cooperative_matrix[]
code:OpCooperativeMatrixMulAddKHR performs its operations in an
implementation-dependent order and internal precision.
endif::VK_KHR_cooperative_matrix[]

ifdef::VK_NV_cooperative_vector[]
code:OpCooperativeVectorMatrixMulNV and
code:OpCooperativeVectorMatrixMulAddNV perform their operations in an
implementation-dependent order and internal precision.

When pname:inputType is ename:VK_COMPONENT_TYPE_FLOAT16_KHR and
pname:inputInterpretation is a lower-precision floating-point type (e.g.
ename:VK_COMPONENT_TYPE_FLOAT_E4M3_NV or
ename:VK_COMPONENT_TYPE_FLOAT_E5M2_NV), the input vector should: be
converted to the lower-precision type before performing the matrix-vector
multiply, but may: keep the full 16 bits of precision.
endif::VK_NV_cooperative_vector[]


[[spirvenv-buffer-indexing]]
== Buffer Indexing Calculations

Pipelines and shaders may: be compiled to use 32-bit integer arithmetic to
compute byte offsets (e.g. based on code:OpAccessChain instructions) within
a
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[physical storage buffer or]
buffer, limiting the accessible range to 4GB.
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
For physical storage buffers, the base address is a 64-bit value and the
implicit base plus offset calculation uses 64-bit addition.
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]

[NOTE]
====
Note that code:OpAccessChain indices are always treated as signed, so a
32-bit index can only address 2GB if the code:ArrayStride is 1.
====

The offset calculations that have the 4GB limit include:

  * code:OpAccessChain and code:OpPtrAccessChain - the total offset summed
    over all indices multiplied by strides, including spanning multiple
    access chain instructions that lead to a given memory access.
ifdef::VK_NV_cooperative_matrix[]
  * code:OpCooperativeMatrixLoadNV and code:OpCooperativeMatrixStoreNV
    instructions computing an offset based on element, row, and stride
    parameters.
endif::VK_NV_cooperative_matrix[]
ifdef::VK_KHR_cooperative_matrix[]
  * code:OpCooperativeMatrixLoadKHR and code:OpCooperativeMatrixStoreKHR
    instructions computing an offset based on element, row, and stride
    parameters.
endif::VK_KHR_cooperative_matrix[]
ifdef::VK_NV_cooperative_matrix2[]
  * code:OpCooperativeMatrixLoadTensorNV and
    code:OpCooperativeMatrixStoreTensorNV instructions computing an offset
    based on tensor layout state.
endif::VK_NV_cooperative_matrix2[]
ifdef::VK_NV_cooperative_vector[]
  * code:OpCooperativeVectorMatrixMulAddNV,
    code:OpCooperativeVectorMatrixMulNV and
    code:OpCooperativeVectorOuterProductAccumulateNV instructions computing
    an offset based on offset, row, and stride parameters.
endif::VK_NV_cooperative_vector[]


[[spirvenv-image-signedness]]
== Signedness of SPIR-V Image Accesses

SPIR-V associates a signedness with all integer image accesses.
This is required in certain parts of the SPIR-V and the Vulkan image access
pipeline to ensure defined results.
The signedness is determined from a combination of the access instruction's
code:Image code:Operands and the underlying image's code:Sampled code:Type
as follows:

 1. If the instruction's code:Image code:Operands contains the
    code:SignExtend operand then the access is signed.
 2. If the instruction's code:Image code:Operands contains the
    code:ZeroExtend operand then the access is unsigned.
 3. Otherwise, the image accesses signedness matches that of the
    code:Sampled code:Type of the code:OpTypeImage being accessed.


[[spirvenv-format-type-matching]]
== Image Format and Type Matching

When specifying the code:Image code:Format of an code:OpTypeImage, the
converted bit width and type, as shown in the table below, must: match the
code:Sampled code:Type.
The signedness must: match the <<spirvenv-image-signedness,signedness of any
access>> to the image.

[NOTE]
====
Formatted accesses are always converted from a shader readable type to the
resource's format or vice versa via <<textures-format-conversion>> for reads
and <<textures-output-format-conversion>> for writes.
As such, the bit width and format below do not necessarily match 1:1 with
what might be expected for some formats.
====

For a given code:Image code:Format, the code:Sampled code:Type must: be the
type described in the _Type_ column of the below table, with its
code:Literal code:Width set to that in the _Bit Width_ column.
Every access that is made to the image must: have a signedness equal to that
in the _Signedness_ column (where applicable).

[options="autowidth"]
|===
| Image Format       | Type-Declaration instructions | Bit Width | Signedness

| code:Unknown       | Any                  | Any       | Any
| code:Rgba32f   .20+| code:OpTypeFloat .20+| 32    .20+| N/A
| code:Rg32f
| code:R32f
| code:Rgba16f
| code:Rg16f
| code:R16f
| code:Rgba16
| code:Rg16
| code:R16
| code:Rgba16Snorm
| code:Rg16Snorm
| code:R16Snorm
| code:Rgb10A2
| code:R11fG11fB10f
| code:Rgba8
| code:Rg8
| code:R8
| code:Rgba8Snorm
| code:Rg8Snorm
| code:R8Snorm
| code:Rgba32i   .19+| code:OpTypeInt   .19+| 32     .9+| 1
| code:Rg32i
| code:R32i
| code:Rgba16i
| code:Rg16i
| code:R16i
| code:Rgba8i
| code:Rg8i
| code:R8i
| code:Rgba32ui                                     .10+| 0
| code:Rg32ui
| code:R32ui
| code:Rgba16ui
| code:Rg16ui
| code:R16ui
| code:Rgb10a2ui
| code:Rgba8ui
| code:Rg8ui
| code:R8ui
| code:R64i       .2+| code:OpTypeInt    .2+| 64        | 1
| code:R64ui                                            | 0
|===

[[spirv-type]]
The _SPIR-V Type_ is defined by an instruction in SPIR-V, declared with the
Type-Declaration Instruction, Bit Width, and Signedness from above.


[[spirvenv-image-dimensions]]
== Compatibility Between SPIR-V Image Dimensions and Vulkan ImageView Types

SPIR-V code:Image code:Dim values are compatible with slink:VkImageView
pname:viewType values as defined below:

.SPIR-V and Vulkan ImageView Dimension Compatibility
[cols="2*", options="header"]
|====
|SPIR-V Image Dim    |Compatible Vulkan ImageView viewTypes
| 1D | ename:VK_IMAGE_VIEW_TYPE_1D, ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY
| 2D | ename:VK_IMAGE_VIEW_TYPE_2D, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY
| 3D | ename:VK_IMAGE_VIEW_TYPE_3D
| Cube | ename:VK_IMAGE_VIEW_TYPE_CUBE, ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
|====


[[spirvenv-image-formats]]
== Compatibility Between SPIR-V Image Formats and Vulkan Formats

SPIR-V code:Image code:Format values are compatible with elink:VkFormat
values as defined below:

.SPIR-V and Vulkan Image Format Compatibility
[cols="2*", options="header"]
|====
|SPIR-V Image Format    |Compatible Vulkan Format
include::{generated}/formats/spirvimageformat.adoc[]
|====


ifdef::VK_KHR_ray_query+VK_KHR_ray_tracing_position_fetch[]
// TODO: add more Ray Query instructions here and move second ifdef down
[[spirenv-ray-query-precision-operation]]
== Ray Query Precision and Operation

The values returned by
code:OpRayQueryGetIntersectionTriangleVertexPositionsKHR are transformed by
the geometry transform, which is performed at standard
<<fundamentals-floating-point, floating-point>> precision, but without a
specifically defined order of floating-point operations to perform the
matrix multiplication.

endif::VK_KHR_ray_query+VK_KHR_ray_tracing_position_fetch[]

ifdef::VK_ARM_tensors[]
[[spirvenv-tensor-formats]]
== Compatibility Between SPIR-V Tensor Element Types And Vulkan Formats

SPIR-V Tensor code:Element code:Type values are compatible with
elink:VkFormat values as defined below:

.SPIR-V Tensor Element Type and Vulkan Format Compatibility
[cols="2*", options="header"]
|====
|SPIR-V Tensor Element Type    |Compatible Vulkan Formats
|code:OpTypeBool               |ename:VK_FORMAT_R8_BOOL_ARM
|`OpTypeFloat 16`              |ename:VK_FORMAT_R16_SFLOAT
|`OpTypeFloat 32`              |ename:VK_FORMAT_R32_SFLOAT
|`OpTypeFloat 64`              |ename:VK_FORMAT_R64_SFLOAT
|`OpTypeInt 8 0`               |ename:VK_FORMAT_R8_UINT
|`OpTypeInt 8 1`               |ename:VK_FORMAT_R8_SINT
|`OpTypeInt 16 0`              |ename:VK_FORMAT_R16_UINT
|`OpTypeInt 16 1`              |ename:VK_FORMAT_R16_SINT
|`OpTypeInt 32 0`              |ename:VK_FORMAT_R32_UINT
|`OpTypeInt 32 1`              |ename:VK_FORMAT_R32_SINT
|`OpTypeInt 64 0`              |ename:VK_FORMAT_R64_UINT
|`OpTypeInt 64 1`              |ename:VK_FORMAT_R64_SINT
|====
endif::VK_ARM_tensors[]
