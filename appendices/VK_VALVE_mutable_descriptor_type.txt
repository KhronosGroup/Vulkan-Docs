// Copyright (c) 2020 The Khronos Group Inc.
//
// SPDX-License-Identifier: CC-BY-4.0

include::{generated}/meta/{refprefix}VK_VALVE_mutable_descriptor_type.txt[]

=== Other Extension Metadata

*Last Modified Date*::
    2020-10-15
*IP Status*::
    No known IP claims.
*Contributors*::
  - Joshua Ashton, Valve
  - Hans-Kristian Arntzen, Valve

=== Description

This extension allows applications to reduce descriptor memory footprint by allowing a
descriptor to be able to mutate to a given list of descriptor types depending on which
descriptor types are written into, or copied into a descriptor set.

The main use case this extension intends to address is descriptor indexing with
ename:VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT, as this means applications
can allocate one large descriptor set, rather than having one large descriptor set per
descriptor type, which significantly bloats descriptor memory usage and causes
performance issues.

This extension also adds a mechanism to declare that a descriptor pool, and therefore
the descriptor sets that are allocated from it, reside only in host memory; as such these
descriptors can only be updated/copied, but not bound.

This allows much more efficient emulation of the binding model present in other
graphics APIs for layering or porting purposes.

include::{generated}/interfaces/VK_VALVE_mutable_descriptor_type.txt[]

=== Version History

 * Revision 1, 2020-10-15 (Joshua Ashton)
   - Initial draft

 * Revision 2, 2020-10-16 (Joshua Ashton)
   - Renamed the extension from VK_VALVE_generic_descriptors to
     VK_VALVE_mutable_descriptor_type
   - Updated appendix description to be more clear
   - Removed properties structure and rely on vkGetDescriptorSetLayoutSupport
     to determine which descriptor types are supported as mutable descriptors
   - Made descriptor type listings per-binding rather than per-layout
   - Improved documentation around various structures
   - Added missing definitions as to what causes undefined descriptors
     when copying between MUTABLE and MUTABLE, and MUTABLE and not MUTABLE
     (and vice versa.)
