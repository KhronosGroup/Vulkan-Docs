// WARNING: DO NOT MODIFY! This file is automatically generated from the vk.xml registry
ifndef::doctype-manpage[]
.Valid Usage
********************************************************************************
endif::doctype-manpage[]
ifdef::doctype-manpage[]
Valid Usage
-----------
endif::doctype-manpage[]
* pname:sType must: be ename:VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
* pname:pNext must: be `NULL`
* pname:flags must: be `0`
* pname:surface must: be a valid sname:VkSurfaceKHR handle
* pname:imageFormat must: be a valid elink:VkFormat value
* pname:imageColorSpace must: be a valid elink:VkColorSpaceKHR value
* pname:imageUsage must: be a valid combination of elink:VkImageUsageFlagBits values
* pname:imageUsage mustnot: be `0`
* pname:imageSharingMode must: be a valid elink:VkSharingMode value
* pname:preTransform must: be a valid elink:VkSurfaceTransformFlagBitsKHR value
* pname:compositeAlpha must: be a valid elink:VkCompositeAlphaFlagBitsKHR value
* pname:presentMode must: be a valid elink:VkPresentModeKHR value
* If pname:oldSwapchain is not dlink:VK_NULL_HANDLE, pname:oldSwapchain must: be a valid sname:VkSwapchainKHR handle
* If pname:oldSwapchain is a valid handle, it must: have been created, allocated or retrieved from pname:surface
* Each of pname:surface and pname:oldSwapchain that are valid handles must: have been created, allocated or retrieved from the same sname:VkInstance
* pname:surface must: be a surface that is supported by the device as determined using fname:vkGetPhysicalDeviceSurfaceSupportKHR
* The native window referred to by pname:surface mustnot: already be associated with a swapchain other than pname:oldSwapchain, or with a non-Vulkan graphics API surface
* pname:minImageCount must: be greater than or equal to the value returned in the pname:minImageCount member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
* pname:minImageCount must: be less than or equal to the value returned in the pname:maxImageCount member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface if the returned pname:maxImageCount is not zero
* pname:imageFormat and pname:imageColorspace must: match the pname:format and pname:colorSpace members, respectively, of one of the sname:VkSurfaceFormatKHR structures returned by fname:vkGetPhysicalDeviceSurfaceFormatsKHR for the surface
* pname:imageExtent must: be between pname:minImageExtent and pname:maxImageExtent, inclusive, where pname:minImageExtent and pname:maxImageExtent are members of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
* pname:imageArrayLayers must: be greater than `0` and less than or equal to the pname:maxImageArrayLayers member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
* pname:imageUsage must: be a subset of the supported usage flags present in the pname:supportedUsageFlags member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
* If pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:pQueueFamilyIndices must: be a pointer to an array of pname:queueFamilyIndexCount basetype:uint32_t values
* If pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:queueFamilyIndexCount must: be greater than `1`
* pname:preTransform must: be one of the bits present in the pname:supportedTransforms member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
* pname:compositeAlpha must: be one of the bits present in the pname:supportedCompositeAlpha member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
* pname:presentMode must: be one of the ename:VkPresentModeKHR values returned by fname:vkGetPhysicalDeviceSurfacePresentModesKHR for the surface
ifndef::doctype-manpage[]
********************************************************************************
endif::doctype-manpage[]

