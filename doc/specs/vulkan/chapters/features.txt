// Copyright (c) 2015-2016 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[features]]
= Features, Limits, and Formats

Vulkan is designed to support a wide range of hardware and as such there
are a number of features, limits, and formats which are not supported on all
hardware. Features describe functionality that is not required: and which
must: be explicitly enabled. Limits describe implementation-dependent
minimums, maximums, and other device characteristics that an application
may: need to be aware of. Supported buffer and image formats may: vary
across implementations. A minimum set of format features are guaranteed, but
others must: be explicitly queried before use to ensure they are supported
by the implementation.

[NOTE]
.Note on extensibility
====
The features and limits are reported via basic structures (that is
slink:VkPhysicalDeviceFeatures and slink:VkPhysicalDeviceLimits).
It is expected that when new features or limits are added in a future
Vulkan version, new structure(s) and entry point(s) will be added as
necessary to query these. New functionality added by
<<extended-functionality-extensions,extensions>> is not expected to
modify the core feature and limit structures.
====

[[features-features]]
== Features

The Specification defines a set of fine-grained features that are not
required:, but may: be supported by a Vulkan implementation. Support for
features is reported and enabled on a per-feature basis. Features are
properties of the physical device.

// refBegin vkGetPhysicalDeviceFeatures Reports capabilities of a physical device.

To query supported features, call:

include::../api/protos/vkGetPhysicalDeviceFeatures.txt[]

  * pname:physicalDevice is the physical device from which to query the
    supported features.
  * pname:pFeatures is a pointer to a slink:VkPhysicalDeviceFeatures
    structure in which the physical device features are returned. For each
    feature, a value of ename:VK_TRUE indicates that the feature is
    supported on this physical device, and ename:VK_FALSE indicates that the
    feature is not supported.

include::../validity/protos/vkGetPhysicalDeviceFeatures.txt[]

Fine-grained features used by a logical device must: be enabled at
sname:VkDevice creation time. If a feature is enabled that the physical
device does not support, sname:VkDevice creation will fail. If an
application uses a feature without enabling it at sname:VkDevice creation
time, the device behaviour is undefined. The validation layer will warn if
features are used without being enabled.

The fine-grained features are enabled by passing a pointer to the
sname:VkPhysicalDeviceFeatures structure via the pname:pEnabledFeatures
member of the sname:VkDeviceCreateInfo structure that is passed into the
fname:vkCreateDevice call. If a member of pname:pEnabledFeatures is set to
ename:VK_TRUE or ename:VK_FALSE, then the device will be created with the
indicated feature enabled or disabled, respectively.

If an application wishes to enable all features supported by a device, it
can: simply pass in the sname:VkPhysicalDeviceFeatures structure that was
previously returned by fname:vkGetPhysicalDeviceFeatures. To disable an
individual feature, the application can: set the desired member to
ename:VK_FALSE in the same structure. To disable all features which are not
required:, set pname:pEnabledFeatures to `NULL`.

[NOTE]
.Note
====
Some features, such as pname:robustBufferAccess, may: incur a run-time
performance cost. Application writers should: carefully consider the
implications of enabling all supported features.
====

// refBegin VkPhysicalDeviceFeatures Structure describing the fine-grained features that can be supported by an implementation.

The sname:VkPhysicalDeviceFeatures structure is defined as:

include::../api/structs/VkPhysicalDeviceFeatures.txt[]

The members of the sname:VkPhysicalDeviceFeatures structure describe the
following features:

  * [[features-features-robustBufferAccess]] pname:robustBufferAccess
    indicates that accesses to buffers are bounds-checked against the range of
    the buffer descriptor (as determined by
    sname:VkDescriptorBufferInfo::pname:range,
    sname:VkBufferViewCreateInfo::pname:range, or the size of the buffer). Out
    of bounds accesses mustnot: cause application termination, and the effects
    of shader loads, stores, and atomics must: conform to an
    implementation-dependent behavior as described below.
  ** A buffer access is considered to be out of bounds if any of the following
     are true:
  *** The pointer was formed by code:OpImageTexelPointer and the coordinate is
      less than zero or greater than or equal to the number of whole elements
      in the bound range.
  *** The pointer was not formed by code:OpImageTexelPointer and the object
      pointed to is not wholly contained within the bound range.
+
--
[NOTE]
.Note
====
If a SPIR-V code:OpLoad instruction loads a structure and the tail end of the
structure is out of bounds, then all members of the structure are considered
out of bounds even if the members at the end are not statically used.
====
--
+
  *** If any buffer access in a given SPIR-V block is determined to be
      out of bounds, then any other access of the same type (load, store, or
      atomic) in the same SPIR-V block that accesses an address less
      than 16 bytes away from the out of bounds address may: also be
      considered out of bounds.
  ** Out-of-bounds buffer loads will return any of the following values:
  *** Values from anywhere within the memory range(s) bound to the buffer
      (possibly including bytes of memory past the end of the buffer, up to
      the end of the bound range).
  *** Zero values, or (0,0,0,x) vectors for vector reads where x is a valid
      value represented in the type of the vector components and may: be any
      of:
  **** 0, 1, or the maximum representable positive integer value, for signed
       or unsigned integer components
  **** 0.0 or 1.0, for floating-point components
  ** Out-of-bounds writes may: modify values within the memory range(s) bound
     to the buffer, but mustnot: modify any other memory.
  ** Out-of-bounds atomics may: modify values within the memory range(s) bound
     to the buffer, but mustnot: modify any other memory, and return an
     undefined value.
  ** Vertex input attributes are considered out of bounds if the address of the
     attribute plus the size of the attribute is greater than the size of the
     bound buffer. Further, if any vertex input attribute using a specific
     vertex input binding is out of bounds, then all vertex input attributes
     using that vertex input binding for that vertex shader invocation are
     considered out of bounds.
  *** If a vertex input attribute is out of bounds, it will be assigned one
      of the following values:
  **** Values from anywhere within the memory range(s) bound to the buffer,
     converted according to the format of the attribute.
  **** Zero values, format converted according to the format of the attribute.
  **** Zero values, or (0,0,0,x) vectors, as described above.
  ** If pname:robustBufferAccess is not enabled, out of bounds accesses may:
     corrupt any memory within the process and cause undefined behaviour up
     to and including application termination.
  * [[features-features-fullDrawIndexUint32]] pname:fullDrawIndexUint32
    indicates the full 32-bit range of indices is supported for indexed draw
    calls when using a elink:VkIndexType of ename:VK_INDEX_TYPE_UINT32.
    pname:maxDrawIndexedIndexValue is the maximum index value that may: be
    used (aside from the primitive restart index, which is always 2^32^-1
    when the elink:VkIndexType is ename:VK_INDEX_TYPE_UINT32). If this
    feature is supported, pname:maxDrawIndexedIndexValue must: be 2^32^-1;
    otherwise it must: be no smaller than 2^24^-1. See
    <<features-limits-maxDrawIndexedIndexValue,maxDrawIndexedIndexValue>>.
  * [[features-features-imageCubeArray]] pname:imageCubeArray indicates
    whether image views with a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY can: be created, and that the
    corresponding code:SampledCubeArray and code:ImageCubeArray SPIR-V
    capabilities can: be used in shader code.
  * [[features-features-independentBlend]] pname:independentBlend indicates
    whether the sname:VkPipelineColorBlendAttachmentState settings are
    controlled independently per-attachment. If this feature is not enabled,
    the sname:VkPipelineColorBlendAttachmentState settings for all color
    attachments must: be identical. Otherwise, a different
    sname:VkPipelineColorBlendAttachmentState can: be provided for each
    bound color attachment.
  * [[features-features-geometryShader]] pname:geometryShader indicates
    whether geometry shaders are supported. If this feature is not enabled,
    the ename:VK_SHADER_STAGE_GEOMETRY_BIT and
    ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT enum values mustnot: be
    used. This also indicates whether shader modules can: declare the
    code:Geometry capability.
  * [[features-features-tessellationShader]] pname:tessellationShader
    indicates whether tessellation control and evaluation shaders are
    supported. If this feature is not enabled, the
    ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, and
    ename:VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO enum
    values mustnot: be used. This also indicates whether shader modules can:
    declare the code:Tessellation capability.
  * [[features-features-sampleRateShading]] pname:sampleRateShading
    indicates whether per-sample shading and multisample interpolation are
    supported. If this feature is not enabled, the pname:sampleShadingEnable
    member of the sname:VkPipelineMultisampleStateCreateInfo structure must:
    be set to ename:VK_FALSE and the pname:minSampleShading member is
    ignored. This also indicates whether shader modules can: declare the
    code:SampleRateShading capability.
  * [[features-features-dualSrcBlend]] pname:dualSrcBlend indicates whether
    blend operations which take two sources are supported. If this feature
    is not enabled, the ename:VK_BLEND_FACTOR_SRC1_COLOR,
    ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
    ename:VK_BLEND_FACTOR_SRC1_ALPHA, and
    ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA enum values mustnot: be used
    as source or destination blending factors. See <<framebuffer-dsb>>.
  * [[features-features-logicOp]] pname:logicOp indicates whether logic
    operations are supported. If this feature is not enabled, the
    pname:logicOpEnable member of the
    sname:VkPipelineColorBlendStateCreateInfo structure must: be set to
    ename:VK_FALSE, and the pname:logicOp member is ignored.
  * [[features-features-multiDrawIndirect]] pname:multiDrawIndirect
    indicates whether multiple draw indirect is supported. If this feature
    is not enabled, the pname:drawCount parameter to the
    fname:vkCmdDrawIndirect and fname:vkCmdDrawIndexedIndirect commands
    must: be 0 or 1. The pname:maxDrawIndirectCount member of the
    sname:VkPhysicalDeviceLimits structure must: also be 1 if this feature
    is not supported. See
    <<features-limits-maxDrawIndirectCount,maxDrawIndirectCount>>.
  * [[features-features-drawIndirectFirstInstance]]
    pname:drawIndirectFirstInstance indicates whether indirect draw calls
    support the pname:firstInstance parameter. If this feature is not
    enabled, the pname:firstInstance member of all
    sname:VkDrawIndirectCommand and sname:VkDrawIndexedIndirectCommand
    structures that are provided to the fname:vkCmdDrawIndirect and
    fname:vkCmdDrawIndexedIndirect commands must: be 0.
  * [[features-features-depthClamp]] pname:depthClamp indicates whether
    depth clamping is supported. If this feature is not enabled, the
    pname:depthClampEnable member of the
    sname:VkPipelineRasterizationStateCreateInfo structure must: be set to
    ename:VK_FALSE. Otherwise, setting pname:depthClampEnable to
    ename:VK_TRUE will enable depth clamping.
  * [[features-features-depthBiasClamp]] pname:depthBiasClamp indicates
    whether depth bias clamping is supported. If this feature is not
    enabled, the pname:depthBiasClamp member of the
    sname:VkPipelineRasterizationStateCreateInfo structure must: be set
    to 0.0 unless the VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state is enabled,
    and the pname:depthBiasClamp parameter to fname:vkCmdSetDepthBias must:
    be set to 0.0.
  * [[features-features-fillModeNonSolid]] pname:fillModeNonSolid indicates
    whether point and wireframe fill modes are supported. If this feature is
    not enabled, the ename:VK_POLYGON_MODE_POINT and
    ename:VK_POLYGON_MODE_LINE enum values mustnot: be used.
  * [[features-features-depthBounds]] pname:depthBounds indicates whether
    depth bounds tests are supported. If this feature is not enabled, the
    pname:depthBoundsTestEnable member of the
    sname:VkPipelineDepthStencilStateCreateInfo structure must: be set to
    ename:VK_FALSE. When pname:depthBoundsTestEnable is set to
    ename:VK_FALSE, the pname:minDepthBounds and
    pname:maxDepthBounds members of the
    sname:VkPipelineDepthStencilStateCreateInfo structure are ignored.
  * [[features-features-wideLines]] pname:wideLines indicates whether lines
    with width other than 1.0 are supported. If this feature is not enabled,
    the pname:lineWidth member of the
    sname:VkPipelineRasterizationStateCreateInfo structure must: be set
    to 1.0 unless the VK_DYNAMIC_STATE_LINE_WIDTH dynamic state is enabled,
    and the pname:lineWidth parameter to fname:vkCmdSetLineWidth must: be set
    to 1.0. When this feature is supported, the range and granularity of
    supported line widths are indicated by the pname:lineWidthRange and
    pname:lineWidthGranularity members of the sname:VkPhysicalDeviceLimits
    structure, respectively.
  * [[features-features-largePoints]] pname:largePoints indicates whether
    points with size greater than 1.0 are supported. If this feature is not
    enabled, only a point size of 1.0 written by a shader is supported. The
    range and granularity of supported point sizes are indicated by the
    pname:pointSizeRange and pname:pointSizeGranularity members of the
    sname:VkPhysicalDeviceLimits structure, respectively.
  * [[features-features-alphaToOne]] pname:alphaToOne indicates whether the
    implementation is able to replace the alpha value of the color fragment
    output from the fragment shader with the maximum representable alpha
    value for fixed-point colors or 1.0 for floating-point colors. If this
    feature is not enabled, then the pname:alphaToOneEnable member of the
    sname:VkPipelineMultisampleStateCreateInfo structure must: be set to
    ename:VK_FALSE. Otherwise setting pname:alphaToOneEnable to
    ename:VK_TRUE will enable alpha-to-one behaviour.
  * [[features-features-multiViewport]] pname:multiViewport indicates
    whether more than one viewport is supported. If this feature is not
    enabled, the pname:viewportCount and pname:scissorCount members of the
    sname:VkPipelineViewportStateCreateInfo structure must: be set to 1.
    Similarly, the pname:viewportCount parameter to the
    fname:vkCmdSetViewport command and the pname:scissorCount parameter to
    the fname:vkCmdSetScissor command must: be 1, and the
    pname:firstViewport parameter to the fname:vkCmdSetViewport command and
    the pname:firstScissor parameter to the fname:vkCmdSetScissor command
    must: be 0.
  * [[features-features-samplerAnisotropy]] pname:samplerAnisotropy
    indicates whether anisotropic filtering is supported. If this feature is
    not enabled, the pname:maxAnisotropy member of the
    sname:VkSamplerCreateInfo structure must: be 1.0.
  * [[features-features-textureCompressionETC2]]
    pname:textureCompressionETC2 indicates whether the ETC2 and EAC
    compressed texture formats are supported. If this feature is not
    enabled, the following formats mustnot: be used to create images:
+
--
* ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
* ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
* ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK
* ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
* ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK
* ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
* ename:VK_FORMAT_EAC_R11_UNORM_BLOCK
* ename:VK_FORMAT_EAC_R11_SNORM_BLOCK
* ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK
* ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK
--
+
flink:vkGetPhysicalDeviceFormatProperties is used to
check for the supported properties of individual formats.
+
  * [[features-features-textureCompressionASTC_LDR]]
    pname:textureCompressionASTC_LDR indicates whether the ASTC LDR
    compressed texture formats are supported. If this feature is not
    enabled, the following formats mustnot: be used to create images:
+
--
* ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK
* ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK
* ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK
* ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK
* ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK
* ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK
* ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK
* ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK
* ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK
* ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK
* ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK
* ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK
* ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK
* ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK
* ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK
--
+
flink:vkGetPhysicalDeviceFormatProperties is used to
check for the supported properties of individual formats.
+
  * [[features-features-textureCompressionBC]] pname:textureCompressionBC
    indicates whether the BC compressed texture formats are supported. If
    this feature is not enabled, the following formats mustnot: be used to
    create images:
+
--
* ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK
* ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK
* ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK
* ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK
* ename:VK_FORMAT_BC2_UNORM_BLOCK
* ename:VK_FORMAT_BC2_SRGB_BLOCK
* ename:VK_FORMAT_BC3_UNORM_BLOCK
* ename:VK_FORMAT_BC3_SRGB_BLOCK
* ename:VK_FORMAT_BC4_UNORM_BLOCK
* ename:VK_FORMAT_BC4_SNORM_BLOCK
* ename:VK_FORMAT_BC5_UNORM_BLOCK
* ename:VK_FORMAT_BC5_SNORM_BLOCK
* ename:VK_FORMAT_BC6H_UFLOAT_BLOCK
* ename:VK_FORMAT_BC6H_SFLOAT_BLOCK
* ename:VK_FORMAT_BC7_UNORM_BLOCK
* ename:VK_FORMAT_BC7_SRGB_BLOCK
--
+
flink:vkGetPhysicalDeviceFormatProperties is used to
check for the supported properties of individual formats.
+
  * [[features-features-occlusionQueryPrecise]] pname:occlusionQueryPrecise
    indicates whether occlusion queries returning actual sample counts are
    supported. Occlusion queries are created in a sname:VkQueryPool by
    specifying the pname:queryType of ename:VK_QUERY_TYPE_OCCLUSION in the
    sname:VkQueryPoolCreateInfo structure which is passed to
    fname:vkCreateQueryPool. If this feature is enabled, queries of this
    type can: enable ename:VK_QUERY_CONTROL_PRECISE_BIT in the pname:flags
    parameter to fname:vkCmdBeginQuery. If this feature is not supported,
    the implementation supports only boolean occlusion queries. When any
    samples are passed, boolean queries will return a non-zero result value,
    otherwise a result value of zero is returned. When this feature is
    enabled and ename:VK_QUERY_CONTROL_PRECISE_BIT is set, occlusion queries
    will report the actual number of samples passed.
  * [[features-features-pipelineStatisticsQuery]]
    pname:pipelineStatisticsQuery indicates whether the pipeline statistics
    queries are supported. If this feature is not enabled, queries of type
    ename:VK_QUERY_TYPE_PIPELINE_STATISTICS cannot: be created, and none of
    the elink:VkQueryPipelineStatisticFlagBits bits can: be set in the
    pname:pipelineStatistics member of the sname:VkQueryPoolCreateInfo
    structure.
  * [[features-features-vertexPipelineStoresAndAtomics]]
    pname:vertexPipelineStoresAndAtomics indicates whether storage buffers
    and images support stores and atomic operations in the vertex,
    tessellation, and geometry shader stages. If this feature is not
    enabled, all storage image, storage texel buffers, and storage buffer
    variables used by these stages in shader modules must: be decorated with
    the code:NonWriteable decoration (or the code:readonly memory qualifier
    in GLSL).
  * [[features-features-fragmentStoresAndAtomics]]
    pname:fragmentStoresAndAtomics indicates whether storage buffers and
    images support stores and atomic operations in the fragment shader
    stage. If this feature is not enabled, all storage image, storage texel
    buffers, and storage buffer variables used by the fragment stage in
    shader modules must: be decorated with the code:NonWriteable decoration
    (or the code:readonly memory qualifier in GLSL).
  * [[features-features-shaderTessellationAndGeometryPointSize]]
    pname:shaderTessellationAndGeometryPointSize indicates whether the
    code:PointSize built-in decoration is available in the tessellation
    control, tessellation evaluation, and geometry shader stages. If this
    feature is not enabled, members decorated with the code:PointSize
    built-in decoration mustnot: be read from or written to
    and all points written from a
    tessellation or geometry shader will have a size of 1.0. This also
    indicates whether shader modules can: declare the
    code:TessellationPointSize capability for tessellation control and
    evaluation shaders, or if the shader modules can: declare the
    code:GeometryPointSize capability for geometry shaders. An
    implementation supporting this feature must: also support one or both of
    the <<features-features-tessellationShader,pname:tessellationShader>> or
    <<features-features-geometryShader,pname:geometryShader>> features.
  * [[features-features-shaderImageGatherExtended]]
    pname:shaderImageGatherExtended indicates whether the extended set of
    image gather instructions are available in shader code. If this feature
    is not enabled, the code:OpImage*code:Gather instructions do not support
    the code:Offset and code:ConstOffsets operands. This also indicates
    whether shader modules can: declare the code:ImageGatherExtended
    capability.
  * [[features-features-shaderStorageImageExtendedFormats]]
    pname:shaderStorageImageExtendedFormats indicates whether the extended
    storage image formats are available in shader code. If this feature is
    not enabled, the formats requiring the code:StorageImageExtendedFormats
    capability are not supported for storage images. This also indicates
    whether shader modules can: declare the code:StorageImageExtendedFormats
    capability.
  * [[features-features-shaderStorageImageMultisample]]
    pname:shaderStorageImageMultisample indicates whether multisampled
    storage images are supported. If this feature is not enabled, images
    that are created with a pname:usage that includes
    ename:VK_IMAGE_USAGE_STORAGE_BIT must: be created with pname:samples
    equal to ename:VK_SAMPLE_COUNT_1_BIT. This also indicates whether shader
    modules can: declare the code:StorageImageMultisample capability.
  * [[features-features-shaderStorageImageReadWithoutFormat]]
    pname:shaderStorageImageReadWithoutFormat indicates whether storage
    images require a format qualifier to be specified when reading from
    storage images. If this feature is not enabled, the code:OpImageRead
    instruction mustnot: have an code:OpTypeImage of code:Unknown. This also
    indicates whether shader modules can: declare the
    code:StorageImageReadWithoutFormat capability.
  * [[features-features-shaderStorageImageWriteWithoutFormat]]
    pname:shaderStorageImageWriteWithoutFormat indicates whether storage
    images require a format qualifier to be specified when writing to
    storage images. If this feature is not enabled, the code:OpImageWrite
    instruction mustnot: have an code:OpTypeImage of code:Unknown. This also
    indicates whether shader modules can: declare the
    code:StorageImageWriteWithoutFormat capability.
  * [[features-features-shaderUniformBufferArrayDynamicIndexing]]
    pname:shaderUniformBufferArrayDynamicIndexing indicates whether arrays
    of uniform buffers can: be indexed by dynamically uniform integer
    expressions in shader code. If this feature is not enabled, resources
    with a descriptor type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code. This also indicates whether shader modules can: declare the
    code:UniformBufferArrayDynamicIndexing capability.
  * [[features-features-shaderSampledImageArrayDynamicIndexing]]
    pname:shaderSampledImageArrayDynamicIndexing indicates whether arrays of
    samplers or sampled images can: be indexed by dynamically uniform
    integer expressions in shader code. If this feature is not enabled,
    resources with a descriptor type of ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must: be indexed only by constant
    integral expressions when aggregated into arrays in shader code. This
    also indicates whether shader modules can: declare the
    code:SampledImageArrayDynamicIndexing capability.
  * [[features-features-shaderStorageBufferArrayDynamicIndexing]]
    pname:shaderStorageBufferArrayDynamicIndexing indicates whether arrays
    of storage buffers can: be indexed by dynamically uniform integer
    expressions in shader code. If this feature is not enabled, resources
    with a descriptor type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code. This also indicates whether shader modules can: declare the
    code:StorageBufferArrayDynamicIndexing capability.
  * [[features-features-shaderStorageImageArrayDynamicIndexing]]
    pname:shaderStorageImageArrayDynamicIndexing indicates whether arrays of
    storage images can: be indexed by dynamically uniform integer
    expressions in shader code. If this feature is not enabled, resources
    with a descriptor type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must:
    be indexed only by constant integral expressions when aggregated into
    arrays in shader code. This also indicates whether shader modules can:
    declare the code:StorageImageArrayDynamicIndexing capability.
  * [[features-features-shaderClipDistance]] pname:shaderClipDistance
    indicates whether clip distances are supported in shader code. If this
    feature is not enabled, any members decorated with the code:ClipDistance
    built-in decoration mustnot: be read from or written to in shader modules.
    This also indicates whether shader
    modules can: declare the code:ClipDistance capability.
  * [[features-features-shaderCullDistance]] pname:shaderCullDistance
    indicates whether cull distances are supported in shader code. If this
    feature is not enabled, any members decorated with the code:CullDistance
    built-in decoration mustnot: be read from or written to in shader modules.
    This also indicates whether shader
    modules can: declare the code:CullDistance capability.
  * [[features-features-shaderFloat64]] pname:shaderFloat64 indicates
    whether 64-bit floats (doubles) are supported in shader code. If this
    feature is not enabled, 64-bit floating-point types mustnot: be used in
    shader code. This also indicates whether shader modules can: declare the
    code:Float64 capability.
  * [[features-features-shaderInt64]] pname:shaderInt64 indicates whether
    64-bit integers (signed and unsigned) are supported in shader code. If
    this feature is not enabled, 64-bit integer types mustnot: be used in
    shader code. This also indicates whether shader modules can: declare the
    code:Int64 capability.
  * [[features-features-shaderInt16]] pname:shaderInt16 indicates whether
    16-bit integers (signed and unsigned) are supported in shader code. If
    this feature is not enabled, 16-bit integer types mustnot: be used in
    shader code. This also indicates whether shader modules can: declare the
    code:Int16 capability.
  * [[features-features-shaderResourceResidency]]
    pname:shaderResourceResidency indicates whether image operations that
    return resource residency information are supported in shader code. If
    this feature is not enabled, the code:OpImageSparse* instructions
    mustnot: be used in shader code. This also indicates whether shader
    modules can: declare the code:SparseResidency capability. The feature
    requires at least one of the ptext:sparseResidency* features to be
    supported.
  * [[features-features-shaderResourceMinLod]] pname:shaderResourceMinLod
    indicates whether image operations that specify the minimum resource
    level-of-detail (LOD) are supported in shader code. If this feature is
    not enabled, the code:MinLod image operand mustnot: be used in shader
    code. This also indicates whether shader modules can: declare the
    code:MinLod capability.
  * [[features-features-sparseBinding]] pname:sparseBinding indicates
    whether resource memory can: be managed at opaque sparse block level
    instead of at the object level. If this feature is not enabled, resource
    memory must: be bound only on a per-object basis using the
    fname:vkBindBufferMemory and fname:vkBindImageMemory commands. In this
    case, buffers and images mustnot: be created with
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT and
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in the pname:flags member
    of the sname:VkBufferCreateInfo and sname:VkImageCreateInfo structures,
    respectively. Otherwise resource memory can: be managed as described in
    <<sparsememory-sparseresourcefeatures,Sparse Resource Features>>.
  * [[features-features-sparseResidencyBuffer]] pname:sparseResidencyBuffer
    indicates whether the device can: access partially resident buffers. If
    this feature is not enabled, buffers mustnot: be created with
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags
    member of the sname:VkBufferCreateInfo structure.
  * [[features-features-sparseResidencyImage2D]]
    pname:sparseResidencyImage2D indicates whether the device can: access
    partially resident 2D images with 1 sample per pixel. If this feature is
    not enabled, images with an pname:imageType of ename:VK_IMAGE_TYPE_2D
    and pname:samples set to ename:VK_SAMPLE_COUNT_1_BIT mustnot: be created
    with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags
    member of the sname:VkImageCreateInfo structure.
  * [[features-features-sparseResidencyImage3D]]
    pname:sparseResidencyImage3D indicates whether the device can: access
    partially resident 3D images. If this feature is not enabled, images
    with an pname:imageType of ename:VK_IMAGE_TYPE_3D mustnot: be created
    with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags
    member of the sname:VkImageCreateInfo structure.
  * [[features-features-sparseResidency2Samples]]
    pname:sparseResidency2Samples indicates whether the physical device can:
    access partially resident 2D images with 2 samples per pixel. If this
    feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_2_BIT mustnot: be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-features-sparseResidency4Samples]]
    pname:sparseResidency4Samples indicates whether the physical device can:
    access partially resident 2D images with 4 samples per pixel. If this
    feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_4_BIT mustnot: be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-features-sparseResidency8Samples]]
    pname:sparseResidency8Samples indicates whether the physical device can:
    access partially resident 2D images with 8 samples per pixel. If this
    feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_8_BIT mustnot: be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-features-sparseResidency16Samples]]
    pname:sparseResidency16Samples indicates whether the physical device
    can: access partially resident 2D images with 16 samples per pixel. If
    this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_16_BIT mustnot: be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-features-sparseResidencyAliased]]
    pname:sparseResidencyAliased indicates whether the physical device can:
    correctly access data aliased into multiple locations. If this feature
    is not enabled, the ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT and
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT enum values mustnot: be used in
    pname:flags members of the sname:VkBufferCreateInfo and
    sname:VkImageCreateInfo structures, respectively.
  * [[features-features-variableMultisampleRate]]
    pname:variableMultisampleRate indicates whether all pipelines that will
    be bound to a command buffer during a subpass with no attachments must:
    have the same value for
    sname:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples.
    If set to ename:VK_TRUE, the implementation supports variable
    multisample rates in a subpass with no attachments. If set to
    ename:VK_FALSE, then all pipelines bound in such a subpass must: have
    the same multisample rate. This has no effect in situations where a
    subpass uses any attachments.
  * [[features-features-inheritedQueries]] pname:inheritedQueries indicates
    whether a secondary command buffer may: be executed while a query is
    active.

include::../validity/structs/VkPhysicalDeviceFeatures.txt[]


[[features-features-requirements]]
=== Feature Requirements

All Vulkan graphics implementations must: support the following features:

  * robustBufferAccess.

All other features are not required: by the Specification.


[[features-limits]]
== Limits

There are a variety of implementation-dependent limits.

The sname:VkPhysicalDeviceLimits are properties of the physical
device. These are available in the pname:limits member of the
slink:VkPhysicalDeviceProperties structure which is returned from
flink:vkGetPhysicalDeviceProperties.

// refBegin VkPhysicalDeviceLimits Structure

The sname:VkPhysicalDeviceLimits structure is defined as:

include::../api/structs/VkPhysicalDeviceLimits.txt[]

  * [[features-limits-maxImageDimension1D]] pname:maxImageDimension1D is the
    maximum dimension (pname:width) of an image created with an
    pname:imageType of ename:VK_IMAGE_TYPE_1D.
  * [[features-limits-maxImageDimension2D]] pname:maxImageDimension2D is the
    maximum dimension (pname:width or pname:height) of an image created with
    an pname:imageType of ename:VK_IMAGE_TYPE_2D and without
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.
  * [[features-limits-maxImageDimension3D]] pname:maxImageDimension3D is the
    maximum dimension (pname:width, pname:height, or pname:depth) of an
    image created with an pname:imageType of ename:VK_IMAGE_TYPE_3D.
  * [[features-limits-maxImageDimensionCube]] pname:maxImageDimensionCube is
    the maximum dimension (pname:width or pname:height) of an image created
    with an pname:imageType of ename:VK_IMAGE_TYPE_2D and with
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.
  * [[features-limits-maxImageArrayLayers]] pname:maxImageArrayLayers is the
    maximum number of layers (pname:arrayLayers) for an image.
  * [[features-limits-maxTexelBufferElements]] pname:maxTexelBufferElements
    is the maximum number of addressable texels for a buffer view created on
    a buffer which was created with the
    ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or
    ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the pname:usage
    member of the sname:VkBufferCreateInfo structure.
  * [[features-limits-maxUniformBufferRange]] pname:maxUniformBufferRange is
    the maximum value that can: be specified in the pname:range member of
    any slink:VkDescriptorBufferInfo structures passed to a call to
    flink:vkUpdateDescriptorSets for descriptors of type
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.
  * [[features-limits-maxStorageBufferRange]] pname:maxStorageBufferRange is
    the maximum value that can: be specified in the pname:range member of
    any slink:VkDescriptorBufferInfo structures passed to a call to
    flink:vkUpdateDescriptorSets for descriptors of type
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.
  * [[features-limits-maxPushConstantsSize]] pname:maxPushConstantsSize is
    the maximum size, in bytes, of the pool of push constant memory. For
    each of the push constant ranges indicated by the
    pname:pPushConstantRanges member of the sname:VkPipelineLayoutCreateInfo
    structure, pname:offset + pname:size must: be less than or equal to this
    limit.
  * [[features-limits-maxMemoryAllocationCount]]
    pname:maxMemoryAllocationCount is the maximum number of device memory
    allocations, as created by flink:vkAllocateMemory, which can:
    simultaneously exist.
  * [[features-limits-maxSamplerAllocationCount]]
    pname:maxSamplerAllocationCount is the maximum number of sampler
    objects, as created by flink:vkCreateSampler, which can: simultaneously
    exist on a device.
  * [[features-limits-bufferImageGranularity]] pname:bufferImageGranularity
    is the granularity, in bytes, at which buffer or linear image resources,
    and optimal image resources can: be bound to adjacent offsets in the same
    sname:VkDeviceMemory object without aliasing. See
    <<resources-bufferimagegranularity,Buffer-Image Granularity>> for more
    details.
  * [[features-limits-sparseAddressSpaceSize]] pname:sparseAddressSpaceSize
    is the total amount of address space available, in bytes, for sparse
    memory resources. This is an upper bound on the sum of the size of all
    sparse resources, regardless of whether any memory is bound to them.
  * [[features-limits-maxBoundDescriptorSets]] pname:maxBoundDescriptorSets
    is the maximum number of descriptor sets that can: be simultaneously
    used by a pipeline. All code:DescriptorSet decorations in shader modules
    must: have a value less than pname:maxBoundDescriptorSets. See
    <<descriptorsets-sets>>.
  * [[features-limits-maxPerStageDescriptorSamplers]]
    pname:maxPerStageDescriptorSamplers is the maximum number of samplers
    that can: be accessible to a single shader stage in a pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this
    limit. A descriptor is accessible to a shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set. See
    <<descriptorsets-sampler>> and <<descriptorsets-combinedimagesampler>>.
  * [[features-limits-maxPerStageDescriptorUniformBuffers]]
    pname:maxPerStageDescriptorUniformBuffers is the maximum number of
    uniform buffers that can: be accessible to a single shader stage in a
    pipeline layout. Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
    limit. A descriptor is accessible to a shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set. See
    <<descriptorsets-uniformbuffer>> and
    <<descriptorsets-uniformbufferdynamic>>.
  * [[features-limits-maxPerStageDescriptorStorageBuffers]]
    pname:maxPerStageDescriptorStorageBuffers is the maximum number of
    storage buffers that can: be accessible to a single shader stage in a
    pipeline layout. Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
    limit. A descriptor is accessible to a pipeline shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set. See
    <<descriptorsets-storagebuffer>> and
    <<descriptorsets-storagebufferdynamic>>.
  * [[features-limits-maxPerStageDescriptorSampledImages]]
    pname:maxPerStageDescriptorSampledImages is the maximum number of
    sampled images that can: be accessible to a single shader stage in a
    pipeline layout. Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit.
    A descriptor is accessible to a pipeline shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set. See
    <<descriptorsets-combinedimagesampler>>,
    <<descriptorsets-sampledimage>>, and
    <<descriptorsets-uniformtexelbuffer>>.
  * [[features-limits-maxPerStageDescriptorStorageImages]]
    pname:maxPerStageDescriptorStorageImages is the maximum number of
    storage images that can: be accessible to a single shader stage in a
    pipeline layout. Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit.
    A descriptor is accessible to a pipeline shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set. See
    <<descriptorsets-storageimage>>, and
    <<descriptorsets-storagetexelbuffer>>.
  * [[features-limits-maxPerStageDescriptorInputAttachments]]
    pname:maxPerStageDescriptorInputAttachments is the maximum number of
    input attachments that can: be accessible to a single shader stage in a
    pipeline layout. Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit.
    A descriptor is accessible to a pipeline shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set. These are only
    supported for the fragment stage. See
    <<descriptorsets-inputattachment>>.
  * [[features-limits-maxPerStageResources]] pname:maxPerStageResources is
    the maximum number of resources that can: be accessible to a single
    shader stage in a pipeline layout. Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, or
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. For
    the fragment shader stage the framebuffer color attachments also count
    against this limit.
  * [[features-limits-maxDescriptorSetSamplers]]
    pname:maxDescriptorSetSamplers is the maximum number of samplers that
    can: be included in descriptor bindings in a pipeline layout across all
    pipeline shader stages and descriptor set numbers. Descriptors with a
    type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this
    limit. See <<descriptorsets-sampler>> and
    <<descriptorsets-combinedimagesampler>>.
  * [[features-limits-maxDescriptorSetUniformBuffers]]
    pname:maxDescriptorSetUniformBuffers is the maximum number of uniform
    buffers that can: be included in descriptor bindings in a pipeline
    layout across all pipeline shader stages and descriptor set numbers.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
    limit. See <<descriptorsets-uniformbuffer>> and
    <<descriptorsets-uniformbufferdynamic>>.
  * [[features-limits-maxDescriptorSetUniformBuffersDynamic]]
    pname:maxDescriptorSetUniformBuffersDynamic is the maximum number of
    dynamic uniform buffers that can: be included in descriptor bindings in
    a pipeline layout across all pipeline shader stages and descriptor set
    numbers. Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
    limit. See <<descriptorsets-uniformbufferdynamic>>.
  * [[features-limits-maxDescriptorSetStorageBuffers]]
    pname:maxDescriptorSetStorageBuffers is the maximum number of storage
    buffers that can: be included in descriptor bindings in a pipeline
    layout across all pipeline shader stages and descriptor set numbers.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
    limit. See <<descriptorsets-storagebuffer>> and
    <<descriptorsets-storagebufferdynamic>>.
  * [[features-limits-maxDescriptorSetStorageBuffersDynamic]]
    pname:maxDescriptorSetStorageBuffersDynamic is the maximum number of
    dynamic storage buffers that can: be included in descriptor bindings
    in a pipeline layout across all pipeline shader stages and descriptor
    set numbers. Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
    limit. See <<descriptorsets-storagebufferdynamic>>.
  * [[features-limits-maxDescriptorSetSampledImages]]
    pname:maxDescriptorSetSampledImages is the maximum number of sampled
    images that can: be included in descriptor bindings in a pipeline
    layout across all pipeline shader stages and descriptor set numbers.
    Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit.
    See <<descriptorsets-combinedimagesampler>>,
    <<descriptorsets-sampledimage>>, and
    <<descriptorsets-uniformtexelbuffer>>.
  * [[features-limits-maxDescriptorSetStorageImages]]
    pname:maxDescriptorSetStorageImages is the maximum number of storage
    images that can: be included in descriptor bindings in a pipeline
    layout across all pipeline shader stages and descriptor set numbers.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit.
    See <<descriptorsets-storageimage>>, and
    <<descriptorsets-storagetexelbuffer>>.
  * [[features-limits-maxDescriptorSetInputAttachments]]
    pname:maxDescriptorSetInputAttachments is the maximum number of input
    attachments that can: be included in descriptor bindings in a
    pipeline layout across all pipeline shader stages and descriptor set
    numbers. Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. See
    <<descriptorsets-inputattachment>>.
  * [[features-limits-maxVertexInputAttributes]]
    pname:maxVertexInputAttributes is the maximum number of vertex input
    attributes that can: be specified for a graphics pipeline. These are
    described in the array of sname:VkVertexInputAttributeDescription
    structures that are provided at graphics pipeline creation time via the
    pname:pVertexAttributeDescriptions member of the
    sname:VkPipelineVertexInputStateCreateInfo structure. See
    <<fxvertex-attrib>> and <<fxvertex-input>>.
  * [[features-limits-maxVertexInputBindings]]
    pname:maxVertexInputBindings is the maximum number of vertex buffers
    that can: be specified for providing vertex attributes to a graphics
    pipeline. These are described in the array of
    sname:VkVertexInputBindingDescription structures that are provided at
    graphics pipeline creation time via the pname:pVertexBindingDescriptions
    member of the sname:VkPipelineVertexInputStateCreateInfo structure. The
    pname:binding member of sname:VkVertexInputBindingDescription must: be
    less than this limit. See <<fxvertex-input>>.
  * [[features-limits-maxVertexInputAttributeOffset]]
    pname:maxVertexInputAttributeOffset is the maximum vertex input
    attribute offset that can: be added to the vertex input binding stride.
    The pname:offset member of the sname:VkVertexInputAttributeDescription
    structure must: be less than or equal to this limit. See
    <<fxvertex-input>>.
  * [[features-limits-maxVertexInputBindingStride]]
    pname:maxVertexInputBindingStride is the maximum vertex input binding
    stride that can: be specified in a vertex input binding. The
    pname:stride member of the sname:VkVertexInputBindingDescription
    structure must: be less than or equal to this limit. See
    <<fxvertex-input>>.
  * [[features-limits-maxVertexOutputComponents]]
    pname:maxVertexOutputComponents is the maximum number of components of
    output variables which can: be output by a vertex shader. See
    <<shaders-vertex>>.
  * [[features-limits-maxTessellationGenerationLevel]]
    pname:maxTessellationGenerationLevel is the maximum tessellation
    generation level supported by the fixed-function tessellation primitive
    generator. See <<tessellation>>.
  * [[features-limits-maxTessellationPatchSize]]
    pname:maxTessellationPatchSize is the maximum patch size, in vertices,
    of patches that can: be processed by the tessellation control shader and
    tessellation primitive generator. The
    pname:patchControlPoints member of the
    sname:VkPipelineTessellationStateCreateInfo structure specified at
    pipeline creation time and the value provided in the code:OutputVertices
    execution mode of shader modules must: be less than or equal to this
    limit. See <<tessellation>>.
  * [[features-limits-maxTessellationControlPerVertexInputComponents]]
    pname:maxTessellationControlPerVertexInputComponents is the maximum
    number of components of input variables which can: be provided as
    per-vertex inputs to the tessellation control shader stage.
  * [[features-limits-maxTessellationControlPerVertexOutputComponents]]
    pname:maxTessellationControlPerVertexOutputComponents is the maximum
    number of components of per-vertex output variables which can: be output
    from the tessellation control shader stage.
  * [[features-limits-maxTessellationControlPerPatchOutputComponents]]
    pname:maxTessellationControlPerPatchOutputComponents is the maximum
    number of components of per-patch output variables which can: be output
    from the tessellation control shader stage.
  * [[features-limits-maxTessellationControlTotalOutputComponents]]
    pname:maxTessellationControlTotalOutputComponents is the maximum total
    number of components of per-vertex and per-patch output variables which
    can: be output from the tessellation control shader stage.
  * [[features-limits-maxTessellationEvaluationInputComponents]]
    pname:maxTessellationEvaluationInputComponents is the maximum number of
    components of input variables which can: be provided as per-vertex
    inputs to the tessellation evaluation shader stage.
  * [[features-limits-maxTessellationEvaluationOutputComponents]]
    pname:maxTessellationEvaluationOutputComponents is the maximum number of
    components of per-vertex output variables which can: be output from the
    tessellation evaluation shader stage.
  * [[features-limits-maxGeometryShaderInvocations]]
    pname:maxGeometryShaderInvocations is the maximum invocation count
    supported for instanced geometry shaders. The value provided in the
    code:Invocations execution mode of shader modules must: be less than
    or equal to this limit. See <<geometry>>.
  * [[features-limits-maxGeometryInputComponents]]
    pname:maxGeometryInputComponents is the maximum number of components of
    input variables which can: be provided as inputs to the geometry shader
    stage.
  * [[features-limits-maxGeometryOutputComponents]]
    pname:maxGeometryOutputComponents is the maximum number of components of
    output variables which can: be output from the geometry shader stage.
  * [[features-limits-maxGeometryOutputVertices]]
    pname:maxGeometryOutputVertices is the maximum number of vertices which
    can: be emitted by any geometry shader.
  * [[features-limits-maxGeometryTotalOutputComponents]]
    pname:maxGeometryTotalOutputComponents is the maximum total number of
    components of output, across all emitted vertices, which can: be output
    from the geometry shader stage.
  * [[features-limits-maxFragmentInputComponents]]
    pname:maxFragmentInputComponents is the maximum number of components of
    input variables which can: be provided as inputs to the fragment shader
    stage.
  * [[features-limits-maxFragmentOutputAttachments]]
    pname:maxFragmentOutputAttachments is the maximum number of output
    attachments which can: be written to by the fragment shader stage.
  * [[features-limits-maxFragmentDualSrcAttachments]]
    pname:maxFragmentDualSrcAttachments is the maximum number of output
    attachments which can: be written to by the fragment shader stage when
    blending is enabled and one of the dual source blend modes is in use.
    See <<framebuffer-dsb>> and
    <<features-features-dualSrcBlend,dualSrcBlend>>.
  * [[features-limits-maxFragmentCombinedOutputResources]]
    pname:maxFragmentCombinedOutputResources is the total number of storage
    buffers, storage images, and output buffers which can: be used in the
    fragment shader stage.
  * [[features-limits-maxComputeSharedMemorySize]]
    pname:maxComputeSharedMemorySize is the maximum total storage size, in
    bytes, of all variables declared with the code:WorkgroupLocal storage
    class in shader modules (or with the code:shared storage qualifier in
    GLSL) in the compute shader stage.
  * [[features-limits-maxComputeWorkGroupCount]]
    pname:maxComputeWorkGroupCount[3] is the maximum number of local workgroups
    that can: be dispatched by a single dispatch command. These three values
    represent the maximum number of local workgroups for the X, Y, and Z
    dimensions, respectively. The pname:x, pname:y, and pname:z parameters
    to the flink:vkCmdDispatch command, or members of the
    slink:VkDispatchIndirectCommand structure must: be less than or equal to
    the corresponding limit. See <<dispatch>>.
  * [[features-limits-maxComputeWorkGroupInvocations]]
    pname:maxComputeWorkGroupInvocations is the maximum total number of
    compute shader invocations in a single local workgroup. The product of
    the X, Y, and Z sizes as specified by the code:LocalSize execution mode
    in shader modules and by the object decorated by the code:WorkgroupSize
    decoration must: be less than or equal to this limit.
  * [[features-limits-maxComputeWorkGroupSize]]
    pname:maxComputeWorkGroupSize[3] is the maximum size of a local compute
    workgroup, per dimension. These three values represent the maximum
    local workgroup size in the X, Y, and Z dimensions, respectively. The
    pname:x, pname:y, and pname:z sizes specified by the code:LocalSize
    execution mode and by the object decorated by the code:WorkgroupSize
    decoration in shader modules must: be less than or equal to the
    corresponding limit.
  * [[features-limits-subPixelPrecisionBits]] pname:subPixelPrecisionBits is
    the number of bits of subpixel precision in framebuffer coordinates
    latexmath:[$x_f$] and latexmath:[$y_f$]. See <<primsrast>>.
  * [[features-limits-subTexelPrecisionBits]] pname:subTexelPrecisionBits is
    the number of bits of precision in the division along an axis of an
    image used for minification and magnification filters.
    latexmath:[$2^\mathit{subTexelPrecisionBits}$] is the actual number of
    divisions along each axis of the image represented. The filtering
    hardware will snap to these locations when computing the filtered
    results.
  * [[features-limits-mipmapPrecisionBits]] pname:mipmapPrecisionBits is the
    number of bits of division that the LOD calculation for mipmap fetching
    get snapped to when determining the contribution from each miplevel to
    the mip filtered results. latexmath:[$2^\mathit{mipmapPrecisionBits}$] is
    the actual number of divisions.
+
--
[NOTE]
.Note
====
For example, if this value is 2 bits then when linearly filtering between
two levels, each level could: contribute: 0%, 33%, 66%, or 100% (this is
just an example and the amount of contribution should: be covered by
different equations in the spec).
====
--
+
  * [[features-limits-maxDrawIndexedIndexValue]]
    pname:maxDrawIndexedIndexValue is the maximum index value that can: be
    used for indexed draw calls when using 32-bit indices. This excludes the
    primitive restart index value of 0xFFFFFFFF. See
    <<features-features-fullDrawIndexUint32,fullDrawIndexUint32>>.
  * [[features-limits-maxDrawIndirectCount]] pname:maxDrawIndirectCount is
    the maximum draw count that is supported for indirect draw calls. See
    <<features-features-multiDrawIndirect,multiDrawIndirect>>.
  * [[features-limits-maxSamplerLodBias]] pname:maxSamplerLodBias is the
    maximum absolute sampler level of detail bias. The sum of the
    pname:mipLodBias member of the sname:VkSamplerCreateInfo structure and
    the code:Bias operand of image sampling operations in shader modules (or
    0 if no code:Bias operand is provided to an image sampling operation)
    are clamped to the range
    latexmath:[$[-\mathit{maxSamplerLodBias},+\mathit{maxSamplerLodBias}\]$].
    See <<samplers-mipLodBias>>.
  * [[features-limits-maxSamplerAnisotropy]] pname:maxSamplerAnisotropy is
    the maximum degree of sampler anisotropy. The maximum degree of
    anisotropic filtering used for an image sampling operation is the
    minimum of the pname:maxAnisotropy member of the
    sname:VkSamplerCreateInfo structure and this limit. See
    <<samplers-maxAnisotropy>>.
  * [[features-limits-maxViewports]] pname:maxViewports is the maximum
    number of active viewports. The pname:viewportCount member of the
    sname:VkPipelineViewportStateCreateInfo structure that is provided at
    pipeline creation must: be less than or equal to this limit.
  * [[features-limits-maxViewportDimensions]] pname:maxViewportDimensions[2]
    are the maximum viewport dimensions in the X (width) and Y (height)
    dimensions, respectively. The maximum viewport dimensions must: be
    greater than or equal to the largest image
    which can: be created and used as a framebuffer attachment. See
    <<vertexpostproc-viewport,Controlling the Viewport>>.
  * [[features-limits-viewportboundsrange]] pname:viewportBoundsRange[2] is
    the latexmath:[$[\mathit{minimum},\mathit{maximum}\]$] range that the
    corners of a viewport must: be contained in. This range must: be at
    least latexmath:[$[- 2 \times \mathit{maxViewportDimensions},
                       2 \times \mathit{maxViewportDimensions} - 1\]$].
    See <<vertexpostproc-viewport,Controlling the Viewport>>.
+
--
[NOTE]
.Note
====
The intent of the pname:viewportBoundsRange limit is to allow a maximum sized
viewport to be arbitrarily shifted relative to the output target as long
as at least some portion intersects. This would give a bounds limit of
latexmath:[$[- \mathit{maxViewportDimensions}+1,
             2 \times \mathit{maxViewportDimensions} -1\]$] which would allow
all possible non-empty-set intersections of the output target and the viewport.
Since these numbers are typically powers of two, picking the signed number
range using the smalled possible number of bits, ends up with the specified
range.
====
--
  * [[features-limits-viewportSubPixelBits]] pname:viewportSubPixelBits is
    the number of bits of subpixel precision for viewport bounds. The
    subpixel precision that floating-point viewport bounds are interpreted
    at is given by this limit.
  * [[features-limits-minMemoryMapAlignment]] pname:minMemoryMapAlignment is
    the minimum required alignment, in bytes, of host visible memory
    allocations within the host address space. When mapping a memory
    allocation with flink:vkMapMemory, subtracting pname:offset bytes from
    the returned pointer will always produce an integer multiple of this
    limit. See <<memory-device-hostaccess>>.
  * [[features-limits-minTexelBufferOffsetAlignment]]
    pname:minTexelBufferOffsetAlignment is the minimum required alignment,
    in bytes, for the pname:offset member of the
    sname:VkBufferViewCreateInfo structure for texel buffers. When a buffer
    view is created for a buffer which was created with
    ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or
    ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the pname:usage
    member of the sname:VkBufferCreateInfo structure, the pname:offset must:
    be an integer multiple of this limit.
  * [[features-limits-minUniformBufferOffsetAlignment]]
    pname:minUniformBufferOffsetAlignment is the minimum required alignment,
    in bytes, for the pname:offset member of the
    sname:VkDescriptorBufferInfo structure for uniform buffers. When a
    descriptor of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC is updated, the
    pname:offset must: be an integer multiple of this limit. Similarly,
    dynamic offsets for uniform buffers must: be multiples of this limit.
  * [[features-limits-minStorageBufferOffsetAlignment]]
    pname:minStorageBufferOffsetAlignment is the minimum required alignment,
    in bytes, for the pname:offset member of the
    sname:VkDescriptorBufferInfo structure for storage buffers. When a
    descriptor of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC is updated, the
    pname:offset must: be an integer multiple of this limit. Similarly,
    dynamic offsets for storage buffers must: be multiples of this limit.
  * [[features-limits-minTexelOffset]] pname:minTexelOffset is the minimum
    offset value for the code:ConstOffset image operand of any of the
    code:OpImageSample* or code:OpImageFetch* image instructions.
  * [[features-limits-maxTexelOffset]] pname:maxTexelOffset is the maximum
    offset value for the code:ConstOffset image operand of any of the
    code:OpImageSample* or code:OpImageFetch* image instructions.
  * [[features-limits-minTexelGatherOffset]] pname:minTexelGatherOffset is
    the minimum offset value for the code:Offset or code:ConstOffsets image
    operands of any of the code:OpImage*code:Gather image instructions.
  * [[features-limits-maxTexelGatherOffset]] pname:maxTexelGatherOffset is
    the maximum offset value for the code:Offset or code:ConstOffsets image
    operands of any of the code:OpImage*code:Gather image instructions.
  * [[features-limits-minInterpolationOffset]] pname:minInterpolationOffset
    is the minimum negative offset value for the code:offset operand of the
    code:InterpolateAtOffset extended instruction.
  * [[features-limits-maxInterpolationOffset]] pname:maxInterpolationOffset
    is the maximum positive offset value for the code:offset operand of the
    code:InterpolateAtOffset extended instruction.
  * [[features-limits-subPixelInterpolationOffsetBits]]
    pname:subPixelInterpolationOffsetBits is the number of subpixel
    fractional bits that the code:x and code:y offsets to the
    code:InterpolateAtOffset extended instruction may: be rounded to as
    fixed-point values.
  * [[features-limits-maxFramebufferWidth]] pname:maxFramebufferWidth is the
    maximum width for a framebuffer. The pname:width member of the
    sname:VkFramebufferCreateInfo structure must: be less than or equal to
    this limit.
  * [[features-limits-maxFramebufferHeight]] pname:maxFramebufferHeight is
    the maximum height for a framebuffer. The pname:height member of the
    sname:VkFramebufferCreateInfo structure must: be less than or equal to
    this limit.
  * [[features-limits-maxFramebufferLayers]] pname:maxFramebufferLayers is
    the maximum layer count for a layered framebuffer. The pname:layers
    member of the sname:VkFramebufferCreateInfo structure must: be less than
    or equal to this limit.
  * [[features-limits-framebufferColorSampleCounts]]
    pname:framebufferColorSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits bits indicating the color sample counts that
    are supported for all framebuffer color attachments.
  * [[features-limits-framebufferDepthSampleCounts]]
    pname:framebufferDepthSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits bits indicating the supported depth sample
    counts for all framebuffer depth/stencil attachments, when the format
    includes a depth component.
  * pname:framebufferStencilSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits bits indicating the supported stencil sample
    counts for all framebuffer depth/stencil attachments, when the format
    includes a stencil component.
  * pname:framebufferNoAttachmentsSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits bits indicating the supported sample counts
    for a framebuffer with no attachments.
  * [[features-limits-maxColorAttachments]] pname:maxColorAttachments is the
    maximum number of color attachments that can: be used by a subpass in a
    render pass. The pname:colorAttachmentCount member of the
    sname:VkSubpassDescription structure must: be less than or equal to this
    limit.
  * [[features-limits-sampledImageColorSampleCounts]]
    pname:sampledImageColorSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits bits indicating the sample counts supported
    for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage
    containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a non-integer color
    format.
  * [[features-limits-sampledImageIntegerSampleCounts]]
    pname:sampledImageIntegerSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits bits indicating the sample counts supported
    for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage
    containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and an integer color
    format.
  * [[features-limits-sampledImageDepthSampleCounts]]
    pname:sampledImageDepthSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits bits indicating the sample counts supported
    for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage
    containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a depth format.
  * [[features-limits-sampledImageStencilSampleCounts]]
    pname:sampledImageStencilSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits bits indicating the sample supported
    for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage
    containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a stencil format.
  * [[features-limits-storageImageSampleCounts]]
    pname:storageImageSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits bits indicating the sample counts supported
    for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, and
    pname:usage containing ename:VK_IMAGE_USAGE_STORAGE_BIT.
  * [[features-limits-maxSampleMaskWords]] pname:maxSampleMaskWords is the
    maximum number of array elements of a variable decorated with the
    code:SampleMask built-in decoration.
  * [[features-limits-timestampComputeAndGraphics]]
    pname:timestampComputeAndGraphics indicates support for timestamps on
    all graphics and compute queues. If this limit is set to ename:VK_TRUE,
    all queues that advertise the ename:VK_QUEUE_GRAPHICS_BIT or
    ename:VK_QUEUE_COMPUTE_BIT in the
    sname:VkQueueFamilyProperties::pname:queueFlags support
    sname:VkQueueFamilyProperties::pname:timestampValidBits of at least 36.
    See <<queries-timestamps, Timestamp Queries>>.
  * [[features-limits-timestampPeriod]] pname:timestampPeriod is the number
    of nanoseconds required for a timestamp query to be incremented by 1.
    See <<queries-timestamps, Timestamp Queries>>.
  * [[features-limits-maxClipDistances]] pname:maxClipDistances is the
    maximum number of clip distances that can: be used in a single shader
    stage. The size of any array declared with the code:ClipDistance
    built-in decoration in a shader module must: be less than or equal to
    this limit.
  * [[features-limits-maxCullDistances]] pname:maxCullDistances is the
    maximum number of cull distances that can: be used in a single shader
    stage. The size of any array declared with the code:CullDistance
    built-in decoration in a shader module must: be less than or equal to
    this limit.
  * [[features-limits-maxCombinedClipAndCullDistances]]
    pname:maxCombinedClipAndCullDistances is the maximum combined number of
    clip and cull distances that can: be used in a single shader stage.
    The sum of the sizes of any pair of arrays declared with the
    code:ClipDistance and code:CullDistance built-in decoration used by
    a single shader stage in a shader module must: be less than or equal to
    this limit.
  * [[features-limits-discreteQueuePriorities]]
    pname:discreteQueuePriorities is the number of discrete priorities that
    can: be assigned to a queue based on the value of each member of
    sname:VkDeviceQueueCreateInfo::pname:pQueuePriorities. This must: be at
    least 2, and levels must: be spread evenly over the range, with at least
    one level at 1.0, and another at 0.0. See <<devsandqueues-priority>>.
  * [[features-limits-pointSizeRange]] pname:pointSizeRange[2] is the range
    latexmath:[$[\mathit{minimum},\mathit{maximum}\]$] of supported sizes
    for points. Values written to variables decorated with the
    code:PointSize built-in decoration are clamped to this range.
  * [[features-limits-lineWidthRange]] pname:lineWidthRange[2] is the range
    latexmath:[$[\mathit{minimum},\mathit{maximum}\]$] of supported widths
    for lines. Values specified by the pname:lineWidth member of the
    sname:VkPipelineRasterizationStateCreateInfo or the pname:lineWidth
    parameter to fname:vkCmdSetLineWidth are clamped to this range.
  * [[features-limits-pointSizeGranularity]] pname:pointSizeGranularity is
    the granularity of supported point sizes. Not all point sizes in the
    range defined by pname:pointSizeRange are supported. This limit
    specifies the granularity (or increment) between successive supported
    point sizes.
  * [[features-limits-lineWidthGranularity]] pname:lineWidthGranularity is
    the granularity of supported line widths. Not all line widths in the
    range defined by pname:lineWidthRange are supported. This limit
    specifies the granularity (or increment) between successive supported
    line widths.
  * [[features-limits-strictLines]] pname:strictLines indicates whether
    lines are rasterized according to the preferred method of rasterization.
    If set to ename:VK_FALSE, lines may: be rasterized under a relaxed set
    of rules. If set to ename:VK_TRUE, lines are rasterized as per the
    strict definition. See <<primsrast-lines-basic,Basic Line Segment
    Rasterization>>.
  * [[features-limits-standardSampleLocations]]
    pname:standardSampleLocations indicates whether rasterization uses the
    standard sample locations as documented in
    <<primsrast-multisampling,Multisampling>>. If set to ename:VK_TRUE, the
    implementation uses the documented sample locations. If set to
    ename:VK_FALSE, the implementation may: use different sample locations.
  * [[features-limits-optimalBufferCopyOffsetAlignment]]
    pname:optimalBufferCopyOffsetAlignment is the optimal buffer
    offset alignment in bytes for fname:vkCmdCopyBufferToImage and
    fname:vkCmdCopyImageToBuffer. The per texel alignment requirements are
    still enforced, this is just an additional alignment recommendation for
    optimal performance and power.
  * [[features-limits-optimalBufferCopyRowPitchAlignment]]
    pname:optimalBufferCopyRowPitchAlignment is the optimal buffer
    row pitch alignment in bytes for fname:vkCmdCopyBufferToImage and
    fname:vkCmdCopyImageToBuffer. Row pitch is the number of bytes between
    texels with the same X coordinate in adjacent rows (Y coordinates differ
    by one). The per texel alignment requirements are still enforced, this
    is just an additional alignment recommendation for optimal performance
    and power.
  * [[features-limits-nonCoherentAtomSize]]
    pname:nonCoherentAtomSize is the size and alignment in bytes that bounds
    concurrent access to
    <<memory-device-hostaccess, host-mapped device memory>>.

// End of list

1::
    For all bitmasks of type elink:VkSampleCountFlags above, possible
    values include:
+
--
// refBegin VkSampleCountFlagBits - Bitmask specifying sample counts supported for an image used for storage operations
include::../api/enums/VkSampleCountFlagBits.txt[]
--
+
The sample count limits defined above represent the minimum
supported sample counts for each image type. Individual images may: support
additional sample counts, which are queried using
flink:vkGetPhysicalDeviceImageFormatProperties as described
in <<features-supported-sample-counts, Supported Sample Counts>>.

include::../validity/structs/VkPhysicalDeviceLimits.txt[]


[[features-limits-minmax]]
=== Limit Requirements

The following table specifies the required minimum/maximum for all Vulkan
graphics implementations. Where a limit corresponds to a fine-grained
device feature which is optional:, the feature name is listed with two
required limits, one when the feature is supported and one when it is not
supported. If an implementation supports a feature, the limits reported are
the same whether or not the feature is enabled.

[[features-limits-types]]
.Required Limit Types
[width="100%",cols="<20%,<50%,<30%",options="header"]
|=============================
| Type | Limit | Feature
|uint32_t            |maxImageDimension1D               |-
|uint32_t            |maxImageDimension2D               |-
|uint32_t            |maxImageDimension3D               |-
|uint32_t            |maxImageDimensionCube             |-
|uint32_t            |maxImageArrayLayers               |-
|uint32_t            |maxTexelBufferElements            |-
|uint32_t            |maxUniformBufferRange             |-
|uint32_t            |maxStorageBufferRange             |-
|uint32_t            |maxPushConstantsSize              |-
|uint32_t            |maxMemoryAllocationCount          |-
|uint32_t            |maxSamplerAllocationCount         |-
|VkDeviceSize        |bufferImageGranularity            |-
|VkDeviceSize        |sparseAddressSpaceSize            |sparseBinding
|uint32_t            |maxBoundDescriptorSets            |-
|uint32_t            |maxPerStageDescriptorSamplers     |-
|uint32_t            |maxPerStageDescriptorUniformBuffers|-
|uint32_t            |maxPerStageDescriptorStorageBuffers|-
|uint32_t            |maxPerStageDescriptorSampledImages|-
|uint32_t            |maxPerStageDescriptorStorageImages|-
|uint32_t            |maxPerStageDescriptorInputAttachments|-
|uint32_t            |maxPerStageResources              |-
|uint32_t            |maxDescriptorSetSamplers          |-
|uint32_t            |maxDescriptorSetUniformBuffers    |-
|uint32_t            |maxDescriptorSetUniformBuffersDynamic|-
|uint32_t            |maxDescriptorSetStorageBuffers    |-
|uint32_t            |maxDescriptorSetStorageBuffersDynamic|-
|uint32_t            |maxDescriptorSetSampledImages     |-
|uint32_t            |maxDescriptorSetStorageImages     |-
|uint32_t            |maxDescriptorSetInputAttachments  |-
|uint32_t            |maxVertexInputAttributes          |-
|uint32_t            |maxVertexInputBindings            |-
|uint32_t            |maxVertexInputAttributeOffset     |-
|uint32_t            |maxVertexInputBindingStride       |-
|uint32_t            |maxVertexOutputComponents         |-
|uint32_t            |maxTessellationGenerationLevel    |tessellationShader
|uint32_t            |maxTessellationPatchSize          |tessellationShader
|uint32_t            |maxTessellationControlPerVertexInputComponents  |tessellationShader
|uint32_t            |maxTessellationControlPerVertexOutputComponents |tessellationShader
|uint32_t            |maxTessellationControlPerPatchOutputComponents  |tessellationShader
|uint32_t            |maxTessellationControlTotalOutputComponents     |tessellationShader
|uint32_t            |maxTessellationEvaluationInputComponents        |tessellationShader
|uint32_t            |maxTessellationEvaluationOutputComponents       |tessellationShader
|uint32_t            |maxGeometryShaderInvocations      |geometryShader
|uint32_t            |maxGeometryInputComponents        |geometryShader
|uint32_t            |maxGeometryOutputComponents       |geometryShader
|uint32_t            |maxGeometryOutputVertices         |geometryShader
|uint32_t            |maxGeometryTotalOutputComponents  |geometryShader
|uint32_t            |maxFragmentInputComponents        |-
|uint32_t            |maxFragmentOutputAttachments      |-
|uint32_t            |maxFragmentDualSrcAttachments     |dualSrcBlend
|uint32_t            |maxFragmentCombinedOutputResources|-
|uint32_t            |maxComputeSharedMemorySize        |-
|3 × uint32_t        |maxComputeWorkGroupCount          |-
|uint32_t            |maxComputeWorkGroupInvocations    |-
|3 × uint32_t        |maxComputeWorkGroupSize           |-
|uint32_t            |subPixelPrecisionBits             |-
|uint32_t            |subTexelPrecisionBits             |-
|uint32_t            |mipmapPrecisionBits               |-
|uint32_t            |maxDrawIndexedIndexValue          |fullDrawIndexUint32
|uint32_t            |maxDrawIndirectCount              |multiDrawIndirect
|float               |maxSamplerLodBias                 |-
|float               |maxSamplerAnisotropy              |samplerAnisotropy
|uint32_t            |maxViewports                      |multiViewport
|2 × uint32_t        |maxViewportDimensions             |-
|2 × float           |viewportBoundsRange               |-
|uint32_t            |viewportSubPixelBits              |-
|size_t              |minMemoryMapAlignment             |-
|VkDeviceSize        |minTexelBufferOffsetAlignment     |-
|VkDeviceSize        |minUniformBufferOffsetAlignment   |-
|VkDeviceSize        |minStorageBufferOffsetAlignment   |-
|int32_t             |minTexelOffset                    |-
|uint32_t            |maxTexelOffset                    |-
|int32_t             |minTexelGatherOffset              |shaderImageGatherExtended
|uint32_t            |maxTexelGatherOffset              |shaderImageGatherExtended
|float               |minInterpolationOffset            |sampleRateShading
|float               |maxInterpolationOffset            |sampleRateShading
|uint32_t            |subPixelInterpolationOffsetBits   |sampleRateShading
|uint32_t            |maxFramebufferWidth               |-
|uint32_t            |maxFramebufferHeight              |-
|uint32_t            |maxFramebufferLayers              |-
|VkSampleCountFlags  |framebufferColorSampleCounts      |-
|VkSampleCountFlags  |framebufferDepthSampleCounts      |-
|VkSampleCountFlags  |framebufferStencilSampleCounts    |-
|VkSampleCountFlags  |framebufferNoAttachmentsSampleCounts |-
|uint32_t            |maxColorAttachments               |-
|VkSampleCountFlags  |sampledImageColorSampleCounts     |-
|VkSampleCountFlags  |sampledImageIntegerSampleCounts   |-
|VkSampleCountFlags  |sampledImageDepthSampleCounts     |-
|VkSampleCountFlags  |sampledImageStencilSampleCounts   |-
|VkSampleCountFlags  |storageImageSampleCounts          |shaderStorageImageMultisample
|uint32_t            |maxSampleMaskWords                |-
|VkBool32            |timestampComputeAndGraphics       |-
|float               |timestampPeriod                   |-
|uint32_t            |maxClipDistances                  |shaderClipDistance
|uint32_t            |maxCullDistances                  |shaderCullDistance
|uint32_t            |maxCombinedClipAndCullDistances   |shaderCullDistance
|uint32_t            |discreteQueuePriorities           |-
|2 × float           |pointSizeRange                    |largePoints
|2 × float           |lineWidthRange                    |wideLines
|float               |pointSizeGranularity              |largePoints
|float               |lineWidthGranularity              |wideLines
|VkBool32            |strictLines                       |-
|VkBool32            |standardSampleLocations           |-
|VkDeviceSize        |optimalBufferCopyOffsetAlignment  |-
|VkDeviceSize        |optimalBufferCopyRowPitchAlignment|-
|VkDeviceSize        |nonCoherentAtomSize               |-
|=============================

[[features-limits-required]]
.Required Limits
[width="100%",cols="<35,<9,<14,<11",options="header"]
|=============================
| Limit | Unsupported Limit | Supported Limit | Limit Type^1^
|maxImageDimension1D               |- |4096 | min
|maxImageDimension2D               |- |4096 | min
|maxImageDimension3D               |- |256 | min
|maxImageDimensionCube             |- |4096 | min
|maxImageArrayLayers               |- |256 | min
|maxTexelBufferElements            |- |65536 | min
|maxUniformBufferRange             |- |16384 | min
|maxStorageBufferRange             |- |2^27^ | min
|maxPushConstantsSize              |- |128 | min
|maxMemoryAllocationCount          |- |4096 | min
|maxSamplerAllocationCount         |- |4000 | min
|bufferImageGranularity            |- |131072 | max
|sparseAddressSpaceSize            | 0 | 2^31^ | min
|maxBoundDescriptorSets            |- |4 | min
|maxPerStageDescriptorSamplers     |- |16 | min
|maxPerStageDescriptorUniformBuffers|- |12 | min
|maxPerStageDescriptorStorageBuffers|- |4 | min
|maxPerStageDescriptorSampledImages|- |16 | min
|maxPerStageDescriptorStorageImages|- |4 | min
|maxPerStageDescriptorInputAttachments|- |4 | min
|maxPerStageResources              |- |128 ^2^|min
|maxDescriptorSetSamplers          |- |96 | min, 6×PerStage
|maxDescriptorSetUniformBuffers    |- |72 | min, 6×PerStage
|maxDescriptorSetUniformBuffersDynamic|- |8 |min
|maxDescriptorSetStorageBuffers    |- |24 | min, 6×PerStage
|maxDescriptorSetStorageBuffersDynamic|- |4 |min
|maxDescriptorSetSampledImages     |- |96| min, 6×PerStage
|maxDescriptorSetStorageImages     |- |24 | min, 6×PerStage
|maxDescriptorSetInputAttachments  |- |4 | min
|maxVertexInputAttributes          |- |16 |min
|maxVertexInputBindings            |- |16 |min
|maxVertexInputAttributeOffset     |- |2047 |min
|maxVertexInputBindingStride       |- |2048 |min
|maxVertexOutputComponents         |- |64 |min
|maxTessellationGenerationLevel    |0 |64 | min
|maxTessellationPatchSize          |0 |32 | min
|maxTessellationControlPerVertexInputComponents  |0 |64 | min
|maxTessellationControlPerVertexOutputComponents |0 |64 | min
|maxTessellationControlPerPatchOutputComponents  |0 |120 |min
|maxTessellationControlTotalOutputComponents     |0 |2048 |min
|maxTessellationEvaluationInputComponents        |0 |64 |min
|maxTessellationEvaluationOutputComponents       |0 |64 |min
|maxGeometryShaderInvocations      |0 |32 |min
|maxGeometryInputComponents        |0 |64 |min
|maxGeometryOutputComponents       |0 |64 |min
|maxGeometryOutputVertices         |0 |256 |min
|maxGeometryTotalOutputComponents  |0 |1024 |min
|maxFragmentInputComponents        |- |64 |min
|maxFragmentOutputAttachments      |- |4 |min
|maxFragmentDualSrcAttachments     |0 |1 |min
|maxFragmentCombinedOutputResources|- |4 |min
|maxComputeSharedMemorySize        |- |16384 |min
|maxComputeWorkGroupCount          |- |(65535,65535,65535) |min
|maxComputeWorkGroupInvocations    |- |128 |min
|maxComputeWorkGroupSize           |- |(128,128,64) |min
|subPixelPrecisionBits             |- |4 |min
|subTexelPrecisionBits             |- |4 |min
|mipmapPrecisionBits               |- |4 |min
|maxDrawIndexedIndexValue          |2^24^-1 |2^32^-1 |min
|maxDrawIndirectCount              |1 |2^16^-1 |min
|maxSamplerLodBias                 |- |2 |min
|maxSamplerAnisotropy              |1 |16 |min
|maxViewports                      |1 |16 |min
|maxViewportDimensions             |- |(4096,4096) ^3^ | min
|viewportBoundsRange               |- |(-8192,8191) ^4^ |(max,min)
|viewportSubPixelBits              |- |0 |min
|minMemoryMapAlignment             |- |64 |min
|minTexelBufferOffsetAlignment     |- |256 | max
|minUniformBufferOffsetAlignment   |- |256 | max
|minStorageBufferOffsetAlignment   |- |256 | max
|minTexelOffset                    |- |-8 |max
|maxTexelOffset                    |- |7 |min
|minTexelGatherOffset              |0 |-8 |max
|maxTexelGatherOffset              |0 |7 |min
|minInterpolationOffset            |0.0 |-0.5 ^5^ |max
|maxInterpolationOffset            |0.0 |0.5 - (1 ULP) ^5^ |min
|subPixelInterpolationOffsetBits   |0 |4 ^5^ |min
|maxFramebufferWidth               |- |4096 |min
|maxFramebufferHeight              |- |4096 |min
|maxFramebufferLayers              |- |256 |min
|framebufferColorSampleCounts      |- |(VK_SAMPLE_COUNT_1_BIT \| VK_SAMPLE_COUNT_4_BIT) |min
|framebufferDepthSampleCounts      |- |(VK_SAMPLE_COUNT_1_BIT \| VK_SAMPLE_COUNT_4_BIT) |min
|framebufferStencilSampleCounts    |- |(VK_SAMPLE_COUNT_1_BIT \| VK_SAMPLE_COUNT_4_BIT) |min
|framebufferNoAttachmentsSampleCounts |- |(VK_SAMPLE_COUNT_1_BIT \| VK_SAMPLE_COUNT_4_BIT) |min
|maxColorAttachments               |- |4 |min
|sampledImageColorSampleCounts     |- |(VK_SAMPLE_COUNT_1_BIT \| VK_SAMPLE_COUNT_4_BIT) |min
|sampledImageIntegerSampleCounts   |- |VK_SAMPLE_COUNT_1_BIT |min
|sampledImageDepthSampleCounts     |- |(VK_SAMPLE_COUNT_1_BIT \| VK_SAMPLE_COUNT_4_BIT) |min
|sampledImageStencilSampleCounts   |- |(VK_SAMPLE_COUNT_1_BIT \| VK_SAMPLE_COUNT_4_BIT) |min
|storageImageSampleCounts          |VK_SAMPLE_COUNT_1_BIT |(VK_SAMPLE_COUNT_1_BIT \| VK_SAMPLE_COUNT_4_BIT) |min
|maxSampleMaskWords                |- |1 |min
|timestampComputeAndGraphics       |- |- |implementation dependent
|timestampPeriod                   |- |- |duration
|maxClipDistances                  |0 |8 |min
|maxCullDistances                  |0 |8 |min
|maxCombinedClipAndCullDistances   |0 |8 |min
|discreteQueuePriorities           |- |2 |min
|pointSizeRange                    |(1.0,1.0) |(1.0,64.0 - ULP)^6^| (max,min)
|lineWidthRange                    |(1.0,1.0)|(1.0,8.0 - ULP)^7^ |(max,min)
|pointSizeGranularity              | 0.0 | 1.0 ^6^ | max, fixed point increment
|lineWidthGranularity              | 0.0 | 1.0 ^7^ | max, fixed point increment
|strictLines                       |- |- |implementation dependent
|standardSampleLocations           |- |- |implementation dependent
|optimalBufferCopyOffsetAlignment  |- |- |recommendation
|optimalBufferCopyRowPitchAlignment|- |- |recommendation
|nonCoherentAtomSize               |- |128 |max
|=============================

1::
    The *Limit Type* column indicates the limit is either the minimum limit all
    implementations must: support or the maximum limit all implementations
    must: support. For bitmasks a minimum limit is the least
    bits all implementations must: set, but they may: have
    additional bits set beyond this minimum.

2::
    The pname:maxPerStageResources must: be at least the smallest of the
    following:
+
--
* the sum of the pname:maxPerStageDescriptorUniformBuffers,
  pname:maxPerStageDescriptorStorageBuffers,
  pname:maxPerStageDescriptorSampledImages,
  pname:maxPerStageDescriptorStorageImages,
  pname:maxPerStageDescriptorInputAttachments, pname:maxColorAttachments
  limits, or
* 128.
--
+
It may: not be possible to reach this limit in every stage.

3::
    See <<features-limits-maxViewportDimensions,pname:maxViewportDimensions>>
    for the required relationship to other limits.

4::
    See <<features-limits-viewportboundsrange,pname:viewportBoundsRange>>
    for the required relationship to other limits.

5::
    The values pname:minInterpolationOffset and pname:maxInterpolationOffset
    describe the closed interval of supported interpolation offsets:
    [pname:minInterpolationOffset, pname:maxInterpolationOffset]. The ULP is
    determined by pname:subPixelInterpolationOffsetBits. If
    pname:subPixelInterpolationOffsetBits is 4, this provides increments of
    (1/2^4^) = 0.0625, and thus the range of supported interpolation offsets
    would be [-0.5, 0.4375].

6::
    The point size ULP is determined by pname:pointSizeGranularity. If the
    pname:pointSizeGranularity is 0.125, the range of supported point sizes
    must: be at least [1.0, 63.875].

7::
    The line width ULP is determined by pname:lineWidthGranularity. If the
    pname:lineWidthGranularity is 0.0625, the range of supported line widths
    must: be at least [1.0, 7.9375].


[[features-formats]]
== Formats

The features for the set of formats (elink:VkFormat) supported by the
implementation are queried individually using the
flink:vkGetPhysicalDeviceFormatProperties command.


[[features-formats-definition]]
=== Format Definition

// refBegin VkFormat available image formats

The available formats are defined by the elink:VkFormat enumeration:

include::../api/enums/VkFormat.txt[]

ename:VK_FORMAT_UNDEFINED::
    The format is not specified.

ename:VK_FORMAT_R4G4_UNORM_PACK8::
    A two-component, 8-bit packed unsigned normalized format that has
    a 4-bit R component in bits 4..7, and
    a 4-bit G component in bits 0..3.

ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16::
    A four-component, 16-bit packed unsigned normalized format that has
    a 4-bit R component in bits 12..15,
    a 4-bit G component in bits 8..11,
    a 4-bit B component in bits 4..7, and
    a 4-bit A component in bits 0..3.

ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16::
    A four-component, 16-bit packed unsigned normalized format that has
    a 4-bit B component in bits 12..15,
    a 4-bit G component in bits 8..11,
    a 4-bit R component in bits 4..7, and
    a 4-bit A component in bits 0..3.

ename:VK_FORMAT_R5G6B5_UNORM_PACK16::
    A three-component, 16-bit packed unsigned normalized format that has
    a 5-bit R component in bits 11..15,
    a 6-bit G component in bits 5..10, and
    a 5-bit B component in bits 0..4.

ename:VK_FORMAT_B5G6R5_UNORM_PACK16::
    A three-component, 16-bit packed unsigned normalized format that has
    a 5-bit B component in bits 11..15,
    a 6-bit G component in bits 5..10, and
    a 5-bit R component in bits 0..4.

ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16::
    A four-component, 16-bit packed unsigned normalized format that has
    a 5-bit R component in bits 11..15,
    a 5-bit G component in bits 6..10,
    a 5-bit B component in bits 1..5, and
    a 1-bit A component in bit 0.

ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16::
    A four-component, 16-bit packed unsigned normalized format that has
    a 5-bit B component in bits 11..15,
    a 5-bit G component in bits 6..10,
    a 5-bit R component in bits 1..5, and
    a 1-bit A component in bit 0.

ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16::
    A four-component, 16-bit packed unsigned normalized format that has
    a 1-bit A component in bit 15,
    a 5-bit R component in bits 10..14,
    a 5-bit G component in bits 5..9, and
    a 5-bit B component in bits 0..4.

ename:VK_FORMAT_R8_UNORM::
    A one-component, 8-bit unsigned normalized format that has
    a single 8-bit R component.

ename:VK_FORMAT_R8_SNORM::
    A one-component, 8-bit signed normalized format that has
    a single 8-bit R component.

ename:VK_FORMAT_R8_USCALED::
    A one-component, 8-bit unsigned scaled integer format that has
    a single 8-bit R component.

ename:VK_FORMAT_R8_SSCALED::
    A one-component, 8-bit signed scaled integer format that has
    a single 8-bit R component.

ename:VK_FORMAT_R8_UINT::
    A one-component, 8-bit unsigned integer format that has
    a single 8-bit R component.

ename:VK_FORMAT_R8_SINT::
    A one-component, 8-bit signed integer format that has
    a single 8-bit R component.

ename:VK_FORMAT_R8_SRGB::
    A one-component, 8-bit unsigned normalized format that has
    a single 8-bit R component stored with sRGB nonlinear encoding.

ename:VK_FORMAT_R8G8_UNORM::
    A two-component, 16-bit unsigned normalized format that has
    an 8-bit R component in byte 0, and
    an 8-bit G component in byte 1.

ename:VK_FORMAT_R8G8_SNORM::
    A two-component, 16-bit signed normalized format that has
    an 8-bit R component in byte 0, and
    an 8-bit G component in byte 1.

ename:VK_FORMAT_R8G8_USCALED::
    A two-component, 16-bit unsigned scaled integer format that has
    an 8-bit R component in byte 0, and
    an 8-bit G component in byte 1.

ename:VK_FORMAT_R8G8_SSCALED::
    A two-component, 16-bit signed scaled integer format that has
    an 8-bit R component in byte 0, and
    an 8-bit G component in byte 1.

ename:VK_FORMAT_R8G8_UINT::
    A two-component, 16-bit unsigned integer format that has
    an 8-bit R component in byte 0, and
    an 8-bit G component in byte 1.

ename:VK_FORMAT_R8G8_SINT::
    A two-component, 16-bit signed integer format that has
    an 8-bit R component in byte 0, and
    an 8-bit G component in byte 1.

ename:VK_FORMAT_R8G8_SRGB::
    A two-component, 16-bit unsigned normalized format that has
    an 8-bit R component stored with sRGB nonlinear encoding in byte 0, and
    an 8-bit G component stored with sRGB nonlinear encoding in byte 1.

ename:VK_FORMAT_R8G8B8_UNORM::
    A three-component, 24-bit unsigned normalized format that has
    an 8-bit R component in byte 0,
    an 8-bit G component in byte 1, and
    an 8-bit B component in byte 2.

ename:VK_FORMAT_R8G8B8_SNORM::
    A three-component, 24-bit signed normalized format that has
    an 8-bit R component in byte 0,
    an 8-bit G component in byte 1, and
    an 8-bit B component in byte 2.

ename:VK_FORMAT_R8G8B8_USCALED::
    A three-component, 24-bit unsigned scaled format that has
    an 8-bit R component in byte 0,
    an 8-bit G component in byte 1, and
    an 8-bit B component in byte 2.

ename:VK_FORMAT_R8G8B8_SSCALED::
    A three-component, 24-bit signed scaled format that has
    an 8-bit R component in byte 0,
    an 8-bit G component in byte 1, and
    an 8-bit B component in byte 2.

ename:VK_FORMAT_R8G8B8_UINT::
    A three-component, 24-bit unsigned integer format that has
    an 8-bit R component in byte 0,
    an 8-bit G component in byte 1, and
    an 8-bit B component in byte 2.

ename:VK_FORMAT_R8G8B8_SINT::
    A three-component, 24-bit signed integer format that has
    an 8-bit R component in byte 0,
    an 8-bit G component in byte 1, and
    an 8-bit B component in byte 2.

ename:VK_FORMAT_R8G8B8_SRGB::
    A three-component, 24-bit unsigned normalized format that has
    an 8-bit R component stored with sRGB nonlinear encoding in byte 0,
    an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and
    an 8-bit B component stored with sRGB nonlinear encoding in byte 2.

ename:VK_FORMAT_B8G8R8_UNORM::
    A three-component, 24-bit unsigned normalized format that has
    an 8-bit B component in byte 0,
    an 8-bit G component in byte 1, and
    an 8-bit R component in byte 2.

ename:VK_FORMAT_B8G8R8_SNORM::
    A three-component, 24-bit signed normalized format that has
    an 8-bit B component in byte 0,
    an 8-bit G component in byte 1, and
    an 8-bit R component in byte 2.

ename:VK_FORMAT_B8G8R8_USCALED::
    A three-component, 24-bit unsigned scaled format that has
    an 8-bit B component in byte 0,
    an 8-bit G component in byte 1, and
    an 8-bit R component in byte 2.

ename:VK_FORMAT_B8G8R8_SSCALED::
    A three-component, 24-bit signed scaled format that has
    an 8-bit B component in byte 0,
    an 8-bit G component in byte 1, and
    an 8-bit R component in byte 2.

ename:VK_FORMAT_B8G8R8_UINT::
    A three-component, 24-bit unsigned integer format that has
    an 8-bit B component in byte 0,
    an 8-bit G component in byte 1, and
    an 8-bit R component in byte 2.

ename:VK_FORMAT_B8G8R8_SINT::
    A three-component, 24-bit signed integer format that has
    an 8-bit B component in byte 0,
    an 8-bit G component in byte 1, and
    an 8-bit R component in byte 2.

ename:VK_FORMAT_B8G8R8_SRGB::
    A three-component, 24-bit unsigned normalized format that has
    an 8-bit B component stored with sRGB nonlinear encoding in byte 0,
    an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and
    an 8-bit R component stored with sRGB nonlinear encoding in byte 2.

ename:VK_FORMAT_R8G8B8A8_UNORM::
    A four-component, 32-bit unsigned normalized format that has
    an 8-bit R component in byte 0,
    an 8-bit G component in byte 1,
    an 8-bit B component in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_R8G8B8A8_SNORM::
    A four-component, 32-bit signed normalized format that has
    an 8-bit R component in byte 0,
    an 8-bit G component in byte 1,
    an 8-bit B component in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_R8G8B8A8_USCALED::
    A four-component, 32-bit unsigned scaled format that has
    an 8-bit R component in byte 0,
    an 8-bit G component in byte 1,
    an 8-bit B component in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_R8G8B8A8_SSCALED::
    A four-component, 32-bit signed scaled format that has
    an 8-bit R component in byte 0,
    an 8-bit G component in byte 1,
    an 8-bit B component in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_R8G8B8A8_UINT::
    A four-component, 32-bit unsigned integer format that has
    an 8-bit R component in byte 0,
    an 8-bit G component in byte 1,
    an 8-bit B component in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_R8G8B8A8_SINT::
    A four-component, 32-bit signed integer format that has
    an 8-bit R component in byte 0,
    an 8-bit G component in byte 1,
    an 8-bit B component in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_R8G8B8A8_SRGB::
    A four-component, 32-bit unsigned normalized format that has
    an 8-bit R component stored with sRGB nonlinear encoding in byte 0,
    an 8-bit G component stored with sRGB nonlinear encoding in byte 1,
    an 8-bit B component stored with sRGB nonlinear encoding in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_B8G8R8A8_UNORM::
    A four-component, 32-bit unsigned normalized format that has
    an 8-bit B component in byte 0,
    an 8-bit G component in byte 1,
    an 8-bit R component in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_B8G8R8A8_SNORM::
    A four-component, 32-bit signed normalized format that has
    an 8-bit B component in byte 0,
    an 8-bit G component in byte 1,
    an 8-bit R component in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_B8G8R8A8_USCALED::
    A four-component, 32-bit unsigned scaled format that has
    an 8-bit B component in byte 0,
    an 8-bit G component in byte 1,
    an 8-bit R component in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_B8G8R8A8_SSCALED::
    A four-component, 32-bit signed scaled format that has
    an 8-bit B component in byte 0,
    an 8-bit G component in byte 1,
    an 8-bit R component in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_B8G8R8A8_UINT::
    A four-component, 32-bit unsigned integer format that has
    an 8-bit B component in byte 0,
    an 8-bit G component in byte 1,
    an 8-bit R component in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_B8G8R8A8_SINT::
    A four-component, 32-bit signed integer format that has
    an 8-bit B component in byte 0,
    an 8-bit G component in byte 1,
    an 8-bit R component in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_B8G8R8A8_SRGB::
    A four-component, 32-bit unsigned normalized format that has
    an 8-bit B component stored with sRGB nonlinear encoding in byte 0,
    an 8-bit G component stored with sRGB nonlinear encoding in byte 1,
    an 8-bit R component stored with sRGB nonlinear encoding in byte 2, and
    an 8-bit A component in byte 3.

ename:VK_FORMAT_A8B8G8R8_UNORM_PACK32::
    A four-component, 32-bit packed unsigned normalized format that has
    an 8-bit A component in bits 24..31,
    an 8-bit B component in bits 16..23,
    an 8-bit G component in bits 8..15, and
    an 8-bit R component in bits 0..7.

ename:VK_FORMAT_A8B8G8R8_SNORM_PACK32::
    A four-component, 32-bit packed signed normalized format that has
    an 8-bit A component in bits 24..31,
    an 8-bit B component in bits 16..23,
    an 8-bit G component in bits 8..15, and
    an 8-bit R component in bits 0..7.

ename:VK_FORMAT_A8B8G8R8_USCALED_PACK32::
    A four-component, 32-bit packed unsigned scaled integer format that has
    an 8-bit A component in bits 24..31,
    an 8-bit B component in bits 16..23,
    an 8-bit G component in bits 8..15, and
    an 8-bit R component in bits 0..7.

ename:VK_FORMAT_A8B8G8R8_SSCALED_PACK32::
    A four-component, 32-bit packed signed scaled integer format that has
    an 8-bit A component in bits 24..31,
    an 8-bit B component in bits 16..23,
    an 8-bit G component in bits 8..15, and
    an 8-bit R component in bits 0..7.

ename:VK_FORMAT_A8B8G8R8_UINT_PACK32::
    A four-component, 32-bit packed unsigned integer format that has
    an 8-bit A component in bits 24..31,
    an 8-bit B component in bits 16..23,
    an 8-bit G component in bits 8..15, and
    an 8-bit R component in bits 0..7.

ename:VK_FORMAT_A8B8G8R8_SINT_PACK32::
    A four-component, 32-bit packed signed integer format that has
    an 8-bit A component in bits 24..31,
    an 8-bit B component in bits 16..23,
    an 8-bit G component in bits 8..15, and
    an 8-bit R component in bits 0..7.

ename:VK_FORMAT_A8B8G8R8_SRGB_PACK32::
    A four-component, 32-bit packed unsigned normalized format that has
    an 8-bit A component in bits 24..31,
    an 8-bit B component stored with sRGB nonlinear encoding in bits 16..23,
    an 8-bit G component stored with sRGB nonlinear encoding in bits 8..15, and
    an 8-bit R component stored with sRGB nonlinear encoding in bits
    0..7.

ename:VK_FORMAT_A2R10G10B10_UNORM_PACK32::
    A four-component, 32-bit packed unsigned normalized format that has
    a 2-bit A component in bits 30..31,
    a 10-bit R component in bits 20..29,
    a 10-bit G component in bits 10..19, and
    a 10-bit B component in bits 0..9.

ename:VK_FORMAT_A2R10G10B10_SNORM_PACK32::
    A four-component, 32-bit packed signed normalized format that has
    a 2-bit A component in bits 30..31,
    a 10-bit R component in bits 20..29,
    a 10-bit G component in bits 10..19, and
    a 10-bit B component in bits 0..9.

ename:VK_FORMAT_A2R10G10B10_USCALED_PACK32::
    A four-component, 32-bit packed unsigned scaled integer format that has
    a 2-bit A component in bits 30..31,
    a 10-bit R component in bits 20..29,
    a 10-bit G component in bits 10..19, and
    a 10-bit B component in bits 0..9.

ename:VK_FORMAT_A2R10G10B10_SSCALED_PACK32::
    A four-component, 32-bit packed signed scaled integer format that has
    a 2-bit A component in bits 30..31,
    a 10-bit R component in bits 20..29,
    a 10-bit G component in bits 10..19, and
    a 10-bit B component in bits 0..9.

ename:VK_FORMAT_A2R10G10B10_UINT_PACK32::
    A four-component, 32-bit packed unsigned integer format that has
    a 2-bit A component in bits 30..31,
    a 10-bit R component in bits 20..29,
    a 10-bit G component in bits 10..19, and
    a 10-bit B component in bits 0..9.

ename:VK_FORMAT_A2R10G10B10_SINT_PACK32::
    A four-component, 32-bit packed signed integer format that has
    a 2-bit A component in bits 30..31,
    a 10-bit R component in bits 20..29,
    a 10-bit G component in bits 10..19, and
    a 10-bit B component in bits 0..9.

ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32::
    A four-component, 32-bit packed unsigned normalized format that has
    a 2-bit A component in bits 30..31,
    a 10-bit B component in bits 20..29,
    a 10-bit G component in bits 10..19, and
    a 10-bit R component in bits 0..9.

ename:VK_FORMAT_A2B10G10R10_SNORM_PACK32::
    A four-component, 32-bit packed signed normalized format that has
    a 2-bit A component in bits 30..31,
    a 10-bit B component in bits 20..29,
    a 10-bit G component in bits 10..19, and
    a 10-bit R component in bits 0..9.

ename:VK_FORMAT_A2B10G10R10_USCALED_PACK32::
    A four-component, 32-bit packed unsigned scaled integer format that has
    a 2-bit A component in bits 30..31,
    a 10-bit B component in bits 20..29,
    a 10-bit G component in bits 10..19, and
    a 10-bit R component in bits 0..9.

ename:VK_FORMAT_A2B10G10R10_SSCALED_PACK32::
    A four-component, 32-bit packed signed scaled integer format that has
    a 2-bit A component in bits 30..31,
    a 10-bit B component in bits 20..29,
    a 10-bit G component in bits 10..19, and
    a 10-bit R component in bits 0..9.

ename:VK_FORMAT_A2B10G10R10_UINT_PACK32::
    A four-component, 32-bit packed unsigned integer format that has
    a 2-bit A component in bits 30..31,
    a 10-bit B component in bits 20..29,
    a 10-bit G component in bits 10..19, and
    a 10-bit R component in bits 0..9.

ename:VK_FORMAT_A2B10G10R10_SINT_PACK32::
    A four-component, 32-bit packed signed integer format that has
    a 2-bit A component in bits 30..31,
    a 10-bit B component in bits 20..29,
    a 10-bit G component in bits 10..19, and
    a 10-bit R component in bits 0..9.

ename:VK_FORMAT_R16_UNORM::
    A one-component, 16-bit unsigned normalized format that has
    a single 16-bit R component.

ename:VK_FORMAT_R16_SNORM::
    A one-component, 16-bit signed normalized format that has
    a single 16-bit R component.

ename:VK_FORMAT_R16_USCALED::
    A one-component, 16-bit unsigned scaled integer format that has
    a single 16-bit R component.

ename:VK_FORMAT_R16_SSCALED::
    A one-component, 16-bit signed scaled integer format that has
    a single 16-bit R component.

ename:VK_FORMAT_R16_UINT::
    A one-component, 16-bit unsigned integer format that has
    a single 16-bit R component.

ename:VK_FORMAT_R16_SINT::
    A one-component, 16-bit signed integer format that has
    a single 16-bit R component.

ename:VK_FORMAT_R16_SFLOAT::
    A one-component, 16-bit signed floating-point format that has
    a single 16-bit R component.

ename:VK_FORMAT_R16G16_UNORM::
    A two-component, 32-bit unsigned normalized format that has
    a 16-bit R component in bytes 0..1, and
    a 16-bit G component in bytes 2..3.

ename:VK_FORMAT_R16G16_SNORM::
    A two-component, 32-bit signed normalized format that has
    a 16-bit R component in bytes 0..1, and
    a 16-bit G component in bytes 2..3.

ename:VK_FORMAT_R16G16_USCALED::
    A two-component, 32-bit unsigned scaled integer format that has
    a 16-bit R component in bytes 0..1, and
    a 16-bit G component in bytes 2..3.

ename:VK_FORMAT_R16G16_SSCALED::
    A two-component, 32-bit signed scaled integer format that has
    a 16-bit R component in bytes 0..1, and
    a 16-bit G component in bytes 2..3.

ename:VK_FORMAT_R16G16_UINT::
    A two-component, 32-bit unsigned integer format that has
    a 16-bit R component in bytes 0..1, and
    a 16-bit G component in bytes 2..3.

ename:VK_FORMAT_R16G16_SINT::
    A two-component, 32-bit signed integer format that has
    a 16-bit R component in bytes 0..1, and
    a 16-bit G component in bytes 2..3.

ename:VK_FORMAT_R16G16_SFLOAT::
    A two-component, 32-bit signed floating-point format that has
    a 16-bit R component in bytes 0..1, and
    a 16-bit G component in bytes 2..3.

ename:VK_FORMAT_R16G16B16_UNORM::
    A three-component, 48-bit unsigned normalized format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3, and
    a 16-bit B component in bytes 4..5.

ename:VK_FORMAT_R16G16B16_SNORM::
    A three-component, 48-bit signed normalized format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3, and
    a 16-bit B component in bytes 4..5.

ename:VK_FORMAT_R16G16B16_USCALED::
    A three-component, 48-bit unsigned scaled integer format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3, and
    a 16-bit B component in bytes 4..5.

ename:VK_FORMAT_R16G16B16_SSCALED::
    A three-component, 48-bit signed scaled integer format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3, and
    a 16-bit B component in bytes 4..5.

ename:VK_FORMAT_R16G16B16_UINT::
    A three-component, 48-bit unsigned integer format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3, and
    a 16-bit B component in bytes 4..5.

ename:VK_FORMAT_R16G16B16_SINT::
    A three-component, 48-bit signed integer format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3, and
    a 16-bit B component in bytes 4..5.

ename:VK_FORMAT_R16G16B16_SFLOAT::
    A three-component, 48-bit signed floating-point format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3, and
    a 16-bit B component in bytes 4..5.

ename:VK_FORMAT_R16G16B16A16_UNORM::
    A four-component, 64-bit unsigned normalized format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3,
    a 16-bit B component in bytes 4..5, and
    a 16-bit A component in bytes 6..7.

ename:VK_FORMAT_R16G16B16A16_SNORM::
    A four-component, 64-bit signed normalized format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3,
    a 16-bit B component in bytes 4..5, and
    a 16-bit A component in bytes 6..7.

ename:VK_FORMAT_R16G16B16A16_USCALED::
    A four-component, 64-bit unsigned scaled integer format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3,
    a 16-bit B component in bytes 4..5, and
    a 16-bit A component in bytes 6..7.

ename:VK_FORMAT_R16G16B16A16_SSCALED::
    A four-component, 64-bit signed scaled integer format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3,
    a 16-bit B component in bytes 4..5, and
    a 16-bit A component in bytes 6..7.

ename:VK_FORMAT_R16G16B16A16_UINT::
    A four-component, 64-bit unsigned integer format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3,
    a 16-bit B component in bytes 4..5, and
    a 16-bit A component in bytes 6..7.

ename:VK_FORMAT_R16G16B16A16_SINT::
    A four-component, 64-bit signed integer format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3,
    a 16-bit B component in bytes 4..5, and
    a 16-bit A component in bytes 6..7.

ename:VK_FORMAT_R16G16B16A16_SFLOAT::
    A four-component, 64-bit signed floating-point format that has
    a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3,
    a 16-bit B component in bytes 4..5, and
    a 16-bit A component in bytes 6..7.

ename:VK_FORMAT_R32_UINT::
    A one-component, 32-bit unsigned integer format that has
    a single 32-bit R component.

ename:VK_FORMAT_R32_SINT::
    A one-component, 32-bit signed integer format that has
    a single 32-bit R component.

ename:VK_FORMAT_R32_SFLOAT::
    A one-component, 32-bit signed floating-point format that has
    a single 32-bit R component.

ename:VK_FORMAT_R32G32_UINT::
    A two-component, 64-bit unsigned integer format that has
    a 32-bit R component in bytes 0..3, and
    a 32-bit G component in bytes 4..7.

ename:VK_FORMAT_R32G32_SINT::
    A two-component, 64-bit signed integer format that has
    a 32-bit R component in bytes 0..3, and
    a 32-bit G component in bytes 4..7.

ename:VK_FORMAT_R32G32_SFLOAT::
    A two-component, 64-bit signed floating-point format that has
    a 32-bit R component in bytes 0..3, and
    a 32-bit G component in bytes 4..7.

ename:VK_FORMAT_R32G32B32_UINT::
    A three-component, 96-bit unsigned integer format that has
    a 32-bit R component in bytes 0..3,
    a 32-bit G component in bytes 4..7, and
    a 32-bit B component in bytes 8..11.

ename:VK_FORMAT_R32G32B32_SINT::
    A three-component, 96-bit signed integer format that has
    a 32-bit R component in bytes 0..3,
    a 32-bit G component in bytes 4..7, and
    a 32-bit B component in bytes 8..11.

ename:VK_FORMAT_R32G32B32_SFLOAT::
    A three-component, 96-bit signed floating-point format that has
    a 32-bit R component in bytes 0..3,
    a 32-bit G component in bytes 4..7, and
    a 32-bit B component in bytes 8..11.

ename:VK_FORMAT_R32G32B32A32_UINT::
    A four-component, 128-bit unsigned integer format that has
    a 32-bit R component in bytes 0..3,
    a 32-bit G component in bytes 4..7,
    a 32-bit B component in bytes 8..11, and
    a 32-bit A component in bytes 12..15.

ename:VK_FORMAT_R32G32B32A32_SINT::
    A four-component, 128-bit signed integer format that has
    a 32-bit R component in bytes 0..3,
    a 32-bit G component in bytes 4..7,
    a 32-bit B component in bytes 8..11, and
    a 32-bit A component in bytes 12..15.

ename:VK_FORMAT_R32G32B32A32_SFLOAT::
    A four-component, 128-bit signed floating-point format that has
    a 32-bit R component in bytes 0..3,
    a 32-bit G component in bytes 4..7,
    a 32-bit B component in bytes 8..11, and
    a 32-bit A component in bytes 12..15.

ename:VK_FORMAT_R64_UINT::
    A one-component, 64-bit unsigned integer format that has
    a single 64-bit R component.

ename:VK_FORMAT_R64_SINT::
    A one-component, 64-bit signed integer format that has
    a single 64-bit R component.

ename:VK_FORMAT_R64_SFLOAT::
    A one-component, 64-bit signed floating-point format that has
    a single 64-bit R component.

ename:VK_FORMAT_R64G64_UINT::
    A two-component, 128-bit unsigned integer format that has
    a 64-bit R component in bytes 0..7, and
    a 64-bit G component in bytes 8..15.

ename:VK_FORMAT_R64G64_SINT::
    A two-component, 128-bit signed integer format that has
    a 64-bit R component in bytes 0..7, and
    a 64-bit G component in bytes 8..15.

ename:VK_FORMAT_R64G64_SFLOAT::
    A two-component, 128-bit signed floating-point format that has
    a 64-bit R component in bytes 0..7, and
    a 64-bit G component in bytes 8..15.

ename:VK_FORMAT_R64G64B64_UINT::
    A three-component, 192-bit unsigned integer format that has
    a 64-bit R component in bytes 0..7,
    a 64-bit G component in bytes 8..15, and
    a 64-bit B component in bytes 16..23.

ename:VK_FORMAT_R64G64B64_SINT::
    A three-component, 192-bit signed integer format that has
    a 64-bit R component in bytes 0..7,
    a 64-bit G component in bytes 8..15, and
    a 64-bit B component in bytes 16..23.

ename:VK_FORMAT_R64G64B64_SFLOAT::
    A three-component, 192-bit signed floating-point format that has
    a 64-bit R component in bytes 0..7,
    a 64-bit G component in bytes 8..15, and
    a 64-bit B component in bytes 16..23.

ename:VK_FORMAT_R64G64B64A64_UINT::
    A four-component, 256-bit unsigned integer format that has
    a 64-bit R component in bytes 0..7,
    a 64-bit G component in bytes 8..15,
    a 64-bit B component in bytes 16..23, and
    a 64-bit A component in bytes 24..31.

ename:VK_FORMAT_R64G64B64A64_SINT::
    A four-component, 256-bit signed integer format that has
    a 64-bit R component in bytes 0..7,
    a 64-bit G component in bytes 8..15,
    a 64-bit B component in bytes 16..23, and
    a 64-bit A component in bytes 24..31.

ename:VK_FORMAT_R64G64B64A64_SFLOAT::
    A four-component, 256-bit signed floating-point format that has
    a 64-bit R component in bytes 0..7,
    a 64-bit G component in bytes 8..15,
    a 64-bit B component in bytes 16..23, and
    a 64-bit A component in bytes 24..31.

ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32::
    A three-component, 32-bit packed unsigned floating-point format that has
    a 10-bit B component in bits 22..31,
    an 11-bit G component in bits 11..21,
    an 11-bit R component in bits 0..10.
    See <<fundamentals-fp10>> and <<fundamentals-fp11>>.

ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32::
    A three-component, 32-bit packed unsigned floating-point format that has
    a 5-bit shared exponent in bits 27..31,
    a 9-bit B component mantissa in bits 18..26,
    a 9-bit G component mantissa in bits 9..17, and
    a 9-bit R component mantissa in bits 0..8.

ename:VK_FORMAT_D16_UNORM::
    A one-component, 16-bit unsigned normalized format that has a
    single 16-bit depth component.

ename:VK_FORMAT_X8_D24_UNORM_PACK32::
    A two-component, 32-bit format that has 24 unsigned normalized bits in
    the depth component and, optionally:, 8 bits that are unused.

ename:VK_FORMAT_D32_SFLOAT::
    A one-component, 32-bit signed floating-point format that has 32-bits in
    the depth component.

ename:VK_FORMAT_S8_UINT::
    A one-component, 8-bit unsigned integer format that has 8-bits in the
    stencil component.

ename:VK_FORMAT_D16_UNORM_S8_UINT::
    A two-component, 24-bit format that has 16 unsigned normalized bits in
    the depth component and 8 unsigned integer bits in the stencil
    component.

ename:VK_FORMAT_D24_UNORM_S8_UINT::
    A two-component, 32-bit packed format that has
    8 unsigned integer bits in the stencil component, and
    24 unsigned normalized bits in the depth component.

ename:VK_FORMAT_D32_SFLOAT_S8_UINT::
    A two-component format that has 32 signed float bits in the depth
    component and 8 unsigned integer bits in the stencil component. There
    are optionally: 24-bits that are unused.

ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK::
    A three-component, block-compressed format where each 64-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data.
    This format has no alpha and is considered opaque.

ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK::
    A three-component, block-compressed format where each 64-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data
    with sRGB nonlinear encoding. This format has no alpha and is considered
    opaque.

ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK::
    A four-component, block-compressed format where each 64-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data,
    and provides 1 bit of alpha.

ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK::
    A four-component, block-compressed format where each 64-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data
    with sRGB nonlinear encoding, and provides 1 bit of alpha.

ename:VK_FORMAT_BC2_UNORM_BLOCK::
    A four-component, block-compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data
    with the first 64 bits encoding alpha values followed by 64 bits encoding
    RGB values.

ename:VK_FORMAT_BC2_SRGB_BLOCK::
    A four-component, block-compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data
    with the first 64 bits encoding alpha values followed by 64 bits encoding
    RGB values with sRGB nonlinear encoding.

ename:VK_FORMAT_BC3_UNORM_BLOCK::
    A four-component, block-compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data
    with the first 64 bits encoding alpha values followed by 64 bits encoding
    RGB values.

ename:VK_FORMAT_BC3_SRGB_BLOCK::
    A four-component, block-compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data
    with the first 64 bits encoding alpha values followed by 64 bits encoding
    RGB values with sRGB nonlinear encoding.

ename:VK_FORMAT_BC4_UNORM_BLOCK::
    A one-component, block-compressed format where each 64-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized red texel data.

ename:VK_FORMAT_BC4_SNORM_BLOCK::
    A one-component, block-compressed format where each 64-bit compressed
    texel block encodes a 4x4 rectangle of signed normalized red texel data.

ename:VK_FORMAT_BC5_UNORM_BLOCK::
    A two-component, block-compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RG texel data
    with the first 64 bits encoding red values followed by 64 bits encoding
    green values.

ename:VK_FORMAT_BC5_SNORM_BLOCK::
    A two-component, block-compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of signed normalized RG texel data
    with the first 64 bits encoding red values followed by 64 bits encoding
    green values.

ename:VK_FORMAT_BC6H_UFLOAT_BLOCK::
    A three-component, block-compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of unsigned floating-point RGB texel
    data.

ename:VK_FORMAT_BC6H_SFLOAT_BLOCK::
    A three-component, block-compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of signed floating-point RGB texel
    data.

ename:VK_FORMAT_BC7_UNORM_BLOCK::
    A four-component, block-compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel
    data.

ename:VK_FORMAT_BC7_SRGB_BLOCK::
    A four-component, block-compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel
    data with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK::
    A three-component, ETC2 compressed format where each 64-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data.
    This format has no alpha and is considered opaque.

ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK::
    A three-component, ETC2 compressed format where each 64-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data
    with sRGB nonlinear encoding. This format has no alpha and is considered
    opaque.

ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK::
    A four-component, ETC2 compressed format where each 64-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data,
    and provides 1 bit of alpha.

ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK::
    A four-component, ETC2 compressed format where each 64-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data
    with sRGB nonlinear encoding, and provides 1 bit of alpha.

ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK::
    A four-component, ETC2 compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data
    with the first 64 bits encoding alpha values followed by 64 bits encoding
    RGB values.

ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK::
    A four-component, ETC2 compressed format where each 64-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data
    with the first 64 bits encoding alpha values followed by 64 bits encoding
    RGB values with sRGB nonlinear encoding applied.

ename:VK_FORMAT_EAC_R11_UNORM_BLOCK::
    A one-component, ETC2 compressed format where each 64-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized red texel data.

ename:VK_FORMAT_EAC_R11_SNORM_BLOCK::
    A one-component, ETC2 compressed format where each 64-bit compressed
    texel block encodes a 4x4 rectangle of signed normalized red texel data.

ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK::
    A two-component, ETC2 compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RG texel data
    with the first 64 bits encoding red values followed by 64 bits encoding
    green values.

ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK::
    A two-component, ETC2 compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of signed normalized RG texel data
    with the first 64 bits encoding red values followed by 64 bits encoding
    green values.

ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data.

ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data
    with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 5x4 rectangle of unsigned normalized RGBA texel data.

ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 5x4 rectangle of unsigned normalized RGBA texel data
    with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 5x5 rectangle of unsigned normalized RGBA texel data.

ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 5x5 rectangle of unsigned normalized RGBA texel data
    with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 6x5 rectangle of unsigned normalized RGBA texel data.

ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 6x5 rectangle of unsigned normalized RGBA texel data
    with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 6x6 rectangle of unsigned normalized RGBA texel data.

ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 6x6 rectangle of unsigned normalized RGBA texel data
    with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 8x5 rectangle of unsigned normalized RGBA texel data.

ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 8x5 rectangle of unsigned normalized RGBA texel data
    with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 8x6 rectangle of unsigned normalized RGBA texel data.

ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 8x6 rectangle of unsigned normalized RGBA texel data
    with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 8x8 rectangle of unsigned normalized RGBA texel data.

ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 8x8 rectangle of unsigned normalized RGBA texel data
    with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 10x5 rectangle of unsigned normalized RGBA texel
    data.

ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 10x5 rectangle of unsigned normalized RGBA texel data
    with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 10x6 rectangle of unsigned normalized RGBA texel
    data.

ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 10x6 rectangle of unsigned normalized RGBA texel data
    with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 10x8 rectangle of unsigned normalized RGBA texel
    data.

ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 10x8 rectangle of unsigned normalized RGBA texel data
    with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 10x10 rectangle of unsigned normalized RGBA texel
    data.

ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 10x10 rectangle of unsigned normalized RGBA texel
    data with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 12x10 rectangle of unsigned normalized RGBA texel
    data.

ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 12x10 rectangle of unsigned normalized RGBA texel
    data with sRGB nonlinear encoding applied to the RGB components.

ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 12x12 rectangle of unsigned normalized RGBA texel
    data.

ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK::
    A four-component, ASTC compressed format where each 128-bit compressed
    texel block encodes a 12x12 rectangle of unsigned normalized RGBA texel
    data with sRGB nonlinear encoding applied to the RGB components.

// refEnd VkFormat


[[features-formats-packed]]
==== Packed Formats

For the purposes of address alignment when accessing buffer memory
containing vertex attribute or texel data, the following formats are
considered _packed_ - whole texels or attributes are stored in a single data
element, rather than individual components occupying a single data element:

  * <<features-formats-packed-8-bit,Packed into 8-bit data types>>:
  ** ename:VK_FORMAT_R4G4_UNORM_PACK8
  * <<features-formats-packed-16-bit,Packed into 16-bit data types>>:
  ** ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16
  ** ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16
  ** ename:VK_FORMAT_R5G6B5_UNORM_PACK16
  ** ename:VK_FORMAT_B5G6R5_UNORM_PACK16
  ** ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16
  ** ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16
  ** ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16
  * <<features-formats-packed-32-bit,Packed into 32-bit data types>>:
  ** ename:VK_FORMAT_A8B8G8R8_UNORM_PACK32
  ** ename:VK_FORMAT_A8B8G8R8_SNORM_PACK32
  ** ename:VK_FORMAT_A8B8G8R8_USCALED_PACK32
  ** ename:VK_FORMAT_A8B8G8R8_SSCALED_PACK32
  ** ename:VK_FORMAT_A8B8G8R8_UINT_PACK32
  ** ename:VK_FORMAT_A8B8G8R8_SINT_PACK32
  ** ename:VK_FORMAT_A8B8G8R8_SRGB_PACK32
  ** ename:VK_FORMAT_A2R10G10B10_UNORM_PACK32
  ** ename:VK_FORMAT_A2R10G10B10_SNORM_PACK32
  ** ename:VK_FORMAT_A2R10G10B10_USCALED_PACK32
  ** ename:VK_FORMAT_A2R10G10B10_SSCALED_PACK32
  ** ename:VK_FORMAT_A2R10G10B10_UINT_PACK32
  ** ename:VK_FORMAT_A2R10G10B10_SINT_PACK32
  ** ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32
  ** ename:VK_FORMAT_A2B10G10R10_SNORM_PACK32
  ** ename:VK_FORMAT_A2B10G10R10_USCALED_PACK32
  ** ename:VK_FORMAT_A2B10G10R10_SSCALED_PACK32
  ** ename:VK_FORMAT_A2B10G10R10_UINT_PACK32
  ** ename:VK_FORMAT_A2B10G10R10_SINT_PACK32
  ** ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32
  ** ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32
  ** ename:VK_FORMAT_X8_D24_UNORM_PACK32


==== Identification of Formats

A ``format'' is represented by a single enum value. The name of a format is
usually built up by using the following pattern:

    VK_FORMAT_{component-format|compression-scheme}_{numeric-format}

The component-format specifies either the size of the R, G, B, and A
components (if they are present) in the case of a color format, or the size
of the depth (D) and stencil (S) components (if they are present) in the
case of a depth/stencil format (see below). An X indicates a component that
is unused, but may: be present for padding.

<<<

[[features-formats-numericformat]]
.Interpretation of Numeric Format
[width="95%",cols="2,10",options="header"]
|===================
| Numeric format | Description
| etext:UNORM    | The components are unsigned normalized values in the range [0,1]
| etext:SNORM    | The components are signed normalized values in the range [-1,1]
| etext:USCALED  | The components are unsigned integer values that get converted to floating-point in the range [0,2^n^-1]
| etext:SSCALED  | The components are signed integer values that get converted to floating-point in the range [-2^n-1^,2^n-1^-1]
| etext:UINT     | The components are unsigned integer values in the range [0,2^n^-1]
| etext:SINT     | The components are signed integer values in the range [-2^n-1^,2^n-1^-1]
| etext:UFLOAT   | The components are unsigned floating-point numbers (used by packed, shared exponent, and some compressed formats)
| etext:SFLOAT   | The components are signed floating-point numbers
| etext:SRGB     | The R, G, and B components are unsigned normalized values that represent values using sRGB nonlinear encoding, while the A component (if one exists) is a regular unsigned normalized value
|===================

The suffix etext:_PACKnn indicates that the format is packed into an
underlying type with nn bits.

The suffix etext:_BLOCK indicates that the format is a block-compressed
format, with the representation of multiple pixels encoded interdependently
within a region.

[[features-formats-compressionscheme]]
.Interpretation of Compression Scheme
[width="95%",cols="2,10",options="header"]
|==================
| Compression scheme | Description
| etext:BC           | Block Compression. See <<appendix-compressedtex-bc>>.
| etext:ETC2         | Ericsson Texture Compression. See <<appendix-compressedtex-etc2>>.
| etext:EAC          | ETC2 Alpha Compression. See <<appendix-compressedtex-etc2>>.
| etext:ASTC         | Adaptive Scalable Texture Compression (LDR Profile). See <<appendix-compressedtex-astc>>.
|==================


==== Representation

Color formats must: be represented in memory in exactly the form indicated
by the format's name. This means that promoting one format to
another with more bits per component and/or additional components
mustnot: occur for color formats. Depth/stencil formats have more relaxed
requirements as discussed <<features-formats-depth-stencil,below>>.

The representation of non-packed formats is that the first component
specified in the name of the format is in the lowest memory addresses and
the last component specified is in the highest memory addresses. See
<<features-formats-non-packed,Byte mappings for non-packed/compressed color
formats>>. The in-memory ordering of bytes within a component is determined
by the host endianness.

[[features-formats-non-packed]]
.Byte mappings for non-packed/compressed color formats
[options="header",cols="16*1,23",width="100%"]
|===============
>|0 >|1 >|2 >|3 >|4 >|5 >|6 >|7 >|8 >|9 >|10 >|11 >|12 >|13 >|14 >|15 ^| latexmath:[$\leftarrow$] Byte
^|R 16+>s|VK_FORMAT_R8_*
^|R ^|G 15+>s|VK_FORMAT_R8G8_*
^|R ^|G ^|B 14+>s|VK_FORMAT_R8G8B8_*
^|B ^|G ^|R 14+>s|VK_FORMAT_B8G8R8_*
^|R ^|G ^|B ^|A 13+>s|VK_FORMAT_R8G8B8A8_*
^|B ^|G ^|R ^|A 13+>s|VK_FORMAT_B8G8R8A8_*
2+^|R 15+>s|VK_FORMAT_R16_*
2+^|R 2+^|G 13+>s|VK_FORMAT_R16G16_*
2+^|R 2+^|G 2+^|B 11+>s|VK_FORMAT_R16G16B16_*
2+^|R 2+^|G 2+^|B 2+^|A 9+>s|VK_FORMAT_R16G16B16A16_*
4+^|R 13+>s|VK_FORMAT_R32_*
4+^|R 4+^|G 9+>s|VK_FORMAT_R32G32_*
4+^|R 4+^|G 4+^|B 5+>s|VK_FORMAT_R32G32B32_*
4+^|R 4+^|G 4+^|B 4+^|A >s|VK_FORMAT_R32G32B32A32_*
8+^|R 9+>s|VK_FORMAT_R64_*
8+^|R 8+^|G >s|VK_FORMAT_R64G64_*
17+^s|VK_FORMAT_R64G64B64_* as VK_FORMAT_R64G64_* but with B in bytes 16-23
17+^s|VK_FORMAT_R64G64B64A64_* as VK_FORMAT_R64G64B64_* but with A in bytes 24-31
|===============

Packed formats store multiple components within one underlying type. The bit
representation is that the first component specified in the name of the
format is in the most-significant bits and the last component specified is
in the least-significant bits of the underlying type. The in-memory ordering
of bytes comprising the underlying type is determined by the host
endianness.

[[features-formats-packed-8-bit]]
.Bit mappings for packed 8-bit formats
[options="header",cols="24h,8*1",width="80%"]
|===============
^| Bit latexmath:[$\rightarrow$] >| 7 >| 6 >| 5 >| 4 >| 3 >| 2 >| 1 >| 0
^| VK_FORMAT_R4G4_UNORM_PACK8
^| latexmath:[$R_3$] ^| latexmath:[$R_2$] ^| latexmath:[$R_1$] ^| latexmath:[$R_0$]
^| latexmath:[$G_3$] ^| latexmath:[$G_2$] ^| latexmath:[$G_1$] ^| latexmath:[$G_0$]
|===============

[[features-formats-packed-16-bit]]
.Bit mappings for packed 16-bit etext:VK_FORMAT_* formats
[options="header",cols="18h,16*1",width="100%"]
|===============
^| Bit latexmath:[$\rightarrow$] >| 15 >| 14 >| 13 >| 12 >| 11 >| 10 >| 9 >| 8 >| 7 >| 6 >| 5 >| 4 >| 3 >| 2 >| 1 >| 0
^|R4G4B4A4_UNORM_PACK16
^| latexmath:[$R_3$] ^| latexmath:[$R_2$] ^| latexmath:[$R_1$] ^| latexmath:[$R_0$]
^| latexmath:[$G_3$] ^| latexmath:[$G_2$] ^| latexmath:[$G_1$] ^| latexmath:[$G_0$]
^| latexmath:[$B_3$] ^| latexmath:[$B_2$] ^| latexmath:[$B_1$] ^| latexmath:[$B_0$]
^| latexmath:[$A_3$] ^| latexmath:[$A_2$] ^| latexmath:[$A_1$] ^| latexmath:[$A_0$]
^|B4G4R4A4_UNORM_PACK16
^| latexmath:[$B_3$] ^| latexmath:[$B_2$] ^| latexmath:[$B_1$] ^| latexmath:[$B_0$]
^| latexmath:[$G_3$] ^| latexmath:[$G_2$] ^| latexmath:[$G_1$] ^| latexmath:[$G_0$]
^| latexmath:[$R_3$] ^| latexmath:[$R_2$] ^| latexmath:[$R_1$] ^| latexmath:[$R_0$]
^| latexmath:[$A_3$] ^| latexmath:[$A_2$] ^| latexmath:[$A_1$] ^| latexmath:[$A_0$]
^|R5G6B5_UNORM_PACK16
^| latexmath:[$R_4$] ^| latexmath:[$R_3$] ^| latexmath:[$R_2$] ^| latexmath:[$R_1$] ^| latexmath:[$R_0$]
^| latexmath:[$G_5$] ^| latexmath:[$G_4$] ^| latexmath:[$G_3$] ^| latexmath:[$G_2$] ^| latexmath:[$G_1$] ^| latexmath:[$G_0$]
^| latexmath:[$B_4$] ^| latexmath:[$B_3$] ^| latexmath:[$B_2$] ^| latexmath:[$B_1$] ^| latexmath:[$B_0$]
^|B5G6R5_UNORM_PACK16
^| latexmath:[$B_4$] ^| latexmath:[$B_3$] ^| latexmath:[$B_2$] ^| latexmath:[$B_1$] ^| latexmath:[$B_0$]
^| latexmath:[$G_5$] ^| latexmath:[$G_4$] ^| latexmath:[$G_3$] ^| latexmath:[$G_2$] ^| latexmath:[$G_1$] ^| latexmath:[$G_0$]
^| latexmath:[$R_4$] ^| latexmath:[$R_3$] ^| latexmath:[$R_2$] ^| latexmath:[$R_1$] ^| latexmath:[$R_0$]
^|R5G5B5A1_UNORM_PACK16
^| latexmath:[$R_4$] ^| latexmath:[$R_3$] ^| latexmath:[$R_2$] ^| latexmath:[$R_1$] ^| latexmath:[$R_0$]
^| latexmath:[$G_4$] ^| latexmath:[$G_3$] ^| latexmath:[$G_2$] ^| latexmath:[$G_1$] ^| latexmath:[$G_0$]
^| latexmath:[$B_4$] ^| latexmath:[$B_3$] ^| latexmath:[$B_2$] ^| latexmath:[$B_1$] ^| latexmath:[$B_0$]
^| latexmath:[$A_0$]
^|B5G5R5A1_UNORM_PACK16
^| latexmath:[$B_4$] ^| latexmath:[$B_3$] ^| latexmath:[$B_2$] ^| latexmath:[$B_1$] ^| latexmath:[$B_0$]
^| latexmath:[$G_4$] ^| latexmath:[$G_3$] ^| latexmath:[$G_2$] ^| latexmath:[$G_1$] ^| latexmath:[$G_0$]
^| latexmath:[$R_4$] ^| latexmath:[$R_3$] ^| latexmath:[$R_2$] ^| latexmath:[$R_1$] ^| latexmath:[$R_0$]
^| latexmath:[$A_0$]
^|A1R5G5B5_UNORM_PACK16
^| latexmath:[$A_0$]
^| latexmath:[$R_4$] ^| latexmath:[$R_3$] ^| latexmath:[$R_2$] ^| latexmath:[$R_1$] ^| latexmath:[$R_0$]
^| latexmath:[$G_4$] ^| latexmath:[$G_3$] ^| latexmath:[$G_2$] ^| latexmath:[$G_1$] ^| latexmath:[$G_0$]
^| latexmath:[$B_4$] ^| latexmath:[$B_3$] ^| latexmath:[$B_2$] ^| latexmath:[$B_1$] ^| latexmath:[$B_0$]
|===============

// N.B. This table is slightly too wide to fit - we cheat by not drawing the grid lines so we cannot see...
[[features-formats-packed-32-bit]]
.Bit mappings for packed 32-bit formats
[cols="32*1",frame="none",grid="rows",options="header"]
|===============
>|31 >|30 >|29 >|28 >|27 >|26 >|25 >|24 >|23 >|22 >|21 >|20 >|19 >|18 >|17 >|16
>|15 >|14 >|13 >|12 >|11 >|10 >|9 >|8 >|7 >|6 >|5 >|4 >|3 >|2 >|1 >|0
32+^s|VK_FORMAT_A8B8G8R8_*_PACK32
^|latexmath:[$A_7$] ^|latexmath:[$A_6$] ^|latexmath:[$A_5$] ^|latexmath:[$A_4$]
^|latexmath:[$A_3$] ^|latexmath:[$A_2$] ^|latexmath:[$A_1$] ^|latexmath:[$A_0$]
^|latexmath:[$B_7$] ^|latexmath:[$B_6$] ^|latexmath:[$B_5$] ^|latexmath:[$B_4$]
^|latexmath:[$B_3$] ^|latexmath:[$B_2$] ^|latexmath:[$B_1$] ^|latexmath:[$B_0$]
^|latexmath:[$G_7$] ^|latexmath:[$G_6$] ^|latexmath:[$G_5$] ^|latexmath:[$G_4$]
^|latexmath:[$G_3$] ^|latexmath:[$G_2$] ^|latexmath:[$G_1$] ^|latexmath:[$G_0$]
^|latexmath:[$R_7$] ^|latexmath:[$R_6$] ^|latexmath:[$R_5$] ^|latexmath:[$R_4$]
^|latexmath:[$R_3$] ^|latexmath:[$R_2$] ^|latexmath:[$R_1$] ^|latexmath:[$R_0$]
32+^s|VK_FORMAT_A2R10G10B10_*_PACK32
^|latexmath:[$A_1$] ^|latexmath:[$A_0$]
^|latexmath:[$R_9$] ^|latexmath:[$R_8$] ^|latexmath:[$R_7$] ^|latexmath:[$R_6$] ^|latexmath:[$R_5$]
^|latexmath:[$R_4$] ^|latexmath:[$R_3$] ^|latexmath:[$R_2$] ^|latexmath:[$R_1$] ^|latexmath:[$R_0$]
^|latexmath:[$G_9$] ^|latexmath:[$G_8$] ^|latexmath:[$G_7$] ^|latexmath:[$G_6$] ^|latexmath:[$G_5$]
^|latexmath:[$G_4$] ^|latexmath:[$G_3$] ^|latexmath:[$G_2$] ^|latexmath:[$G_1$] ^|latexmath:[$G_0$]
^|latexmath:[$B_9$] ^|latexmath:[$B_8$] ^|latexmath:[$B_7$] ^|latexmath:[$B_6$] ^|latexmath:[$B_5$]
^|latexmath:[$B_4$] ^|latexmath:[$B_3$] ^|latexmath:[$B_2$] ^|latexmath:[$B_1$] ^|latexmath:[$B_0$]
32+^s|VK_FORMAT_A2B10G10R10_*_PACK32
^|latexmath:[$A_1$] ^|latexmath:[$A_0$]
^|latexmath:[$B_9$] ^|latexmath:[$B_8$] ^|latexmath:[$B_7$] ^|latexmath:[$B_6$] ^|latexmath:[$B_5$]
^|latexmath:[$B_4$] ^|latexmath:[$B_3$] ^|latexmath:[$B_2$] ^|latexmath:[$B_1$] ^|latexmath:[$B_0$]
^|latexmath:[$G_9$] ^|latexmath:[$G_8$] ^|latexmath:[$G_7$] ^|latexmath:[$G_6$] ^|latexmath:[$G_5$]
^|latexmath:[$G_4$] ^|latexmath:[$G_3$] ^|latexmath:[$G_2$] ^|latexmath:[$G_1$] ^|latexmath:[$G_0$]
^|latexmath:[$R_9$] ^|latexmath:[$R_8$] ^|latexmath:[$R_7$] ^|latexmath:[$R_6$] ^|latexmath:[$R_5$]
^|latexmath:[$R_4$] ^|latexmath:[$R_3$] ^|latexmath:[$R_2$] ^|latexmath:[$R_1$] ^|latexmath:[$R_0$]
32+^s|VK_FORMAT_B10G11R11_UFLOAT_PACK32
^|latexmath:[$B_9$] ^|latexmath:[$B_8$] ^|latexmath:[$B_7$] ^|latexmath:[$B_6$] ^|latexmath:[$B_5$]
^|latexmath:[$B_4$] ^|latexmath:[$B_3$] ^|latexmath:[$B_2$] ^|latexmath:[$B_1$] ^|latexmath:[$B_0$]
^|latexmath:[$G_{10}$] ^|latexmath:[$G_9$] ^|latexmath:[$G_8$] ^|latexmath:[$G_7$] ^|latexmath:[$G_6$] ^|latexmath:[$G_5$]
^|latexmath:[$G_4$] ^|latexmath:[$G_3$] ^|latexmath:[$G_2$] ^|latexmath:[$G_1$] ^|latexmath:[$G_0$]
^|latexmath:[$R_{10}$] ^|latexmath:[$R_9$] ^|latexmath:[$R_8$] ^|latexmath:[$R_7$] ^|latexmath:[$R_6$] ^|latexmath:[$R_5$]
^|latexmath:[$R_4$] ^|latexmath:[$R_3$] ^|latexmath:[$R_2$] ^|latexmath:[$R_1$] ^|latexmath:[$R_0$]
32+^s|VK_FORMAT_E5B9G9R9_UFLOAT_PACK32
^|latexmath:[$E_4$] ^|latexmath:[$E_3$] ^|latexmath:[$E_2$] ^|latexmath:[$E_1$] ^|latexmath:[$E_0$]
^|latexmath:[$B_8$] ^|latexmath:[$B_7$] ^|latexmath:[$B_6$] ^|latexmath:[$B_5$]
^|latexmath:[$B_4$] ^|latexmath:[$B_3$] ^|latexmath:[$B_2$] ^|latexmath:[$B_1$] ^|latexmath:[$B_0$]
^|latexmath:[$G_8$] ^|latexmath:[$G_7$] ^|latexmath:[$G_6$] ^|latexmath:[$G_5$]
^|latexmath:[$G_4$] ^|latexmath:[$G_3$] ^|latexmath:[$G_2$] ^|latexmath:[$G_1$] ^|latexmath:[$G_0$]
^|latexmath:[$R_8$] ^|latexmath:[$R_7$] ^|latexmath:[$R_6$] ^|latexmath:[$R_5$]
^|latexmath:[$R_4$] ^|latexmath:[$R_3$] ^|latexmath:[$R_2$] ^|latexmath:[$R_1$] ^|latexmath:[$R_0$]
32+^s|VK_FORMAT_X8_D24_UNORM_PACK32
^|latexmath:[$X_7$] ^|latexmath:[$X_6$] ^|latexmath:[$X_5$] ^|latexmath:[$X_4$]
^|latexmath:[$X_3$] ^|latexmath:[$X_2$] ^|latexmath:[$X_1$] ^|latexmath:[$X_0$]
^|latexmath:[$D_{23}$] ^|latexmath:[$D_{22}$] ^|latexmath:[$D_{21}$] ^|latexmath:[$D_{20}$]
^|latexmath:[$D_{19}$] ^|latexmath:[$D_{18}$] ^|latexmath:[$D_{17}$] ^|latexmath:[$D_{16}$]
^|latexmath:[$D_{15}$] ^|latexmath:[$D_{14}$] ^|latexmath:[$D_{13}$] ^|latexmath:[$D_{12}$]
^|latexmath:[$D_{11}$] ^|latexmath:[$D_{10}$] ^|latexmath:[$D_9$] ^|latexmath:[$D_8$]
^|latexmath:[$D_7$] ^|latexmath:[$D_6$] ^|latexmath:[$D_5$] ^|latexmath:[$D_4$]
^|latexmath:[$D_3$] ^|latexmath:[$D_2$] ^|latexmath:[$D_1$] ^|latexmath:[$D_0$]
|===============

[[features-formats-depth-stencil]]
==== Depth/Stencil Formats

Depth/stencil formats are considered opaque and need not
be stored in the exact number of bits per texel or component ordering
indicated by the format enum. However, implementations mustnot: substitute
a different depth or stencil precision than that described in the format
(e.g. D16 mustnot: be implemented as D24 or D32).


[[features-formats-compatibility-classes]]
==== Format Compatibility Classes

Uncompressed color formats are _compatible_ with each other if they occupy
the same number of bits per data element. Compressed color formats are
compatible with each other if the only difference between them is the
numerical type of the uncompressed pixels (e.g. signed vs. unsigned, or
SRGB vs. UNORM encoding). Each depth/stencil format is only compatible
with itself. In the <<features-formats-compatibility,following>> table,
all the formats in the same row are compatible.


[[features-formats-compatibility]]
.Compatible formats
[width="80%",cols="4,10",options="header"]
|=========================================
| Class           | Formats
| 8-bit           | ename:VK_FORMAT_R4G4_UNORM_PACK8, +
                    ename:VK_FORMAT_R8_UNORM, +
                    ename:VK_FORMAT_R8_SNORM, +
                    ename:VK_FORMAT_R8_USCALED, +
                    ename:VK_FORMAT_R8_SSCALED, +
                    ename:VK_FORMAT_R8_UINT, +
                    ename:VK_FORMAT_R8_SINT, +
                    ename:VK_FORMAT_R8_SRGB
| 16-bit          | ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16, +
                    ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16, +
                    ename:VK_FORMAT_R5G6B5_UNORM_PACK16, +
                    ename:VK_FORMAT_B5G6R5_UNORM_PACK16, +
                    ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16, +
                    ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16, +
                    ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16, +
                    ename:VK_FORMAT_R8G8_UNORM, +
                    ename:VK_FORMAT_R8G8_SNORM, +
                    ename:VK_FORMAT_R8G8_USCALED, +
                    ename:VK_FORMAT_R8G8_SSCALED, +
                    ename:VK_FORMAT_R8G8_UINT, +
                    ename:VK_FORMAT_R8G8_SINT, +
                    ename:VK_FORMAT_R8G8_SRGB, +
                    ename:VK_FORMAT_R16_UNORM, +
                    ename:VK_FORMAT_R16_SNORM, +
                    ename:VK_FORMAT_R16_USCALED, +
                    ename:VK_FORMAT_R16_SSCALED, +
                    ename:VK_FORMAT_R16_UINT, +
                    ename:VK_FORMAT_R16_SINT, +
                    ename:VK_FORMAT_R16_SFLOAT
| 24-bit          | ename:VK_FORMAT_R8G8B8_UNORM, +
                    ename:VK_FORMAT_R8G8B8_SNORM, +
                    ename:VK_FORMAT_R8G8B8_USCALED, +
                    ename:VK_FORMAT_R8G8B8_SSCALED, +
                    ename:VK_FORMAT_R8G8B8_UINT, +
                    ename:VK_FORMAT_R8G8B8_SINT, +
                    ename:VK_FORMAT_R8G8B8_SRGB, +
                    ename:VK_FORMAT_B8G8R8_UNORM, +
                    ename:VK_FORMAT_B8G8R8_SNORM, +
                    ename:VK_FORMAT_B8G8R8_USCALED, +
                    ename:VK_FORMAT_B8G8R8_SSCALED, +
                    ename:VK_FORMAT_B8G8R8_UINT, +
                    ename:VK_FORMAT_B8G8R8_SINT, +
                    ename:VK_FORMAT_B8G8R8_SRGB
| 32-bit          | ename:VK_FORMAT_R8G8B8A8_UNORM, +
                    ename:VK_FORMAT_R8G8B8A8_SNORM, +
                    ename:VK_FORMAT_R8G8B8A8_USCALED, +
                    ename:VK_FORMAT_R8G8B8A8_SSCALED, +
                    ename:VK_FORMAT_R8G8B8A8_UINT, +
                    ename:VK_FORMAT_R8G8B8A8_SINT, +
                    ename:VK_FORMAT_R8G8B8A8_SRGB, +
                    ename:VK_FORMAT_B8G8R8A8_UNORM, +
                    ename:VK_FORMAT_B8G8R8A8_SNORM, +
                    ename:VK_FORMAT_B8G8R8A8_USCALED, +
                    ename:VK_FORMAT_B8G8R8A8_SSCALED, +
                    ename:VK_FORMAT_B8G8R8A8_UINT, +
                    ename:VK_FORMAT_B8G8R8A8_SINT, +
                    ename:VK_FORMAT_B8G8R8A8_SRGB, +
                    ename:VK_FORMAT_A8B8G8R8_UNORM_PACK32, +
                    ename:VK_FORMAT_A8B8G8R8_SNORM_PACK32, +
                    ename:VK_FORMAT_A8B8G8R8_USCALED_PACK32, +
                    ename:VK_FORMAT_A8B8G8R8_SSCALED_PACK32, +
                    ename:VK_FORMAT_A8B8G8R8_UINT_PACK32, +
                    ename:VK_FORMAT_A8B8G8R8_SINT_PACK32, +
                    ename:VK_FORMAT_A8B8G8R8_SRGB_PACK32, +
                    ename:VK_FORMAT_A2R10G10B10_UNORM_PACK32, +
                    ename:VK_FORMAT_A2R10G10B10_SNORM_PACK32, +
                    ename:VK_FORMAT_A2R10G10B10_USCALED_PACK32, +
                    ename:VK_FORMAT_A2R10G10B10_SSCALED_PACK32, +
                    ename:VK_FORMAT_A2R10G10B10_UINT_PACK32, +
                    ename:VK_FORMAT_A2R10G10B10_SINT_PACK32, +
                    ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32, +
                    ename:VK_FORMAT_A2B10G10R10_SNORM_PACK32, +
                    ename:VK_FORMAT_A2B10G10R10_USCALED_PACK32, +
                    ename:VK_FORMAT_A2B10G10R10_SSCALED_PACK32, +
                    ename:VK_FORMAT_A2B10G10R10_UINT_PACK32, +
                    ename:VK_FORMAT_A2B10G10R10_SINT_PACK32, +
                    ename:VK_FORMAT_R16G16_UNORM, +
                    ename:VK_FORMAT_R16G16_SNORM, +
                    ename:VK_FORMAT_R16G16_USCALED, +
                    ename:VK_FORMAT_R16G16_SSCALED, +
                    ename:VK_FORMAT_R16G16_UINT, +
                    ename:VK_FORMAT_R16G16_SINT, +
                    ename:VK_FORMAT_R16G16_SFLOAT, +
                    ename:VK_FORMAT_R32_UINT, +
                    ename:VK_FORMAT_R32_SINT, +
                    ename:VK_FORMAT_R32_SFLOAT, +
                    ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32, +
                    ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32
| 48-bit          | ename:VK_FORMAT_R16G16B16_UNORM, +
                    ename:VK_FORMAT_R16G16B16_SNORM, +
                    ename:VK_FORMAT_R16G16B16_USCALED, +
                    ename:VK_FORMAT_R16G16B16_SSCALED, +
                    ename:VK_FORMAT_R16G16B16_UINT, +
                    ename:VK_FORMAT_R16G16B16_SINT, +
                    ename:VK_FORMAT_R16G16B16_SFLOAT
| 64-bit          | ename:VK_FORMAT_R16G16B16A16_UNORM, +
                    ename:VK_FORMAT_R16G16B16A16_SNORM, +
                    ename:VK_FORMAT_R16G16B16A16_USCALED, +
                    ename:VK_FORMAT_R16G16B16A16_SSCALED, +
                    ename:VK_FORMAT_R16G16B16A16_UINT, +
                    ename:VK_FORMAT_R16G16B16A16_SINT, +
                    ename:VK_FORMAT_R16G16B16A16_SFLOAT, +
                    ename:VK_FORMAT_R32G32_UINT, +
                    ename:VK_FORMAT_R32G32_SINT, +
                    ename:VK_FORMAT_R32G32_SFLOAT, +
                    ename:VK_FORMAT_R64_UINT, +
                    ename:VK_FORMAT_R64_SINT, +
                    ename:VK_FORMAT_R64_SFLOAT
| 96-bit          | ename:VK_FORMAT_R32G32B32_UINT, +
                    ename:VK_FORMAT_R32G32B32_SINT, +
                    ename:VK_FORMAT_R32G32B32_SFLOAT
| 128-bit         | ename:VK_FORMAT_R32G32B32A32_UINT, +
                    ename:VK_FORMAT_R32G32B32A32_SINT, +
                    ename:VK_FORMAT_R32G32B32A32_SFLOAT, +
                    ename:VK_FORMAT_R64G64_UINT, +
                    ename:VK_FORMAT_R64G64_SINT, +
                    ename:VK_FORMAT_R64G64_SFLOAT
| 192-bit         | ename:VK_FORMAT_R64G64B64_UINT, +
                    ename:VK_FORMAT_R64G64B64_SINT, +
                    ename:VK_FORMAT_R64G64B64_SFLOAT
| 256-bit         | ename:VK_FORMAT_R64G64B64A64_UINT, +
                    ename:VK_FORMAT_R64G64B64A64_SINT, +
                    ename:VK_FORMAT_R64G64B64A64_SFLOAT
| BC1_RGB         | ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK
| BC1_RGBA        | ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK
| BC2             | ename:VK_FORMAT_BC2_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC2_SRGB_BLOCK
| BC3             | ename:VK_FORMAT_BC3_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC3_SRGB_BLOCK
| BC4             | ename:VK_FORMAT_BC4_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC4_SNORM_BLOCK
| BC5             | ename:VK_FORMAT_BC5_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC5_SNORM_BLOCK
| BC6H            | ename:VK_FORMAT_BC6H_UFLOAT_BLOCK, +
                    ename:VK_FORMAT_BC6H_SFLOAT_BLOCK
| BC7             | ename:VK_FORMAT_BC7_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC7_SRGB_BLOCK
| ETC2_RGB        | ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK, +
                    ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
| ETC2_RGBA       | ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK, +
                    ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
| ETC2_EAC_RGBA   | ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK, +
                    ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
| EAC_R           | ename:VK_FORMAT_EAC_R11_UNORM_BLOCK, +
                    ename:VK_FORMAT_EAC_R11_SNORM_BLOCK
| EAC_RG          | ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK, +
                    ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK
| ASTC_4x4        | ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK
| ASTC_5x4        | ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK
| ASTC_5x5        | ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK
| ASTC_6x5        | ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK
| ASTC_6x6        | ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK
| ASTC_8x5        | ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK
| ASTC_8x6        | ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK
| ASTC_8x8        | ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK
| ASTC_10x5       | ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK
| ASTC_10x6       | ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK
| ASTC_10x8       | ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK
| ASTC_10x10      | ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK
| ASTC_12x10      | ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK
| ASTC_12x12      | ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK
| D16             | ename:VK_FORMAT_D16_UNORM
| D24             | ename:VK_FORMAT_X8_D24_UNORM_PACK32
| D32             | ename:VK_FORMAT_D32_SFLOAT
| S8              | ename:VK_FORMAT_S8_UINT
| D16S8           | ename:VK_FORMAT_D16_UNORM_S8_UINT
| D24S8           | ename:VK_FORMAT_D24_UNORM_S8_UINT
| D32S8           | ename:VK_FORMAT_D32_SFLOAT_S8_UINT
|=========================================


[[features-formats-properties]]
=== Format Properties

// refBegin vkGetPhysicalDeviceFormatProperties Lists physical device's format capabilities.

To query supported format features which are properties of the physical
device, call:

include::../api/protos/vkGetPhysicalDeviceFormatProperties.txt[]

  * pname:physicalDevice is the physical device from which to query the
    format properties.
  * pname:format is the format whose properties are queried.
  * pname:pFormatProperties is a pointer to a slink:VkFormatProperties
    structure in which physical device properties for pname:format are
    returned.

include::../validity/protos/vkGetPhysicalDeviceFormatProperties.txt[]

// refBegin VkFormatProperties - Structure specifying image format properties

The sname:VkPhysicalDeviceLimits structure is defined as:

include::../api/structs/VkFormatProperties.txt[]

  * pname:linearTilingFeatures describes the features supported by
    ename:VK_IMAGE_TILING_LINEAR.
  * pname:optimalTilingFeatures describes the features supported by
    ename:VK_IMAGE_TILING_OPTIMAL.
  * pname:bufferFeatures describes the features supported by buffers.

Supported features are described as a set of elink:VkFormatFeatureFlagBits:

// refBegin VkFormatFeatureFlagBits - Bitmask specifying features supported by a buffer
include::../api/enums/VkFormatFeatureFlagBits.txt[]

The pname:linearTilingFeatures and pname:optimalTilingFeatures members of
the sname:VkFormatProperties structure describe what features are supported
by ename:VK_IMAGE_TILING_LINEAR and ename:VK_IMAGE_TILING_OPTIMAL images,
respectively.

The following bits may: be set in pname:linearTilingFeatures and
pname:optimalTilingFeatures, indicating they are supported by images or
image views created with the queried
flink:vkGetPhysicalDeviceFormatProperties::pname:format:

ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT::
    sname:VkImageView can: be sampled from. See
    <<descriptorsets-sampledimage, sampled images>> section.

ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT::
    sname:VkImageView can: be used as storage image. See
    <<descriptorsets-storageimage, storage images>> section.

ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT::
    sname:VkImageView can: be used as storage image that supports atomic
    operations.

ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT::
    sname:VkImageView can: be used as a framebuffer color attachment and
    as an input attachment.

ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT::
    sname:VkImageView can: be used as a framebuffer color attachment that
    supports blending and as an input attachment.

ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT::
    sname:VkImageView can: be used as a framebuffer depth/stencil attachment
    and as an input attachment.

ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT::
    sname:VkImage can: be used as pname:srcImage for the
    fname:vkCmdBlitImage command.

ename:VK_FORMAT_FEATURE_BLIT_DST_BIT::
    sname:VkImage can: be used as pname:dstImage for the
    fname:vkCmdBlitImage command.

ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT::
    If ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT is also set,
    sname:VkImageView can: be used with a sampler that has either of
    pname:magFilter or pname:minFilter set to ename:VK_FILTER_LINEAR,
    or pname:mipmapMode set to ename:VK_SAMPLER_MIPMAP_MODE_LINEAR.
    If ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT is also set, sname:VkImage
    can be used as the pname:srcImage to flink:vkCmdBlitImage
    with a pname:filter of ename:VK_FILTER_LINEAR. This bit must: only be
    exposed for formats that also support the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT or
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT.
+
If the format being queried is a depth/stencil format, this bit only indicates
    that the depth aspect (not the stencil aspect) of an image of this format
    supports linear filtering,
    and that linear filtering of the depth aspect is supported whether depth
    compare is enabled in the sampler or not. If this bit is not present,
    linear filtering with depth compare disabled is unsupported and linear
    filtering with depth compare enabled is supported, but may: compute the
    filtered value in an implementation-dependent manner which differs from
    the normal rules of linear filtering. The resulting value must: be in the
    range latexmath:[$[0,1\]$] and should: be proportional to, or a weighted
    average of, the number of comparison passes or failures.

The following features may: appear in pname:bufferFeatures, indicating they
are supported by buffers or buffer views created with the queried
flink:vkGetPhysicalDeviceFormatProperties::pname:format:

ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT::
    Format can: be used to create a sname:VkBufferView that can: be bound to
    a ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER descriptor.

ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT::
    Format can: be used to create a sname:VkBufferView that can: be bound to
    a ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor.

ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT::
    Atomic operations are supported on
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER with this format.

ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT::
    Format can: be used as a vertex attribute format
    (sname:VkVertexInputAttributeDescription::pname:format).

[NOTE]
.Note
====
If no format feature flags are supported, then the only possible use would
be image transfers - which alone are not useful.
As such, if no format feature flags are supported, the format itself is not
supported, and images of that format cannot be created.
====

If pname:format is a block-compression format, then buffers mustnot: support
any features for the format.

include::../validity/structs/VkFormatProperties.txt[]


[[features-required-format-support]]
=== Required Format Support

Implementations must: support at least the following set of
features on the listed formats. For images, these features must:
be supported for every elink:VkImageType (including arrayed and cube
variants) unless otherwise noted. These features are supported
on existing formats without needing to advertise an extension or
needing to explicitly enable them. Support for additional functionality
beyond the requirements listed here is queried using the
flink:vkGetPhysicalDeviceFormatProperties command.

The following tables show which feature bits must: be supported
for each format.

.Key for format feature tables
[width="70%",cols="1,10"]
|============
^|{sym1} | This feature must: be supported on the named format
^|{sym2} | This feature must: be supported on at least some
of the named formats, with more information in the table
where the symbol appears
|============

.Feature bits in pname:optimalTilingFeatures
[width="70%"]
|============
|ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
|ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT
|ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
|ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT
|ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
|ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT
|ename:VK_FORMAT_FEATURE_BLIT_DST_BIT
|ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
|ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
|============

.Feature bits in pname:bufferFeatures
[width="70%"]
|============
|ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT
|ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT
|ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT
|ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
|============

<<<

[[features-formats-mandatory-features-subbyte]]
.Mandatory format support: sub-byte channels
[width="100%",cols="62,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|=========================================
14+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT      .13+^.^|latexmath:[$\downarrow$]
12+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT      .12+^.^|latexmath:[$\downarrow$]
11+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT             .11+^.^|latexmath:[$\downarrow$]
10+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT  .10+^.^|latexmath:[$\downarrow$]
9+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT      .9+^.^|latexmath:[$\downarrow$]
8+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                    .8+^.^|latexmath:[$\downarrow$]
7+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT            .7+^.^|latexmath:[$\downarrow$]
6+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT        .6+^.^|latexmath:[$\downarrow$]
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT               .5+^.^|latexmath:[$\downarrow$]
4+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT .4+^.^|latexmath:[$\downarrow$]
3+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                    .3+^.^|latexmath:[$\downarrow$]
2+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT               .2+^.^|latexmath:[$\downarrow$]
s| Format                                                  ^.^|latexmath:[$\downarrow$]
| ename:VK_FORMAT_UNDEFINED                  |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R4G4_UNORM_PACK8           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16      |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16      | {sym1} | {sym1} | {sym1} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R5G6B5_UNORM_PACK16        | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   |   |   |   |
| ename:VK_FORMAT_B5G6R5_UNORM_PACK16        |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16      |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16      |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16      | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   |   |   |   |
|=========================================

<<<

[[features-formats-mandatory-features-2byte]]
.Mandatory format support: 1-3 byte-sized channels
[width="100%",cols="62,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|=========================================
14+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT      .13+^.^|latexmath:[$\downarrow$]
12+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT      .12+^.^|latexmath:[$\downarrow$]
11+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT             .11+^.^|latexmath:[$\downarrow$]
10+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT  .10+^.^|latexmath:[$\downarrow$]
9+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT      .9+^.^|latexmath:[$\downarrow$]
8+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                    .8+^.^|latexmath:[$\downarrow$]
7+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT            .7+^.^|latexmath:[$\downarrow$]
6+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT        .6+^.^|latexmath:[$\downarrow$]
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT               .5+^.^|latexmath:[$\downarrow$]
4+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT .4+^.^|latexmath:[$\downarrow$]
3+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                    .3+^.^|latexmath:[$\downarrow$]
2+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT               .2+^.^|latexmath:[$\downarrow$]
s| Format                                                  ^.^|latexmath:[$\downarrow$]
| ename:VK_FORMAT_R8_UNORM                   | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8_SNORM                   | {sym1} | {sym1} | {sym1} |   |   |   |   |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8_USCALED                 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8_SSCALED                 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8_UINT                    | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8_SINT                    | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8_SRGB                    |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8_UNORM                 | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8G8_SNORM                 | {sym1} | {sym1} | {sym1} |   |   |   |   |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8G8_USCALED               |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8_SSCALED               |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8_UINT                  | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8G8_SINT                  | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8G8_SRGB                  |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_UNORM               |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_SNORM               |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_USCALED             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_SSCALED             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_UINT                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_SINT                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_SRGB                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_UNORM               |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_SNORM               |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_USCALED             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_SSCALED             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_UINT                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_SINT                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_SRGB                |   |   |   |   |   |   |   |   |   |   |   |   |
|=========================================

<<<

[[features-formats-mandatory-features-4byte]]
.Mandatory format support: 4 byte-sized channels
[width="100%",cols="62,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|=========================================
14+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT      .13+^.^|latexmath:[$\downarrow$]
12+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT      .12+^.^|latexmath:[$\downarrow$]
11+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT             .11+^.^|latexmath:[$\downarrow$]
10+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT  .10+^.^|latexmath:[$\downarrow$]
9+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT      .9+^.^|latexmath:[$\downarrow$]
8+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                    .8+^.^|latexmath:[$\downarrow$]
7+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT            .7+^.^|latexmath:[$\downarrow$]
6+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT        .6+^.^|latexmath:[$\downarrow$]
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT               .5+^.^|latexmath:[$\downarrow$]
4+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT .4+^.^|latexmath:[$\downarrow$]
3+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                    .3+^.^|latexmath:[$\downarrow$]
2+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT               .2+^.^|latexmath:[$\downarrow$]
s| Format                                                  ^.^|latexmath:[$\downarrow$]
| ename:VK_FORMAT_R8G8B8A8_UNORM             | {sym1} | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R8G8B8A8_SNORM             | {sym1} | {sym1} | {sym1} | {sym1} |   |   |   |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R8G8B8A8_USCALED           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8A8_SSCALED           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8A8_UINT              | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R8G8B8A8_SINT              | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R8G8B8A8_SRGB              | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   |   |   |   |
| ename:VK_FORMAT_B8G8R8A8_UNORM             | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_B8G8R8A8_SNORM             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8A8_USCALED           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8A8_SSCALED           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8A8_UINT              |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8A8_SINT              |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8A8_SRGB              | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   |   |   |   |
| ename:VK_FORMAT_A8B8G8R8_UNORM_PACK32      | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_A8B8G8R8_SNORM_PACK32      | {sym1} | {sym1} | {sym1} |   |   |   |   |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_A8B8G8R8_USCALED_PACK32    |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A8B8G8R8_SSCALED_PACK32    |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A8B8G8R8_UINT_PACK32       | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_A8B8G8R8_SINT_PACK32       | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_A8B8G8R8_SRGB_PACK32       | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   |   |   |   |
|=========================================

<<<

[[features-formats-mandatory-features-10bit]]
.Mandatory format support: 10-bit channels
[width="100%",cols="62,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|=========================================
14+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT      .13+^.^|latexmath:[$\downarrow$]
12+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT      .12+^.^|latexmath:[$\downarrow$]
11+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT             .11+^.^|latexmath:[$\downarrow$]
10+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT  .10+^.^|latexmath:[$\downarrow$]
9+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT      .9+^.^|latexmath:[$\downarrow$]
8+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                    .8+^.^|latexmath:[$\downarrow$]
7+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT            .7+^.^|latexmath:[$\downarrow$]
6+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT        .6+^.^|latexmath:[$\downarrow$]
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT               .5+^.^|latexmath:[$\downarrow$]
4+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT .4+^.^|latexmath:[$\downarrow$]
3+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                    .3+^.^|latexmath:[$\downarrow$]
2+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT               .2+^.^|latexmath:[$\downarrow$]
s| Format                                                  ^.^|latexmath:[$\downarrow$]
| ename:VK_FORMAT_A2R10G10B10_UNORM_PACK32   |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2R10G10B10_SNORM_PACK32   |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2R10G10B10_USCALED_PACK32 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2R10G10B10_SSCALED_PACK32 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2R10G10B10_UINT_PACK32    |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2R10G10B10_SINT_PACK32    |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32   | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_A2B10G10R10_SNORM_PACK32   |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2B10G10R10_USCALED_PACK32 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2B10G10R10_SSCALED_PACK32 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2B10G10R10_UINT_PACK32    | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   |   | {sym1} |   |
| ename:VK_FORMAT_A2B10G10R10_SINT_PACK32    |   |   |   |   |   |   |   |   |   |   |   |   |
|=========================================

<<<

[[features-formats-mandatory-features-16bit]]
.Mandatory format support: 16-bit channels
[width="100%",cols="62,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|=========================================
14+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT      .13+^.^|latexmath:[$\downarrow$]
12+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT      .12+^.^|latexmath:[$\downarrow$]
11+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT             .11+^.^|latexmath:[$\downarrow$]
10+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT  .10+^.^|latexmath:[$\downarrow$]
9+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT      .9+^.^|latexmath:[$\downarrow$]
8+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                    .8+^.^|latexmath:[$\downarrow$]
7+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT            .7+^.^|latexmath:[$\downarrow$]
6+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT        .6+^.^|latexmath:[$\downarrow$]
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT               .5+^.^|latexmath:[$\downarrow$]
4+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT .4+^.^|latexmath:[$\downarrow$]
3+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                    .3+^.^|latexmath:[$\downarrow$]
2+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT               .2+^.^|latexmath:[$\downarrow$]
s| Format                                                  ^.^|latexmath:[$\downarrow$]
| ename:VK_FORMAT_R16_UNORM                  |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R16_SNORM                  |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R16_USCALED                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16_SSCALED                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16_UINT                   | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R16_SINT                   | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R16_SFLOAT                 | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R16G16_UNORM               |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R16G16_SNORM               |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R16G16_USCALED             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16_SSCALED             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16_UINT                | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R16G16_SINT                | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R16G16_SFLOAT              | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R16G16B16_UNORM            |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16_SNORM            |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16_USCALED          |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16_SSCALED          |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16_UINT             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16_SINT             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16_SFLOAT           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16A16_UNORM         |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R16G16B16A16_SNORM         |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R16G16B16A16_USCALED       |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16A16_SSCALED       |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16A16_UINT          | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R16G16B16A16_SINT          | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R16G16B16A16_SFLOAT        | {sym1} | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} |
|=========================================

<<<

[[features-formats-mandatory-features-32bit]]
.Mandatory format support: 32-bit channels
[width="100%",cols="62,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|=========================================
14+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT      .13+^.^|latexmath:[$\downarrow$]
12+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT      .12+^.^|latexmath:[$\downarrow$]
11+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT             .11+^.^|latexmath:[$\downarrow$]
10+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT  .10+^.^|latexmath:[$\downarrow$]
9+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT      .9+^.^|latexmath:[$\downarrow$]
8+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                    .8+^.^|latexmath:[$\downarrow$]
7+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT            .7+^.^|latexmath:[$\downarrow$]
6+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT        .6+^.^|latexmath:[$\downarrow$]
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT               .5+^.^|latexmath:[$\downarrow$]
4+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT .4+^.^|latexmath:[$\downarrow$]
3+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                    .3+^.^|latexmath:[$\downarrow$]
2+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT               .2+^.^|latexmath:[$\downarrow$]
s| Format                                                  ^.^|latexmath:[$\downarrow$]
| ename:VK_FORMAT_R32_UINT                   | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} | {sym1}
| ename:VK_FORMAT_R32_SINT                   | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} | {sym1}
| ename:VK_FORMAT_R32_SFLOAT                 | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R32G32_UINT                | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R32G32_SINT                | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R32G32_SFLOAT              | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R32G32B32_UINT             |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R32G32B32_SINT             |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R32G32B32_SFLOAT           |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R32G32B32A32_UINT          | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R32G32B32A32_SINT          | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R32G32B32A32_SFLOAT        | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
|=========================================

<<<

[[features-formats-mandatory-features-64bit]]
.Mandatory format support: 64-bit/uneven channels and depth/stencil
[width="100%",cols="62,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|=========================================
14+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT      .13+^.^|latexmath:[$\downarrow$]
12+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT      .12+^.^|latexmath:[$\downarrow$]
11+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT             .11+^.^|latexmath:[$\downarrow$]
10+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT  .10+^.^|latexmath:[$\downarrow$]
9+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT      .9+^.^|latexmath:[$\downarrow$]
8+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                    .8+^.^|latexmath:[$\downarrow$]
7+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT            .7+^.^|latexmath:[$\downarrow$]
6+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT        .6+^.^|latexmath:[$\downarrow$]
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT               .5+^.^|latexmath:[$\downarrow$]
4+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT .4+^.^|latexmath:[$\downarrow$]
3+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                    .3+^.^|latexmath:[$\downarrow$]
2+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT               .2+^.^|latexmath:[$\downarrow$]
s| Format                                                  ^.^|latexmath:[$\downarrow$]
| ename:VK_FORMAT_R64_UINT                   |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64_SINT                   |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64_SFLOAT                 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64_UINT                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64_SINT                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64_SFLOAT              |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64B64_UINT             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64B64_SINT             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64B64_SFLOAT           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64B64A64_UINT          |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64B64A64_SINT          |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64B64A64_SFLOAT        |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32    | {sym1} | {sym1} | {sym1} |   |   |   |   |   |   |   | {sym1} |   |
| ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32     | {sym1} | {sym1} | {sym1} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_D16_UNORM                  | {sym1} | {sym1} |   |   |   |   |   |   | {sym1} |   |   |   |
| ename:VK_FORMAT_X8_D24_UNORM_PACK32        |   |   |   |   |   |   |   |   | {sym2} |   |   |   |
| ename:VK_FORMAT_D32_SFLOAT                 | {sym1} | {sym1} |   |   |   |   |   |   | {sym2} |   |   |   |
| ename:VK_FORMAT_S8_UINT                    |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_D16_UNORM_S8_UINT          |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_D24_UNORM_S8_UINT          |   |   |   |   |   |   |   |   | {sym2} |   |   |   |
| ename:VK_FORMAT_D32_SFLOAT_S8_UINT         |   |   |   |   |   |   |   |   | {sym2} |   |   |   |
14+| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT feature must: be
supported for at least one of ename:VK_FORMAT_X8_D24_UNORM_PACK32 and
ename:VK_FORMAT_D32_SFLOAT, and must: be supported for at least one of
ename:VK_FORMAT_D24_UNORM_S8_UINT and ename:VK_FORMAT_D32_SFLOAT_S8_UINT.
|=========================================

<<<

[[features-formats-mandatory-features-bcn]]
.Mandatory format support: BC compressed formats with elink:VkImageType ename:VK_IMAGE_TYPE_2D and ename:VK_IMAGE_TYPE_3D
[width="100%",cols="62,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|=========================================
14+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT      .13+^.^|latexmath:[$\downarrow$]
12+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT      .12+^.^|latexmath:[$\downarrow$]
11+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT             .11+^.^|latexmath:[$\downarrow$]
10+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT  .10+^.^|latexmath:[$\downarrow$]
9+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT      .9+^.^|latexmath:[$\downarrow$]
8+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                    .8+^.^|latexmath:[$\downarrow$]
7+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT            .7+^.^|latexmath:[$\downarrow$]
6+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT        .6+^.^|latexmath:[$\downarrow$]
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT               .5+^.^|latexmath:[$\downarrow$]
4+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT .4+^.^|latexmath:[$\downarrow$]
3+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                    .3+^.^|latexmath:[$\downarrow$]
2+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT               .2+^.^|latexmath:[$\downarrow$]
s| Format                                                  ^.^|latexmath:[$\downarrow$]
| ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK         | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC2_UNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC2_SRGB_BLOCK             | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC3_UNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC3_SRGB_BLOCK             | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC4_UNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC4_SNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC5_UNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC5_SNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC6H_UFLOAT_BLOCK          | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC6H_SFLOAT_BLOCK          | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC7_UNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC7_SRGB_BLOCK             | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
14+|The ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must: be
supported in pname:optimalTilingFeatures for all the formats in at least
one of: this table, <<features-formats-mandatory-features-etc>>, or
<<features-formats-mandatory-features-astc>>.
|=========================================

<<<

[[features-formats-mandatory-features-etc]]
.Mandatory format support: ETC2 and EAC compressed formats with elink:VkImageType ename:VK_IMAGE_TYPE_2D
[width="100%",cols="62,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|=========================================
14+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT      .13+^.^|latexmath:[$\downarrow$]
12+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT      .12+^.^|latexmath:[$\downarrow$]
11+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT             .11+^.^|latexmath:[$\downarrow$]
10+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT  .10+^.^|latexmath:[$\downarrow$]
9+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT      .9+^.^|latexmath:[$\downarrow$]
8+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                    .8+^.^|latexmath:[$\downarrow$]
7+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT            .7+^.^|latexmath:[$\downarrow$]
6+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT        .6+^.^|latexmath:[$\downarrow$]
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT               .5+^.^|latexmath:[$\downarrow$]
4+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT .4+^.^|latexmath:[$\downarrow$]
3+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                    .3+^.^|latexmath:[$\downarrow$]
2+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT               .2+^.^|latexmath:[$\downarrow$]
s| Format                                                  ^.^|latexmath:[$\downarrow$]
| ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK    | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK     | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK  | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK   | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK  | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK   | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_EAC_R11_UNORM_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_EAC_R11_SNORM_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK     | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK     | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
14+|The ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must: be
supported in pname:optimalTilingFeatures for all the formats in at least
one of: this table, <<features-formats-mandatory-features-bcn>>, or
<<features-formats-mandatory-features-astc>>.
|=========================================

<<<

[[features-formats-mandatory-features-astc]]
.Mandatory format support: ASTC LDR compressed formats with elink:VkImageType ename:VK_IMAGE_TYPE_2D
[width="100%",cols="62,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|=========================================
14+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT      .13+^.^|latexmath:[$\downarrow$]
12+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT      .12+^.^|latexmath:[$\downarrow$]
11+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT             .11+^.^|latexmath:[$\downarrow$]
10+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT  .10+^.^|latexmath:[$\downarrow$]
9+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT      .9+^.^|latexmath:[$\downarrow$]
8+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                    .8+^.^|latexmath:[$\downarrow$]
7+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT            .7+^.^|latexmath:[$\downarrow$]
6+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT        .6+^.^|latexmath:[$\downarrow$]
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT               .5+^.^|latexmath:[$\downarrow$]
4+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT .4+^.^|latexmath:[$\downarrow$]
3+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                    .3+^.^|latexmath:[$\downarrow$]
2+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT               .2+^.^|latexmath:[$\downarrow$]
s| Format                                                  ^.^|latexmath:[$\downarrow$]
| ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK      | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK      | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK      | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK     | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK      | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK     | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK      | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK     | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK      | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
14+|The ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must: be
supported in pname:optimalTilingFeatures for all the formats in at least
one of: this table, <<features-formats-mandatory-features-bcn>>, or
<<features-formats-mandatory-features-etc>>.
|=========================================


== Additional Image Capabilities

In addition to the minimum capabilities described in the previous sections
(<<features-limits,Limits>> and <<features-formats,Formats>>),
implementations may: support additional capabilities for certain types of
images. For example, larger dimensions or additional sample counts for
certain image types, or additional capabilities for _linear_ tiling format
images.

// refBegin vkGetPhysicalDeviceImageFormatProperties Lists physical device's image format capabilities.

To query additional capabilities specific to image types, call:

include::../api/protos/vkGetPhysicalDeviceImageFormatProperties.txt[]

  * pname:physicalDevice is the physical device from which to query the
    image capabilities.
  * pname:format is the image format, corresponding to
    slink:VkImageCreateInfo::pname:format.
  * pname:type is the image type, corresponding to
    slink:VkImageCreateInfo::pname:imageType.
  * pname:tiling is the image tiling, corresponding to
    slink:VkImageCreateInfo::pname:tiling.
  * pname:usage is the intended usage of the image, corresponding to
    slink:VkImageCreateInfo::pname:usage.
  * pname:flags is a bitmask describing additional parameters of the image,
    corresponding to slink:VkImageCreateInfo::pname:flags.
  * pname:pImageFormatProperties points to an instance of the
    slink:VkImageFormatProperties structure in which capabilities are
    returned.

The pname:format, pname:type, pname:tiling, pname:usage, and pname:flags
parameters correspond to parameters that would be consumed by
flink:vkCreateImage.

If pname:format is not a supported image format, or if the combination of
pname:format, pname:type, pname:tiling, pname:usage, and pname:flags is not
supported for images, then fname:vkGetPhysicalDeviceImageFormatProperties
returns ename:VK_ERROR_FORMAT_NOT_SUPPORTED.

The limitations on an image format that are reported by
fname:vkGetPhysicalDeviceImageFormatProperties have the following property:
if code:usage1 and code:usage2 of type elink:VkImageUsageFlags are such that
the bits set in code:usage1 are a subset of the bits set in code:usage2, and
code:flags1 and code:flags2 of type elink:VkImageCreateFlags are such that
the bits set in code:flags1 are a subset of the bits set in code:flags2,
then the limitations for code:usage1 and code:flags1 must: be no more strict
than the limitations for code:usage2 and code:flags2, for all values of
pname:format, pname:type, and pname:tiling.

include::../validity/protos/vkGetPhysicalDeviceImageFormatProperties.txt[]

// refBegin VkImageFormatProperties - Structure specifying a image format properties

The sname:VkImageFormatProperties structure is defined as:

include::../api/structs/VkImageFormatProperties.txt[]

  * pname:maxExtent are the maximum image dimensions. See the
    <<features-extentperimagetype,Allowed Extent Values>> section below for
    how these values are constrained by pname:type.
  * pname:maxMipLevels is the maximum number of mipmap levels.
    pname:maxMipLevels must: either be equal to 1 (valid only if
    pname:tiling is ename:VK_IMAGE_TILING_LINEAR) or be
    equal to
        latexmath:[$\left\lceil\log_2(\max(
                    \mathit{width},\mathit{height},\mathit{depth}))
                    \right\rceil + 1$]
    where latexmath:[$\mathit{width}$], latexmath:[$\mathit{height}$], and
    latexmath:[$\mathit{depth}$] are taken from the corresponding members of
    pname:maxExtent.
  * pname:maxArrayLayers is the maximum number of array layers.
    pname:maxArrayLayers must: either be equal to 1 or be greater than or
    equal to the pname:maxImageArrayLayers member of
    slink:VkPhysicalDeviceLimits. A value of 1 is valid only if pname:tiling
    is ename:VK_IMAGE_TILING_LINEAR or if pname:type is
    ename:VK_IMAGE_TYPE_3D.
  * pname:sampleCounts is a bitmask of elink:VkSampleCountFlagBits
    specifying all the supported sample counts for this image as described
    <<features-supported-sample-counts, below>>.
  * pname:maxResourceSize is an upper bound on the total image size in bytes,
    inclusive of all image subresources. Implementations may: have an
    address space limit on total size of a resource, which is advertised by
    this property. pname:maxResourceSize must: be at least 2^31^.

[NOTE]
.Note
====
There is no mechanism to query the size of an image before creating it, to
compare that size against pname:maxResourceSize. If an application attempts
to create an image that exceeds this limit, the creation will fail or the
image will be invalid. While the advertised limit must: be at least 2^31^,
it may: not be possible to create an image that approaches that size,
particularly for ename:VK_IMAGE_TYPE_1D.
====

If the combination of parameters to
fname:vkGetPhysicalDeviceImageFormatProperties is not supported by the
implementation for use in flink:vkCreateImage, then all members of
sname:VkImageFormatProperties will be filled with zero.

include::../validity/structs/VkImageFormatProperties.txt[]


[[features-supported-sample-counts]]
=== Supported Sample Counts
fname:vkGetPhysicalDeviceImageFormatProperties returns a bitmask of
elink:VkSampleCountFlagBits in pname:sampleCounts specifying the supported
sample counts for the image parameters.

pname:sampleCounts will be set to ename:VK_SAMPLE_COUNT_1_BIT if at least
one of the following conditions is true:
 * pname:tiling is ename:VK_IMAGE_TILING_LINEAR
 * pname:type is not ename:VK_IMAGE_TYPE_2D
 * The ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT flag in
   sname:VkFormatProperties::pname:optimalTilingFeatures returned by
   flink:vkGetPhysicalDeviceFormatProperties is not set

Otherwise, the bits set in pname:sampleCounts will be the sample counts
supported for the specified values of pname:usage and pname:format. For
each bit set in pname:usage, the supported sample counts relate to the
limits in sname:VkPhysicalDeviceLimits as follows:

 * If pname:usage includes ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
   a superset of sname:VkPhysicalDeviceLimits::pname:framebufferColorSampleCounts
 * If pname:usage includes ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
   and pname:format includes a depth aspect, a superset of
   sname:VkPhysicalDeviceLimits::pname:framebufferDepthSampleCounts
 * If pname:usage includes ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
   and pname:format includes a stencil aspect, a superset of
   sname:VkPhysicalDeviceLimits::pname:framebufferStencilSampleCounts
 * If pname:usage includes ename:VK_IMAGE_USAGE_SAMPLED_BIT, and pname:format
   includes a color aspect, a superset of
   sname:VkPhysicalDeviceLimits::pname:sampledImageColorSampleCounts
 * If pname:usage includes ename:VK_IMAGE_USAGE_SAMPLED_BIT, and pname:format
   includes a depth aspect, a superset of
   sname:VkPhysicalDeviceLimits::pname:sampledImageDepthSampleCounts
 * If pname:usage includes ename:VK_IMAGE_USAGE_SAMPLED_BIT, and pname:format
   is an integer format, a superset of
   sname:VkPhysicalDeviceLimits::pname:sampledImageIntegerSampleCounts
 * If pname:usage includes ename:VK_IMAGE_USAGE_STORAGE_BIT, a superset of
   sname:VkPhysicalDeviceLimits::pname:storageImageSampleCounts

If multiple bits are set in pname:usage, pname:sampleCounts will be the
intersection of the per-usage values described above.


[[features-extentperimagetype]]
=== Allowed Extent Values Based On Image Type

For ename:VK_IMAGE_TYPE_1D:

  * latexmath:[$\mathit{maxExtent.width} \leq
                \mathit{VkPhysicalDeviceLimits.maxImageDimension1D}$]
  * latexmath:[$\mathit{maxExtent.height} = 1$]
  * latexmath:[$\mathit{maxExtent.depth} = 1$]

For ename:VK_IMAGE_TYPE_2D:

  * latexmath:[$\mathit{maxExtent.width} \leq
                \mathit{VkPhysicalDeviceLimits.maxImageDimension2D}$]
  * latexmath:[$\mathit{maxExtent.height} \leq
                \mathit{VkPhysicalDeviceLimits.maxImageDimension2D}$]
  * latexmath:[$\mathit{maxExtent.depth} = 1$]

For ename:VK_IMAGE_TYPE_3D:

  * latexmath:[$\mathit{maxExtent.width} \leq
                \mathit{VkPhysicalDeviceLimits.maxImageDimension3D}$]
  * latexmath:[$\mathit{maxExtent.height} \leq
                \mathit{VkPhysicalDeviceLimits.maxImageDimension3D}$]
  * latexmath:[$\mathit{maxExtent.depth} \leq
                \mathit{VkPhysicalDeviceLimits.maxImageDimension3D}$]
