// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[drawing]]
= 绘制命令

_Drawing commands_ (commands with ftext:Draw in the name) provoke work in a
graphics pipeline.
Drawing commands are recorded into a command buffer and when executed by a
queue, will produce work which executes according to the currently bound
graphics pipeline.
A graphics pipeline must: be bound to a command buffer before any drawing
commands are recorded in that command buffer.

// refBegin VkPipelineInputAssemblyStateCreateInfo Structure specifying parameters of a newly created pipeline input assembly state

Each draw is made up of zero or more vertices and zero or more instances,
which are processed by the device and result in the assembly of primitives.
Primitives are assembled according to the pname:pInputAssemblyState member
of the sname:VkGraphicsPipelineCreateInfo structure, which is of type
sname:VkPipelineInputAssemblyStateCreateInfo:

include::../api/structs/VkPipelineInputAssemblyStateCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags is reserved for future use.
  * pname:topology is a elink:VkPrimitiveTopology defining the primitive
    topology, as described below.
  * pname:primitiveRestartEnable controls whether a special vertex index
    value is treated as restarting the assembly of primitives.
    This enable only applies to indexed draws (flink:vkCmdDrawIndexed and
    flink:vkCmdDrawIndexedIndirect), and the special index value is either
    0xFFFFFFFF when the pname:indexType parameter of
    fname:vkCmdBindIndexBuffer is equal to ename:VK_INDEX_TYPE_UINT32, or
    0xFFFF when pname:indexType is equal to ename:VK_INDEX_TYPE_UINT16.
    Primitive restart is not allowed for "`list`" topologies.

Restarting the assembly of primitives discards the most recent index values
if those elements formed an incomplete primitive, and restarts the primitive
assembly using the subsequent indices, but only assembling the immediately
following element through the end of the originally specified elements.
The primitive restart index value comparison is performed before adding the
pname:vertexOffset value to the index value.

.Valid Usage
****
  * If pname:topology is ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, pname:primitiveRestartEnable
    must: be ename:VK_FALSE
  * If the <<features-features-geometryShader,geometry shaders>> feature is
    not enabled, pname:topology must: not be any of
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY
  * If the <<features-features-tessellationShader,tessellation shaders>>
    feature is not enabled, pname:topology must: not be
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST
****

include::../validity/structs/VkPipelineInputAssemblyStateCreateInfo.txt[]


[[drawing-primitive-topologies]]
== Primitive Topologies

// refBegin VkPrimitiveTopology Supported primitive topologies

_Primitive topology_ determines how consecutive vertices are organized into
primitives, and determines the type of primitive that is used at the
beginning of the graphics pipeline.
The effective topology for later stages of the pipeline is altered by
tessellation or geometry shading (if either is in use) and depends on the
execution modes of those shaders.
Supported topologies are defined by elink:VkPrimitiveTopology and include:

include::../api/enums/VkPrimitiveTopology.txt[]

// refEnd VkPrimitiveTopology

Each primitive topology, and its construction from a list of vertices, is
summarized below.

[NOTE]
.Note
====
The terminology {ldquo}the vertex [eq]#i# {rdquo} means {ldquo}the vertex
with index [eq]#i# in the ordered list of vertices defining this
primitive{rdquo}.
====


=== Points

A series of individual points are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST.
Each vertex defines a separate point.


=== Separate Lines

Individual line segments, each defined by a pair of vertices, are specified
with pname:topology ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST.
The first two vertices define the first segment, with subsequent pairs of
vertices each defining one more segment.
If the number of vertices is odd, then the last vertex is ignored.


=== Line Strips

A series of one or more connected line segments are specified with
pname:topology ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP.
In this case, the first vertex specifies the first segment's start point
while the second vertex specifies the first segment's endpoint and the
second segment's start point.
In general, vertex [eq]#i# (for [eq]#i > 0#) specifies the beginning of the
[eq]##i##th segment and the end of the previous segment.
The last vertex specifies the end of the last segment.
If only one vertex is specified, then no primitive is generated.


=== Triangle Strips

A triangle strip is a series of triangles connected along shared edges, and
is specified with pname:topology ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP.
In this case, the first three vertices define the first triangle, and their
order is significant.
Each subsequent vertex defines a new triangle using that point along with
the last two vertices from the previous triangle, as shown in figure
<<fig-triangles>>.
If fewer than three vertices are specified, no primitive is produced.
The order of vertices in successive triangles changes as shown in the
figure, so that all triangle faces have the same orientation.

[[fig-triangles]]
image::images/triangles.svg[align="center",title="Triangle strips, fans, and lists",{fullimagewidth}]

.Caption
****
In the <<fig-triangles,Triangle strips>>, fans, and lists diagram, the
sub-sections represent:

  * (a) A triangle strip.
  * (b) A triangle fan.
  * (c) Independent triangles.

The numbers give the sequencing of the vertices in order within the vertex
arrays.
Note that in (a) and (b) triangle edge ordering is determined by the first
triangle, while in (c) the order of each triangle's edges is independent of
the other triangles.
****


=== Triangle Fans

A triangle fan is specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN.
It is similar to a triangle strip, but changes the vertex replaced from the
previous triangle as shown in figure <<fig-triangles>>, so that all
triangles in the fan share a common vertex.


=== Separate Triangles

Separate triangles are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, as shown in figure
<<fig-triangles>>.
In this case, vertices [eq]#3 i#, [eq]#3 i + 1#, and [eq]#3 i + 2# (in that
order) determine a triangle for each [eq]#i = 0, 1, ..., n-1#, where there
are [eq]#3 n + k# vertices drawn.
[eq]#k# is either 0, 1, or 2; if [eq]#k# is not zero, the final [eq]#k#
vertices are ignored.


=== Lines With Adjacency

Lines with adjacency are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, and are independent
line segments where each endpoint has a corresponding _adjacent_ vertex that
is accessible in a <<geometry,geometry shader>>.
If a geometry shader is not active, the adjacent vertices are ignored.

A line segment is drawn from vertex [eq]#4 i + 1# to vertex [eq]#4 i + 2#
for each [eq]#i = 0, 1, ..., n-1#, where there are [eq]#4 n + k# vertices.
[eq]#k# is either 0, 1, 2, or 3; if [eq]#k# is not zero, the final [eq]#k#
vertices are ignored.
For line segment [eq]#i#, vertices [eq]#4 i# and [eq]#4 i + 3# vertices are
considered adjacent to vertices [eq]#4 i + 1# and [eq]#4 i + 2#,
respectively, as shown in figure <<fig-lineadj>>.

[[fig-lineadj]]
image::images/lineadj.svg[align="center",title="Lines with adjacency",{fullimagewidth}]

.Caption
****
In the <<fig-lineadj,Lines with adjacency>> diagram, the sub-sections
represent:

  * (a) Lines with adjacency.
  * (b) Line strips with adjacency.

The vertices connected with solid lines belong to the main primitives.
The vertices connected by dashed lines are the adjacent vertices that are
accessible in a geometry shader.
****


=== Line Strips With Adjacency

Line strips with adjacency are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY and are similar to
line strips, except that each line segment has a pair of adjacent vertices
that are accessible in a geometry shader.
If a geometry shader is not active, the adjacent vertices are ignored.

A line segment is drawn from vertex [eq]#i + 1# vertex to vertex [eq]#i + 2#
for each [eq]#i = 0, 1, ..., n-1#, where there are [eq]#n + 3# vertices.
If there are fewer than four vertices, all vertices are ignored.
For line segment [eq]#i#, vertices [eq]#i# and [eq]#i + 3# are considered
adjacent to vertices [eq]#i + 1# and [eq]#i + 2#, respectively, as shown in
figure <<fig-lineadj>>.


=== Triangle List With Adjacency

Triangles with adjacency are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY, and are similar to
separate triangles except that each triangle edge has an adjacent vertex
that is accessible in a geometry shader.
If a geometry shader is not active, the adjacent vertices are ignored.

Vertices [eq]#6 i#, [eq]#6 i + 2#, and [eq]#6 i + 4# (in that order)
determine a triangle for each [eq]#i = 0, 1, ..., n-1#, where there are
[eq]#6 n+k# vertices.
[eq]#k# is either 0, 1, 2, 3, 4, or 5; if [eq]#k# is non-zero, the final
[eq]#k# vertices are ignored.
For triangle [eq]#i#, vertices [eq]#6 i + 1#, [eq]#6 i + 3#, and [eq]#6 i
{plus} 5# vertices are considered adjacent to edges from vertex [eq]#6 i# to
[eq]#6 i + 2#, from [eq]#6 i + 2# to [eq]#6 i + 4#, and from [eq]#6 i + 4#
to [eq]#6 i# vertices, respectively, as shown in figure <<fig-triadj>>.

[[fig-triadj]]
image::images/triadj.svg[align="center",title="Triangles with adjacency",{fullimagewidth}]

.Caption
****
In the <<fig-triadj,Triangles with adjacency>> diagram, the vertices
connected with solid lines belong to the main primitive.
The vertices connected by dashed lines are the adjacent vertices that are
accessible in a geometry shader.
****


=== Triangle Strips With Adjacency

Triangle strips with adjacency are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY, and are similar
to triangle strips except that each triangle edge has an adjacent vertex
that is accessible in a geometry shader.
If a geometry shader is not active, the adjacent vertices are ignored.

[[fig-tstripadj]]
image::images/tstripadj.svg[align="center",title="Triangle strips with adjacency",{fullimagewidth}]

.Caption
****
In the <<fig-tstripadj,Triangle strips with adjacency>> diagram, the
vertices connected with solid lines belong to the main primitive; the
vertices connected by dashed lines are the adjacent vertices that are
accessible in a geometry shader.
****

In triangle strips with adjacency, [eq]#n# triangles are drawn where there
are [eq]#2 (n + 2) + k# vertices.
[eq]#k# is either 0 or 1; if [eq]#k# is 1, the final vertex is ignored.
If there are fewer than 6 vertices, the entire primitive is ignored.
Table <<trigenadj>> describes the vertices and order used to draw each
triangle, and which vertices are considered adjacent to each edge of the
triangle, as shown in figure <<fig-tstripadj>>.


[[trigenadj]]
.Triangles generated by triangle strips with adjacency.
[options="header", cols="2,1,1,1,1,1,1"]
|====
|                                3+| Primitive Vertices                             3+| Adjacent Vertices
| Primitive                        | 1st           | 2nd           | 3rd           | 1/2         | 2/3           | 3/1
| only ([eq]#i = 0, n = 1#)        | 0             | 2             | 4             | 1           | 5             | 3
| first ([eq]#i = 0#)              | 0             | 2             | 4             | 1           | 6             | 3
| middle ([eq]#i# odd)             | [eq]#2 i + 2# | [eq]#2 i#     | [eq]#2 i + 4# | [eq]#2 i-2# | [eq]#2 i + 3# | [eq]#2 i + 6#
| middle ([eq]#i# even)            | [eq]#2 i#     | [eq]#2 i + 2# | [eq]#2 i + 4# | [eq]#2 i-2# | [eq]#2 i + 6# | [eq]#2 i + 3#
| last ([eq]#i=n-1#, [eq]#i# odd)  | [eq]#2 i + 2# | [eq]#2 i#     | [eq]#2 i + 4# | [eq]#2 i-2# | [eq]#2 i + 3# | [eq]#2 i + 5#
| last ([eq]#i=n-1#, [eq]#i# even) | [eq]#2 i#     | [eq]#2 i + 2# | [eq]#2 i + 4# | [eq]#2 i-2# | [eq]#2 i + 5# | [eq]#2 i + 3#
|====

.Caption
****
In the <<trigenadj,Triangles generated by triangle strips with adjacency>>
table, each triangle is drawn using the vertices whose numbers are in the
*1st*, *2nd*, and *3rd* columns under *Primitive Vertices*, in that order.
The vertices in the 1/2, 2/3, and 3/1 columns under *Adjacent Vertices* are
considered adjacent to the edges from the first to the second, from the
second to the third, and from the third to the first vertex of the triangle,
respectively.
The six rows correspond to six cases: the first and only triangle [eq]#(i =
0, n = 1)#, the first triangle of several [eq]#(i = 0, n > 0)#, _odd_ middle
triangles [eq]#(i = 1, 3, 5 ...)#, _even_ middle triangles [eq]#(i = 2, 4,
6, ...)#, and special cases for the last triangle, when [eq]#i# is either
even or odd.
For the purposes of this table, both the first vertex and first triangle are
numbered [eq]#0#.
****


[[drawing-primitive-topologies-patches]]
=== Separate Patches

Separate patches are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST.
A patch is an ordered collection of vertices used for
<<tessellation,primitive tessellation>>.
The vertices comprising a patch have no implied geometric ordering, and are
used by tessellation shaders and the fixed-function tessellator to generate
new point, line, or triangle primitives.

Each patch in the series has a fixed number of vertices, specified by the
pname:patchControlPoints member of the
slink:VkPipelineTessellationStateCreateInfo structure passed to
flink:vkCreateGraphicsPipelines.
Once assembled and vertex shaded, these patches are provided as input to the
tessellation control shader stage.

If the number of vertices in a patch is given by [eq]#v#, vertices [eq]#v
{times} i# through [eq]#v {times} i + v - 1# (in that order) determine a
patch for each [eq]#i = 0, 1, ..., n-1#, where there are [eq]#v {times} n
{plus} k# vertices.
[eq]#k# is in the range [eq]#[0, v - 1]#; if [eq]#k# is not zero, the final
[eq]#k# vertices are ignored.


=== General Considerations For Polygon Primitives

Depending on the <<primsrast-polygonmode,polygon mode>>, a _polygon
primitive_ generated from a drawing command with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY, or
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY is rendered in one
of several ways, such as outlining its border or filling its interior.
The order of vertices in such a primitive is significant during
<<primsrast-polygons-basic,polygon rasterization>> and
<<shaders-fragment,fragment shading>>.


[[drawing-primitive-order]]
== Primitive Order

Primitives generated by <<drawing, drawing commands>> progress through the
stages of the <<synchronization-pipeline-stages-types, graphics pipeline>>
in _primitive order_.
Primitive order is initially determined in the following way:

  . Submission order determines the initial ordering
  . For indirect draw commands, the order in which accessed instances of the
    slink:VkDrawIndirectCommand are stored in pname:buffer, from lower
    indirect buffer addresses to higher addresses.
  . If a draw command includes multiple instances, the order in which
    instances are executed, from lower numbered instances to higher.
  . The order in which primitives are specified by a draw command:
  ** For non-indexed draws, from vertices with a lower numbered
     code:vertexIndex to a higher numbered code:vertexIndex.
  ** For indexed draws, vertices sourced from a lower index buffer addresses
     to higher addresses.

Within this order implementations further sort primitives:

[start=5]
  . If tessellation shading is active, by an implementation-dependent order
    of new primitives generated by <<tessellation-primitive-order,
    tessellation>>.
  . If geometry shading is active, by the order new primitives are generated
    by <<geometry-ordering, geometry shading>>.
  . If the <<primsrast-polygonmode,polygon mode>> is not
    ename:VK_POLYGON_MODE_FILL, by an implementation-dependent ordering of
    the new primitives generated within the original primitive.

Primitive order is later used to define <<primrast-order, rasterization
order>>, which determines the order in which fragments output results to a
framebuffer.


== Programmable Primitive Shading

Once primitives are assembled, they proceed to the vertex shading stage of
the pipeline.
If the draw includes multiple instances, then the set of primitives is sent
to the vertex shading stage multiple times, once for each instance.

It is undefined whether vertex shading occurs on vertices that are discarded
as part of incomplete primitives, but if it does occur then it operates as
if they were vertices in complete primitives and such invocations can: have
side effects.

Vertex shading receives two per-vertex inputs from the primitive assembly
stage - the code:vertexIndex and the code:instanceIndex.
How these values are generated is defined below, with each command.

Drawing commands fall roughly into two categories:

  * Non-indexed drawing commands present a sequential code:vertexIndex to
    the vertex shader.
    The sequential index is generated automatically by the device (see
    <<fxvertex,Fixed-Function Vertex Processing>> for details on both
    specifying the vertex attributes indexed by code:vertexIndex, as well as
    binding vertex buffers containing those attributes to a command buffer).
    These commands are:
  ** flink:vkCmdDraw
  ** flink:vkCmdDrawIndirect
ifdef::VK_AMD_draw_indirect_count[]
  ** flink:vkCmdDrawIndirectCountAMD.
endif::VK_AMD_draw_indirect_count[]
  * Indexed drawing commands read index values from an _index buffer_ and
    use this to compute the code:vertexIndex value for the vertex shader.
    These commands are:
  ** flink:vkCmdDrawIndexed
  ** flink:vkCmdDrawIndexedIndirect
ifdef::VK_AMD_draw_indirect_count[]
  ** flink:vkCmdDrawIndexedIndirectCountAMD.
endif::VK_AMD_draw_indirect_count[]


// refBegin vkCmdBindIndexBuffer Bind an index buffer to a command buffer

To bind an index buffer to a command buffer, call:

include::../api/protos/vkCmdBindIndexBuffer.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer being bound.
  * pname:offset is the starting offset in bytes within pname:buffer used in
    index buffer address calculations.
  * pname:indexType selects whether indices are treated as 16 bits or 32
    bits.
    Possible values include:
+
--
// refBegin VkIndexType Type of index buffer indices
include::../api/enums/VkIndexType.txt[]
--

.Valid Usage
****
  * pname:offset must: be less than the size of pname:buffer
  * The sum of pname:offset and the address of the range of
    sname:VkDeviceMemory object that is backing pname:buffer, must: be a
    multiple of the type indicated by pname:indexType
  * pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT flag
  * If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
****

include::../validity/protos/vkCmdBindIndexBuffer.txt[]

The parameters for each drawing command are specified directly in the
command or read from buffer memory, depending on the command.
Drawing commands that source their parameters from buffer memory are known
as _indirect_ drawing commands.

All drawing commands interact with the
<<features-features-robustBufferAccess, Robust Buffer Access>> feature.


// refBegin vkCmdDraw Draw primitives

To record a non-indexed draw, call:

include::../api/protos/vkCmdDraw.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:vertexCount is the number of vertices to draw.
  * pname:instanceCount is the number of instances to draw.
  * pname:firstVertex is the index of the first vertex to draw.
  * pname:firstInstance is the instance ID of the first instance to draw.

When the command is executed, primitives are assembled using the current
primitive topology and pname:vertexCount consecutive vertex indices with the
first code:vertexIndex value equal to pname:firstVertex.
The primitives are drawn pname:instanceCount times with code:instanceIndex
starting with pname:firstInstance and increasing sequentially for each
instance.
The assembled primitives execute the currently bound graphics pipeline.

.Valid Usage
****
  * The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * For each set _n_ that is statically used by the sname:VkPipeline
    currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor
    set must: have been bound to _n_ at
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout
    that is compatible for set _n_, with the sname:VkPipelineLayout used to
    create the current sname:VkPipeline, as described in
    <<descriptorsets-compatibility>>
  * For each push constant that is statically used by the sname:VkPipeline
    currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push
    constant value must: have been set for
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout
    that is compatible for push constants, with the sname:VkPipelineLayout
    used to create the current sname:VkPipeline, as described in
    <<descriptorsets-compatibility>>
  * Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the currently bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * For a given vertex buffer binding, any attribute data fetched must: be
    entirely contained within the corresponding vertex buffer binding, as
    described in <<fxvertex-input>>
  * A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * If the sname:VkPipeline object currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used to sample from any sname:VkImage with a
    sname:VkImageView of the type ename:VK_IMAGE_VIEW_TYPE_3D,
    ename:VK_IMAGE_VIEW_TYPE_CUBE, ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY,
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used with any of the SPIR-V `OpImageSample*` or
    `OpImageSparseSample*` instructions with code:ImplicitLod, code:Dref or
    code:Proj in their name, in any shader stage
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used with any of the SPIR-V `OpImageSample*` or
    `OpImageSparseSample*` instructions that includes a LOD bias or any
    offset values, in any shader stage
  * If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses
    a uniform buffer, it must: not access values outside of the range of
    that buffer specified in the currently bound descriptor set
  * If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses
    a storage buffer, it must: not access values outside of the range of
    that buffer specified in the currently bound descriptor set
  * Any sname:VkImageView being sampled with ename:VK_FILTER_LINEAR as a
    result of this command must: be of a format which supports linear
    filtering, as specified by the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in
    sname:VkFormatProperties::pname:linearTilingFeatures (for a linear
    image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an
    optimally tiled image) returned by
    fname:vkGetPhysicalDeviceFormatProperties
ifdef::VK_IMG_filter_cubic[]
  * Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: be of a format which supports cubic
    filtering, as specified by the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in
    sname:VkFormatProperties::pname:linearTilingFeatures (for a linear
    image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an
    optimally tiled image) returned by
    fname:vkGetPhysicalDeviceFormatProperties
  * Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_IMG_filter_cubic[]
****

include::../validity/protos/vkCmdDraw.txt[]

// refBegin vkCmdDrawIndexed Issue an indexed draw into a command buffer

To record an indexed draw, call:

include::../api/protos/vkCmdDrawIndexed.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:indexCount is the number of vertices to draw.
  * pname:instanceCount is the number of instances to draw.
  * pname:firstIndex is the base index within the index buffer.
  * pname:vertexOffset is the value added to the vertex index before
    indexing into the vertex buffer.
  * pname:firstInstance is the instance ID of the first instance to draw.

When the command is executed, primitives are assembled using the current
primitive topology and pname:indexCount vertices whose indices are retrieved
from the index buffer.
The index buffer is treated as an array of tightly packed unsigned integers
of size defined by the flink:vkCmdBindIndexBuffer::pname:indexType parameter
with which the buffer was bound.

The first vertex index is at an offset of pname:firstIndex * code:indexSize
+ pname:offset within the currently bound index buffer, where pname:offset
is the offset specified by fname:vkCmdBindIndexBuffer and code:indexSize is
the byte size of the type specified by pname:indexType.
Subsequent index values are retrieved from consecutive locations in the
index buffer.
Indices are first compared to the primitive restart value, then zero
extended to 32 bits (if the code:indexType is ename:VK_INDEX_TYPE_UINT16)
and have pname:vertexOffset added to them, before being supplied as the
code:vertexIndex value.

The primitives are drawn pname:instanceCount times with code:instanceIndex
starting with pname:firstInstance and increasing sequentially for each
instance.
The assembled primitives execute the currently bound graphics pipeline.

.Valid Usage
****
  * The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * For each set _n_ that is statically used by the sname:VkPipeline
    currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor
    set must: have been bound to _n_ at
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout
    that is compatible for set _n_, with the sname:VkPipelineLayout used to
    create the current sname:VkPipeline, as described in
    <<descriptorsets-compatibility>>
  * For each push constant that is statically used by the sname:VkPipeline
    currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push
    constant value must: have been set for
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout
    that is compatible for push constants, with the sname:VkPipelineLayout
    used to create the current sname:VkPipeline, as described in
    <<descriptorsets-compatibility>>
  * Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the currently bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * For a given vertex buffer binding, any attribute data fetched must: be
    entirely contained within the corresponding vertex buffer binding, as
    described in <<fxvertex-input>>
  * A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * If the sname:VkPipeline object currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * (pname:indexSize * (pname:firstIndex + pname:indexCount) + pname:offset)
    must: be less than or equal to the size of the currently bound index
    buffer, with indexSize being based on the type specified by
    pname:indexType, where the index buffer, pname:indexType, and
    pname:offset are specified via fname:vkCmdBindIndexBuffer
  * Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used to sample from any sname:VkImage with a
    sname:VkImageView of the type ename:VK_IMAGE_VIEW_TYPE_3D,
    ename:VK_IMAGE_VIEW_TYPE_CUBE, ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY,
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used with any of the SPIR-V `OpImageSample*` or
    `OpImageSparseSample*` instructions with code:ImplicitLod, code:Dref or
    code:Proj in their name, in any shader stage
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used with any of the SPIR-V `OpImageSample*` or
    `OpImageSparseSample*` instructions that includes a LOD bias or any
    offset values, in any shader stage
  * If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses
    a uniform buffer, it must: not access values outside of the range of
    that buffer specified in the currently bound descriptor set
  * If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses
    a storage buffer, it must: not access values outside of the range of
    that buffer specified in the currently bound descriptor set
  * Any sname:VkImageView being sampled with ename:VK_FILTER_LINEAR as a
    result of this command must: be of a format which supports linear
    filtering, as specified by the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in
    sname:VkFormatProperties::pname:linearTilingFeatures (for a linear
    image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an
    optimally tiled image) returned by
    fname:vkGetPhysicalDeviceFormatProperties
ifdef::VK_IMG_filter_cubic[]
  * Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: be of a format which supports cubic
    filtering, as specified by the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in
    sname:VkFormatProperties::pname:linearTilingFeatures (for a linear
    image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an
    optimally tiled image) returned by
    fname:vkGetPhysicalDeviceFormatProperties
  * Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_IMG_filter_cubic[]
****

include::../validity/protos/vkCmdDrawIndexed.txt[]

// refBegin vkCmdDrawIndirect Issue an indirect draw into a command buffer

To record a non-indexed indirect draw, call:

include::../api/protos/vkCmdDrawIndirect.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:drawCount is the number of draws to execute, and can: be zero.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndirect behaves similarly to flink:vkCmdDraw except that the
parameters are read by the device from a buffer during execution.
pname:drawCount draws are executed by the command, with parameters taken
from pname:buffer starting at pname:offset and increasing by pname:stride
bytes for each successive draw.
The parameters of each draw are encoded in an array of
slink:VkDrawIndirectCommand structures.
If pname:drawCount is less than or equal to one, pname:stride is ignored.

.Valid Usage
****
  * If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * pname:offset must: be a multiple of `4`
  * If pname:drawCount is greater than `1`, pname:stride must: be a multiple
    of `4` and must: be greater than or equal to
    sizeof(sname:VkDrawIndirectCommand)
  * If the <<features-features-multiDrawIndirect,multi-draw indirect>>
    feature is not enabled, pname:drawCount must: be `0` or `1`
  * If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndirectCommand structures accessed by this command must: be
    code:0
  * The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * For each set _n_ that is statically used by the sname:VkPipeline
    currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor
    set must: have been bound to _n_ at
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout
    that is compatible for set _n_, with the sname:VkPipelineLayout used to
    create the current sname:VkPipeline, as described in
    <<descriptorsets-compatibility>>
  * For each push constant that is statically used by the sname:VkPipeline
    currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push
    constant value must: have been set for
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout
    that is compatible for push constants, with the sname:VkPipelineLayout
    used to create the current sname:VkPipeline, as described in
    <<descriptorsets-compatibility>>
  * Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the currently bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * If the sname:VkPipeline object currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * If pname:drawCount is equal to `1`, [eq]#(pname:offset {plus}
    sizeof(slink:VkDrawIndirectCommand))# must: be less than or equal to the
    size of pname:buffer
  * If pname:drawCount is greater than `1`, [eq]#(pname:stride {times}
    (pname:drawCount - 1) + pname:offset {plus}
    sizeof(slink:VkDrawIndirectCommand))# must: be less than or equal to the
    size of pname:buffer
  * pname:drawCount must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used to sample from any sname:VkImage with a
    sname:VkImageView of the type ename:VK_IMAGE_VIEW_TYPE_3D,
    ename:VK_IMAGE_VIEW_TYPE_CUBE, ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY,
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used with any of the SPIR-V `OpImageSample*` or
    `OpImageSparseSample*` instructions with code:ImplicitLod, code:Dref or
    code:Proj in their name, in any shader stage
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used with any of the SPIR-V `OpImageSample*` or
    `OpImageSparseSample*` instructions that includes a LOD bias or any
    offset values, in any shader stage
  * If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses
    a uniform buffer, it must: not access values outside of the range of
    that buffer specified in the currently bound descriptor set
  * If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses
    a storage buffer, it must: not access values outside of the range of
    that buffer specified in the currently bound descriptor set
  * Any sname:VkImageView being sampled with ename:VK_FILTER_LINEAR as a
    result of this command must: be of a format which supports linear
    filtering, as specified by the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in
    sname:VkFormatProperties::pname:linearTilingFeatures (for a linear
    image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an
    optimally tiled image) returned by
    fname:vkGetPhysicalDeviceFormatProperties
ifdef::VK_IMG_filter_cubic[]
  * Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: be of a format which supports cubic
    filtering, as specified by the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in
    sname:VkFormatProperties::pname:linearTilingFeatures (for a linear
    image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an
    optimally tiled image) returned by
    fname:vkGetPhysicalDeviceFormatProperties
  * Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_IMG_filter_cubic[]
****

include::../validity/protos/vkCmdDrawIndirect.txt[]

// refBegin VkDrawIndirectCommand Structure specifying a draw indirect command

The sname:VkDrawIndirectCommand structure is defined as:

include::../api/structs/VkDrawIndirectCommand.txt[]

  * pname:vertexCount is the number of vertices to draw.
  * pname:instanceCount is the number of instances to draw.
  * pname:firstVertex is the index of the first vertex to draw.
  * pname:firstInstance is the instance ID of the first instance to draw.

The members of sname:VkDrawIndirectCommand have the same meaning as the
similarly named parameters of flink:vkCmdDraw.

.Valid Usage
****
  * For a given vertex buffer binding, any attribute data fetched must: be
    entirely contained within the corresponding vertex buffer binding, as
    described in <<fxvertex-input>>
  * If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, pname:firstInstance must: be code:0
****

include::../validity/structs/VkDrawIndirectCommand.txt[]

// refEnd VkDrawIndirectCommand vkCmdDrawIndirect

ifdef::VK_AMD_draw_indirect_count[]
// refBegin vkCmdDrawIndirectCountAMD Perform an indirect draw with the draw count sourced from a buffer

To record a non-indexed draw call with a draw call count sourced from a
buffer, call:

include::../api/protos/vkCmdDrawIndirectCountAMD.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:countBuffer is the buffer containing the draw count.
  * pname:countBufferOffset is the byte offset into pname:countBuffer where
    the draw count begins.
  * pname:maxDrawCount specifies the maximum number of draws that will be
    executed.
    The actual number of executed draw calls is the minimum of the count
    specified in pname:countBuffer and pname:maxDrawCount.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndirectCountAMD behaves similar to flink:vkCmdDrawIndirect
except that the draw count is read by the device from a buffer during
execution.
The command will read an unsigned 32-bit integer from pname:countBuffer
located at pname:countBufferOffset and use this as the draw count.

.Valid Usage
****
  * pname:offset must: be a multiple of `4`
  * pname:countBufferOffset must: be a multiple of `4`
  * pname:stride must: be a multiple of `4` and must: be greater than or
    equal to sizeof(sname:VkDrawIndirectCommand)
  * If pname:maxDrawCount is greater than or equal to `1`,
    [eq]#(pname:stride {times} (pname:maxDrawCount - 1) + pname:offset
    {plus} sizeof(sname:VkDrawIndirectCommand))# must: be less than or equal
    to the size of pname:buffer
  * If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndirectCommand structures accessed by this command must: be
    code:0
  * The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * For each set _n_ that is statically used by the sname:VkPipeline
    currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor
    set must: have been bound to _n_ at
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout
    that is compatible for set _n_, with the sname:VkPipelineLayout used to
    create the current sname:VkPipeline, as described in
    <<descriptorsets-compatibility>>
  * For each push constant that is statically used by the sname:VkPipeline
    currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push
    constant value must: have been set for
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout
    that is compatible for push constants, with the sname:VkPipelineLayout
    used to create the current sname:VkPipeline, as described in
    <<descriptorsets-compatibility>>
  * Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the currently bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * If the sname:VkPipeline object currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * If the count stored in pname:countBuffer is equal to `1`,
    [eq]#(pname:offset + sizeof(sname:VkDrawIndirectCommand))# must: be less
    than or equal to the size of pname:buffer
  * If the count stored in pname:countBuffer is greater than `1`,
    [eq]#(pname:stride {times} (pname:drawCount - 1) + pname:offset {plus}
    sizeof(sname:VkDrawIndirectCommand))# must: be less than or equal to the
    size of pname:buffer
  * The count stored in pname:countBuffer must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used to sample from any sname:VkImage with a
    sname:VkImageView of the type ename:VK_IMAGE_VIEW_TYPE_3D,
    ename:VK_IMAGE_VIEW_TYPE_CUBE, ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY,
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used with any of the SPIR-V `OpImageSample*` or
    `OpImageSparseSample*` instructions with code:ImplicitLod, code:Dref or
    code:Proj in their name, in any shader stage
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used with any of the SPIR-V `OpImageSample*` or
    `OpImageSparseSample*` instructions that includes a LOD bias or any
    offset values, in any shader stage
  * If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses
    a uniform buffer, it must: not access values outside of the range of
    that buffer specified in the currently bound descriptor set
  * If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses
    a storage buffer, it must: not access values outside of the range of
    that buffer specified in the currently bound descriptor set
  * Any sname:VkImageView being sampled with ename:VK_FILTER_LINEAR as a
    result of this command must: be of a format which supports linear
    filtering, as specified by the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in
    sname:VkFormatProperties::pname:linearTilingFeatures (for a linear
    image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an
    optimally tiled image) returned by
    fname:vkGetPhysicalDeviceFormatProperties
****

include::../validity/protos/vkCmdDrawIndirectCountAMD.txt[]

// refEnd vkCmdDrawIndirectCountAMD
endif::VK_AMD_draw_indirect_count[]

// refBegin vkCmdDrawIndexedIndirect Perform an indexed indirect draw

To record an indexed indirect draw, call:

include::../api/protos/vkCmdDrawIndexedIndirect.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:drawCount is the number of draws to execute, and can: be zero.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndexedIndirect behaves similarly to flink:vkCmdDrawIndexed
except that the parameters are read by the device from a buffer during
execution.
pname:drawCount draws are executed by the command, with parameters taken
from pname:buffer starting at pname:offset and increasing by pname:stride
bytes for each successive draw.
The parameters of each draw are encoded in an array of
slink:VkDrawIndexedIndirectCommand structures.
If pname:drawCount is less than or equal to one, pname:stride is ignored.

.Valid Usage
****
  * If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * pname:offset must: be a multiple of `4`
  * If pname:drawCount is greater than `1`, pname:stride must: be a multiple
    of `4` and must: be greater than or equal to
    sizeof(sname:VkDrawIndexedIndirectCommand)
  * If the <<features-features-multiDrawIndirect,multi-draw indirect>>
    feature is not enabled, pname:drawCount must: be `0` or `1`
  * If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndexedIndirectCommand structures accessed by this command
    must: be code:0
  * The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * For each set _n_ that is statically used by the sname:VkPipeline
    currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor
    set must: have been bound to _n_ at
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout
    that is compatible for set _n_, with the sname:VkPipelineLayout used to
    create the current sname:VkPipeline, as described in
    <<descriptorsets-compatibility>>
  * For each push constant that is statically used by the sname:VkPipeline
    currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push
    constant value must: have been set for
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout
    that is compatible for push constants, with the sname:VkPipelineLayout
    used to create the current sname:VkPipeline, as described in
    <<descriptorsets-compatibility>>
  * Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the currently bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * If the sname:VkPipeline object currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * If pname:drawCount is equal to `1`, [eq]#(pname:offset {plus}
    sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than or equal
    to the size of pname:buffer
  * If pname:drawCount is greater than `1`, [eq]#(pname:stride {times}
    (pname:drawCount - 1) + pname:offset {plus}
    sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than or equal
    to the size of pname:buffer
  * pname:drawCount must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used to sample from any sname:VkImage with a
    sname:VkImageView of the type ename:VK_IMAGE_VIEW_TYPE_3D,
    ename:VK_IMAGE_VIEW_TYPE_CUBE, ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY,
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used with any of the SPIR-V `OpImageSample*` or
    `OpImageSparseSample*` instructions with code:ImplicitLod, code:Dref or
    code:Proj in their name, in any shader stage
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used with any of the SPIR-V `OpImageSample*` or
    `OpImageSparseSample*` instructions that includes a LOD bias or any
    offset values, in any shader stage
  * If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses
    a uniform buffer, it must: not access values outside of the range of
    that buffer specified in the currently bound descriptor set
  * If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses
    a storage buffer, it must: not access values outside of the range of
    that buffer specified in the currently bound descriptor set
  * Any sname:VkImageView being sampled with ename:VK_FILTER_LINEAR as a
    result of this command must: be of a format which supports linear
    filtering, as specified by the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in
    sname:VkFormatProperties::pname:linearTilingFeatures (for a linear
    image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an
    optimally tiled image) returned by
    fname:vkGetPhysicalDeviceFormatProperties
ifdef::VK_IMG_filter_cubic[]
  * Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: be of a format which supports cubic
    filtering, as specified by the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in
    sname:VkFormatProperties::pname:linearTilingFeatures (for a linear
    image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an
    optimally tiled image) returned by
    fname:vkGetPhysicalDeviceFormatProperties
  * Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_IMG_filter_cubic[]
****

include::../validity/protos/vkCmdDrawIndexedIndirect.txt[]

// refBegin VkDrawIndexedIndirectCommand Structure specifying a draw indexed indirect command

The sname:VkDrawIndexedIndirectCommand structure is defined as:

include::../api/structs/VkDrawIndexedIndirectCommand.txt[]

  * pname:indexCount is the number of vertices to draw.
  * pname:instanceCount is the number of instances to draw.
  * pname:firstIndex is the base index within the index buffer.
  * pname:vertexOffset is the value added to the vertex index before
    indexing into the vertex buffer.
  * pname:firstInstance is the instance ID of the first instance to draw.

The members of sname:VkDrawIndexedIndirectCommand have the same meaning as
the similarly named parameters of flink:vkCmdDrawIndexed.

.Valid Usage
****
  * For a given vertex buffer binding, any attribute data fetched must: be
    entirely contained within the corresponding vertex buffer binding, as
    described in <<fxvertex-input>>
  * (pname:indexSize * (pname:firstIndex + pname:indexCount) + pname:offset)
    must: be less than or equal to the size of the currently bound index
    buffer, with pname:indexSize being based on the type specified by
    pname:indexType, where the index buffer, pname:indexType, and
    pname:offset are specified via fname:vkCmdBindIndexBuffer
  * If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, pname:firstInstance must: be code:0
****

include::../validity/structs/VkDrawIndexedIndirectCommand.txt[]

// refEnd VkDrawIndexedIndirectCommand vkCmdDrawIndexedIndirect

ifdef::VK_AMD_draw_indirect_count[]
// refBegin vkCmdDrawIndexedIndirectCountAMD Perform an indexed indirect draw with the draw count sourced from a buffer

To record an indexed draw call with a draw call count sourced from a buffer,
call:

include::../api/protos/vkCmdDrawIndexedIndirectCountAMD.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:countBuffer is the buffer containing the draw count.
  * pname:countBufferOffset is the byte offset into pname:countBuffer where
    the draw count begins.
  * pname:maxDrawCount specifies the maximum number of draws that will be
    executed.
    The actual number of executed draw calls is the minimum of the count
    specified in pname:countBuffer and pname:maxDrawCount.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndexedIndirectCountAMD behaves similar to
flink:vkCmdDrawIndirectCountAMD except that the draw count is read by the
device from a buffer during execution.
The command will read an unsigned 32-bit integer from pname:countBuffer
located at pname:countBufferOffset and use this as the draw count.

.Valid Usage
****
  * pname:offset must: be a multiple of `4`
  * pname:countBufferOffset must: be a multiple of `4`
  * pname:stride must: be a multiple of `4` and must: be greater than or
    equal to sizeof(sname:VkDrawIndirectCommand)
  * If pname:maxDrawCount is greater than or equal to `1`,
    [eq]#(pname:stride {times} (pname:maxDrawCount - 1) + pname:offset
    {plus} sizeof(sname:VkDrawIndirectCommand))# must: be less than or equal
    to the size of pname:buffer
  * If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndexedIndirectCommand structures accessed by this command
    must: be code:0
  * The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * For each set _n_ that is statically used by the sname:VkPipeline
    currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor
    set must: have been bound to _n_ at
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout
    that is compatible for set _n_, with the sname:VkPipelineLayout used to
    create the current sname:VkPipeline, as described in
    <<descriptorsets-compatibility>>
  * For each push constant that is statically used by the sname:VkPipeline
    currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push
    constant value must: have been set for
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout
    that is compatible for push constants, with the sname:VkPipelineLayout
    used to create the current sname:VkPipeline, as described in
    <<descriptorsets-compatibility>>
  * Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the currently bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * If the sname:VkPipeline object currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * If count stored in pname:countBuffer is equal to `1`, [eq]#(pname:offset
    {plus} sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than
    or equal to the size of pname:buffer
  * If count stored in pname:countBuffer is greater than `1`,
    [eq]#(pname:stride {times} (pname:drawCount - 1) + pname:offset {plus}
    sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than or equal
    to the size of pname:buffer
  * pname:drawCount must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used to sample from any sname:VkImage with a
    sname:VkImageView of the type ename:VK_IMAGE_VIEW_TYPE_3D,
    ename:VK_IMAGE_VIEW_TYPE_CUBE, ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY,
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used with any of the SPIR-V `OpImageSample*` or
    `OpImageSparseSample*` instructions with code:ImplicitLod, code:Dref or
    code:Proj in their name, in any shader stage
  * If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline currently bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it
    must: not be used with any of the SPIR-V `OpImageSample*` or
    `OpImageSparseSample*` instructions that includes a LOD bias or any
    offset values, in any shader stage
  * If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses
    a uniform buffer, it must: not access values outside of the range of
    that buffer specified in the currently bound descriptor set
  * If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses
    a storage buffer, it must: not access values outside of the range of
    that buffer specified in the currently bound descriptor set
  * Any sname:VkImageView being sampled with ename:VK_FILTER_LINEAR as a
    result of this command must: be of a format which supports linear
    filtering, as specified by the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in
    sname:VkFormatProperties::pname:linearTilingFeatures (for a linear
    image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an
    optimally tiled image) returned by
    fname:vkGetPhysicalDeviceFormatProperties
****

include::../validity/protos/vkCmdDrawIndexedIndirectCountAMD.txt[]

// refEnd vkCmdDrawIndexedIndirectCountAMD
endif::VK_AMD_draw_indirect_count[]
