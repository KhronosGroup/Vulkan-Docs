// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[devsandqueues]]
= 设备和队列

一旦Vulkan完成初始化，设备和队列是用来和Vulkan实现交互的主要对象。

// refBegin VkPhysicalDevice Opaque handle to a physical device object

Vulkan把 _physical_ 和 _logical_ 设备的概念分开了。一个物理设备通常表示单独的一个系统（也许由几个单独的硬件组成一起工作），
个数是有限的。逻辑设备表示从应用程序的角度看设备。

物理设备通过 sname:VkPhysicalDevice handles表示：

include::../api/handles/VkPhysicalDevice.txt[]

// refEnd VkPhysicalDevice


[[devsandqueues-physical-device-enumeration]]
== 物理设备

// refBegin vkEnumeratePhysicalDevices Enumerates the physical devices accessible to a Vulkan instance

要从系统中获取表示已安装的物理设备的对象列表，可调用：

include::../api/protos/vkEnumeratePhysicalDevices.txt[]

  * pname:instance is a handle to a Vulkan instance previously created with
    fname:vkCreateInstance.
  * pname:pPhysicalDeviceCount is a pointer to an integer related to the
    number of physical devices available or queried, as described below.
  * pname:pPhysicalDevices is either `NULL` or a pointer to an array of
    sname:VkPhysicalDevice handles.

如果pname:pPhysicalDevices 为 `NULL`，那么可用的物理设备的个数通过pname:pPhysicalDeviceCount返回。
否则，pname:pPhysicalDeviceCount必须指向一个用户端设置的、值为pname:pPhysicalDevices数组大小的变量，
且返回时，变量被覆写为pname:pPhysicalDevices数组的大小。
如果pname:pPhysicalDeviceCount 比可用的物理设备个数小，最多pname:pPhysicalDeviceCount被覆盖。
如果pname:pPhysicalDeviceCount 比可用的物理设备个数小，ename:VK_INCOMPLETE 将被返回，表示不是所有可用设备被返回。

include::../validity/protos/vkEnumeratePhysicalDevices.txt[]

// refBegin vkGetPhysicalDeviceProperties Returns properties of a physical device

要查询一个获取的物理设备的通用属性，调用：

include::../api/protos/vkGetPhysicalDeviceProperties.txt[]

  * pname:physicalDevice is the handle to the physical device whose
    properties will be queried.
  * pname:pProperties points to an instance of the
    slink:VkPhysicalDeviceProperties structure, that will be filled with
    returned information.

include::../validity/protos/vkGetPhysicalDeviceProperties.txt[]

// refBegin VkPhysicalDeviceProperties Structure specifying physical device properties

The sname:VkPhysicalDeviceProperties structure is defined as:

include::../api/structs/VkPhysicalDeviceProperties.txt[]

  * pname:apiVersion is the version of Vulkan supported by the device,
    encoded as described in the <<fundamentals-versionnum,API Version
    Numbers and Semantics>> section.
  * pname:driverVersion is the vendor-specified version of the driver.
  * pname:vendorID is a unique identifier for the _vendor_ (see below) of
    the physical device.
  * pname:deviceID is a unique identifier for the physical device among
    devices available from the vendor.
  * pname:deviceType is a elink:VkPhysicalDeviceType specifying the type of
    device.
  * pname:deviceName is a null-terminated UTF-8 string containing the name
    of the device.
  * pname:pipelineCacheUUID is an array of size ename:VK_UUID_SIZE,
    containing 8-bit values that represent a universally unique identifier
    for the device.
  * pname:limits is the slink:VkPhysicalDeviceLimits structure which
    specifies device-specific limits of the physical device.
    See <<features-limits,Limits>> for details.
  * pname:sparseProperties is the slink:VkPhysicalDeviceSparseProperties
    structure which specifies various sparse related properties of the
    physical device.
    See <<sparsememory-physicalprops,Sparse Properties>> for details.

pname:vendorID 和 pname:deviceID 域可以让应用程序适配硬件的没有通过其他Vulkan查询暴露出来的特性，
这些也可能包括性能分析，硬件勘误，或者其他的特性。在基于PCI的Vulkan实现中，pname:vendorID 和
pname:deviceID最低6位必须包含 PCI供应商和硬件设备关联的设备ID，剩下的位必须设置为0。
在非PCI实现中，渲染返回什么值可以有操作系统或者平台策略来决定。
It is otherwise at the discretion of the implementer, subject to the
following constraints and guidelines:

  * For purposes of physical device identification, the _vendor_ of a
    physical device is the entity responsible for the most salient
    characteristics of the hardware represented by the physical device
    handle.
    In the case of a discrete GPU, this should: be the GPU chipset vendor.
    In the case of a GPU or other accelerator integrated into a
    system-on-chip (SoC), this should: be the supplier of the silicon IP
    used to create the GPU or other accelerator.
  * If the vendor of the physical device has a valid PCI vendor ID issued by
    https://pcisig.com/[PCI-SIG], that ID should: be used to construct
    pname:vendorID as described above for PCI-based implementations.
    Implementations that do not return a PCI vendor ID in pname:vendorID
    must: return a valid Khronos vendor ID, obtained as described in the
    <<vulkan-styleguide,Vulkan Documentation and Extensions>> document in
    the section "`Registering a Vendor ID with Khronos`".
    Khronos vendor IDs are allocated starting at 0x10000, to distinguish
    them from the PCI vendor ID namespace.
  * The vendor of the physical device is responsible for selecting
    pname:deviceID.
    The value selected should: uniquely identify both the device version and
    any major configuration options (for example, core count in the case of
    multicore devices).
    The same device ID should: be used for all physical implementations of
    that device version and configuration.
    For example, all uses of a specific silicon IP GPU version and
    configuration should: use the same device ID, even if those uses occur
    in different SoCs.

include::../validity/structs/VkPhysicalDeviceProperties.txt[]

// refBegin VkPhysicalDeviceType Supported physical device types

The physical devices types are:

include::../api/enums/VkPhysicalDeviceType.txt[]

  * ename:VK_PHYSICAL_DEVICE_TYPE_OTHER The device does not match any other
    available types.
  * ename:VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU The device is typically one
    embedded in or tightly coupled with the host.
  * ename:VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU The device is typically a
    separate processor connected to the host via an interlink.
  * ename:VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU The device is typically a
    virtual node in a virtualization environment.
  * ename:VK_PHYSICAL_DEVICE_TYPE_CPU The device is typically running on the
    same processors as the host.

The physical device type is advertised for informational purposes only, and
does not directly affect the operation of the system.
However, the device type may: correlate with other advertised properties or
capabilities of the system, such as how many memory heaps there are.

// refEnd VkPhysicalDeviceType

ifdef::VK_KHR_get_physical_device_properties2[]

// refBegin vkGetPhysicalDeviceProperties2KHR Returns properties of a physical device

To query general properties of physical devices once enumerated, call:

include::../api/protos/vkGetPhysicalDeviceProperties2KHR.txt[]

  * pname:physicalDevice is the handle to the physical device whose
    properties will be queried.
  * pname:pProperties points to an instance of the
    slink:VkPhysicalDeviceProperties2KHR structure, that will be filled with
    returned information.

Each structure in pname:pProperties and its pname:pNext chain contain
members corresponding to properties or implementation-dependent limits.
fname:vkGetPhysicalDeviceProperties2KHR writes each member to a value
indicating the value of that property or limit.

include::../validity/protos/vkGetPhysicalDeviceProperties2KHR.txt[]

// refBegin VkPhysicalDeviceProperties2KHR Structure specifying physical device properties

The sname:VkPhysicalDeviceProperties2KHR structure is defined as:

include::../api/structs/VkPhysicalDeviceProperties2KHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:properties is a structure of type slink:VkPhysicalDeviceProperties
    describing the properties of the physical device.
    This structure is written with the same values as if it were written by
    flink:vkGetPhysicalDeviceProperties.

The pname:pNext chain of this structure is used to extend the structure with
properties defined by extensions.

include::../validity/structs/VkPhysicalDeviceProperties2KHR.txt[]

endif::VK_KHR_get_physical_device_properties2[]

// refBegin vkGetPhysicalDeviceQueueFamilyProperties Reports properties of the queues of the specified physical device

To query properties of queues available on a physical device, call:

include::../api/protos/vkGetPhysicalDeviceQueueFamilyProperties.txt[]

  * pname:physicalDevice is the handle to the physical device whose
    properties will be queried.
  * pname:pQueueFamilyPropertyCount is a pointer to an integer related to
    the number of queue families available or queried, as described below.
  * pname:pQueueFamilyProperties is either `NULL` or a pointer to an array
    of slink:VkQueueFamilyProperties structures.

If pname:pQueueFamilyProperties is `NULL`, then the number of queue families
available is returned in pname:pQueueFamilyPropertyCount.
Otherwise, pname:pQueueFamilyPropertyCount must: point to a variable set by
the user to the number of elements in the pname:pQueueFamilyProperties
array, and on return the variable is overwritten with the number of
structures actually written to pname:pQueueFamilyProperties.
If pname:pQueueFamilyPropertyCount is less than the number of queue families
available, at most pname:pQueueFamilyPropertyCount structures will be
written.

include::../validity/protos/vkGetPhysicalDeviceQueueFamilyProperties.txt[]

// refBegin VkQueueFamilyProperties Structure providing information about a queue family

The sname:VkQueueFamilyProperties structure is defined as:

include::../api/structs/VkQueueFamilyProperties.txt[]

  * pname:queueFlags contains flags indicating the capabilities of the
    queues in this queue family.
  * pname:queueCount is the unsigned integer count of queues in this queue
    family.
  * pname:timestampValidBits is the unsigned integer count of meaningful
    bits in the timestamps written via fname:vkCmdWriteTimestamp.
    The valid range for the count is 36..64 bits, or a value of 0,
    indicating no support for timestamps.
    Bits outside the valid range are guaranteed to be zeros.
  * pname:minImageTransferGranularity is the minimum granularity supported
    for image transfer operations on the queues in this queue family.

The bits specified in pname:queueFlags are:

// refBegin VkQueueFlagBits Bitmask specifying capabilities of queues in a queue family
include::../api/enums/VkQueueFlagBits.txt[]

  * if ename:VK_QUEUE_GRAPHICS_BIT is set, then the queues in this queue
    family support graphics operations.
  * if ename:VK_QUEUE_COMPUTE_BIT is set, then the queues in this queue
    family support compute operations.
  * if ename:VK_QUEUE_TRANSFER_BIT is set, then the queues in this queue
    family support transfer operations.
  * if ename:VK_QUEUE_SPARSE_BINDING_BIT is set, then the queues in this
    queue family support sparse memory management operations (see
    <<sparsememory,Sparse Resources>>).
    If any of the sparse resource features are enabled, then at least one
    queue family must: support this bit.

If an implementation exposes any queue family that supports graphics
operations, at least one queue family of at least one physical device
exposed by the implementation must: support both graphics and compute
operations.

[NOTE]
.Note
====
All commands that are allowed on a queue that supports transfer operations
are also allowed on a queue that supports either graphics or compute
operations thus if the capabilities of a queue family include
ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT then reporting the
ename:VK_QUEUE_TRANSFER_BIT capability separately for that queue family is
optional:.
====

For further details see <<devsandqueues-queues,Queues>>.

The value returned in pname:minImageTransferGranularity has a unit of
compressed texel blocks for images having a block-compressed format, and a
unit of texels otherwise.

Possible values of pname:minImageTransferGranularity are:

  * [eq]#(0,0,0)# which indicates that only whole mip levels must: be
    transferred using the image transfer operations on the corresponding
    queues.
    In this case, the following restrictions apply to all offset and extent
    parameters of image transfer operations:

  ** The pname:x, pname:y, and pname:z members of a slink:VkOffset3D
     parameter must: always be zero.
  ** The pname:width, pname:height, and pname:depth members of a
     slink:VkExtent3D parameter must: always match the width, height, and
     depth of the image subresource corresponding to the parameter,
     respectively.

  * [eq]#(A~x~, A~y~, A~z~)# where [eq]#A~x~#, [eq]#A~y~#, and [eq]#A~z~#
    are all integer powers of two.
    In this case the following restrictions apply to all image transfer
    operations:

  ** pname:x, pname:y, and pname:z of a slink:VkOffset3D parameter must: be
     integer multiples of [eq]#A~x~#, [eq]#A~y~#, and [eq]#A~z~#,
     respectively.
  ** pname:width of a slink:VkExtent3D parameter must: be an integer
     multiple of [eq]#A~x~#, or else [eq]#pname:x + pname:width# must: equal
     the width of the image subresource corresponding to the parameter.
  ** pname:height of a slink:VkExtent3D parameter must: be an integer
     multiple of [eq]#A~y~#, or else [eq]#pname:y + pname:height# must:
     equal the height of the image subresource corresponding to the
     parameter.
  ** pname:depth of a slink:VkExtent3D parameter must: be an integer
     multiple of [eq]#A~z~#, or else [eq]#pname:z + pname:depth# must: equal
     the depth of the image subresource corresponding to the parameter.
  ** If the format of the image corresponding to the parameters is one of
     the block-compressed formats then for the purposes of the above
     calculations the granularity must: be scaled up by the compressed texel
     block dimensions.

Queues supporting graphics and/or compute operations must: report
[eq]#(1,1,1)# in pname:minImageTransferGranularity, meaning that there are
no additional restrictions on the granularity of image transfer operations
for these queues.
Other queues supporting image transfer operations are only required: to
support whole mip level transfers, thus pname:minImageTransferGranularity
for queues belonging to such queue families may: be [eq]#(0,0,0)#.

include::../validity/structs/VkQueueFamilyProperties.txt[]

The <<memory-device,Device Memory>> section describes memory properties
queried from the physical device.

For physical device feature queries see the <<features, Features>> chapter.

ifdef::VK_KHR_get_physical_device_properties2[]

// refBegin vkGetPhysicalDeviceQueueFamilyProperties2KHR Reports properties of the queues of the specified physical device

To query properties of queues available on a physical device, call:

include::../api/protos/vkGetPhysicalDeviceQueueFamilyProperties2KHR.txt[]

  * pname:physicalDevice is the handle to the physical device whose
    properties will be queried.
  * pname:pQueueFamilyPropertyCount is a pointer to an integer related to
    the number of queue families available or queried, as described in
    flink:vkGetPhysicalDeviceQueueFamilyProperties.
  * pname:pQueueFamilyProperties is either `NULL` or a pointer to an array
    of slink:VkQueueFamilyProperties2KHR structures.

fname:vkGetPhysicalDeviceQueueFamilyProperties2KHR behaves similarly to
flink:vkGetPhysicalDeviceQueueFamilyProperties, with the ability to return
extended information via chained output structures.

include::../validity/protos/vkGetPhysicalDeviceQueueFamilyProperties2KHR.txt[]

// refBegin VkQueueFamilyProperties2KHR Structure providing information about a queue family

The sname:VkQueueFamilyProperties2KHR structure is defined as:

include::../api/structs/VkQueueFamilyProperties2KHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:queueFamilyProperties is a structure of type
    slink:VkQueueFamilyProperties which is populated with the same values as
    in flink:vkGetPhysicalDeviceQueueFamilyProperties.

include::../validity/structs/VkQueueFamilyProperties2KHR.txt[]

endif::VK_KHR_get_physical_device_properties2[]


[[devsandqueues-devices]]
== 设备

设备对象表示和物理设备之间的一个连接。每一个设备对外暴露一些 _队列族_，每一个都有一个或多个_队列_。
在一个队列族中的所有队列都支持相同的操作。

如在<<devsandqueues-physical-device-enumeration,Physical Devices>>中所描述的，一个Vulkan应用程序将首先查询
一个系统中所有的物理设备。
每一个物理设备可以被查询它的能力，包含队列和队列族的属性。一旦一个可接受的物理设备被确认了，应用程序将创建对应的
逻辑设备。应用程序必须对每一个使用的物理设备创建单独的逻辑设备。被创建的逻辑设备然后就是和物理设备之间的接口了。

如何遍历一个系统中的物理设备并查询这些物理设备的队列族属性在之前的
<<devsandqueues-physical-device-enumeration, Physical Device Enumeration>>小节讲解过。


[[devsandqueues-device-creation]]
=== 设备创建

// refBegin VkDevice Opaque handle to a device object

逻辑设备通过sname:VkDevice handles表示：

include::../api/handles/VkDevice.txt[]

// refEnd VkDevice

// refBegin vkCreateDevice Create a new device instance

一个逻辑设备被当作和物理设备的连接被创建。调用下面的命令来创建逻辑设备：

include::../api/protos/vkCreateDevice.txt[]

  * pname:physicalDevice must: be one of the device handles returned from a
    call to fname:vkEnumeratePhysicalDevices (see
    <<devsandqueues-physical-device-enumeration, Physical Device
    Enumeration>>).
  * pname:pCreateInfo is a pointer to a slink:VkDeviceCreateInfo structure
    containing information about how to create the device.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pDevice points to a handle in which the created sname:VkDevice is
    returned.

可以在同一个物理设备上创建多个逻辑设备。因为物理资源的缺乏（和其他错误），逻辑设备的创建可能失败。
如果发生了失败，fname:vkCreateDevice 将返回ename:VK_ERROR_TOO_MANY_OBJECTS。

include::../validity/protos/vkCreateDevice.txt[]

// refBegin VkDeviceCreateInfo Structure specifying parameters of a newly created device

The sname:VkDeviceCreateInfo structure is defined as:

include::../api/structs/VkDeviceCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags is reserved for future use.
  * pname:queueCreateInfoCount is the unsigned integer size of the
    pname:pQueueCreateInfos array.
    Refer to the <<devsandqueues-queue-creation,Queue Creation>> section
    below for further details.
  * pname:pQueueCreateInfos is a pointer to an array of
    slink:VkDeviceQueueCreateInfo structures describing the queues that are
    requested to be created along with the logical device.
    Refer to the <<devsandqueues-queue-creation,Queue Creation>> section
    below for further details.
  * pname:enabledLayerCount is deprecated and ignored.
  * pname:ppEnabledLayerNames is deprecated and ignored.
    See <<extended-functionality-device-layer-deprecation,Device Layer
    Deprecation>>.
  * pname:enabledExtensionCount is the number of device extensions to
    enable.
  * pname:ppEnabledExtensionNames is a pointer to an array of
    pname:enabledExtensionCount null-terminated UTF-8 strings containing the
    names of extensions to enable for the created device.
    See the <<extended-functionality-extensions,Extensions>> section for
    further details.
  * pname:pEnabledFeatures is `NULL` or a pointer to a
    slink:VkPhysicalDeviceFeatures structure that contains boolean
    indicators of all the features to be enabled.
    Refer to the <<features-features,Features>> section for further details.

.Valid Usage
****
  * The pname:queueFamilyIndex member of any given element of
    pname:pQueueCreateInfos must: be unique within pname:pQueueCreateInfos
ifdef::VK_KHR_get_physical_device_properties2[]
  * If the pname:pNext chain includes a slink:VkPhysicalDeviceFeatures2KHR
    structure, then pname:pEnabledFeatures must: be `NULL`
endif::VK_KHR_get_physical_device_properties2[]
ifdef::VK_KHR_maintenance1[]
ifdef::VK_AMD_negative_viewport_height[]
  * pname:ppEnabledExtensionNames must: not contain both
    code:VK_KHR_maintenance1 and code:VK_AMD_negative_viewport_height
endif::VK_AMD_negative_viewport_height[]
endif::VK_KHR_maintenance1[]
****

include::../validity/structs/VkDeviceCreateInfo.txt[]


[[devsandqueues-use]]
=== 使用设备


The following is a high-level list of sname:VkDevice uses along with
references on where to find more information:

  * Creation of queues.
    See the <<devsandqueues-queues,Queues>> section below for further
    details.
  * Creation and tracking of various synchronization constructs.
    See <<synchronization,Synchronization and Cache Control>> for further
    details.
  * Allocating, freeing, and managing memory.
    See <<memory,Memory Allocation>> and <<resources,Resource Creation>> for
    further details.
  * Creation and destruction of command buffers and command buffer pools.
    See <<commandbuffers,Command Buffers>> for further details.
  * Creation, destruction, and management of graphics state.
    See <<pipelines,Pipelines>> and <<descriptorsets,Resource Descriptors>>,
    among others, for further details.


[[devsandqueues-lost-device]]
=== 设备丢失

逻辑设备可能因为硬件错误、执行超时、电源管理事件和平台某些事件而丢失。这会导致待执行的命令执行失败和硬件资源损坏。
当发生这种情况时，某些命令会返回name:VK_ERROR_DEVICE_LOST（参考<<fundamentals-errorcodes,Error Codes>>）。
发生了这种情况后，逻辑设备被认为已经丢失了。
不可能重置逻辑设备到非丢失状态，然而，这个丢失状态只是针对逻辑设备而言的，对应的物理设备（sname:VkPhysicalDevice）可能不受影响。
一些情况下，物理设备也可能丢失，尝试创建逻辑设备会失败，返回ename:VK_ERROR_DEVICE_LOST。这通常意味着潜在的硬件问题，或者和
CPU端的连接问题。
如果物理设备没有被丢失，在它上面一个新的逻辑设备成功的被创建了，物理设备一定是非丢失状态。

[NOTE]
.注意
====
同时，逻辑设备丢失是可恢复的，物理设备丢失的情况下，除非系统中有另外未受影响的物理设备，否则应用程序不可能会恢复。
错误大体上是信息性的，试图通知用户他们的硬件可能产生了错误或连接不良，应该自己调查一下。一些情况下，物理设备丢失可能导致
其他严重的问题，比如操作系统崩溃，这样的话Vulkan API就不会给出原因了。
====

[NOTE]
.注意
====
应用程序导致的未知行为可能导致设备丢失。然而，这些未定义行为也会导致进程内存损坏，此时就不能保证API对象，包括
sname:VkPhysicalDevice 或者sname:VkInstance仍然是有效的，或者是可恢复的。 
====

当设备丢失了，它的子对象并没有隐式的被销毁，它们的handle仍然有效。这些对象必须要在他们父对象
或者设备被销毁之前被销毁（参考 <<fundamentals-objectmodel-lifetime,Object Lifetime>> 小节 ）。
The host address space corresponding to device memory mapped using
flink:vkMapMemory is still valid, and host memory accesses to these mapped
regions are still valid, but the contents are undefined.
It is still legal to call any API command on the device and child objects.

Once a device is lost, command execution may: fail, and commands that return
a elink:VkResult may: return ename:VK_ERROR_DEVICE_LOST.
Commands that do not allow run-time errors must: still operate correctly for
valid usage and, if applicable, return valid data.

Commands that wait indefinitely for device execution (namely
flink:vkDeviceWaitIdle, flink:vkQueueWaitIdle, flink:vkWaitForFences
ifdef::VK_KHR_swapchain[]
or flink:vkAcquireNextImageKHR
endif::VK_KHR_swapchain[]
with a maximum pname:timeout, and flink:vkGetQueryPoolResults with the
ename:VK_QUERY_RESULT_WAIT_BIT bit set in pname:flags) must: return in
finite time even in the case of a lost device, and return either
ename:VK_SUCCESS or ename:VK_ERROR_DEVICE_LOST.
For any command that may: return ename:VK_ERROR_DEVICE_LOST, for the purpose
of determining whether a command buffer is pending execution, or whether
resources are considered in-use by the device, a return value of
ename:VK_ERROR_DEVICE_LOST is equivalent to ename:VK_SUCCESS.

ifdef::editing-notes[]
[NOTE]
.editing-note
====
TODO (piman) - I do not think we are very clear about what "`in-use by the
device`" means.
====
endif::editing-notes[]


[[devsandqueues-destruction]]
=== 设备销毁

// refBegin vkDestroyDevice Destroy a logical device

To destroy a device, call:

include::../api/protos/vkDestroyDevice.txt[]

  * pname:device is the logical device to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

To ensure that no work is active on the device, flink:vkDeviceWaitIdle can:
be used to gate the destruction of the device.
Prior to destroying a device, an application is responsible for
destroying/freeing any Vulkan objects that were created using that device as
the first parameter of the corresponding ftext:vkCreate* or
ftext:vkAllocate* command.

[NOTE]
.Note
====
The lifetime of each of these objects is bound by the lifetime of the
sname:VkDevice object.
Therefore, to avoid resource leaks, it is critical that an application
explicitly free all of these resources prior to calling
fname:vkDestroyDevice.
====

.Valid Usage
****
  * All child objects created on pname:device must: have been destroyed
    prior to destroying pname:device
  * If sname:VkAllocationCallbacks were provided when pname:device was
    created, a compatible set of callbacks must: be provided here
  * If no sname:VkAllocationCallbacks were provided when pname:device was
    created, pname:pAllocator must: be `NULL`
****

include::../validity/protos/vkDestroyDevice.txt[]


[[devsandqueues-queues]]
== 队列


[[devsandqueues-queueprops]]
=== 队列族的属性

如之前的<<devsandqueues-physical-device-enumeration,Physical Device Enumeration>>一节讲过，flink:vkGetPhysicalDeviceQueueFamilyProperties
命令是用来获取设备所支持的队列族的属性的。

flink:vkGetPhysicalDeviceQueueFamilyProperties返回的pname:pQueueFamilyProperties数组的每一个索引描述了
物理设备上唯一的队列族。
这些索引被用来创建队列，它们通过下节<<devsandqueues-queue-creation,Queue Creation>> 讲解的slink:VkDeviceQueueCreateInfo类型数据
直接对应着传递给 flink:vkCreateDevice命令的 pname:queueFamilyIndex。

同一个物理设备上的队列族的分组取决于Vulkan实现。

[NOTE]
.注意
====
可以假定一个物理设备会把能力匹配的所有队列分组到一个族。
然而，这是对Vulkan实现的一个推荐，很可能，物理设备可能会返回两个拥有相同能力的族。
====

一旦应用程序以它想用的族来确定了物理设备，它将结合逻辑设备来创建这些队列。
这在下节讲述。


[[devsandqueues-queue-creation]]
=== 创建队列

// refBegin VkQueue Opaque handle to a queue object

创建一个逻辑设备也会创建该设备相关的队列。需要创建的队列通过传递给flink:vkCreateDevice 
的参数pname:pQueueCreateInfos的一系列slink:VkDeviceQueueCreateInfo类型数据描述。

队列通过sname:VkQueue handles表示：

include::../api/handles/VkQueue.txt[]

// refEnd VkQueue

// refBegin VkDeviceQueueCreateInfo Structure specifying parameters of a newly created device queue

The sname:VkDeviceQueueCreateInfo structure is defined as:

include::../api/structs/VkDeviceQueueCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags is reserved for future use.
  * pname:queueFamilyIndex is an unsigned integer indicating the index of
    the queue family to create on this device.
    This index corresponds to the index of an element of the
    pname:pQueueFamilyProperties array that was returned by
    fname:vkGetPhysicalDeviceQueueFamilyProperties.
  * pname:queueCount is an unsigned integer specifying the number of queues
    to create in the queue family indicated by pname:queueFamilyIndex.
  * pname:pQueuePriorities is an array of pname:queueCount normalized
    floating point values, specifying priorities of work that will be
    submitted to each created queue.
    See <<devsandqueues-priority,Queue Priority>> for more information.

.Valid Usage
****
  * pname:queueFamilyIndex must: be less than
    pname:pQueueFamilyPropertyCount returned by
    fname:vkGetPhysicalDeviceQueueFamilyProperties
  * pname:queueCount must: be less than or equal to the pname:queueCount
    member of the sname:VkQueueFamilyProperties structure, as returned by
    fname:vkGetPhysicalDeviceQueueFamilyProperties in the
    pname:pQueueFamilyProperties[pname:queueFamilyIndex]
  * Each element of pname:pQueuePriorities must: be between `0.0` and `1.0`
    inclusive
****

include::../validity/structs/VkDeviceQueueCreateInfo.txt[]

// refBegin vkGetDeviceQueue Get a queue handle from a device

To retrieve a handle to a VkQueue object, call:

include::../api/protos/vkGetDeviceQueue.txt[]

  * pname:device is the logical device that owns the queue.
  * pname:queueFamilyIndex is the index of the queue family to which the
    queue belongs.
  * pname:queueIndex is the index within this queue family of the queue to
    retrieve.
  * pname:pQueue is a pointer to a sname:VkQueue object that will be filled
    with the handle for the requested queue.

.Valid Usage
****
  * pname:queueFamilyIndex must: be one of the queue family indices
    specified when pname:device was created, via the
    sname:VkDeviceQueueCreateInfo structure
  * pname:queueIndex must: be less than the number of queues created for the
    specified queue family index when pname:device was created, via the
    pname:queueCount member of the sname:VkDeviceQueueCreateInfo structure
****

include::../validity/protos/vkGetDeviceQueue.txt[]


[[devsandqueues-index]]
=== 队列族索引

The queue family index is used in multiple places in Vulkan in order to tie
operations to a specific family of queues.

When retrieving a handle to the queue via fname:vkGetDeviceQueue, the queue
family index is used to select which queue family to retrieve the
sname:VkQueue handle from as described in the previous section.

When creating a sname:VkCommandPool object (see
<<commandbuffers-pools,Command Pools>>), a queue family index is specified
in the slink:VkCommandPoolCreateInfo structure.
Command buffers from this pool can: only be submitted on queues
corresponding to this queue family.

When creating sname:VkImage (see <<resources-images,Images>>) and
sname:VkBuffer (see <<resources-buffers,Buffers>>) resources, a set of queue
families is included in the slink:VkImageCreateInfo and
slink:VkBufferCreateInfo structures to specify the queue families that can:
access the resource.

When inserting a slink:VkBufferMemoryBarrier or slink:VkImageMemoryBarrier
(see <<synchronization-events>>) a source and destination queue family index
is specified to allow the ownership of a buffer or image to be transferred
from one queue family to another.
See the <<resources-sharing,Resource Sharing>> section for details.


[[devsandqueues-priority]]
=== 队列优先级

每一个队列都被分配了一个优先级，在创建设备过程中slink:VkDeviceQueueCreateInfo的数据结构中设置的。
每一个队列的优先级是一个归一化的浮点值，在0.0和1.0之间，然后有Vulkan实现转换到离散的的优先级级别。
高的值表示更高的优先级，0.0表示最低的优先级，1.0表示最高。一个设备内，拥有高优先级的队列将会比
优先级低的队列获得更多的处理时间。Vulkan实现不保证相同优先级的队列的排序或者调度，
不管<<synchronization, explicit synchronization primitives>>中已定义的限制如何。
Vulkan实现不保证不同设备之间的队列要如何安排优先级。

一个Vulkan实现也许允许更高优先级的队列会让同一个设备上的低优先级的队列挨饿，直到自己完成所有命令的执行。
队列优先级的关系必须不能导致另外一个设备上的队列暂停工作。

没有任何明确的保证高优先级的队列比低优先级的队列接受更多的处理时间和服务质量。

[[devsandqueues-submission]]
=== 队列提交

通过_队列提交_命令，如flink:vkQueueSubmit，工作就被提交到队列了。队列提交命令定义了一系列的需要
物理设备执行的_队列操作_，包括使用信号量和栅栏来同步。

提交命令接受目标设备为参数，零个或者多个_batches_的任务，和一个可选的栅栏来激发任务完成的信号。
每一个批次由三个部分组成：

  . Zero or more semaphores to wait on before execution of the rest of the
    batch.
  ** If present, these describe a <<synchronization-semaphores-waiting,
     semaphore wait operation>>.
  . Zero or more work items to execute.
  ** If present, these describe a _queue operation_ matching the work
     described.
  . Zero or more semaphores to signal upon completion of the work items.
  ** If present, these describe a <<synchronization-semaphores-signaling,
     semaphore signal operation>>.

If a fence is present in a queue submission, it describes a
<<synchronization-fences-signaling, fence signal operation>>.

通过一个队列提交命令描述的所有任务必须在命令返回前提交到队列。


[[devsandqueues-sparsebinding]]
==== 稀疏内存绑定

在Vulkan里，可以稀疏的绑定内存到缓冲区或者图像，这点在前面的<<sparsememory,Sparse Resource>>一章讲过。
稀疏内存绑定是一个队列操作。包含ename:VK_QUEUE_SPARSE_BINDING_BIT标志的队列必须能支持在设备上
映射虚拟地址到物理地址。这将导致设备上映射表的更新。这个更新必须让队列保持同步，以避免在图形命令执行期间
损坏page table映射。通过在队列上绑定稀疏内存，所有依赖于被更新的绑定的命令在绑定更新之后同步的执行。
查看 <<synchronization,Synchronization and Cache Control>> 一章可知如何实现同步。


[[devsandqueues-queuedestruction]]
=== 队列销毁

队列和fname:vkCreateDevice创建的逻辑设备一同被创建。当调用fname:vkDestroyDevice后，和逻辑设备关联的所有队列都被销毁了。
