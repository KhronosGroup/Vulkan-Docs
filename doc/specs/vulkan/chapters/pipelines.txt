// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[pipelines]]
= 管线

接下来的<<pipelines-block-diagram,figure>> 展示了Vulkan管线的一些图表。一些Vulkan命令指定了需要被绘制对象或者需要执行的计算任务，
其他的指定了控制对象如何被管线各个阶段控制，或者控制了数据如何在有组织的内存（如图像、缓冲区）之间转移。
命令通过一个处理管线（_图形管线_ 或者 _计算管线_）高效的发送出去。

<<pipelines-graphics,graphics pipeline>>(<<drawing,Input Assembler>>)的第一个阶段按照要求的图元拓扑把顶点组装成几何图元，
如圆点，线段和三角形。在下一个阶段（<<shaders-vertex,Vertex Shader>>） 顶点可以形变、计算位置和属性。
如果<<tessellation, 细分>> and/or <<geometry, 几何>>着色器被支持，他们可以从单个输入图元生成多个图元，可能
改变原图元拓扑或者生成在处理过程中生成另外的属性。

最终生成的图元被剪裁到一个剪裁空间，为下一个阶段<<primsrast,Rasterization>>做准备。
栅格化器一系列帧缓冲区地址和值，使用二维的方式描述点、线段或者三角形。产生的每一个_片元_都传递给
下一个阶段(<<shaders-fragment,片元着色器>>)，在每一个单独的片元上进行操作，最后才进入帧缓冲区。
这些操作包含根据之前或之后存储的深度值（影响<<fragops-depth, 深度缓冲>>）来判断是否进入帧缓冲区，
新的片元颜色值是否和之前存储的颜色进行<<framebuffer-blending,blending>>，还有<<framebuffer-blendoperations,masking>>,
<<fragops-stencil, 模板>>和其他的 <<framebuffer-logicop, 逻辑操作>>。

帧缓冲区操作针对<renderpass,render pass instance>>读写帧缓冲区的颜色、深度/模板附件。
附件可以在同一个render pass中后续subpass中用作片元着色器的输入附件。

<<pipelines-compute,compute pipeline>>和图形管线是独立的，图形管线可操作一维、二维或者三维工作组（可读写缓冲区和图像内存）。

这个顺序是用来描述Vulkan的，并不是Vulkan如何实现的一个严格准则，我们这里提到只是为了组织管线中各种各样的操作。
管线阶段之间真正的顺序保证在稍后的 <<synchronization-pipeline-stages-order, synchronization chapter>>详细讲解。


[[pipelines-block-diagram]]
image::images/pipeline.svg[title="Block diagram of the Vulkan pipeline",{fullimagewidth},align="center"]

每一个管线都是被所有的着色器阶段描述或者任何相关的固定功能阶段创造的一个对象所控制。
把整个管线<<interfaces, 链接>> 可以基于着色器的输入、输出来优化着色器，消除绘制阶段内昂贵的验证操作。

一个管线对象在命令缓冲区中被绑定到物理状态。当管线被绑定时，被标记为动态的任何管线对象状态都不可以应用到动态状态。
没用通过绑定管线对象来设置的动态状态可以在任何时刻被修改，在整个命令缓冲区生命周期内持续有效，直到被其他动态状态命令或者管线绑定所修改。
所有的状态，包括动态状态，都不从一个命令缓冲区继承到另外一个命令缓冲区。
只有在命令缓冲区中执行的操作所需的动态状态需要被设置。
比如，如果管线禁用了混合，那么动态颜色混合常量不需要在命令缓冲区中指定，甚至如果这个状态在管线状态对象中被标记为动态。
如果一个管线对象被绑定为一个没有被之前管线对象标记为动态的状态，这个新的管线对象状态将会覆盖动态状态。
修改没有被管线状态对象设置为动态的动态状态将会导致为定义的结果。


// refBegin VkPipeline Opaque handle to a pipeline object

Compute and graphics pipelines are each represented by sname:VkPipeline
handles:

include::../api/handles/VkPipeline.txt[]

// refEnd VkPipeline


[[pipelines-compute]]
== 计算管线

计算管线有单个静态计算着色器阶段和管线布局组成。

计算管线代表着一个计算着色器，通过参数pname:module 和 pname:pName从计算着色器中选择一个入口点来 调用fname:vkCreateComputePipelines，
这个入口点定义了一个有效的计算着色器，包含在sname:VkComputePipelineCreateInfo数据结构中的sname:VkPipelineShaderStageCreateInfo。


// refBegin vkCreateComputePipelines Creates a new compute pipeline object

To create compute pipelines, call:

include::../api/protos/vkCreateComputePipelines.txt[]

  * pname:device is the logical device that creates the compute pipelines.
  * pname:pipelineCache is either dlink:VK_NULL_HANDLE, indicating that
    pipeline caching is disabled; or the handle of a valid
    <<pipelines-cache,pipeline cache>> object, in which case use of that
    cache is enabled for the duration of the command.
  * pname:createInfoCount is the length of the pname:pCreateInfos and
    pname:pPipelines arrays.
  * pname:pCreateInfos is an array of sname:VkComputePipelineCreateInfo
    structures.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pPipelines is a pointer to an array in which the resulting compute
    pipeline objects are returned.
+
--
ifdef::editing-notes[]
[NOTE]
.editing-note
====
TODO (Jon) - Should we say something like ``the i'th element of the
pname:pPipelines array is created based on the corresponding element of the
pname:pCreateInfos array''? Also for flink:vkCreateGraphicsPipelines below.
====
endif::editing-notes[]
--

.Valid Usage
****
  * If the pname:flags member of any given element of pname:pCreateInfos
    contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the
    pname:basePipelineIndex member of that same element is not `-1`,
    pname:basePipelineIndex must: be less than the index into
    pname:pCreateInfos that corresponds to that element
  * If the pname:flags member of any given element of pname:pCreateInfos
    contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base
    pipeline must: have been created with the
    ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set
****

include::../validity/protos/vkCreateComputePipelines.txt[]

// refBegin VkComputePipelineCreateInfo Structure specifying parameters of a newly created compute pipeline

The sname:VkComputePipelineCreateInfo structure is defined as:

include::../api/structs/VkComputePipelineCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags provides options for pipeline creation, and is of type
    elink:VkPipelineCreateFlagBits.
  * pname:stage is a slink:VkPipelineShaderStageCreateInfo describing the
    compute shader.
  * pname:layout is the description of binding locations used by both the
    pipeline and descriptor sets used with the pipeline.
  * pname:basePipelineHandle is a pipeline to derive from
  * pname:basePipelineIndex is an index into the pname:pCreateInfos
    parameter to use as a pipeline to derive from

The parameters pname:basePipelineHandle and pname:basePipelineIndex are
described in more detail in <<pipelines-pipeline-derivatives,Pipeline
Derivatives>>.

pname:stage points to a structure of type
sname:VkPipelineShaderStageCreateInfo.

.Valid Usage
****
  * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineIndex is -1, pname:basePipelineHandle must:
    be a valid handle to a compute sname:VkPipeline
  * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineHandle is dlink:VK_NULL_HANDLE,
    pname:basePipelineIndex must: be a valid index into the calling
    command's pname:pCreateInfos parameter
  * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineIndex is not -1, pname:basePipelineHandle
    must: be dlink:VK_NULL_HANDLE
  * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineHandle is not dlink:VK_NULL_HANDLE,
    pname:basePipelineIndex must: be -1
  * The pname:stage member of pname:stage must: be
    ename:VK_SHADER_STAGE_COMPUTE_BIT
  * The shader code for the entry point identified by pname:stage and the
    rest of the state identified by this structure must: adhere to the
    pipeline linking rules described in the <<interfaces,Shader Interfaces>>
    chapter
  * pname:layout must: be
    <<descriptorsets-pipelinelayout-consistency,consistent>> with the layout
    of the compute shader specified in pname:stage
****

include::../validity/structs/VkComputePipelineCreateInfo.txt[]

// refBegin VkPipelineShaderStageCreateInfo Structure specifying parameters of a newly created pipeline shader stage

The sname:VkPipelineShaderStageCreateInfo structure is defined as:

include::../api/structs/VkPipelineShaderStageCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags is reserved for future use.
  * pname:stage names a single pipeline stage.
    Bits which can: be set include:
+
--
// refBegin VkShaderStageFlagBits Bitmask specifying a pipeline stage
include::../api/enums/VkShaderStageFlagBits.txt[]
--
  * pname:module is a sname:VkShaderModule object that contains the shader
    for this stage.
  * pname:pName is a pointer to a null-terminated UTF-8 string specifying
    the entry point name of the shader for this stage.
  * pname:pSpecializationInfo is a pointer to slink:VkSpecializationInfo, as
    described in <<pipelines-specialization-constants,Specialization
    Constants>>, and can: be `NULL`.

.Valid Usage
****
  * If the <<features-features-geometryShader,geometry shaders>> feature is
    not enabled, pname:stage must: not be ename:VK_SHADER_STAGE_GEOMETRY_BIT
  * If the <<features-features-tessellationShader,tessellation shaders>>
    feature is not enabled, pname:stage must: not be
    ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
  * pname:stage must: not be ename:VK_SHADER_STAGE_ALL_GRAPHICS, or
    ename:VK_SHADER_STAGE_ALL
  * pname:pName must: be the name of an code:OpEntryPoint in pname:module
    with an execution model that matches pname:stage
  * If the identified entry point includes any variable in its interface
    that is declared with the code:ClipDistance code:BuiltIn decoration,
    that variable must: not have an array size greater than
    sname:VkPhysicalDeviceLimits::pname:maxClipDistances
  * If the identified entry point includes any variable in its interface
    that is declared with the code:CullDistance code:BuiltIn decoration,
    that variable must: not have an array size greater than
    sname:VkPhysicalDeviceLimits::pname:maxCullDistances
  * If the identified entry point includes any variables in its interface
    that are declared with the code:ClipDistance or code:CullDistance
    code:BuiltIn decoration, those variables must: not have array sizes
    which sum to more than
    sname:VkPhysicalDeviceLimits::pname:maxCombinedClipAndCullDistances
  * If the identified entry point includes any variable in its interface
    that is declared with the code:SampleMask code:BuiltIn decoration, that
    variable must: not have an array size greater than
    sname:VkPhysicalDeviceLimits::pname:maxSampleMaskWords
  * If pname:stage is ename:VK_SHADER_STAGE_VERTEX_BIT, the identified entry
    point must: not include any input variable in its interface that is
    decorated with code:CullDistance
  * If pname:stage is ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, and the identified
    entry point has an code:OpExecutionMode instruction that specifies a
    patch size with code:OutputVertices, the patch size must: be greater
    than `0` and less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxTessellationPatchSize
  * If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, the identified
    entry point must: have an code:OpExecutionMode instruction that
    specifies a maximum output vertex count that is greater than `0` and
    less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxGeometryOutputVertices
  * If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, the identified
    entry point must: have an code:OpExecutionMode instruction that
    specifies an invocation count that is greater than `0` and less than or
    equal to
    sname:VkPhysicalDeviceLimits::pname:maxGeometryShaderInvocations
  * If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, and the identified
    entry point writes to code:Layer for any primitive, it must: write the
    same value to code:Layer for all vertices of a given primitive
  * If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, and the identified
    entry point writes to code:ViewportIndex for any primitive, it must:
    write the same value to code:ViewportIndex for all vertices of a given
    primitive
  * If pname:stage is ename:VK_SHADER_STAGE_FRAGMENT_BIT, the identified
    entry point must: not include any output variables in its interface
    decorated with code:CullDistance
  * If pname:stage is ename:VK_SHADER_STAGE_FRAGMENT_BIT, and the identified
    entry point writes to code:FragDepth in any execution path, it must:
    write to code:FragDepth in all execution paths
****

include::../validity/structs/VkPipelineShaderStageCreateInfo.txt[]


[[pipelines-graphics]]
== 图形管线

图形管线由多个着色器阶段、多个固定功能管线阶段和管线布局组成。


// refBegin vkCreateGraphicsPipelines Create graphics pipelines

想创建图形管线，可调用：

include::../api/protos/vkCreateGraphicsPipelines.txt[]

  * pname:device is the logical device that creates the graphics pipelines.
  * pname:pipelineCache is either dlink:VK_NULL_HANDLE, indicating that
    pipeline caching is disabled; or the handle of a valid
    <<pipelines-cache,pipeline cache>> object, in which case use of that
    cache is enabled for the duration of the command.
  * pname:createInfoCount is the length of the pname:pCreateInfos and
    pname:pPipelines arrays.
  * pname:pCreateInfos is an array of sname:VkGraphicsPipelineCreateInfo
    structures.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pPipelines is a pointer to an array in which the resulting
    graphics pipeline objects are returned.

The slink:VkGraphicsPipelineCreateInfo structure includes an array of shader
create info structures containing all the desired active shader stages, as
well as creation info to define all relevant fixed-function stages, and a
pipeline layout.

.Valid Usage
****
  * If the pname:flags member of any given element of pname:pCreateInfos
    contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the
    pname:basePipelineIndex member of that same element is not `-1`,
    pname:basePipelineIndex must: be less than the index into
    pname:pCreateInfos that corresponds to that element
  * If the pname:flags member of any given element of pname:pCreateInfos
    contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base
    pipeline must: have been created with the
    ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set
****

include::../validity/protos/vkCreateGraphicsPipelines.txt[]

// refBegin VkGraphicsPipelineCreateInfo Structure specifying parameters of a newly created graphics pipeline

The sname:VkGraphicsPipelineCreateInfo structure is defined as:

include::../api/structs/VkGraphicsPipelineCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags is a bitmask of elink:VkPipelineCreateFlagBits controlling
    how the pipeline will be generated, as described below.
  * pname:stageCount is the number of entries in the pname:pStages array.
  * pname:pStages is an array of size pname:stageCount structures of type
    slink:VkPipelineShaderStageCreateInfo describing the set of the shader
    stages to be included in the graphics pipeline.
  * pname:pVertexInputState is a pointer to an instance of the
    slink:VkPipelineVertexInputStateCreateInfo structure.
  * pname:pInputAssemblyState is a pointer to an instance of the
    slink:VkPipelineInputAssemblyStateCreateInfo structure which determines
    input assembly behavior, as described in <<drawing, Drawing Commands>>.
  * pname:pTessellationState is a pointer to an instance of the
    slink:VkPipelineTessellationStateCreateInfo structure, or `NULL` if the
    pipeline does not include a tessellation control shader stage and
    tessellation evaluation shader stage.
  * pname:pViewportState is a pointer to an instance of the
    slink:VkPipelineViewportStateCreateInfo structure, or `NULL` if the
    pipeline has rasterization disabled.
  * pname:pRasterizationState is a pointer to an instance of the
    slink:VkPipelineRasterizationStateCreateInfo structure.
  * pname:pMultisampleState is a pointer to an instance of the
    slink:VkPipelineMultisampleStateCreateInfo, or `NULL` if the pipeline
    has rasterization disabled.
  * pname:pDepthStencilState is a pointer to an instance of the
    slink:VkPipelineDepthStencilStateCreateInfo structure, or `NULL` if the
    pipeline has rasterization disabled or if the subpass of the render pass
    the pipeline is created against does not use a depth/stencil attachment.
  * pname:pColorBlendState is a pointer to an instance of the
    slink:VkPipelineColorBlendStateCreateInfo structure, or `NULL` if the
    pipeline has rasterization disabled or if the subpass of the render pass
    the pipeline is created against does not use any color attachments.
  * pname:pDynamicState is a pointer to
    slink:VkPipelineDynamicStateCreateInfo and is used to indicate which
    properties of the pipeline state object are dynamic and can: be changed
    independently of the pipeline state.
    This can: be `NULL`, which means no state in the pipeline is considered
    dynamic.
  * pname:layout is the description of binding locations used by both the
    pipeline and descriptor sets used with the pipeline.
  * pname:renderPass is a handle to a render pass object describing the
    environment in which the pipeline will be used; the pipeline must: only
    be used with an instance of any render pass compatible with the one
    provided.
    See <<renderpass-compatibility,Render Pass Compatibility>> for more
    information.
  * pname:subpass is the index of the subpass in the render pass where this
    pipeline will be used.
  * pname:basePipelineHandle is a pipeline to derive from.
  * pname:basePipelineIndex is an index into the pname:pCreateInfos
    parameter to use as a pipeline to derive from.

The parameters pname:basePipelineHandle and pname:basePipelineIndex are
described in more detail in <<pipelines-pipeline-derivatives,Pipeline
Derivatives>>.

pname:pStages points to an array of slink:VkPipelineShaderStageCreateInfo
structures, which were previously described in <<pipelines-compute,Compute
Pipelines>>.

Bits which can: be set in pname:flags are:

// refBegin VkPipelineCreateFlagBits Bitmask controlling how a pipeline is generated
include::../api/enums/VkPipelineCreateFlagBits.txt[]

  * ename:VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT specifies that the
    created pipeline will not be optimized.
    Using this flag may: reduce the time taken to create the pipeline.
  * ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT specifies that the
    pipeline to be created is allowed to be the parent of a pipeline that
    will be created in a subsequent call to flink:vkCreateGraphicsPipelines.
  * ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT specifies that the pipeline to
    be created will be a child of a previously created parent pipeline.

It is valid to set both ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT and
ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT.
This allows a pipeline to be both a parent and possibly a child in a
pipeline hierarchy.
See <<pipelines-pipeline-derivatives,Pipeline Derivatives>> for more
information.

pname:pDynamicState points to a structure of type
sname:VkPipelineDynamicStateCreateInfo.

ifdef::VK_NV_glsl_shader[]
If any shader stage fails to compile,
ifdef::VK_EXT_debug_report[]
the compile log will be reported back to the application, and
endif::VK_EXT_debug_report[]
ename:VK_ERROR_INVALID_SHADER_NV will be generated.
endif::VK_NV_glsl_shader[]

.Valid Usage
****
  * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineIndex is -1, pname:basePipelineHandle must:
    be a valid handle to a graphics sname:VkPipeline
  * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineHandle is dlink:VK_NULL_HANDLE,
    pname:basePipelineIndex must: be a valid index into the calling
    command's pname:pCreateInfos parameter
  * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineIndex is not -1, pname:basePipelineHandle
    must: be dlink:VK_NULL_HANDLE
  * If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineHandle is not dlink:VK_NULL_HANDLE,
    pname:basePipelineIndex must: be -1
  * The pname:stage member of each element of pname:pStages must: be unique
  * The pname:stage member of one element of pname:pStages must: be
    ename:VK_SHADER_STAGE_VERTEX_BIT
  * The pname:stage member of any given element of pname:pStages must: not
    be ename:VK_SHADER_STAGE_COMPUTE_BIT
  * If pname:pStages includes a tessellation control shader stage, it must:
    include a tessellation evaluation shader stage
  * If pname:pStages includes a tessellation evaluation shader stage, it
    must: include a tessellation control shader stage
  * If pname:pStages includes a tessellation control shader stage and a
    tessellation evaluation shader stage, pname:pTessellationState must: not
    be `NULL`
  * If pname:pStages includes tessellation shader stages, the shader code of
    at least one stage must: contain an code:OpExecutionMode instruction
    that specifies the type of subdivision in the pipeline
  * If pname:pStages includes tessellation shader stages, and the shader
    code of both stages contain an code:OpExecutionMode instruction that
    specifies the type of subdivision in the pipeline, they must: both
    specify the same subdivision mode
  * If pname:pStages includes tessellation shader stages, the shader code of
    at least one stage must: contain an code:OpExecutionMode instruction
    that specifies the output patch size in the pipeline
  * If pname:pStages includes tessellation shader stages, and the shader
    code of both contain an code:OpExecutionMode instruction that specifies
    the out patch size in the pipeline, they must: both specify the same
    patch size
  * If pname:pStages includes tessellation shader stages, the pname:topology
    member of pname:pInputAssembly must: be
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST
  * If the pname:topology member of pname:pInputAssembly is
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, pname:pStages must: include
    tessellation shader stages
  * If pname:pStages includes a geometry shader stage, and does not include
    any tessellation shader stages, its shader code must: contain an
    code:OpExecutionMode instruction that specifies an input primitive type
    that is <<shaders-geometry-execution, compatible>> with the primitive
    topology specified in pname:pInputAssembly
  * If pname:pStages includes a geometry shader stage, and also includes
    tessellation shader stages, its shader code must: contain an
    code:OpExecutionMode instruction that specifies an input primitive type
    that is <<shaders-geometry-execution, compatible>> with the primitive
    topology that is output by the tessellation stages
  * If pname:pStages includes a fragment shader stage and a geometry shader
    stage, and the fragment shader code reads from an input variable that is
    decorated with code:PrimitiveID, then the geometry shader code must:
    write to a matching output variable, decorated with code:PrimitiveID, in
    all execution paths
  * If pname:pStages includes a fragment shader stage, its shader code must:
    not read from any input attachment that is defined as
    ename:VK_ATTACHMENT_UNUSED in pname:subpass
  * The shader code for the entry points identified by pname:pStages, and
    the rest of the state identified by this structure must: adhere to the
    pipeline linking rules described in the <<interfaces,Shader Interfaces>>
    chapter
  * If pname:subpass uses a depth/stencil attachment in pname:renderpass
    that has a layout of
    ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL in the
    sname:VkAttachmentReference defined by pname:subpass, and
    pname:pDepthStencilState is not `NULL`, the pname:depthWriteEnable
    member of pname:pDepthStencilState must: be ename:VK_FALSE
  * If pname:subpass uses a depth/stencil attachment in pname:renderpass
    that has a layout of
    ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL in the
    sname:VkAttachmentReference defined by pname:subpass, and
    pname:pDepthStencilState is not `NULL`, the pname:failOp, pname:passOp
    and pname:depthFailOp members of each of the pname:front and pname:back
    members of pname:pDepthStencilState must: be ename:VK_STENCIL_OP_KEEP
  * If pname:pColorBlendState is not `NULL`, the pname:blendEnable member of
    each element of the pname:pAttachment member of pname:pColorBlendState
    must: be ename:VK_FALSE if the pname:format of the attachment referred
    to in pname:subpass of pname:renderPass does not support color blend
    operations, as specified by the
    ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT flag in
    sname:VkFormatProperties::pname:linearTilingFeatures or
    sname:VkFormatProperties::pname:optimalTilingFeatures returned by
    fname:vkGetPhysicalDeviceFormatProperties
  * If pname:pColorBlendState is not `NULL`, The pname:attachmentCount
    member of pname:pColorBlendState must: be equal to the
    pname:colorAttachmentCount used to create pname:subpass
  * If no element of the pname:pDynamicStates member of pname:pDynamicState
    is ename:VK_DYNAMIC_STATE_VIEWPORT, the pname:pViewports member of
    pname:pViewportState must: be a pointer to an array of
    pname:pViewportState::pname:viewportCount sname:VkViewport structures
  * If no element of the pname:pDynamicStates member of pname:pDynamicState
    is ename:VK_DYNAMIC_STATE_SCISSOR, the pname:pScissors member of
    pname:pViewportState must: be a pointer to an array of
    pname:pViewportState::pname:scissorCount sname:VkRect2D structures
  * If the wide lines feature is not enabled, and no element of the
    pname:pDynamicStates member of pname:pDynamicState is
    ename:VK_DYNAMIC_STATE_LINE_WIDTH, the pname:lineWidth member of
    pname:pRasterizationState must: be `1.0`
  * If the pname:rasterizerDiscardEnable member of pname:pRasterizationState
    is ename:VK_FALSE, pname:pViewportState must: be a pointer to a valid
    sname:VkPipelineViewportStateCreateInfo structure
  * If the pname:rasterizerDiscardEnable member of pname:pRasterizationState
    is ename:VK_FALSE, pname:pMultisampleState must: be a pointer to a valid
    sname:VkPipelineMultisampleStateCreateInfo structure
  * If the pname:rasterizerDiscardEnable member of pname:pRasterizationState
    is ename:VK_FALSE, and pname:subpass uses a depth/stencil attachment,
    pname:pDepthStencilState must: be a pointer to a valid
    sname:VkPipelineDepthStencilStateCreateInfo structure
  * If the pname:rasterizerDiscardEnable member of pname:pRasterizationState
    is ename:VK_FALSE, and pname:subpass uses color attachments,
    pname:pColorBlendState must: be a pointer to a valid
    sname:VkPipelineColorBlendStateCreateInfo structure
  * If the depth bias clamping feature is not enabled, no element of the
    pname:pDynamicStates member of pname:pDynamicState is
    ename:VK_DYNAMIC_STATE_DEPTH_BIAS, and the pname:depthBiasEnable member
    of pname:pDepthStencil is ename:VK_TRUE, the pname:depthBiasClamp member
    of pname:pDepthStencil must: be `0.0`
  * If no element of the pname:pDynamicStates member of pname:pDynamicState
    is ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the
    pname:depthBoundsTestEnable member of pname:pDepthStencil is
    ename:VK_TRUE, the pname:minDepthBounds and pname:maxDepthBounds members
    of pname:pDepthStencil must: be between `0.0` and `1.0`, inclusive
  * pname:layout must: be
    <<descriptorsets-pipelinelayout-consistency,consistent>> with all
    shaders specified in pname:pStages
  * If pname:subpass uses color and/or depth/stencil attachments, then the
    pname:rasterizationSamples member of pname:pMultisampleState must: be
    the same as the sample count for those subpass attachments
  * If pname:subpass does not use any color and/or depth/stencil
    attachments, then the pname:rasterizationSamples member of
    pname:pMultisampleState must: follow the rules for a
    <<renderpass-noattachments, zero-attachment subpass>>
  * pname:subpass must: be a valid subpass within pname:renderpass
****

include::../validity/structs/VkGraphicsPipelineCreateInfo.txt[]

// refBegin VkPipelineDynamicStateCreateInfo Structure specifying parameters of a newly created pipeline dynamic state

The sname:VkPipelineDynamicStateCreateInfo structure is defined as:

include::../api/structs/VkPipelineDynamicStateCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags is reserved for future use.
  * pname:dynamicStateCount is the number of elements in the
    pname:pDynamicStates array.
  * pname:pDynamicStates is an array of elink:VkDynamicState enums which
    indicate which pieces of pipeline state will use the values from dynamic
    state commands rather than from the pipeline state creation info.

include::../validity/structs/VkPipelineDynamicStateCreateInfo.txt[]

// refBegin VkDynamicState Indicate which dynamic state is taken from dynamic state commands

The source of difference pieces of dynamic state is determined by the
slink:VkPipelineDynamicStateCreateInfo::pname:pDynamicStates property of the
currently active pipeline, which takes the following values:

include::../api/enums/VkDynamicState.txt[]

  * ename:VK_DYNAMIC_STATE_VIEWPORT indicates that the pname:pViewports
    state in sname:VkPipelineViewportStateCreateInfo will be ignored and
    must: be set dynamically with flink:vkCmdSetViewport before any draw
    commands.
    The number of viewports used by a pipeline is still specified by the
    pname:viewportCount member of sname:VkPipelineViewportStateCreateInfo.
  * ename:VK_DYNAMIC_STATE_SCISSOR indicates that the pname:pScissors state
    in sname:VkPipelineViewportStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetScissor before any draw commands.
    The number of scissor rectangles used by a pipeline is still specified
    by the pname:scissorCount member of
    sname:VkPipelineViewportStateCreateInfo.
  * ename:VK_DYNAMIC_STATE_LINE_WIDTH indicates that the pname:lineWidth
    state in sname:VkPipelineRasterizationStateCreateInfo will be ignored
    and must: be set dynamically with flink:vkCmdSetLineWidth before any
    draw commands that generate line primitives for the rasterizer.
  * ename:VK_DYNAMIC_STATE_DEPTH_BIAS indicates that the
    pname:depthBiasConstantFactor, pname:depthBiasClamp and
    pname:depthBiasSlopeFactor states in
    sname:VkPipelineRasterizationStateCreateInfo will be ignored and must:
    be set dynamically with flink:vkCmdSetDepthBias before any draws are
    performed with pname:depthBiasEnable in
    sname:VkPipelineRasterizationStateCreateInfo set to ename:VK_TRUE.
  * ename:VK_DYNAMIC_STATE_BLEND_CONSTANTS indicates that the
    pname:blendConstants state in sname:VkPipelineColorBlendStateCreateInfo
    will be ignored and must: be set dynamically with
    flink:vkCmdSetBlendConstants before any draws are performed with a
    pipeline state with sname:VkPipelineColorBlendAttachmentState member
    pname:blendEnable set to ename:VK_TRUE and any of the blend functions
    using a constant blend color.
  * ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS indicates that the
    pname:minDepthBounds and pname:maxDepthBounds states of
    slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetDepthBounds before any draws are
    performed with a pipeline state with
    sname:VkPipelineDepthStencilStateCreateInfo member
    pname:depthBoundsTestEnable set to ename:VK_TRUE.
  * ename:VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK indicates that the
    pname:compareMask state in sname:VkPipelineDepthStencilStateCreateInfo
    for both pname:front and pname:back will be ignored and must: be set
    dynamically with flink:vkCmdSetStencilCompareMask before any draws are
    performed with a pipeline state with
    sname:VkPipelineDepthStencilStateCreateInfo member
    pname:stencilTestEnable set to ename:VK_TRUE
  * ename:VK_DYNAMIC_STATE_STENCIL_WRITE_MASK indicates that the
    pname:writeMask state in sname:VkPipelineDepthStencilStateCreateInfo for
    both pname:front and pname:back will be ignored and must: be set
    dynamically with flink:vkCmdSetStencilWriteMask before any draws are
    performed with a pipeline state with
    sname:VkPipelineDepthStencilStateCreateInfo member
    pname:stencilTestEnable set to ename:VK_TRUE
  * ename:VK_DYNAMIC_STATE_STENCIL_REFERENCE indicates that the
    pname:reference state in sname:VkPipelineDepthStencilStateCreateInfo for
    both pname:front and pname:back will be ignored and must: be set
    dynamically with flink:vkCmdSetStencilReference before any draws are
    performed with a pipeline state with
    sname:VkPipelineDepthStencilStateCreateInfo member
    pname:stencilTestEnable set to ename:VK_TRUE

// refEnd VkDynamicState


=== Valid Combinations of Stages for Graphics Pipelines

If tessellation shader stages are omitted, the tessellation shading and
fixed-function stages of the pipeline are skipped.

If a geometry shader is omitted, the geometry shading stage is skipped.

If a fragment shader is omitted, the results of fragment processing are
undefined.
Specifically, any fragment color outputs are considered to have undefined
values, and the fragment depth is considered to be unmodified.
This can: be useful for depth-only rendering.

Presence of a shader stage in a pipeline is indicated by including a valid
sname:VkPipelineShaderStageCreateInfo with pname:module and pname:pName
selecting an entry point from a shader module, where that entry point is
valid for the stage specified by pname:stage.

Presence of some of the fixed-function stages in the pipeline is implicitly
derived from enabled shaders and provided state.
For example, the fixed-function tessellator is always present when the
pipeline has valid Tessellation Control and Tessellation Evaluation shaders.

.For example:
  * Depth/stencil-only rendering in a subpass with no color attachments
  ** Active Pipeline Shader Stages
  *** Vertex Shader
  ** Required: Fixed-Function Pipeline Stages
  *** slink:VkPipelineVertexInputStateCreateInfo
  *** slink:VkPipelineInputAssemblyStateCreateInfo
  *** slink:VkPipelineViewportStateCreateInfo
  *** slink:VkPipelineRasterizationStateCreateInfo
  *** slink:VkPipelineMultisampleStateCreateInfo
  *** slink:VkPipelineDepthStencilStateCreateInfo
  * Color-only rendering in a subpass with no depth/stencil attachment
  ** Active Pipeline Shader Stages
  *** Vertex Shader
  *** Fragment Shader
  ** Required: Fixed-Function Pipeline Stages
  *** slink:VkPipelineVertexInputStateCreateInfo
  *** slink:VkPipelineInputAssemblyStateCreateInfo
  *** slink:VkPipelineViewportStateCreateInfo
  *** slink:VkPipelineRasterizationStateCreateInfo
  *** slink:VkPipelineMultisampleStateCreateInfo
  *** slink:VkPipelineColorBlendStateCreateInfo
  * Rendering pipeline with tessellation and geometry shaders
  ** Active Pipeline Shader Stages
  *** Vertex Shader
  *** Tessellation Control Shader
  *** Tessellation Evaluation Shader
  *** Geometry Shader
  *** Fragment Shader
  ** Required: Fixed-Function Pipeline Stages
  *** slink:VkPipelineVertexInputStateCreateInfo
  *** slink:VkPipelineInputAssemblyStateCreateInfo
  *** slink:VkPipelineTessellationStateCreateInfo
  *** slink:VkPipelineViewportStateCreateInfo
  *** slink:VkPipelineRasterizationStateCreateInfo
  *** slink:VkPipelineMultisampleStateCreateInfo
  *** slink:VkPipelineDepthStencilStateCreateInfo
  *** slink:VkPipelineColorBlendStateCreateInfo


[[pipelines-destruction]]
== 管线的销毁

// refBegin vkDestroyPipeline Destroy a pipeline object

To destroy a graphics or compute pipeline, call:

include::../api/protos/vkDestroyPipeline.txt[]

  * pname:device is the logical device that destroys the pipeline.
  * pname:pipeline is the handle of the pipeline to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * All submitted commands that refer to pname:pipeline must: have completed
    execution
  * If sname:VkAllocationCallbacks were provided when pname:pipeline was
    created, a compatible set of callbacks must: be provided here
  * If no sname:VkAllocationCallbacks were provided when pname:pipeline was
    created, pname:pAllocator must: be `NULL`
****

include::../validity/protos/vkDestroyPipeline.txt[]


[[pipelines-multiple]]
== 多管线的创建

可传递一个数组的sname:VkGraphicsPipelineCreateInfo或者sname:VkComputePipelineCreateInfo到flink:vkCreateGraphicsPipelines 和
flink:vkCreateComputePipelines命令。应用程序可以在单个调用中成组的创建相似的管线，Vulkan实现被鼓励寻求在组创建的机会中重用资源。

当一个应用程序尝试在单个命令中创建多个管线，也还是有可能一些子集会创建失败。
这种情况下，在输出的pname:pPipelines对应入口点将被赋值为dlink:VK_NULL_HANDLE。
如果任何管线创建失败（例如，因为内存错误），ftext:vkCreate*Pipelines 命令将会返回一个错误码。
Vulkan实现将尝试创建所有的管线，那些失败的只返回dlink:VK_NULL_HANDLE 。


[[pipelines-pipeline-derivatives]]
== 管线衍生（Pipeline Derivatives）

一个管线衍生是父管线创建的一个子管线，父子管线拥有很大的共同性。
衍生管线的设计目标是用父管线当作起始点来创建管线会更加便宜，而且和父子管线之间切换或绑定会更加高效（CPU和GPU端都如此）。

设置stext:Vk*PipelineCreateInfo的flag为ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT来创建衍生管线。
如果这个标志位被设置了，那么pname:basePipelineHandle 或者pname:basePipelineIndex 成员之一必须有有效的handle/索引来表示父管线。
如果使用了pname:basePipelineHandle，那么父管线必须已经被创建好了。
如果使用了pname:basePipelineIndex，那么可在同一个命令中创建父管线。
对于pname:basePipelineHandle来说，dlink:VK_NULL_HANDLE表示一个无效的handle，
对于pname:basePipelineIndex来说， -1 表示一个无效的索引。
如果使用了pname:basePipelineIndex，基管线必须在数组中更早出现。
基管线必须带有ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT这个标志位被创建。


[[pipelines-cache]]
== 管线缓存

// refBegin VkPipelineCache Opaque handle to a pipeline cache object

管线缓存对象允许管线构造的结果可以在不同的管线之间，应用程序多次运行之间重用。
在不同管线之间重用是在创建多个关联管线时通过传递相同的管线缓存对象来实现的。
在应用程序多次运行之间重用是通过获取管线缓存内容、保存内容，在下一次运行时初始化管线之前使用它们。
管线缓存对象的内容是由Vulkan实现来管理的。
应用程序可以管理管线缓存对象消耗的主机端内存，控制从管线缓存对象中获取的数据的量的大小。

管线缓存对象通过sname:VkPipelineCache handles来表示：

include::../api/handles/VkPipelineCache.txt[]

// refEnd VkPipelineCache

// refBegin vkCreatePipelineCache Creates a new pipeline cache

To create pipeline cache objects, call:

include::../api/protos/vkCreatePipelineCache.txt[]

  * pname:device is the logical device that creates the pipeline cache
    object.
  * pname:pCreateInfo is a pointer to a sname:VkPipelineCacheCreateInfo
    structure that contains the initial parameters for the pipeline cache
    object.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pPipelineCache is a pointer to a sname:VkPipelineCache handle in
    which the resulting pipeline cache object is returned.

[NOTE]
.注意
====
应用程序可以使用pname:pAllocator来跟踪和管理管线缓存对象的主机端内存大小。
应用程序可以通过fname:vkGetPipelineCacheData来限制从管线缓存对象中获取数据总量的大小。
Vulkan实现不应该在内部限制添加到管线缓存对象的入口点的个数或者是主机端消耗的内存总量。
====

一旦创建完成，一个管线缓存可以被传递到fname:vkCreateGraphicsPipelines 和 fname:vkCreateComputePipelines命令。
如果传递到这些命令的一个管线缓存对象不是dlink:VK_NULL_HANDLE，Vulkan实现将查询是否可重用它并更新。
在这些命令内使用管线缓存对象是内部同步的，同一个管线缓存对象可以在多线程中同时使用。

[NOTE]
.注意
====
Vulkan实现应该尽量限制critical sections 代码段对缓存的访问，亦即，最好比
fname:vkCreateGraphicsPipelines 和fname:vkCreateComputePipelines命令的执行周期要短很多。
====

include::../validity/protos/vkCreatePipelineCache.txt[]

// refBegin VkPipelineCacheCreateInfo Structure specifying parameters of a newly created pipeline cache

The sname:VkPipelineCacheCreateInfo structure is defined as:

include::../api/structs/VkPipelineCacheCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags is reserved for future use.
  * pname:initialDataSize is the number of bytes in pname:pInitialData.
    If pname:initialDataSize is zero, the pipeline cache will initially be
    empty.
  * pname:pInitialData is a pointer to previously retrieved pipeline cache
    data.
    If the pipeline cache data is incompatible (as defined below) with the
    device, the pipeline cache will be initially empty.
    If pname:initialDataSize is zero, pname:pInitialData is ignored.

.Valid Usage
****
  * If pname:initialDataSize is not `0`, it must: be equal to the size of
    pname:pInitialData, as returned by fname:vkGetPipelineCacheData when
    pname:pInitialData was originally retrieved
  * If pname:initialDataSize is not `0`, pname:pInitialData must: have been
    retrieved from a previous call to fname:vkGetPipelineCacheData
****

include::../validity/structs/VkPipelineCacheCreateInfo.txt[]

// refBegin vkMergePipelineCaches Combine the data stores of pipeline caches

Pipeline cache objects can: be merged using the command:

include::../api/protos/vkMergePipelineCaches.txt[]

  * pname:device is the logical device that owns the pipeline cache objects.
  * pname:dstCache is the handle of the pipeline cache to merge results
    into.
  * pname:srcCacheCount is the length of the pname:pSrcCaches array.
  * pname:pSrcCaches is an array of pipeline cache handles, which will be
    merged into pname:dstCache.
    The previous contents of pname:dstCache are included after the merge.

[NOTE]
.注意
====
The details of the merge operation are implementation dependent, but
implementations should: merge the contents of the specified pipelines and
prune duplicate entries.
====

.Valid Usage
****
  * pname:dstCache must: not appear in the list of source caches
****

include::../validity/protos/vkMergePipelineCaches.txt[]

// refBegin vkGetPipelineCacheData Get the data store from a pipeline cache

Data can: be retrieved from a pipeline cache object using the command:

include::../api/protos/vkGetPipelineCacheData.txt[]

  * pname:device is the logical device that owns the pipeline cache.
  * pname:pipelineCache is the pipeline cache to retrieve data from.
  * pname:pDataSize is a pointer to a value related to the amount of data in
    the pipeline cache, as described below.
  * pname:pData is either `NULL` or a pointer to a buffer.

If pname:pData is `NULL`, then the maximum size of the data that can: be
retrieved from the pipeline cache, in bytes, is returned in pname:pDataSize.
Otherwise, pname:pDataSize must: point to a variable set by the user to the
size of the buffer, in bytes, pointed to by pname:pData, and on return the
variable is overwritten with the amount of data actually written to
pname:pData.

If pname:pDataSize is less than the maximum size that can: be retrieved by
the pipeline cache, at most pname:pDataSize bytes will be written to
pname:pData, and fname:vkGetPipelineCacheData will return
ename:VK_INCOMPLETE.
Any data written to pname:pData is valid and can: be provided as the
pname:pInitialData member of the sname:VkPipelineCacheCreateInfo structure
passed to fname:vkCreatePipelineCache.

Two calls to fname:vkGetPipelineCacheData with the same parameters must:
retrieve the same data unless a command that modifies the contents of the
cache is called between them.

[[pipelines-cache-header]]
Applications can: store the data retrieved from the pipeline cache, and use
these data, possibly in a future run of the application, to populate new
pipeline cache objects.
The results of pipeline compiles, however, may: depend on the vendor ID,
device ID, driver version, and other details of the device.
To enable applications to detect when previously retrieved data is
incompatible with the device, the initial bytes written to pname:pData must:
be a header consisting of the following members:

.Layout for pipeline cache header version ename:VK_PIPELINE_CACHE_HEADER_VERSION_ONE
[width="85%",cols="8%,21%,71%",options="header"]
|====
| Offset | Size | Meaning
| 0 | 4                    | length in bytes of the entire pipeline cache header
                             written as a stream of bytes, with the least
                             significant byte first
| 4 | 4                    | a elink:VkPipelineCacheHeaderVersion value
                             written as a stream of bytes, with the least
                             significant byte first
| 8 | 4                    | a vendor ID equal to
                             sname:VkPhysicalDeviceProperties::pname:vendorID
                             written as a stream of bytes, with the least
                             significant byte first
| 12 | 4                    | a device ID equal to
                             sname:VkPhysicalDeviceProperties::pname:deviceID
                             written as a stream of bytes, with the least
                             significant byte first
| 16 | ename:VK_UUID_SIZE   | a pipeline cache ID equal to
                             sname:VkPhysicalDeviceProperties::pname:pipelineCacheUUID
|====

The first four bytes encode the length of the entire pipeline header, in
bytes.
This value includes all fields in the header including the pipeline cache
version field and the size of the length field.

// refBegin VkPipelineCacheHeaderVersion Encode pipeline cache version

The next four bytes encode the pipeline cache version.
This field is interpreted as a elink:VkPipelineCacheHeaderVersion value, and
must: have one of the following values:

include::../api/enums/VkPipelineCacheHeaderVersion.txt[]

A consumer of the pipeline cache should: use the cache version to interpret
the remainder of the cache header.

// refEnd VkPipelineCacheHeaderVersion vkCreatePipelineCache vkGetPipelineCacheData

If pname:pDataSize is less than what is necessary to store this header,
nothing will be written to pname:pData and zero will be written to
pname:pDataSize.

include::../validity/protos/vkGetPipelineCacheData.txt[]

// refBegin vkDestroyPipelineCache Destroy a pipeline cache object

To destroy a pipeline cache, call:

include::../api/protos/vkDestroyPipelineCache.txt[]

  * pname:device is the logical device that destroys the pipeline cache
    object.
  * pname:pipelineCache is the handle of the pipeline cache to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * If sname:VkAllocationCallbacks were provided when pname:pipelineCache
    was created, a compatible set of callbacks must: be provided here
  * If no sname:VkAllocationCallbacks were provided when pname:pipelineCache
    was created, pname:pAllocator must: be `NULL`
****

include::../validity/protos/vkDestroyPipelineCache.txt[]


[[pipelines-specialization-constants]]
== 特化常量（Specialization Constants）
特化常量是一种机制，在SPIR-V模块中保有sname:VkPipeline被创建时指定的常量。
这允许SPIR-V模块保有应用程序运行过程中通过Vulkan API可更改的常量。

[NOTE]
.注意
====
计算着色器需要在运行时改变本地工作组大小时，特化常量很有用。
====

sname:VkPipelineShaderStageCreateInfo的每一个实例包含一个参数pname:pSpecializationInfo，
可以是 `NULL` ，表示没有特化常量，或者指向sname:VkSpecializationInfo。


// refBegin VkSpecializationInfo Structure specifying specialization info

The sname:VkSpecializationInfo structure is defined as:

include::../api/structs/VkSpecializationInfo.txt[]

  * pname:mapEntryCount is the number of entries in the pname:pMapEntries
    array.
  * pname:pMapEntries is a pointer to an array of
    sname:VkSpecializationMapEntry which maps constant IDs to offsets in
    pname:pData.
  * pname:dataSize is the byte size of the pname:pData buffer.
  * pname:pData contains the actual constant values to specialize with.

pname:pMapEntries points to a structure of type
slink:VkSpecializationMapEntry.

.Valid Usage
****
  * The pname:offset member of any given element of pname:pMapEntries must:
    be less than pname:dataSize
  * For any given element of pname:pMapEntries, pname:size must: be less
    than or equal to pname:dataSize minus pname:offset
  * If pname:mapEntryCount is not `0`, pname:pMapEntries must: be a pointer
    to an array of pname:mapEntryCount valid sname:VkSpecializationMapEntry
    structures
****

include::../validity/structs/VkSpecializationInfo.txt[]

// refBegin VkSpecializationMapEntry Structure specifying a specialization map entry

The sname:VkSpecializationMapEntry structure is defined as:

include::../api/structs/VkSpecializationMapEntry.txt[]

  * pname:constantID is the ID of the specialization constant in SPIR-V.
  * pname:offset is the byte offset of the specialization constant value
    within the supplied data buffer.
  * pname:size is the byte size of the specialization constant value within
    the supplied data buffer.

If a pname:constantID value is not a specialization constant ID used in the
shader, that map entry does not affect the behavior of the pipeline.

.Valid Usage
****
  * For a pname:constantID specialization constant declared in a shader,
    pname:size must: match the byte size of the pname:constantID.
    If the specialization constant is of type code:boolean, pname:size must:
    be the byte size of basetype:VkBool32
****

include::../validity/structs/VkSpecializationMapEntry.txt[]

In human readable SPIR-V:

[source,glsl]
---------------------------------------------------
OpDecorate %x SpecId 13 ; decorate .x component of WorkgroupSize with ID 13
OpDecorate %y SpecId 42 ; decorate .y component of WorkgroupSize with ID 42
OpDecorate %z SpecId 3  ; decorate .z component of WorkgroupSize with ID 3
OpDecorate %wgsize BuiltIn WorkgroupSize ; decorate WorkgroupSize onto constant
%i32 = OpTypeInt 32 0 ; declare an unsigned 32-bit type
%uvec3 = OpTypeVector %i32 3 ; declare a 3 element vector type of unsigned 32-bit
%x = OpSpecConstant %i32 1 ; declare the .x component of WorkgroupSize
%y = OpSpecConstant %i32 1 ; declare the .y component of WorkgroupSize
%z = OpSpecConstant %i32 1 ; declare the .z component of WorkgroupSize
%wgsize = OpSpecConstantComposite %uvec3 %x %y %z ; declare WorkgroupSize
---------------------------------------------------

From the above we have three specialization constants, one for each of the
x, y & z elements of the WorkgroupSize vector.

Now to specialize the above via the specialization constants mechanism:

[source,c++]
---------------------------------------------------
const VkSpecializationMapEntry entries[] =
{
    {
        13,                             // constantID
        0 * sizeof(uint32_t),           // offset
        sizeof(uint32_t)                // size
    },
    {
        42,                             // constantID
        1 * sizeof(uint32_t),           // offset
        sizeof(uint32_t)                // size
    },
    {
        3,                              // constantID
        2 * sizeof(uint32_t),           // offset
        sizeof(uint32_t)                // size
    }
};

const uint32_t data[] = { 16, 8, 4 }; // our workgroup size is 16x8x4

const VkSpecializationInfo info =
{
    3,                                  // mapEntryCount
    entries,                            // pMapEntries
    3 * sizeof(uint32_t),               // dataSize
    data,                               // pData
};
---------------------------------------------------

Then when calling flink:vkCreateComputePipelines, and passing the
sname:VkSpecializationInfo we defined as the pname:pSpecializationInfo
parameter of slink:VkPipelineShaderStageCreateInfo, we will create a compute
pipeline with the runtime specified local workgroup size.

Another example would be that an application has a SPIR-V module that has
some platform-dependent constants they wish to use.

In human readable SPIR-V:

// [source,glsl]
[source,glsl]
---------------------------------------------------
OpDecorate %1 SpecId 0  ; decorate our signed 32-bit integer constant
OpDecorate %2 SpecId 12 ; decorate our 32-bit floating-point constant
%i32 = OpTypeInt 32 1   ; declare a signed 32-bit type
%float = OpTypeFloat 32 ; declare a 32-bit floating-point type
%1 = OpSpecConstant %i32 -1 ; some signed 32-bit integer constant
%2 = OpSpecConstant %float 0.5 ; some 32-bit floating-point constant
---------------------------------------------------

From the above we have two specialization constants, one is a signed 32-bit
integer and the second is a 32-bit floating-point.

Now to specialize the above via the specialization constants mechanism:

[source,c++]
---------------------------------------------------
struct SpecializationData {
    int32_t data0;
    float data1;
};

const VkSpecializationMapEntry entries[] =
{
    {
        0,                                    // constantID
        offsetof(SpecializationData, data0),  // offset
        sizeof(SpecializationData::data0)     // size
    },
    {
        12,                                   // constantID
        offsetof(SpecializationData, data1),  // offset
        sizeof(SpecializationData::data1)     // size
    }
};

SpecializationData data;
data.data0 = -42;    // set the data for the 32-bit integer
data.data1 = 42.0f;  // set the data for the 32-bit floating-point

const VkSpecializationInfo info =
{
    2,                                  // mapEntryCount
    entries,                            // pMapEntries
    sizeof(data),                       // dataSize
    &data,                              // pData
};
---------------------------------------------------

It is legal for a SPIR-V module with specializations to be compiled into a
pipeline where no specialization info was provided.
SPIR-V specialization constants contain default values such that if a
specialization is not provided, the default value will be used.
In the examples above, it would be valid for an application to only
specialize some of the specialization constants within the SPIR-V module,
and let the other constants use their default values encoded within the
OpSpecConstant declarations.


[[pipelines-binding]]
== 管线的绑定

// refBegin vkCmdBindPipeline Bind a pipeline object to a command buffer

一旦管线被创建完成，可以使用一个命令把它绑定到命令缓冲区：

include::../api/protos/vkCmdBindPipeline.txt[]

  * pname:commandBuffer is the command buffer that the pipeline will be
    bound to.
  * pname:pipelineBindPoint specifies the bind point, and must: have one of
    the values
+
--
// refBegin VkPipelineBindPoint Specify the bind point of a pipeline object to a command buffer
include::../api/enums/VkPipelineBindPoint.txt[]
--
+
specifying whether pname:pipeline will be bound as a compute
(ename:VK_PIPELINE_BIND_POINT_COMPUTE) or graphics
(ename:VK_PIPELINE_BIND_POINT_GRAPHICS) pipeline.
There are separate bind points for each of graphics and compute, so binding
one does not disturb the other.
+
  * pname:pipeline is the pipeline to be bound.

绑定完成后，该绑定影响命令缓冲区中稍后的图形和计算命令，直到新的管线被绑定到绑定点。
The pipeline bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE controls the
behavior of flink:vkCmdDispatch and flink:vkCmdDispatchIndirect.
The pipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS controls the
behavior of flink:vkCmdDraw, flink:vkCmdDrawIndexed,
flink:vkCmdDrawIndirect, and flink:vkCmdDrawIndexedIndirect.
No other commands are affected by the pipeline state.

.Valid Usage
****
  * If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_COMPUTE, the
    sname:VkCommandPool that pname:commandBuffer was allocated from must:
    support compute operations
  * If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_GRAPHICS, the
    sname:VkCommandPool that pname:commandBuffer was allocated from must:
    support graphics operations
  * If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_COMPUTE,
    pname:pipeline must: be a compute pipeline
  * If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_GRAPHICS,
    pname:pipeline must: be a graphics pipeline
  * If the <<features-features-variableMultisampleRate,variable multisample
    rate>> feature is not supported, pname:pipeline is a graphics pipeline,
    the current subpass has no attachments, and this is not the first call
    to this function with a graphics pipeline after transitioning to the
    current subpass, then the sample count specified by this pipeline must:
    match that set in the previous pipeline
****

include::../validity/protos/vkCmdBindPipeline.txt[]

