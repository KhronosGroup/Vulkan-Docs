// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[interfaces]]
= 着色器接口

当创建了一个管线，在对应的 stext:Vk*PipelineCreateInfo数据结构中指定的着色器集合被隐式的链接到一系列不同的接口。

  * <<interfaces-iointerfaces, 着色器输入输出接口>>
  * <<interfaces-vertexinput, 顶点输入接口>>
  * <<interfaces-fragmentoutput, 片元输出接口>>
  * <<interfaces-inputattachment, 片元输入附件接口>>
  * <<interfaces-resources, 着色器资源接口>>

接口定义使用下列SPIR-V 修饰符：  

  * code:DescriptorSet 和 code:Binding
  * code:Location, code:Component, and code:Index
  * code:Flat, code:NoPerspective, code:Centroid, and code:Sample
  * code:Block and code:BufferBlock
  * code:InputAttachmentIndex
  * code:Offset, code:ArrayStride, and code:MatrixStride
  * code:BuiltIn

本规范文档描述了Vulkan 正确的使用这些修饰符。

[[interfaces-iointerfaces]]
== 着色器输入输出接口

当一个管线内有多个阶段时，一个阶段的输出和下一个阶段的输入形成了一个接口。
当这个接口涉及到着色器时，着色器输出和下一个阶段的输入相匹配，着色器输入和上一个阶段的输出相匹配。

有两类变量可以在着色器阶段间匹配：内置变量，用户自定义变量。
每一类都有不同的匹配条件。通常，当不同阶段之间的是非着色器阶段，用户自定义的变量基本上是内置变量，在着色器
阶段之间形成接口。

形成输入、输出 _接口_ 的变量被当作 code:OpEntryPoint 指令的操作对象，
在SPIR-V模块中各以code:Input 或 code:Output 存储描述符所修饰。

一个着色器阶段的code:Output 变量在着色器写入它们或者使用code:Initializer来声明操作对象之前，它们的值是未知的。


[[interfaces-iointerfaces-builtin]]
=== 内置的接口Block

着色器<<interfaces-builtin-variables,  内置>> 变量须满足以下定义 _内置接口block_ 要求：

  * 被显式的声明（并没有隐式的内置变量）
  * 被 code:BuiltIn 修饰，
  * 形成如<<interfaces-builtin-variables,Built-in Variables>> 一节所描述的变量类型
  * 在顶层成员都是内置类型的block中被声明。

如果在这样的block中被声明了，内置变量只参与接口匹配。
它们不能有 code:Location 或 code:Component修饰符。
在每一个着色器接口内，不能有多个内置接口block。


[[interfaces-iointerfaces-user]]
=== 用户自定义变量接口

被以code:Input 或 code:Output 存储修饰符列举的code:OpEntryPoint 变量形成了 _用户自定义变量接口_ 。
这些变量必须以code:Location 修饰符指定，也可以被 code:Component 修饰符指定。


[[interfaces-iointerfaces-matching]]
=== 接口匹配

一个用户自定义输出变量被认为与下一个阶段的输入变量匹配，若两个变量被相同code:Location 和 code:Component
描述符修饰，并类型匹配，除了<<shaders-interpolation-decorations,interpolation decorations>> 没有要求被匹配。
为了做到接口匹配，没有以code:Component修饰的变量被认为有以 值为0的code:Component 来修饰。


Variables or block members declared as structures are considered to match in
type if and only if the structure members match in type, decoration, number,
and declaration order.
Variables or block members declared as arrays are considered to match in
type only if both declarations specify the same element type and size.

Tessellation control shader per-vertex output variables and blocks, and
tessellation control, tessellation evaluation, and geometry shader
per-vertex input variables and blocks are required to be declared as arrays,
with each element representing input or output values for a single vertex of
a multi-vertex primitive.
For the purposes of interface matching, the outermost array dimension of
such variables and blocks is ignored.

At an interface between two non-fragment shader stages, the built-in
interface block must: match exactly, as described above.
At an interface involving the fragment shader inputs, the presence or
absence of any built-in output does not affect the interface matching.

At an interface between two shader stages, the user-defined variable
interface must: match exactly, as described above.

Any input value to a shader stage is well-defined as long as the preceding
stages writes to a matching output, as described above.

Additionally, scalar and vector inputs are well-defined if there is a
corresponding output satisfying all of the following conditions:

  * the input and output match exactly in decoration,
  * the output is a vector with the same basic type and has at least as many
    components as the input, and
  * the common component type of the input and output is 32-bit integer or
    floating-point (64-bit component types are excluded).

In this case, the components of the input will be taken from the first
components of the output, and any extra components of the output will be
ignored.


[[interfaces-iointerfaces-locations]]
=== Location Assignment

This section describes how many locations are consumed by a given type.
As mentioned above, geometry shader inputs, tessellation control shader
inputs and outputs, and tessellation evaluation inputs all have an
additional level of arrayness relative to other shader inputs and outputs.
This outer array level is removed from the type before considering how many
locations the type consumes.

The code:Location value specifies an interface slot comprised of a 32-bit
four-component vector conveyed between stages.
The code:Component specifies
<<interfaces-iointerfaces-components,components>> within these vector
locations.
Only types with widths of 32 or 64 are supported in shader interfaces.

Inputs and outputs of the following types consume a single interface
location:

  * 32-bit scalar and vector types, and
  * 64-bit scalar and 2-component vector types.

64-bit three- and four-component vectors consume two consecutive locations.

If a declared input or output is an array of size _n_ and each element takes
_m_ locations, it will be assigned _m_ {times} _n_ consecutive locations
starting with the location specified.

If the declared input or output is an _n_ {times} _m_ 32- or 64-bit matrix,
it will be assigned multiple locations starting with the location specified.
The number of locations assigned for each matrix will be the same as for an
_n_-element array of _m_-component vectors.

The layout of a structure type used as an code:Input or code:Output depends
on whether it is also a code:Block (i.e. has a code:Block decoration).

If it is a not a code:Block, then the structure type must: have a
code:Location decoration.
Its members are assigned consecutive locations in their declaration order,
with the first member assigned to the location specified for the structure
type.
The members, and their nested types, must: not themselves have code:Location
decorations.

If the structure type is a code:Block but without a code:Location, then each
of its members must: have a code:Location decoration.
If it is a code:Block with a code:Location decoration, then its members are
assigned consecutive locations in declaration order, starting from the first
member which is initially assigned the location specified for the
code:Block.
Any member with its own code:Location decoration is assigned that location.
Each remaining member is assigned the location after the immediately
preceding member in declaration order.

The locations consumed by block and structure members are determined by
applying the rules above in a depth-first traversal of the instantiated
members as though the structure or block member were declared as an input or
output variable of the same type.

Any two inputs listed as operands on the same code:OpEntryPoint must: not be
assigned the same location, either explicitly or implicitly.
Any two outputs listed as operands on the same code:OpEntryPoint must: not
be assigned the same location, either explicitly or implicitly.

The number of input and output locations available for a shader input or
output interface are limited, and dependent on the shader stage as described
in <<interfaces-iointerfaces-limits>>.


[[interfaces-iointerfaces-limits]]
.Shader Input and Output Locations
[width="90%",cols="<6,<13",options="header"]
|====
| Shader Interface              | Locations Available
| vertex input                  | pname:maxVertexInputAttributes
| vertex output                 | pname:maxVertexOutputComponents / 4
| tessellation control input    | pname:maxTessellationControlPerVertexInputComponents / 4
| tessellation control output   | pname:maxTessellationControlPerVertexOutputComponents / 4
| tessellation evaluation input | pname:maxTessellationEvaluationInputComponents / 4
| tessellation evaluation output| pname:maxTessellationEvaluationOutputComponents / 4
| geometry input                | pname:maxGeometryInputComponents / 4
| geometry output               | pname:maxGeometryOutputComponents / 4
| fragment input                | pname:maxFragmentInputComponents / 4
| fragment output               | pname:maxFragmentOutputAttachments
|====


[[interfaces-iointerfaces-components]]
=== Component Assignment

The code:Component decoration allows the code:Location to be more finely
specified for scalars and vectors, down to the individual components within
a location that are consumed.
The components within a location are 0, 1, 2, and 3.
A variable or block member starting at component N will consume components
N, N+1, N+2, ...
up through its size.
For single precision types, it is invalid if this sequence of components
gets larger than 3.
A scalar 64-bit type will consume two of these components in sequence, and a
two-component 64-bit vector type will consume all four components available
within a location.
A three- or four-component 64-bit vector type must: not specify a
code:Component decoration.
A three-component 64-bit vector type will consume all four components of the
first location and components 0 and 1 of the second location.
This leaves components 2 and 3 available for other component-qualified
declarations.

A scalar or two-component 64-bit data type must: not specify a
code:Component decoration of 1 or 3.
A code:Component decoration must: not be specified for any type that is not
a scalar or vector.


[[interfaces-vertexinput]]
== Vertex Input Interface

When the vertex stage is present in a pipeline, the vertex shader input
variables form an interface with the vertex input attributes.
The vertex shader input variables are matched by the code:Location and
code:Component decorations to the vertex input attributes specified in the
pname:pVertexInputState member of the slink:VkGraphicsPipelineCreateInfo
structure.

The vertex shader input variables listed by code:OpEntryPoint with the
code:Input storage class form the _vertex input interface_.
These variables must: be identified with a code:Location decoration and can:
also be identified with a code:Component decoration.

For the purposes of interface matching: variables declared without a
code:Component decoration are considered to have a code:Component decoration
of zero.
The number of available vertex input locations is given by the
pname:maxVertexInputAttributes member of the sname:VkPhysicalDeviceLimits
structure.

See <<fxvertex-attrib-location>> for details.

All vertex shader inputs declared as above must: have a corresponding
attribute and binding in the pipeline.


[[interfaces-fragmentoutput]]
== Fragment Output Interface

When the fragment stage is present in a pipeline, the fragment shader
outputs form an interface with the output attachments of the current
subpass.
The fragment shader output variables are matched by the code:Location and
code:Component decorations to the color attachments specified in the
pname:pColorAttachments array of the slink:VkSubpassDescription structure
that describes the subpass that the fragment shader is executed in.

The fragment shader output variables listed by code:OpEntryPoint with the
code:Output storage class form the _fragment output interface_.
These variables must: be identified with a code:Location decoration.
They can: also be identified with a code:Component decoration and/or an
code:Index decoration.
For the purposes of interface matching: variables declared without a
code:Component decoration are considered to have a code:Component decoration
of zero, and variables declared without an code:Index decoration are
considered to have an code:Index decoration of zero.

A fragment shader output variable identified with a code:Location decoration
of _i_ is directed to the color attachment indicated by
pname:pColorAttachments[_i_], after passing through the blending unit as
described in <<framebuffer-blending>>, if enabled.
Locations are consumed as described in
<<interfaces-iointerfaces-locations,Location Assignment>>.
The number of available fragment output locations is given by the
pname:maxFragmentOutputAttachments member of the
sname:VkPhysicalDeviceLimits structure.

Components of the output variables are assigned as described in
<<interfaces-iointerfaces-components,Component Assignment>>.
Output components identified as 0, 1, 2, and 3 will be directed to the R, G,
B, and A inputs to the blending unit, respectively, or to the output
attachment if blending is disabled.
If two variables are placed within the same location, they must: have the
same underlying type (floating-point or integer).
The input to blending or color attachment writes is undefined for components
which do not correspond to a fragment shader output.

Fragment outputs identified with an code:Index of zero are directed to the
first input of the blending unit associated with the corresponding
code:Location.
Outputs identified with an code:Index of one are directed to the second
input of the corresponding blending unit.

No _component aliasing_ of output variables is allowed, that is there must:
not be two output variables which have the same location, component, and
index, either explicitly declared or implied.

Output values written by a fragment shader must: be declared with either
code:OpTypeFloat or code:OpTypeInt, and a Width of 32.
Composites of these types are also permitted.
If the color attachment has a signed or unsigned normalized fixed-point
format, color values are assumed to be floating-point and are converted to
fixed-point as described in <<fundamentals-fixedfpconv>>; otherwise no type
conversion is applied.
If the type of the values written by the fragment shader do not match the
format of the corresponding color attachment, the result is undefined for
those components.


[[interfaces-inputattachment]]
== Fragment Input Attachment Interface

When a fragment stage is present in a pipeline, the fragment shader subpass
inputs form an interface with the input attachments of the current subpass.
The fragment shader subpass input variables are matched by
code:InputAttachmentIndex decorations to the input attachments specified in
the pname:pInputAttachments array of the slink:VkSubpassDescription
structure that describes the subpass that the fragment shader is executed
in.

The fragment shader subpass input variables with the code:UniformConstant
storage class and a decoration of code:InputAttachmentIndex that are
statically used by code:OpEntryPoint form the _fragment input attachment
interface_.
These variables must: be declared with a type of code:OpTypeImage, a
code:Dim operand of code:SubpassData, and a code:Sampled operand of 2.

A subpass input variable identified with an code:InputAttachmentIndex
decoration of _i_ reads from the input attachment indicated by
pname:pInputAttachments[_i_] member of sname:VkSubpassDescription.
If the subpass input variable is declared as an array of size N, it consumes
N consecutive input attachments, starting with the index specified.
There must: not be more than one input variable with the same
code:InputAttachmentIndex whether explicitly declared or implied by an array
declaration.
The number of available input attachment indices is given by the
pname:maxPerStageDescriptorInputAttachments member of the
sname:VkPhysicalDeviceLimits structure.

Variables identified with the code:InputAttachmentIndex must: only be used
by a fragment stage.
The basic data type (floating-point, integer, unsigned integer) of the
subpass input must: match the basic format of the corresponding input
attachment, or the values of subpass loads from these variables are
undefined.

See <<descriptorsets-inputattachment>> for more details.


[[interfaces-resources]]
== Shader Resource Interface

When a shader stage accesses buffer or image resources, as described in the
<<descriptorsets,Resource Descriptors>> section, the shader resource
variables must: be matched with the <<descriptorsets-pipelinelayout,pipeline
layout>> that is provided at pipeline creation time.

The set of shader resources that form the _shader resource interface_ for a
stage are the variables statically used by code:OpEntryPoint with the
storage class of code:Uniform, code:UniformConstant, or code:PushConstant.
For the fragment shader, this includes the <<interfaces-inputattachment,
fragment input attachment interface>>.

The shader resource interface consists of two sub-interfaces: the push
constant interface and the descriptor set interface.


[[interfaces-resources-pushconst]]
=== Push Constant Interface

The shader variables defined with a storage class of code:PushConstant that
are statically used by the shader entry points for the pipeline define the
_push constant interface_.
They must: be:

  * typed as code:OpTypeStruct,
  * identified with a code:Block decoration, and
  * laid out explicitly using the code:Offset, code:ArrayStride, and
    code:MatrixStride decorations as specified in
    <<interfaces-resources-layout,Offset and Stride Assignment>>.

There must: be no more than one push constant block statically used per
shader entry point.

Each variable in a push constant block must: be placed at an code:Offset
such that the entire constant value is entirely contained within the
slink:VkPushConstantRange for each code:OpEntryPoint that uses it, and the
pname:stageFlags for that range must: specify the appropriate
elink:VkShaderStageFlagBits for that stage.
The code:Offset decoration for any variable in a push constant block must:
not cause the space required for that variable to extend outside the range
[eq]#[0, pname:maxPushConstantsSize)#.

Any variable in a push constant block that is declared as an array must:
only be accessed with _dynamically uniform_ indices.


[[interfaces-resources-descset]]
=== Descriptor Set Interface

The _descriptor set interface_ is comprised of the shader variables with the
storage class of code:Uniform or code:UniformConstant (including the
variables in the <<interfaces-inputattachment,fragment input attachment
interface>>) that are statically used by the shader entry points for the
pipeline.

These variables must: have code:DescriptorSet and code:Binding decorations
specified, which are assigned and matched with the
sname:VkDescriptorSetLayout objects in the pipeline layout as described in
<<interfaces-resources-setandbinding,DescriptorSet and Binding Assignment>>.

Variables identified with the code:UniformConstant storage class are used
only as handles to refer to opaque resources.
Such variables must: be typed as code:OpTypeImage, code:OpTypeSampler,
code:OpTypeSampledImage, or arrays of only these types.
Variables of type code:OpTypeImage must: have a code:Sampled operand of 1
(sampled image) or 2 (storage image).

Any array of these types must: only be indexed with constant integral
expressions, except under the following conditions:

  * For arrays of code:OpTypeImage variables with code:Sampled operand of 2,
    if the pname:shaderStorageImageArrayDynamicIndexing feature is enabled
    and the shader module declares the code:StorageImageArrayDynamicIndexing
    capability, the array must: only be indexed by dynamically uniform
    expressions.
  * For arrays of code:OpTypeSampler, code:OpTypeSampledImage variables, or
    code:OpTypeImage variables with code:Sampled operand of 1, if the
    pname:shaderSampledImageArrayDynamicIndexing feature is enabled and the
    shader module declares the code:SampledImageArrayDynamicIndexing
    capability, the array must: only be indexed by dynamically uniform
    expressions.

The code:Sampled code:Type of an code:OpTypeImage declaration must: match
the same basic data type as the corresponding resource, or the values
obtained by reading or sampling from this image are undefined.

The code:Image code:Format of an code:OpTypeImage declaration must: not be
*Unknown*, for variables which are used for code:OpImageRead or
code:OpImageWrite operations, except under the following conditions:

  * For code:OpImageWrite, if the pname:shaderStorageImageWriteWithoutFormat
    feature is enabled and the shader module declares the
    code:StorageImageWriteWithoutFormat capability.
  * For code:OpImageRead, if the pname:shaderStorageImageReadWithoutFormat
    feature is enabled and the shader module declares the
    code:StorageImageReadWithoutFormat capability.

Variables identified with the code:Uniform storage class are used to access
transparent buffer backed resources.
Such variables must: be:

  * typed as code:OpTypeStruct, or arrays of only this type,
  * identified with a code:Block or code:BufferBlock decoration, and
  * laid out explicitly using the code:Offset, code:ArrayStride, and
    code:MatrixStride decorations as specified in
    <<interfaces-resources-layout,Offset and Stride Assignment>>.

Any array of these types must: only be indexed with constant integral
expressions, except under the following conditions.

  * For arrays of code:Block variables, if the
    pname:shaderUniformBufferArrayDynamicIndexing feature is enabled and the
    shader module declares the code:UniformBufferArrayDynamicIndexing
    capability, the array must: only be indexed by dynamically uniform
    expressions.
  * For arrays of code:BufferBlock variables, if the
    pname:shaderStorageBufferArrayDynamicIndexing feature is enabled and the
    shader module declares the code:StorageBufferArrayDynamicIndexing
    capability, the array must: only be indexed by dynamically uniform
    expressions.

The code:Offset decoration for any variable in a code:Block must: not cause
the space required for that variable to extend outside the range [eq]#[0,
pname:maxUniformBufferRange)#.
The code:Offset decoration for any variable in a code:BufferBlock must: not
cause the space required for that variable to extend outside the range
[eq]#[0, pname:maxStorageBufferRange)#.

Variables identified with a storage class of code:UniformConstant and a
decoration of code:InputAttachmentIndex must: be declared as described in
<<interfaces-inputattachment,Fragment Input Attachment Interface>>.

Each shader variable declaration must: refer to the same type of resource as
is indicated by the pname:descriptorType.
See <<interfaces-resources-correspondence,Shader Resource and Descriptor
Type Correspondence>> for the relationship between shader declarations and
descriptor types.

[[interfaces-resources-correspondence]]
.Shader Resource and Descriptor Type Correspondence
[width="90%",cols="<1,<2",options="header"]
|====
| Resource type          | Descriptor Type
| sampler                | ename:VK_DESCRIPTOR_TYPE_SAMPLER
| sampled image          | ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
| storage image          | ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE
| combined image sampler | ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
| uniform texel buffer   | ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
| storage texel buffer   | ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER
| uniform buffer         | ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER +
                           ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC
| storage buffer         | ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER +
                           ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC
| input attachment       | ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT
|====

.Shader Resource and Storage Class Correspondence
[width="100%",cols="<21%,<22%,<27%,<30%",options="header"]
|====
| Resource type   | Storage Class | Type | Decoration(s)^1^
| sampler
        | code:UniformConstant | code:OpTypeSampler |
| sampled image
        | code:UniformConstant | code:OpTypeImage (code:Sampled=1)|
| storage image
        | code:UniformConstant | code:OpTypeImage (code:Sampled=2) |
| combined image sampler
        | code:UniformConstant | code:OpTypeSampledImage |
| uniform texel buffer
        | code:UniformConstant | code:OpTypeImage (code:Dim=code:Buffer, code:Sampled=1) |
| storage texel buffer
        | code:UniformConstant | code:OpTypeImage (code:Dim=code:Buffer, code:Sampled=2) |
| uniform buffer
        | code:Uniform         | code:OpTypeStruct
        | code:Block, code:Offset, (code:ArrayStride), (code:MatrixStride)
| storage buffer
        | code:Uniform         | code:OpTypeStruct
        | code:BufferBlock, code:Offset, (code:ArrayStride), (code:MatrixStride)
| input attachment
        | code:UniformConstant | code:OpTypeImage (code:Dim=code:SubpassData, code:Sampled=2)
        | code:InputAttachmentIndex
|====
1:: in addition to code:DescriptorSet and code:Binding


[[interfaces-resources-setandbinding]]
=== DescriptorSet and Binding Assignment

A variable identified with a code:DescriptorSet decoration of [eq]#s# and a
code:Binding decoration of [eq]#b# indicates that this variable is
associated with the slink:VkDescriptorSetLayoutBinding that has a
pname:binding equal to [eq]#b# in pname:pSetLayouts[_s_] that was specified
in slink:VkPipelineLayoutCreateInfo.

The range of descriptor sets is between zero and
pname:maxBoundDescriptorSets minus one.
If a descriptor set value is statically used by an entry point there must:
be an associated pname:pSetLayout in the corresponding pipeline layout as
described in <<descriptorsets-pipelinelayout-consistency,Pipeline Layouts
consistency>>.

If the code:Binding decoration is used with an array, the entire array is
identified with that binding value.
The size of the array declaration must: be no larger than the
pname:descriptorCount of that sname:VkDescriptorSetLayoutBinding.
The index of each element of the array is referred to as the _arrayElement_.
For the purposes of interface matching and descriptor set
<<descriptorsets-updates,operations>>, if a resource variable is not an
array, it is treated as if it has an arrayElement of zero.

The binding can: be any 32-bit unsigned integer value, as described in
<<descriptorsets-setlayout>>.
Each descriptor set has its own binding name space.

There is a limit on the number of resources of each type that can: be
accessed by a pipeline stage as shown in
<<interfaces-resources-limits,Shader Resource Limits>>.
The "`Resources Per Stage`" column gives the limit on the number each type
of resource that can: be statically used for an entry point in any given
stage in a pipeline.
The "`Resource Types`" column lists which resource types are counted against
the limit.
Some resource types count against multiple limits.

If multiple entry points in the same pipeline refer to the same set and
binding, all variable definitions with that code:DescriptorSet and
code:Binding must: have the same basic type.

Not all descriptor sets and bindings specified in a pipeline layout need to
be used in a particular shader stage or pipeline, but if a
code:DescriptorSet and code:Binding decoration is specified for a variable
that is statically used in that shader there must: be a pipeline layout
entry identified with that descriptor set and pname:binding and the
corresponding pname:stageFlags must: specify the appropriate
elink:VkShaderStageFlagBits for that stage.


[[interfaces-resources-limits]]
.Shader Resource Limits
[width="80%",cols="<35,<23",options="header"]
|====
| Resources per Stage                   | Resource Types
.2+<.^| pname:maxPerStageDescriptorSamplers
            | sampler           | combined image sampler
.3+<.^| pname:maxPerStageDescriptorSampledImages
            | sampled image     | combined image sampler | uniform texel buffer
.2+<.^| pname:maxPerStageDescriptorStorageImages
            | storage image     | storage texel buffer
.2+<.^| pname:maxPerStageDescriptorUniformBuffers
            | uniform buffer    | uniform buffer dynamic
.2+<.^| pname:maxPerStageDescriptorStorageBuffers
            | storage buffer    | storage buffer dynamic
| pname:maxPerStageDescriptorInputAttachments
            | input attachment^1^
|====

1::
    Input attachments can: only be used in the fragment shader stage


[[interfaces-resources-layout]]
=== Offset and Stride Assignment

All variables with a storage class of code:PushConstant or code:Uniform
must: be explicitly laid out using the code:Offset, code:ArrayStride, and
code:MatrixStride decorations.
There are two different layouts requirements depending on the specific
resources.

[[interfaces-resources-layout-std140]]
*Standard Uniform Buffer Layout*

Member variables of an code:OpTypeStruct with storage class of code:Uniform
and a decoration of code:Block (uniform buffers) must: be laid out according
to the following rules.

  * The code:Offset Decoration must: be a multiple of its base alignment,
    computed recursively as follows:
  ** a scalar of size [eq]#N# has a base alignment of [eq]#N#
  ** a two-component vector, with components of size [eq]#N#, has a base
     alignment of [eq]#2 N#
  ** a three- or four-component vector, with components of size [eq]#N#, has
     a base alignment of [eq]#4 N#
  ** an array has a base alignment equal to the base alignment of its
     element type, rounded up to a multiple of [eq]#16#
  ** a structure has a base alignment equal to the largest base alignment of
     any of its members, rounded up to a multiple of [eq]#16#
  ** a row-major matrix of [eq]#C# columns has a base alignment equal to the
     base alignment of vector of [eq]#C# matrix components
  ** a column-major matrix has a base alignment equal to the base alignment
     of the matrix column type
  * Any code:ArrayStride or code:MatrixStride decoration must: be an integer
    multiple of the base alignment of the array or matrix from above.
  * The code:Offset Decoration of a member must: not place it between the
    end of a structure or an array and the next multiple of the base
    alignment of that structure or array.
  * The numeric order of code:Offset Decorations need not follow member
    declaration order.

[NOTE]
.Note
====
The *std140 layout* in GLSL satisfies these rules.
====

[[interfaces-resources-layout-std430]]
*Standard Storage Buffer Layout*

Member variables of an code:OpTypeStruct with a storage class of
code:PushConstant (push constants), or a storage class of code:Uniform with
a decoration of code:BufferBlock (storage buffers) must: be laid out as
<<interfaces-resources-layout-std140,above>>, except for array and structure
base alignment which do not need to be rounded up to a multiple of [eq]#16#.

[NOTE]
.Note
====
The *std430 layout* in GLSL satisfies these rules.
====


[[interfaces-builtin-variables]]
== Built-In Variables

Built-in variables are accessed in shaders by declaring a variable decorated
with a code:BuiltIn decoration.
The meaning of each code:BuiltIn decoration is as follows.
In the remainder of this section, the name of a built-in is used
interchangeably with a term equivalent to a variable decorated with that
particular built-in.
Built-ins that represent integer values can: be declared as either signed or
unsigned 32-bit integers.

ifdef::VK_AMD_shader_explicit_vertex_parameter[]
code:BaryCoordNoPerspAMD::

The code:BaryCoordNoPerspAMD decoration can: be used to decorate a fragment
shader input variable.
This variable will contain the (I,J) pair of the barycentric coordinates
corresponding to the fragment evaluated using linear interpolation at the
pixel's center.
The K coordinate of the barycentric coordinates can: be derived given the
identity I + J + K = 1.0.

code:BaryCoordNoPerspCentroidAMD::

The code:BaryCoordNoPerspCentroidAMD decoration can: be used to decorate a
fragment shader input variable.
This variable will contain the (I,J) pair of the barycentric coordinates
corresponding to the fragment evaluated using linear interpolation at the
centroid.
The K coordinate of the barycentric coordinates can: be derived given the
identity I + J + K = 1.0.

code:BaryCoordNoPerspSampleAMD::

The code:BaryCoordNoPerspCentroidAMD decoration can: be used to decorate a
fragment shader input variable.
This variable will contain the (I,J) pair of the barycentric coordinates
corresponding to the fragment evaluated using linear interpolation at each
covered sample.
The K coordinate of the barycentric coordinates can: be derived given the
identity I + J + K = 1.0.

code:BaryCoordPullModelAMD::

The code:BaryCoordPullModelAMD decoration can: be used to decorate a
fragment shader input variable.
This variable will contain (1/W, 1/I, 1/J) evaluated at the pixel center and
can: be used to calculate gradients and then interpolate I, J, and W at any
desired sample location.

code:BaryCoordSmoothAMD::

The code:BaryCoordSmoothAMD decoration can: be used to decorate a fragment
shader input variable.
This variable will contain the (I,J) pair of the barycentric coordinates
corresponding to the fragment evaluated using perspective interpolation at
the pixel's center.
The K coordinate of the barycentric coordinates can: be derived given the
identity I + J + K = 1.0.

code:BaryCoordSmoothCentroidAMD::

The code:BaryCoordSmoothCentroidAMD decoration can: be used to decorate a
fragment shader input variable.
This variable will contain the (I,J) pair of the barycentric coordinates
corresponding to the fragment evaluated using perspective interpolation at
the centroid.
The K coordinate of the barycentric coordinates can: be derived given the
identity I + J + K = 1.0.

code:BaryCoordSmoothSampleAMD::

The code:BaryCoordSmoothCentroidAMD decoration can: be used to decorate a
fragment shader input variable.
This variable will contain the (I,J) pair of the barycentric coordinates
corresponding to the fragment evaluated using perspective interpolation at
each covered sample.
The K coordinate of the barycentric coordinates can: be derived given the
identity I + J + K = 1.0.

endif::VK_AMD_shader_explicit_vertex_parameter[]

ifdef::VK_KHR_shader_draw_parameters[]

[[interfaces-builtin-variables-baseinstance]]
code:BaseInstance::

Decorating a variable with the code:BaseInstance built-in will make that
variable contain the integer value corresponding to the first instance that
was passed to the command that invoked the current vertex shader invocation.
code:BaseInstance is the pname:firstInstance parameter to a _direct drawing
command_ or the pname:firstInstance member of a structure consumed by an
_indirect drawing command_.
+
The code:BaseInstance decoration must: be used only within vertex shaders.
+
The variable decorated with BaseInstance must: be declared using the input
storage class.
+
The variable decorated with BaseInstance must: be declared as a scalar
32-bit integer.

[[interfaces-builtin-variables-basevertex]]
code:BaseVertex::

Decorating a variable with the code:BaseVertex built-in will make that
variable contain the integer value corresponding to the first vertex or
vertex offset that was passed to the command that invoked the current vertex
shader invocation.
For _non-indexed drawing commands_, this variable is the pname:firstVertex
parameter to a _direct drawing command_ or the pname:firstVertex member of
the structure consumed by an _indirect drawing command_.
For _indexed drawing commands_, this variable is the pname:vertexOffset
parameter to a _direct drawing command_ or the pname:vertexOffset member of
the structure consumed by an _indirect drawing command_.
+
The code:BaseVertex decoration must: be used only within vertex shaders.
+
The variable decorated with code:BaseVertex must: be declared using the
input storage class.
+
The variable decorated with codeBaseVertex must: be declared as a scalar
32-bit integer.

endif::VK_KHR_shader_draw_parameters[]

code:ClipDistance::

Decorating a variable with the code:ClipDistance built-in decoration will
make that variable contain the mechanism for controlling user clipping.
code:ClipDistance is an array such that the i^th^ element of the array
specifies the clip distance for plane i.
A clip distance of 0 means the vertex is on the plane, a positive distance
means the vertex is inside the clip half-space, and a negative distance
means the point is outside the clip half-space.
+
The code:ClipDistance decoration must: be used only within vertex, fragment,
tessellation control, tessellation evaluation, and geometry shaders.
+
In vertex shaders, any variable decorated with code:ClipDistance must: be
declared using the code:Output storage class.
+
In fragment shaders, any variable decorated with code:ClipDistance must: be
declared using the code:Input storage class.
+
In tessellation control, tessellation evaluation, or geometry shaders, any
variable decorated with code:ClipDistance must: not be in a storage class
other than code:Input or code:Output.
+
Any variable decorated with code:ClipDistance must: be declared as an array
of 32-bit floating-point values.

[NOTE]
.Note
====
The array variable decorated with code:ClipDistance is explicitly sized by
the shader.
====

[NOTE]
.Note
====
In the last vertex processing stage, these values will be linearly
interpolated across the primitive and the portion of the primitive with
interpolated distances less than 0 will be considered outside the clip
volume.
If code:ClipDistance is then used by a fragment shader, code:ClipDistance
contains these linearly interpolated values.
====

code:CullDistance::

Decorating a variable with the code:CullDistance built-in decoration will
make that variable contain the mechanism for controlling user culling.
If any member of this array is assigned a negative value for all vertices
belonging to a primitive, then the primitive is discarded before
rasterization.
+
The code:CullDistance decoration must: be used only within vertex, fragment,
tessellation control, tessellation evaluation, and geometry shaders.
+
In vertex shaders, any variable decorated with code:CullDistance must: be
declared using the code:Output storage class.
+
In fragment shaders, any variable decorated with code:CullDistance must: be
declared using the code:Input storage class.
+
In tessellation control, tessellation evaluation, or geometry shaders, any
variable decorated with code:CullDistance must: not be declared in a storage
class other than input or output.
+
Any variable decorated with code:CullDistance must: be declared as an array
of 32-bit floating-point values.

[NOTE]
.Note
====
In fragment shaders, the values of the code:CullDistance array are linearly
interpolated across each primitive.
====

[NOTE]
.Note
====
If code:CullDistance decorates an input variable, that variable will contain
the corresponding value from the code:CullDistance decorated output variable
from the previous shader stage.
====

ifdef::VK_KHR_shader_draw_parameters[]

[[interfaces-builtin-variables-drawindex]]
code:DrawIndex::

Decorating a variable with the code:DrawIndex built-in will make that
variable contain the integer value corresponding to the zero-based index of
the drawing command that invoked the current vertex shader invocation.
For _indirect drawing commands_, code:DrawIndex begins at zero and
increments by one for each draw command executed.
The number of draw commands is given by the pname:drawCount parameter.
For _direct drawing commands_, code:DrawIndex is always zero.
code:DrawIndex is dynamically uniform.
+
The code:DrawIndex decoration must: be used only within vertex shaders.
+
The variable decorated with code:DrawIndex must: be declared using the input
storage class.
+
The variable decorated with code:DrawIndex must: be declared as a scalar
32-bit integer.

endif::VK_KHR_shader_draw_parameters[]

code:FragCoord::

Decorating a variable with the code:FragCoord built-in decoration will make
that variable contain the framebuffer coordinate
latexmath:[(x,y,z,\frac{1}{w})] of the fragment being processed.
The [eq]#(x,y)# coordinate [eq]#(0,0)# is the upper left corner of the upper
left pixel in the framebuffer.
+
When sample shading is enabled, the [eq]#x# and [eq]#y# components of
code:FragCoord reflect the location of the sample corresponding to the
shader invocation.
+
When sample shading is not enabled, the x and y components of code:FragCoord
reflect the location of the center of the pixel, [eq]#(0.5,0.5)#.
+
The [eq]#z# component of code:FragCoord is the interpolated depth value of
the primitive.
+
The [eq]#w# component is the interpolated latexmath:[\frac{1}{w}].
+
The code:FragCoord decoration must: be used only within fragment shaders.
+
The variable decorated with code:FragCoord must: be declared using the
code:Input storage class.
+
The code:Centroid interpolation decoration is ignored, but allowed, on
code:FragCoord.
+
The variable decorated with code:FragCoord must: be declared as a
four-component vector of 32-bit floating-point values.

code:FragDepth::

Decorating a variable with the code:FragDepth built-in decoration will make
that variable contain the new depth value for all samples covered by the
fragment.
This value will be used for depth testing and, if the depth test passes, any
subsequent write to the depth/stencil attachment.
+
To write to code:FragDepth, a shader must: declare the code:DepthReplacing
execution mode.
If a shader declares the code:DepthReplacing execution mode and there is an
execution path through the shader that does not set code:FragDepth, then the
fragment's depth value is undefined for executions of the shader that take
that path.
+
The code:FragDepth decoration must: be used only within fragment shaders.
+
The variable decorated with code:FragDepth must: be declared using the
code:Output storage class.
+
The variable decorated with code:FragDepth must: be declared as a scalar
32-bit floating-point value.

code:FrontFacing::

Decorating a variable with the code:FrontFacing built-in decoration will
make that variable contain whether a primitive is front or back facing.
This variable is non-zero if the current fragment is considered to be part
of a <<primsrast-polygons-basic,front-facing>> primitive and is zero if the
fragment is considered to be part of a back-facing primitive.
+
The code:FrontFacing decoration must: be used only within fragment shaders.
+
The variable decorated with code:FrontFacing must: be declared using the
code:Input storage class.
+
The variable decorated with code:FrontFacing must: be declared as a boolean.

code:GlobalInvocationId::

Decorating a variable with the code:GlobalInvocationId built-in decoration
will make that variable contain the location of the current invocation
within the global workgroup.
Each component is equal to the index of the local workgroup multiplied by
the size of the local workgroup plus code:LocalInvocationId.
+
The code:GlobalInvocationId decoration must: be used only within compute
shaders.
+
The variable decorated with code:GlobalInvocationId must: be declared using
the code:Input storage class.
+
The variable decorated with code:GlobalInvocationId must: be declared as a
three-component vector of 32-bit integers.

code:HelperInvocation::

Decorating a variable with the code:HelperInvocation built-in decoration
will make that variable contain whether the current invocation is a helper
invocation.
This variable is non-zero if the current fragment being shaded is a helper
invocation and zero otherwise.
A helper invocation is an invocation of the shader that is produced to
satisfy internal requirements such as the generation of derivatives.
+
The code:HelperInvocation decoration must: be used only within fragment
shaders.
+
The variable decorated with code:HelperInvocation must: be declared using
the code:Input storage class.
+
The variable decorated with code:HelperInvocation must: be declared as a
boolean.

[NOTE]
.Note
====
It is very likely that a helper invocation will have a value of
code:SampleMask fragment shader input value that is zero.
====

code:InvocationId::

Decorating a variable with the code:InvocationId built-in decoration will
make that variable contain the index of the current shader invocation in a
geometry shader, or the index of the output patch vertex in a tessellation
control shader.
+
In a geometry shader, the index of the current shader invocation ranges from
zero to the number of <<geometry-invocations,instances>> declared in the
shader minus one.
If the instance count of the geometry shader is one or is not specified,
then code:InvocationId will be zero.
+
The code:InvocationId decoration must: be used only within tessellation
control and geometry shaders.
+
The variable decorated with code:InvocationId must: be declared using the
code:Input storage class.
+
The variable decorated with code:InvocationId must: be declared as a scalar
32-bit integer.

code:InstanceIndex::

Decorating a variable with the code:InstanceIndex built-in decoration will
make that variable contain the index of the instance that is being processed
by the current vertex shader invocation.
code:InstanceIndex begins at the pname:firstInstance parameter to
flink:vkCmdDraw or flink:vkCmdDrawIndexed or at the pname:firstInstance
member of a structure consumed by flink:vkCmdDrawIndirect or
flink:vkCmdDrawIndexedIndirect.
+
The code:InstanceIndex decoration must: be used only within vertex shaders.
+
The variable decorated with code:InstanceIndex must: be declared using the
code:Input storage class.
+
The variable decorated with code:InstanceIndex must: be declared as a scalar
32-bit integer.

code:Layer::

Decorating a variable with the code:Layer built-in decoration will make that
variable contain the select layer of a multi-layer framebuffer attachment.
+
In a geometry shader, any variable decorated with code:Layer can be written
with the framebuffer layer index to which the primitive produced by the
geometry shader will be directed.
If a geometry shader entry point's interface does not include a variable
decorated with code:Layer, then the first layer is used.
If a geometry shader entry point's interface includes a variable decorated
with code:Layer, it must: write the same value to code:Layer for all output
vertices of a given primitive.
+
In a fragment shader, a variable decorated with code:Layer contains the
layer index of the primitive that the fragment invocation belongs to.
+
The code:Layer decoration must: be used only within geometry and fragment
shaders.
+
In a geometry shader, any variable decorated with code:Layer must: be
declared using the code:Output storage class.
+
In a fragment shader, any variable decorated with code:Layer must: be
declared using the code:Input storage class.
+
Any variable decorated with code:Layer must: be declared as a scalar 32-bit
integer.

code:LocalInvocationId::

Decorating a variable with the code:LocalInvocationId built-in decoration
will make that variable contain the location of the current compute shader
invocation within the local workgroup.
Each component ranges from zero through to the size of the workgroup in that
dimension minus one.
+
The code:LocalInvocationId decoration must: be used only within compute
shaders.
+
The variable decorated with code:LocalInvocationId must: be declared using
the code:Input storage class.
+
The variable decorated with code:LocalInvocationId must: be declared as a
three-component vector of 32-bit integers.

[NOTE]
.Note
====
If the size of the workgroup in a particular dimension is one, then the
code:LocalInvocationId in that dimension will be zero.
If the workgroup is effectively two-dimensional, then
code:LocalInvocationId.z will be zero.
If the workgroup is effectively one-dimensional, then both
code:LocalInvocationId.y and code:LocalInvocationId.z will be zero.
====

code:NumWorkgroups::

Decorating a variable with the code:NumWorkgroups built-in decoration will
make that variable contain the number of local workgroups that are part of
the dispatch that the invocation belongs to.
Each component is equal to the values of the parameters passed into
flink:vkCmdDispatch or read from the sname:VkDispatchIndirectCommand
structure read through a call to flink:vkCmdDispatchIndirect.
+
The code:NumWorkgroups decoration must: be used only within compute shaders.
+
The variable decorated with code:NumWorkgroups must: be declared using the
code:Input storage class.
+
The variable decorated with code:NumWorkgroups must: be declared as a
three-component vector of 32-bit integers.

code:PatchVertices::

Decorating a variable with the code:PatchVertices built-in decoration will
make that variable contain the number of vertices in the input patch being
processed by the shader.
A single tessellation control or tessellation evaluation shader can: read
patches of differing sizes, so the value of the code:PatchVertices variable
may: differ between patches.
+
The code:PatchVertices decoration must: be used only within tessellation
control and tessellation evaluation shaders.
+
The variable decorated with code:PatchVertices must: be declared using the
code:Input storage class.
+
The variable decorated with code:PatchVertices must: be declared as a scalar
32-bit integer.

code:PointCoord::

Decorating a variable with the code:PointCoord built-in decoration will make
that variable contain the coordinate of the current fragment within the
point being rasterized, normalized to the size of the point with origin in
the upper left corner of the point, as described in
<<primsrast-points-basic,Basic Point Rasterization>>.
If the primitive the fragment shader invocation belongs to is not a point,
then the variable decorated with code:PointCoord contains an undefined
value.
+
The code:PointCoord decoration must: be used only within fragment shaders.
+
The variable decorated with code:PointCoord must: be declared using the
code:Input storage class.
+
The variable decorated with code:PointCoord must: be declared as
two-component vector of 32-bit floating-point values.

[NOTE]
.Note
====
Depending on how the point is rasterized, code:PointCoord may: never reach
[eq]#(0,0)# or [eq]#(1,1)#.
====

code:PointSize::

Decorating a variable with the code:PointSize built-in decoration will make
that variable contain the size of point primitives.
The value written to the variable decorated with code:PointSize by the last
vertex processing stage in the pipeline is used as the framebuffer-space
size of points produced by rasterization.
+
The code:PointSize decoration must: be used only within vertex, tessellation
control, tessellation evaluation, and geometry shaders.
+
In a vertex shader, any variable decorated with code:PointSize must: be
declared using the code:Output storage class.
+
In a tessellation control, tessellation evaluation, or geometry shader, any
variable decorated with code:PointSize must: be declared using either the
code:Input or code:Output storage class.
+
Any variable decorated with code:PointSize must: be declared as a scalar
32-bit floating-point value.

[NOTE]
.Note
====
When code:PointSize decorates a variable in the code:Input storage class, it
contains the data written to the output variable decorated with
code:PointSize from the previous shader stage.
====

code:Position::

Decorating a variable with the code:Position built-in decoration will make
that variable contain the position of the current vertex.
In the last vertex processing stage, the value of the variable decorated
with code:Position is used in subsequent primitive assembly, clipping, and
rasterization operations.
+
The code:Position decoration must: be used only within vertex, tessellation
control, tessellation evaluation, and geometry shaders.
+
In a vertex shader, any variable decorated with code:Position must: be
declared using the code:Output storage class.
+
In a tessellation control, tessellation evaluation, or geometry shader, any
variable decorated with code:Position must: not be declared in a storage
class other than input or output.
+
Any variable decorated with code:Position must: be declared as a
four-component vector of 32-bit floating-point values.

[NOTE]
.Note
====
When code:Position decorates a variable in the code:Input storage class, it
contains the data written to the output variable decorated with
code:Position from the previous shader stage.
====

code:PrimitiveId::

Decorating a variable with the code:PrimitiveId built-in decoration will
make that variable contain the index of the current primitive.
+
In tessellation control and tessellation evaluation shaders, it will contain
the index of the patch within the current set of rendering primitives that
correspond to the shader invocation.
+
In a geometry shader, it will contain the number of primitives presented as
input to the shader since the current set of rendering primitives was
started.
+
In a fragment shader, it will contain the primitive index written by the
geometry shader if a geometry shader is present, or with the value that
would have been presented as input to the geometry shader had it been
present.
+
If a geometry shader is present and the fragment shader reads from an input
variable decorated with code:PrimitiveId, then the geometry shader must:
write to an output variable decorated with code:PrimitiveId in all execution
paths.
+
The code:PrimitiveId decoration must: be used only within fragment,
tessellation control, tessellation evaluation, and geometry shaders.
+
In a tessellation control or tessellation evaluation shader, any variable
decorated with code:PrimitiveId must: be declared using the code:Output
storage class.
+
In a geometry shader, any variable decorated with code:PrimitiveId must: be
declared using either the code:Input or code:Output storage class.
+
In a fragment shader, any variable decorated with code:PrimitiveId must: be
declared using the code:Input storage class, and either the code:Geometry or
code:Tessellation capability must also be declared.
+
Any variable decorated with code:PrimitiveId must: be declared as a scalar
32-bit integer.

[NOTE]
.Note
====
When the code:PrimitiveId decoration is applied to an output variable in the
geometry shader, the resulting value is seen through the code:PrimitiveId
decorated input variable in the fragment shader.
====

code:SampleId::

Decorating a variable with the code:SampleId built-in decoration will make
that variable contain the zero-based index of the sample the invocation
corresponds to.
code:SampleId ranges from zero to the number of samples in the framebuffer
minus one.
If a fragment shader entry point's interface includes an input variable
decorated with code:SampleId, per-sample shading is enabled for draws that
use that fragment shader.
+
The code:SampleId decoration must: be used only within fragment shaders.
+
The variable decorated with code:SampleId must: be declared using the
code:Input storage class.
+
The variable decorated with code:SampleId must: be declared as a scalar
32-bit integer.

code:SampleMask::

Decorating a variable with the code:SampleMask built-in decoration will make
any variable contain the sample coverage mask for the current fragment
shader invocation.
+
A variable in the code:Input storage class decorated with code:SampleMask
will contain a bitmask of the set of samples covered by the primitive
generating the fragment during rasterization.
It has a sample bit set if and only if the sample is considered covered for
this fragment shader invocation.
code:SampleMask[] is an array of integers.
Bits are mapped to samples in a manner where bit B of mask M
(`SampleMask[M]`) corresponds to sample [eq]#32 {times} M + B#.
+
When state specifies multiple fragment shader invocations for a given
fragment, the sample mask for any single fragment shader invocation
specifies the subset of the covered samples for the fragment that correspond
to the invocation.
In this case, the bit corresponding to each covered sample will be set in
exactly one fragment shader invocation.
+
A variable in the code:Output storage class decorated with code:SampleMask
is an array of integers forming a bit array in a manner similar an input
variable decorated with code:SampleMask, but where each bit represents
coverage as computed by the shader.
Modifying the sample mask by writing zero to a bit of code:SampleMask causes
the sample to be considered uncovered.
However, setting sample mask bits to one will never enable samples not
covered by the original primitive.
If the fragment shader is being evaluated at any frequency other than
per-fragment, bits of the sample mask not corresponding to the current
fragment shader invocation are ignored.
This array must: be sized in the fragment shader either implicitly or
explicitly, to be no larger than the implementation-dependent maximum
sample-mask (as an array of 32-bit elements), determined by the maximum
number of samples.
If a fragment shader entry point's interface includes an output variable
decorated with code:SampleMask, the sample mask will be undefined for any
array elements of any fragment shader invocations that fail to assign a
value.
If a fragment shader entry point's interface does not include an output
variable decorated with code:SampleMask, the sample mask has no effect on
the processing of a fragment.
+
The code:SampleMask decoration must: be used only within fragment shaders.
+
Any variable decorated with code:SampleMask must: be declared using either
the code:Input or code:Output storage class.
+
Any variable decorated with code:SampleMask must: be declared as an array of
32-bit integers.

code:SamplePosition::

Decorating a variable with the code:SamplePosition built-in decoration will
make that variable contain the sub-pixel position of the sample being
shaded.
The top left of the pixel is considered to be at coordinate [eq]#(0,0)# and
the bottom right of the pixel is considered to be at coordinate [eq]#(1,1)#.
If a fragment shader entry point's interface includes an input variable
decorated with code:SamplePosition, per-sample shading is enabled for draws
that use that fragment shader.
+
The code:SamplePosition decoration must: be used only within fragment
shaders.
+
The variable decorated with code:SamplePosition must: be declared using the
code:Input storage class.
+
The variable decorated with code:SamplePosition must: be declared as a
two-component vector of 32-bit floating-point values.

ifdef::VK_EXT_shader_subgroup_ballot[]

[[interfaces-builtin-variables-sgeq]]
code:SubgroupEqMaskKHR::
+
Decorating a variable with the code:SubgroupEqMaskKHR builtin decoration
will make that variable contain the _subgroup mask_ of the current subgroup
invocation.
The bit corresponding to the code:SubgroupLocalInvocationId is set in the
variable decorated with code:SubgroupEqMaskKHR.
All other bits are set to zero.
+
The variable decorated with code:SubgroupEqMaskKHR must: be declared using
the code:Input storage class.
+
The variable decorated with code:SubgroupEqMaskKHR must: be declared as a
four-component vector of 32-bit integer values.

[[interfaces-builtin-variables-sgge]]
code:SubgroupGeMaskKHR::
+
Decorating a variable with the code:SubgroupGeMaskKHR builtin decoration
will make that variable contain the _subgroup mask_ of the invocations
greater than or equal to the current subgroup invocation.
The bits corresponding to the invocations greather than or equal to
code:SubgroupLocalInvocationId through code:SubgroupSize-1 are set in the
variable decorated with code:SubgroupGeMaskKHR.
All other bits are set to zero.
+
The variable decorated with code:SubgroupGeMaskKHR must: be declared using
the code:Input storage class.
+
The variable decorated with code:SubgroupGeMaskKHR must: be declared as a
four-component vector of 32-bit integer values.

[[interfaces-builtin-variables-sggt]]
code:SubgroupGtMaskKHR::
+
Decorating a variable with the code:SubgroupGtMaskKHR builtin decoration
will make that variable contain the _subgroup mask_ of the invocations
greater than the current subgroup invocation.
The bits corresponding to the invocations greater than
code:SubgroupLocalInvocationId through code:SubgroupSize-1 are set in the
variable decorated with code:SubgroupGtMaskKHR.
All other bits are set to zero.
+
The variable decorated with code:SubgroupGtMaskKHR must: be declared using
the code:Input storage class.
+
The variable decorated with code:SubgroupGtMaskKHR must: be declared as a
four-component vector of 32-bit integer values.

[[interfaces-builtin-variables-sgle]]
code:SubgroupLeMaskKHR::
+
Decorating a variable with the code:SubgroupLeMaskKHR builtin decoration
will make that variable contain the _subgroup mask_ of the invocations less
than or equal to the current subgroup invocation.
The bits corresponding to the invocations less than or equal to
code:SubgroupLocalInvocationId are set in the variable decorated with
code:SubgroupLeMaskKHR.
All other bits are set to zero.
+
The variable decorated with code:SubgroupLeMaskKHR must: be declared using
the code:Input storage class.
+
The variable decorated with code:SubgroupLeMaskKHR must: be declared as a
four-component vector of 32-bit integer values.

[[interfaces-builtin-variables-sglt]]
code:SubgroupLtMaskKHR::
+
Decorating a variable with the code:SubgroupLtMaskKHR builtin decoration
will make that variable contain the _subgroup mask_ of the invocations less
than the current subgroup invocation.
The bits corresponding to the invocations less than
code:SubgroupLocalInvocationId are set in the variable decorated with
code:SubgroupLtMaskKHR.
All other bits are set to zero.
+
The variable decorated with code:SubgroupLtMaskKHR must: be declared using
the code:Input storage class.
+
The variable decorated with code:SubgroupLtMaskKHR must: be declared as a
four-component vector of 32-bit integer values.

[[interfaces-builtin-variables-sgli]]
code:SubgroupLocalInvocationId::
+
Decorating a variable with the code:SubgroupLocalInvocationId builtin
decoration will make that variable contain the index of the invocation
within the subgroup.
This variable is in range [0,code:SubgroupSize-1].
+
The variable decorated with code:SubgroupLocalInvocationId must: be declared
using the code:Input storage class.
+
The variable decorated with code:SubgroupLocalInvocationId must: be declared
as a scalar 32-bit integer.

[[interfaces-builtin-variables-sgs]]
code:SubgroupSize::
+
Decorating a variable with the code:SubgroupSize builtin decoration will
make that variable contain the implementation-dependent maximum number of
invocations in a subgroup.
The maximum number of invocations that an implementation can support per
subgroup is 128.
+
The variable decorated with code:SubgroupSize must: be declared using the
code:Input storage class.
+
The variable decorated with code:SubgroupSize must: be declared as a scalar
32-bit integer.

endif::VK_EXT_shader_subgroup_ballot[]

code:TessCoord::

Decorating a variable with the code:TessCoord built-in decoration will make
that variable contain the three-dimensional [eq]#(u,v,w)# barycentric
coordinate of the tessellated vertex within the patch.
[eq]#u#, [eq]#v#, and [eq]#w# are in the range [eq]#[0,1]# and vary linearly
across the primitive being subdivided.
For the tessellation modes of code:Quads or code:IsoLines, the third
component is always zero.
+
The code:TessCoord decoration must: be used only within tessellation
evaluation shaders.
+
The variable decorated with code:TessCoord must: be declared using the
code:Input storage class.
+
The variable decorated with code:TessCoord must: be declared as
three-component vector of 32-bit floating-point values.

code:TessLevelOuter::

Decorating a variable with the code:TessLevelOuter built-in decoration will
make that variable contain the outer tessellation levels for the current
patch.
+
In tessellation control shaders, the variable decorated with
code:TessLevelOuter can: be written to which controls the tessellation
factors for the resulting patch.
These values are used by the tessellator to control primitive tessellation
and can: be read by tessellation evaluation shaders.
+
In tessellation evaluation shaders, the variable decorated with
code:TessLevelOuter can: read the values written by the tessellation control
shader.
+
The code:TessLevelOuter decoration must: be used only within tessellation
control and tessellation evaluation shaders.
+
In a tessellation control shader, any variable decorated with
code:TessLevelOuter must: be declared using the code:Output storage class.
+
In a tessellation evaluation shader, any variable decorated with
code:TessLevelOuter must: be declared using the code:Input storage class.
+
Any variable decorated with code:TessLevelOuter must: be declared as an
array of size four, containing 32-bit floating-point values.

code:TessLevelInner::

Decorating a variable with the code:TessLevelInner built-in decoration will
make that variable contain the inner tessellation levels for the current
patch.
+
In tessellation control shaders, the variable decorated with
code:TessLevelInner can: be written to, which controls the tessellation
factors for the resulting patch.
These values are used by the tessellator to control primitive tessellation
and can: be read by tessellation evaluation shaders.
+
In tessellation evaluation shaders, the variable decorated with
code:TessLevelInner can: read the values written by the tessellation control
shader.
+
The code:TessLevelInner decoration must: be used only within tessellation
control and tessellation evaluation shaders.
+
In a tessellation control shader, any variable decorated with
code:TessLevelInner must: be declared using the code:Output storage class.
+
In a tessellation evaluation shader, any variable decorated with
code:TessLevelInner must: be declared using the code:Input storage class.
+
Any variable decorated with code:TessLevelInner must: be declared as an
array of size two, containing 32-bit floating-point values.

code:VertexIndex::

Decorating a variable with the code:VertexIndex built-in decoration will
make that variable contain the index of the vertex that is being processed
by the current vertex shader invocation.
For non-indexed draws, this variable begins at the pname:firstVertex
parameter to flink:vkCmdDraw or the pname:firstVertex member of a structure
consumed by flink:vkCmdDrawIndirect and increments by one for each vertex in
the draw.
For indexed draws, its value is the content of the index buffer for the
vertex plus the pname:vertexOffset parameter to flink:vkCmdDrawIndexed or
the pname:vertexOffset member of the structure consumed by
flink:vkCmdDrawIndexedIndirect.
+
The code:VertexIndex decoration must: be used only within vertex shaders.
+
The variable decorated with code:VertexIndex must: be declared using the
code:Input storage class.
+
The variable decorated with code:VertexIndex must: be declared as a scalar
32-bit integer.

[NOTE]
.Note
====
code:VertexIndex starts at the same starting value for each instance.
====

code:ViewportIndex::

Decorating a variable with the code:ViewportIndex built-in decoration will
make that variable contain the index of the viewport.
+
In a geometry shader, the variable decorated with code:ViewportIndex can be
written to with the viewport index to which the primitive produced by the
geometry shader will be directed.
The selected viewport index is used to select the viewport transform and
scissor rectangle.
If a geometry shader entry point's interface does not include a variable
decorated with code:ViewportIndex, then the first viewport is used.
If a geometry shader entry point's interface includes a variable decorated
with code:ViewportIndex, it must: write the same value to code:ViewportIndex
for all output vertices of a given primitive.
+
In a fragment shader, the variable decorated with code:ViewportIndex
contains the viewport index of the primitive that the fragment invocation
belongs to.
+
The code:ViewportIndex decoration must: be used only within geometry and
fragment shaders.
+
In a geometry shader, any variable decorated with code:ViewportIndex must:
be declared using the code:Output storage class.
+
In a fragment shader, any variable decorated with code:ViewportIndex must:
be declared using the code:Input storage class.
+
Any variable decorated with code:ViewportIndex must: be declared as a scalar
32-bit integer.

code:WorkgroupId::

Decorating a variable with the code:WorkgroupId built-in decoration will
make that variable contain the global workgroup that the current invocation
is a member of.
Each component ranges from zero to the values of the parameters passed into
flink:vkCmdDispatch or read from the sname:VkDispatchIndirectCommand
structure read through a call to flink:vkCmdDispatchIndirect.
+
The code:WorkgroupId decoration must: be used only within compute shaders.
+
The variable decorated with code:WorkgroupId must: be declared using the
code:Input storage class.
+
The variable decorated with code:WorkgroupId must: be declared as a
three-component vector of 32-bit integers.

code:WorkgroupSize::

Decorating a variable with the code:WorkgroupSize built-in decoration will
make that variable contain the dimensions of a local workgroup.
If an object is decorated with the code:WorkgroupSize decoration, this must:
take precedence over any execution mode set for code:LocalSize.
+
The code:WorkgroupSize decoration must: be used only within compute shaders.
+
The object decorated with code:WorkgroupSize must: be a specialization
constant or a constant.
+
The object decorated with code:WorkgroupSize must: be declared as a
three-component vector of 32-bit integers.
