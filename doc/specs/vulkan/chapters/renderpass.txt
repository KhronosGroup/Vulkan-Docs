// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[renderpass]]
= Render Pass

// refBegin VkRenderPass Opaque handle to a render pass object
一个render pass表示一系列附件、subpass、subpass之间的依赖关系的集合，描述了附件在subpass的过程中是
如何被使用的。
在命令缓冲区中render pass的使用 是一个 _render pass实例_ 。

render pass由sname:VkRenderPass类型的handle表示：

include::../api/handles/VkRenderPass.txt[]

// refEnd VkRenderPass

一个 _附件描述_ 描述了一个附件的属性，包含它的格式、采样数、在每一个render pass实例的开始和结束时它的内容是被看作了什么。

[[renderpass-subpass]]
一个 _subpass_ 代表渲染中的一个读写render pass 的附件子集的阶段 。
渲染命令被记录在render pass实例的某一个subpass中。

一个 _subpass_ 描述了参与到subpass执行的附件的子集。
每一个subpass都可以被当作_输入附件_ 的附件中读取数据，写入数据到被当作颜色、深度、模板附件的附件中，并对解析附件执行多采样解析操作。
一个subpass描述也可以包含多个 _保留附件_，这些附件不被subpass读取或者写入，但是它们的内容在subpass之间被一直保留。


如果附件是该subpass的颜色、深度、模板、解析或者输入附件（如slink:VkSubpassDescription的成员
pname:pColorAttachments, pname:pDepthStencilAttachment,
pname:pResolveAttachments, and pname:pInputAttachments所描述），一个subpass就可以使用它。
如果一个附件在subpass之间被保留，subpass就不会使用它。
序号最小的subpass第一次使用附件。序号最大的subpass最后一次使用附件。

一个renderpass的所有subpass都渲染到同一维，每一个像素对应的单subpass的多个片元可读取前一个subpass在同一个 (x,y,layer)位置写入的内容。

[NOTE]
.注意
====
通过提前描述一个完整的subpass集合，render pass提供了在不同subpass之间优化存储和转移附件数据的机会。

实际上，这意味着带有一个简单帧缓冲区空间依赖的subpass也许会被合并到一个tiled rendering pass，一个render pass实例内附件的数据保持在芯片上。
然而，一个render pass仅仅包含一个subpass也很常见。
====
_subpass依赖_ 描述了subpass之间的<<synchronization-dependencies, 执行和内存依赖>>。

一个 _subpass依赖链_ 是render pass内部多个subpass之间的一系列依赖关系，每一个subpass依赖的源subpass就是前一个依赖关系的目标subpass。

多个subpass也许会重叠或者乱序的执行，除非强制指定执行的依赖顺序。每一个subpass只参考记录到同一个subpass的命令<<synchronization-submission-order, submission order>> ，
和划分renderpass界限的flink:vkCmdBeginRenderPass、 flink:vkCmdEndRenderPass命令（在另一个subpass的命令并没有被包含）。
这影响力大多数其他的<<synchronization-implicit, implicit ordering guarantees>>。

一个render pass描述了subpass和独立于任何特定图像视图的附件的结构。
这个特定的图像视图（将被用于附件）和附件的维度，通过sname:VkFramebuffer 对象指定。
缓冲区是参考特定的render pass（和缓冲区兼容的，参考<<renderpass-compatibility, Render Pass 兼容性>>）来创建的。
总的来说，一个render pass和一个帧缓存器给一个或多个subpass定义了完整的渲染状态，也包括多个subpass之间的依赖性。

一个给定的subpass绘制命令的各种管线阶段，在多个绘制命令之内或者跨多个命令，也许会顺序/乱序的并行执行，然而仍遵循
<<synchronization-pipeline-stages-order, 管线顺序>>。
然而，对于给定的(x,y,layer,sample) 采样位置，某个逐采样操作依<<primrast-order, 栅格化顺序>>执行。


[[renderpass-creation]]
== 创建Render Pass  

// refBegin vkCreateRenderPass Create a new render pass object

可调用如下函数来创建render pass：

include::../api/protos/vkCreateRenderPass.txt[]

  * pname:device 是创建render pass的逻辑设备。
  * pname:pCreateInfo 是一个指向 slink:VkRenderPassCreateInfo实例的指针，描述了render pass的参数。
  * pname:pAllocator 控制了主机端内存如何分配，如<<memory-allocation, Memory Allocation>>一章所述。
  * pname:pRenderPass 指向了sname:VkRenderPass handle，是被返回的生成的render pass。

include::../validity/protos/vkCreateRenderPass.txt[]

// refBegin VkRenderPassCreateInfo Structure specifying parameters of a newly created render pass

sname:VkRenderPassCreateInfo 数据类型定义如下：

include::../api/structs/VkRenderPassCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags is reserved for future use.
  * pname:attachmentCount is the number of attachments used by this render
    pass, or zero indicating no attachments.
    Attachments are referred to by zero-based indices in the range
    [0,pname:attachmentCount).
  * pname:pAttachments points to an array of pname:attachmentCount number of
    slink:VkAttachmentDescription structures describing properties of the
    attachments, or `NULL` if pname:attachmentCount is zero.
  * pname:subpassCount is the number of subpasses to create for this render
    pass.
    Subpasses are referred to by zero-based indices in the range
    [0,pname:subpassCount).
    A render pass must: have at least one subpass.
  * pname:pSubpasses points to an array of pname:subpassCount number of
    slink:VkSubpassDescription structures describing properties of the
    subpasses.
  * pname:dependencyCount is the number of dependencies between pairs of
    subpasses, or zero indicating no dependencies.
  * pname:pDependencies points to an array of pname:dependencyCount number
    of slink:VkSubpassDependency structures describing dependencies between
    pairs of subpasses, or `NULL` if pname:dependencyCount is zero.

.Valid Usage
****
  * If any two subpasses operate on attachments with overlapping ranges of
    the same sname:VkDeviceMemory object, and at least one subpass writes to
    that area of sname:VkDeviceMemory, a subpass dependency must: be
    included (either directly or via some intermediate subpasses) between
    them
  * If the pname:attachment member of any element of
    pname:pInputAttachments, pname:pColorAttachments,
    pname:pResolveAttachments or pname:pDepthStencilAttachment, or the
    attachment indexed by any element of pname:pPreserveAttachments in any
    given element of pname:pSubpasses is bound to a range of a
    sname:VkDeviceMemory object that overlaps with any other attachment in
    any subpass (including the same subpass), the
    sname:VkAttachmentDescription structures describing them must: include
    ename:VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT in pname:flags
  * If the pname:attachment member of any element of
    pname:pInputAttachments, pname:pColorAttachments,
    pname:pResolveAttachments or pname:pDepthStencilAttachment, or any
    element of pname:pPreserveAttachments in any given element of
    pname:pSubpasses is not ename:VK_ATTACHMENT_UNUSED, it must: be less
    than pname:attachmentCount
  * The value of any element of the pname:pPreserveAttachments member in any
    given element of pname:pSubpasses must: not be
    ename:VK_ATTACHMENT_UNUSED
  * For any member of pname:pAttachments with a pname:loadOp equal to
    ename:VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment
    must: not specify a pname:layout equal to
    pname:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL or
    pname:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL.
  * For any element of pname:pDependencies, if the pname:srcSubpass is not
    ename:VK_SUBPASS_EXTERNAL, all stage flags included in the
    pname:srcStageMask member of that dependency must: be a pipeline stage
    supported by the <<synchronization-pipeline-stages-types, pipeline>>
    identified by the pname:pipelineBindPoint member of the source subpass.
  * For any element of pname:pDependencies, if the pname:dstSubpass is not
    ename:VK_SUBPASS_EXTERNAL, all stage flags included in the
    pname:dstStageMask member of that dependency must: be a pipeline stage
    supported by the <<synchronization-pipeline-stages-types, pipeline>>
    identified by the pname:pipelineBindPoint member of the source subpass.
****

include::../validity/structs/VkRenderPassCreateInfo.txt[]

// refBegin VkAttachmentDescription Structure specifying an attachment description

sname:VkAttachmentDescription数据结构定义如下:

include::../api/structs/VkAttachmentDescription.txt[]

  * pname:flags is a bitmask describing additional properties of the
    attachment.
    Bits which can: be set include:
+
--
// refBegin VkAttachmentDescriptionFlagBits Bitmask specifying additional properties of an attachment
include::../api/enums/VkAttachmentDescriptionFlagBits.txt[]
--
  * pname:format is a elink:VkFormat value specifying the format of the
    image that will be used for the attachment.
  * pname:samples is the number of samples of the image as defined in
    elink:VkSampleCountFlagBits.
  * pname:loadOp specifies how the contents of color and depth components of
    the attachment are treated at the beginning of the subpass where it is
    first used:
+
--
// refBegin VkAttachmentLoadOp Specify how contents of an attachment are treated at the beginning of a subpass
include::../api/enums/VkAttachmentLoadOp.txt[]
--
  ** ename:VK_ATTACHMENT_LOAD_OP_LOAD means the previous contents of the
     image within the render area will be preserved.
     For attachments with a depth/stencil format, this uses the access type
     ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT.
     For attachments with a color format, this uses the access type
     ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT.
  ** ename:VK_ATTACHMENT_LOAD_OP_CLEAR means the contents within the render
     area will be cleared to a uniform value, which is specified when a
     render pass instance is begun.
     For attachments with a depth/stencil format, this uses the access type
     ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT.
     For attachments with a color format, this uses the access type
     ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT.
  ** ename:VK_ATTACHMENT_LOAD_OP_DONT_CARE means the previous contents
     within the area need not be preserved; the contents of the attachment
     will be undefined inside the render area.
     For attachments with a depth/stencil format, this uses the access type
     ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT.
     For attachments with a color format, this uses the access type
     ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT.
  * pname:storeOp specifies how the contents of color and depth components
    of the attachment are treated at the end of the subpass where it is last
    used:
+
--
// refBegin VkAttachmentStoreOp Specify how contents of an attachment are treated at the end of a subpass
include::../api/enums/VkAttachmentStoreOp.txt[]
--
  ** ename:VK_ATTACHMENT_STORE_OP_STORE means the contents generated during
     the render pass and within the render area are written to memory.
     For attachments with a depth/stencil format, this uses the access type
     ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT.
     For attachments with a color format, this uses the access type
     ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT.
  ** ename:VK_ATTACHMENT_STORE_OP_DONT_CARE means the contents within the
     render area are not needed after rendering, and may: be discarded; the
     contents of the attachment will be undefined inside the render area.
     For attachments with a depth/stencil format, this uses the access type
     ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT.
     For attachments with a color format, this uses the access type
     ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT.
  * pname:stencilLoadOp specifies how the contents of stencil components of
    the attachment are treated at the beginning of the subpass where it is
    first used, and must: be one of the same values allowed for pname:loadOp
    above.
  * pname:stencilStoreOp specifies how the contents of stencil components of
    the attachment are treated at the end of the last subpass where it is
    used, and must: be one of the same values allowed for pname:storeOp
    above.
  * pname:initialLayout is the layout the attachment image subresource will
    be in when a render pass instance begins.
  * pname:finalLayout is the layout the attachment image subresource will be
    transitioned to when a render pass instance ends.
    During a render pass instance, an attachment can: use a different layout
    in each subpass, if desired.

[[renderpass-load-store-ops]]
如果附件使用了颜色格式，那么pname:loadOp 和 pname:storeOp就被使用了，pname:stencilLoadOp 和 pname:stencilStoreOp被忽略。
如果该格式有深度和/或模板数据，那么pname:loadOp 和pname:storeOp仅用于深度数据，pname:stencilLoadOp 和pname:stencilStoreOp 定义了模板数据如何被处理。
pname:loadOp 和 pname:stencilLoadOp 定义了  _load operations_ ，它作为第一个使用该附件的subpass的一部分被执行。
pname:storeOp 和 pname:stencilStoreOp 定义了 _store operations_，它作为最后一个使用该附件的subpass的一部分被执行。

被subpass使用的附件内每一个值的加载操作，在被记录到subpass的命令读取这个值之前发生。
对于带有深度/模板格式的附件的加载操作发生在ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT pipeline阶段。
对于带有颜色格式的附件的加载操作在ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT管线阶段执行。

对于被subpass使用的附件内每一个值的存储操作发生在被记录到subpass的命令向该值写入之后。
对于带有深度/模板格式的附件的存储操作，发生在ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT管线阶段。
对于带有颜色格式的附件的存储操作在ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT 管线阶段执行。

如果一个附件没有被subpass使用，那么pname:loadOp, pname:storeOp, pname:stencilStoreOp, and pname:stencilLoadOp 都被忽略，附件的内存内容将不会被render pass的执行所修改。


[[renderpass-precision]]
在一个render pass实例期间内，带有颜色格式（每一个成员大小为8，16或32位）的输入/颜色附件，贯穿于整个实例必须以附件的格式表示。
带有其他浮点或定点颜色格式，或深度成分的附件可能通过比附件格式精度更高的格式所表示，但是必须表示相同的范围。
当这样的component通过pname:loadOp被载入时，它将被转换为被render pass使用的依赖于Vulkan实现的格式。

Such components must: be converted from the render pass format, to the
format of the attachment, before they are resolved or stored at the end of a
render pass instance via pname:storeOp.
Conversions occur as described in <<fundamentals-numerics,Numeric
Representation and Computation>> and <<fundamentals-fixedconv, Fixed-Point
Data Conversions>>.

[[renderpass-aliasing]]
If pname:flags includes ename:VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT, then
the attachment is treated as if it shares physical memory with another
attachment in the same render pass.
This information limits the ability of the implementation to reorder certain
operations (like layout transitions and the pname:loadOp) such that it is
not improperly reordered against other uses of the same physical memory via
a different attachment.
This is described in more detail below.

.Valid Usage
****
  * pname:finalLayout must: not be ename:VK_IMAGE_LAYOUT_UNDEFINED or
    ename:VK_IMAGE_LAYOUT_PREINITIALIZED
****

include::../validity/structs/VkAttachmentDescription.txt[]

ifdef::editing-notes[]
[NOTE]
.editing-note
====
TODO (Jon) - the following text may need to be moved back to combine with
flink:vkCreateRenderPass above for automatic ref page generation.
====
endif::editing-notes[]

If a render pass uses multiple attachments that alias the same device
memory, those attachments must: each include the
ename:VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT bit in their attachment
description flags.
Attachments aliasing the same memory occurs in multiple ways:

  * Multiple attachments being assigned the same image view as part of
    framebuffer creation.
  * Attachments using distinct image views that correspond to the same image
    subresource of an image.
  * Attachments using views of distinct image subresources which are bound
    to overlapping memory ranges.

.Note
[NOTE]
====
Render passes must: include subpass dependencies (either directly or via a
subpass dependency chain) between any two subpasses that operate on the same
attachment or aliasing attachments and those subpass dependencies must:
include execution and memory dependencies separating uses of the aliases, if
at least one of those subpasses writes to one of the aliases.
These dependencies must: not include the ename:VK_DEPENDENCY_BY_REGION_BIT
if the aliases are views of distinct image subresources which overlap in
memory.
====

Multiple attachments that alias the same memory must: not be used in a
single subpass.
A given attachment index must: not be used multiple times in a single
subpass, with one exception: two subpass attachments can: use the same
attachment index if at least one use is as an input attachment and neither
use is as a resolve or preserve attachment.
In other words, the same view can: be used simultaneously as an input and
color or depth/stencil attachment, but must: not be used as multiple color
or depth/stencil attachments nor as resolve or preserve attachments.
The precise set of valid scenarios is described in more detail
<<renderpass-feedbackloop, below>>.

If a set of attachments alias each other, then all except the first to be
used in the render pass must: use an pname:initialLayout of
ename:VK_IMAGE_LAYOUT_UNDEFINED, since the earlier uses of the other aliases
make their contents undefined.
Once an alias has been used and a different alias has been used after it,
the first alias must: not be used in any later subpasses.
However, an application can: assign the same image view to multiple aliasing
attachment indices, which allows that image view to be used multiple times
even if other aliases are used in between.

[NOTE]
.Note
====
Once an attachment needs the ename:VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT
bit, there should: be no additional cost of introducing additional aliases,
and using these additional aliases may: allow more efficient clearing of the
attachments on multiple uses via ename:VK_ATTACHMENT_LOAD_OP_CLEAR.
====

// refBegin VkSubpassDescription Structure specifying a subpass description

The sname:VkSubpassDescription structure is defined as:

include::../api/structs/VkSubpassDescription.txt[]

  * pname:flags is reserved for future use.
  * pname:pipelineBindPoint is a elink:VkPipelineBindPoint value specifying
    whether this is a compute or graphics subpass.
    Currently, only graphics subpasses are supported.
  * pname:inputAttachmentCount is the number of input attachments.
  * pname:pInputAttachments is an array of slink:VkAttachmentReference
    structures (defined below) that lists which of the render pass's
    attachments can: be read in the shader during the subpass, and what
    layout each attachment will be in during the subpass.
    Each element of the array corresponds to an input attachment unit number
    in the shader, i.e. if the shader declares an input variable
    `layout(input_attachment_index=X, set=Y, binding=Z)` then it uses the
    attachment provided in pname:pInputAttachments[X].
    Input attachments must: also be bound to the pipeline with a descriptor
    set, with the input attachment descriptor written in the location
    (set=Y, binding=Z).
  * pname:colorAttachmentCount is the number of color attachments.
  * pname:pColorAttachments is an array of pname:colorAttachmentCount
    slink:VkAttachmentReference structures that lists which of the render
    pass's attachments will be used as color attachments in the subpass, and
    what layout each attachment will be in during the subpass.
    Each element of the array corresponds to a fragment shader output
    location, i.e. if the shader declared an output variable
    `layout(location=X)` then it uses the attachment provided in
    pname:pColorAttachments[X].
  * pname:pResolveAttachments is `NULL` or an array of
    pname:colorAttachmentCount slink:VkAttachmentReference structures that
    lists which of the render pass's attachments are resolved to at the end
    of the subpass, and what layout each attachment will be in during the
    multisample resolve operation.
    If pname:pResolveAttachments is not `NULL`, each of its elements
    corresponds to a color attachment (the element in
    pname:pColorAttachments at the same index), and a multisample resolve
    operation is defined for each attachment.
    At the end of each subpass, multisample resolve operations read the
    subpass's color attachments, and resolve the samples for each pixel to
    the same pixel location in the corresponding resolve attachments, unless
    the resolve attachment index is ename:VK_ATTACHMENT_UNUSED.
    If the first use of an attachment in a render pass is as a resolve
    attachment, then the pname:loadOp is effectively ignored as the resolve
    is guaranteed to overwrite all pixels in the render area.
  * pname:pDepthStencilAttachment is a pointer to a
    slink:VkAttachmentReference specifying which attachment will be used for
    depth/stencil data and the layout it will be in during the subpass.
    Setting the attachment index to ename:VK_ATTACHMENT_UNUSED or leaving
    this pointer as `NULL` indicates that no depth/stencil attachment will
    be used in the subpass.
  * pname:preserveAttachmentCount is the number of preserved attachments.
  * pname:pPreserveAttachments is an array of pname:preserveAttachmentCount
    render pass attachment indices describing the attachments that are not
    used by a subpass, but whose contents must: be preserved throughout the
    subpass.

The contents of an attachment within the render area become undefined at the
start of a subpass *S* if all of the following conditions are true:

  * The attachment is used as a color, depth/stencil, or resolve attachment
    in any subpass in the render pass.
  * There is a subpass *S~1~* that uses or preserves the attachment, and a
    subpass dependency from *S~1~* to *S*.
  * The attachment is not used or preserved in subpass *S*.

Once the contents of an attachment become undefined in subpass *S*, they
remain undefined for subpasses in subpass dependency chains starting with
subpass *S* until they are written again.
However, they remain valid for subpasses in other subpass dependency chains
starting with subpass *S~1~* if those subpasses use or preserve the
attachment.

.Valid Usage
****
  * pname:pipelineBindPoint must: be ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * pname:colorAttachmentCount must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxColorAttachments
  * If the first use of an attachment in this render pass is as an input
    attachment, and the attachment is not also used as a color or
    depth/stencil attachment in the same subpass, then pname:loadOp must:
    not be ename:VK_ATTACHMENT_LOAD_OP_CLEAR
  * If pname:pResolveAttachments is not `NULL`, for each resolve attachment
    that does not have the value ename:VK_ATTACHMENT_UNUSED, the
    corresponding color attachment must: not have the value
    ename:VK_ATTACHMENT_UNUSED
  * If pname:pResolveAttachments is not `NULL`, the sample count of each
    element of pname:pColorAttachments must: be anything other than
    ename:VK_SAMPLE_COUNT_1_BIT
  * Any given element of pname:pResolveAttachments must: have a sample count
    of ename:VK_SAMPLE_COUNT_1_BIT
  * Any given element of pname:pResolveAttachments must: have the same
    elink:VkFormat as its corresponding color attachment
  * All attachments in pname:pColorAttachments and
    pname:pDepthStencilAttachment that are not ename:VK_ATTACHMENT_UNUSED
    must: have the same sample count
  * If any input attachments are ename:VK_ATTACHMENT_UNUSED, then any
    pipelines bound during the subpass must: not access those input
    attachments from the fragment shader
  * The pname:attachment member of any element of pname:pPreserveAttachments
    must: not be ename:VK_ATTACHMENT_UNUSED
  * Any given element of pname:pPreserveAttachments must: not also be an
    element of any other member of the subpass description
  * If any attachment is used as both an input attachment and a color or
    depth/stencil attachment, then each use must: use the same pname:layout
****

include::../validity/structs/VkSubpassDescription.txt[]

// refBegin VkAttachmentReference Structure specifying an attachment reference

The sname:VkAttachmentReference structure is defined as:

include::../api/structs/VkAttachmentReference.txt[]

  * pname:attachment is the index of the attachment of the render pass, and
    corresponds to the index of the corresponding element in the
    pname:pAttachments array of the sname:VkRenderPassCreateInfo structure.
    If any color or depth/stencil attachments are
    ename:VK_ATTACHMENT_UNUSED, then no writes occur for those attachments.
  * pname:layout is a elink:VkImageLayout value specifying the layout the
    attachment uses during the subpass.

.Valid Usage
****
  * pname:layout must: not be ename:VK_IMAGE_LAYOUT_UNDEFINED or
    ename:VK_IMAGE_LAYOUT_PREINITIALIZED
****

include::../validity/structs/VkAttachmentReference.txt[]

// refBegin VkSubpassDependency Structure specifying a subpass dependency

The sname:VkSubpassDependency structure is defined as:

include::../api/structs/VkSubpassDependency.txt[]

  * pname:srcSubpass is the subpass index of the first subpass in the
    dependency, or ename:VK_SUBPASS_EXTERNAL.
  * pname:dstSubpass is the subpass index of the second subpass in the
    dependency, or ename:VK_SUBPASS_EXTERNAL.
  * pname:srcStageMask defines a <<synchronization-pipeline-stages-masks,
    source stage mask>>.
  * pname:dstStageMask defines a <<synchronization-pipeline-stages-masks,
    destination stage mask>>.
  * pname:srcAccessMask defines a <<synchronization-access-masks, source
    access mask>>.
  * pname:dstAccessMask defines a <<synchronization-access-masks,
    destination access mask>>.
  * pname:dependencyFlags is a bitmask of elink:VkDependencyFlagBits.

If pname:srcSubpass is equal to pname:dstSubpass then the
slink:VkSubpassDependency describes a
<<synchronization-pipeline-barriers-subpass-self-dependencies, subpass
self-dependency>>, and only constrains the pipeline barriers allowed within
a subpass instance.
Otherwise, when a render pass instance which includes a subpass dependency
is submitted to a queue, it defines a memory dependency between the
subpasses identified by pname:srcSubpass and pname:dstSubpass.

If pname:srcSubpass is equal to ename:VK_SUBPASS_EXTERNAL, the first
<<synchronization-dependencies-scopes, synchronization scope>> includes
commands submitted to the queue before the render pass instance began.
Otherwise, the first set of commands includes all commands submitted as part
of the subpass instance identified by pname:srcSubpass and any load, store
or multisample resolve operations on attachments used in pname:srcSubpass.
In either case, the first synchronization scope is limited to operations on
the pipeline stages determined by the
<<synchronization-pipeline-stages-masks, source stage mask>> specified by
pname:srcStageMask.

If pname:dstSubpass is equal to ename:VK_SUBPASS_EXTERNAL, the second
<<synchronization-dependencies-scopes, synchronization scope>> includes
commands submitted after the render pass instance is ended.
Otherwise, the second set of commands includes all commands submitted as
part of the subpass instance identified by pname:dstSubpass and any load,
store or multisample resolve operations on attachments used in
pname:dstSubpass.
In either case, the second synchronization scope is limited to operations on
the pipeline stages determined by the
<<synchronization-pipeline-stages-masks, destination stage mask>> specified
by pname:dstStageMask.

The first <<synchronization-dependencies-access-scopes, access scope>> is
limited to access in the pipeline stages determined by the
<<synchronization-pipeline-stages-masks, source stage mask>> specified by
pname:srcStageMask.
It is also limited to access types in the <<synchronization-access-masks,
source access mask>> specified by pname:srcAccessMask.

The second <<synchronization-dependencies-access-scopes, access scope>> is
limited to access in the pipeline stages determined by the
<<synchronization-pipeline-stages-masks, destination stage mask>> specified
by pname:dstStageMask.
It is also limited to access types in the <<synchronization-access-masks,
destination access mask>> specified by pname:dstAccessMask.

The <<synchronization-dependencies-available-and-visible, availability and
visibility operations>> defined by a subpass dependency affect the execution
of <<renderpass-layout-transitions, image layout transitions>> within the
render pass.

.Valid Usage
****
  * If pname:srcSubpass is not ename:VK_SUBPASS_EXTERNAL, pname:srcStageMask
    must: not include ename:VK_PIPELINE_STAGE_HOST_BIT
  * If pname:dstSubpass is not ename:VK_SUBPASS_EXTERNAL, pname:dstStageMask
    must: not include ename:VK_PIPELINE_STAGE_HOST_BIT
  * If the <<features-features-geometryShader,geometry shaders>> feature is
    not enabled, pname:srcStageMask must: not contain
    ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * If the <<features-features-geometryShader,geometry shaders>> feature is
    not enabled, pname:dstStageMask must: not contain
    ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * If the <<features-features-tessellationShader,tessellation shaders>>
    feature is not enabled, pname:srcStageMask must: not contain
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * If the <<features-features-tessellationShader,tessellation shaders>>
    feature is not enabled, pname:dstStageMask must: not contain
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * pname:srcSubpass must: be less than or equal to pname:dstSubpass, unless
    one of them is ename:VK_SUBPASS_EXTERNAL, to avoid cyclic dependencies
    and ensure a valid execution order
  * pname:srcSubpass and pname:dstSubpass must: not both be equal to
    ename:VK_SUBPASS_EXTERNAL
  * If pname:srcSubpass is equal to pname:dstSubpass, pname:srcStageMask and
    pname:dstStageMask must: only contain one of
    ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
    ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
    ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
    ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
    ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
    ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
    ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
    ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, or
    ename:VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT
  * If pname:srcSubpass is equal to pname:dstSubpass, the
    <<synchronization-pipeline-stages-order, logically latest>> pipeline
    stage in pname:srcStageMask must: be
    <<synchronization-pipeline-stages-order, logically earlier>> than or
    equal to the <<synchronization-pipeline-stages-order, logically
    earliest>> pipeline stage in pname:dstStageMask
  * Any access flag included in pname:srcAccessMask must: be supported by
    one of the pipeline stages in pname:srcStageMask, as specified in the
    <<synchronization-access-types-supported, table of supported access
    types>>.
  * Any access flag included in pname:dstAccessMask must: be supported by
    one of the pipeline stages in pname:dstStageMask, as specified in the
    <<synchronization-access-types-supported, table of supported access
    types>>.
****

include::../validity/structs/VkSubpassDependency.txt[]

ifdef::editing-notes[]
[NOTE]
.editing-note
====
The following two alleged implicit dependencies are practically no-ops, as
the operations they describe are already guaranteed by semaphores and
submission order (so they're almost entirely no-ops on their own).
The *only* reason they exist is because it simplifies reasoning about where
<<renderpass-layout-transitions, automatic layout transitions>> happen.
Further rewrites of this chapter could potentially remove the need for
these.
====
endif::editing-notes[]

If there is no subpass dependency from ename:VK_SUBPASS_EXTERNAL to the
first subpass that uses an attachment, then an implicit subpass dependency
exists from ename:VK_SUBPASS_EXTERNAL to the first subpass it is used in.
The subpass dependency operates as if defined with the following parameters:

[source,c]
----
VkSubpassDependency implicitDependency = {
    .srcSubpass = VK_SUBPASS_EXTERNAL;
    .dstSubpass = firstSubpass; // First subpass attachment is used in
    .srcStageMask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
    .dstStageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
    .srcAccessMask = 0;
    .dstAccessMask = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT |
                     VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |
                     VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
                     VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
                     VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
    .dependencyFlags = 0;
};
----

Similarly, if there is no subpass dependency from the last subpass that uses
an attachment to ename:VK_SUBPASS_EXTERNAL, then an implicit subpass
dependency exists from the last subpass it is used in to
ename:VK_SUBPASS_EXTERNAL.
The subpass dependency operates as if defined with the following parameters:

[source,c]
----
VkSubpassDependency implicitDependency = {
    .srcSubpass = lastSubpass; // Last subpass attachment is used in
    .dstSubpass = VK_SUBPASS_EXTERNAL;
    .srcStageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
    .dstStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;
    .srcAccessMask = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT |
                     VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |
                     VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
                     VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
                     VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
    .dstAccessMask = 0;
    .dependencyFlags = 0;
};
----

[[renderpass-layout-transitions]]
As subpasses may: overlap or execute out of order with regards to other
subpasses unless a subpass dependency chain describes otherwise, the layout
transitions required between subpasses cannot: be known to an application.
Instead, an application provides the layout that each attachment must: be in
at the start and end of a renderpass, and the layout it must: be in during
each subpass it is used in.
The implementation then must: execute layout transitions between subpasses
in order to guarantee that the images are in the layouts required by each
subpass, and in the final layout at the end of the render pass.

Automatic layout transitions away from the layout used in a subpass
happen-after the availability operations for all dependencies with that
subpass as the pname:srcSubpass.

Automatic layout transitions into the layout used in a subpass happen-before
the visibility operations for all dependencies with that subpass as the
pname:dstSubpass.

Automatic layout transitions away from pname:initialLayout happens-after the
availability operations for all dependencies with a pname:srcSubpass equal
to ename:VK_SUBPASS_EXTERNAL, where pname:dstSubpass uses the attachment
that will be transitioned.
For attachments created with ename:VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,
automatic layout transitions away from pname:initialLayout happen-after the
availability operations for all dependencies with a pname:srcSubpass equal
to ename:VK_SUBPASS_EXTERNAL, where pname:dstSubpass uses any aliased
attachment.

Automatic layout transitions into pname:finalLayout happens-before the
visibility operations for all dependencies with a pname:dstSubpass equal to
ename:VK_SUBPASS_EXTERNAL, where pname:srcSubpass uses the attachment that
will be transitioned.
For attachments created with ename:VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,
automatic layout transitions into pname:finalLayout happen-before the
visibility operations for all dependencies with a pname:dstSubpass equal to
ename:VK_SUBPASS_EXTERNAL, where pname:srcSubpass uses any aliased
attachment.

If two subpasses use the same attachment in different layouts, and both
layouts are read-only, no subpass dependency needs to be specified between
those subpasses.
If an implementation treats those layouts separately, it must: insert an
implicit subpass dependency between those subpasses to separate the uses in
each layout.
The subpass dependency operates as if defined with the following parameters:

[source,c]
----
// Used for input attachments
VkPipelineStageFlags inputAttachmentStages = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
VkAccessFlags inputAttachmentAccess = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT;

// Used for depth/stencil attachments
VkPipelineStageFlags depthStencilAttachmentStages = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;
VkAccessFlags depthStencilAttachmentAccess = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT;

VkSubpassDependency implicitDependency = {
    .srcSubpass = firstSubpass;
    .dstSubpass = secondSubpass;
    .srcStageMask = inputAttachmentStages | depthStencilAttachmentStages;
    .dstStageMask = inputAttachmentStages | depthStencilAttachmentStages;
    .srcAccessMask = inputAttachmentAccess | depthStencilAttachmentAccess;
    .dstAccessMask = inputAttachmentAccess | depthStencilAttachmentAccess;
    .dependencyFlags = 0;
};
----

[[renderpass-feedbackloop]]
If a subpass uses the same attachment as both an input attachment and either
a color attachment or a depth/stencil attachment, writes via the color or
depth/stencil attachment are not automatically made visible to reads via the
input attachment, causing a _feedback loop_, except in any of the following
conditions:

  * If the color components or depth/stencil components read by the input
    attachment are mutually exclusive with the components written by the
    color or depth/stencil attachments, then there is no feedback loop.
    This requires the graphics pipelines used by the subpass to disable
    writes to color components that are read as inputs via the
    pname:colorWriteMask, and to disable writes to depth/stencil components
    that are read as inputs via pname:depthWriteEnable or
    pname:stencilTestEnable.
  * If the attachment is used as an input attachment and depth/stencil
    attachment only, and the depth/stencil attachment is not written to.
  * If a memory dependency is inserted between when the attachment is
    written and when it is subsequently read by later fragments.
    <<synchronization-pipeline-barriers, Pipeline barriers>> expressing a
    <<synchronization-pipeline-barriers-subpass-self-dependencies, subpass
    self-dependency>> are the only way to achieve this, and one must: be
    inserted every time a fragment will read values at a particular sample
    (x, y, layer, sample) coordinate, if those values have been written
    since the most recent pipeline barrier; or the since start of the
    subpass if there have been no pipeline barriers since the start of the
    subpass.

An attachment used as both an input attachment and a color attachment must:
be in the ename:VK_IMAGE_LAYOUT_GENERAL layout.
An attachment used as an input attachment and depth/stencil attachment must:
be in either ename:VK_IMAGE_LAYOUT_GENERAL or
ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL.
An attachment must: not be used as both a depth/stencil attachment and a
color attachment.

// refBegin vkDestroyRenderPass Destroy a render pass object

To destroy a render pass, call:

include::../api/protos/vkDestroyRenderPass.txt[]

  * pname:device is the logical device that destroys the render pass.
  * pname:renderPass is the handle of the render pass to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * All submitted commands that refer to pname:renderPass must: have
    completed execution
  * If sname:VkAllocationCallbacks were provided when pname:renderPass was
    created, a compatible set of callbacks must: be provided here
  * If no sname:VkAllocationCallbacks were provided when pname:renderPass
    was created, pname:pAllocator must: be `NULL`
****

include::../validity/protos/vkDestroyRenderPass.txt[]


[[renderpass-compatibility]]
== Render Pass 兼容性

帧缓冲区和图形管线是基于特定render pass对象创建的。它们必须只能被用于该render pass对象，或者
与之兼容的对象。

如果两个reference指向的附件有相同的格式和采样数量，或者两个都是ename:VK_ATTACHMENT_UNUSED，又或都指向`NULL`，
它们就是兼容的。

如果两个附件数组中对应位置元素都是是兼容的，那么这两个数组就是兼容的。
如果数组有不同的长度，个数少的数组中没有对应元素的位置都被当作ename:VK_ATTACHMENT_UNUSED对待。

两个render pass是兼容的，如果它们对应的颜色、输入、解析和深度/模板附件的引用是兼容的，
如果符合除了以下的条件，它们就是完全相同的：
  * 附件描述中初始和最终的图像布局
  * 附件描述中load 和 store操作
  * 附件一用的图像布局

如果帧缓冲区和render pass是通过相同的或者兼容的render pass创建的，那么它们是兼容的。


== 帧缓冲区

// refBegin VkFramebuffer Opaque handle to a framebuffer object

render pass操作通过 _帧缓存区_ 联系在一起。帧缓存区表示一个render pass实例使用的多个特定内存附件。

帧缓冲区通过sname:VkFramebuffer handle表示：

include::../api/handles/VkFramebuffer.txt[]

// refEnd VkFramebuffer

// refBegin vkCreateFramebuffer Create a new framebuffer object

To create a framebuffer, call:

include::../api/protos/vkCreateFramebuffer.txt[]

  * pname:device is the logical device that creates the framebuffer.
  * pname:pCreateInfo points to a slink:VkFramebufferCreateInfo structure
    which describes additional information about framebuffer creation.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pFramebuffer points to a sname:VkFramebuffer handle in which the
    resulting framebuffer object is returned.

include::../validity/protos/vkCreateFramebuffer.txt[]

// refBegin VkFramebufferCreateInfo Structure specifying parameters of a newly created framebuffer

The sname:VkFramebufferCreateInfo structure is defined as:

include::../api/structs/VkFramebufferCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags is reserved for future use.
  * pname:renderPass is a render pass that defines what render passes the
    framebuffer will be compatible with.
    See <<renderpass-compatibility,Render Pass Compatibility>> for details.
  * pname:attachmentCount is the number of attachments.
  * pname:pAttachments is an array of sname:VkImageView handles, each of
    which will be used as the corresponding attachment in a render pass
    instance.
  * pname:width, pname:height and pname:layers define the dimensions of the
    framebuffer.

被当作图像子资源使用的附件不能通过非附件用途的方式在render pass实例内部被使用。

[NOTE]
.注意
====
这个限制意味着render pass完全知道所有附件的所有用途，所以Vulkan实现能够正确的决定
何时及如何进行布局转变，何时并行执行subpass等。
====

[[renderpass-noattachments]]
It is legal for a subpass to use no color or depth/stencil attachments, and
rather use shader side effects such as image stores and atomics to produce
an output.
In this case, the subpass continues to use the pname:width, pname:height,
and pname:layers of the framebuffer to define the dimensions of the
rendering area, and the pname:rasterizationSamples from each pipeline's
slink:VkPipelineMultisampleStateCreateInfo to define the number of samples
used in rasterization; however, if
slink:VkPhysicalDeviceFeatures::pname:variableMultisampleRate is
code:VK_FALSE, then all pipelines to be bound with a given zero-attachment
subpass must: have the same value for
slink:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples.

.Valid Usage
****
  * pname:attachmentCount must: be equal to the attachment count specified
    in pname:renderPass
  * Any given element of pname:pAttachments that is used as a color
    attachment or resolve attachment by pname:renderPass must: have been
    created with a pname:usage value including
    ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
  * Any given element of pname:pAttachments that is used as a depth/stencil
    attachment by pname:renderPass must: have been created with a
    pname:usage value including
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
  * Any given element of pname:pAttachments that is used as an input
    attachment by pname:renderPass must: have been created with a
    pname:usage value including ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
  * Any given element of pname:pAttachments must: have been created with an
    elink:VkFormat value that matches the elink:VkFormat specified by the
    corresponding sname:VkAttachmentDescription in pname:renderPass
  * Any given element of pname:pAttachments must: have been created with a
    pname:samples value that matches the pname:samples value specified by
    the corresponding sname:VkAttachmentDescription in pname:renderPass
  * Any given element of pname:pAttachments must: have dimensions at least
    as large as the corresponding framebuffer dimension
  * Any given element of pname:pAttachments must: only specify a single mip
    level
  * Any given element of pname:pAttachments must: have been created with the
    identity swizzle
  * pname:width must: be greater than `0`.
  * pname:width must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxFramebufferWidth
  * pname:height must: be greater than `0`.
  * pname:height must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxFramebufferHeight
  * pname:layers must: be greater than `0`.
  * pname:layers must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxFramebufferLayers
ifdef::VK_KHR_maintenance1[]
  * Any given element of pname:pAttachments that is a 2D or 2D array image
    view taken from a 3D image must: not be a depth/stencil format
endif::VK_KHR_maintenance1[]
****

include::../validity/structs/VkFramebufferCreateInfo.txt[]

// refBegin vkDestroyFramebuffer Destroy a framebuffer object

To destroy a framebuffer, call:

include::../api/protos/vkDestroyFramebuffer.txt[]

  * pname:device is the logical device that destroys the framebuffer.
  * pname:framebuffer is the handle of the framebuffer to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * All submitted commands that refer to pname:framebuffer must: have
    completed execution
  * If sname:VkAllocationCallbacks were provided when pname:framebuffer was
    created, a compatible set of callbacks must: be provided here
  * If no sname:VkAllocationCallbacks were provided when pname:framebuffer
    was created, pname:pAllocator must: be `NULL`
****

include::../validity/protos/vkDestroyFramebuffer.txt[]


[[renderpass-commands]]
== Render Pass 命令

应用程序按照每个subpass记录一个命令到render pass实例，从render pass开始迭代，遍历subpass并记录命令到subpass，
直到render pass对象结束。

// refBegin vkCmdBeginRenderPass Begin a new render pass

To begin a render pass instance, call:

include::../api/protos/vkCmdBeginRenderPass.txt[]

  * pname:commandBuffer is the command buffer in which to record the
    command.
  * pname:pRenderPassBegin is a pointer to a slink:VkRenderPassBeginInfo
    structure (defined below) which indicates the render pass to begin an
    instance of, and the framebuffer the instance uses.
  * pname:contents specifies how the commands in the first subpass will be
    provided, and is one of the values:
+
--
// refBegin VkSubpassContents Specify how commands in the first subpass of a render pass are provided
include::../api/enums/VkSubpassContents.txt[]
--
+
如果pname:contents是ename:VK_SUBPASS_CONTENTS_INLINE，subpass的内容将被嵌入记录到主命令缓冲区，
次命令缓冲区不能在subpass内执行。
如果pname:contents是ename:VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS，内容将被记录到被主缓冲区调用的
次命令缓冲区，fname:vkCmdExecuteCommands是唯一的有效命令，直到fname:vkCmdNextSubpass 或者
fname:vkCmdEndRenderPass。

一个render pass实例开始后，命令缓冲区就准备好了记录命令到该render pass的第一个subpass。

.Valid Usage
****
  * If any of the pname:initialLayout or pname:finalLayout member of the
    sname:VkAttachmentDescription structures or the pname:layout member of
    the sname:VkAttachmentReference structures specified when creating the
    render pass specified in the pname:renderPass member of
    pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
    then the corresponding attachment image subresource of the framebuffer
    specified in the pname:framebuffer member of pname:pRenderPassBegin
    must: have been created with ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
    set
****

.Valid Usage
****
  * If any of the pname:initialLayout or pname:finalLayout member of the
    sname:VkAttachmentDescription structures or the pname:layout member of
    the sname:VkAttachmentReference structures specified when creating the
    render pass specified in the pname:renderPass member of
    pname:pRenderPassBegin is
    ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or
    ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the
    corresponding attachment image subresource of the framebuffer specified
    in the pname:framebuffer member of pname:pRenderPassBegin must: have
    been created with ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set
  * If any of the pname:initialLayout or pname:finalLayout member of the
    sname:VkAttachmentDescription structures or the pname:layout member of
    the sname:VkAttachmentReference structures specified when creating the
    render pass specified in the pname:renderPass member of
    pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
    then the corresponding attachment image subresource of the framebuffer
    specified in the pname:framebuffer member of pname:pRenderPassBegin
    must: have been created with ename:VK_IMAGE_USAGE_SAMPLED_BIT or
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set
  * If any of the pname:initialLayout or pname:finalLayout member of the
    sname:VkAttachmentDescription structures or the pname:layout member of
    the sname:VkAttachmentReference structures specified when creating the
    render pass specified in the pname:renderPass member of
    pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
    then the corresponding attachment image subresource of the framebuffer
    specified in the pname:framebuffer member of pname:pRenderPassBegin
    must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT set
  * If any of the pname:initialLayout or pname:finalLayout member of the
    sname:VkAttachmentDescription structures or the pname:layout member of
    the sname:VkAttachmentReference structures specified when creating the
    render pass specified in the pname:renderPass member of
    pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
    then the corresponding attachment image subresource of the framebuffer
    specified in the pname:framebuffer member of pname:pRenderPassBegin
    must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT set
  * If any of the pname:initialLayout members of the
    sname:VkAttachmentDescription structures specified when creating the
    render pass specified in the pname:renderPass member of
    pname:pRenderPassBegin is not ename:VK_IMAGE_LAYOUT_UNDEFINED, then each
    such pname:initialLayout must: be equal to the current layout of the
    corresponding attachment image subresource of the framebuffer specified
    in the pname:framebuffer member of pname:pRenderPassBegin
  * The pname:srcStageMask and pname:dstStageMask members of any element of
    the pname:pDependencies member of slink:VkRenderPassCreateInfo used to
    create pname:renderpass must: be supported by the capabilities of the
    queue family identified by the pname:queueFamilyIndex member of the
    slink:VkCommandPoolCreateInfo used to create the command pool which
    pname:commandBuffer was allocated from.
****

include::../validity/protos/vkCmdBeginRenderPass.txt[]

// refBegin VkRenderPassBeginInfo Structure specifying render pass begin info

The sname:VkRenderPassBeginInfo structure is defined as:

include::../api/structs/VkRenderPassBeginInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:renderPass is the render pass to begin an instance of.
  * pname:framebuffer is the framebuffer containing the attachments that are
    used with the render pass.
  * pname:renderArea is the render area that is affected by the render pass
    instance, and is described in more detail below.
  * pname:clearValueCount is the number of elements in pname:pClearValues.
  * pname:pClearValues is an array of slink:VkClearValue structures that
    contains clear values for each attachment, if the attachment uses a
    pname:loadOp value of ename:VK_ATTACHMENT_LOAD_OP_CLEAR or if the
    attachment has a depth/stencil format and uses a pname:stencilLoadOp
    value of ename:VK_ATTACHMENT_LOAD_OP_CLEAR.
    The array is indexed by attachment number.
    Only elements corresponding to cleared attachments are used.
    Other elements of pname:pClearValues are ignored.

pname:renderArea is the render area that is affected by the render pass
instance.
The effects of attachment load, store and multisample resolve operations are
restricted to the pixels whose x and y coordinates fall within the render
area on all attachments.
The render area extends to all layers of pname:framebuffer.
The application must: ensure (using scissor if necessary) that all rendering
is contained within the render area, otherwise the pixels outside of the
render area become undefined and shader side effects may: occur for
fragments outside the render area.
The render area must: be contained within the framebuffer dimensions.

[NOTE]
.Note
====
There may: be a performance cost for using a render area smaller than the
framebuffer, unless it matches the render area granularity for the render
pass.
====

.Valid Usage
****
  * pname:clearValueCount must: be greater than the largest attachment index
    in pname:renderPass that specifies a pname:loadOp (or
    pname:stencilLoadOp, if the attachment has a depth/stencil format) of
    ename:VK_ATTACHMENT_LOAD_OP_CLEAR
  * If pname:clearValueCount is not `0`, pname:pClearValues must: be a
    pointer to an array of pname:clearValueCount valid sname:VkClearValue
    unions
  * pname:renderPass must: be <<renderpass-compatibility,compatible>> with
    the pname:renderPass member of the sname:VkFramebufferCreateInfo
    structure specified when creating pname:framebuffer.
****

include::../validity/structs/VkRenderPassBeginInfo.txt[]

// refBegin vkGetRenderAreaGranularity Returns the granularity for optimal render area

To query the render area granularity, call:

include::../api/protos/vkGetRenderAreaGranularity.txt[]

  * pname:device is the logical device that owns the render pass.
  * pname:renderPass is a handle to a render pass.
  * pname:pGranularity points to a slink:VkExtent2D structure in which the
    granularity is returned.

The conditions leading to an optimal pname:renderArea are:

  * the pname:offset.x member in pname:renderArea is a multiple of the
    pname:width member of the returned slink:VkExtent2D (the horizontal
    granularity).
  * the pname:offset.y member in pname:renderArea is a multiple of the
    pname:height of the returned slink:VkExtent2D (the vertical
    granularity).
  * either the pname:offset.width member in pname:renderArea is a multiple
    of the horizontal granularity or pname:offset.x+pname:offset.width is
    equal to the pname:width of the pname:framebuffer in the
    slink:VkRenderPassBeginInfo.
  * either the pname:offset.height member in pname:renderArea is a multiple
    of the vertical granularity or pname:offset.y+pname:offset.height is
    equal to the pname:height of the pname:framebuffer in the
    slink:VkRenderPassBeginInfo.

Subpass dependencies are not affected by the render area, and apply to the
entire image subresources attached to the framebuffer.
Similarly, pipeline barriers are valid even if their effect extends outside
the render area.

include::../validity/protos/vkGetRenderAreaGranularity.txt[]

// refBegin vkCmdNextSubpass Transition to the next subpass of a render pass

To transition to the next subpass in the render pass instance after
recording the commands for a subpass, call:

include::../api/protos/vkCmdNextSubpass.txt[]

  * pname:commandBuffer is the command buffer in which to record the
    command.
  * pname:contents specifies how the commands in the next subpass will be
    provided, in the same fashion as the corresponding parameter of
    flink:vkCmdBeginRenderPass.

The subpass index for a render pass begins at zero when
fname:vkCmdBeginRenderPass is recorded, and increments each time
fname:vkCmdNextSubpass is recorded.

Moving to the next subpass automatically performs any multisample resolve
operations in the subpass being ended.
End-of-subpass multisample resolves are treated as color attachment writes
for the purposes of synchronization.
That is, they are considered to execute in the
ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT pipeline stage and their
writes are synchronized with ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT.
Synchronization between rendering within a subpass and any resolve
operations at the end of the subpass occurs automatically, without need for
explicit dependencies or pipeline barriers.
However, if the resolve attachment is also used in a different subpass, an
explicit dependency is needed.

After transitioning to the next subpass, the application can: record the
commands for that subpass.

.Valid Usage
****
  * The current subpass index must: be less than the number of subpasses in
    the render pass minus one
****

include::../validity/protos/vkCmdNextSubpass.txt[]

// refBegin vkCmdEndRenderPass End the current render pass

To record a command to end a render pass instance after recording the
commands for the last subpass, call:

include::../api/protos/vkCmdEndRenderPass.txt[]

  * pname:commandBuffer is the command buffer in which to end the current
    render pass instance.

Ending a render pass instance performs any multisample resolve operations on
the final subpass.

.Valid Usage
****
  * The current subpass index must: be equal to the number of subpasses in
    the render pass minus one
****

include::../validity/protos/vkCmdEndRenderPass.txt[]

