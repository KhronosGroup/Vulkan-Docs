// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[shaders]]
= 着色器

一个着色器指定了在图形和计算管线对应各阶段的每个顶点、控制点、细分顶点、图元、片元或者工作组 上执行的可编程的操作。

图形管线包括作为<<drawing,primitive assembly>>结果的顶点着色器执行，
紧接着是在<<drawing-primitive-topologies-patches,patches>>之上的
细分控制、求值着色器（如果开启了）操作，作用在图元之上的几何着色器（如果开启了），
操作于 <<primsrast,Rasterization>>产生的片元之上的片元着色器。
在本规范中，顶细分控制、细分求值、几何着色器都是指顶点处理阶段，发生在逻辑管线中栅格化之前。
片元着色器程序在栅格化之后运行。

只有计算着色器阶段被包含在计算管线中。计算着色器操作一个工作组中的一些调用。

着色器可以从输入变量中读取，从输出变量中读取或者写入。
输入和输出变量可以被用来在不同着色器阶段之间转移数据，或者允许着色器和执行环境中变量值直接交互。
同样的，执行环境也提供了描述性能的常量。

着色器变量和执行环境提供的着色器内部_built-in_修饰的输入和输出变量相关。
对于每个阶段可用的修饰符在下面小节中列出。


[[shader-modules]]
== 着色器模块

// refBegin VkShaderModule Opaque handle to a shader module object
_Shader modules_ 包含 _shader code_ 和一个或多个入口点。
可通过指定一个入口点作为创建<<pipelines,pipeline>>的一部分来从着色器模块中选择着色器。
管线的阶段可以使用来自不同模块的着色器。定义了一个着色器模块的着色器代码必须是SPIR-V格式，
在附录 <<spirvenv,Vulkan Environment for SPIR-V>> 有描述。

着色器模块通过sname:VkShaderModule handles表示：

include::../api/handles/VkShaderModule.txt[]

// refEnd VkShaderModule

// refBegin vkCreateShaderModule Creates a new shader module object

To create a shader module, call:

include::../api/protos/vkCreateShaderModule.txt[]

  * pname:device is the logical device that creates the shader module.
  * pname:pCreateInfo parameter is a pointer to an instance of the
    sname:VkShaderModuleCreateInfo structure.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pShaderModule points to a sname:VkShaderModule handle in which the
    resulting shader module object is returned.

一旦着色器模块被创建完成，它所包含的入口点在<<pipelines-compute,Compute Pipelines>> 
和 <<pipelines-graphics,Graphics Pipelines>>中描述的管线阶段。


ifdef::VK_NV_glsl_shader[]
如果着色器阶段编译失败，将会返回ename:VK_ERROR_INVALID_SHADER_NV，如果 +VK_EXT_debug_report+ 开启了，
编译日志将会被报告到应用程序。
endif::VK_NV_glsl_shader[]

include::../validity/protos/vkCreateShaderModule.txt[]

// refBegin VkShaderModuleCreateInfo Structure specifying parameters of a newly created shader module

The sname:VkShaderModuleCreateInfo structure is defined as:

include::../api/structs/VkShaderModuleCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags is reserved for future use.
  * pname:codeSize is the size, in bytes, of the code pointed to by
    pname:pCode.
  * pname:pCode points to code that is used to create the shader module.
    The type and format of the code is determined from the content of the
    memory addressed by pname:pCode.

.Valid Usage
****
  * pname:codeSize must: be greater than 0
  * pname:codeSize must: be a multiple of 4.
    If the +VK_NV_glsl_shader extension+ is enabled and pname:pCode
    references GLSL code pname:codeSize can be a multiple of 1
  * pname:pCode must: point to valid SPIR-V code, formatted and packed as
    described by the <<spirv-spec,Khronos SPIR-V Specification>>.
    If the +VK_NV_glsl_shader+ extension is enabled pname:pCode can instead
    reference valid GLSL code and must: be written to the
    +GL_KHR_vulkan_glsl+ extension specification
  * pname:pCode must: adhere to the validation rules described by the
    <<spirvenv-module-validation, Validation Rules within a Module>> section
    of the <<spirvenv-capabilities,SPIR-V Environment>> appendix.
    If the +VK_NV_glsl_shader+ extension is enabled pname:pCode can be valid
    GLSL code with respect to the +GL_KHR_vulkan_glsl+ GLSL extension
    specification
  * pname:pCode must: declare the code:Shader capability for SPIR-V code
  * pname:pCode must: not declare any capability that is not supported by
    the API, as described by the <<spirvenv-module-validation,
    Capabilities>> section of the <<spirvenv-capabilities,SPIR-V
    Environment>> appendix
  * If pname:pCode declares any of the capabilities that are listed as not
    required by the implementation, the relevant feature must: be enabled,
    as listed in the <<spirvenv-capabilities-table,SPIR-V Environment>>
    appendix
****

include::../validity/structs/VkShaderModuleCreateInfo.txt[]

// refBegin vkDestroyShaderModule Destroy a shader module module

To destroy a shader module, call:

include::../api/protos/vkDestroyShaderModule.txt[]

  * pname:device is the logical device that destroys the shader module.
  * pname:shaderModule is the handle of the shader module to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

A shader module can: be destroyed while pipelines created using its shaders
are still in use.

.Valid Usage
****
  * If sname:VkAllocationCallbacks were provided when pname:shaderModule was
    created, a compatible set of callbacks must: be provided here
  * If no sname:VkAllocationCallbacks were provided when pname:shaderModule
    was created, pname:pAllocator must: be `NULL`
****

include::../validity/protos/vkDestroyShaderModule.txt[]


[[shaders-execution]]
== 着色器的执行

在管线的每一个阶段，对着色器的多次调用可能同时执行。
甚至，多个命令都调用的单个着色器也可以同时执行。
调用同一个着色器类型所产生的相对执行顺序也是未知的。
应用程序绘制命令或者分发命令产生的图元的顺序和着色器调用完成的顺序也可能不一致。
然而，片元着色器输出到附件依<<primrast-order, 栅格化顺序>>。

不同着色器类型调用的相对顺序基本上是未定义的。
然而，当调用的着色器的输入是前一个管线阶段的输出时，可以保证前一个阶段在产生所有必需的输入信息之前已经完成了。


[[shaders-execution-memory-ordering]]
== 着色器内存访问顺序
着色器读取或者写入图像或缓冲区的顺序基本上是未定义的。
对于一些着色器类型（顶点、细分求值和某些情况下的片元着色器），甚至是可能进行加载和存储的着色器调用的次数也是未定义的。

In particular, the following rules apply:

  * <<shaders-vertex-execution,Vertex>> and
    <<shaders-tessellation-evaluation-execution,tessellation evaluation>>
    shaders will be invoked at least once for each unique vertex, as defined
    in those sections.
  * <<shaders-fragment-execution,Fragment>> shaders will be invoked zero or
    more times, as defined in that section.
  * The relative order of invocations of the same shader type are undefined.
    A store issued by a shader when working on primitive B might complete
    prior to a store for primitive A, even if primitive A is specified prior
    to primitive B.
    This applies even to fragment shaders; while fragment shader outputs are
    always written to the framebuffer in <<primrast-order, rasterization
    order>>, stores executed by fragment shader invocations are not.
  * The relative order of invocations of different shader types is largely
    undefined.

[NOTE]
.注意
====
上述的对于着色器调用的顺序的限制形成了在一系列的不可能实现的图元上着色器调用之间的同步。
For example, having one invocation poll memory written by another invocation
assumes that the other invocation has been launched and will complete its
writes in finite time.
====

Stores issued to different memory locations within a single shader
invocation may: not be visible to other invocations, or may: not become
visible in the order they were performed.

The code:OpMemoryBarrier instruction can: be used to provide stronger
ordering of reads and writes performed by a single invocation.
code:OpMemoryBarrier guarantees that any memory transactions issued by the
shader invocation prior to the instruction complete prior to the memory
transactions issued after the instruction.
Memory barriers are needed for algorithms that require multiple invocations
to access the same memory and require the operations to be performed in a
partially-defined relative order.
For example, if one shader invocation does a series of writes, followed by
an code:OpMemoryBarrier instruction, followed by another write, then the
results of the series of writes before the barrier become visible to other
shader invocations at a time earlier or equal to when the results of the
final write become visible to those invocations.
In practice it means that another invocation that sees the results of the
final write would also see the previous writes.
Without the memory barrier, the final write may: be visible before the
previous writes.

Writes that are the result of shader stores through a variable decorated
with code:Coherent automatically have available writes to the same buffer,
buffer view, or image view made visible to them, and are themselves
automatically made available to access by the same buffer, buffer view, or
image view.
Reads that are the result of shader loads through a variable decorated with
code:Coherent automatically have available writes to the same buffer, buffer
view, or image view made visible to them.
The order that coherent writes to different locations become available is
undefined, unless enforced by a memory barrier instruction or other memory
dependency.

.Note
[注意]
====
显式的内存依赖仍然需要使用，来保证对其他缓冲区、缓冲区视图、图像视图的访问的可用性和可见性。
====

内置的内存事务指令可以用来对给定内存地址读取或者写作的原子性。
当多个着色器调用内置的原子函数互相之间按照未定义的顺序执行时，这些函数都对一个内存地址进行内存读写操作，
且保证没有其他的内存事务将在读写期间对潜在的内存写入。
原子操作像对code:Coherent变量一样，保证了读写操作的可用性和可见性。

.注意
[[Note]]
====
在同一份内存上不同资源描述符进行内存访问，甚至有code:Coherent修饰符或通过原子操作，也可能是没有良好定义的，
因为诸如图像布局或者资源归属（<<synchronization, Synchronization and Cache Control>>一章中讲解）等原因。
====

[NOTE]
.注意
====
原子操作允许着色器使用共享全局地址作为互斥性或者作为计数器，或其他用途。
====


[[shaders-inputs]]
== 着色器的输入和输出
数据通过 input 和 output修饰的变量传入和传出着色器。
在不同阶段之间用户自定义的输入和输出是通过匹配code:Location修饰符来联系起来的。
另外，可以使用 code:BuiltIn 修饰符来对执行环境中特殊函数提供数据或进行数据交换。

在很多场合下，同一个code:BuiltIn可以在多个着色器阶段使用，含义相近。
code:BuiltIn修饰的变量的行为在下面小节中有记录。


[[shaders-vertex]]
== 顶点着色器
对每一个顶点和它相关的<<fxvertex-attrib,vertex attribute>>数据，都调用一次顶点着色器，
输出一个顶点和相关的数据。
图形管线必须包含一个顶点着色器，且顶点着色器阶段始终都是图形管线的第一个阶段。


[[shaders-vertex-execution]]
=== 顶点着色器的执行
在一个绘制命令中，对于一个顶点至少执行一次。
在执行期间，对着色器提供了顶点的索引和顶点本身数据。
在着色器内声明的输入变量通过Vulkan实现填充与调用关联的顶点属性值。

如果在一个绘制命令中同一个顶点出现多次（），且如果顶点着色总是产生相同的结果，
Vulkan实现也许会重用该结果。


[NOTE]
.注意
==================
顶点着色的结果什么时候、是否被重用以及顶点着色器被执行多少次，都是依赖于Vulkan实现的。
当顶点着色器包含存储或者原子操作时依然如此（参看
<<features-features-vertexPipelineStoresAndAtomics, pname:vertexPipelineStoresAndAtomics>>）。
==================



[[shaders-tessellation-control]]
== 细分控制着色器
细分控制着色器是用来读取应用程序提供的输入图元，并产生一个输出图元。
对于一个图元及关联的数据，调用一次细分控制着色器（在顶点着色器处理完一个图元所有的顶点之后），
并每一个输出图元输出一个控制点及关联数据，也可以输出附加的图元数据。
按照slink:VkPipelineTessellationStateCreateInfo的pname:patchControlPoints成员来调整输入图元的顶点个数，
这是输入组装的一部分。
输出图元的大小由细分控制或细分求值着色器指定的code:OpExecutionMode code:OutputVertices 控制，
至少在其中一个着色器中指定。
输入、输出图元的大小必须大于0，不大于sname:VkPhysicalDeviceLimits::pname:maxTessellationPatchSize。


[[shaders-tessellation-control-execution]]
=== 细分控制着色器的执行
对于一个图元内每一个 _output_ 顶点都至少调用一次细分控制着色器。

细分控制着色器的输入是由顶点着色器生成的。
每一次细分控制着色器调用可以读取任何一个输入的顶点的属性和它关联的数据。
对于一个给定图元的多次着色器调用逻辑上并行执行，相对顺序是未定义的。
然而，通过在一个图元内同步着色器调用，code:OpControlBarrier 指令可以用来提供对执行顺序的有限度的控制，
有效地把细分控制着色器执行划分为多个周期。
如果一次调用在同一个周期内读取被其他调用写入的逐顶点或者逐图元属性，
或者两个调用尝试在一个周期内向一个图元输出写入，细分控制着色器将读取到未定义的值。


[[shaders-tessellation-evaluation]]
== 细分求值着色器（Tessellation Evaluation Shaders）

细分求值着色器在控制点组成的输入图元和它关联数据上进行操作，单个输入重心坐标表示了在子图元中调用的对象的相对位置，
输入单个顶点和关联数据。


[[shaders-tessellation-evaluation-execution]]
=== 细分求值着色器的执行

对细分器生成的每一个顶点至少调用一次细分求值着色器。


[[shaders-geometry]]
== 几何着色器
几何着色器在一个输入图元上一系列的顶点和它们关联的数据上进行操作，输入零个或者多个输出图元，和它们的顶点及输出每个图元
需要的关联数据。


[[shaders-geometry-execution]]
=== 几何着色器的执行
对于细分阶段产生的每一个图元，几何着色器至少被调用一次，或者没有使用细分时<<drawing,primitive assembly>>
生成的每一个图元都调用至少一次。
每一个输入图元调用几何着色器的次数是由几何着色器中code:OpExecutionMode code:Invocations指定的每图元几何着色器调用次数
决定。
如果调用次数未指定，默认只调用一次。


[[shaders-fragment]]
== 片元着色器
片元着色器作为图形管线栅格化的结果被调用。
每一次片元着色器调用都作用在一个片元和它关联的数据上。
除了少数例外，片元着色器并不访问其他片元关联的数据，和其他片元关联的片元着色器的执行之间是孤立的。


[[shaders-fragment-execution]]
=== 片元着色器的执行

对于栅格化产生的每个片元，一个片元着色器都被调用一次。
如果 <<fragops-early,Early Per-Fragment Tests>>导致它没有被覆盖到 ，一个片元着色器就不能被调用。
还有，如果第一个图元栅格化生成的片元的输出将会被同一个subpass中第二个图元栅格化产生的片元所覆盖，
且该片元所对应的片元着色器没有其他副作用，那么第一个图元中这个片元可能不需要执行片元着色器。

不同的片元着色器相对的执行顺序是未定义的。

每一个像素对应的片元着色器调用次数由以下规则决定：

  * 如果开启了逐采样着色，每一个被覆盖的采样点都被执行一次。
  * 否则，每一个片元都至少需要执行一次片元着色器，但是每一个覆盖到的采样点无需执行多次。

关于片元着色器调用，除了上面强调的条件外，片元着色器也可被 _helper invocation_ 产生。
一个 helper invocation是一次片元着色器调用，只为了给非helper 片元着色器求导而产生的。
helper 调用所执行的存储和原子操作不能给内存造成任何副作用，helper调用中原子指令返回的值是为定义的。


[[shaders-fragment-earlytest]]
=== 早期片元测试

Vulkan提供了显式的控制，允许片元着色器开启早期片元测试。如果片元着色器指定了code:EarlyFragmentTests code:OpExecutionMode，
在<<fragops-early-mode,Early Fragment Test Mode>>中描述过的逐片元测试发生在片元着色器执行之前。
否则，它们在片元着色器执行之后才被执行。


[[shaders-compute]]
== 计算着色器

Compute shaders are invoked via flink:vkCmdDispatch and
flink:vkCmdDispatchIndirect commands.
In general, they have access to similar resources as shader stages executing
as part of a graphics pipeline.

Compute workloads are formed from groups of work items called workgroups and
processed by the compute shader in the current compute pipeline.
A workgroup is a collection of shader invocations that execute the same
shader, potentially in parallel.
Compute shaders execute in _global workgroups_ which are divided into a
number of _local workgroups_ with a size that can: be set by assigning a
value to the code:LocalSize execution mode or via an object decorated by the
code:WorkgroupSize decoration.
An invocation within a local workgroup can: share data with other members of
the local workgroup through shared variables and issue memory and control
flow barriers to synchronize with other members of the local workgroup.


[[shaders-interpolation-decorations]]
== 插值修饰（Interpolation Decorations）
插值修饰控制了片元着色器阶段插值属性的行为。
插值修饰可以应用到片元着色器的 code:Input 存储类变量，并控制这些变量的插值行为。

输入变量最多可以被下列描述符中的一个所修饰：

  * code:Flat: 无插值
  * code:NoPerspective: 线性插值 (对于 <<line_linear_interpolation, 线>> 和 <<triangle_linear_interpolation, 多边形>>来说).

不被 code:Flat 和 code:NoPerspective 修饰的片元输入变量，使用透视插值（对
<<line_perspective_interpolation,线>> 和 <<triangle_perspective_interpolation, 多边形>>来说）。
 
插值的类型和是否被应用是被上述插值修饰符所控制的，同样也被附加的 code:Centroid 和 code:Sample 所描述。

一个被 code:Flat 修饰的变量将不会被插值。
相反，三角形内每一个片元都保持相同的值。这个值从单个<<vertexpostproc-flatshading, provoking vertex>> 中获取。
一个被 code:Flat 修饰的变量也可以被 code:Centroid 或者 code:Sample 修饰，这表示和只有 code:Flat 修饰时一样的效果。

对于不是 code:Centroid 或 code:Sample 修饰的片元着色器输入变量，被赋值的变量也许会插值到像素内任意位置，一个值也许被赋值给像素内每一个采样点。

code:Centroid 和 code:Sample 可以被用于控制被修饰着色器输入变量采样的位置和频率。
如果一个片元着色器输入变量被  code:Centroid 修饰，像素内所有采样点都会被赋值为同一个值，但是这个值必须必须要被插值到一个位置，该位置在像素和被渲染的图元上，
包括这个图元覆盖的像素采样点中任一个点。
因为变量被插值的位置可能在临近的像素上，导数可能以两个临近像素来做计算， centroid-sampled 输入变量的导数可能比 non-centroid 插值的变量准确度偏低。
如果一个片元着色器输入被 code:Sample 修饰，对于该像素覆盖的每一个采样点都需要赋值一个单独的值，这个值必须从不同的采样点采样获取到。
当 pname:rasterizationSamples 是 ename:VK_SAMPLE_COUNT_1_BIT时，像素中心必须被用作 code:Centroid, code:Sample, 和无描述采样。

有、无符号整型，整型向量，或者双精度浮点类型片元着色器输入变量必须以 code:Flat 描述。


ifdef::VK_AMD_shader_explicit_vertex_parameter[]
When the +VK_AMD_shader_explicit_vertex_parameter+ device extension is
enabled inputs can: be also decorated with the code:CustomInterpAMD
interpolation decoration, including fragment shader inputs that are signed
or unsigned integers, integer vectors, or any double-precision
floating-point type.
Inputs decorated with code:CustomInterpAMD can: only be accessed by the
extended instruction code:InterpolateAtVertexAMD and allows accessing the
value of the input for individual vertices of the primitive.
endif::VK_AMD_shader_explicit_vertex_parameter[]


[[shaders-staticuse]]
== 静态使用

一个SPIR-V模块使用code:OpVariable指令在内存中声明一个全局对象，将产生一个code:x指针指向该对象。
如果一个入口点的调用栈包含一个函数，该函数包含这个以code:id为操作对象的内存指令或者图像指令code:x，
一个SPIR-V模块中该特定的入口点被称为_静态使用_该对象。参看SPIR-V规范第三小节 "`Binary Form`"的"`Memory Instructions`" 和 "`Image Instructions`"
来获取完整的SPIR-V内存指令。

静态使用并不以code:Input和 code:Output storage用来控制变量的行为。这些变量的效果基于它们是否在着色器入口点接口中出现来生效。


[[shaders-invocationgroups]]
== 调用和衍生组

一个计算着色器的_调用组_（参看SPIR-V规范第二节的"`Control Flow`"）是在单个本地工作组内一系列调用的集合。
对于图形着色器，一个调用组是在单个绘制命令内产生的指定着色器阶段的着色器调用集合的Vulkan实现各异的子集合。
对于pname:drawCount大于1的间接绘制命令，单个绘制内的调用在不同的调用组中。

[NOTE]
.注意
====
因为把调用分组为调用群依赖于Vulkan实现，且不可观测，应用程序一般需要假设在属于一个调用群的绘制操作所有调用的最糟糕情形。
====

A _derivative group_ (see the subsection "`Control Flow`" of section 2 of
the SPIR-V 1.00 Revision 4 specification) for a fragment shader is the set
of invocations generated by a single primitive (point, line, or triangle),
including any helper invocations generated by that primitive.
Derivatives are undefined for a sampled image instruction if the instruction
is in flow control that is not uniform across the derivative group.
