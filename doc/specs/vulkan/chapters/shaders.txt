// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[shaders]]
= 着色器

一个着色器指定了在图形和计算管线对应各阶段的每个顶点、控制点、细分顶点、图元、片元或者工作组 上执行的可编程的操作。

图形管线包括作为<<drawing,primitive assembly>>结果的顶点着色器执行，
紧接着是在<<drawing-primitive-topologies-patches,patches>>之上的
细分控制、求值着色器（如果开启了）操作，作用在图元之上的几何着色器（如果开启了），
操作于 <<primsrast,Rasterization>>产生的片元之上的片元着色器。
在本规范中，顶细分控制、细分求值、几何着色器都是指顶点处理阶段，发生在逻辑管线中栅格化之前。
片元着色器程序在栅格化之后运行。

只有计算着色器阶段被包含在计算管线中。计算着色器操作一个工作组中的一些调用。

着色器可以从输入变量中读取，从输出变量中读取或者写入。
输入和输出变量可以被用来在不同着色器阶段之间转移数据，或者允许着色器和执行环境中变量值直接交互。
同样的，执行环境也提供了描述性能的常量。

着色器变量和执行环境提供的着色器内部_built-in_修饰的输入和输出变量相关。
对于每个阶段可用的修饰符在下面小节中列出。


[[shader-modules]]
== 着色器模块

// refBegin VkShaderModule Opaque handle to a shader module object
_Shader modules_ 包含 _shader code_ 和一个或多个入口点。
可通过指定一个入口点作为创建<<pipelines,pipeline>>的一部分来从着色器模块中选择着色器。
管线的阶段可以使用来自不同模块的着色器。定义了一个着色器模块的着色器代码必须是SPIR-V格式，
在附录 <<spirvenv,Vulkan Environment for SPIR-V>> 有描述。

着色器模块通过sname:VkShaderModule handles表示：

include::../api/handles/VkShaderModule.txt[]

// refEnd VkShaderModule

// refBegin vkCreateShaderModule Creates a new shader module object

To create a shader module, call:

include::../api/protos/vkCreateShaderModule.txt[]

  * pname:device is the logical device that creates the shader module.
  * pname:pCreateInfo parameter is a pointer to an instance of the
    sname:VkShaderModuleCreateInfo structure.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pShaderModule points to a sname:VkShaderModule handle in which the
    resulting shader module object is returned.

一旦着色器模块被创建完成，它所包含的入口点在<<pipelines-compute,Compute Pipelines>> 
和 <<pipelines-graphics,Graphics Pipelines>>中描述的管线阶段。


ifdef::VK_NV_glsl_shader[]
如果着色器阶段编译失败，将会返回ename:VK_ERROR_INVALID_SHADER_NV，如果 +VK_EXT_debug_report+ 开启了，
编译日志将会被报告到应用程序。
endif::VK_NV_glsl_shader[]

include::../validity/protos/vkCreateShaderModule.txt[]

// refBegin VkShaderModuleCreateInfo Structure specifying parameters of a newly created shader module

The sname:VkShaderModuleCreateInfo structure is defined as:

include::../api/structs/VkShaderModuleCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags is reserved for future use.
  * pname:codeSize is the size, in bytes, of the code pointed to by
    pname:pCode.
  * pname:pCode points to code that is used to create the shader module.
    The type and format of the code is determined from the content of the
    memory addressed by pname:pCode.

.Valid Usage
****
  * pname:codeSize must: be greater than 0
  * pname:codeSize must: be a multiple of 4.
    If the +VK_NV_glsl_shader extension+ is enabled and pname:pCode
    references GLSL code pname:codeSize can be a multiple of 1
  * pname:pCode must: point to valid SPIR-V code, formatted and packed as
    described by the <<spirv-spec,Khronos SPIR-V Specification>>.
    If the +VK_NV_glsl_shader+ extension is enabled pname:pCode can instead
    reference valid GLSL code and must: be written to the
    +GL_KHR_vulkan_glsl+ extension specification
  * pname:pCode must: adhere to the validation rules described by the
    <<spirvenv-module-validation, Validation Rules within a Module>> section
    of the <<spirvenv-capabilities,SPIR-V Environment>> appendix.
    If the +VK_NV_glsl_shader+ extension is enabled pname:pCode can be valid
    GLSL code with respect to the +GL_KHR_vulkan_glsl+ GLSL extension
    specification
  * pname:pCode must: declare the code:Shader capability for SPIR-V code
  * pname:pCode must: not declare any capability that is not supported by
    the API, as described by the <<spirvenv-module-validation,
    Capabilities>> section of the <<spirvenv-capabilities,SPIR-V
    Environment>> appendix
  * If pname:pCode declares any of the capabilities that are listed as not
    required by the implementation, the relevant feature must: be enabled,
    as listed in the <<spirvenv-capabilities-table,SPIR-V Environment>>
    appendix
****

include::../validity/structs/VkShaderModuleCreateInfo.txt[]

// refBegin vkDestroyShaderModule Destroy a shader module module

To destroy a shader module, call:

include::../api/protos/vkDestroyShaderModule.txt[]

  * pname:device is the logical device that destroys the shader module.
  * pname:shaderModule is the handle of the shader module to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

A shader module can: be destroyed while pipelines created using its shaders
are still in use.

.Valid Usage
****
  * If sname:VkAllocationCallbacks were provided when pname:shaderModule was
    created, a compatible set of callbacks must: be provided here
  * If no sname:VkAllocationCallbacks were provided when pname:shaderModule
    was created, pname:pAllocator must: be `NULL`
****

include::../validity/protos/vkDestroyShaderModule.txt[]


[[shaders-execution]]
== 着色器的执行

在管线的每一个阶段，对着色器的多次调用可能同时执行。
甚至，多个命令都调用的单个着色器也可以同时执行。
调用同一个着色器类型所产生的相对执行顺序也是未知的。
应用程序绘制命令或者分发命令产生的图元的顺序和着色器调用完成的顺序也可能不一致。
然而，片元着色器输出到附件依<<primrast-order, 栅格化顺序>>。

不同着色器类型调用的相对顺序基本上是未定义的。
然而，当调用的着色器的输入是前一个管线阶段的输出时，可以保证前一个阶段在产生所有必需的输入信息之前已经完成了。


[[shaders-execution-memory-ordering]]
== 着色器内存访问顺序
着色器读取或者写入图像或缓冲区的顺序基本上是未定义的。
对于一些着色器类型（顶点、细分求值和某些情况下的片元着色器），甚至是可能进行加载和存储的着色器调用的次数也是未定义的。

In particular, the following rules apply:

  * <<shaders-vertex-execution,Vertex>> and
    <<shaders-tessellation-evaluation-execution,tessellation evaluation>>
    shaders will be invoked at least once for each unique vertex, as defined
    in those sections.
  * <<shaders-fragment-execution,Fragment>> shaders will be invoked zero or
    more times, as defined in that section.
  * The relative order of invocations of the same shader type are undefined.
    A store issued by a shader when working on primitive B might complete
    prior to a store for primitive A, even if primitive A is specified prior
    to primitive B.
    This applies even to fragment shaders; while fragment shader outputs are
    always written to the framebuffer in <<primrast-order, rasterization
    order>>, stores executed by fragment shader invocations are not.
  * The relative order of invocations of different shader types is largely
    undefined.

[NOTE]
.注意
====
上述的对于着色器调用的顺序的限制形成了在一系列的不可能实现的图元上着色器调用之间的同步。
For example, having one invocation poll memory written by another invocation
assumes that the other invocation has been launched and will complete its
writes in finite time.
====

Stores issued to different memory locations within a single shader
invocation may: not be visible to other invocations, or may: not become
visible in the order they were performed.

The code:OpMemoryBarrier instruction can: be used to provide stronger
ordering of reads and writes performed by a single invocation.
code:OpMemoryBarrier guarantees that any memory transactions issued by the
shader invocation prior to the instruction complete prior to the memory
transactions issued after the instruction.
Memory barriers are needed for algorithms that require multiple invocations
to access the same memory and require the operations to be performed in a
partially-defined relative order.
For example, if one shader invocation does a series of writes, followed by
an code:OpMemoryBarrier instruction, followed by another write, then the
results of the series of writes before the barrier become visible to other
shader invocations at a time earlier or equal to when the results of the
final write become visible to those invocations.
In practice it means that another invocation that sees the results of the
final write would also see the previous writes.
Without the memory barrier, the final write may: be visible before the
previous writes.

Writes that are the result of shader stores through a variable decorated
with code:Coherent automatically have available writes to the same buffer,
buffer view, or image view made visible to them, and are themselves
automatically made available to access by the same buffer, buffer view, or
image view.
Reads that are the result of shader loads through a variable decorated with
code:Coherent automatically have available writes to the same buffer, buffer
view, or image view made visible to them.
The order that coherent writes to different locations become available is
undefined, unless enforced by a memory barrier instruction or other memory
dependency.

.Note
[注意]
====
显式的内存依赖仍然需要使用，来保证对其他缓冲区、缓冲区视图、图像视图的访问的可用性和可见性。
====

内置的内存事务指令可以用来对给定内存地址读取或者写作的原子性。
当多个着色器调用内置的原子函数互相之间按照未定义的顺序执行时，这些函数都对一个内存地址进行内存读写操作，
且保证没有其他的内存事务将在读写期间对潜在的内存写入。
原子操作像对code:Coherent变量一样，保证了读写操作的可用性和可见性。

.Note
[[注意]]
====
在同一份内存上不同资源描述符进行内存访问，甚至有code:Coherent修饰符或通过原子操作，也可能是没有良好定义的，
因为诸如图像布局或者资源归属（<<synchronization, Synchronization and Cache Control>>一章中讲解）等原因。
====

[NOTE]
.注意
====
原子操作允许着色器使用共享全局地址作为互斥性或者作为计数器，或其他用途。
====


[[shaders-inputs]]
== 着色器的输入和输出
数据通过 input 和 output修饰的变量传入和传出着色器。
在不同阶段之间用户自定义的输入和输出是通过匹配code:Location修饰符来联系起来的。
另外，可以使用 code:BuiltIn 修饰符来对执行环境中特殊函数提供数据或进行数据交换。

在很多场合下，同一个code:BuiltIn可以在多个着色器阶段使用，含义相近。
code:BuiltIn修饰的变量的行为在下面小节中有记录。


[[shaders-vertex]]
== 顶点着色器
对每一个顶点和它相关的<<fxvertex-attrib,vertex attribute>>数据，都调用一次顶点着色器，
输出一个顶点和相关的数据。
图形管线必须包含一个顶点着色器，且顶点着色器阶段始终都是图形管线的第一个阶段。


[[shaders-vertex-execution]]
=== 顶点着色器的执行
在一个绘制命令中，对于一个顶点至少执行一次。
在执行期间，对着色器提供了顶点的索引和顶点本身数据。
在着色器内声明的输入变量通过Vulkan实现填充与调用关联的顶点属性值。

如果在一个绘制命令中同一个顶点出现多次（），且如果顶点着色总是产生相同的结果，
Vulkan实现也许会重用该结果。


[NOTE]
.注意
==================
顶点着色的结果什么时候、是否被重用以及顶点着色器被执行多少次，都是依赖于Vulkan实现的。
当顶点着色器包含存储或者原子操作时依然如此（参看
<<features-features-vertexPipelineStoresAndAtomics, pname:vertexPipelineStoresAndAtomics>>）。
==================



[[shaders-tessellation-control]]
== 细分控制着色器
细分控制着色器是用来读取应用程序提供的输入图元，并产生一个输出图元。
对于一个图元及关联的数据，调用一次细分控制着色器（在顶点着色器处理完一个图元所有的顶点之后），
并每一个输出图元输出一个控制点及关联数据，也可以输出附加的图元数据。
按照slink:VkPipelineTessellationStateCreateInfo的pname:patchControlPoints成员来调整输入图元的顶点个数，
这是输入组装的一部分。
输出图元的大小由细分控制或细分求值着色器指定的code:OpExecutionMode code:OutputVertices 控制，
至少在其中一个着色器中指定。
输入、输出图元的大小必须大于0，不大于sname:VkPhysicalDeviceLimits::pname:maxTessellationPatchSize。


[[shaders-tessellation-control-execution]]
=== 细分控制着色器的执行
对于一个图元内每一个 _output_ 顶点都至少调用一次细分控制着色器。

细分控制着色器的输入是由顶点着色器生成的。
每一次细分控制着色器调用可以读取任何一个输入的顶点的属性和它关联的数据。
对于一个给定图元的多次着色器调用逻辑上并行执行，相对顺序是未定义的。
然而，通过在一个图元内同步着色器调用，code:OpControlBarrier 指令可以用来提供对执行顺序的有限度的控制，
有效地把细分控制着色器执行划分为多个周期。
如果一次调用在同一个周期内读取被其他调用写入的逐顶点或者逐图元属性，
或者两个调用尝试在一个周期内向一个图元输出写入，细分控制着色器将读取到未定义的值。


[[shaders-tessellation-evaluation]]
== 细分求值着色器（Tessellation Evaluation Shaders）

细分求值着色器在控制点组成的输入图元和它关联数据上进行操作，单个输入重心坐标表示了在子图元中调用的对象的相对位置，
输入单个顶点和关联数据。


[[shaders-tessellation-evaluation-execution]]
=== 细分求值着色器的执行

对细分器生成的每一个顶点至少调用一次细分求值着色器。


[[shaders-geometry]]
== 几何着色器
几何着色器
The geometry shader operates on a group of vertices and their associated
data assembled from a single input primitive, and emits zero or more output
primitives and the group of vertices and their associated data required for
each output primitive.


[[shaders-geometry-execution]]
=== 几何着色器的执行

A geometry shader is invoked at least once for each primitive produced by
the tessellation stages, or at least once for each primitive generated by
<<drawing,primitive assembly>> when tessellation is not in use.
The number of geometry shader invocations per input primitive is determined
from the invocation count of the geometry shader specified by the
code:OpExecutionMode code:Invocations in the geometry shader.
If the invocation count is not specified, then a default of one invocation
is executed.


[[shaders-fragment]]
== 片元着色器

Fragment shaders are invoked as the result of rasterization in a graphics
pipeline.
Each fragment shader invocation operates on a single fragment and its
associated data.
With few exceptions, fragment shaders do not have access to any data
associated with other fragments and are considered to execute in isolation
of fragment shader invocations associated with other fragments.


[[shaders-fragment-execution]]
=== 片元着色器的执行

对于栅格化产生的每个片元，一个片元着色器都被调用一次。
如果 <<fragops-early,Early Per-Fragment Tests>>导致它没有被覆盖到 ，一个片元着色器就不能被调用。

Furthermore, if it is determined that a fragment generated as the result of
rasterizing a first primitive will have its outputs entirely overwritten by
a fragment generated as the result of rasterizing a second primitive in the
same subpass, and the fragment shader used for the fragment has no other
side effects, then the fragment shader may: not be executed for the fragment
from the first primitive.

Relative ordering of execution of different fragment shader invocations is
not defined.

The number of fragment shader invocations produced per-pixel is determined
as follows:

  * If per-sample shading is enabled, the fragment shader is invoked once
    per covered sample.
  * Otherwise, the fragment shader is invoked at least once per fragment but
    no more than once per covered sample.

In addition to the conditions outlined above for the invocation of a
fragment shader, a fragment shader invocation may: be produced as a _helper
invocation_.
A helper invocation is a fragment shader invocation that is created solely
for the purposes of evaluating derivatives for use in non-helper fragment
shader invocations.
Stores and atomics performed by helper invocations must: not have any effect
on memory, and values returned by atomic instructions in helper invocations
are undefined.


[[shaders-fragment-earlytest]]
=== 早期片元测试

Vulkan提供了显式的控制，允许片元着色器开启早期片元测试。如果片元着色器指定了code:EarlyFragmentTests code:OpExecutionMode，
在<<fragops-early-mode,Early Fragment Test Mode>>中描述过的逐片元测试发生在片元着色器执行之前。
否则，它们在片元着色器执行之后才被执行。


[[shaders-compute]]
== 计算着色器

Compute shaders are invoked via flink:vkCmdDispatch and
flink:vkCmdDispatchIndirect commands.
In general, they have access to similar resources as shader stages executing
as part of a graphics pipeline.

Compute workloads are formed from groups of work items called workgroups and
processed by the compute shader in the current compute pipeline.
A workgroup is a collection of shader invocations that execute the same
shader, potentially in parallel.
Compute shaders execute in _global workgroups_ which are divided into a
number of _local workgroups_ with a size that can: be set by assigning a
value to the code:LocalSize execution mode or via an object decorated by the
code:WorkgroupSize decoration.
An invocation within a local workgroup can: share data with other members of
the local workgroup through shared variables and issue memory and control
flow barriers to synchronize with other members of the local workgroup.


[[shaders-interpolation-decorations]]
== 插值修饰（Interpolation Decorations）

Interpolation decorations control the behavior of attribute interpolation in
the fragment shader stage.
Interpolation decorations can: be applied to code:Input storage class
variables in the fragment shader stage's interface, and control the
interpolation behavior of those variables.

Inputs that could be interpolated can: be decorated by at most one of the
following decorations:

  * code:Flat: no interpolation
  * code:NoPerspective: linear interpolation (for
    <<line_linear_interpolation,lines>> and
    <<triangle_linear_interpolation,polygons>>).

Fragment input variables decorated with neither code:Flat nor
code:NoPerspective use perspective-correct interpolation (for
<<line_perspective_interpolation,lines>> and
<<triangle_perspective_interpolation,polygons>>).

The presence of and type of interpolation is controlled by the above
interpolation decorations as well as the auxiliary decorations code:Centroid
and code:Sample.

A variable decorated with code:Flat will not be interpolated.
Instead, it will have the same value for every fragment within a triangle.
This value will come from a single <<vertexpostproc-flatshading,provoking
vertex>>.
A variable decorated with code:Flat can: also be decorated with
code:Centroid or code:Sample, which will mean the same thing as decorating
it only as code:Flat.

For fragment shader input variables decorated with neither code:Centroid nor
code:Sample, the assigned variable may: be interpolated anywhere within the
pixel and a single value may: be assigned to each sample within the pixel.

code:Centroid and code:Sample can: be used to control the location and
frequency of the sampling of the decorated fragment shader input.
If a fragment shader input is decorated with code:Centroid, a single value
may: be assigned to that variable for all samples in the pixel, but that
value must: be interpolated to a location that lies in both the pixel and in
the primitive being rendered, including any of the pixel's samples covered
by the primitive.
Because the location at which the variable is interpolated may: be different
in neighboring pixels, and derivatives may: be computed by computing
differences between neighboring pixels, derivatives of centroid-sampled
inputs may: be less accurate than those for non-centroid interpolated
variables.
If a fragment shader input is decorated with code:Sample, a separate value
must: be assigned to that variable for each covered sample in the pixel, and
that value must: be sampled at the location of the individual sample.
When pname:rasterizationSamples is ename:VK_SAMPLE_COUNT_1_BIT, the pixel
center must: be used for code:Centroid, code:Sample, and undecorated
attribute interpolation.

Fragment shader inputs that are signed or unsigned integers, integer
vectors, or any double-precision floating-point type must: be decorated with
code:Flat.

ifdef::VK_AMD_shader_explicit_vertex_parameter[]
When the +VK_AMD_shader_explicit_vertex_parameter+ device extension is
enabled inputs can: be also decorated with the code:CustomInterpAMD
interpolation decoration, including fragment shader inputs that are signed
or unsigned integers, integer vectors, or any double-precision
floating-point type.
Inputs decorated with code:CustomInterpAMD can: only be accessed by the
extended instruction code:InterpolateAtVertexAMD and allows accessing the
value of the input for individual vertices of the primitive.
endif::VK_AMD_shader_explicit_vertex_parameter[]


[[shaders-staticuse]]
== 静态使用

一个SPIR-V模块使用code:OpVariable指令在内存中声明一个全局对象，将产生一个code:x指针指向该对象。
如果一个入口点的调用栈包含一个函数，该函数包含这个以code:id为操作对象的内存指令或者图像指令code:x，
一个SPIR-V模块中该特定的入口点被称为_静态使用_该对象。参看SPIR-V规范第三小节 "`Binary Form`"的"`Memory Instructions`" 和 "`Image Instructions`"
来获取完整的SPIR-V内存指令。

静态使用并不以code:Input和 code:Output storage用来控制变量的行为。这些变量的效果基于它们是否在着色器入口点接口中出现来生效。


[[shaders-invocationgroups]]
== 调用和衍生组

一个计算着色器的_调用组_（参看SPIR-V规范第二节的"`Control Flow`"）是在单个本地工作组内一系列调用的集合。
对于图形着色器，一个调用组是在单个绘制命令内产生的指定着色器阶段的着色器调用集合的Vulkan实现各异的子集合。
对于pname:drawCount大于1的间接绘制命令，单个绘制内的调用在不同的调用组中。

[NOTE]
.注意
====
Because the partitioning of invocations into invocation groups is
implementation-dependent and not observable, applications generally need to
assume the worst case of all invocations in a draw belonging to a single
invocation group.
====

A _derivative group_ (see the subsection "`Control Flow`" of section 2 of
the SPIR-V 1.00 Revision 4 specification) for a fragment shader is the set
of invocations generated by a single primitive (point, line, or triangle),
including any helper invocations generated by that primitive.
Derivatives are undefined for a sampled image instruction if the instruction
is in flow control that is not uniform across the derivative group.
