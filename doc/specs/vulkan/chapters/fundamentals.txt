// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[fundamentals]]
= 基础

本章介绍一些基础的概念，包括Vulkan架构和执行模型、API语法、队列、管线、配置、
数值表示、状态和状态查询，还有不同类型的对象和着色器。
在本规范文档剩余部分中它提供了一个对更加精细描述命令和行为做解释的框架。


[[fundamentals-architecture-model]]
== 架构模型

Vulkan和其API为符合以下特征的CPU、GPU和其他硬件加速架构所设计和实现：

  * 运行时库支持8位、16位、32位和64位有符号和无符号整形，都可以通过该类型
    数据的粒度的大小来寻址到。
  * 运行时库支持满足  <<fundamentals-floatingpoint,Floating Point Computation>> 节
    的范围和精度的32位和64位浮点类型。  
  * 这些类型的表示和大小端必须满足主机端和设备端一致。


[NOTE]
.注意
====
因为Vulkan中很多数据类型和结构可能在主机端和设备端内存来回的映射，主机端和设备端
架构必须能够高效的访问到数据，以便很方便的写高性能、可移植的应用程序。
====

在支持Vulkan的特定平台上此规范对影响ABI（）的选项开放，这些选项通常是平台提供商用来
向前兼容的。
一些选项，比如函数调用惯例，可能在+vk_platform.h+头文件中的不同部分。


[NOTE]
.注意
====
例如，Android ABI由Google定义，Linux ABI是通过一系列的GCC默认项、发行版提供商和诸如Linux标准库
的外部标准一同定义的。
====


[[fundamentals-execmodel]]
== 执行模型

本节描绘了Vulkan执行系统执行模型的主框架。

Vulkan对外暴露一个或多个 _设备_，每一个对外暴露一个或多个 _队列_，队列之间异步的处理工作。
一个设备支持的一个集合的队列被分到 _族_里。每一个族都支持一个或多个类型的功能，并可能包含多个拥有相近特性的队列。
在同一个族中的队列被认为是互相 _兼容的_，同一个族中的队列需要完成的任务可以被任何一个队列执行。
这份规范定义了队列可能支持的四种功能：图形，计算，转移，稀疏内存管理。

[NOTE]
.注意
====
单个设备可能报告有多个相近的队列族，而非报告含有这些队列中一个或者多个成员。
这表明多个族的有相近功能的成员之间可能并不兼容。
====

设备内存是由应用程序显式的管理的。每一个设备可能宣称有一个或多个堆，表示内存的不同区域。
内存堆可能是在主机端或者是设备端，但是，都能被设备所见。
关于内存堆的更多细节是通过该堆上获取的内存类型对外暴露的。
在一个Vulkan实现上可用的内存区域的例子包含如下：

  * _device local_ 设物理连接到设备的内存。
  * _device local, host visible_ 是设备端内存，对主机端可见。
    the host.
  * _host local, host visible_ 是主机端内存，对设备和主机都可见。

在其他的一些架构上，也许只有个堆，可以用作任何用途。

一个Vulkan应用程序通过提交记录了Vulkan库调用激发的设备命令的命令缓冲区来控制多个物理设备。
命令缓冲区的内容是通过硬件指定的，对应用程序不可见。
一个命令缓冲区一旦被构造出来，就可以马上一次或多次提交到一个设备上以备执行。
多个命令缓冲区可能在应用程序里多线程中并行的被构建。

提交到不同的队列的命令缓冲区可能并行的执行或者乱序执行。
提交到同一个队列的命令缓冲区遵循<<synchronization-submission-order, submission order>>，
这在<<synchronization, synchronization chapter>>中深入描述。
命令缓冲区在设备上的执行和主机端的执行也是异步的。
一旦命令缓冲区被提交到一个队列，控制权马上返回到应用程序。
在主机端和设备之间的同步，和不同队列之间的同步是应用程序的职责。


[[fundamentals-queueoperation]]
=== 队列操作

Vulkan队列提供了设备执行引擎的接口。执行引擎的命令需要在执行之前被记录到命令缓冲区。
这些命令缓冲区然后被一个 _queue submission_提交到队列以供一个或多个批次执行。
一旦提交到队列，这些命令将开始并完成执行，不受应用程序的干扰，虽然执行的顺序会受到
<<synchronization, implicit and explicit ordering constraints>>的一些限制。

任务通常被一些队列提交命令提交到队列，这些命令一般形如ftext:vkQueue* (比如 flink:vkQueueSubmit,
flink:vkQueueBindSparse)，且可能接受一些等待任务开始的信号量和一些任务完成才激发的信号量。
任务本身，以及激发和等待信号量都是 _队列操作_。

在不同队列上的队列操作并没有隐式的顺序限制，可能以任何顺序执行。
不同队列间显式的顺序限制可以通过<<synchronization-semaphores,semaphores>> 和
<<synchronization-fences,fences>>表述。

提交到单个队列的命令缓冲区遵循<<synchronization-submission-order, submission order>> 和其他
<<synchronization-implicit, implicit ordering guarantees>>，否则可能重叠或者乱序执行。
对于单一队列上的批次和队列提交的其他类型，和其他队列或批次提交之间并没有隐式的顺序限制。
在不同队列和各自的批次之间的附加显式的顺序限制可以通过<<synchronization-semaphores,semaphores>> 和
<<synchronization-fences,fences>>表述。

在栅栏或信号量被激发之前，可以确定的是之前被提交的队列操作已经完成了，且这些队列操作的内存写入对未来的队列操作
<<synchronization-dependencies-available-and-visible,可见>> 。
等待一个被激发的信号量或者栅栏保证之前的可用的写入对后续的命令是<<synchronization-dependencies-available-and-visible,可见的>>。

在相同或不同的批次或者提交，还有主和次命令缓冲区之间的命令缓冲区边界，不会有任何附加的顺序限制。
也就是，在任何信号量或栅栏操作之间提交多个命令缓冲区（包含执行次级命令缓冲区）执行被记录的命令，就如同他们被记录进入
单个主命令缓冲区一样，除了每一个边界当前的状态都被<<commandbuffers-statereset,重置>> 。显式顺序限制可以通过
<<synchronization,explicit synchronization primitives>>表示。

在一个命令缓冲区内多个命令之间有一些<<synchronization-implicit, 隐式顺序保证>>，但是只包含
一部分执行子集。附加的显式顺序限制可以通过多种<<synchronization, 显式同步原语>>来表示。


[NOTE]
.注意
====
Vulkan实现对提交到一个队列的任务之间的重叠执行有极大的自由度，这是由
Vulkan设备里深度的管线和并行机制导致的。
====

[[fundamentals-queueoperation-command-types]]
被记录在命令缓冲区的命令，要么执行操作（绘制、分发、清除、复制、查询/时间戳操作、开始/结束subpass操作），
设置状态（绑定管线、描述符集、缓冲区、设置动态状态、推送常量、设置render pass/subpass状态），
要们执行同步（设置/等待时间、管线屏障、renderpass/subpass依赖）。一些命令执行不止一个上述任务。状态设置命令
更新命令缓冲区的 _当前状态_。一些命令执行操作（如绘制/分发）基于从命令缓冲区开始累积到当前状态集。
执行操作的命令内的任务是可以重叠或者重新记录的，但是必须禁止改动每一个操作命令使用的状态。
通常，操作命令是那些更改帧缓冲区附件、读写缓冲区或者图像内存、想查询池写入的命令，

同步命令在两个操作命令集合之间引入显式的<<synchronization-dependencies,execution and memory dependencies>> ，这里
第二个命令集合依赖于第一个命令集合。
这些依赖强制保证在后面的集合中的某些<<synchronization-pipeline-stages, 管线阶段>>的执行发生在源集合中某些阶段的执行之后，
且某些管线阶段执行的<<synchronization-global-memory-barriers,内存访问>>的影响结果顺序发生并对彼此可见。
当没有显式的依赖或<<synchronization-implicit,隐式的顺序保证>>，操作命令也许重叠执行或者乱序执行，而且看不到
彼此的内存访问的影响结果。

设备执行队列操作和主机端是异步的。当命令缓冲区被提交到队列后控制流马上就退回到应用程序了。
应用程序必须按需求在主机端和设备端同步任务。


[[fundamentals-objectmodel-overview]]
== 对象模型

设备、队列和Vulkan中其他的的实体都是通过Vulkan对象表示的。
在API层，所有的对象都通过handle来引用。有两种类型的handle：可分发的与不可分发的。
_可分发的_ handle是不可见类型数据的指针。这个指针可被layers使用，被当作拦截API命令的一部分，
每一个API命令头接受一个可分发类型的handle作为第一个参数。
每一个不可分发类型的对象必须在其生命周期内有唯一一个handle值。

_不可分发的_handle类型是64位整型类型，其含义是Vulkan实现决定的，能把对象信息直接包含到handle里，而非通过指向一个数据结构。
不可分发类型的对象，不一定只有一个唯一的handle值。
如果其他类型的handle值变得无效了，那么销毁这样的一个handle必须不能导致此对象其他类型的handle失效，如果一个handle值被创建的次数多与被销毁的次数
，则必须不能导致同种类型的等价的handle变得无效。

所有通过sname:VkDevice (比如 with a sname:VkDevice 作为第一个参数)的命令创建的对象都是该设备私有的，必须不能被其他设备使用。


[[fundamentals-objectmodel-lifetime]]
=== 对象的生存周期

对象都是通过形如ftext:vkCreate* and ftext:vkAllocate* 这样的命令创建或者分配的。
一旦一个对象被创建或者分配，它的结构就被认为是不变的，即使某个对象类型的内容仍然是可以被自由的改动。
对象都是通过形如ftext:vkDestroy* and ftext:vkFree* 的命令来销毁或者释放的。

被分配（而不是创建）的对象从一个已存在的池子对象或者内存堆中获取资源，当被释放时把资源归还给该池子或者堆。但 对象的创建和销毁在运行时通常是低频操作，
分配或者释放对象可能是高频的。对象池帮助调节分配和释放的性能提升。

应用程序有责任跟踪Vulkan对象的生命周期，且在对象正在被使用时不能销毁它们。

应用程序所拥有的内存被内存传递所到的命令迅速使用。在使用这些内存的命令返回后，应用程序可以立刻更改或者释放这些内存。

以下对象类型被传入Vulkan命令是被使用，此后并不被用它们来创建的对象所访问。它们在传入所到的API命令执行期间被能被销毁：

  * sname:VkShaderModule
  * sname:VkPipelineCache

一个 sname:VkPipelineLayout 对象在被任何使用它的命令缓冲区记录状态时被销毁。

sname:VkDescriptorSetLayout 对象可以被操作使用其布局的描述符集合的命令访问，在描述符集合布局被销毁后这些描述符集合必须不能被flink:vkUpdateDescriptorSets
更新。否则的话，描述符集合布局可在它们不被Vulkan API命令使用的任何时刻被销毁。

在设备（如从过命令缓冲区执行）已经完成使用Vulkan对象之前，应用程序必须不能销毁这些任何类型的Vulkan对象。

如下类型的Vulkan对象在被命令缓冲区使用或者暂停执行时不能被销毁：

  * sname:VkEvent
  * sname:VkQueryPool
  * sname:VkBuffer
  * sname:VkBufferView
  * sname:VkImage
  * sname:VkImageView
  * sname:VkPipeline
  * sname:VkSampler
  * sname:VkDescriptorPool
  * sname:VkFramebuffer
  * sname:VkRenderPass
  * sname:VkCommandPool
  * sname:VkDeviceMemory
  * sname:VkDescriptorSet
ifdef::VK_NVX_device_generated_commands[]
  * sname:VkObjectTableNVX
  * sname:VkIndirectCommandsLayout
endif::VK_NVX_device_generated_commands[]

一下Vulkan对象在队列执行使用到这些对象的命令时不能被销毁：

  * sname:VkFence
  * sname:VkSemaphore
  * sname:VkCommandBuffer
  * sname:VkCommandPool

通常，对象可以按照任意顺序销毁或者释放 ，即使被释放的对象可能使用到另外一个对象（如在视图中使用一个资源，
在描述符集合中使用视图，在命令缓冲区中使用对象，绑定分配的内存到资源），只要使用被释放了的对象的对象不被
再次使用，除了被销毁或者重置这样的导致对象不再使用另外一个对象的情况（比如重置了命令缓冲区）。
如果对象被重置，那么它可以被使用，如同从来没有用过被释放的对象一样。
一个例外是对象之间存在父子关系时。在这种情况下，在子对象被销毁前应用程序必须不能销毁父对象，除非父对象被释放
时被定义显式的释放它的子对象（比如下面定义的对象池）。

sname:VkCommandPool 对象是 sname:VkCommandBuffer 的父对象。
sname:VkDescriptorPool 对象是 sname:VkDescriptorSet 的父对象。
sname:VkDevice 对象是很多对象类型（所有接受sname:VkDevice作为参数来创建）的父对象。

下面的Vulkan对象在被销毁时有特定的限制：

  * sname:VkQueue 不能被显式的销毁。当它们所在的sname:VkDevice对象被销毁时才被隐式的销毁。
  * 销毁一个池对象隐式的释放从它分配出来的所有对象。特别是，销毁sname:VkCommandPool就会释放所有从之分配出来
    的sname:VkCommandBuffer对象，销毁sname:VkDescriptorPool会释放从之分配而来的sname:VkDescriptorSet对象。
  * 当所有从sname:VkDevice获取到的sname:VkQueue对象处于空闲状态时，sname:VkDevice 对象可以被销毁，
	所有依sname:VkQueue而创建的对象也被销毁了。这包括如下对象：
  ** sname:VkFence
  ** sname:VkSemaphore
  ** sname:VkEvent
  ** sname:VkQueryPool
  ** sname:VkBuffer
  ** sname:VkBufferView
  ** sname:VkImage
  ** sname:VkImageView
  ** sname:VkShaderModule
  ** sname:VkPipelineCache
  ** sname:VkPipeline
  ** sname:VkPipelineLayout
  ** sname:VkSampler
  ** sname:VkDescriptorSetLayout
  ** sname:VkDescriptorPool
  ** sname:VkFramebuffer
  ** sname:VkRenderPass
  ** sname:VkCommandPool
  ** sname:VkCommandBuffer
  ** sname:VkDeviceMemory
  * sname:VkPhysicalDevice 不能被显式的销毁。相反，在所有从值获取的sname:VkInstance对象被销毁后被隐式的销毁。
  * 当所有从sname:VkPhysicalDevice中创建的 sname:VkDevice被销毁后， sname:VkInstance 对象才被销毁。


[[fundamentals-commandsyntax]]
== 命令的语法和duration

这份规范描述Vulkan命令为C99语法的函数或者过程。其他语言，如C++和JavaScript的绑定允许更严格的参数传递，或者面向对象接口。
Vulkan使用标准的C类型作为标量参数的基础类型（比如stdint.h中的类型），例外的情况有如下或者本文档中任何合适的地方：

// refBegin VkBool32 Vulkan boolean type

basetype:VkBool32表示boolean类型的`True` and `False`值，因为C并没有可移植的内置boolean类型：

include::../api/basetypes/VkBool32.txt[]

ename:VK_TRUE 表示 boolean *True* (整型 1) 值, ename:VK_FALSE 表示一个boolean *False* (整型 0) 值。

从Vulkan实现返回的basetype:VkBool32类型的值要么是ename:VK_TRUE 要么是 ename:VK_FALSE。

当Vulkan实现期望basetype:VkBool32类型参数时，应用程序不能传入 ename:VK_TRUE 或
ename:VK_FALSE 以外的值。

// refEnd VkBool32

// refBegin VkDeviceSize Vulkan device memory size and offsets

basetype:VkDeviceSize 表示设备内存大小和偏移量:

include::../api/basetypes/VkDeviceSize.txt[]

// refEnd VkDeviceSize

创建Vulkan对象的命令都形如ftext:vkCreate*，接受形如stext:Vk*CreateInfo的参数。这些Vulkan对象通过形如ftext:vkDestroy*
的命令来销毁。

每一个用来创建或者销毁Vulkan对象的命令的最后一个传入参数是pname:pAllocator。pname:pAllocator参数可以被置为非NULL值，此时，
对给定对象的分配任务就代理给应用程序提供的回调函数了；请参考<<memory-allocation,Memory Allocation>>章节以得到更多细节。

从池对象中分配Vulkan对象的命令都形如ftext:vkAllocate*，接受形如 stext:Vk*AllocateInfo 的结构为参数。
这些Vulkan对象都通过形如ftext:vkFree*的命令来释放。这些对象并不接受内存分配器；如果需要主机端内存，它们将使用缓存池被创建时
指定分配器。

通过调用形如ftext:vkCmd*的API命令把命令记录到命令缓冲区。每一个命令可能有不同的限制条件：在和/或此命令缓冲区，在一个
renderpass内部和/或外部，在一个或者多个受支持队列类型中。这些限制条件都在每一个命令的定义处给出。

Vulkan命令的 _duration_是指调用命令到它返回的时间段。


[[fundamentals-commandsyntax-results-lifetime]]
=== 获取的值的生命周期

通过形如ftext:vkGet* and ftext:vkEnumerate*的命令从Vulkan实现中获取这些信息。

除非针对一个特定的命令，结果都是 _不变的_ 。亦即，只要参数保持有效，用相同的参数调用这些命令的结果将会保持不变。


[[fundamentals-threadingbehavior]]
== 线程的行为

在多线程CPU主机上，Vulkan提供线性拓展能力。所有的命令都支持多线程，但是一些参数或者参数成员需要在外部保持同步。这意味着
调用者必须保证同一时刻只能有一个线程在使用这个参数。

更准确的来说，Vulkan命令使用简单的存储来更新表示Vulkan对象的数据结构。在主机端执行命令时，被声明为外部同步的参数的内容可能
就被更新了。如果两个命令操作同一个对象，至少有一个命令生命这个对象需要被外部同步保护，然而调用者保证命令不会同时执行，
但是如果有必要，两个命令可以通过内存屏障被分离。

[NOTE]
.注意
====
内存屏障在ARM CPU架构上非常重要，因为很多开发者所熟悉的X86/x64平台编程比相对无序一些。幸运的是，大多数高层同步原语
（像pthread库）是内存屏障表现为互斥的一种，所以通过这些原语实现Vulkan对象互斥会有预期的效果。
====

很多对象类型是不可改变内容的，意味着对象一旦被创建就不能被改变。这些类型不需要外部同步，除了在销毁的时候不能在另外
一个线程中使用。在一些特定的场合下，可改变内容的对象参数在其内部同步，所以无需在外部保持同步。这样的一个例子是在
fname:vkCreateGraphicsPipelines和fname:vkCreateComputePipelines中sname:VkPipelineCach的使用，这里给这样一个重型的
命令做外部同步不切实际。在这个例子中，Vulkan实现必须在cache内部保持同步。还有，某些和命令参数相关的对象（比如命令池和描述符池）可能
被命令影响，它们也必须在外部保持同步。这些隐式的参数在下面文档给出。
 
需要在外部保持同步的命令的参数列举如下。

include::../hostsynctable/parameters.txt[]

也有一些接受内容是在外部保持同步的参数的用户分配列表的命令的例子。这些情况下，调用者必须保证某时刻最多只有一个线程正在使用
列表中指定的元素。这些参数列举如下。

include::../hostsynctable/parameterlists.txt[]

另外，有一些隐式参数需要在外部保持同步。比如所有需要在外部保持同步的的pname:commandBuffer参数表明当创建
该命令缓冲区时被传入的pname:commandPool也需要在外部保持同步。这个隐式的参数和它关联的对象列举如下。

include::../hostsynctable/implicit.txt[]


[[fundamentals-errors]]
== 错误

Vulkan是一个分层的API。最底层是Vulkan核心层，就是本规范所定义的。应用程序可以在其上使用附加层来调试、验证或者达到其他的目的。

Vulkan一个核心的原则就是构建并提交命令缓冲区应该是非常高效的。所以，错误检查和状态验证在核心层应该尽量小，
尽管可以使用这些层来开启更严格的验证。

核心层假设应用程序正确的使用API。除了按照本规范所写的内容，应用程序中核心层错误的使用API将导致未知的结果，可能包括程序终止。
然而，Vulkan实现必须保证应用程序错误的使用并不影响操作系统的完整性、Vulkan实现或者其他Vulkan客户端应用程序，也不允许一个应用程序去
访问另外一个程序的数据。应用程序可以通过启用<<features>>中描述的pname:robustBufferAccess特征来要求更健壮的保证。

Validation of correct API usage is left to validation layers.
Applications should: be developed with validation layers enabled, to help
catch and eliminate errors.
Once validated, released applications should: not enable validation layers
by default.


[[fundamentals-validusage]]
=== Valid Usage

Valid usage defines a set of conditions which must: be met in order to
achieve well-defined run-time behavior in an application.
These conditions depend only on Vulkan state, and the parameters or objects
whose usage is constrained by the condition.

Some valid usage conditions have dependencies on run-time limits or feature
availability.
It is possible to validate these conditions against Vulkan's minimum
supported values for these limits and features, or some subset of other
known values.

Valid usage conditions do not cover conditions where well-defined behavior
(including returning an error code) exists.

Valid usage conditions should: apply to the command or structure where
complete information about the condition would be known during execution of
an application.
This is such that a validation layer or linter can: be written directly
against these statements at the point they are specified.

[NOTE]
.Note
====
This does lead to some non-obvious places for valid usage statements.
For instance, the valid values for a structure might depend on a separate
value in the calling command.
In this case, the structure itself will not reference this valid usage as it
is impossible to determine validity from the structure that it is invalid -
instead this valid usage would be attached to the calling command.

Another example is draw state - the state setters are independent, and can
cause a legitimately invalid state configuration between draw calls; so the
valid usage statements are attached to the place where all state needs to be
valid - at the draw command.
====

Valid usage conditions are described in a block labelled "`Valid Usage`"
following each command or structure they apply to.


[[fundamentals-implicit-validity]]
=== Implicit Valid Usage

Some valid usage conditions apply to all commands and structures in the API,
unless explicitly denoted otherwise for a specific command or structure.
These conditions are considered _implicit_, and are described in a block
labelled "`Valid Usage (Implicit)`" following each command or structure they
apply to.
Implicit valid usage conditions are described in detail below.


[[fundamentals-validusage-handles]]
==== Valid Usage for Object Handles

Any input parameter to a command that is an object handle must: be a valid
object handle, unless otherwise specified.
An object handle is valid if:

  * It has been created or allocated by a previous, successful call to the
    API.
    Such calls are noted in the specification.
  * It has not been deleted or freed by a previous call to the API.
    Such calls are noted in the specification.
  * Any objects used by that object, either as part of creation or
    execution, must: also be valid.

The reserved values dlink:VK_NULL_HANDLE and `NULL` can: be used in place of
valid non-dispatchable handles and dispatchable handles, respectively, when
_explicitly called out in the specification_.
Any command that creates an object successfully must: not return these
values.
It is valid to pass these values to ftext:vkDestroy* or ftext:vkFree*
commands, which will silently ignore these values.


[[fundamentals-validusage-pointers]]
==== Valid Usage for Pointers

Any parameter that is a pointer must: be a valid pointer.
A pointer is valid if it points at memory containing values of the number
and type(s) expected by the command, and all fundamental types accessed
through the pointer (e.g. as elements of an array or as members of a
structure) satisfy the alignment requirements of the host processor.


[[fundamentals-validusage-enums]]
==== Valid Usage for Enumerated Types

Any parameter of an enumerated type must: be a valid enumerant for that
type.
A enumerant is valid if:

  * The enumerant is defined as part of the enumerated type.
  * The enumerant is not one of the special values defined for the
    enumerated type, which are suffixed with etext:_BEGIN_RANGE,
    etext:_END_RANGE, etext:_RANGE_SIZE or etext:_MAX_ENUM.


[[fundamentals-validusage-flags]]
==== Valid Usage for Flags

// refBegin VkFlags Vulkan bitmasks

A collection of flags is represented by a bitmask using the type
basetype:VkFlags:

include::../api/basetypes/VkFlags.txt[]

Bitmasks are passed to many commands and structures to compactly represent
options, but basetype:VkFlags is not used directly in the API.
Instead, a etext:Vk*Flags type which is an alias of basetype:VkFlags, and
whose name matches the corresponding etext:Vk*FlagBits that are valid for
that type, is used.
These aliases are described in the <<boilerplate-flags,Flag Types>> appendix
of the Specification.

// refEnd VkFlags VkColorComponentFlags

Any etext:Vk*Flags member or parameter used in the API must: be a valid
combination of bit flags.
A valid combination is either zero or the bitwise OR of valid bit flags.
A bit flag is valid if:

  * The bit flag is defined as part of the etext:Vk*FlagBits type, where the
    bits type is obtained by taking the flag type and replacing the trailing
    etext:Flags with etext:FlagBits.
    For example, a flag value of type elink:VkColorComponentFlags must:
    contain only bit flags defined by elink:VkColorComponentFlagBits.
  * The flag is allowed in the context in which it is being used.
    For example, in some cases, certain bit flags or combinations of bit
    flags are mutually exclusive.


[[fundamentals-validusage-sType]]
==== Valid Usage for Structure Types

Any parameter that is a structure containing a pname:sType member must: have
a value of ptext:sType which is a valid elink:VkStructureType value matching
the type of the structure.
As a general rule, the name of this value is obtained by taking the
structure name, stripping the leading etext:Vk, prefixing each capital
letter with etext:_, converting the entire resulting string to upper case,
and prefixing it with etext:VK_STRUCTURE_TYPE_.
For example, structures of type sname:VkImageCreateInfo must: have a
ptext:sType value of ename:VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO.

The values ename:VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO and
ename:VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO are reserved for internal
use by the loader, and do not have corresponding Vulkan structures in this
specification.

The list of supported <<boilerplate-sType,structure types>> is defined in an
appendix.


[[fundamentals-validusage-pNext]]
==== Valid Usage for Structure Pointer Chains

Any parameter that is a structure containing a `void*` ptext:pNext member
must: have a value of pname:pNext that is either `NULL`, or points to a
valid structure defined by an extension, containing ptext:sType and
ptext:pNext members as described in the <<vulkan-styleguide,Vulkan
Documentation and Extensions>> document in the section "`Extension
Interactions`".
If that extension is supported by the implementation, then it must: be
enabled.
Any component of the implementation (the loader, any enabled layers, and
drivers) must: skip over, without processing (other than reading the
pname:sType and pname:pNext members) any chained structures with pname:sType
values not defined by extensions supported by that component.

Extension structures are not described in the base Vulkan specification, but
either in layered specifications incorporating those extensions, or in
separate vendor-provided documents.


[[fundamentals-validusage-nested-structs]]
==== Valid Usage for Nested Structures

The above conditions also apply recursively to members of structures
provided as input to a command, either as a direct argument to the command,
or themselves a member of another structure.

Specifics on valid usage of each command are covered in their individual
sections.


[[fundamentals-returncodes]]
=== Return Codes

// refBegin VkResult Vulkan command return codes

While the core Vulkan API is not designed to capture incorrect usage, some
circumstances still require return codes.
Commands in Vulkan return their status via return codes that are in one of
two categories:

  * Successful completion codes are returned when a command needs to
    communicate success or status information.
    All successful completion codes are non-negative values.
  * Run time error codes are returned when a command needs to communicate a
    failure that could only be detected at run time.
    All run time error codes are negative values.

All return codes in Vulkan are reported via elink:VkResult return values.
The possible codes are:

include::../api/enums/VkResult.txt[]

[[fundamentals-successcodes]]
.Success Codes
  * ename:VK_SUCCESS Command successfully completed
  * ename:VK_NOT_READY A fence or query has not yet completed
  * ename:VK_TIMEOUT A wait operation has not completed in the specified
    time
  * ename:VK_EVENT_SET An event is signaled
  * ename:VK_EVENT_RESET An event is unsignaled
  * ename:VK_INCOMPLETE A return array was too small for the result
ifdef::VK_KHR_swapchain[]
  * ename:VK_SUBOPTIMAL_KHR A swapchain no longer matches the surface
    properties exactly, but can: still be used to present to the surface
    successfully.
endif::VK_KHR_swapchain[]

[[fundamentals-errorcodes]]
.Error codes
  * ename:VK_ERROR_OUT_OF_HOST_MEMORY A host memory allocation has failed.
  * ename:VK_ERROR_OUT_OF_DEVICE_MEMORY A device memory allocation has
    failed.
  * ename:VK_ERROR_INITIALIZATION_FAILED Initialization of an object could
    not be completed for implementation-specific reasons.
  * ename:VK_ERROR_DEVICE_LOST The logical or physical device has been lost.
    See <<devsandqueues-lost-device,Lost Device>>
  * ename:VK_ERROR_MEMORY_MAP_FAILED Mapping of a memory object has failed.
  * ename:VK_ERROR_LAYER_NOT_PRESENT A requested layer is not present or
    could not be loaded.
  * ename:VK_ERROR_EXTENSION_NOT_PRESENT A requested extension is not
    supported.
  * ename:VK_ERROR_FEATURE_NOT_PRESENT A requested feature is not supported.
  * ename:VK_ERROR_INCOMPATIBLE_DRIVER The requested version of Vulkan is
    not supported by the driver or is otherwise incompatible for
    implementation-specific reasons.
  * ename:VK_ERROR_TOO_MANY_OBJECTS Too many objects of the type have
    already been created.
  * ename:VK_ERROR_FORMAT_NOT_SUPPORTED A requested format is not supported
    on this device.
  * ename:VK_ERROR_FRAGMENTED_POOL A requested pool allocation has failed
    due to fragmentation of the pool's memory.
ifdef::VK_KHR_surface[]
  * ename:VK_ERROR_SURFACE_LOST_KHR A surface is no longer available.
  * ename:VK_ERROR_NATIVE_WINDOW_IN_USE_KHR The requested window is already
    in use by Vulkan or another API in a manner which prevents it from being
    used again.
endif::VK_KHR_surface[]
ifdef::VK_KHR_swapchain[]
  * ename:VK_ERROR_OUT_OF_DATE_KHR A surface has changed in such a way that
    it is no longer compatible with the swapchain, and further presentation
    requests using the swapchain will fail.
    Applications must: query the new surface properties and recreate their
    swapchain if they wish to continue presenting to the surface.
endif::VK_KHR_swapchain[]
ifdef::VK_KHR_display_swapchain[]
  * ename:VK_ERROR_INCOMPATIBLE_DISPLAY_KHR The display used by a swapchain
    does not use the same presentable image layout, or is incompatible in a
    way that prevents sharing an image.
endif::VK_KHR_display_swapchain[]
ifdef::VK_NV_glsl_shader[]
  * ename:VK_ERROR_INVALID_SHADER_NV One or more shaders failed to compile
    or link.
    More details are reported back to the application via
    +VK_EXT_debug_report+ if enabled.
endif::VK_NV_glsl_shader[]
ifdef::VK_KHR_maintenance1[]
  * ename:VK_ERROR_OUT_OF_POOL_MEMORY_KHR There is no more memory in the
    descriptor set pool.
endif::VK_KHR_maintenance1[]

If a command returns a run time error, it will leave any result pointers
unmodified, unless other behavior is explicitly defined in the
specification.

Out of memory errors do not damage any currently existing Vulkan objects.
Objects that have already been successfully created can: still be used by
the application.

Performance-critical commands generally do not have return codes.
If a run time error occurs in such commands, the implementation will defer
reporting the error until a specified point.
For commands that record into command buffers (ftext:vkCmd*) run time errors
are reported by fname:vkEndCommandBuffer.

// refEnd VkResult TBD


[[fundamentals-numerics]]
== Numeric Representation and Computation

Implementations normally perform computations in floating-point, and must:
meet the range and precision requirements defined under "`Floating-Point
Computation`" below.

These requirements only apply to computations performed in Vulkan operations
outside of shader execution, such as texture image specification and
sampling, and per-fragment operations.
Range and precision requirements during shader execution differ and are
specified by the <<spirvenv-precision-operation, Precision and Operation of
SPIR-V Instructions>> section.

In some cases, the representation and/or precision of operations is
implicitly limited by the specified format of vertex or texel data consumed
by Vulkan.
Specific floating-point formats are described later in this section.


[[fundamentals-floatingpoint]]
=== 浮点计算

Most floating-point computation is performed in SPIR-V shader modules.
The properties of computation within shaders are constrained as defined by
the <<spirvenv-precision-operation, Precision and Operation of SPIR-V
Instructions>> section.

Some floating-point computation is performed outside of shaders, such as
viewport and depth range calculations.
For these computations, we do not specify how floating-point numbers are to
be represented, or the details of how operations on them are performed, but
only place minimal requirements on representation and precision as described
in the remainder of this section.

ifdef::editing-notes[]
[NOTE]
.editing-note
====
(Jon, Bug 14966) This is a rat's nest of complexity, both in terms of
describing/enumerating places such computation may: take place (other than
"`not shader code`") and in how implementations may: do it.
We have consciously deferred the resolution of this issue to post-1.0, and
in the meantime, the following language inherited from the OpenGL
Specification is inserted as a placeholder.
Hopefully it can: be tightened up considerably.
====
endif::editing-notes[]

We require simply that numbers' floating-point parts contain enough bits and
that their exponent fields are large enough so that individual results of
floating-point operations are accurate to about 1 part in 10^5^.
The maximum representable magnitude for all floating-point values must: be
at least 2^32^.

  :: [eq]#x {times} 0 = 0 {times} x = 0# for any non-infinite and
     non-[eq]#NaN# [eq]#x#.
  :: [eq]#1 {times} x = x {times} 1 = x#.
  :: [eq]#x + 0 = 0 + x = x#.
  :: [eq]#0^0^ = 1#.

Occasionally, further requirements will be specified.
Most single-precision floating-point formats meet these requirements.

The special values [eq]#Inf# and [eq]#-Inf# encode values with magnitudes
too large to be represented; the special value [eq]#NaN# encodes {ldquo}Not
A Number{rdquo} values resulting from undefined arithmetic operations such
as [eq]#0 / 0#.
Implementations may: support [eq]#Inf# and [eq]#NaN# in their floating-point
computations.

Any representable floating-point value is legal as input to a Vulkan command
that requires floating-point data.
The result of providing a value that is not a floating-point number to such
a command is unspecified, but must: not lead to Vulkan interruption or
termination.
In <<ieee-754,IEEE 754>> arithmetic, for example, providing a negative zero
or a denormalized number to an Vulkan command must: yield deterministic
results, while providing a [eq]#NaN# or [eq]#Inf# yields unspecified
results.


[[fundamentals-fp16]]
=== 16-Bit Floating-Point Numbers

16-bit floating point numbers are defined in the "`16-bit floating point
numbers`" section of the <<data-format,Khronos Data Format Specification>>.

Any representable 16-bit floating-point value is legal as input to a Vulkan
command that accepts 16-bit floating-point data.
The result of providing a value that is not a floating-point number (such as
[eq]#Inf# or [eq]#NaN#) to such a command is unspecified, but must: not lead
to Vulkan interruption or termination.
Providing a denormalized number or negative zero to Vulkan must: yield
deterministic results.


[[fundamentals-fp11]]
=== Unsigned 11-Bit Floating-Point Numbers

Unsigned 11-bit floating point numbers are defined in the "`Unsigned 11-bit
floating point numbers`" section of the <<data-format,Khronos Data Format
Specification>>.

When a floating-point value is converted to an unsigned 11-bit
floating-point representation, finite values are rounded to the closest
representable finite value.

While less accurate, implementations are allowed to always round in the
direction of zero.
This means negative values are converted to zero.
Likewise, finite positive values greater than 65024 (the maximum finite
representable unsigned 11-bit floating-point value) are converted to 65024.
Additionally: negative infinity is converted to zero; positive infinity is
converted to positive infinity; and both positive and negative [eq]#NaN# are
converted to positive [eq]#NaN#.

Any representable unsigned 11-bit floating-point value is legal as input to
a Vulkan command that accepts 11-bit floating-point data.
The result of providing a value that is not a floating-point number (such as
[eq]#Inf# or [eq]#NaN#) to such a command is unspecified, but must: not lead
to Vulkan interruption or termination.
Providing a denormalized number to Vulkan must: yield deterministic results.


[[fundamentals-fp10]]
=== Unsigned 10-Bit Floating-Point Numbers

Unsigned 10-bit floating point numbers are defined in the "`Unsigned 10-bit
floating point numbers`" section of the <<data-format,Khronos Data Format
Specification>>.

When a floating-point value is converted to an unsigned 10-bit
floating-point representation, finite values are rounded to the closest
representable finite value.

While less accurate, implementations are allowed to always round in the
direction of zero.
This means negative values are converted to zero.
Likewise, finite positive values greater than 64512 (the maximum finite
representable unsigned 10-bit floating-point value) are converted to 64512.
Additionally: negative infinity is converted to zero; positive infinity is
converted to positive infinity; and both positive and negative [eq]#NaN# are
converted to positive [eq]#NaN#.

Any representable unsigned 10-bit floating-point value is legal as input to
a Vulkan command that accepts 10-bit floating-point data.
The result of providing a value that is not a floating-point number (such as
[eq]#Inf# or [eq]#NaN#) to such a command is unspecified, but must: not lead
to Vulkan interruption or termination.
Providing a denormalized number to Vulkan must: yield deterministic results.


[[fundamentals-general]]
=== General Requirements

Some calculations require division.
In such cases (including implied divisions performed by vector
normalization), division by zero produces an unspecified result but must:
not lead to Vulkan interruption or termination.


[[fundamentals-fixedconv]]
== 浮点数据转换

When generic vertex attributes and pixel color or depth _components_ are
represented as integers, they are often (but not always) considered to be
_normalized_.
Normalized integer values are treated specially when being converted to and
from floating-point values, and are usually referred to as _normalized
fixed-point_.

In the remainder of this section, [eq]#b# denotes the bit width of the
fixed-point integer representation.
When the integer is one of the types defined by the API, [eq]#b# is the bit
width of that type.
When the integer comes from an <<resources-images,image>> containing color
or depth component texels, [eq]#b# is the number of bits allocated to that
component in its <<features-formats,specified image format>>.

The signed and unsigned fixed-point representations are assumed to be
[eq]#b#-bit binary two's-complement integers and binary unsigned integers,
respectively.


[[fundamentals-fixedfpconv]]
=== Conversion from Normalized Fixed-Point to Floating-Point

Unsigned normalized fixed-point integers represent numbers in the range
[eq]#[0,1]#.
The conversion from an unsigned normalized fixed-point value [eq]#c# to the
corresponding floating-point value [eq]#f# is defined as

[latexmath]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
f = { c \over { 2^b - 1 } }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Signed normalized fixed-point integers represent numbers in the range
[eq]#[-1,1]#.
The conversion from a signed normalized fixed-point value [eq]#c# to the
corresponding floating-point value [eq]#f# is performed using

[latexmath]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
f = \max\left( {c \over {2^{b-1} - 1}}, -1.0 \right)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Only the range [eq]#[-2^b-1^ + 1, 2^b-1^ - 1]# is used to represent signed
fixed-point values in the range [eq]#[-1,1]#.
For example, if [eq]#b = 8#, then the integer value [eq]#-127# corresponds
to [eq]#-1.0# and the value 127 corresponds to [eq]#1.0#.
Note that while zero is exactly expressible in this representation, one
value ([eq]#-128# in the example) is outside the representable range, and
must: be clamped before use.
This equation is used everywhere that signed normalized fixed-point values
are converted to floating-point.


[[fundamentals-fpfixedconv]]
=== Conversion from Floating-Point to Normalized Fixed-Point

The conversion from a floating-point value [eq]#f# to the corresponding
unsigned normalized fixed-point value [eq]#c# is defined by first clamping
[eq]#f# to the range [eq]#[0,1]#, then computing

  :: [eq]#c = convertFloatToUint(f {times} (2^b^ - 1), b)#

where [eq]#convertFloatToUint}(r,b)# returns one of the two unsigned binary
integer values with exactly [eq]#b# bits which are closest to the
floating-point value [eq]#r#.
Implementations should: round to nearest.
If [eq]#r# is equal to an integer, then that integer value must: be
returned.
In particular, if [eq]#f# is equal to 0.0 or 1.0, then [eq]#c# must: be
assigned 0 or [eq]#2^b^ - 1#, respectively.

The conversion from a floating-point value [eq]#f# to the corresponding
signed normalized fixed-point value [eq]#c# is performed by clamping [eq]#f#
to the range [eq]#[-1,1]#, then computing

  :: [eq]#c = convertFloatToInt(f {times} (2^b-1^ - 1), b)#

where [eq]#convertFloatToInt(r,b)# returns one of the two signed
two's-complement binary integer values with exactly [eq]#b# bits which are
closest to the floating-point value [eq]#r#.
Implementations should: round to nearest.
If [eq]#r# is equal to an integer, then that integer value must: be
returned.
In particular, if [eq]#f# is equal to -1.0, 0.0, or 1.0, then [eq]#c# must:
be assigned [eq]#-(2^b-1^ - 1)#, 0, or [eq]#2^b-1^ - 1#, respectively.

This equation is used everywhere that floating-point values are converted to
signed normalized fixed-point.


[[fundamentals-versionnum]]
== API版本数字和语义

The Vulkan version number is used in several places in the API.
In each such use, the API _major version number_, _minor version number_,
and _patch version number_ are packed into a 32-bit integer as follows:

  * The major version number is a 10-bit integer packed into bits 31-22.
  * The minor version number is a 10-bit integer packed into bits 21-12.
  * The patch version number is a 12-bit integer packed into bits 11-0.

Differences in any of the Vulkan version numbers indicates a change to the
API in some way, with each part of the version number indicating a different
scope of changes.

A difference in patch version numbers indicates that some usually small part
of the specification or header has been modified, typically to fix a bug,
and may: have an impact on the behavior of existing functionality.
Differences in this version number should: not affect either _full
compatibility_ or _backwards compatibility_ between two versions, or add
additional interfaces to the API.

A difference in minor version numbers indicates that some amount of new
functionality has been added.
This will usually include new interfaces in the header, and may: also
include behavior changes and bug fixes.
Functionality may: be deprecated in a minor revision, but will not be
removed.
When a new minor version is introduced, the patch version is reset to 0, and
each minor revision maintains its own set of patch versions.
Differences in this version should: not affect backwards compatibility, but
will affect full compatibility.

A difference in major version numbers indicates a large set of changes to
the API, potentially including new functionality and header interfaces,
behavioral changes, removal of deprecated features, modification or outright
replacement of any feature, and is thus very likely to break any and all
compatibility.
Differences in this version will typically require significant modification
to an application in order for it to function.

C language macros for manipulating version numbers are defined in the
<<boilerplate-versions,Version Number Macros>> appendix.


[[fundamentals-common-objects]]
== 常见对象类型

Some types of Vulkan objects are used in many different structures and
command parameters, and are described here.
These types include _offsets_, _extents_, and _rectangles_.


=== Offsets

Offsets are used to describe a pixel location within an image or
framebuffer, as an (x,y) location for two-dimensional images, or an (x,y,z)
location for three-dimensional images.

// refBegin VkOffset2D Structure specifying a two-dimensional offset

A two-dimensional offsets is defined by the structure:

include::../api/structs/VkOffset2D.txt[]

include::../validity/structs/VkOffset2D.txt[]

// refBegin VkOffset3D Structure specifying a three-dimensional offset

A three-dimensional offset is defined by the structure:

include::../api/structs/VkOffset3D.txt[]

include::../validity/structs/VkOffset3D.txt[]


=== Extents

Extents are used to describe the size of a rectangular region of pixels
within an image or framebuffer, as (width,height) for two-dimensional
images, or as (width,height,depth) for three-dimensional images.

// refBegin VkExtent2D Structure specifying a two-dimensional extent

A two-dimensional extent is defined by the structure:

include::../api/structs/VkExtent2D.txt[]

include::../validity/structs/VkExtent2D.txt[]

// refBegin VkExtent3D Structure specifying a three-dimensional extent

A three-dimensional extent is defined by the structure:

include::../api/structs/VkExtent3D.txt[]

include::../validity/structs/VkExtent3D.txt[]


=== Rectangles

// refBegin VkRect2D Structure specifying a two-dimensional subregion

Rectangles are used to describe a specified rectangular region of pixels
within an image or framebuffer.
Rectangles include both an offset and an extent of the same dimensionality,
as described above.
Two-dimensional rectangles are defined by the structure

include::../api/structs/VkRect2D.txt[]

include::../validity/structs/VkRect2D.txt[]
