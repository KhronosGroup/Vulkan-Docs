// Copyright (c) 2015-2017 The Khronos Group Inc.
// Copyright notice at https://www.khronos.org/registry/speccopyright.html

[[fundamentals]]
= 基础

本章介绍一些基础的概念，包括Vulkan架构和执行模型、API语法、队列、管线、配置、
数值表示、状态和状态查询，还有不同类型的对象和着色器。
在本规范文档剩余部分中它提供了一个对更加精细描述命令和行为做解释的框架。


[[fundamentals-architecture-model]]
== 架构模型

Vulkan和其API为符合以下特征的CPU、GPU和其他硬件加速架构所设计和实现：

  * 运行时库支持8位、16位、32位和64位有符号和无符号整形，都可以通过该类型
    数据的粒度的大小来寻址到。
  * 运行时库支持满足  <<fundamentals-floatingpoint,Floating Point Computation>> 节
    的范围和精度的32位和64位浮点类型。  
  * 这些类型的表示和大小端必须满足主机端和设备端一致。


[NOTE]
.注意
====
因为Vulkan中很多数据类型和结构可能在主机端和设备端内存来回的映射，主机端和设备端
架构必须能够高效的访问到数据，以便很方便的写高性能、可移植的应用程序。
====

在支持Vulkan的特定平台上此规范对影响ABI（）的选项开放，这些选项通常是平台提供商用来
向前兼容的。
一些选项，比如函数调用惯例，可能在+vk_platform.h+头文件中的不同部分。


[NOTE]
.注意
====
例如，Android ABI由Google定义，Linux ABI是通过一系列的GCC默认项、发行版提供商和诸如Linux标准库
的外部标准一同定义的。
====


[[fundamentals-execmodel]]
== 执行模型

本节描绘了Vulkan执行系统执行模型的主框架。

Vulkan对外暴露一个或多个 _设备_，每一个对外暴露一个或多个 _队列_，队列之间异步的处理工作。
一个设备支持的一个集合的队列被分到 _族_里。每一个族都支持一个或多个类型的功能，并可能包含多个拥有相近特性的队列。
在同一个族中的队列被认为是互相 _兼容的_，同一个族中的队列需要完成的任务可以被任何一个队列执行。
这份规范定义了队列可能支持的四种功能：图形，计算，转移，稀疏内存管理。

[NOTE]
.注意
====
单个设备可能报告有多个相近的队列族，而非报告含有这些队列中一个或者多个成员。
这表明多个族的有相近功能的成员之间可能并不兼容。
====

设备内存是由应用程序显式的管理的。每一个设备可能宣称有一个或多个堆，表示内存的不同区域。
内存堆可能是在主机端或者是设备端，但是，都能被设备所见。
关于内存堆的更多细节是通过该堆上获取的内存类型对外暴露的。
在一个Vulkan实现上可用的内存区域的例子包含如下：

  * _device local_ 设物理连接到设备的内存。
  * _device local, host visible_ 是设备端内存，对主机端可见。
    the host.
  * _host local, host visible_ 是主机端内存，对设备和主机都可见。

在其他的一些架构上，也许只有个堆，可以用作任何用途。

一个Vulkan应用程序通过提交记录了Vulkan库调用激发的设备命令的命令缓冲区来控制多个物理设备。
命令缓冲区的内容是通过硬件指定的，对应用程序不可见。
一个命令缓冲区一旦被构造出来，就可以马上一次或多次提交到一个设备上以备执行。
多个命令缓冲区可能在应用程序里多线程中并行的被构建。

提交到不同的队列的命令缓冲区可能并行的执行或者乱序执行。
提交到同一个队列的命令缓冲区遵循<<synchronization-submission-order, submission order>>，
这在<<synchronization, synchronization chapter>>中深入描述。
命令缓冲区在设备上的执行和主机端的执行也是异步的。
一旦命令缓冲区被提交到一个队列，控制权马上返回到应用程序。
在主机端和设备之间的同步，和不同队列之间的同步是应用程序的职责。


[[fundamentals-queueoperation]]
=== 队列操作

Vulkan队列提供了设备执行引擎的接口。执行引擎的命令需要在执行之前被记录到命令缓冲区。
这些命令缓冲区然后被一个 _queue submission_提交到队列以供一个或多个批次执行。
一旦提交到队列，这些命令将开始并完成执行，不受应用程序的干扰，虽然执行的顺序会受到
<<synchronization, implicit and explicit ordering constraints>>的一些限制。

任务通常被一些队列提交命令提交到队列，这些命令一般形如ftext:vkQueue* (比如 flink:vkQueueSubmit,
flink:vkQueueBindSparse)，且可能接受一些等待任务开始的信号量和一些任务完成才激发的信号量。
任务本身，以及激发和等待信号量都是 _队列操作_。

在不同队列上的队列操作并没有隐式的顺序限制，可能以任何顺序执行。
不同队列间显式的顺序限制可以通过<<synchronization-semaphores,semaphores>> 和
<<synchronization-fences,fences>>表述。

提交到单个队列的命令缓冲区遵循<<synchronization-submission-order, submission order>> 和其他
<<synchronization-implicit, implicit ordering guarantees>>，否则可能重叠或者乱序执行。
对于单一队列上的批次和队列提交的其他类型，和其他队列或批次提交之间并没有隐式的顺序限制。
在不同队列和各自的批次之间的附加显式的顺序限制可以通过<<synchronization-semaphores,semaphores>> 和
<<synchronization-fences,fences>>表述。

在栅栏或信号量被激发之前，可以确定的是之前被提交的队列操作已经完成了，且这些队列操作的内存写入对未来的队列操作
<<synchronization-dependencies-available-and-visible,可见>> 。
等待一个被激发的信号量或者栅栏保证之前的可用的写入对后续的命令是<<synchronization-dependencies-available-and-visible,可见的>>。

在相同或不同的批次或者提交，还有主和次命令缓冲区之间的命令缓冲区边界，不会有任何附加的顺序限制。
也就是，在任何信号量或栅栏操作之间提交多个命令缓冲区（包含执行次级命令缓冲区）执行被记录的命令，就如同他们被记录进入
单个主命令缓冲区一样，除了每一个边界当前的状态都被<<commandbuffers-statereset,重置>> 。显式顺序限制可以通过
<<synchronization,explicit synchronization primitives>>表示。

在一个命令缓冲区内多个命令之间有一些<<synchronization-implicit, 隐式顺序保证>>，但是只包含
一部分执行子集。附加的显式顺序限制可以通过多种<<synchronization, 显式同步原语>>来表示。


[NOTE]
.注意
====
Vulkan实现对提交到一个队列的任务之间的重叠执行有极大的自由度，这是由
Vulkan设备里深度的管线和并行机制导致的。
====

[[fundamentals-queueoperation-command-types]]
被记录在命令缓冲区的命令，要么执行操作（绘制、分发、清除、复制、查询/时间戳操作、开始/结束subpass操作），
设置状态（绑定管线、描述符集、缓冲区、设置动态状态、推送常量、设置render pass/subpass状态），
要们执行同步（设置/等待时间、管线屏障、renderpass/subpass依赖）。一些命令执行不止一个上述任务。状态设置命令
更新命令缓冲区的 _当前状态_。一些命令执行操作（如绘制/分发）基于从命令缓冲区开始累积到当前状态集。
执行操作的命令内的任务是可以重叠或者重新记录的，但是必须禁止改动每一个操作命令使用的状态。
通常，操作命令是那些更改帧缓冲区附件、读写缓冲区或者图像内存、想查询池写入的命令，

同步命令在两个操作命令集合之间引入显式的<<synchronization-dependencies,execution and memory dependencies>> ，这里
第二个命令集合依赖于第一个命令集合。
这些依赖强制保证在后面的集合中的某些<<synchronization-pipeline-stages, 管线阶段>>的执行发生在源集合中某些阶段的执行之后，
且某些管线阶段执行的<<synchronization-global-memory-barriers,内存访问>>的影响结果顺序发生并对彼此可见。
当没有显式的依赖或<<synchronization-implicit,隐式的顺序保证>>，操作命令也许重叠执行或者乱序执行，而且看不到
彼此的内存访问的影响结果。

设备执行队列操作和主机端是异步的。当命令缓冲区被提交到队列后控制流马上就退回到应用程序了。
应用程序必须按需求在主机端和设备端同步任务。


[[fundamentals-objectmodel-overview]]
== 对象模型

设备、队列和Vulkan中其他的的实体都是通过Vulkan对象表示的。
在API层，所有的对象都通过handle来引用。有两种类型的handle：可分发的与不可分发的。
_可分发的_ handle是不可见类型数据的指针。这个指针可被layers使用，被当作拦截API命令的一部分，
每一个API命令头接受一个可分发类型的handle作为第一个参数。
每一个不可分发类型的对象必须在其生命周期内有唯一一个handle值。

_不可分发的_handle类型是64位整型类型，其含义是Vulkan实现决定的，能把对象信息直接包含到handle里，而非通过指向一个数据结构。
不可分发类型的对象，不一定只有一个唯一的handle值。
如果其他类型的handle值变得无效了，那么销毁这样的一个handle必须不能导致此对象其他类型的handle失效，如果一个handle值被创建的次数多与被销毁的次数
，则必须不能导致同种类型的等价的handle变得无效。

所有通过sname:VkDevice (比如 with a sname:VkDevice 作为第一个参数)的命令创建的对象都是该设备私有的，必须不能被其他设备使用。


[[fundamentals-objectmodel-lifetime]]
=== 对象的生存周期

对象都是通过形如ftext:vkCreate* and ftext:vkAllocate* 这样的命令创建或者分配的。
一旦一个对象被创建或者分配，它的结构就被认为是不变的，即使某个对象类型的内容仍然是可以被自由的改动。
对象都是通过形如ftext:vkDestroy* and ftext:vkFree* 的命令来销毁或者释放的。

被分配（而不是创建）的对象从一个已存在的池子对象或者内存堆中获取资源，当被释放时把资源归还给该池子或者堆。但 对象的创建和销毁在运行时通常是低频操作，
分配或者释放对象可能是高频的。对象池帮助调节分配和释放的性能提升。

应用程序有责任跟踪Vulkan对象的生命周期，且在对象正在被使用时不能销毁它们。

应用程序所拥有的内存被内存传递所到的命令迅速使用。在使用这些内存的命令返回后，应用程序可以立刻更改或者释放这些内存。

以下对象类型被传入Vulkan命令是被使用，此后并不被用它们来创建的对象所访问。它们在传入所到的API命令执行期间被能被销毁：

  * sname:VkShaderModule
  * sname:VkPipelineCache

一个 sname:VkPipelineLayout 对象在被任何使用它的命令缓冲区记录状态时被销毁。

sname:VkDescriptorSetLayout 对象可以被操作使用其布局的描述符集合的命令访问，在描述符集合布局被销毁后这些描述符集合必须不能被flink:vkUpdateDescriptorSets
更新。否则的话，描述符集合布局可在它们不被Vulkan API命令使用的任何时刻被销毁。

在设备（如从过命令缓冲区执行）已经完成使用Vulkan对象之前，应用程序必须不能销毁这些任何类型的Vulkan对象。

如下类型的Vulkan对象在被命令缓冲区使用或者暂停执行时不能被销毁：

  * sname:VkEvent
  * sname:VkQueryPool
  * sname:VkBuffer
  * sname:VkBufferView
  * sname:VkImage
  * sname:VkImageView
  * sname:VkPipeline
  * sname:VkSampler
  * sname:VkDescriptorPool
  * sname:VkFramebuffer
  * sname:VkRenderPass
  * sname:VkCommandPool
  * sname:VkDeviceMemory
  * sname:VkDescriptorSet
ifdef::VK_NVX_device_generated_commands[]
  * sname:VkObjectTableNVX
  * sname:VkIndirectCommandsLayout
endif::VK_NVX_device_generated_commands[]

一下Vulkan对象在队列执行使用到这些对象的命令时不能被销毁：

  * sname:VkFence
  * sname:VkSemaphore
  * sname:VkCommandBuffer
  * sname:VkCommandPool

In general, objects can: be destroyed or freed in any order, even if the
object being freed is involved in the use of another object (e.g. use of a
resource in a view, use of a view in a descriptor set, use of an object in a
command buffer, binding of a memory allocation to a resource), as long as
any object that uses the freed object is not further used in any way except
to be destroyed or to be reset in such a way that it no longer uses the
other object (such as resetting a command buffer).
If the object has been reset, then it can: be used as if it never used the
freed object.
An exception to this is when there is a parent/child relationship between
objects.
In this case, the application must: not destroy a parent object before its
children, except when the parent is explicitly defined to free its children
when it is destroyed (e.g. for pool objects, as defined below).

sname:VkCommandPool objects are parents of sname:VkCommandBuffer objects.
sname:VkDescriptorPool objects are parents of sname:VkDescriptorSet objects.
sname:VkDevice objects are parents of many object types (all that take a
sname:VkDevice as a parameter to their creation).

The following Vulkan objects have specific restrictions for when they can:
be destroyed:

  * sname:VkQueue objects cannot: be explicitly destroyed.
    Instead, they are implicitly destroyed when the sname:VkDevice object
    they are retrieved from is destroyed.
  * Destroying a pool object implicitly frees all objects allocated from
    that pool.
    Specifically, destroying sname:VkCommandPool frees all
    sname:VkCommandBuffer objects that were allocated from it, and
    destroying sname:VkDescriptorPool frees all sname:VkDescriptorSet
    objects that were allocated from it.
  * sname:VkDevice objects can: be destroyed when all sname:VkQueue objects
    retrieved from them are idle, and all objects created from them have
    been destroyed.
    This includes the following objects:
  ** sname:VkFence
  ** sname:VkSemaphore
  ** sname:VkEvent
  ** sname:VkQueryPool
  ** sname:VkBuffer
  ** sname:VkBufferView
  ** sname:VkImage
  ** sname:VkImageView
  ** sname:VkShaderModule
  ** sname:VkPipelineCache
  ** sname:VkPipeline
  ** sname:VkPipelineLayout
  ** sname:VkSampler
  ** sname:VkDescriptorSetLayout
  ** sname:VkDescriptorPool
  ** sname:VkFramebuffer
  ** sname:VkRenderPass
  ** sname:VkCommandPool
  ** sname:VkCommandBuffer
  ** sname:VkDeviceMemory
  * sname:VkPhysicalDevice objects cannot: be explicitly destroyed.
    Instead, they are implicitly destroyed when the sname:VkInstance object
    they are retrieved from is destroyed.
  * sname:VkInstance objects can: be destroyed once all sname:VkDevice
    objects created from any of its sname:VkPhysicalDevice objects have been
    destroyed.


[[fundamentals-commandsyntax]]
== 命令的语法和duration

The Specification describes Vulkan commands as functions or procedures using
C99 syntax.
Language bindings for other languages such as C++ and JavaScript may: allow
for stricter parameter passing, or object-oriented interfaces.

Vulkan uses the standard C types for the base type of scalar parameters
(e.g. types from +stdint.h+), with exceptions described below, or elsewhere
in the text when appropriate:

// refBegin VkBool32 Vulkan boolean type

basetype:VkBool32 represents boolean `True` and `False` values, since C does
not have a sufficiently portable built-in boolean type:

include::../api/basetypes/VkBool32.txt[]

ename:VK_TRUE represents a boolean *True* (integer 1) value, and
ename:VK_FALSE a boolean *False* (integer 0) value.

All values returned from a Vulkan implementation in a basetype:VkBool32 will
be either ename:VK_TRUE or ename:VK_FALSE.

Applications must: not pass any other values than ename:VK_TRUE or
ename:VK_FALSE into a Vulkan implementation where a basetype:VkBool32 is
expected.

// refEnd VkBool32

// refBegin VkDeviceSize Vulkan device memory size and offsets

basetype:VkDeviceSize represents device memory size and offset values:

include::../api/basetypes/VkDeviceSize.txt[]

// refEnd VkDeviceSize

Commands that create Vulkan objects are of the form ftext:vkCreate* and take
stext:Vk*CreateInfo structures with the parameters needed to create the
object.
These Vulkan objects are destroyed with commands of the form
ftext:vkDestroy*.

The last in-parameter to each command that creates or destroys a Vulkan
object is pname:pAllocator.
The pname:pAllocator parameter can: be set to a non-`NULL` value such that
allocations for the given object are delegated to an application provided
callback; refer to the <<memory-allocation,Memory Allocation>> chapter for
further details.

Commands that allocate Vulkan objects owned by pool objects are of the form
ftext:vkAllocate*, and take stext:Vk*AllocateInfo structures.
These Vulkan objects are freed with commands of the form ftext:vkFree*.
These objects do not take allocators; if host memory is needed, they will
use the allocator that was specified when their parent pool was created.

Commands are recorded into a command buffer by calling API commands of the
form ftext:vkCmd*.
Each such command may: have different restrictions on where it can: be used:
in a primary and/or secondary command buffer, inside and/or outside a render
pass, and in one or more of the supported queue types.
These restrictions are documented together with the definition of each such
command.

The _duration_ of a Vulkan command refers to the interval between calling
the command and its return to the caller.


[[fundamentals-commandsyntax-results-lifetime]]
=== 获取的值的生命周期

Information is retrieved from the implementation with commands of the form
ftext:vkGet* and ftext:vkEnumerate*.

Unless otherwise specified for an individual command, the results are
_invariant_; that is, they will remain unchanged when retrieved again by
calling the same command with the same parameters, so long as those
parameters themselves all remain valid.


[[fundamentals-threadingbehavior]]
== 线程的行为

Vulkan is intended to provide scalable performance when used on multiple
host threads.
All commands support being called concurrently from multiple threads, but
certain parameters, or components of parameters are defined to be
_externally synchronized_.
This means that the caller must: guarantee that no more than one thread is
using such a parameter at a given time.

More precisely, Vulkan commands use simple stores to update software
structures representing Vulkan objects.
A parameter declared as externally synchronized may: have its software
structures updated at any time during the host execution of the command.
If two commands operate on the same object and at least one of the commands
declares the object to be externally synchronized, then the caller must:
guarantee not only that the commands do not execute simultaneously, but also
that the two commands are separated by an appropriate memory barrier (if
needed).

[NOTE]
.Note
====
Memory barriers are particularly relevant on the ARM CPU architecture which
is more weakly ordered than many developers are accustomed to from x86/x64
programming.
Fortunately, most higher-level synchronization primitives (like the pthread
library) perform memory barriers as a part of mutual exclusion, so mutexing
Vulkan objects via these primitives will have the desired effect.
====

Many object types are _immutable_, meaning the objects cannot: change once
they have been created.
These types of objects never need external synchronization, except that they
must: not be destroyed while they are in use on another thread.
In certain special cases, mutable object parameters are internally
synchronized such that they do not require external synchronization.
One example of this is the use of a sname:VkPipelineCache in
fname:vkCreateGraphicsPipelines and fname:vkCreateComputePipelines, where
external synchronization around such a heavyweight command would be
impractical.
The implementation must: internally synchronize the cache in this example,
and may: be able to do so in the form of a much finer-grained mutex around
the command.
Any command parameters that are not labeled as externally synchronized are
either not mutated by the command or are internally synchronized.
Additionally, certain objects related to a command's parameters (e.g.
command pools and descriptor pools) may: be affected by a command, and must:
also be externally synchronized.
These implicit parameters are documented as described below.

Parameters of commands that are externally synchronized are listed below.

include::../hostsynctable/parameters.txt[]

There are also a few instances where a command can: take in a user allocated
list whose contents are externally synchronized parameters.
In these cases, the caller must: guarantee that at most one thread is using
a given element within the list at a given time.
These parameters are listed below.

include::../hostsynctable/parameterlists.txt[]

In addition, there are some implicit parameters that need to be externally
synchronized.
For example, all pname:commandBuffer parameters that need to be externally
synchronized imply that the pname:commandPool that was passed in when
creating that command buffer also needs to be externally synchronized.
The implicit parameters and their associated object are listed below.

include::../hostsynctable/implicit.txt[]


[[fundamentals-errors]]
== 错误

Vulkan is a layered API.
The lowest layer is the core Vulkan layer, as defined by this Specification.
The application can: use additional layers above the core for debugging,
validation, and other purposes.

One of the core principles of Vulkan is that building and submitting command
buffers should: be highly efficient.
Thus error checking and validation of state in the core layer is minimal,
although more rigorous validation can: be enabled through the use of layers.

The core layer assumes applications are using the API correctly.
Except as documented elsewhere in the Specification, the behavior of the
core layer to an application using the API incorrectly is undefined, and
may: include program termination.
However, implementations must: ensure that incorrect usage by an application
does not affect the integrity of the operating system, the Vulkan
implementation, or other Vulkan client applications in the system, and does
not allow one application to access data belonging to another application.
Applications can: request stronger robustness guarantees by enabling the
pname:robustBufferAccess feature as described in <<features>>.

Validation of correct API usage is left to validation layers.
Applications should: be developed with validation layers enabled, to help
catch and eliminate errors.
Once validated, released applications should: not enable validation layers
by default.


[[fundamentals-validusage]]
=== Valid Usage

Valid usage defines a set of conditions which must: be met in order to
achieve well-defined run-time behavior in an application.
These conditions depend only on Vulkan state, and the parameters or objects
whose usage is constrained by the condition.

Some valid usage conditions have dependencies on run-time limits or feature
availability.
It is possible to validate these conditions against Vulkan's minimum
supported values for these limits and features, or some subset of other
known values.

Valid usage conditions do not cover conditions where well-defined behavior
(including returning an error code) exists.

Valid usage conditions should: apply to the command or structure where
complete information about the condition would be known during execution of
an application.
This is such that a validation layer or linter can: be written directly
against these statements at the point they are specified.

[NOTE]
.Note
====
This does lead to some non-obvious places for valid usage statements.
For instance, the valid values for a structure might depend on a separate
value in the calling command.
In this case, the structure itself will not reference this valid usage as it
is impossible to determine validity from the structure that it is invalid -
instead this valid usage would be attached to the calling command.

Another example is draw state - the state setters are independent, and can
cause a legitimately invalid state configuration between draw calls; so the
valid usage statements are attached to the place where all state needs to be
valid - at the draw command.
====

Valid usage conditions are described in a block labelled "`Valid Usage`"
following each command or structure they apply to.


[[fundamentals-implicit-validity]]
=== Implicit Valid Usage

Some valid usage conditions apply to all commands and structures in the API,
unless explicitly denoted otherwise for a specific command or structure.
These conditions are considered _implicit_, and are described in a block
labelled "`Valid Usage (Implicit)`" following each command or structure they
apply to.
Implicit valid usage conditions are described in detail below.


[[fundamentals-validusage-handles]]
==== Valid Usage for Object Handles

Any input parameter to a command that is an object handle must: be a valid
object handle, unless otherwise specified.
An object handle is valid if:

  * It has been created or allocated by a previous, successful call to the
    API.
    Such calls are noted in the specification.
  * It has not been deleted or freed by a previous call to the API.
    Such calls are noted in the specification.
  * Any objects used by that object, either as part of creation or
    execution, must: also be valid.

The reserved values dlink:VK_NULL_HANDLE and `NULL` can: be used in place of
valid non-dispatchable handles and dispatchable handles, respectively, when
_explicitly called out in the specification_.
Any command that creates an object successfully must: not return these
values.
It is valid to pass these values to ftext:vkDestroy* or ftext:vkFree*
commands, which will silently ignore these values.


[[fundamentals-validusage-pointers]]
==== Valid Usage for Pointers

Any parameter that is a pointer must: be a valid pointer.
A pointer is valid if it points at memory containing values of the number
and type(s) expected by the command, and all fundamental types accessed
through the pointer (e.g. as elements of an array or as members of a
structure) satisfy the alignment requirements of the host processor.


[[fundamentals-validusage-enums]]
==== Valid Usage for Enumerated Types

Any parameter of an enumerated type must: be a valid enumerant for that
type.
A enumerant is valid if:

  * The enumerant is defined as part of the enumerated type.
  * The enumerant is not one of the special values defined for the
    enumerated type, which are suffixed with etext:_BEGIN_RANGE,
    etext:_END_RANGE, etext:_RANGE_SIZE or etext:_MAX_ENUM.


[[fundamentals-validusage-flags]]
==== Valid Usage for Flags

// refBegin VkFlags Vulkan bitmasks

A collection of flags is represented by a bitmask using the type
basetype:VkFlags:

include::../api/basetypes/VkFlags.txt[]

Bitmasks are passed to many commands and structures to compactly represent
options, but basetype:VkFlags is not used directly in the API.
Instead, a etext:Vk*Flags type which is an alias of basetype:VkFlags, and
whose name matches the corresponding etext:Vk*FlagBits that are valid for
that type, is used.
These aliases are described in the <<boilerplate-flags,Flag Types>> appendix
of the Specification.

// refEnd VkFlags VkColorComponentFlags

Any etext:Vk*Flags member or parameter used in the API must: be a valid
combination of bit flags.
A valid combination is either zero or the bitwise OR of valid bit flags.
A bit flag is valid if:

  * The bit flag is defined as part of the etext:Vk*FlagBits type, where the
    bits type is obtained by taking the flag type and replacing the trailing
    etext:Flags with etext:FlagBits.
    For example, a flag value of type elink:VkColorComponentFlags must:
    contain only bit flags defined by elink:VkColorComponentFlagBits.
  * The flag is allowed in the context in which it is being used.
    For example, in some cases, certain bit flags or combinations of bit
    flags are mutually exclusive.


[[fundamentals-validusage-sType]]
==== Valid Usage for Structure Types

Any parameter that is a structure containing a pname:sType member must: have
a value of ptext:sType which is a valid elink:VkStructureType value matching
the type of the structure.
As a general rule, the name of this value is obtained by taking the
structure name, stripping the leading etext:Vk, prefixing each capital
letter with etext:_, converting the entire resulting string to upper case,
and prefixing it with etext:VK_STRUCTURE_TYPE_.
For example, structures of type sname:VkImageCreateInfo must: have a
ptext:sType value of ename:VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO.

The values ename:VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO and
ename:VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO are reserved for internal
use by the loader, and do not have corresponding Vulkan structures in this
specification.

The list of supported <<boilerplate-sType,structure types>> is defined in an
appendix.


[[fundamentals-validusage-pNext]]
==== Valid Usage for Structure Pointer Chains

Any parameter that is a structure containing a `void*` ptext:pNext member
must: have a value of pname:pNext that is either `NULL`, or points to a
valid structure defined by an extension, containing ptext:sType and
ptext:pNext members as described in the <<vulkan-styleguide,Vulkan
Documentation and Extensions>> document in the section "`Extension
Interactions`".
If that extension is supported by the implementation, then it must: be
enabled.
Any component of the implementation (the loader, any enabled layers, and
drivers) must: skip over, without processing (other than reading the
pname:sType and pname:pNext members) any chained structures with pname:sType
values not defined by extensions supported by that component.

Extension structures are not described in the base Vulkan specification, but
either in layered specifications incorporating those extensions, or in
separate vendor-provided documents.


[[fundamentals-validusage-nested-structs]]
==== Valid Usage for Nested Structures

The above conditions also apply recursively to members of structures
provided as input to a command, either as a direct argument to the command,
or themselves a member of another structure.

Specifics on valid usage of each command are covered in their individual
sections.


[[fundamentals-returncodes]]
=== Return Codes

// refBegin VkResult Vulkan command return codes

While the core Vulkan API is not designed to capture incorrect usage, some
circumstances still require return codes.
Commands in Vulkan return their status via return codes that are in one of
two categories:

  * Successful completion codes are returned when a command needs to
    communicate success or status information.
    All successful completion codes are non-negative values.
  * Run time error codes are returned when a command needs to communicate a
    failure that could only be detected at run time.
    All run time error codes are negative values.

All return codes in Vulkan are reported via elink:VkResult return values.
The possible codes are:

include::../api/enums/VkResult.txt[]

[[fundamentals-successcodes]]
.Success Codes
  * ename:VK_SUCCESS Command successfully completed
  * ename:VK_NOT_READY A fence or query has not yet completed
  * ename:VK_TIMEOUT A wait operation has not completed in the specified
    time
  * ename:VK_EVENT_SET An event is signaled
  * ename:VK_EVENT_RESET An event is unsignaled
  * ename:VK_INCOMPLETE A return array was too small for the result
ifdef::VK_KHR_swapchain[]
  * ename:VK_SUBOPTIMAL_KHR A swapchain no longer matches the surface
    properties exactly, but can: still be used to present to the surface
    successfully.
endif::VK_KHR_swapchain[]

[[fundamentals-errorcodes]]
.Error codes
  * ename:VK_ERROR_OUT_OF_HOST_MEMORY A host memory allocation has failed.
  * ename:VK_ERROR_OUT_OF_DEVICE_MEMORY A device memory allocation has
    failed.
  * ename:VK_ERROR_INITIALIZATION_FAILED Initialization of an object could
    not be completed for implementation-specific reasons.
  * ename:VK_ERROR_DEVICE_LOST The logical or physical device has been lost.
    See <<devsandqueues-lost-device,Lost Device>>
  * ename:VK_ERROR_MEMORY_MAP_FAILED Mapping of a memory object has failed.
  * ename:VK_ERROR_LAYER_NOT_PRESENT A requested layer is not present or
    could not be loaded.
  * ename:VK_ERROR_EXTENSION_NOT_PRESENT A requested extension is not
    supported.
  * ename:VK_ERROR_FEATURE_NOT_PRESENT A requested feature is not supported.
  * ename:VK_ERROR_INCOMPATIBLE_DRIVER The requested version of Vulkan is
    not supported by the driver or is otherwise incompatible for
    implementation-specific reasons.
  * ename:VK_ERROR_TOO_MANY_OBJECTS Too many objects of the type have
    already been created.
  * ename:VK_ERROR_FORMAT_NOT_SUPPORTED A requested format is not supported
    on this device.
  * ename:VK_ERROR_FRAGMENTED_POOL A requested pool allocation has failed
    due to fragmentation of the pool's memory.
ifdef::VK_KHR_surface[]
  * ename:VK_ERROR_SURFACE_LOST_KHR A surface is no longer available.
  * ename:VK_ERROR_NATIVE_WINDOW_IN_USE_KHR The requested window is already
    in use by Vulkan or another API in a manner which prevents it from being
    used again.
endif::VK_KHR_surface[]
ifdef::VK_KHR_swapchain[]
  * ename:VK_ERROR_OUT_OF_DATE_KHR A surface has changed in such a way that
    it is no longer compatible with the swapchain, and further presentation
    requests using the swapchain will fail.
    Applications must: query the new surface properties and recreate their
    swapchain if they wish to continue presenting to the surface.
endif::VK_KHR_swapchain[]
ifdef::VK_KHR_display_swapchain[]
  * ename:VK_ERROR_INCOMPATIBLE_DISPLAY_KHR The display used by a swapchain
    does not use the same presentable image layout, or is incompatible in a
    way that prevents sharing an image.
endif::VK_KHR_display_swapchain[]
ifdef::VK_NV_glsl_shader[]
  * ename:VK_ERROR_INVALID_SHADER_NV One or more shaders failed to compile
    or link.
    More details are reported back to the application via
    +VK_EXT_debug_report+ if enabled.
endif::VK_NV_glsl_shader[]
ifdef::VK_KHR_maintenance1[]
  * ename:VK_ERROR_OUT_OF_POOL_MEMORY_KHR There is no more memory in the
    descriptor set pool.
endif::VK_KHR_maintenance1[]

If a command returns a run time error, it will leave any result pointers
unmodified, unless other behavior is explicitly defined in the
specification.

Out of memory errors do not damage any currently existing Vulkan objects.
Objects that have already been successfully created can: still be used by
the application.

Performance-critical commands generally do not have return codes.
If a run time error occurs in such commands, the implementation will defer
reporting the error until a specified point.
For commands that record into command buffers (ftext:vkCmd*) run time errors
are reported by fname:vkEndCommandBuffer.

// refEnd VkResult TBD


[[fundamentals-numerics]]
== Numeric Representation and Computation

Implementations normally perform computations in floating-point, and must:
meet the range and precision requirements defined under "`Floating-Point
Computation`" below.

These requirements only apply to computations performed in Vulkan operations
outside of shader execution, such as texture image specification and
sampling, and per-fragment operations.
Range and precision requirements during shader execution differ and are
specified by the <<spirvenv-precision-operation, Precision and Operation of
SPIR-V Instructions>> section.

In some cases, the representation and/or precision of operations is
implicitly limited by the specified format of vertex or texel data consumed
by Vulkan.
Specific floating-point formats are described later in this section.


[[fundamentals-floatingpoint]]
=== 浮点计算

Most floating-point computation is performed in SPIR-V shader modules.
The properties of computation within shaders are constrained as defined by
the <<spirvenv-precision-operation, Precision and Operation of SPIR-V
Instructions>> section.

Some floating-point computation is performed outside of shaders, such as
viewport and depth range calculations.
For these computations, we do not specify how floating-point numbers are to
be represented, or the details of how operations on them are performed, but
only place minimal requirements on representation and precision as described
in the remainder of this section.

ifdef::editing-notes[]
[NOTE]
.editing-note
====
(Jon, Bug 14966) This is a rat's nest of complexity, both in terms of
describing/enumerating places such computation may: take place (other than
"`not shader code`") and in how implementations may: do it.
We have consciously deferred the resolution of this issue to post-1.0, and
in the meantime, the following language inherited from the OpenGL
Specification is inserted as a placeholder.
Hopefully it can: be tightened up considerably.
====
endif::editing-notes[]

We require simply that numbers' floating-point parts contain enough bits and
that their exponent fields are large enough so that individual results of
floating-point operations are accurate to about 1 part in 10^5^.
The maximum representable magnitude for all floating-point values must: be
at least 2^32^.

  :: [eq]#x {times} 0 = 0 {times} x = 0# for any non-infinite and
     non-[eq]#NaN# [eq]#x#.
  :: [eq]#1 {times} x = x {times} 1 = x#.
  :: [eq]#x + 0 = 0 + x = x#.
  :: [eq]#0^0^ = 1#.

Occasionally, further requirements will be specified.
Most single-precision floating-point formats meet these requirements.

The special values [eq]#Inf# and [eq]#-Inf# encode values with magnitudes
too large to be represented; the special value [eq]#NaN# encodes {ldquo}Not
A Number{rdquo} values resulting from undefined arithmetic operations such
as [eq]#0 / 0#.
Implementations may: support [eq]#Inf# and [eq]#NaN# in their floating-point
computations.

Any representable floating-point value is legal as input to a Vulkan command
that requires floating-point data.
The result of providing a value that is not a floating-point number to such
a command is unspecified, but must: not lead to Vulkan interruption or
termination.
In <<ieee-754,IEEE 754>> arithmetic, for example, providing a negative zero
or a denormalized number to an Vulkan command must: yield deterministic
results, while providing a [eq]#NaN# or [eq]#Inf# yields unspecified
results.


[[fundamentals-fp16]]
=== 16-Bit Floating-Point Numbers

16-bit floating point numbers are defined in the "`16-bit floating point
numbers`" section of the <<data-format,Khronos Data Format Specification>>.

Any representable 16-bit floating-point value is legal as input to a Vulkan
command that accepts 16-bit floating-point data.
The result of providing a value that is not a floating-point number (such as
[eq]#Inf# or [eq]#NaN#) to such a command is unspecified, but must: not lead
to Vulkan interruption or termination.
Providing a denormalized number or negative zero to Vulkan must: yield
deterministic results.


[[fundamentals-fp11]]
=== Unsigned 11-Bit Floating-Point Numbers

Unsigned 11-bit floating point numbers are defined in the "`Unsigned 11-bit
floating point numbers`" section of the <<data-format,Khronos Data Format
Specification>>.

When a floating-point value is converted to an unsigned 11-bit
floating-point representation, finite values are rounded to the closest
representable finite value.

While less accurate, implementations are allowed to always round in the
direction of zero.
This means negative values are converted to zero.
Likewise, finite positive values greater than 65024 (the maximum finite
representable unsigned 11-bit floating-point value) are converted to 65024.
Additionally: negative infinity is converted to zero; positive infinity is
converted to positive infinity; and both positive and negative [eq]#NaN# are
converted to positive [eq]#NaN#.

Any representable unsigned 11-bit floating-point value is legal as input to
a Vulkan command that accepts 11-bit floating-point data.
The result of providing a value that is not a floating-point number (such as
[eq]#Inf# or [eq]#NaN#) to such a command is unspecified, but must: not lead
to Vulkan interruption or termination.
Providing a denormalized number to Vulkan must: yield deterministic results.


[[fundamentals-fp10]]
=== Unsigned 10-Bit Floating-Point Numbers

Unsigned 10-bit floating point numbers are defined in the "`Unsigned 10-bit
floating point numbers`" section of the <<data-format,Khronos Data Format
Specification>>.

When a floating-point value is converted to an unsigned 10-bit
floating-point representation, finite values are rounded to the closest
representable finite value.

While less accurate, implementations are allowed to always round in the
direction of zero.
This means negative values are converted to zero.
Likewise, finite positive values greater than 64512 (the maximum finite
representable unsigned 10-bit floating-point value) are converted to 64512.
Additionally: negative infinity is converted to zero; positive infinity is
converted to positive infinity; and both positive and negative [eq]#NaN# are
converted to positive [eq]#NaN#.

Any representable unsigned 10-bit floating-point value is legal as input to
a Vulkan command that accepts 10-bit floating-point data.
The result of providing a value that is not a floating-point number (such as
[eq]#Inf# or [eq]#NaN#) to such a command is unspecified, but must: not lead
to Vulkan interruption or termination.
Providing a denormalized number to Vulkan must: yield deterministic results.


[[fundamentals-general]]
=== General Requirements

Some calculations require division.
In such cases (including implied divisions performed by vector
normalization), division by zero produces an unspecified result but must:
not lead to Vulkan interruption or termination.


[[fundamentals-fixedconv]]
== 浮点数据转换

When generic vertex attributes and pixel color or depth _components_ are
represented as integers, they are often (but not always) considered to be
_normalized_.
Normalized integer values are treated specially when being converted to and
from floating-point values, and are usually referred to as _normalized
fixed-point_.

In the remainder of this section, [eq]#b# denotes the bit width of the
fixed-point integer representation.
When the integer is one of the types defined by the API, [eq]#b# is the bit
width of that type.
When the integer comes from an <<resources-images,image>> containing color
or depth component texels, [eq]#b# is the number of bits allocated to that
component in its <<features-formats,specified image format>>.

The signed and unsigned fixed-point representations are assumed to be
[eq]#b#-bit binary two's-complement integers and binary unsigned integers,
respectively.


[[fundamentals-fixedfpconv]]
=== Conversion from Normalized Fixed-Point to Floating-Point

Unsigned normalized fixed-point integers represent numbers in the range
[eq]#[0,1]#.
The conversion from an unsigned normalized fixed-point value [eq]#c# to the
corresponding floating-point value [eq]#f# is defined as

[latexmath]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
f = { c \over { 2^b - 1 } }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Signed normalized fixed-point integers represent numbers in the range
[eq]#[-1,1]#.
The conversion from a signed normalized fixed-point value [eq]#c# to the
corresponding floating-point value [eq]#f# is performed using

[latexmath]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
f = \max\left( {c \over {2^{b-1} - 1}}, -1.0 \right)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Only the range [eq]#[-2^b-1^ + 1, 2^b-1^ - 1]# is used to represent signed
fixed-point values in the range [eq]#[-1,1]#.
For example, if [eq]#b = 8#, then the integer value [eq]#-127# corresponds
to [eq]#-1.0# and the value 127 corresponds to [eq]#1.0#.
Note that while zero is exactly expressible in this representation, one
value ([eq]#-128# in the example) is outside the representable range, and
must: be clamped before use.
This equation is used everywhere that signed normalized fixed-point values
are converted to floating-point.


[[fundamentals-fpfixedconv]]
=== Conversion from Floating-Point to Normalized Fixed-Point

The conversion from a floating-point value [eq]#f# to the corresponding
unsigned normalized fixed-point value [eq]#c# is defined by first clamping
[eq]#f# to the range [eq]#[0,1]#, then computing

  :: [eq]#c = convertFloatToUint(f {times} (2^b^ - 1), b)#

where [eq]#convertFloatToUint}(r,b)# returns one of the two unsigned binary
integer values with exactly [eq]#b# bits which are closest to the
floating-point value [eq]#r#.
Implementations should: round to nearest.
If [eq]#r# is equal to an integer, then that integer value must: be
returned.
In particular, if [eq]#f# is equal to 0.0 or 1.0, then [eq]#c# must: be
assigned 0 or [eq]#2^b^ - 1#, respectively.

The conversion from a floating-point value [eq]#f# to the corresponding
signed normalized fixed-point value [eq]#c# is performed by clamping [eq]#f#
to the range [eq]#[-1,1]#, then computing

  :: [eq]#c = convertFloatToInt(f {times} (2^b-1^ - 1), b)#

where [eq]#convertFloatToInt(r,b)# returns one of the two signed
two's-complement binary integer values with exactly [eq]#b# bits which are
closest to the floating-point value [eq]#r#.
Implementations should: round to nearest.
If [eq]#r# is equal to an integer, then that integer value must: be
returned.
In particular, if [eq]#f# is equal to -1.0, 0.0, or 1.0, then [eq]#c# must:
be assigned [eq]#-(2^b-1^ - 1)#, 0, or [eq]#2^b-1^ - 1#, respectively.

This equation is used everywhere that floating-point values are converted to
signed normalized fixed-point.


[[fundamentals-versionnum]]
== API版本数字和语义

The Vulkan version number is used in several places in the API.
In each such use, the API _major version number_, _minor version number_,
and _patch version number_ are packed into a 32-bit integer as follows:

  * The major version number is a 10-bit integer packed into bits 31-22.
  * The minor version number is a 10-bit integer packed into bits 21-12.
  * The patch version number is a 12-bit integer packed into bits 11-0.

Differences in any of the Vulkan version numbers indicates a change to the
API in some way, with each part of the version number indicating a different
scope of changes.

A difference in patch version numbers indicates that some usually small part
of the specification or header has been modified, typically to fix a bug,
and may: have an impact on the behavior of existing functionality.
Differences in this version number should: not affect either _full
compatibility_ or _backwards compatibility_ between two versions, or add
additional interfaces to the API.

A difference in minor version numbers indicates that some amount of new
functionality has been added.
This will usually include new interfaces in the header, and may: also
include behavior changes and bug fixes.
Functionality may: be deprecated in a minor revision, but will not be
removed.
When a new minor version is introduced, the patch version is reset to 0, and
each minor revision maintains its own set of patch versions.
Differences in this version should: not affect backwards compatibility, but
will affect full compatibility.

A difference in major version numbers indicates a large set of changes to
the API, potentially including new functionality and header interfaces,
behavioral changes, removal of deprecated features, modification or outright
replacement of any feature, and is thus very likely to break any and all
compatibility.
Differences in this version will typically require significant modification
to an application in order for it to function.

C language macros for manipulating version numbers are defined in the
<<boilerplate-versions,Version Number Macros>> appendix.


[[fundamentals-common-objects]]
== 常见对象类型

Some types of Vulkan objects are used in many different structures and
command parameters, and are described here.
These types include _offsets_, _extents_, and _rectangles_.


=== Offsets

Offsets are used to describe a pixel location within an image or
framebuffer, as an (x,y) location for two-dimensional images, or an (x,y,z)
location for three-dimensional images.

// refBegin VkOffset2D Structure specifying a two-dimensional offset

A two-dimensional offsets is defined by the structure:

include::../api/structs/VkOffset2D.txt[]

include::../validity/structs/VkOffset2D.txt[]

// refBegin VkOffset3D Structure specifying a three-dimensional offset

A three-dimensional offset is defined by the structure:

include::../api/structs/VkOffset3D.txt[]

include::../validity/structs/VkOffset3D.txt[]


=== Extents

Extents are used to describe the size of a rectangular region of pixels
within an image or framebuffer, as (width,height) for two-dimensional
images, or as (width,height,depth) for three-dimensional images.

// refBegin VkExtent2D Structure specifying a two-dimensional extent

A two-dimensional extent is defined by the structure:

include::../api/structs/VkExtent2D.txt[]

include::../validity/structs/VkExtent2D.txt[]

// refBegin VkExtent3D Structure specifying a three-dimensional extent

A three-dimensional extent is defined by the structure:

include::../api/structs/VkExtent3D.txt[]

include::../validity/structs/VkExtent3D.txt[]


=== Rectangles

// refBegin VkRect2D Structure specifying a two-dimensional subregion

Rectangles are used to describe a specified rectangular region of pixels
within an image or framebuffer.
Rectangles include both an offset and an extent of the same dimensionality,
as described above.
Two-dimensional rectangles are defined by the structure

include::../api/structs/VkRect2D.txt[]

include::../validity/structs/VkRect2D.txt[]
