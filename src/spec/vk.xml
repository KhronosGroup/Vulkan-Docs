<?xml version="1.0" encoding="UTF-8"?>
<registry>
    <comment>
Copyright (c) 2015-2016 The Khronos Group Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and/or associated documentation files (the
"Materials"), to deal in the Materials without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Materials, and to
permit persons to whom the Materials are furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Materials.

THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

------------------------------------------------------------------------

This file, vk.xml, is the Vulkan API Registry. It is a critically important
and normative part of the Vulkan Specification, including a canonical
machine-readable definition of the API, parameter and member validation
language incorporated into the Specification and reference pages, and other
material which is registered by Khronos, such as tags used by extension and
layer authors. The only authoritative version of vk.xml is the one
maintained in the master branch of the Khronos Vulkan GitHub project.
    </comment>

    <!-- SECTION: Vulkan vendor IDs for physical devices without PCI vendor IDs -->
    <vendorids>
        <vendorid name="KHR"    id="0x10000"            comment="This is the next available Khronos vendor ID"/>
        <vendorid name="VIV"    id="0x10001"            comment="Vivante vendor ID"/>
        <vendorid name="VSI"    id="0x10002"            comment="VeriSilicon vendor ID"/>
    </vendorids>

    <!-- SECTION: Vulkan vendor/author tags for extensions and layers -->
    <tags>
        <tag name="IMG"         author="Imagination Technologies"      contact="Michael Worcester @michaelworcester"/>
        <tag name="AMD"         author="Advanced Micro Devices, Inc."  contact="Daniel Rakos @aqnuep"/>
        <tag name="ARM"         author="ARM Limited"                   contact="Jan-Harald Fredriksen @janharald"/>
        <tag name="FSL"         author="Freescale Semiconductor, Inc." contact="Norbert Nopper @FslNopper"/>
        <tag name="BRCM"        author="Broadcom Corporation"          contact="Graeme Leese @gnl21"/>
        <tag name="NXP"         author="NXP Semiconductors N.V."       contact="Norbert Nopper @FslNopper"/>
        <tag name="NV"          author="NVIDIA Corporation"            contact="Daniel Koch @dgkoch"/>
        <tag name="NVX"         author="NVIDIA Corporation"            contact="Daniel Koch @dgkoch"/>
        <tag name="VIV"         author="Vivante Corporation"           contact="Yanjun Zhang @yanjunzhang"/>
        <tag name="VSI"         author="VeriSilicon Holdings Co., Ltd." contact="Yanjun Zhang @yanjunzhang"/>
        <tag name="KDAB"        author="KDAB"                          contact="Sean Harmer @seanharmer"/>
        <tag name="ANDROID"     author="Google, Inc."                  contact="Jesse Hall @jessehall"/>
        <tag name="CHROMIUM"    author="Google, Inc."                  contact="Jesse Hall @jessehall"/>
        <tag name="GOOGLE"      author="Google, Inc."                  contact="Jesse Hall @jessehall"/>
        <tag name="QCOM"        author="Qualcomm Technologies, Inc."   contact="Maurice Ribble @mribble"/>
        <tag name="LUNARG"      author="LunarG, Inc."                  contact="Karen Ghavam @KarenGhavam"/>
        <tag name="SAMSUNG"     author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
        <tag name="SEC"         author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
        <tag name="TIZEN"       author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
        <tag name="RENDERDOC"   author="RenderDoc (renderdoc.org)"     contact="baldurk@baldurk.org"/>
    </tags>

    <!-- SECTION: Vulkan type definitions -->
    <types>
        <type name="vk_platform" category="include">#include "vk_platform.h"</type>
            <!-- WSI extensions -->
        <type category="include">#include "<name>vulkan.h</name>"</type>
        <type category="include">#include &lt;<name>X11/Xlib.h</name>&gt;</type>
        <type category="include">#include &lt;<name>android/native_window.h</name>&gt;</type>
        <type category="include">#include &lt;<name>mir_toolkit/client_types.h</name>&gt;</type>
        <type category="include">#include &lt;<name>wayland-client.h</name>&gt;</type>
        <type category="include">#include &lt;<name>windows.h</name>&gt;</type>
        <type category="include">#include &lt;<name>xcb/xcb.h</name>&gt;</type>

        <type requires="X11/Xlib.h" name="Display"/>
        <type requires="X11/Xlib.h" name="VisualID"/>
        <type requires="X11/Xlib.h" name="Window"/>
        <type requires="android/native_window.h" name="ANativeWindow"/>
        <type requires="mir_toolkit/client_types.h" name="MirConnection"/>
        <type requires="mir_toolkit/client_types.h" name="MirSurface"/>
        <type requires="wayland-client.h" name="wl_display"/>
        <type requires="wayland-client.h" name="wl_surface"/>
        <type requires="windows.h" name="HINSTANCE"/>
        <type requires="windows.h" name="HWND"/>
        <type requires="windows.h" name="HANDLE"/>
        <type requires="windows.h" name="SECURITY_ATTRIBUTES"/>
        <type requires="windows.h" name="DWORD"/>
        <type requires="xcb/xcb.h" name="xcb_connection_t"/>
        <type requires="xcb/xcb.h" name="xcb_visualid_t"/>
        <type requires="xcb/xcb.h" name="xcb_window_t"/>

        <type category="define">#define <name>VK_MAKE_VERSION</name>(major, minor, patch) \
    (((major) &lt;&lt; 22) | ((minor) &lt;&lt; 12) | (patch))</type>
        <type category="define">#define <name>VK_VERSION_MAJOR</name>(version) ((uint32_t)(version) &gt;&gt; 22)</type>
        <type category="define">#define <name>VK_VERSION_MINOR</name>(version) (((uint32_t)(version) &gt;&gt; 12) &amp; 0x3ff)</type>
        <type category="define">#define <name>VK_VERSION_PATCH</name>(version) ((uint32_t)(version) &amp; 0xfff)</type>

        <type category="define">// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
//#define <name>VK_API_VERSION</name> <type>VK_MAKE_VERSION</type>(1, 0, 0)</type>    <!-- The patch version here should never be set to anything other than 0 -->
        <type category="define">// Vulkan 1.0 version number
#define <name>VK_API_VERSION_1_0</name> <type>VK_MAKE_VERSION</type>(1, 0, 0)</type>    <!-- The patch version here should never be set to anything other than 0 -->
        <type category="define">// Version of this file
#define <name>VK_HEADER_VERSION</name> 38</type>

        <type category="define">
#define <name>VK_DEFINE_HANDLE</name>(object) typedef struct object##_T* object;</type>

        <type category="define" name="VK_DEFINE_NON_DISPATCHABLE_HANDLE">
#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) &amp;&amp; !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif
        </type>

        <type category="define">
#define <name>VK_NULL_HANDLE</name> 0
        </type>

        <type category="basetype">typedef <type>uint32_t</type> <name>VkSampleMask</name>;</type>
        <type category="basetype">typedef <type>uint32_t</type> <name>VkBool32</name>;</type>
        <type category="basetype">typedef <type>uint32_t</type> <name>VkFlags</name>;</type>
        <type category="basetype">typedef <type>uint64_t</type> <name>VkDeviceSize</name>;</type>
        <!-- Basic C types, pulled in via vk_platform.h -->
        <type requires="vk_platform" name="void"/>
        <type requires="vk_platform" name="char"/>
        <type requires="vk_platform" name="float"/>
        <type requires="vk_platform" name="uint8_t"/>
        <type requires="vk_platform" name="uint32_t"/>
        <type requires="vk_platform" name="uint64_t"/>
        <type requires="vk_platform" name="int32_t"/>
        <type requires="vk_platform" name="size_t"/>
        <!-- Bitmask types -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkFramebufferCreateFlags</name>;</type>               <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPoolCreateFlags</name>;</type>                 <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkRenderPassCreateFlags</name>;</type>                <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSamplerCreateFlags</name>;</type>                   <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineLayoutCreateFlags</name>;</type>            <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCacheCreateFlags</name>;</type>             <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDepthStencilStateCreateFlags</name>;</type> <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDynamicStateCreateFlags</name>;</type>      <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineColorBlendStateCreateFlags</name>;</type>   <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineMultisampleStateCreateFlags</name>;</type>  <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationStateCreateFlags</name>;</type>       <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineViewportStateCreateFlags</name>;</type>     <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineTessellationStateCreateFlags</name>;</type> <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineInputAssemblyStateCreateFlags</name>;</type><!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineVertexInputStateCreateFlags</name>;</type>  <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineShaderStageCreateFlags</name>;</type>       <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorSetLayoutCreateFlags</name>;</type>       <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkBufferViewCreateFlags</name>;</type>                <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkInstanceCreateFlags</name>;</type>                  <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceCreateFlags</name>;</type>                    <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceQueueCreateFlags</name>;</type>               <!-- creation flags -->
        <type requires="VkQueueFlagBits"                  category="bitmask">typedef <type>VkFlags</type> <name>VkQueueFlags</name>;</type>                       <!-- Queue capabilities -->
        <type requires="VkMemoryPropertyFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryPropertyFlags</name>;</type>              <!-- Memory properties passed into vkAllocateMemory(). -->
        <type requires="VkMemoryHeapFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryHeapFlags</name>;</type>                  <!-- Memory heap flags -->
        <type requires="VkAccessFlagBits"                 category="bitmask">typedef <type>VkFlags</type> <name>VkAccessFlags</name>;</type>                      <!-- Memory access flags passed to barrier/dependency operations -->
        <type requires="VkBufferUsageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkBufferUsageFlags</name>;</type>                 <!-- Buffer usage flags -->
        <type requires="VkBufferCreateFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkBufferCreateFlags</name>;</type>                <!-- Buffer creation flags -->
        <type requires="VkShaderStageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkShaderStageFlags</name>;</type>                 <!-- Shader stage flags -->
        <type requires="VkImageUsageFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkImageUsageFlags</name>;</type>                  <!-- Image usage flags -->
        <type requires="VkImageCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageCreateFlags</name>;</type>                 <!-- Image creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkImageViewCreateFlags</name>;</type>             <!-- Image view creation flags (no bits yet) -->
        <type requires="VkPipelineCreateFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCreateFlags</name>;</type>              <!-- Pipeline creation flags -->
        <type requires="VkColorComponentFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkColorComponentFlags</name>;</type>              <!-- Color component flags -->
        <type requires="VkFenceCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkFenceCreateFlags</name>;</type>                 <!-- Fence creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreCreateFlags</name>;</type>             <!-- Semaphore creation flags -->
        <type requires="VkFormatFeatureFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkFormatFeatureFlags</name>;</type>               <!-- Format capability flags -->
        <type requires="VkQueryControlFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkQueryControlFlags</name>;</type>                <!-- Query control flags -->
        <type requires="VkQueryResultFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkQueryResultFlags</name>;</type>                 <!-- Query result flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkShaderModuleCreateFlags</name>;</type>          <!-- Shader module creation flags (no bits yet) -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkEventCreateFlags</name>;</type>                 <!-- Event creation flags  (no bits yet) -->
        <type requires="VkCommandPoolCreateFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolCreateFlags</name>;</type>               <!-- Command pool creation flags -->
        <type requires="VkCommandPoolResetFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolResetFlags</name>;</type>                <!-- Command pool reset flags -->
        <type requires="VkCommandBufferResetFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferResetFlags</name>;</type>              <!-- Command buffer reset flags -->
        <type requires="VkCommandBufferUsageFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferUsageFlags</name>;</type>              <!-- Command buffer usage flags -->
        <type requires="VkQueryPipelineStatisticFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPipelineStatisticFlags</name>;</type>      <!-- Pipeline statistics flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryMapFlags</name>;</type>                   <!-- Memory mapping flags (no bits yet) -->
        <type requires="VkImageAspectFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageAspectFlags</name>;</type>                 <!-- Bitmask of image aspects -->
        <type requires="VkSparseMemoryBindFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkSparseMemoryBindFlags</name>;</type>            <!-- Sparse memory bind flags -->
        <type requires="VkSparseImageFormatFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkSparseImageFormatFlags</name>;</type>           <!-- Sparse image memory requirements flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSubpassDescriptionFlags</name>;</type>          <!-- Subpass description flags -->
        <type requires="VkPipelineStageFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineStageFlags</name>;</type>               <!-- Pipeline stages -->
        <type requires="VkSampleCountFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkSampleCountFlags</name>;</type>                 <!-- Pipeline stages -->
        <type requires="VkAttachmentDescriptionFlagBits"  category="bitmask">typedef <type>VkFlags</type> <name>VkAttachmentDescriptionFlags</name>;</type>       <!-- Render pass attachment description flags -->
        <type requires="VkStencilFaceFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkStencilFaceFlags</name>;</type>                 <!-- Stencil face flags -->
        <type requires="VkCullModeFlagBits"               category="bitmask">typedef <type>VkFlags</type> <name>VkCullModeFlags</name>;</type>                    <!-- Cull mode flags -->
        <type requires="VkDescriptorPoolCreateFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorPoolCreateFlags</name>;</type>        <!-- Descriptor pool creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorPoolResetFlags</name>;</type>         <!-- Descriptor pool reset flags -->
        <type requires="VkDependencyFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkDependencyFlags</name>;</type>                  <!-- Pipeline barrier and subpass dependency flags -->

        <type requires="VkIndirectCommandsLayoutUsageFlagBitsNVX"  category="bitmask">typedef <type>VkFlags</type> <name>VkIndirectCommandsLayoutUsageFlagsNVX</name>;</type>  <!-- Device generated commands usage flags -->
        <type requires="VkObjectEntryUsageFlagBitsNVX"             category="bitmask">typedef <type>VkFlags</type> <name>VkObjectEntryUsageFlagsNVX</name>;</type>             <!-- Object usage flags -->

            <!-- WSI extensions -->
        <type requires="VkCompositeAlphaFlagBitsKHR"      category="bitmask">typedef <type>VkFlags</type> <name>VkCompositeAlphaFlagsKHR</name>;</type>
        <type requires="VkDisplayPlaneAlphaFlagBitsKHR"   category="bitmask">typedef <type>VkFlags</type> <name>VkDisplayPlaneAlphaFlagsKHR</name>;</type>
        <type requires="VkSurfaceTransformFlagBitsKHR"    category="bitmask">typedef <type>VkFlags</type> <name>VkSurfaceTransformFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSwapchainCreateFlagsKHR</name>;</type>          <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDisplayModeCreateFlagsKHR</name>;</type>        <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDisplaySurfaceCreateFlagsKHR</name>;</type>     <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkAndroidSurfaceCreateFlagsKHR</name>;</type>     <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMirSurfaceCreateFlagsKHR</name>;</type>         <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkWaylandSurfaceCreateFlagsKHR</name>;</type>     <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkWin32SurfaceCreateFlagsKHR</name>;</type>       <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkXlibSurfaceCreateFlagsKHR</name>;</type>        <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkXcbSurfaceCreateFlagsKHR</name>;</type>         <!-- creation flags -->

        <type requires="VkDebugReportFlagBitsEXT"      category="bitmask">typedef <type>VkFlags</type> <name>VkDebugReportFlagsEXT</name>;</type>
        <type requires="VkExternalMemoryHandleTypeFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryHandleTypeFlagsNV</name>;</type>
        <type requires="VkExternalMemoryFeatureFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryFeatureFlagsNV</name>;</type>

        <!-- Types which can be void pointers or class pointers, selected at compile time -->
        <type category="handle"><type>VK_DEFINE_HANDLE</type>(<name>VkInstance</name>)</type>
        <type category="handle" parent="VkInstance"><type>VK_DEFINE_HANDLE</type>(<name>VkPhysicalDevice</name>)</type>
        <type category="handle" parent="VkPhysicalDevice"><type>VK_DEFINE_HANDLE</type>(<name>VkDevice</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_HANDLE</type>(<name>VkQueue</name>)</type>
        <type category="handle" parent="VkCommandPool"><type>VK_DEFINE_HANDLE</type>(<name>VkCommandBuffer</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDeviceMemory</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCommandPool</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBuffer</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBufferView</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkImage</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkImageView</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkShaderModule</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipeline</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipelineLayout</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSampler</name>)</type>
        <type category="handle" parent="VkDescriptorPool"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorSet</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorSetLayout</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorPool</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkFence</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSemaphore</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkEvent</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkQueryPool</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkFramebuffer</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkRenderPass</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipelineCache</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkObjectTableNVX</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkIndirectCommandsLayoutNVX</name>)</type>

        <!-- WSI extensions -->
        <type category="handle"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDisplayKHR</name>)</type>
        <type category="handle" parent="VkPhysicalDevice,VkDisplayKHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDisplayModeKHR</name>)</type>
        <type category="handle" parent="VkInstance"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSurfaceKHR</name>)</type>
        <type category="handle" parent="VkSurfaceKHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSwapchainKHR</name>)</type>
        <type category="handle" parent="VkInstance"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDebugReportCallbackEXT</name>)</type>

        <!-- Types generated from corresponding <enums> tags below -->
        <type name="VkAttachmentLoadOp" category="enum"/>
        <type name="VkAttachmentStoreOp" category="enum"/>
        <type name="VkBlendFactor" category="enum"/>
        <type name="VkBlendOp" category="enum"/>
        <type name="VkBorderColor" category="enum"/>
        <type name="VkFramebufferCreateFlagBits" category="enum"/>
        <type name="VkQueryPoolCreateFlagBits" category="enum"/>
        <type name="VkRenderPassCreateFlagBits" category="enum"/>
        <type name="VkSamplerCreateFlagBits" category="enum"/>
        <type name="VkPipelineCacheHeaderVersion" category="enum"/>
        <type name="VkPipelineLayoutCreateFlagBits" category="enum"/>
        <type name="VkPipelineCacheCreateFlagBits" category="enum"/>
        <type name="VkPipelineDepthStencilStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineDynamicStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineColorBlendStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineMultisampleStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineRasterizationStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineViewportStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineTessellationStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineInputAssemblyStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineVertexInputStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineShaderStageCreateFlagBits" category="enum"/>
        <type name="VkDescriptorSetLayoutCreateFlagBits" category="enum"/>
        <type name="VkBufferViewCreateFlagBits" category="enum"/>
        <type name="VkInstanceCreateFlagBits" category="enum"/>
        <type name="VkDeviceQueueCreateFlagBits" category="enum"/>
        <type name="VkBufferCreateFlagBits" category="enum"/>
        <type name="VkBufferUsageFlagBits" category="enum"/>
        <type name="VkColorComponentFlagBits" category="enum"/>
        <type name="VkComponentSwizzle" category="enum"/>
        <type name="VkCommandPoolCreateFlagBits" category="enum"/>
        <type name="VkCommandPoolResetFlagBits" category="enum"/>
        <type name="VkCommandBufferResetFlagBits" category="enum"/>
        <type name="VkCommandBufferLevel" category="enum"/>
        <type name="VkCommandBufferUsageFlagBits" category="enum"/>
        <type name="VkCompareOp" category="enum"/>
        <type name="VkCullModeFlagBits" category="enum"/>
        <type name="VkDescriptorType" category="enum"/>
        <type name="VkDeviceCreateFlagBits" category="enum"/>
        <type name="VkDynamicState" category="enum"/>
        <type name="VkFenceCreateFlagBits" category="enum"/>
        <type name="VkPolygonMode" category="enum"/>
        <type name="VkFormat" category="enum"/>
        <type name="VkFormatFeatureFlagBits" category="enum"/>
        <type name="VkFrontFace" category="enum"/>
        <type name="VkImageAspectFlagBits" category="enum"/>
        <type name="VkImageCreateFlagBits" category="enum"/>
        <type name="VkImageLayout" category="enum"/>
        <type name="VkImageTiling" category="enum"/>
        <type name="VkImageType" category="enum"/>
        <type name="VkImageUsageFlagBits" category="enum"/>
        <type name="VkImageViewType" category="enum"/>
        <type name="VkSharingMode" category="enum"/>
        <type name="VkIndexType" category="enum"/>
        <type name="VkLogicOp" category="enum"/>
        <type name="VkMemoryHeapFlagBits" category="enum"/>
        <type name="VkAccessFlagBits" category="enum"/>
        <type name="VkMemoryPropertyFlagBits" category="enum"/>
        <type name="VkPhysicalDeviceType" category="enum"/>
        <type name="VkPipelineBindPoint" category="enum"/>
        <type name="VkPipelineCreateFlagBits" category="enum"/>
        <type name="VkPrimitiveTopology" category="enum"/>
        <type name="VkQueryControlFlagBits" category="enum"/>
        <type name="VkQueryPipelineStatisticFlagBits" category="enum"/>
        <type name="VkQueryResultFlagBits" category="enum"/>
        <type name="VkQueryType" category="enum"/>
        <type name="VkQueueFlagBits" category="enum"/>
        <type name="VkSubpassContents" category="enum"/>
        <type name="VkResult" category="enum"/>
        <type name="VkShaderStageFlagBits" category="enum"/>
        <type name="VkSparseMemoryBindFlagBits" category="enum"/>
        <type name="VkStencilFaceFlagBits" category="enum"/>
        <type name="VkStencilOp" category="enum"/>
        <type name="VkStructureType" category="enum"/>
        <type name="VkSystemAllocationScope" category="enum"/>
        <type name="VkInternalAllocationType" category="enum"/>
        <type name="VkSamplerAddressMode" category="enum"/>
        <type name="VkFilter" category="enum"/>
        <type name="VkSamplerMipmapMode" category="enum"/>
        <type name="VkVertexInputRate" category="enum"/>
        <type name="VkPipelineStageFlagBits" category="enum"/>
        <type name="VkSparseImageFormatFlagBits" category="enum"/>
        <type name="VkSampleCountFlagBits" category="enum"/>
        <type name="VkAttachmentDescriptionFlagBits" category="enum"/>
        <type name="VkDescriptorPoolCreateFlagBits" category="enum"/>
        <type name="VkDependencyFlagBits" category="enum"/>
        <type name="VkIndirectCommandsLayoutUsageFlagBitsNVX" category="enum"/>
        <type name="VkIndirectCommandsTokenTypeNVX" category="enum"/>
        <type name="VkObjectEntryUsageFlagBitsNVX" category="enum"/>
        <type name="VkObjectEntryTypeNVX" category="enum"/>
        <!-- WSI extensions -->
        <type name="VkColorSpaceKHR" category="enum"/>
        <type name="VkCompositeAlphaFlagBitsKHR" category="enum"/>
        <type name="VkDisplayPlaneAlphaFlagBitsKHR" category="enum"/>
        <type name="VkPresentModeKHR" category="enum"/>
        <type name="VkSurfaceTransformFlagBitsKHR" category="enum"/>
        <type name="VkDebugReportFlagBitsEXT" category="enum"/>
        <type name="VkDebugReportObjectTypeEXT" category="enum"/>
        <type name="VkDebugReportErrorEXT" category="enum"/>
        <type name="VkRasterizationOrderAMD" category="enum"/>
        <type name="VkExternalMemoryHandleTypeFlagBitsNV" category="enum"/>
        <type name="VkExternalMemoryFeatureFlagBitsNV" category="enum"/>
        <type name="VkValidationCheckEXT" category="enum"/>

        <!-- The PFN_vk*Function types are used by VkAllocationCallbacks below -->
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkInternalAllocationNotification</name>)(
    <type>void</type>*                                       pUserData,
    <type>size_t</type>                                      size,
    <type>VkInternalAllocationType</type>                    allocationType,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkInternalFreeNotification</name>)(
    <type>void</type>*                                       pUserData,
    <type>size_t</type>                                      size,
    <type>VkInternalAllocationType</type>                    allocationType,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void* (VKAPI_PTR *<name>PFN_vkReallocationFunction</name>)(
    <type>void</type>*                                       pUserData,
    <type>void</type>*                                       pOriginal,
    <type>size_t</type>                                      size,
    <type>size_t</type>                                      alignment,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void* (VKAPI_PTR *<name>PFN_vkAllocationFunction</name>)(
    <type>void</type>*                                       pUserData,
    <type>size_t</type>                                      size,
    <type>size_t</type>                                      alignment,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkFreeFunction</name>)(
    <type>void</type>*                                       pUserData,
    <type>void</type>*                                       pMemory);</type>

    <!-- The PFN_vkVoidFunction type are used by VkGet*ProcAddr below -->
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkVoidFunction</name>)(void);</type>

    <!-- The PFN_vkDebugReportCallbackEXT type are used by the DEBUG_REPORT extension-->
        <type category="funcpointer">typedef VkBool32 (VKAPI_PTR *<name>PFN_vkDebugReportCallbackEXT</name>)(
    <type>VkDebugReportFlagsEXT</type>                       flags,
    <type>VkDebugReportObjectTypeEXT</type>                  objectType,
    <type>uint64_t</type>                                    object,
    <type>size_t</type>                                      location,
    <type>int32_t</type>                                     messageCode,
    const <type>char</type>*                                 pLayerPrefix,
    const <type>char</type>*                                 pMessage,
    <type>void</type>*                                       pUserData);</type>

        <!-- Struct types -->
        <type category="struct" name="VkOffset2D">
            <member><type>int32_t</type>        <name>x</name></member>
            <member><type>int32_t</type>        <name>y</name></member>
        </type>
        <type category="struct" name="VkOffset3D">
            <member><type>int32_t</type>        <name>x</name></member>
            <member><type>int32_t</type>        <name>y</name></member>
            <member><type>int32_t</type>        <name>z</name></member>
        </type>
        <type category="struct" name="VkExtent2D">
            <member><type>uint32_t</type>        <name>width</name></member>
            <member><type>uint32_t</type>        <name>height</name></member>
        </type>
        <type category="struct" name="VkExtent3D">
            <member><type>uint32_t</type>        <name>width</name></member>
            <member><type>uint32_t</type>        <name>height</name></member>
            <member><type>uint32_t</type>        <name>depth</name></member>
        </type>
        <type category="struct" name="VkViewport">
            <member><type>float</type>          <name>x</name></member>
            <member><type>float</type>          <name>y</name></member>
            <member><type>float</type>          <name>width</name></member>
            <member><type>float</type>          <name>height</name></member>
            <member><type>float</type>          <name>minDepth</name></member>
            <member><type>float</type>          <name>maxDepth</name></member>
        </type>
        <type category="struct" name="VkRect2D">
            <member><type>VkOffset2D</type>     <name>offset</name></member>
            <member><type>VkExtent2D</type>     <name>extent</name></member>
        </type>
        <type category="struct" name="VkRect3D">
            <member><type>VkOffset3D</type>     <name>offset</name></member>
            <member><type>VkExtent3D</type>     <name>extent</name></member>
        </type>
        <type category="struct" name="VkClearRect">
            <member><type>VkRect2D</type>       <name>rect</name></member>
            <member><type>uint32_t</type>       <name>baseArrayLayer</name></member>
            <member><type>uint32_t</type>       <name>layerCount</name></member>
        </type>
        <type category="struct" name="VkComponentMapping">
            <member><type>VkComponentSwizzle</type> <name>r</name></member>
            <member><type>VkComponentSwizzle</type> <name>g</name></member>
            <member><type>VkComponentSwizzle</type> <name>b</name></member>
            <member><type>VkComponentSwizzle</type> <name>a</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceProperties" returnedonly="true">
            <member><type>uint32_t</type>       <name>apiVersion</name></member>
            <member><type>uint32_t</type>       <name>driverVersion</name></member>
            <member><type>uint32_t</type>       <name>vendorID</name></member>
            <member><type>uint32_t</type>       <name>deviceID</name></member>
            <member><type>VkPhysicalDeviceType</type> <name>deviceType</name></member>
            <member><type>char</type>           <name>deviceName</name>[<enum>VK_MAX_PHYSICAL_DEVICE_NAME_SIZE</enum>]</member>
            <member><type>uint8_t</type>        <name>pipelineCacheUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member><type>VkPhysicalDeviceLimits</type> <name>limits</name></member>
            <member><type>VkPhysicalDeviceSparseProperties</type> <name>sparseProperties</name></member>
        </type>
        <type category="struct" name="VkExtensionProperties" returnedonly="true">
            <member><type>char</type>            <name>extensionName</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]</member> <!-- extension name -->
            <member><type>uint32_t</type>        <name>specVersion</name></member>                    <!-- version of the extension specification implemented -->
        </type>
        <type category="struct" name="VkLayerProperties" returnedonly="true">
            <member><type>char</type>            <name>layerName</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]</member> <!-- layer name -->
            <member><type>uint32_t</type>        <name>specVersion</name></member>                    <!-- version of the layer specification implemented -->
            <member><type>uint32_t</type>        <name>implementationVersion</name></member>                    <!-- build or release version of the layer's library -->
            <member><type>char</type>            <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member> <!-- Free-form description of the layer -->
        </type>
        <type category="struct" name="VkApplicationInfo">
            <member values="VK_STRUCTURE_TYPE_APPLICATION_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*     <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true" len="null-terminated">const <type>char</type>*     <name>pApplicationName</name></member>
            <member><type>uint32_t</type>        <name>applicationVersion</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*     <name>pEngineName</name></member>
            <member><type>uint32_t</type>        <name>engineVersion</name></member>
            <member><type>uint32_t</type>        <name>apiVersion</name></member>
        </type>
        <type category="struct" name="VkAllocationCallbacks">
            <member optional="true"><type>void</type>*           <name>pUserData</name></member>
            <member><type>PFN_vkAllocationFunction</type>   <name>pfnAllocation</name></member>
            <member><type>PFN_vkReallocationFunction</type> <name>pfnReallocation</name></member>
            <member><type>PFN_vkFreeFunction</type>    <name>pfnFree</name></member>
            <member optional="true"><type>PFN_vkInternalAllocationNotification</type> <name>pfnInternalAllocation</name></member>
            <member optional="true"><type>PFN_vkInternalFreeNotification</type> <name>pfnInternalFree</name></member>
        </type>
        <type category="struct" name="VkDeviceQueueCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*     <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkDeviceQueueCreateFlags</type>    <name>flags</name></member>              <!-- Reserved -->
            <member><type>uint32_t</type>        <name>queueFamilyIndex</name></member>
            <member><type>uint32_t</type>        <name>queueCount</name></member>
            <member len="queueCount">const <type>float</type>*    <name>pQueuePriorities</name></member>
        </type>
        <type category="struct" name="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*     <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkDeviceCreateFlags</type>    <name>flags</name></member>                   <!-- Reserved -->
            <member><type>uint32_t</type>        <name>queueCreateInfoCount</name></member>
            <member len="queueCreateInfoCount">const <type>VkDeviceQueueCreateInfo</type>* <name>pQueueCreateInfos</name></member>
            <member optional="true"><type>uint32_t</type>               <name>enabledLayerCount</name></member>
            <member len="enabledLayerCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledLayerNames</name></member>            <!-- Ordered list of layer names to be enabled -->
            <member optional="true"><type>uint32_t</type>               <name>enabledExtensionCount</name></member>
            <member len="enabledExtensionCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledExtensionNames</name></member>
            <member optional="true">const <type>VkPhysicalDeviceFeatures</type>* <name>pEnabledFeatures</name></member>
        </type>
        <type category="struct" name="VkInstanceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkInstanceCreateFlags</type>  <name>flags</name></member>                          <!-- Reserved -->
            <member optional="true">const <type>VkApplicationInfo</type>* <name>pApplicationInfo</name></member>
            <member optional="true"><type>uint32_t</type>               <name>enabledLayerCount</name></member>
            <member len="enabledLayerCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledLayerNames</name></member>            <!-- Ordered list of layer names to be enabled -->
            <member optional="true"><type>uint32_t</type>               <name>enabledExtensionCount</name></member>
            <member len="enabledExtensionCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledExtensionNames</name></member>        <!-- Extension names to be enabled -->
        </type>
        <type category="struct" name="VkQueueFamilyProperties" returnedonly="true">
            <member optional="true"><type>VkQueueFlags</type>           <name>queueFlags</name></member>                     <!-- Queue flags -->
            <member><type>uint32_t</type>               <name>queueCount</name></member>
            <member><type>uint32_t</type>               <name>timestampValidBits</name></member>
            <member><type>VkExtent3D</type>             <name>minImageTransferGranularity</name></member>    <!-- Minimum alignment requirement for image transfers -->
        </type>
        <type category="struct" name="VkPhysicalDeviceMemoryProperties" returnedonly="true">
            <member><type>uint32_t</type>               <name>memoryTypeCount</name></member>
            <member><type>VkMemoryType</type>           <name>memoryTypes</name>[<enum>VK_MAX_MEMORY_TYPES</enum>]</member>
            <member><type>uint32_t</type>               <name>memoryHeapCount</name></member>
            <member><type>VkMemoryHeap</type>           <name>memoryHeaps</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
        </type>
        <type category="struct" name="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member validextensionstructs="VkDedicatedAllocationMemoryAllocateInfoNV">const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDeviceSize</type>           <name>allocationSize</name></member>                 <!-- Size of memory allocation -->
            <member><type>uint32_t</type>               <name>memoryTypeIndex</name></member>                <!-- Index of the of the memory type to allocate from -->
        </type>
        <type category="struct" name="VkMemoryRequirements" returnedonly="true">
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>alignment</name></member>                      <!-- Specified in bytes -->
            <member><type>uint32_t</type>               <name>memoryTypeBits</name></member>                 <!-- Bitmask of the allowed memory type indices into memoryTypes[] for this object -->
        </type>
        <type category="struct" name="VkSparseImageFormatProperties" returnedonly="true">
            <member optional="true"><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>VkExtent3D</type>             <name>imageGranularity</name></member>
            <member optional="true"><type>VkSparseImageFormatFlags</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkSparseImageMemoryRequirements" returnedonly="true">
            <member><type>VkSparseImageFormatProperties</type> <name>formatProperties</name></member>
            <member><type>uint32_t</type>               <name>imageMipTailFirstLod</name></member>
            <member><type>VkDeviceSize</type>           <name>imageMipTailSize</name></member>               <!-- Specified in bytes, must be a multiple of sparse block size in bytes / alignment -->
            <member><type>VkDeviceSize</type>           <name>imageMipTailOffset</name></member>             <!-- Specified in bytes, must be a multiple of sparse block size in bytes / alignment -->
            <member><type>VkDeviceSize</type>           <name>imageMipTailStride</name></member>             <!-- Specified in bytes, must be a multiple of sparse block size in bytes / alignment -->
        </type>
        <type category="struct" name="VkMemoryType" returnedonly="true">
            <member optional="true"><type>VkMemoryPropertyFlags</type>  <name>propertyFlags</name></member>                  <!-- Memory properties of this memory type -->
            <member><type>uint32_t</type>               <name>heapIndex</name></member>                      <!-- Index of the memory heap allocations of this memory type are taken from -->
        </type>
        <type category="struct" name="VkMemoryHeap" returnedonly="true">
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Available memory in the heap-->
            <member optional="true"><type>VkMemoryHeapFlags</type>      <name>flags</name></member>                          <!-- Flags for the heap-->
        </type>
        <type category="struct" name="VkMappedMemoryRange">
            <member values="VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDeviceMemory</type>         <name>memory</name></member>                            <!-- Mapped memory object -->
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Offset within the memory object where the range starts -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Size of the range within the memory object -->
        </type>
        <type category="struct" name="VkFormatProperties" returnedonly="true">
            <member optional="true"><type>VkFormatFeatureFlags</type>   <name>linearTilingFeatures</name></member>           <!-- Format features in case of linear tiling -->
            <member optional="true"><type>VkFormatFeatureFlags</type>   <name>optimalTilingFeatures</name></member>          <!-- Format features in case of optimal tiling -->
            <member optional="true"><type>VkFormatFeatureFlags</type>   <name>bufferFeatures</name></member>                 <!-- Format features supported by buffers -->
        </type>
        <type category="struct" name="VkImageFormatProperties" returnedonly="true">
            <member><type>VkExtent3D</type>             <name>maxExtent</name></member>                      <!-- max image dimensions for this resource type -->
            <member><type>uint32_t</type>               <name>maxMipLevels</name></member>                   <!-- max number of mipmap levels for this resource type -->
            <member><type>uint32_t</type>               <name>maxArrayLayers</name></member>                 <!-- max array size for this resource type -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampleCounts</name></member>                   <!-- supported sample counts for this resource type -->
            <member><type>VkDeviceSize</type>           <name>maxResourceSize</name></member>                <!-- max size (in bytes) of this resource type -->
        </type>
        <type category="struct" name="VkDescriptorBufferInfo">
            <member><type>VkBuffer</type>               <name>buffer</name></member>                         <!-- Buffer used for this descriptor slot when the descriptor is UNIFORM_BUFFER[_DYNAMIC] or STORAGE_BUFFER[_DYNAMIC]. VK_NULL_HANDLE otherwise. -->
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Base offset from buffer start in bytes to update in the descriptor set. -->
            <member><type>VkDeviceSize</type>           <name>range</name></member>                          <!-- Size in bytes of the buffer resource for this descriptor update. -->
        </type>
        <type category="struct" name="VkDescriptorImageInfo">
            <member noautovalidity="true"><type>VkSampler</type>       <name>sampler</name></member>                        <!-- Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise. -->
            <member noautovalidity="true"><type>VkImageView</type>     <name>imageView</name></member>                      <!-- Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise. -->
            <member noautovalidity="true"><type>VkImageLayout</type>   <name>imageLayout</name></member>                    <!-- Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE). -->
        </type>
        <type category="struct" name="VkWriteDescriptorSet">
            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDescriptorSet</type>        <name>dstSet</name></member>                        <!-- Destination descriptor set -->
            <member><type>uint32_t</type>               <name>dstBinding</name></member>                    <!-- Binding within the destination descriptor set to write -->
            <member><type>uint32_t</type>               <name>dstArrayElement</name></member>               <!-- Array element within the destination binding to write -->
            <member><type>uint32_t</type>               <name>descriptorCount</name></member>                          <!-- Number of descriptors to write (determines the size of the array pointed by pDescriptors) -->
            <member><type>VkDescriptorType</type>       <name>descriptorType</name></member>                 <!-- Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used) -->
            <member noautovalidity="true" len="descriptorCount">const <type>VkDescriptorImageInfo</type>* <name>pImageInfo</name></member>               <!-- Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types. -->
            <member noautovalidity="true" len="descriptorCount">const <type>VkDescriptorBufferInfo</type>* <name>pBufferInfo</name></member>             <!-- Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types. -->
            <member noautovalidity="true" len="descriptorCount">const <type>VkBufferView</type>*    <name>pTexelBufferView</name></member>               <!-- Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types. -->
        </type>
        <type category="struct" name="VkCopyDescriptorSet">
            <member values="VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDescriptorSet</type>        <name>srcSet</name></member>                         <!-- Source descriptor set -->
            <member><type>uint32_t</type>               <name>srcBinding</name></member>                     <!-- Binding within the source descriptor set to copy from -->
            <member><type>uint32_t</type>               <name>srcArrayElement</name></member>                <!-- Array element within the source binding to copy from -->
            <member><type>VkDescriptorSet</type>        <name>dstSet</name></member>                        <!-- Destination descriptor set -->
            <member><type>uint32_t</type>               <name>dstBinding</name></member>                    <!-- Binding within the destination descriptor set to copy to -->
            <member><type>uint32_t</type>               <name>dstArrayElement</name></member>               <!-- Array element within the destination binding to copy to -->
            <member><type>uint32_t</type>               <name>descriptorCount</name></member>                <!-- Number of descriptors to write (determines the size of the array pointed by pDescriptors) -->
        </type>
        <type category="struct" name="VkBufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member validextensionstructs="VkDedicatedAllocationBufferCreateInfoNV">const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>VkBufferCreateFlags</type>    <name>flags</name></member>                          <!-- Buffer creation flags -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Specified in bytes -->
            <member><type>VkBufferUsageFlags</type>     <name>usage</name></member>                          <!-- Buffer usage flags -->
            <member><type>VkSharingMode</type>          <name>sharingMode</name></member>
            <member optional="true"><type>uint32_t</type>               <name>queueFamilyIndexCount</name></member>
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name></member>
        </type>
        <type category="struct" name="VkBufferViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>VkBufferViewCreateFlags</type><name>flags</name></member>                          <!-- Reserved -->
            <member><type>VkBuffer</type>               <name>buffer</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>                         <!-- Optionally specifies format of elements -->
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>range</name></member>                          <!-- View size specified in bytes -->
        </type>
        <type category="struct" name="VkImageSubresource">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>mipLevel</name></member>
            <member><type>uint32_t</type>               <name>arrayLayer</name></member>
        </type>
        <type category="struct" name="VkImageSubresourceLayers">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>mipLevel</name></member>
            <member><type>uint32_t</type>               <name>baseArrayLayer</name></member>
            <member><type>uint32_t</type>               <name>layerCount</name></member>
        </type>
        <type category="struct" name="VkImageSubresourceRange">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>baseMipLevel</name></member>
            <member><type>uint32_t</type>               <name>levelCount</name></member>
            <member><type>uint32_t</type>               <name>baseArrayLayer</name></member>
            <member><type>uint32_t</type>               <name>layerCount</name></member>
        </type>
        <type category="struct" name="VkMemoryBarrier">
            <member values="VK_STRUCTURE_TYPE_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name></member>                  <!-- Memory accesses from the source of the dependency to synchronize -->
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name></member>                  <!-- Memory accesses from the destination of the dependency to synchronize -->
        </type>
        <type category="struct" name="VkBufferMemoryBarrier">
            <member values="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name></member>                  <!-- Memory accesses from the source of the dependency to synchronize -->
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name></member>                  <!-- Memory accesses from the destination of the dependency to synchronize -->
            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name></member>            <!-- Queue family to transition ownership from -->
            <member><type>uint32_t</type>               <name>dstQueueFamilyIndex</name></member>           <!-- Queue family to transition ownership to -->
            <member><type>VkBuffer</type>               <name>buffer</name></member>                         <!-- Buffer to sync -->
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Offset within the buffer to sync -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Amount of bytes to sync -->
        </type>
        <type category="struct" name="VkImageMemoryBarrier">
            <member values="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name></member>                  <!-- Memory accesses from the source of the dependency to synchronize -->
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name></member>                  <!-- Memory accesses from the destination of the dependency to synchronize -->
            <member><type>VkImageLayout</type>          <name>oldLayout</name></member>                      <!-- Current layout of the image -->
            <member><type>VkImageLayout</type>          <name>newLayout</name></member>                      <!-- New layout to transition the image to -->
            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name></member>            <!-- Queue family to transition ownership from -->
            <member><type>uint32_t</type>               <name>dstQueueFamilyIndex</name></member>           <!-- Queue family to transition ownership to -->
            <member><type>VkImage</type>                <name>image</name></member>                          <!-- Image to sync -->
            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name></member>              <!-- Subresource range to sync -->
        </type>
        <type category="struct" name="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member validextensionstructs="VkDedicatedAllocationImageCreateInfoNV">const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>VkImageCreateFlags</type>     <name>flags</name></member>                          <!-- Image creation flags -->
            <member><type>VkImageType</type>            <name>imageType</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
            <member><type>uint32_t</type>               <name>mipLevels</name></member>
            <member><type>uint32_t</type>               <name>arrayLayers</name></member>
            <member><type>VkSampleCountFlagBits</type>  <name>samples</name></member>
            <member><type>VkImageTiling</type>          <name>tiling</name></member>
            <member><type>VkImageUsageFlags</type>      <name>usage</name></member>                          <!-- Image usage flags -->
            <member><type>VkSharingMode</type>          <name>sharingMode</name></member>                    <!-- Cross-queue-family sharing mode -->
            <member optional="true"><type>uint32_t</type>               <name>queueFamilyIndexCount</name></member>          <!-- Number of queue families to share across -->
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name></member>            <!-- Array of queue family indices to share across -->
            <member><type>VkImageLayout</type>          <name>initialLayout</name></member>                  <!-- Initial image layout for all subresources -->
        </type>
        <type category="struct" name="VkSubresourceLayout" returnedonly="true">
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>rowPitch</name></member>                       <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>arrayPitch</name></member>                     <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>depthPitch</name></member>                     <!-- Specified in bytes -->
        </type>
        <type category="struct" name="VkImageViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkImageViewCreateFlags</type> <name>flags</name></member>                          <!-- Reserved -->
            <member><type>VkImage</type>                <name>image</name></member>
            <member><type>VkImageViewType</type>        <name>viewType</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkComponentMapping</type>     <name>components</name></member>
            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name></member>
        </type>
        <type category="struct" name="VkBufferCopy">
            <member><type>VkDeviceSize</type>           <name>srcOffset</name></member>                      <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>dstOffset</name></member>                     <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Specified in bytes -->
        </type>
        <type category="struct" name="VkSparseMemoryBind">
            <member><type>VkDeviceSize</type>           <name>resourceOffset</name></member>                 <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Specified in bytes -->
            <member optional="true"><type>VkDeviceMemory</type>         <name>memory</name></member>
            <member><type>VkDeviceSize</type>           <name>memoryOffset</name></member>                   <!-- Specified in bytes -->
            <member optional="true"><type>VkSparseMemoryBindFlags</type><name>flags</name></member>                          <!-- Reserved for future -->
        </type>
        <type category="struct" name="VkSparseImageMemoryBind">
            <member><type>VkImageSubresource</type>     <name>subresource</name></member>
            <member><type>VkOffset3D</type>             <name>offset</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
            <member optional="true"><type>VkDeviceMemory</type>         <name>memory</name></member>
            <member><type>VkDeviceSize</type>           <name>memoryOffset</name></member>                   <!-- Specified in bytes -->
            <member optional="true"><type>VkSparseMemoryBindFlags</type><name>flags</name></member>                          <!-- Reserved for future -->
        </type>
        <type category="struct" name="VkSparseBufferMemoryBindInfo">
            <member><type>VkBuffer</type> <name>buffer</name></member>
            <member><type>uint32_t</type>               <name>bindCount</name></member>
            <member len="bindCount">const <type>VkSparseMemoryBind</type>* <name>pBinds</name></member>
        </type>
        <type category="struct" name="VkSparseImageOpaqueMemoryBindInfo">
            <member><type>VkImage</type> <name>image</name></member>
            <member><type>uint32_t</type>               <name>bindCount</name></member>
            <member len="bindCount">const <type>VkSparseMemoryBind</type>* <name>pBinds</name></member>
        </type>
        <type category="struct" name="VkSparseImageMemoryBindInfo">
            <member><type>VkImage</type> <name>image</name></member>
            <member><type>uint32_t</type>               <name>bindCount</name></member>
            <member len="bindCount">const <type>VkSparseImageMemoryBind</type>* <name>pBinds</name></member>
        </type>
        <type category="struct" name="VkBindSparseInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>uint32_t</type>               <name>waitSemaphoreCount</name></member>
            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>*     <name>pWaitSemaphores</name></member>
            <member optional="true"><type>uint32_t</type>               <name>bufferBindCount</name></member>
            <member len="bufferBindCount">const <type>VkSparseBufferMemoryBindInfo</type>* <name>pBufferBinds</name></member>
            <member optional="true"><type>uint32_t</type>               <name>imageOpaqueBindCount</name></member>
            <member len="imageOpaqueBindCount">const <type>VkSparseImageOpaqueMemoryBindInfo</type>* <name>pImageOpaqueBinds</name></member>
            <member optional="true"><type>uint32_t</type>               <name>imageBindCount</name></member>
            <member len="imageBindCount">const <type>VkSparseImageMemoryBindInfo</type>* <name>pImageBinds</name></member>
            <member optional="true"><type>uint32_t</type>               <name>signalSemaphoreCount</name></member>
            <member len="signalSemaphoreCount">const <type>VkSemaphore</type>*     <name>pSignalSemaphores</name></member>
        </type>
        <type category="struct" name="VkImageCopy">
            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffset</name></member>                      <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>dstOffset</name></member>                     <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkExtent3D</type>             <name>extent</name></member>                         <!-- Specified in pixels for both compressed and uncompressed images -->
        </type>
        <type category="struct" name="VkImageBlit">
            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffsets</name>[2]</member>                      <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>dstOffsets</name>[2]</member>                     <!-- Specified in pixels for both compressed and uncompressed images -->
        </type>
        <type category="struct" name="VkBufferImageCopy">
            <member><type>VkDeviceSize</type>           <name>bufferOffset</name></member>                   <!-- Specified in bytes -->
            <member><type>uint32_t</type>               <name>bufferRowLength</name></member>                <!-- Specified in texels -->
            <member><type>uint32_t</type>               <name>bufferImageHeight</name></member>
            <member><type>VkImageSubresourceLayers</type> <name>imageSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>imageOffset</name></member>                    <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkExtent3D</type>             <name>imageExtent</name></member>                    <!-- Specified in pixels for both compressed and uncompressed images -->
        </type>
        <type category="struct" name="VkImageResolve">
            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffset</name></member>
            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>dstOffset</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
        </type>
        <type category="struct" name="VkShaderModuleCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkShaderModuleCreateFlags</type> <name>flags</name></member>                       <!-- Reserved -->
            <member><type>size_t</type>                 <name>codeSize</name></member>                       <!-- Specified in bytes -->
            <member len="latexmath:[$codeSize \over 4$]">const <type>uint32_t</type>*            <name>pCode</name></member>                          <!-- Binary code of size codeSize -->
        </type>
        <type category="struct" name="VkDescriptorSetLayoutBinding">
            <member><type>uint32_t</type>               <name>binding</name></member>                        <!-- Binding number for this entry -->
            <member><type>VkDescriptorType</type>       <name>descriptorType</name></member>                 <!-- Type of the descriptors in this binding -->
            <member optional="true"><type>uint32_t</type> <name>descriptorCount</name></member>              <!-- Number of descriptors in this binding -->
            <member noautovalidity="true"><type>VkShaderStageFlags</type>     <name>stageFlags</name></member>                     <!-- Shader stages this binding is visible to -->
            <member noautovalidity="true" optional="true" len="descriptorCount">const <type>VkSampler</type>*       <name>pImmutableSamplers</name></member>             <!-- Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements) -->
        </type>
        <type category="struct" name="VkDescriptorSetLayoutCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkDescriptorSetLayoutCreateFlags</type>    <name>flags</name></member>             <!-- Reserved -->
            <member optional="true"><type>uint32_t</type>               <name>bindingCount</name></member>                   <!-- Number of bindings in the descriptor set layout -->
            <member len="bindingCount">const <type>VkDescriptorSetLayoutBinding</type>* <name>pBindings</name></member>       <!-- Array of descriptor set layout bindings -->
        </type>
        <type category="struct" name="VkDescriptorPoolSize">
            <member><type>VkDescriptorType</type>       <name>type</name></member>
            <member><type>uint32_t</type>               <name>descriptorCount</name></member>
        </type>
        <type category="struct" name="VkDescriptorPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkDescriptorPoolCreateFlags</type>  <name>flags</name></member>
            <member><type>uint32_t</type>               <name>maxSets</name></member>
            <member><type>uint32_t</type>               <name>poolSizeCount</name></member>
            <member len="poolSizeCount">const <type>VkDescriptorPoolSize</type>* <name>pPoolSizes</name></member>
        </type>
        <type category="struct" name="VkDescriptorSetAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDescriptorPool</type>       <name>descriptorPool</name></member>
            <member><type>uint32_t</type>               <name>descriptorSetCount</name></member>
            <member len="descriptorSetCount">const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name></member>
        </type>
        <type category="struct" name="VkSpecializationMapEntry">
            <member><type>uint32_t</type>               <name>constantID</name></member>                     <!-- The SpecConstant ID specified in the BIL -->
            <member><type>uint32_t</type>               <name>offset</name></member>                         <!-- Offset of the value in the data block -->
            <member><type>size_t</type>                 <name>size</name></member>                           <!-- Size in bytes of the SpecConstant -->
        </type>
        <type category="struct" name="VkSpecializationInfo">
            <member optional="true"><type>uint32_t</type>               <name>mapEntryCount</name></member>                  <!-- Number of entries in the map -->
            <member len="mapEntryCount" noautovalidity="true">const <type>VkSpecializationMapEntry</type>* <name>pMapEntries</name></member>                  <!-- Array of map entries -->
            <member optional="true"><type>size_t</type>                 <name>dataSize</name></member>                       <!-- Size in bytes of pData -->
            <member len="dataSize">const <type>void</type>*            <name>pData</name></member>                          <!-- Pointer to SpecConstant data -->
        </type>
        <type category="struct" name="VkPipelineShaderStageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineShaderStageCreateFlags</type>    <name>flags</name></member>             <!-- Reserved -->
            <member><type>VkShaderStageFlagBits</type>  <name>stage</name></member>                          <!-- Shader stage -->
            <member><type>VkShaderModule</type>         <name>module</name></member>                         <!-- Module containing entry point -->
            <member len="null-terminated">const <type>char</type>*            <name>pName</name></member>                          <!-- Null-terminated entry point name -->
            <member optional="true">const <type>VkSpecializationInfo</type>* <name>pSpecializationInfo</name></member>
        </type>
        <type category="struct" name="VkComputePipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name></member>                          <!-- Pipeline creation flags -->
            <member><type>VkPipelineShaderStageCreateInfo</type> <name>stage</name></member>
            <member><type>VkPipelineLayout</type>       <name>layout</name></member>                         <!-- Interface layout of the pipeline -->
            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name></member>             <!-- If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of -->
            <member><type>int32_t</type>                <name>basePipelineIndex</name></member>              <!-- If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of -->
        </type>
        <type category="struct" name="VkVertexInputBindingDescription">
            <member><type>uint32_t</type>               <name>binding</name></member>                        <!-- Vertex buffer binding id -->
            <member><type>uint32_t</type>               <name>stride</name></member>                         <!-- Distance between vertices in bytes (0 = no advancement) -->
            <member><type>VkVertexInputRate</type>      <name>inputRate</name></member>                      <!-- The rate at which the vertex data is consumed -->
        </type>
        <type category="struct" name="VkVertexInputAttributeDescription">
            <member><type>uint32_t</type>               <name>location</name></member>                       <!-- location of the shader vertex attrib -->
            <member><type>uint32_t</type>               <name>binding</name></member>                        <!-- Vertex buffer binding id -->
            <member><type>VkFormat</type>               <name>format</name></member>                         <!-- format of source data -->
            <member><type>uint32_t</type>               <name>offset</name></member>                         <!-- Offset of first element in bytes from base of vertex -->
        </type>
        <type category="struct" name="VkPipelineVertexInputStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineVertexInputStateCreateFlags</type>    <name>flags</name></member>        <!-- Reserved -->
            <member optional="true"><type>uint32_t</type>               <name>vertexBindingDescriptionCount</name></member>  <!-- number of bindings -->
            <member len="vertexBindingDescriptionCount">const <type>VkVertexInputBindingDescription</type>* <name>pVertexBindingDescriptions</name></member>
            <member optional="true"><type>uint32_t</type>               <name>vertexAttributeDescriptionCount</name></member> <!-- number of attributes -->
            <member len="vertexAttributeDescriptionCount">const <type>VkVertexInputAttributeDescription</type>* <name>pVertexAttributeDescriptions</name></member>
        </type>
        <type category="struct" name="VkPipelineInputAssemblyStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineInputAssemblyStateCreateFlags</type>    <name>flags</name></member>      <!-- Reserved -->
            <member><type>VkPrimitiveTopology</type>    <name>topology</name></member>
            <member><type>VkBool32</type>               <name>primitiveRestartEnable</name></member>
        </type>
        <type category="struct" name="VkPipelineTessellationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineTessellationStateCreateFlags</type>    <name>flags</name></member>        <!-- Reserved -->
            <member><type>uint32_t</type>               <name>patchControlPoints</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineViewportStateCreateFlags</type>    <name>flags</name></member>           <!-- Reserved -->
            <member><type>uint32_t</type>               <name>viewportCount</name></member>
            <member noautovalidity="true" optional="true" len="viewportCount">const <type>VkViewport</type>*      <name>pViewports</name></member>
            <member><type>uint32_t</type>               <name>scissorCount</name></member>
            <member noautovalidity="true" optional="true" len="scissorCount">const <type>VkRect2D</type>*        <name>pScissors</name></member>
        </type>
        <type category="struct" name="VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member validextensionstructs="VkPipelineRasterizationStateRasterizationOrderAMD">const <type>void</type>* <name>pNext</name></member> <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineRasterizationStateCreateFlags</type>    <name>flags</name></member>             <!-- Reserved -->
            <member><type>VkBool32</type>               <name>depthClampEnable</name></member>
            <member><type>VkBool32</type>               <name>rasterizerDiscardEnable</name></member>
            <member><type>VkPolygonMode</type>          <name>polygonMode</name></member>                       <!-- optional (GL45) -->
            <member optional="true"><type>VkCullModeFlags</type>        <name>cullMode</name></member>
            <member><type>VkFrontFace</type>            <name>frontFace</name></member>
            <member><type>VkBool32</type>               <name>depthBiasEnable</name></member>
            <member><type>float</type>                  <name>depthBiasConstantFactor</name></member>
            <member><type>float</type>                  <name>depthBiasClamp</name></member>
            <member><type>float</type>                  <name>depthBiasSlopeFactor</name></member>
            <member><type>float</type>                  <name>lineWidth</name></member>
        </type>
        <type category="struct" name="VkPipelineMultisampleStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineMultisampleStateCreateFlags</type>    <name>flags</name></member>        <!-- Reserved -->
            <member><type>VkSampleCountFlagBits</type>  <name>rasterizationSamples</name></member>           <!-- Number of samples used for rasterization -->
            <member><type>VkBool32</type>               <name>sampleShadingEnable</name></member>            <!-- optional (GL45) -->
            <member><type>float</type>                  <name>minSampleShading</name></member>               <!-- optional (GL45) -->
            <member optional="true" len="latexmath:[$\lceil{\mathit{rasterizationSamples} \over 32}\rceil$]">const <type>VkSampleMask</type>*    <name>pSampleMask</name></member>                    <!-- Array of sampleMask words -->
            <member><type>VkBool32</type>               <name>alphaToCoverageEnable</name></member>
            <member><type>VkBool32</type>               <name>alphaToOneEnable</name></member>
        </type>
        <type category="struct" name="VkPipelineColorBlendAttachmentState">
            <member><type>VkBool32</type>               <name>blendEnable</name></member>
            <member><type>VkBlendFactor</type>          <name>srcColorBlendFactor</name></member>
            <member><type>VkBlendFactor</type>          <name>dstColorBlendFactor</name></member>
            <member><type>VkBlendOp</type>              <name>colorBlendOp</name></member>
            <member><type>VkBlendFactor</type>          <name>srcAlphaBlendFactor</name></member>
            <member><type>VkBlendFactor</type>          <name>dstAlphaBlendFactor</name></member>
            <member><type>VkBlendOp</type>              <name>alphaBlendOp</name></member>
            <member optional="true"><type>VkColorComponentFlags</type>  <name>colorWriteMask</name></member>
        </type>
        <type category="struct" name="VkPipelineColorBlendStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineColorBlendStateCreateFlags</type>    <name>flags</name></member>         <!-- Reserved -->
            <member><type>VkBool32</type>               <name>logicOpEnable</name></member>
            <member noautovalidity="true"><type>VkLogicOp</type>              <name>logicOp</name></member>
            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name></member>                <!-- # of pAttachments -->
            <member len="attachmentCount">const <type>VkPipelineColorBlendAttachmentState</type>* <name>pAttachments</name></member>
            <member><type>float</type>                  <name>blendConstants</name>[4]</member>
        </type>
        <type category="struct" name="VkPipelineDynamicStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineDynamicStateCreateFlags</type>    <name>flags</name></member>            <!-- Reserved -->
            <member><type>uint32_t</type>               <name>dynamicStateCount</name></member>
            <member len="dynamicStateCount">const <type>VkDynamicState</type>*  <name>pDynamicStates</name></member>
        </type>
        <type category="struct" name="VkStencilOpState">
            <member><type>VkStencilOp</type>            <name>failOp</name></member>
            <member><type>VkStencilOp</type>            <name>passOp</name></member>
            <member><type>VkStencilOp</type>            <name>depthFailOp</name></member>
            <member><type>VkCompareOp</type>            <name>compareOp</name></member>
            <member><type>uint32_t</type>               <name>compareMask</name></member>
            <member><type>uint32_t</type>               <name>writeMask</name></member>
            <member><type>uint32_t</type>               <name>reference</name></member>
        </type>
        <type category="struct" name="VkPipelineDepthStencilStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineDepthStencilStateCreateFlags</type>    <name>flags</name></member>       <!-- Reserved -->
            <member><type>VkBool32</type>               <name>depthTestEnable</name></member>
            <member><type>VkBool32</type>               <name>depthWriteEnable</name></member>
            <member><type>VkCompareOp</type>            <name>depthCompareOp</name></member>
            <member><type>VkBool32</type>               <name>depthBoundsTestEnable</name></member>          <!-- optional (depth_bounds_test) -->
            <member><type>VkBool32</type>               <name>stencilTestEnable</name></member>
            <member><type>VkStencilOpState</type>       <name>front</name></member>
            <member><type>VkStencilOpState</type>       <name>back</name></member>
            <member><type>float</type>                  <name>minDepthBounds</name></member>
            <member><type>float</type>                  <name>maxDepthBounds</name></member>
        </type>
        <type category="struct" name="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name></member>                          <!-- Pipeline creation flags -->
            <member><type>uint32_t</type>               <name>stageCount</name></member>
            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name></member>        <!-- One entry for each active shader stage -->
            <member>const <type>VkPipelineVertexInputStateCreateInfo</type>* <name>pVertexInputState</name></member>
            <member>const <type>VkPipelineInputAssemblyStateCreateInfo</type>* <name>pInputAssemblyState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineTessellationStateCreateInfo</type>* <name>pTessellationState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineViewportStateCreateInfo</type>* <name>pViewportState</name></member>
            <member>const <type>VkPipelineRasterizationStateCreateInfo</type>* <name>pRasterizationState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineMultisampleStateCreateInfo</type>* <name>pMultisampleState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineDepthStencilStateCreateInfo</type>* <name>pDepthStencilState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineColorBlendStateCreateInfo</type>* <name>pColorBlendState</name></member>
            <member optional="true">const <type>VkPipelineDynamicStateCreateInfo</type>* <name>pDynamicState</name></member>
            <member><type>VkPipelineLayout</type>       <name>layout</name></member>                         <!-- Interface layout of the pipeline -->
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member><type>uint32_t</type>               <name>subpass</name></member>
            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name></member>             <!-- If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of -->
            <member><type>int32_t</type>                <name>basePipelineIndex</name></member>              <!-- If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of -->
        </type>
        <type category="struct" name="VkPipelineCacheCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineCacheCreateFlags</type>    <name>flags</name></member>                   <!-- Reserved -->
            <member optional="true"><type>size_t</type>                 <name>initialDataSize</name></member>                <!-- Size of initial data to populate cache, in bytes -->
            <member len="initialDataSize">const <type>void</type>*            <name>pInitialData</name></member>                    <!-- Initial data to populate cache -->
        </type>
        <type category="struct" name="VkPushConstantRange">
            <member><type>VkShaderStageFlags</type>     <name>stageFlags</name></member>                     <!-- Which stages use the range -->
            <member><type>uint32_t</type>               <name>offset</name></member>                         <!-- Start of the range, in bytes -->
            <member><type>uint32_t</type>               <name>size</name></member>                           <!-- Size of the range, in bytes -->
        </type>
        <type category="struct" name="VkPipelineLayoutCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineLayoutCreateFlags</type>    <name>flags</name></member>                  <!-- Reserved -->
            <member optional="true"><type>uint32_t</type>               <name>setLayoutCount</name></member>                 <!-- Number of descriptor sets interfaced by the pipeline -->
            <member len="setLayoutCount">const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name></member>              <!-- Array of setCount number of descriptor set layout objects defining the layout of the -->
            <member optional="true"><type>uint32_t</type>               <name>pushConstantRangeCount</name></member>         <!-- Number of push-constant ranges used by the pipeline -->
            <member len="pushConstantRangeCount">const <type>VkPushConstantRange</type>* <name>pPushConstantRanges</name></member>        <!-- Array of pushConstantRangeCount number of ranges used by various shader stages -->
        </type>
        <type category="struct" name="VkSamplerCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkSamplerCreateFlags</type>   <name>flags</name></member>                          <!-- Reserved -->
            <member><type>VkFilter</type>               <name>magFilter</name></member>                      <!-- Filter mode for magnification -->
            <member><type>VkFilter</type>               <name>minFilter</name></member>                      <!-- Filter mode for minifiation -->
            <member><type>VkSamplerMipmapMode</type>    <name>mipmapMode</name></member>                     <!-- Mipmap selection mode -->
            <member><type>VkSamplerAddressMode</type>   <name>addressModeU</name></member>
            <member><type>VkSamplerAddressMode</type>   <name>addressModeV</name></member>
            <member><type>VkSamplerAddressMode</type>   <name>addressModeW</name></member>
            <member><type>float</type>                  <name>mipLodBias</name></member>
            <member><type>VkBool32</type>               <name>anisotropyEnable</name></member>
            <member><type>float</type>                  <name>maxAnisotropy</name></member>
            <member><type>VkBool32</type>               <name>compareEnable</name></member>
            <member noautovalidity="true"><type>VkCompareOp</type>            <name>compareOp</name></member>
            <member><type>float</type>                  <name>minLod</name></member>
            <member><type>float</type>                  <name>maxLod</name></member>
            <member noautovalidity="true"><type>VkBorderColor</type>          <name>borderColor</name></member>
            <member><type>VkBool32</type>               <name>unnormalizedCoordinates</name></member>
        </type>
        <type category="struct" name="VkCommandPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkCommandPoolCreateFlags</type>   <name>flags</name></member>      <!-- Command pool creation flags -->
            <member><type>uint32_t</type>               <name>queueFamilyIndex</name></member>
        </type>
        <type category="struct" name="VkCommandBufferAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkCommandPool</type>          <name>commandPool</name></member>
            <member><type>VkCommandBufferLevel</type>   <name>level</name></member>
            <member><type>uint32_t</type>               <name>commandBufferCount</name></member>
        </type>
        <type category="struct" name="VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true" noautovalidity="true"><type>VkRenderPass</type>    <name>renderPass</name></member>                     <!-- Render pass for secondary command buffers -->
            <member><type>uint32_t</type>               <name>subpass</name></member>
            <member optional="true" noautovalidity="true"><type>VkFramebuffer</type>   <name>framebuffer</name></member>                    <!-- Framebuffer for secondary command buffers -->
            <member><type>VkBool32</type>               <name>occlusionQueryEnable</name></member>           <!-- Whether this secondary command buffer may be executed during an occlusion query -->
            <member optional="true" noautovalidity="true"><type>VkQueryControlFlags</type>    <name>queryFlags</name></member>                     <!-- Query flags used by this secondary command buffer, if executed during an occlusion query -->
            <member optional="true" noautovalidity="true"><type>VkQueryPipelineStatisticFlags</type> <name>pipelineStatistics</name></member>      <!-- Pipeline statistics that may be counted for this secondary command buffer -->
        </type>
        <type category="struct" name="VkCommandBufferBeginInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkCommandBufferUsageFlags</type>  <name>flags</name></member>                          <!-- Command buffer usage flags -->
            <member optional="true" noautovalidity="true">const <type>VkCommandBufferInheritanceInfo</type>*       <name>pInheritanceInfo</name></member>                          <!-- Pointer to inheritance info for secondary command buffers -->
        </type>
        <type category="struct" name="VkRenderPassBeginInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member><type>VkFramebuffer</type>          <name>framebuffer</name></member>
            <member><type>VkRect2D</type>               <name>renderArea</name></member>
            <member optional="true"><type>uint32_t</type>               <name>clearValueCount</name></member>
            <member len="clearValueCount" noautovalidity="true">const <type>VkClearValue</type>*    <name>pClearValues</name></member>
        </type>
        <type category="union" name="VkClearColorValue" comment="// Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.">
            <member><type>float</type>                  <name>float32</name>[4]</member>
            <member><type>int32_t</type>                <name>int32</name>[4]</member>
            <member><type>uint32_t</type>               <name>uint32</name>[4]</member>
        </type>
        <type category="struct" name="VkClearDepthStencilValue">
            <member><type>float</type>                  <name>depth</name></member>
            <member><type>uint32_t</type>               <name>stencil</name></member>
        </type>
        <type category="union" name="VkClearValue" comment="// Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.">
            <member><type>VkClearColorValue</type>      <name>color</name></member>
            <member><type>VkClearDepthStencilValue</type> <name>depthStencil</name></member>
        </type>
        <type category="struct" name="VkClearAttachment">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>colorAttachment</name></member>
            <member><type>VkClearValue</type>           <name>clearValue</name></member>
        </type>
        <type category="struct" name="VkAttachmentDescription">
            <member optional="true"><type>VkAttachmentDescriptionFlags</type> <name>flags</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkSampleCountFlagBits</type>  <name>samples</name></member>
            <member><type>VkAttachmentLoadOp</type>     <name>loadOp</name></member>                         <!-- Load operation for color or depth data -->
            <member><type>VkAttachmentStoreOp</type>    <name>storeOp</name></member>                        <!-- Store operation for color or depth data -->
            <member><type>VkAttachmentLoadOp</type>     <name>stencilLoadOp</name></member>                  <!-- Load operation for stencil data -->
            <member><type>VkAttachmentStoreOp</type>    <name>stencilStoreOp</name></member>                 <!-- Store operation for stencil data -->
            <member><type>VkImageLayout</type>          <name>initialLayout</name></member>
            <member><type>VkImageLayout</type>          <name>finalLayout</name></member>
        </type>
        <type category="struct" name="VkAttachmentReference">
            <member><type>uint32_t</type>               <name>attachment</name></member>
            <member><type>VkImageLayout</type>          <name>layout</name></member>
        </type>
        <type category="struct" name="VkSubpassDescription">
            <member optional="true"><type>VkSubpassDescriptionFlags</type> <name>flags</name></member>
            <member><type>VkPipelineBindPoint</type>    <name>pipelineBindPoint</name></member>              <!-- Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now -->
            <member optional="true"><type>uint32_t</type>               <name>inputAttachmentCount</name></member>
            <member len="inputAttachmentCount">const <type>VkAttachmentReference</type>* <name>pInputAttachments</name></member>
            <member optional="true"><type>uint32_t</type>               <name>colorAttachmentCount</name></member>
            <member len="colorAttachmentCount">const <type>VkAttachmentReference</type>* <name>pColorAttachments</name></member>
            <member optional="true" len="colorAttachmentCount">const <type>VkAttachmentReference</type>* <name>pResolveAttachments</name></member>
            <member optional="true">const <type>VkAttachmentReference</type>* <name>pDepthStencilAttachment</name></member>
            <member optional="true"><type>uint32_t</type>               <name>preserveAttachmentCount</name></member>
            <member len="preserveAttachmentCount">const <type>uint32_t</type>* <name>pPreserveAttachments</name></member>
        </type>
        <type category="struct" name="VkSubpassDependency">
            <member><type>uint32_t</type>               <name>srcSubpass</name></member>
            <member><type>uint32_t</type>               <name>dstSubpass</name></member>
            <member><type>VkPipelineStageFlags</type>   <name>srcStageMask</name></member>
            <member><type>VkPipelineStageFlags</type>   <name>dstStageMask</name></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name></member>                  <!-- Memory accesses from the source of the dependency to synchronize -->
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name></member>                  <!-- Memory accesses from the destination of the dependency to synchronize -->
            <member optional="true"><type>VkDependencyFlags</type>      <name>dependencyFlags</name></member>
        </type>
        <type category="struct" name="VkRenderPassCreateInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkRenderPassCreateFlags</type>    <name>flags</name></member>                      <!-- Reserved -->
            <member optional="true"><type>uint32_t</type>   <name>attachmentCount</name></member>
            <member len="attachmentCount">const <type>VkAttachmentDescription</type>* <name>pAttachments</name></member>
            <member><type>uint32_t</type>               <name>subpassCount</name></member>
            <member len="subpassCount">const <type>VkSubpassDescription</type>* <name>pSubpasses</name></member>
            <member optional="true"><type>uint32_t</type>       <name>dependencyCount</name></member>
            <member len="dependencyCount">const <type>VkSubpassDependency</type>* <name>pDependencies</name></member>
        </type>
        <type category="struct" name="VkEventCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkEventCreateFlags</type>     <name>flags</name></member>                          <!-- Event creation flags -->
        </type>
        <type category="struct" name="VkFenceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkFenceCreateFlags</type>     <name>flags</name></member>                          <!-- Fence creation flags -->
        </type>
        <type category="struct" name="VkPhysicalDeviceFeatures">
            <member><type>VkBool32</type>               <name>robustBufferAccess</name></member>                <!-- out of bounds buffer accesses are well defined -->
            <member><type>VkBool32</type>               <name>fullDrawIndexUint32</name></member>               <!-- full 32-bit range of indices for indexed draw calls -->
            <member><type>VkBool32</type>               <name>imageCubeArray</name></member>                    <!-- image views which are arrays of cube maps -->
            <member><type>VkBool32</type>               <name>independentBlend</name></member>                  <!-- blending operations are controlled per-attachment -->
            <member><type>VkBool32</type>               <name>geometryShader</name></member>                    <!-- geometry stage -->
            <member><type>VkBool32</type>               <name>tessellationShader</name></member>                <!-- tessellation control and evaluation stage -->
            <member><type>VkBool32</type>               <name>sampleRateShading</name></member>                 <!-- per-sample shading and interpolation -->
            <member><type>VkBool32</type>               <name>dualSrcBlend</name></member>                      <!-- blend operations which take two sources -->
            <member><type>VkBool32</type>               <name>logicOp</name></member>                           <!-- logic operations -->
            <member><type>VkBool32</type>               <name>multiDrawIndirect</name></member>                 <!-- multi draw indirect -->
            <member><type>VkBool32</type>               <name>drawIndirectFirstInstance</name></member>         <!-- indirect draws can use non-zero firstInstance -->
            <member><type>VkBool32</type>               <name>depthClamp</name></member>                        <!-- depth clamping -->
            <member><type>VkBool32</type>               <name>depthBiasClamp</name></member>                    <!-- depth bias clamping -->
            <member><type>VkBool32</type>               <name>fillModeNonSolid</name></member>                  <!-- point and wireframe fill modes -->
            <member><type>VkBool32</type>               <name>depthBounds</name></member>                       <!-- depth bounds test -->
            <member><type>VkBool32</type>               <name>wideLines</name></member>                         <!-- lines with width greater than 1 -->
            <member><type>VkBool32</type>               <name>largePoints</name></member>                       <!-- points with size greater than 1 -->
            <member><type>VkBool32</type>               <name>alphaToOne</name></member>                        <!-- the fragment alpha component can be forced to maximum representable alpha value -->
            <member><type>VkBool32</type>               <name>multiViewport</name></member>                     <!-- viewport arrays -->
            <member><type>VkBool32</type>               <name>samplerAnisotropy</name></member>                 <!-- anisotropic sampler filtering -->
            <member><type>VkBool32</type>               <name>textureCompressionETC2</name></member>            <!-- ETC texture compression formats -->
            <member><type>VkBool32</type>               <name>textureCompressionASTC_LDR</name></member>        <!-- ASTC LDR texture compression formats -->
            <member><type>VkBool32</type>               <name>textureCompressionBC</name></member>              <!-- BC1-7 texture compressed formats -->
            <member><type>VkBool32</type>               <name>occlusionQueryPrecise</name></member>             <!-- precise occlusion queries returning actual sample counts -->
            <member><type>VkBool32</type>               <name>pipelineStatisticsQuery</name></member>           <!-- pipeline statistics query -->
            <member><type>VkBool32</type>               <name>vertexPipelineStoresAndAtomics</name></member>    <!-- stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages -->
            <member><type>VkBool32</type>               <name>fragmentStoresAndAtomics</name></member>          <!-- stores and atomic ops on storage buffers and images are supported in the fragment stage -->
            <member><type>VkBool32</type>               <name>shaderTessellationAndGeometryPointSize</name></member><!-- tessellation and geometry stages can export point size -->
            <member><type>VkBool32</type>               <name>shaderImageGatherExtended</name></member>         <!-- image gather with run-time values and independent offsets -->
            <member><type>VkBool32</type>               <name>shaderStorageImageExtendedFormats</name></member> <!-- the extended set of formats can be used for storage images -->
            <member><type>VkBool32</type>               <name>shaderStorageImageMultisample</name></member>     <!-- multisample images can be used for storage images -->
            <member><type>VkBool32</type>               <name>shaderStorageImageReadWithoutFormat</name></member>       <!-- read from storage image does not require format qualifier -->
            <member><type>VkBool32</type>               <name>shaderStorageImageWriteWithoutFormat</name></member>      <!-- write to storage image does not require format qualifier -->
            <member><type>VkBool32</type>               <name>shaderUniformBufferArrayDynamicIndexing</name></member>   <!-- arrays of uniform buffers can be accessed with dynamically uniform indices -->
            <member><type>VkBool32</type>               <name>shaderSampledImageArrayDynamicIndexing</name></member>    <!-- arrays of sampled images can be accessed with dynamically uniform indices -->
            <member><type>VkBool32</type>               <name>shaderStorageBufferArrayDynamicIndexing</name></member>   <!-- arrays of storage buffers can be accessed with dynamically uniform indices -->
            <member><type>VkBool32</type>               <name>shaderStorageImageArrayDynamicIndexing</name></member>    <!-- arrays of storage images can be accessed with dynamically uniform indices -->
            <member><type>VkBool32</type>               <name>shaderClipDistance</name></member>                <!-- clip distance in shaders -->
            <member><type>VkBool32</type>               <name>shaderCullDistance</name></member>                <!-- cull distance in shaders -->
            <member><type>VkBool32</type>               <name>shaderFloat64</name></member>                     <!-- 64-bit floats (doubles) in shaders -->
            <member><type>VkBool32</type>               <name>shaderInt64</name></member>                       <!-- 64-bit integers in shaders -->
            <member><type>VkBool32</type>               <name>shaderInt16</name></member>                       <!-- 16-bit integers in shaders -->
            <member><type>VkBool32</type>               <name>shaderResourceResidency</name></member>           <!-- shader can use texture operations that return resource residency information (requires sparseNonResident support) -->
            <member><type>VkBool32</type>               <name>shaderResourceMinLod</name></member>              <!-- shader can use texture operations that specify minimum resource level of detail -->
            <member><type>VkBool32</type>               <name>sparseBinding</name></member>                     <!-- Sparse resources support: Resource memory can be managed at opaque page level rather than object level -->
            <member><type>VkBool32</type>               <name>sparseResidencyBuffer</name></member>             <!-- Sparse resources support: GPU can access partially resident buffers  -->
            <member><type>VkBool32</type>               <name>sparseResidencyImage2D</name></member>            <!-- Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images  -->
            <member><type>VkBool32</type>               <name>sparseResidencyImage3D</name></member>            <!-- Sparse resources support: GPU can access partially resident 3D images  -->
            <member><type>VkBool32</type>               <name>sparseResidency2Samples</name></member>           <!-- Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples -->
            <member><type>VkBool32</type>               <name>sparseResidency4Samples</name></member>           <!-- Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples -->
            <member><type>VkBool32</type>               <name>sparseResidency8Samples</name></member>           <!-- Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples -->
            <member><type>VkBool32</type>               <name>sparseResidency16Samples</name></member>          <!-- Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples -->
            <member><type>VkBool32</type>               <name>sparseResidencyAliased</name></member>            <!-- Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in) -->
            <member><type>VkBool32</type>               <name>variableMultisampleRate</name></member>           <!-- multisample rate must be the same for all pipelines in a subpass -->
            <member><type>VkBool32</type>               <name>inheritedQueries</name></member>                  <!-- Queries may be inherited from primary to secondary command buffers -->
        </type>
        <type category="struct" name="VkPhysicalDeviceSparseProperties" returnedonly="true">
            <member><type>VkBool32</type>               <name>residencyStandard2DBlockShape</name></member> <!-- Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format) -->
            <member><type>VkBool32</type>               <name>residencyStandard2DMultisampleBlockShape</name></member> <!-- Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format) -->
            <member><type>VkBool32</type>               <name>residencyStandard3DBlockShape</name></member> <!-- Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format) -->
            <member><type>VkBool32</type>               <name>residencyAlignedMipSize</name></member>     <!-- Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail -->
            <member><type>VkBool32</type>               <name>residencyNonResidentStrict</name></member>  <!-- Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded -->
        </type>
        <type category="struct" name="VkPhysicalDeviceLimits" returnedonly="true">
                <!-- resource maximum sizes -->
            <member><type>uint32_t</type>               <name>maxImageDimension1D</name></member>               <!-- max 1D image dimension -->
            <member><type>uint32_t</type>               <name>maxImageDimension2D</name></member>               <!-- max 2D image dimension -->
            <member><type>uint32_t</type>               <name>maxImageDimension3D</name></member>               <!-- max 3D image dimension -->
            <member><type>uint32_t</type>               <name>maxImageDimensionCube</name></member>             <!-- max cubemap image dimension -->
            <member><type>uint32_t</type>               <name>maxImageArrayLayers</name></member>               <!-- max layers for image arrays -->
            <member><type>uint32_t</type>               <name>maxTexelBufferElements</name></member>            <!-- max texel buffer size (fstexels) -->
            <member><type>uint32_t</type>               <name>maxUniformBufferRange</name></member>             <!-- max uniform buffer range (bytes) -->
            <member><type>uint32_t</type>               <name>maxStorageBufferRange</name></member>             <!-- max storage buffer range (bytes) -->
            <member><type>uint32_t</type>               <name>maxPushConstantsSize</name></member>              <!-- max size of the push constants pool (bytes) -->
                <!-- memory limits -->
            <member><type>uint32_t</type>               <name>maxMemoryAllocationCount</name></member>          <!-- max number of device memory allocations supported -->
            <member><type>uint32_t</type>               <name>maxSamplerAllocationCount</name></member>         <!-- max number of samplers that can be allocated on a device -->
            <member><type>VkDeviceSize</type>           <name>bufferImageGranularity</name></member>            <!-- Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage -->
            <member><type>VkDeviceSize</type>           <name>sparseAddressSpaceSize</name></member>            <!-- Total address space available for sparse allocations (bytes) -->
                <!-- descriptor set limits -->
            <member><type>uint32_t</type>               <name>maxBoundDescriptorSets</name></member>                <!-- max number of descriptors sets that can be bound to a pipeline -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorSamplers</name></member>         <!-- max number of samplers allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorUniformBuffers</name></member>   <!-- max number of uniform buffers allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorStorageBuffers</name></member>   <!-- max number of storage buffers allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorSampledImages</name></member>    <!-- max number of sampled images allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorStorageImages</name></member>    <!-- max number of storage images allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorInputAttachments</name></member> <!-- max number of input attachments allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageResources</name></member>                  <!-- max number of resources allowed by a single stage -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetSamplers</name></member>              <!-- max number of samplers allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetUniformBuffers</name></member>        <!-- max number of uniform buffers allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetUniformBuffersDynamic</name></member> <!-- max number of dynamic uniform buffers allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetStorageBuffers</name></member>        <!-- max number of storage buffers allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetStorageBuffersDynamic</name></member> <!-- max number of dynamic storage buffers allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetSampledImages</name></member>         <!-- max number of sampled images allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetStorageImages</name></member>         <!-- max number of storage images allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetInputAttachments</name></member>      <!-- max number of input attachments allowed in all stages in a descriptor set -->
                <!-- vertex stage limits -->
            <member><type>uint32_t</type>               <name>maxVertexInputAttributes</name></member>          <!-- max number of vertex input attribute slots -->
            <member><type>uint32_t</type>               <name>maxVertexInputBindings</name></member>            <!-- max number of vertex input binding slots -->
            <member><type>uint32_t</type>               <name>maxVertexInputAttributeOffset</name></member>     <!-- max vertex input attribute offset added to vertex buffer offset -->
            <member><type>uint32_t</type>               <name>maxVertexInputBindingStride</name></member>       <!-- max vertex input binding stride -->
            <member><type>uint32_t</type>               <name>maxVertexOutputComponents</name></member>         <!-- max number of output components written by vertex shader -->
                <!-- tessellation control stage limits -->
            <member><type>uint32_t</type>               <name>maxTessellationGenerationLevel</name></member>                   <!-- max level supported by tessellation primitive generator -->
            <member><type>uint32_t</type>               <name>maxTessellationPatchSize</name></member>                  <!-- max patch size (vertices) -->
            <member><type>uint32_t</type>               <name>maxTessellationControlPerVertexInputComponents</name></member>    <!-- max number of input components per-vertex in TCS -->
            <member><type>uint32_t</type>               <name>maxTessellationControlPerVertexOutputComponents</name></member>   <!-- max number of output components per-vertex in TCS -->
            <member><type>uint32_t</type>               <name>maxTessellationControlPerPatchOutputComponents</name></member>    <!-- max number of output components per-patch in TCS -->
            <member><type>uint32_t</type>               <name>maxTessellationControlTotalOutputComponents</name></member>       <!-- max total number of per-vertex and per-patch output components in TCS -->
                <!-- tessellation evaluation stage limits -->
            <member><type>uint32_t</type>               <name>maxTessellationEvaluationInputComponents</name></member>  <!-- max number of input components per vertex in TES -->
            <member><type>uint32_t</type>               <name>maxTessellationEvaluationOutputComponents</name></member> <!-- max number of output components per vertex in TES -->
                <!-- geometry stage limits -->
            <member><type>uint32_t</type>               <name>maxGeometryShaderInvocations</name></member>      <!-- max invocation count supported in geometry shader -->
            <member><type>uint32_t</type>               <name>maxGeometryInputComponents</name></member>        <!-- max number of input components read in geometry stage -->
            <member><type>uint32_t</type>               <name>maxGeometryOutputComponents</name></member>       <!-- max number of output components written in geometry stage -->
            <member><type>uint32_t</type>               <name>maxGeometryOutputVertices</name></member>         <!-- max number of vertices that can be emitted in geometry stage -->
            <member><type>uint32_t</type>               <name>maxGeometryTotalOutputComponents</name></member>  <!-- max total number of components (all vertices) written in geometry stage -->
                <!-- fragment stage limits -->
            <member><type>uint32_t</type>               <name>maxFragmentInputComponents</name></member>        <!-- max number of input compontents read in fragment stage -->
            <member><type>uint32_t</type>               <name>maxFragmentOutputAttachments</name></member>      <!-- max number of output attachments written in fragment stage -->
            <member><type>uint32_t</type>               <name>maxFragmentDualSrcAttachments</name></member>     <!-- max number of output attachments written when using dual source blending -->
            <member><type>uint32_t</type>               <name>maxFragmentCombinedOutputResources</name></member><!-- max total number of storage buffers, storage images and output buffers -->
                <!-- compute stage limits -->
            <member><type>uint32_t</type>               <name>maxComputeSharedMemorySize</name></member>        <!-- max total storage size of work group local storage (bytes) -->
            <member><type>uint32_t</type>               <name>maxComputeWorkGroupCount</name>[3]</member>       <!-- max num of compute work groups that may be dispatched by a single command (x,y,z) -->
            <member><type>uint32_t</type>               <name>maxComputeWorkGroupInvocations</name></member>    <!-- max total compute invocations in a single local work group -->
            <member><type>uint32_t</type>               <name>maxComputeWorkGroupSize</name>[3]</member>        <!-- max local size of a compute work group (x,y,z) -->
            <member><type>uint32_t</type>               <name>subPixelPrecisionBits</name></member>             <!-- number bits of subpixel precision in screen x and y-->
            <member><type>uint32_t</type>               <name>subTexelPrecisionBits</name></member>             <!-- number bits of precision for selecting texel weights-->
            <member><type>uint32_t</type>               <name>mipmapPrecisionBits</name></member>               <!-- number bits of precision for selecting mipmap weights -->
            <member><type>uint32_t</type>               <name>maxDrawIndexedIndexValue</name></member>          <!-- max index value for indexed draw calls (for 32-bit indices) -->
            <member><type>uint32_t</type>               <name>maxDrawIndirectCount</name></member>              <!-- max draw count for indirect draw calls -->
            <member><type>float</type>                  <name>maxSamplerLodBias</name></member>                 <!-- max absolute sampler level of detail bias -->
            <member><type>float</type>                  <name>maxSamplerAnisotropy</name></member>              <!-- max degree of sampler anisotropy -->
            <member><type>uint32_t</type>               <name>maxViewports</name></member>                      <!-- max number of active viewports -->
            <member><type>uint32_t</type>               <name>maxViewportDimensions</name>[2]</member>          <!-- max viewport dimensions (x,y) -->
            <member><type>float</type>                  <name>viewportBoundsRange</name>[2]</member>            <!-- viewport bounds range (min,max) -->
            <member><type>uint32_t</type>               <name>viewportSubPixelBits</name></member>              <!-- number bits of subpixel precision for viewport -->
            <member><type>size_t</type>                 <name>minMemoryMapAlignment</name></member>             <!-- min required alignment of pointers returned by MapMemory (bytes) -->
            <member><type>VkDeviceSize</type>           <name>minTexelBufferOffsetAlignment</name></member>     <!-- min required alignment for texel buffer offsets (bytes)  -->
            <member><type>VkDeviceSize</type>           <name>minUniformBufferOffsetAlignment</name></member>   <!-- min required alignment for uniform buffer sizes and offsets (bytes) -->
            <member><type>VkDeviceSize</type>           <name>minStorageBufferOffsetAlignment</name></member>   <!-- min required alignment for storage buffer offsets (bytes) -->
            <member><type>int32_t</type>                <name>minTexelOffset</name></member>                    <!-- min texel offset for OpTextureSampleOffset -->
            <member><type>uint32_t</type>               <name>maxTexelOffset</name></member>                    <!-- max texel offset for OpTextureSampleOffset -->
            <member><type>int32_t</type>                <name>minTexelGatherOffset</name></member>              <!-- min texel offset for OpTextureGatherOffset -->
            <member><type>uint32_t</type>               <name>maxTexelGatherOffset</name></member>              <!-- max texel offset for OpTextureGatherOffset -->
            <member><type>float</type>                  <name>minInterpolationOffset</name></member>            <!-- furthest negative offset for interpolateAtOffset -->
            <member><type>float</type>                  <name>maxInterpolationOffset</name></member>            <!-- furthest positive offset for interpolateAtOffset -->
            <member><type>uint32_t</type>               <name>subPixelInterpolationOffsetBits</name></member>   <!-- number of subpixel bits for interpolateAtOffset -->
            <member><type>uint32_t</type>               <name>maxFramebufferWidth</name></member>               <!-- max width for a framebuffer -->
            <member><type>uint32_t</type>               <name>maxFramebufferHeight</name></member>              <!-- max height for a framebuffer -->
            <member><type>uint32_t</type>               <name>maxFramebufferLayers</name></member>              <!-- max layer count for a layered framebuffer -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>framebufferColorSampleCounts</name></member>      <!-- supported color sample counts for a framebuffer -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>framebufferDepthSampleCounts</name></member>      <!-- supported depth sample counts for a framebuffer -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>framebufferStencilSampleCounts</name></member>    <!-- supported stencil sample counts for a framebuffer -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>framebufferNoAttachmentsSampleCounts</name></member> <!-- supported sample counts for a framebuffer with no attachments -->
            <member><type>uint32_t</type>               <name>maxColorAttachments</name></member>               <!-- max number of color attachments per subpass -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageColorSampleCounts</name></member>     <!-- supported color sample counts for a non-integer sampled image -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageIntegerSampleCounts</name></member>   <!-- supported sample counts for an integer image -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageDepthSampleCounts</name></member>     <!-- supported depth sample counts for a sampled image -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageStencilSampleCounts</name></member>   <!-- supported stencil sample counts for a sampled image -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>storageImageSampleCounts</name></member>          <!-- supported sample counts for a storage image -->
            <member><type>uint32_t</type>               <name>maxSampleMaskWords</name></member>                <!-- max number of sample mask words -->
            <member><type>VkBool32</type>               <name>timestampComputeAndGraphics</name></member>       <!-- timestamps on graphics and compute queues -->
            <member><type>float</type>                  <name>timestampPeriod</name></member>                   <!-- number of nanoseconds it takes for timestamp query value to increment by 1 -->
            <member><type>uint32_t</type>               <name>maxClipDistances</name></member>                  <!-- max number of clip distances -->
            <member><type>uint32_t</type>               <name>maxCullDistances</name></member>                  <!-- max number of cull distances -->
            <member><type>uint32_t</type>               <name>maxCombinedClipAndCullDistances</name></member>   <!-- max combined number of user clipping -->
            <member><type>uint32_t</type>               <name>discreteQueuePriorities</name></member>           <!-- distinct queue priorities available  -->
            <member><type>float</type>                  <name>pointSizeRange</name>[2]</member>                 <!-- range (min,max) of supported point sizes -->
            <member><type>float</type>                  <name>lineWidthRange</name>[2]</member>                 <!-- range (min,max) of supported line widths -->
            <member><type>float</type>                  <name>pointSizeGranularity</name></member>              <!-- granularity of supported point sizes -->
            <member><type>float</type>                  <name>lineWidthGranularity</name></member>              <!-- granularity of supported line widths -->
            <member><type>VkBool32</type>               <name>strictLines</name></member>                       <!-- line rasterization follows preferred rules -->
            <member><type>VkBool32</type>               <name>standardSampleLocations</name></member>           <!-- supports standard sample locations for all supported sample counts -->
            <member><type>VkDeviceSize</type>           <name>optimalBufferCopyOffsetAlignment</name></member>  <!-- optimal offset of buffer copies -->
            <member><type>VkDeviceSize</type>           <name>optimalBufferCopyRowPitchAlignment</name></member><!-- optimal pitch of buffer copies -->
            <member><type>VkDeviceSize</type>           <name>nonCoherentAtomSize</name></member>               <!-- minimum size and alignment for non-coherent host-mapped device memory access -->
        </type>
        <type category="struct" name="VkSemaphoreCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkSemaphoreCreateFlags</type> <name>flags</name></member>                          <!-- Semaphore creation flags -->
        </type>
        <type category="struct" name="VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkQueryPoolCreateFlags</type> <name>flags</name></member>                          <!-- Reserved -->
            <member><type>VkQueryType</type>            <name>queryType</name></member>
            <member><type>uint32_t</type>               <name>queryCount</name></member>
            <member optional="true" noautovalidity="true"><type>VkQueryPipelineStatisticFlags</type> <name>pipelineStatistics</name></member>      <!-- Optional -->
        </type>
        <type category="struct" name="VkFramebufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkFramebufferCreateFlags</type>    <name>flags</name></member>                     <!-- Reserved -->
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name></member>
            <member len="attachmentCount">const <type>VkImageView</type>*     <name>pAttachments</name></member>
            <member><type>uint32_t</type>               <name>width</name></member>
            <member><type>uint32_t</type>               <name>height</name></member>
            <member><type>uint32_t</type>               <name>layers</name></member>
        </type>
        <type category="struct" name="VkDrawIndirectCommand">
            <member><type>uint32_t</type>               <name>vertexCount</name></member>
            <member><type>uint32_t</type>               <name>instanceCount</name></member>
            <member><type>uint32_t</type>               <name>firstVertex</name></member>
            <member><type>uint32_t</type>               <name>firstInstance</name></member>
        </type>
        <type category="struct" name="VkDrawIndexedIndirectCommand">
            <member><type>uint32_t</type>               <name>indexCount</name></member>
            <member><type>uint32_t</type>               <name>instanceCount</name></member>
            <member><type>uint32_t</type>               <name>firstIndex</name></member>
            <member><type>int32_t</type>                <name>vertexOffset</name></member>
            <member><type>uint32_t</type>               <name>firstInstance</name></member>
        </type>
        <type category="struct" name="VkDispatchIndirectCommand">
            <member><type>uint32_t</type>               <name>x</name></member>
            <member><type>uint32_t</type>               <name>y</name></member>
            <member><type>uint32_t</type>               <name>z</name></member>
        </type>
        <type category="struct" name="VkSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>uint32_t</type>       <name>waitSemaphoreCount</name></member>
            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>*     <name>pWaitSemaphores</name></member>
            <member len="waitSemaphoreCount">const <type>VkPipelineStageFlags</type>*           <name>pWaitDstStageMask</name></member>
            <member optional="true"><type>uint32_t</type>       <name>commandBufferCount</name></member>
            <member len="commandBufferCount">const <type>VkCommandBuffer</type>*     <name>pCommandBuffers</name></member>
            <member optional="true"><type>uint32_t</type>       <name>signalSemaphoreCount</name></member>
            <member len="signalSemaphoreCount">const <type>VkSemaphore</type>*     <name>pSignalSemaphores</name></member>
        </type>
        <!-- WSI extensions -->
        <type category="struct" name="VkDisplayPropertiesKHR" returnedonly="true">
            <member><type>VkDisplayKHR</type>                     <name>display</name></member>                  <!-- Handle of the display object -->
            <member len="null-terminated">const <type>char</type>*                      <name>displayName</name></member>              <!-- Name of the display -->
            <member><type>VkExtent2D</type>                       <name>physicalDimensions</name></member>       <!-- In millimeters? -->
            <member><type>VkExtent2D</type>                       <name>physicalResolution</name></member>       <!-- Max resolution for CRT? -->
            <member optional="true"><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name></member>      <!-- one or more bits from VkSurfaceTransformFlagsKHR -->
            <member><type>VkBool32</type>                         <name>planeReorderPossible</name></member>     <!-- VK_TRUE if the overlay plane's z-order can be changed on this display. -->
            <member><type>VkBool32</type>                         <name>persistentContent</name></member>        <!-- VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering. -->
        </type>
        <type category="struct" name="VkDisplayPlanePropertiesKHR" returnedonly="true">
            <member><type>VkDisplayKHR</type>                     <name>currentDisplay</name></member>           <!-- Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use. -->
            <member><type>uint32_t</type>                         <name>currentStackIndex</name></member>        <!-- Current z-order of the plane. -->
        </type>
        <type category="struct" name="VkDisplayModeParametersKHR">
            <member><type>VkExtent2D</type>                       <name>visibleRegion</name></member>            <!-- Visible scanout region. -->
            <member><type>uint32_t</type>                         <name>refreshRate</name></member>              <!-- Number of times per second the display is updated. -->
        </type>
        <type category="struct" name="VkDisplayModePropertiesKHR" returnedonly="true">
            <member><type>VkDisplayModeKHR</type>                 <name>displayMode</name></member>              <!-- Handle of this display mode. -->
            <member><type>VkDisplayModeParametersKHR</type>       <name>parameters</name></member>               <!-- The parameters this mode uses. -->
        </type>
        <type category="struct" name="VkDisplayModeCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkDisplayModeCreateFlagsKHR</type>      <name>flags</name></member>                    <!-- Reserved -->
            <member><type>VkDisplayModeParametersKHR</type>       <name>parameters</name></member>               <!-- The parameters this mode uses. -->
        </type>
        <type category="struct" name="VkDisplayPlaneCapabilitiesKHR" returnedonly="true">
            <member optional="true"><type>VkDisplayPlaneAlphaFlagsKHR</type>      <name>supportedAlpha</name></member>           <!-- Types of alpha blending supported, if any. -->
            <member><type>VkOffset2D</type>                       <name>minSrcPosition</name></member>           <!-- Does the plane have any position and extent restrictions? -->
            <member><type>VkOffset2D</type>                       <name>maxSrcPosition</name></member>
            <member><type>VkExtent2D</type>                       <name>minSrcExtent</name></member>
            <member><type>VkExtent2D</type>                       <name>maxSrcExtent</name></member>
            <member><type>VkOffset2D</type>                       <name>minDstPosition</name></member>
            <member><type>VkOffset2D</type>                       <name>maxDstPosition</name></member>
            <member><type>VkExtent2D</type>                       <name>minDstExtent</name></member>
            <member><type>VkExtent2D</type>                       <name>maxDstExtent</name></member>
        </type>
        <type category="struct" name="VkDisplaySurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkDisplaySurfaceCreateFlagsKHR</type>   <name>flags</name></member>                    <!-- Reserved -->
            <member><type>VkDisplayModeKHR</type>                 <name>displayMode</name></member>              <!-- The mode to use when displaying this surface -->
            <member><type>uint32_t</type>                         <name>planeIndex</name></member>               <!-- The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount. -->
            <member><type>uint32_t</type>                         <name>planeStackIndex</name></member>          <!-- The z-order of the plane. -->
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>transform</name></member>                <!-- Transform to apply to the images as part of the scanout operation -->
            <member><type>float</type>                            <name>globalAlpha</name></member>              <!-- Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR -->
            <member><type>VkDisplayPlaneAlphaFlagBitsKHR</type>   <name>alphaMode</name></member>                <!-- What type of alpha blending to use.  Must be a bit from vkGetDisplayPlanePropertiesKHR::supportedAlpha. -->
            <member><type>VkExtent2D</type>                       <name>imageExtent</name></member>              <!-- size of the images to use with this surface -->
        </type>
        <type category="struct" name="VkDisplayPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member><type>VkRect2D</type>                         <name>srcRect</name></member>                  <!-- Rectangle within the presentable image to read pixel data from when presenting to the display. -->
            <member><type>VkRect2D</type>                         <name>dstRect</name></member>                  <!-- Rectangle within the current display mode's visible region to display srcRectangle in. -->
            <member><type>VkBool32</type>                         <name>persistent</name></member>               <!-- For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE. -->
        </type>
        <type category="struct" name="VkSurfaceCapabilitiesKHR" returnedonly="true">
            <member><type>uint32_t</type>                         <name>minImageCount</name></member>            <!-- Supported minimum number of images for the surface -->
            <member><type>uint32_t</type>                         <name>maxImageCount</name></member>            <!-- Supported maximum number of images for the surface, 0 for unlimited -->
            <member><type>VkExtent2D</type>                       <name>currentExtent</name></member>            <!-- Current image width and height for the surface, (0, 0) if undefined -->
            <member><type>VkExtent2D</type>                       <name>minImageExtent</name></member>           <!-- Supported minimum image width and height for the surface -->
            <member><type>VkExtent2D</type>                       <name>maxImageExtent</name></member>           <!-- Supported maximum image width and height for the surface -->
            <member><type>uint32_t</type>                         <name>maxImageArrayLayers</name></member>      <!-- Supported maximum number of image layers for the surface -->
            <member optional="true"><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name></member>      <!-- 1 or more bits representing the transforms supported -->
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>currentTransform</name></member>         <!-- The surface's current transform relative to the device's natural orientation -->
            <member optional="true"><type>VkCompositeAlphaFlagsKHR</type>         <name>supportedCompositeAlpha</name></member>  <!-- 1 or more bits representing the alpha compositing modes supported -->
            <member optional="true"><type>VkImageUsageFlags</type>                <name>supportedUsageFlags</name></member>      <!-- Supported image usage flags for the surface -->
        </type>
        <type category="struct" name="VkAndroidSurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkAndroidSurfaceCreateFlagsKHR</type>   <name>flags</name></member>    <!-- Reserved -->
            <member noautovalidity="true"><type>ANativeWindow</type>*                   <name>window</name></member>
        </type>
        <type category="struct" name="VkMirSurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkMirSurfaceCreateFlagsKHR</type>   <name>flags</name></member>        <!-- Reserved -->
            <member noautovalidity="true"><type>MirConnection</type>*                   <name>connection</name></member>
            <member noautovalidity="true"><type>MirSurface</type>*                      <name>mirSurface</name></member>
        </type>
        <type category="struct" name="VkWaylandSurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkWaylandSurfaceCreateFlagsKHR</type>   <name>flags</name></member>    <!-- Reserved -->
            <member noautovalidity="true">struct <type>wl_display</type>*               <name>display</name></member>
            <member noautovalidity="true">struct <type>wl_surface</type>*               <name>surface</name></member>
        </type>
        <type category="struct" name="VkWin32SurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkWin32SurfaceCreateFlagsKHR</type>   <name>flags</name></member>      <!-- Reserved -->
            <member><type>HINSTANCE</type>                        <name>hinstance</name></member>
            <member><type>HWND</type>                             <name>hwnd</name></member>
        </type>
        <type category="struct" name="VkXlibSurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkXlibSurfaceCreateFlagsKHR</type>   <name>flags</name></member>       <!-- Reserved -->
            <member noautovalidity="true"><type>Display</type>*                         <name>dpy</name></member>
            <member><type>Window</type>                           <name>window</name></member>
        </type>
        <type category="struct" name="VkXcbSurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkXcbSurfaceCreateFlagsKHR</type>   <name>flags</name></member>        <!-- Reserved -->
            <member noautovalidity="true"><type>xcb_connection_t</type>*                <name>connection</name></member>
            <member><type>xcb_window_t</type>                     <name>window</name></member>
        </type>
        <type category="struct" name="VkSurfaceFormatKHR" returnedonly="true">
            <member><type>VkFormat</type>                         <name>format</name></member>                   <!-- Supported pair of rendering format -->
            <member><type>VkColorSpaceKHR</type>                  <name>colorSpace</name></member>               <!-- and color space for the surface -->
        </type>
        <type category="struct" name="VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkSwapchainCreateFlagsKHR</type>        <name>flags</name></member>                    <!-- Reserved -->
            <member><type>VkSurfaceKHR</type>                     <name>surface</name></member>                  <!-- The swapchain's target surface -->
            <member><type>uint32_t</type>                         <name>minImageCount</name></member>            <!-- Minimum number of presentation images the application needs -->
            <member><type>VkFormat</type>                         <name>imageFormat</name></member>              <!-- Format of the presentation images -->
            <member><type>VkColorSpaceKHR</type>                  <name>imageColorSpace</name></member>          <!-- Colorspace of the presentation images -->
            <member><type>VkExtent2D</type>                       <name>imageExtent</name></member>              <!-- Dimensions of the presentation images -->
            <member><type>uint32_t</type>                         <name>imageArrayLayers</name></member>         <!-- Determines the number of views for multiview/stereo presentation -->
            <member><type>VkImageUsageFlags</type>                <name>imageUsage</name></member>               <!-- Bits indicating how the presentation images will be used -->
            <member><type>VkSharingMode</type>                    <name>imageSharingMode</name></member>         <!-- Sharing mode used for the presentation images -->
            <member optional="true"><type>uint32_t</type>         <name>queueFamilyIndexCount</name></member>    <!-- Number of queue families having access to the images in case of concurrent sharing mode -->
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*                  <name>pQueueFamilyIndices</name></member>      <!-- Array of queue family indices having access to the images in case of concurrent sharing mode -->
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>preTransform</name></member>             <!-- The transform, relative to the device's natural orientation, applied to the image content prior to presentation -->
            <member><type>VkCompositeAlphaFlagBitsKHR</type>      <name>compositeAlpha</name></member>           <!-- The alpha blending mode used when compositing this surface with other surfaces in the window system -->
            <member><type>VkPresentModeKHR</type>                 <name>presentMode</name></member>              <!-- Which presentation mode to use for presents on this swap chain -->
            <member><type>VkBool32</type>                         <name>clipped</name></member>                  <!-- Specifies whether presentable images may be affected by window clip regions -->
            <member optional="true"><type>VkSwapchainKHR</type>   <name>oldSwapchain</name></member>             <!-- Existing swap chain to replace, if any -->
        </type>
        <type category="struct" name="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreCount</name></member>       <!-- Number of semaphores to wait for before presenting -->
            <member optional="true" len="waitSemaphoreCount">const <type>VkSemaphore</type>* <name>pWaitSemaphores</name></member> <!-- Semaphores to wait for before presenting -->
            <member><type>uint32_t</type>                         <name>swapchainCount</name></member>           <!-- Number of swap chains to present in this call -->
            <member len="swapchainCount">const <type>VkSwapchainKHR</type>* <name>pSwapchains</name></member>    <!-- Swapchains to present an image from -->
            <member len="swapchainCount">const <type>uint32_t</type>* <name>pImageIndices</name></member>        <!-- Indices of which swapchain images to present -->
            <member optional="true" len="swapchainCount"><type>VkResult</type>* <name>pResults</name></member>   <!-- Optional (i.e. if non-NULL) VkResult for each swapchain -->
        </type>
        <type category="struct" name="VkDebugReportCallbackCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member><type>VkDebugReportFlagsEXT</type>            <name>flags</name></member>                    <!-- Indicates which events call this callback-->
            <member><type>PFN_vkDebugReportCallbackEXT</type>     <name>pfnCallback</name></member>              <!-- Function pointer of a callback function-->
            <member optional="true"><type>void</type>*            <name>pUserData</name></member>                <!-- User data provided to callback function -->
        </type>
        <type category="struct" name="VkValidationFlagsEXT">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member><type>uint32_t</type>                         <name>disabledValidationCheckCount</name></member>   <!-- Number of validation checks to disable -->
            <member len="disabledValidationCheckCount"><type>VkValidationCheckEXT</type>* <name>pDisabledValidationChecks</name></member>   <!-- Validation checks to disable -->
        </type>
        <type category="struct" name="VkPipelineRasterizationStateRasterizationOrderAMD">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member><type>VkRasterizationOrderAMD</type>          <name>rasterizationOrder</name></member>       <!-- Rasterization order to use for the pipeline -->
        </type>
        <type category="struct" name="VkDebugMarkerObjectNameInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member><type>VkDebugReportObjectTypeEXT</type>       <name>objectType</name></member>               <!-- The type of the object -->
            <member><type>uint64_t</type>                         <name>object</name></member>                   <!-- The handle of the object, cast to uint64_t -->
            <member len="null-terminated">const <type>char</type>* <name>pObjectName</name></member>             <!-- Name to apply to the object -->
        </type>
        <type category="struct" name="VkDebugMarkerObjectTagInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member><type>VkDebugReportObjectTypeEXT</type>       <name>objectType</name></member>               <!-- The type of the object -->
            <member><type>uint64_t</type>                         <name>object</name></member>                   <!-- The handle of the object, cast to uint64_t -->
            <member><type>uint64_t</type>                         <name>tagName</name></member>                  <!-- The name of the tag to set on the object -->
            <member><type>size_t</type>                           <name>tagSize</name></member>                  <!-- The length in bytes of the tag data -->
            <member len="tagSize">const <type>void</type>*        <name>pTag</name></member>                     <!-- Tag data to attach to the object -->
        </type>
        <type category="struct" name="VkDebugMarkerMarkerInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member len="null-terminated">const <type>char</type>* <name>pMarkerName</name></member>             <!-- Name of the debug marker -->
            <member optional="true"><type>float</type>            <name>color</name>[4]</member>                 <!-- Optional color for debug marker -->
        </type>
        <type category="struct" name="VkDedicatedAllocationImageCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member><type>VkBool32</type>                         <name>dedicatedAllocation</name></member>      <!-- Whether this image uses a dedicated allocation -->
        </type>
        <type category="struct" name="VkDedicatedAllocationBufferCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member><type>VkBool32</type>                         <name>dedicatedAllocation</name></member>      <!-- Whether this buffer uses a dedicated allocation -->
        </type>
        <type category="struct" name="VkDedicatedAllocationMemoryAllocateInfoNV">
            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkImage</type>          <name>image</name></member>                    <!-- Image that this allocation will be bound to -->
            <member optional="true"><type>VkBuffer</type>         <name>buffer</name></member>                   <!-- Buffer that this allocation will be bound to -->
        </type>
        <type category="struct" name="VkExternalImageFormatPropertiesNV" returnedonly="true">
            <member><type>VkImageFormatProperties</type>          <name>imageFormatProperties</name></member>
            <member optional="true"><type>VkExternalMemoryFeatureFlagsNV</type>   <name>externalMemoryFeatures</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>exportFromImportedHandleTypes</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>compatibleHandleTypes</name></member>
        </type>
        <type category="struct" name="VkExternalMemoryImageCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkExportMemoryAllocateInfoNV">
            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkImportMemoryWin32HandleInfoNV">
            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleType</name></member>
            <member optional="true"><type>HANDLE</type>                           <name>handle</name></member>
        </type>
        <type category="struct" name="VkExportMemoryWin32HandleInfoNV">
            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>*       <name>pAttributes</name></member>
            <member optional="true"><type>DWORD</type>                            <name>dwAccess</name></member>
        </type>
        <type category="struct" name="VkWin32KeyedMutexAcquireReleaseInfoNV">
            <member values="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                         <name>acquireCount</name></member>
            <member len="acquireCount">const <type>VkDeviceMemory</type>*            <name>pAcquireSyncs</name></member>
            <member len="acquireCount">const <type>uint64_t</type>*                  <name>pAcquireKeys</name></member>
            <member len="acquireCount">const <type>uint32_t</type>*                  <name>pAcquireTimeoutMilliseconds</name></member>
            <member optional="true"><type>uint32_t</type>                         <name>releaseCount</name></member>
            <member len="releaseCount">const <type>VkDeviceMemory</type>*            <name>pReleaseSyncs</name></member>
            <member len="releaseCount">const <type>uint64_t</type>*                  <name>pReleaseKeys</name></member>
        </type>

        <type category="struct" name="VkDeviceGeneratedCommandsFeaturesNVX">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>computeBindingPointSupport</name></member>
        </type>
        <type category="struct" name="VkDeviceGeneratedCommandsLimitsNVX">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>maxIndirectCommandsLayoutTokenCount</name></member>
            <member><type>uint32_t</type>                         <name>maxObjectEntryCounts</name></member>
            <member><type>uint32_t</type>                         <name>minSequenceCountBufferOffsetAlignment</name></member>
            <member><type>uint32_t</type>                         <name>minSequenceIndexBufferOffsetAlignment</name></member>
            <member><type>uint32_t</type>                         <name>minCommandsTokenBufferOffsetAlignment</name></member>
        </type>
        <type category="struct" name="VkIndirectCommandsTokenNVX">
            <member><type>VkIndirectCommandsTokenTypeNVX</type>      <name>tokenType</name></member>
            <member><type>VkBuffer</type>                         <name>buffer</name></member>  <!-- buffer containing tableEntries and additional data for indirectCommands -->
            <member><type>VkDeviceSize</type>                     <name>offset</name></member>  <!-- offset from the base address of the buffer -->
        </type>
        <type category="struct" name="VkIndirectCommandsLayoutTokenNVX">
            <member><type>VkIndirectCommandsTokenTypeNVX</type>      <name>tokenType</name></member>
            <member><type>uint32_t</type>                         <name>bindingUnit</name></member>  <!-- Binding unit for vertex attribute / descriptor set, offset for pushconstants -->
            <member><type>uint32_t</type>                         <name>dynamicCount</name></member> <!-- Number of variable dynamic values for descriptor set / push constants -->
            <member><type>uint32_t</type>                         <name>divisor</name></member>      <!-- Rate the which the array is advanced per element (must be power of 2, minimum 1) -->
        </type>
        <type category="struct" name="VkIndirectCommandsLayoutCreateInfoNVX">
            <member values="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkPipelineBindPoint</type>                      <name>pipelineBindPoint</name></member>
            <member><type>VkIndirectCommandsLayoutUsageFlagsNVX</type>    <name>flags</name></member>
            <member><type>uint32_t</type>                                 <name>tokenCount</name></member>
            <member len="tokenCount">const <type>VkIndirectCommandsLayoutTokenNVX</type>*  <name>pTokens</name></member>
        </type>
        <type category="struct" name="VkCmdProcessCommandsInfoNVX">
            <member values="VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkObjectTableNVX</type>                                         <name>objectTable</name></member>
            <member><type>VkIndirectCommandsLayoutNVX</type>                              <name>indirectCommandsLayout</name></member>
            <member><type>uint32_t</type>                                                 <name>indirectCommandsTokenCount</name></member>
            <member len="indirectCommandsTokenCount">const <type>VkIndirectCommandsTokenNVX</type>*       <name>pIndirectCommandsTokens</name></member>
            <member><type>uint32_t</type>                                                 <name>maxSequencesCount</name></member>
            <member optional="true" externsync="true"><type>VkCommandBuffer</type>                          <name>targetCommandBuffer</name></member>
            <member optional="true"><type>VkBuffer</type>                                 <name>sequencesCountBuffer</name></member>
            <member optional="true"><type>VkDeviceSize</type>                             <name>sequencesCountOffset</name></member>
            <member optional="true"><type>VkBuffer</type>                                 <name>sequencesIndexBuffer</name></member>
            <member optional="true"><type>VkDeviceSize</type>                             <name>sequencesIndexOffset</name></member>
        </type>
        <type category="struct" name="VkCmdReserveSpaceForCommandsInfoNVX">
            <member values="VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkObjectTableNVX</type>                                         <name>objectTable</name></member>
            <member><type>VkIndirectCommandsLayoutNVX</type>                              <name>indirectCommandsLayout</name></member>
            <member><type>uint32_t</type>                                                 <name>maxSequencesCount</name></member>
        </type>
        <type category="struct" name="VkObjectTableCreateInfoNVX">
            <member values="VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member>const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                                          <name>objectCount</name></member>
            <member len="objectCount">const <type>VkObjectEntryTypeNVX</type>*       <name>pObjectEntryTypes</name></member>
            <member len="objectCount">const <type>uint32_t</type>*                   <name>pObjectEntryCounts</name></member>
            <member len="objectCount">const <type>VkObjectEntryUsageFlagsNVX</type>* <name>pObjectEntryUsageFlags</name></member>

            <member><type>uint32_t</type> <name>maxUniformBuffersPerDescriptor</name></member>
            <member><type>uint32_t</type> <name>maxStorageBuffersPerDescriptor</name></member>
            <member><type>uint32_t</type> <name>maxStorageImagesPerDescriptor</name></member>
            <member><type>uint32_t</type> <name>maxSampledImagesPerDescriptor</name></member>
            <member><type>uint32_t</type> <name>maxPipelineLayouts</name></member>
        </type>
        <type category="struct" name="VkObjectTableEntryNVX">
            <member><type>VkObjectEntryTypeNVX</type>         <name>type</name></member>
            <member><type>VkObjectEntryUsageFlagsNVX</type>   <name>flags</name></member>
        </type>
        <type category="struct" name="VkObjectTablePipelineEntryNVX">
            <member><type>VkObjectEntryTypeNVX</type>         <name>type</name></member>
            <member><type>VkObjectEntryUsageFlagsNVX</type>   <name>flags</name></member>
            <member><type>VkPipeline</type>                   <name>pipeline</name></member>
        </type>
        <type category="struct" name="VkObjectTableDescriptorSetEntryNVX">
            <member><type>VkObjectEntryTypeNVX</type>         <name>type</name></member>
            <member><type>VkObjectEntryUsageFlagsNVX</type>   <name>flags</name></member>
            <member><type>VkPipelineLayout</type>             <name>pipelineLayout</name></member>
            <member><type>VkDescriptorSet</type>              <name>descriptorSet</name></member>
        </type>
        <type category="struct" name="VkObjectTableVertexBufferEntryNVX">
            <member><type>VkObjectEntryTypeNVX</type>         <name>type</name></member>
            <member><type>VkObjectEntryUsageFlagsNVX</type>   <name>flags</name></member>
            <member><type>VkBuffer</type>                     <name>buffer</name></member>
        </type>
        <type category="struct" name="VkObjectTableIndexBufferEntryNVX">
            <member><type>VkObjectEntryTypeNVX</type>         <name>type</name></member>
            <member><type>VkObjectEntryUsageFlagsNVX</type>   <name>flags</name></member>
            <member><type>VkBuffer</type>                     <name>buffer</name></member>
        </type>
        <type category="struct" name="VkObjectTablePushConstantEntryNVX">
            <member><type>VkObjectEntryTypeNVX</type>         <name>type</name></member>
            <member><type>VkObjectEntryUsageFlagsNVX</type>   <name>flags</name></member>
            <member><type>VkPipelineLayout</type>             <name>pipelineLayout</name></member>
            <member><type>VkShaderStageFlags</type>           <name>stageFlags</name></member>
        </type>
    </types>

    <!-- SECTION: Vulkan enumerant (token) definitions. -->

    <enums name="API Constants" comment="Misc. hardcoded constants - not an enumerated type">
            <!-- This is part of the header boilerplate -->
        <enum value="256"   name="VK_MAX_PHYSICAL_DEVICE_NAME_SIZE"/>
        <enum value="16"    name="VK_UUID_SIZE"/>
        <enum value="256"   name="VK_MAX_EXTENSION_NAME_SIZE"/>
        <enum value="256"   name="VK_MAX_DESCRIPTION_SIZE"/>
        <enum value="32"    name="VK_MAX_MEMORY_TYPES"/>
        <enum value="16"    name="VK_MAX_MEMORY_HEAPS"/> <!-- The maximum number of unique memory heaps, each of which supporting 1 or more memory types. -->
        <enum value="1000.0f" name="VK_LOD_CLAMP_NONE"/>
        <enum value="(~0U)" name="VK_REMAINING_MIP_LEVELS"/>
        <enum value="(~0U)" name="VK_REMAINING_ARRAY_LAYERS"/>
        <enum value="(~0ULL)" name="VK_WHOLE_SIZE"/>
        <enum value="(~0U)" name="VK_ATTACHMENT_UNUSED"/>
        <enum value="1"     name="VK_TRUE"/>
        <enum value="0"     name="VK_FALSE"/>
        <enum value="(~0U)" name="VK_QUEUE_FAMILY_IGNORED"/>
        <enum value="(~0U)" name="VK_SUBPASS_EXTERNAL"/>
    </enums>

    <!-- Unlike OpenGL, most tokens in Vulkan are actual typed enumerants in
         their own numeric namespaces. The "name" attribute is the C enum
         type name, and is pulled in from a <type> definition above
         (slightly clunky, but retains the type / enum distinction). "type"
         attributes of "enum" or "bitmask" indicate that these values should
         be generated inside an appropriate definition. -->

    <enums name="VkImageLayout" type="enum">
        <enum value="0"     name="VK_IMAGE_LAYOUT_UNDEFINED"                         comment="Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)"/>
        <enum value="1"     name="VK_IMAGE_LAYOUT_GENERAL"                           comment="General layout when image can be used for any kind of access"/>
        <enum value="2"     name="VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"          comment="Optimal layout when image is only used for color attachment read/write"/>
        <enum value="3"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"  comment="Optimal layout when image is only used for depth/stencil attachment read/write"/>
        <enum value="4"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"   comment="Optimal layout when image is used for read only depth/stencil attachment and shader access"/>
        <enum value="5"     name="VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"          comment="Optimal layout when image is used for read only shader access"/>
        <enum value="6"     name="VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"           comment="Optimal layout when image is used only as source of transfer operations"/>
        <enum value="7"     name="VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"      comment="Optimal layout when image is used only as destination of transfer operations"/>
        <enum value="8"     name="VK_IMAGE_LAYOUT_PREINITIALIZED"                    comment="Initial layout used when the data is populated by the CPU"/>
    </enums>
    <enums name="VkAttachmentLoadOp" type="enum">
        <enum value="0"     name="VK_ATTACHMENT_LOAD_OP_LOAD"/>
        <enum value="1"     name="VK_ATTACHMENT_LOAD_OP_CLEAR"/>
        <enum value="2"     name="VK_ATTACHMENT_LOAD_OP_DONT_CARE"/>
    </enums>
    <enums name="VkAttachmentStoreOp" type="enum">
        <enum value="0"     name="VK_ATTACHMENT_STORE_OP_STORE"/>
        <enum value="1"     name="VK_ATTACHMENT_STORE_OP_DONT_CARE"/>
    </enums>
    <enums name="VkImageType" type="enum">
        <enum value="0"     name="VK_IMAGE_TYPE_1D"/>
        <enum value="1"     name="VK_IMAGE_TYPE_2D"/>
        <enum value="2"     name="VK_IMAGE_TYPE_3D"/>
    </enums>
    <enums name="VkImageTiling" type="enum">
        <enum value="0"     name="VK_IMAGE_TILING_OPTIMAL"/>
        <enum value="1"     name="VK_IMAGE_TILING_LINEAR"/>
    </enums>
    <enums name="VkImageViewType" type="enum">
        <enum value="0"     name="VK_IMAGE_VIEW_TYPE_1D"/>
        <enum value="1"     name="VK_IMAGE_VIEW_TYPE_2D"/>
        <enum value="2"     name="VK_IMAGE_VIEW_TYPE_3D"/>
        <enum value="3"     name="VK_IMAGE_VIEW_TYPE_CUBE"/>
        <enum value="4"     name="VK_IMAGE_VIEW_TYPE_1D_ARRAY"/>
        <enum value="5"     name="VK_IMAGE_VIEW_TYPE_2D_ARRAY"/>
        <enum value="6"     name="VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"/>
    </enums>
    <enums name="VkCommandBufferLevel" type="enum">
        <enum value="0"     name="VK_COMMAND_BUFFER_LEVEL_PRIMARY"/>
        <enum value="1"     name="VK_COMMAND_BUFFER_LEVEL_SECONDARY"/>
    </enums>
    <enums name="VkComponentSwizzle" type="enum">
        <enum value="0"     name="VK_COMPONENT_SWIZZLE_IDENTITY"/>
        <enum value="1"     name="VK_COMPONENT_SWIZZLE_ZERO"/>
        <enum value="2"     name="VK_COMPONENT_SWIZZLE_ONE"/>
        <enum value="3"     name="VK_COMPONENT_SWIZZLE_R"/>
        <enum value="4"     name="VK_COMPONENT_SWIZZLE_G"/>
        <enum value="5"     name="VK_COMPONENT_SWIZZLE_B"/>
        <enum value="6"     name="VK_COMPONENT_SWIZZLE_A"/>
    </enums>
    <enums name="VkDescriptorType" type="enum">
        <enum value="0"     name="VK_DESCRIPTOR_TYPE_SAMPLER"/>
        <enum value="1"     name="VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"/>
        <enum value="2"     name="VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"/>
        <enum value="3"     name="VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"/>
        <enum value="4"     name="VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"/>
        <enum value="5"     name="VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"/>
        <enum value="6"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"/>
        <enum value="7"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"/>
        <enum value="8"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"/>
        <enum value="9"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"/>
        <enum value="10"    name="VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"/>
    </enums>
    <enums name="VkQueryType" type="enum">
        <enum value="0"     name="VK_QUERY_TYPE_OCCLUSION"/>
        <enum value="1"     name="VK_QUERY_TYPE_PIPELINE_STATISTICS"                 comment="Optional"/>
        <enum value="2"     name="VK_QUERY_TYPE_TIMESTAMP"/>
    </enums>
    <enums name="VkBorderColor" type="enum">
        <enum value="0"     name="VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"/>
        <enum value="1"     name="VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"/>
        <enum value="2"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"/>
        <enum value="3"     name="VK_BORDER_COLOR_INT_OPAQUE_BLACK"/>
        <enum value="4"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"/>
        <enum value="5"     name="VK_BORDER_COLOR_INT_OPAQUE_WHITE"/>
    </enums>
    <enums name="VkPipelineBindPoint" type="enum">
        <enum value="0"     name="VK_PIPELINE_BIND_POINT_GRAPHICS"/>
        <enum value="1"     name="VK_PIPELINE_BIND_POINT_COMPUTE"/>
    </enums>
    <enums name="VkPipelineCacheHeaderVersion" type="enum">
        <enum value="1"     name="VK_PIPELINE_CACHE_HEADER_VERSION_ONE"/>
    </enums>
    <enums name="VkPrimitiveTopology" type="enum">
        <enum value="0"     name="VK_PRIMITIVE_TOPOLOGY_POINT_LIST"/>
        <enum value="1"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST"/>
        <enum value="2"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"/>
        <enum value="3"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"/>
        <enum value="4"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"/>
        <enum value="5"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"/>
        <enum value="6"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"/>
        <enum value="7"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"/>
        <enum value="8"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"/>
        <enum value="9"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"/>
        <enum value="10"    name="VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"/>
    </enums>
    <enums name="VkSharingMode" type="enum">
        <enum value="0"     name="VK_SHARING_MODE_EXCLUSIVE"/>
        <enum value="1"     name="VK_SHARING_MODE_CONCURRENT"/>
    </enums>
    <enums name="VkIndexType" type="enum">
        <enum value="0"     name="VK_INDEX_TYPE_UINT16"/>
        <enum value="1"     name="VK_INDEX_TYPE_UINT32"/>
    </enums>
    <enums name="VkFilter" type="enum">
        <enum value="0"     name="VK_FILTER_NEAREST"/>
        <enum value="1"     name="VK_FILTER_LINEAR"/>
    </enums>
    <enums name="VkSamplerMipmapMode" type="enum">
        <enum value="0"     name="VK_SAMPLER_MIPMAP_MODE_NEAREST"                        comment="Choose nearest mip level"/>
        <enum value="1"     name="VK_SAMPLER_MIPMAP_MODE_LINEAR"                         comment="Linear filter between mip levels"/>
    </enums>
    <enums name="VkSamplerAddressMode" type="enum">
        <enum value="0"     name="VK_SAMPLER_ADDRESS_MODE_REPEAT"/>
        <enum value="1"     name="VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"/>
        <enum value="2"     name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"/>
        <enum value="3"     name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"/>
        <!-- <enum value="4"     name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" comment="Reserved for VK_KHR_sampler_mirror_clamp_to_edge, do not alias!"/> -->
    </enums>
    <enums name="VkCompareOp" type="enum">
        <enum value="0"     name="VK_COMPARE_OP_NEVER"/>
        <enum value="1"     name="VK_COMPARE_OP_LESS"/>
        <enum value="2"     name="VK_COMPARE_OP_EQUAL"/>
        <enum value="3"     name="VK_COMPARE_OP_LESS_OR_EQUAL"/>
        <enum value="4"     name="VK_COMPARE_OP_GREATER"/>
        <enum value="5"     name="VK_COMPARE_OP_NOT_EQUAL"/>
        <enum value="6"     name="VK_COMPARE_OP_GREATER_OR_EQUAL"/>
        <enum value="7"     name="VK_COMPARE_OP_ALWAYS"/>
    </enums>
    <enums name="VkPolygonMode" type="enum">
        <enum value="0"     name="VK_POLYGON_MODE_FILL"/>
        <enum value="1"     name="VK_POLYGON_MODE_LINE"/>
        <enum value="2"     name="VK_POLYGON_MODE_POINT"/>
    </enums>
    <enums name="VkCullModeFlagBits" type="bitmask">
        <enum value="0"     name="VK_CULL_MODE_NONE"/>
        <enum bitpos="0"    name="VK_CULL_MODE_FRONT_BIT"/>
        <enum bitpos="1"    name="VK_CULL_MODE_BACK_BIT"/>
        <enum value="0x00000003" name="VK_CULL_MODE_FRONT_AND_BACK"/>
    </enums>
    <enums name="VkFrontFace" type="enum">
        <enum value="0"     name="VK_FRONT_FACE_COUNTER_CLOCKWISE"/>
        <enum value="1"     name="VK_FRONT_FACE_CLOCKWISE"/>
    </enums>
    <enums name="VkBlendFactor" type="enum">
        <enum value="0"     name="VK_BLEND_FACTOR_ZERO"/>
        <enum value="1"     name="VK_BLEND_FACTOR_ONE"/>
        <enum value="2"     name="VK_BLEND_FACTOR_SRC_COLOR"/>
        <enum value="3"     name="VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"/>
        <enum value="4"     name="VK_BLEND_FACTOR_DST_COLOR"/>
        <enum value="5"     name="VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"/>
        <enum value="6"     name="VK_BLEND_FACTOR_SRC_ALPHA"/>
        <enum value="7"     name="VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"/>
        <enum value="8"     name="VK_BLEND_FACTOR_DST_ALPHA"/>
        <enum value="9"     name="VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"/>
        <enum value="10"    name="VK_BLEND_FACTOR_CONSTANT_COLOR"/>
        <enum value="11"    name="VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"/>
        <enum value="12"    name="VK_BLEND_FACTOR_CONSTANT_ALPHA"/>
        <enum value="13"    name="VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"/>
        <enum value="14"    name="VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"/>
        <enum value="15"    name="VK_BLEND_FACTOR_SRC1_COLOR"/>
        <enum value="16"    name="VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"/>
        <enum value="17"    name="VK_BLEND_FACTOR_SRC1_ALPHA"/>
        <enum value="18"    name="VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"/>
    </enums>
    <enums name="VkBlendOp" type="enum">
        <enum value="0"     name="VK_BLEND_OP_ADD"/>
        <enum value="1"     name="VK_BLEND_OP_SUBTRACT"/>
        <enum value="2"     name="VK_BLEND_OP_REVERSE_SUBTRACT"/>
        <enum value="3"     name="VK_BLEND_OP_MIN"/>
        <enum value="4"     name="VK_BLEND_OP_MAX"/>
    </enums>
    <enums name="VkStencilOp" type="enum">
        <enum value="0"     name="VK_STENCIL_OP_KEEP"/>
        <enum value="1"     name="VK_STENCIL_OP_ZERO"/>
        <enum value="2"     name="VK_STENCIL_OP_REPLACE"/>
        <enum value="3"     name="VK_STENCIL_OP_INCREMENT_AND_CLAMP"/>
        <enum value="4"     name="VK_STENCIL_OP_DECREMENT_AND_CLAMP"/>
        <enum value="5"     name="VK_STENCIL_OP_INVERT"/>
        <enum value="6"     name="VK_STENCIL_OP_INCREMENT_AND_WRAP"/>
        <enum value="7"     name="VK_STENCIL_OP_DECREMENT_AND_WRAP"/>
    </enums>
    <enums name="VkLogicOp" type="enum">
        <enum value="0"     name="VK_LOGIC_OP_CLEAR"/>
        <enum value="1"     name="VK_LOGIC_OP_AND"/>
        <enum value="2"     name="VK_LOGIC_OP_AND_REVERSE"/>
        <enum value="3"     name="VK_LOGIC_OP_COPY"/>
        <enum value="4"     name="VK_LOGIC_OP_AND_INVERTED"/>
        <enum value="5"     name="VK_LOGIC_OP_NO_OP"/>
        <enum value="6"     name="VK_LOGIC_OP_XOR"/>
        <enum value="7"     name="VK_LOGIC_OP_OR"/>
        <enum value="8"     name="VK_LOGIC_OP_NOR"/>
        <enum value="9"     name="VK_LOGIC_OP_EQUIVALENT"/>
        <enum value="10"    name="VK_LOGIC_OP_INVERT"/>
        <enum value="11"    name="VK_LOGIC_OP_OR_REVERSE"/>
        <enum value="12"    name="VK_LOGIC_OP_COPY_INVERTED"/>
        <enum value="13"    name="VK_LOGIC_OP_OR_INVERTED"/>
        <enum value="14"    name="VK_LOGIC_OP_NAND"/>
        <enum value="15"    name="VK_LOGIC_OP_SET"/>
    </enums>
    <enums name="VkInternalAllocationType" type="enum">
        <enum value="0"     name="VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"/>
    </enums>
    <enums name="VkSystemAllocationScope" type="enum">
        <enum value="0"     name="VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"/>
        <enum value="1"     name="VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"/>
        <enum value="2"     name="VK_SYSTEM_ALLOCATION_SCOPE_CACHE"/>
        <enum value="3"     name="VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"/>
        <enum value="4"     name="VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"/>
    </enums>
    <enums name="VkPhysicalDeviceType" type="enum">
        <enum value="0"     name="VK_PHYSICAL_DEVICE_TYPE_OTHER"/>
        <enum value="1"     name="VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"/>
        <enum value="2"     name="VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"/>
        <enum value="3"     name="VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"/>
        <enum value="4"     name="VK_PHYSICAL_DEVICE_TYPE_CPU"/>
    </enums>
    <enums name="VkVertexInputRate" type="enum">
        <enum value="0"     name="VK_VERTEX_INPUT_RATE_VERTEX"/>
        <enum value="1"     name="VK_VERTEX_INPUT_RATE_INSTANCE"/>
    </enums>
    <enums name="VkFormat" type="enum" comment="Vulkan format definitions">
        <enum value="0"     name="VK_FORMAT_UNDEFINED"/>
        <enum value="1"     name="VK_FORMAT_R4G4_UNORM_PACK8"/>
        <enum value="2"     name="VK_FORMAT_R4G4B4A4_UNORM_PACK16"/>
        <enum value="3"     name="VK_FORMAT_B4G4R4A4_UNORM_PACK16"/>
        <enum value="4"     name="VK_FORMAT_R5G6B5_UNORM_PACK16"/>
        <enum value="5"     name="VK_FORMAT_B5G6R5_UNORM_PACK16"/>
        <enum value="6"     name="VK_FORMAT_R5G5B5A1_UNORM_PACK16"/>
        <enum value="7"     name="VK_FORMAT_B5G5R5A1_UNORM_PACK16"/>
        <enum value="8"     name="VK_FORMAT_A1R5G5B5_UNORM_PACK16"/>
        <enum value="9"     name="VK_FORMAT_R8_UNORM"/>
        <enum value="10"    name="VK_FORMAT_R8_SNORM"/>
        <enum value="11"    name="VK_FORMAT_R8_USCALED"/>
        <enum value="12"    name="VK_FORMAT_R8_SSCALED"/>
        <enum value="13"    name="VK_FORMAT_R8_UINT"/>
        <enum value="14"    name="VK_FORMAT_R8_SINT"/>
        <enum value="15"    name="VK_FORMAT_R8_SRGB"/>
        <enum value="16"    name="VK_FORMAT_R8G8_UNORM"/>
        <enum value="17"    name="VK_FORMAT_R8G8_SNORM"/>
        <enum value="18"    name="VK_FORMAT_R8G8_USCALED"/>
        <enum value="19"    name="VK_FORMAT_R8G8_SSCALED"/>
        <enum value="20"    name="VK_FORMAT_R8G8_UINT"/>
        <enum value="21"    name="VK_FORMAT_R8G8_SINT"/>
        <enum value="22"    name="VK_FORMAT_R8G8_SRGB"/>
        <enum value="23"    name="VK_FORMAT_R8G8B8_UNORM"/>
        <enum value="24"    name="VK_FORMAT_R8G8B8_SNORM"/>
        <enum value="25"    name="VK_FORMAT_R8G8B8_USCALED"/>
        <enum value="26"    name="VK_FORMAT_R8G8B8_SSCALED"/>
        <enum value="27"    name="VK_FORMAT_R8G8B8_UINT"/>
        <enum value="28"    name="VK_FORMAT_R8G8B8_SINT"/>
        <enum value="29"    name="VK_FORMAT_R8G8B8_SRGB"/>
        <enum value="30"    name="VK_FORMAT_B8G8R8_UNORM"/>
        <enum value="31"    name="VK_FORMAT_B8G8R8_SNORM"/>
        <enum value="32"    name="VK_FORMAT_B8G8R8_USCALED"/>
        <enum value="33"    name="VK_FORMAT_B8G8R8_SSCALED"/>
        <enum value="34"    name="VK_FORMAT_B8G8R8_UINT"/>
        <enum value="35"    name="VK_FORMAT_B8G8R8_SINT"/>
        <enum value="36"    name="VK_FORMAT_B8G8R8_SRGB"/>
        <enum value="37"    name="VK_FORMAT_R8G8B8A8_UNORM"/>
        <enum value="38"    name="VK_FORMAT_R8G8B8A8_SNORM"/>
        <enum value="39"    name="VK_FORMAT_R8G8B8A8_USCALED"/>
        <enum value="40"    name="VK_FORMAT_R8G8B8A8_SSCALED"/>
        <enum value="41"    name="VK_FORMAT_R8G8B8A8_UINT"/>
        <enum value="42"    name="VK_FORMAT_R8G8B8A8_SINT"/>
        <enum value="43"    name="VK_FORMAT_R8G8B8A8_SRGB"/>
        <enum value="44"    name="VK_FORMAT_B8G8R8A8_UNORM"/>
        <enum value="45"    name="VK_FORMAT_B8G8R8A8_SNORM"/>
        <enum value="46"    name="VK_FORMAT_B8G8R8A8_USCALED"/>
        <enum value="47"    name="VK_FORMAT_B8G8R8A8_SSCALED"/>
        <enum value="48"    name="VK_FORMAT_B8G8R8A8_UINT"/>
        <enum value="49"    name="VK_FORMAT_B8G8R8A8_SINT"/>
        <enum value="50"    name="VK_FORMAT_B8G8R8A8_SRGB"/>
        <enum value="51"    name="VK_FORMAT_A8B8G8R8_UNORM_PACK32"/>
        <enum value="52"    name="VK_FORMAT_A8B8G8R8_SNORM_PACK32"/>
        <enum value="53"    name="VK_FORMAT_A8B8G8R8_USCALED_PACK32"/>
        <enum value="54"    name="VK_FORMAT_A8B8G8R8_SSCALED_PACK32"/>
        <enum value="55"    name="VK_FORMAT_A8B8G8R8_UINT_PACK32"/>
        <enum value="56"    name="VK_FORMAT_A8B8G8R8_SINT_PACK32"/>
        <enum value="57"    name="VK_FORMAT_A8B8G8R8_SRGB_PACK32"/>
        <enum value="58"    name="VK_FORMAT_A2R10G10B10_UNORM_PACK32"/>
        <enum value="59"    name="VK_FORMAT_A2R10G10B10_SNORM_PACK32"/>
        <enum value="60"    name="VK_FORMAT_A2R10G10B10_USCALED_PACK32"/>
        <enum value="61"    name="VK_FORMAT_A2R10G10B10_SSCALED_PACK32"/>
        <enum value="62"    name="VK_FORMAT_A2R10G10B10_UINT_PACK32"/>
        <enum value="63"    name="VK_FORMAT_A2R10G10B10_SINT_PACK32"/>
        <enum value="64"    name="VK_FORMAT_A2B10G10R10_UNORM_PACK32"/>
        <enum value="65"    name="VK_FORMAT_A2B10G10R10_SNORM_PACK32"/>
        <enum value="66"    name="VK_FORMAT_A2B10G10R10_USCALED_PACK32"/>
        <enum value="67"    name="VK_FORMAT_A2B10G10R10_SSCALED_PACK32"/>
        <enum value="68"    name="VK_FORMAT_A2B10G10R10_UINT_PACK32"/>
        <enum value="69"    name="VK_FORMAT_A2B10G10R10_SINT_PACK32"/>
        <enum value="70"    name="VK_FORMAT_R16_UNORM"/>
        <enum value="71"    name="VK_FORMAT_R16_SNORM"/>
        <enum value="72"    name="VK_FORMAT_R16_USCALED"/>
        <enum value="73"    name="VK_FORMAT_R16_SSCALED"/>
        <enum value="74"    name="VK_FORMAT_R16_UINT"/>
        <enum value="75"    name="VK_FORMAT_R16_SINT"/>
        <enum value="76"    name="VK_FORMAT_R16_SFLOAT"/>
        <enum value="77"    name="VK_FORMAT_R16G16_UNORM"/>
        <enum value="78"    name="VK_FORMAT_R16G16_SNORM"/>
        <enum value="79"    name="VK_FORMAT_R16G16_USCALED"/>
        <enum value="80"    name="VK_FORMAT_R16G16_SSCALED"/>
        <enum value="81"    name="VK_FORMAT_R16G16_UINT"/>
        <enum value="82"    name="VK_FORMAT_R16G16_SINT"/>
        <enum value="83"    name="VK_FORMAT_R16G16_SFLOAT"/>
        <enum value="84"    name="VK_FORMAT_R16G16B16_UNORM"/>
        <enum value="85"    name="VK_FORMAT_R16G16B16_SNORM"/>
        <enum value="86"    name="VK_FORMAT_R16G16B16_USCALED"/>
        <enum value="87"    name="VK_FORMAT_R16G16B16_SSCALED"/>
        <enum value="88"    name="VK_FORMAT_R16G16B16_UINT"/>
        <enum value="89"    name="VK_FORMAT_R16G16B16_SINT"/>
        <enum value="90"    name="VK_FORMAT_R16G16B16_SFLOAT"/>
        <enum value="91"    name="VK_FORMAT_R16G16B16A16_UNORM"/>
        <enum value="92"    name="VK_FORMAT_R16G16B16A16_SNORM"/>
        <enum value="93"    name="VK_FORMAT_R16G16B16A16_USCALED"/>
        <enum value="94"    name="VK_FORMAT_R16G16B16A16_SSCALED"/>
        <enum value="95"    name="VK_FORMAT_R16G16B16A16_UINT"/>
        <enum value="96"    name="VK_FORMAT_R16G16B16A16_SINT"/>
        <enum value="97"    name="VK_FORMAT_R16G16B16A16_SFLOAT"/>
        <enum value="98"    name="VK_FORMAT_R32_UINT"/>
        <enum value="99"    name="VK_FORMAT_R32_SINT"/>
        <enum value="100"   name="VK_FORMAT_R32_SFLOAT"/>
        <enum value="101"   name="VK_FORMAT_R32G32_UINT"/>
        <enum value="102"   name="VK_FORMAT_R32G32_SINT"/>
        <enum value="103"   name="VK_FORMAT_R32G32_SFLOAT"/>
        <enum value="104"   name="VK_FORMAT_R32G32B32_UINT"/>
        <enum value="105"   name="VK_FORMAT_R32G32B32_SINT"/>
        <enum value="106"   name="VK_FORMAT_R32G32B32_SFLOAT"/>
        <enum value="107"   name="VK_FORMAT_R32G32B32A32_UINT"/>
        <enum value="108"   name="VK_FORMAT_R32G32B32A32_SINT"/>
        <enum value="109"   name="VK_FORMAT_R32G32B32A32_SFLOAT"/>
        <enum value="110"   name="VK_FORMAT_R64_UINT"/>
        <enum value="111"   name="VK_FORMAT_R64_SINT"/>
        <enum value="112"   name="VK_FORMAT_R64_SFLOAT"/>
        <enum value="113"   name="VK_FORMAT_R64G64_UINT"/>
        <enum value="114"   name="VK_FORMAT_R64G64_SINT"/>
        <enum value="115"   name="VK_FORMAT_R64G64_SFLOAT"/>
        <enum value="116"   name="VK_FORMAT_R64G64B64_UINT"/>
        <enum value="117"   name="VK_FORMAT_R64G64B64_SINT"/>
        <enum value="118"   name="VK_FORMAT_R64G64B64_SFLOAT"/>
        <enum value="119"   name="VK_FORMAT_R64G64B64A64_UINT"/>
        <enum value="120"   name="VK_FORMAT_R64G64B64A64_SINT"/>
        <enum value="121"   name="VK_FORMAT_R64G64B64A64_SFLOAT"/>
        <enum value="122"   name="VK_FORMAT_B10G11R11_UFLOAT_PACK32"/>
        <enum value="123"   name="VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"/>
        <enum value="124"   name="VK_FORMAT_D16_UNORM"/>
        <enum value="125"   name="VK_FORMAT_X8_D24_UNORM_PACK32"/>
        <enum value="126"   name="VK_FORMAT_D32_SFLOAT"/>
        <enum value="127"   name="VK_FORMAT_S8_UINT"/>
        <enum value="128"   name="VK_FORMAT_D16_UNORM_S8_UINT"/>
        <enum value="129"   name="VK_FORMAT_D24_UNORM_S8_UINT"/>
        <enum value="130"   name="VK_FORMAT_D32_SFLOAT_S8_UINT"/>
        <enum value="131"   name="VK_FORMAT_BC1_RGB_UNORM_BLOCK"/>
        <enum value="132"   name="VK_FORMAT_BC1_RGB_SRGB_BLOCK"/>
        <enum value="133"   name="VK_FORMAT_BC1_RGBA_UNORM_BLOCK"/>
        <enum value="134"   name="VK_FORMAT_BC1_RGBA_SRGB_BLOCK"/>
        <enum value="135"   name="VK_FORMAT_BC2_UNORM_BLOCK"/>
        <enum value="136"   name="VK_FORMAT_BC2_SRGB_BLOCK"/>
        <enum value="137"   name="VK_FORMAT_BC3_UNORM_BLOCK"/>
        <enum value="138"   name="VK_FORMAT_BC3_SRGB_BLOCK"/>
        <enum value="139"   name="VK_FORMAT_BC4_UNORM_BLOCK"/>
        <enum value="140"   name="VK_FORMAT_BC4_SNORM_BLOCK"/>
        <enum value="141"   name="VK_FORMAT_BC5_UNORM_BLOCK"/>
        <enum value="142"   name="VK_FORMAT_BC5_SNORM_BLOCK"/>
        <enum value="143"   name="VK_FORMAT_BC6H_UFLOAT_BLOCK"/>
        <enum value="144"   name="VK_FORMAT_BC6H_SFLOAT_BLOCK"/>
        <enum value="145"   name="VK_FORMAT_BC7_UNORM_BLOCK"/>
        <enum value="146"   name="VK_FORMAT_BC7_SRGB_BLOCK"/>
        <enum value="147"   name="VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"/>
        <enum value="148"   name="VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"/>
        <enum value="149"   name="VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"/>
        <enum value="150"   name="VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"/>
        <enum value="151"   name="VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"/>
        <enum value="152"   name="VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"/>
        <enum value="153"   name="VK_FORMAT_EAC_R11_UNORM_BLOCK"/>
        <enum value="154"   name="VK_FORMAT_EAC_R11_SNORM_BLOCK"/>
        <enum value="155"   name="VK_FORMAT_EAC_R11G11_UNORM_BLOCK"/>
        <enum value="156"   name="VK_FORMAT_EAC_R11G11_SNORM_BLOCK"/>
        <enum value="157"   name="VK_FORMAT_ASTC_4x4_UNORM_BLOCK"/>
        <enum value="158"   name="VK_FORMAT_ASTC_4x4_SRGB_BLOCK"/>
        <enum value="159"   name="VK_FORMAT_ASTC_5x4_UNORM_BLOCK"/>
        <enum value="160"   name="VK_FORMAT_ASTC_5x4_SRGB_BLOCK"/>
        <enum value="161"   name="VK_FORMAT_ASTC_5x5_UNORM_BLOCK"/>
        <enum value="162"   name="VK_FORMAT_ASTC_5x5_SRGB_BLOCK"/>
        <enum value="163"   name="VK_FORMAT_ASTC_6x5_UNORM_BLOCK"/>
        <enum value="164"   name="VK_FORMAT_ASTC_6x5_SRGB_BLOCK"/>
        <enum value="165"   name="VK_FORMAT_ASTC_6x6_UNORM_BLOCK"/>
        <enum value="166"   name="VK_FORMAT_ASTC_6x6_SRGB_BLOCK"/>
        <enum value="167"   name="VK_FORMAT_ASTC_8x5_UNORM_BLOCK"/>
        <enum value="168"   name="VK_FORMAT_ASTC_8x5_SRGB_BLOCK"/>
        <enum value="169"   name="VK_FORMAT_ASTC_8x6_UNORM_BLOCK"/>
        <enum value="170"   name="VK_FORMAT_ASTC_8x6_SRGB_BLOCK"/>
        <enum value="171"   name="VK_FORMAT_ASTC_8x8_UNORM_BLOCK"/>
        <enum value="172"   name="VK_FORMAT_ASTC_8x8_SRGB_BLOCK"/>
        <enum value="173"   name="VK_FORMAT_ASTC_10x5_UNORM_BLOCK"/>
        <enum value="174"   name="VK_FORMAT_ASTC_10x5_SRGB_BLOCK"/>
        <enum value="175"   name="VK_FORMAT_ASTC_10x6_UNORM_BLOCK"/>
        <enum value="176"   name="VK_FORMAT_ASTC_10x6_SRGB_BLOCK"/>
        <enum value="177"   name="VK_FORMAT_ASTC_10x8_UNORM_BLOCK"/>
        <enum value="178"   name="VK_FORMAT_ASTC_10x8_SRGB_BLOCK"/>
        <enum value="179"   name="VK_FORMAT_ASTC_10x10_UNORM_BLOCK"/>
        <enum value="180"   name="VK_FORMAT_ASTC_10x10_SRGB_BLOCK"/>
        <enum value="181"   name="VK_FORMAT_ASTC_12x10_UNORM_BLOCK"/>
        <enum value="182"   name="VK_FORMAT_ASTC_12x10_SRGB_BLOCK"/>
        <enum value="183"   name="VK_FORMAT_ASTC_12x12_UNORM_BLOCK"/>
        <enum value="184"   name="VK_FORMAT_ASTC_12x12_SRGB_BLOCK"/>
    </enums>
    <enums name="VkStructureType" type="enum" comment="Structure type enumerant">
        <enum value="0"     name="VK_STRUCTURE_TYPE_APPLICATION_INFO"/>
        <enum value="1"     name="VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"/>
        <enum value="2"     name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"/>
        <enum value="3"     name="VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"/>
        <enum value="4"     name="VK_STRUCTURE_TYPE_SUBMIT_INFO"/>
        <enum value="5"     name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"/>
        <enum value="6"     name="VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"/>
        <enum value="7"     name="VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"/>
        <enum value="8"     name="VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"/>
        <enum value="9"     name="VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"/>
        <enum value="10"    name="VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"/>
        <enum value="11"    name="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"/>
        <enum value="12"    name="VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"/>
        <enum value="13"    name="VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"/>
        <enum value="14"    name="VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"/>
        <enum value="15"    name="VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"/>
        <enum value="16"    name="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"/>
        <enum value="17"    name="VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"/>
        <enum value="18"    name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"/>
        <enum value="19"    name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"/>
        <enum value="20"    name="VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"/>
        <enum value="21"    name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"/>
        <enum value="22"    name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"/>
        <enum value="23"    name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"/>
        <enum value="24"    name="VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"/>
        <enum value="25"    name="VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"/>
        <enum value="26"    name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"/>
        <enum value="27"    name="VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"/>
        <enum value="28"    name="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"/>
        <enum value="29"    name="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"/>
        <enum value="30"    name="VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"/>
        <enum value="31"    name="VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"/>
        <enum value="32"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"/>
        <enum value="33"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"/>
        <enum value="34"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"/>
        <enum value="35"    name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"/>
        <enum value="36"    name="VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"/>
        <enum value="37"    name="VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"/>
        <enum value="38"    name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"/>
        <enum value="39"    name="VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"/>
        <enum value="40"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"/>
        <enum value="41"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"/>
        <enum value="42"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"/>
        <enum value="43"    name="VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"/>
        <enum value="44"    name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"/>
        <enum value="45"    name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"/>
        <enum value="46"    name="VK_STRUCTURE_TYPE_MEMORY_BARRIER"/>
        <enum value="47"    name="VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"/> <!-- Reserved for internal use by the loader, layers, and ICDs -->
        <enum value="48"    name="VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"/> <!-- Reserved for internal use by the loader, layers, and ICDs -->
    </enums>
    <enums name="VkSubpassContents" type="enum">
        <enum value="0"     name="VK_SUBPASS_CONTENTS_INLINE"/>
        <enum value="1"     name="VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"/>
    </enums>
    <enums name="VkResult" type="enum" comment="Error and return codes">
        <!-- Return codes for successful operation execution (positive values) -->
        <enum value="0"     name="VK_SUCCESS" comment="Command completed successfully"/>
        <enum value="1"     name="VK_NOT_READY" comment="A fence or query has not yet completed"/>
        <enum value="2"     name="VK_TIMEOUT" comment="A wait operation has not completed in the specified time"/>
        <enum value="3"     name="VK_EVENT_SET" comment="An event is signaled"/>
        <enum value="4"     name="VK_EVENT_RESET" comment="An event is unsignaled"/>
        <enum value="5"     name="VK_INCOMPLETE" comment="A return array was too small for the result"/>
        <!-- Error codes (negative values) -->
        <enum value="-1"    name="VK_ERROR_OUT_OF_HOST_MEMORY" comment="A host memory allocation has failed"/>
        <enum value="-2"    name="VK_ERROR_OUT_OF_DEVICE_MEMORY" comment="A device memory allocation has failed"/>
        <enum value="-3"    name="VK_ERROR_INITIALIZATION_FAILED" comment="Initialization of a object has failed"/>
        <enum value="-4"    name="VK_ERROR_DEVICE_LOST" comment="The logical device has been lost. See &lt;&lt;devsandqueues-lost-device&gt;&gt;"/>
        <enum value="-5"    name="VK_ERROR_MEMORY_MAP_FAILED" comment="Mapping of a memory object has failed"/>
        <enum value="-6"    name="VK_ERROR_LAYER_NOT_PRESENT" comment="Layer specified does not exist"/>
        <enum value="-7"    name="VK_ERROR_EXTENSION_NOT_PRESENT" comment="Extension specified does not exist"/>
        <enum value="-8"    name="VK_ERROR_FEATURE_NOT_PRESENT" comment="Requested feature is not available on this device"/>
        <enum value="-9"    name="VK_ERROR_INCOMPATIBLE_DRIVER" comment="Unable to find a Vulkan driver"/>
        <enum value="-10"   name="VK_ERROR_TOO_MANY_OBJECTS" comment="Too many objects of the type have already been created"/>
        <enum value="-11"   name="VK_ERROR_FORMAT_NOT_SUPPORTED" comment="Requested format is not supported on this device"/>
        <enum value="-12"   name="VK_ERROR_FRAGMENTED_POOL" comment="A requested pool allocation has failed due to fragmentation of the pool's memory"/>
            <unused start="-12"/>
    </enums>
    <enums name="VkDynamicState" type="enum">
        <enum value="0"    name="VK_DYNAMIC_STATE_VIEWPORT"/>
        <enum value="1"    name="VK_DYNAMIC_STATE_SCISSOR"/>
        <enum value="2"    name="VK_DYNAMIC_STATE_LINE_WIDTH"/>
        <enum value="3"    name="VK_DYNAMIC_STATE_DEPTH_BIAS"/>
        <enum value="4"    name="VK_DYNAMIC_STATE_BLEND_CONSTANTS"/>
        <enum value="5"    name="VK_DYNAMIC_STATE_DEPTH_BOUNDS"/>
        <enum value="6"    name="VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"/>
        <enum value="7"    name="VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"/>
        <enum value="8"    name="VK_DYNAMIC_STATE_STENCIL_REFERENCE"/>
    </enums>

    <!-- Flags -->
    <enums name="VkQueueFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUEUE_GRAPHICS_BIT"                             comment="Queue supports graphics operations"/>
        <enum bitpos="1"    name="VK_QUEUE_COMPUTE_BIT"                              comment="Queue supports compute operations"/>
        <enum bitpos="2"    name="VK_QUEUE_TRANSFER_BIT"                             comment="Queue supports transfer operations"/>
        <enum bitpos="3"    name="VK_QUEUE_SPARSE_BINDING_BIT"                       comment="Queue supports sparse resource memory management operations"/>
    </enums>
    <enums name="VkMemoryPropertyFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"               comment="If otherwise stated, then allocate memory on device"/>
        <enum bitpos="1"    name="VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"               comment="Memory is mappable by host"/>
        <enum bitpos="2"    name="VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"              comment="Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache"/>
        <enum bitpos="3"    name="VK_MEMORY_PROPERTY_HOST_CACHED_BIT"                comment="Memory will be cached by the host"/>
        <enum bitpos="4"    name="VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"           comment="Memory may be allocated by the driver when it is required"/>
    </enums>
    <enums name="VkMemoryHeapFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"                   comment="If set, heap represents device memory"/>
    </enums>
    <enums name="VkAccessFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_ACCESS_INDIRECT_COMMAND_READ_BIT"               comment="Controls coherency of indirect command reads"/>
        <enum bitpos="1"    name="VK_ACCESS_INDEX_READ_BIT"                          comment="Controls coherency of index reads"/>
        <enum bitpos="2"    name="VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"               comment="Controls coherency of vertex attribute reads"/>
        <enum bitpos="3"    name="VK_ACCESS_UNIFORM_READ_BIT"                        comment="Controls coherency of uniform buffer reads"/>
        <enum bitpos="4"    name="VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"               comment="Controls coherency of input attachment reads"/>
        <enum bitpos="5"    name="VK_ACCESS_SHADER_READ_BIT"                         comment="Controls coherency of shader reads"/>
        <enum bitpos="6"    name="VK_ACCESS_SHADER_WRITE_BIT"                        comment="Controls coherency of shader writes"/>
        <enum bitpos="7"    name="VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"               comment="Controls coherency of color attachment reads"/>
        <enum bitpos="8"    name="VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"              comment="Controls coherency of color attachment writes"/>
        <enum bitpos="9"    name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"       comment="Controls coherency of depth/stencil attachment reads"/>
        <enum bitpos="10"   name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"      comment="Controls coherency of depth/stencil attachment writes"/>
        <enum bitpos="11"   name="VK_ACCESS_TRANSFER_READ_BIT"                       comment="Controls coherency of transfer reads"/>
        <enum bitpos="12"   name="VK_ACCESS_TRANSFER_WRITE_BIT"                      comment="Controls coherency of transfer writes"/>
        <enum bitpos="13"   name="VK_ACCESS_HOST_READ_BIT"                           comment="Controls coherency of host reads"/>
        <enum bitpos="14"   name="VK_ACCESS_HOST_WRITE_BIT"                          comment="Controls coherency of host writes"/>
        <enum bitpos="15"   name="VK_ACCESS_MEMORY_READ_BIT"                         comment="Controls coherency of memory reads"/>
        <enum bitpos="16"   name="VK_ACCESS_MEMORY_WRITE_BIT"                        comment="Controls coherency of memory writes"/>
    </enums>
    <enums name="VkBufferUsageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_BUFFER_USAGE_TRANSFER_SRC_BIT"                  comment="Can be used as a source of transfer operations"/>
        <enum bitpos="1"    name="VK_BUFFER_USAGE_TRANSFER_DST_BIT"                  comment="Can be used as a destination of transfer operations"/>
        <enum bitpos="2"    name="VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"          comment="Can be used as TBO"/>
        <enum bitpos="3"    name="VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"          comment="Can be used as IBO"/>
        <enum bitpos="4"    name="VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"                comment="Can be used as UBO"/>
        <enum bitpos="5"    name="VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"                comment="Can be used as SSBO"/>
        <enum bitpos="6"    name="VK_BUFFER_USAGE_INDEX_BUFFER_BIT"                  comment="Can be used as source of fixed-function index fetch (index buffer)"/>
        <enum bitpos="7"    name="VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"                 comment="Can be used as source of fixed-function vertex fetch (VBO)"/>
        <enum bitpos="8"    name="VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"               comment="Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)"/>
    </enums>
    <enums name="VkBufferCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_BUFFER_CREATE_SPARSE_BINDING_BIT"               comment="Buffer should support sparse backing"/>
        <enum bitpos="1"    name="VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"             comment="Buffer should support sparse backing with partial residency"/>
        <enum bitpos="2"    name="VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"               comment="Buffer should support constent data access to physical memory ranges mapped into multiple locations of sparse buffers"/>
    </enums>
    <enums name="VkShaderStageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SHADER_STAGE_VERTEX_BIT"/>
        <enum bitpos="1"    name="VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"/>
        <enum bitpos="2"    name="VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"/>
        <enum bitpos="3"    name="VK_SHADER_STAGE_GEOMETRY_BIT"/>
        <enum bitpos="4"    name="VK_SHADER_STAGE_FRAGMENT_BIT"/>
        <enum bitpos="5"    name="VK_SHADER_STAGE_COMPUTE_BIT"/>
        <enum value="0x0000001F" name="VK_SHADER_STAGE_ALL_GRAPHICS"/>
        <enum value="0x7FFFFFFF" name="VK_SHADER_STAGE_ALL"/>
    </enums>
    <enums name="VkImageUsageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_USAGE_TRANSFER_SRC_BIT"                   comment="Can be used as a source of transfer operations"/>
        <enum bitpos="1"    name="VK_IMAGE_USAGE_TRANSFER_DST_BIT"                   comment="Can be used as a destination of transfer operations"/>
        <enum bitpos="2"    name="VK_IMAGE_USAGE_SAMPLED_BIT"                        comment="Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
        <enum bitpos="3"    name="VK_IMAGE_USAGE_STORAGE_BIT"                        comment="Can be used as storage image (STORAGE_IMAGE descriptor type)"/>
        <enum bitpos="4"    name="VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"               comment="Can be used as framebuffer color attachment"/>
        <enum bitpos="5"    name="VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"       comment="Can be used as framebuffer depth/stencil attachment"/>
        <enum bitpos="6"    name="VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"           comment="Image data not needed outside of rendering"/>
        <enum bitpos="7"    name="VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"               comment="Can be used as framebuffer input attachment"/>
    </enums>
    <enums name="VkImageCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_CREATE_SPARSE_BINDING_BIT"                comment="Image should support sparse backing"/>
        <enum bitpos="1"    name="VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"              comment="Image should support sparse backing with partial residency"/>
        <enum bitpos="2"    name="VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"                comment="Image should support constent data access to physical memory ranges mapped into multiple locations of sparse images"/>
        <enum bitpos="3"    name="VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"                comment="Allows image views to have different format than the base image"/>
        <enum bitpos="4"    name="VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"               comment="Allows creating image views with cube type from the created image"/>
    </enums>
    <enums name="VkPipelineCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"/>
        <enum bitpos="1"    name="VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"/>
        <enum bitpos="2"    name="VK_PIPELINE_CREATE_DERIVATIVE_BIT"/>
    </enums>
    <enums name="VkColorComponentFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COLOR_COMPONENT_R_BIT"/>
        <enum bitpos="1"    name="VK_COLOR_COMPONENT_G_BIT"/>
        <enum bitpos="2"    name="VK_COLOR_COMPONENT_B_BIT"/>
        <enum bitpos="3"    name="VK_COLOR_COMPONENT_A_BIT"/>
    </enums>
    <enums name="VkFenceCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_FENCE_CREATE_SIGNALED_BIT"/>
    </enums>
    <enums name="VkFormatFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"               comment="Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
        <enum bitpos="1"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"               comment="Format can be used for storage images (STORAGE_IMAGE descriptor type)"/>
        <enum bitpos="2"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"        comment="Format supports atomic operations in case it is used for storage images"/>
        <enum bitpos="3"    name="VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"        comment="Format can be used for uniform texel buffers (TBOs)"/>
        <enum bitpos="4"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"        comment="Format can be used for storage texel buffers (IBOs)"/>
        <enum bitpos="5"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT" comment="Format supports atomic operations in case it is used for storage texel buffers"/>
        <enum bitpos="6"    name="VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"               comment="Format can be used for vertex buffers (VBOs)"/>
        <enum bitpos="7"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"            comment="Format can be used for color attachment images"/>
        <enum bitpos="8"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"      comment="Format supports blending in case it is used for color attachment images"/>
        <enum bitpos="9"    name="VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"    comment="Format can be used for depth/stencil attachment images"/>
        <enum bitpos="10"   name="VK_FORMAT_FEATURE_BLIT_SRC_BIT"                    comment="Format can be used as the source image of blits with vkCmdBlitImage"/>
        <enum bitpos="11"   name="VK_FORMAT_FEATURE_BLIT_DST_BIT"                    comment="Format can be used as the destination image of blits with vkCmdBlitImage"/>
        <enum bitpos="12"   name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT" comment="Format can be filtered with VK_FILTER_LINEAR when being sampled"/>
    </enums>
    <enums name="VkQueryControlFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_CONTROL_PRECISE_BIT"                      comment="Require precise results to be collected by the query"/>
    </enums>
    <enums name="VkQueryResultFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_RESULT_64_BIT"                            comment="Results of the queries are written to the destination buffer as 64-bit values"/>
        <enum bitpos="1"    name="VK_QUERY_RESULT_WAIT_BIT"                          comment="Results of the queries are waited on before proceeding with the result copy"/>
        <enum bitpos="2"    name="VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"             comment="Besides the results of the query, the availability of the results is also written"/>
        <enum bitpos="3"    name="VK_QUERY_RESULT_PARTIAL_BIT"                       comment="Copy the partial results of the query even if the final results are not available"/>
    </enums>
    <enums name="VkCommandBufferUsageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"/>
        <enum bitpos="1"    name="VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"/>
        <enum bitpos="2"    name="VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"      comment="Command buffer may be submitted/executed more than once simultaneously"/>
    </enums>
    <enums name="VkQueryPipelineStatisticFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"                    comment="Optional"/>
        <enum bitpos="1"    name="VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"                  comment="Optional"/>
        <enum bitpos="2"    name="VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"                  comment="Optional"/>
        <enum bitpos="3"    name="VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"                comment="Optional"/>
        <enum bitpos="4"    name="VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"                 comment="Optional"/>
        <enum bitpos="5"    name="VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"                       comment="Optional"/>
        <enum bitpos="6"    name="VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"                        comment="Optional"/>
        <enum bitpos="7"    name="VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"                comment="Optional"/>
        <enum bitpos="8"    name="VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"        comment="Optional"/>
        <enum bitpos="9"    name="VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT" comment="Optional"/>
        <enum bitpos="10"   name="VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"                 comment="Optional"/>
    </enums>
    <enums name="VkImageAspectFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_ASPECT_COLOR_BIT"/>
        <enum bitpos="1"    name="VK_IMAGE_ASPECT_DEPTH_BIT"/>
        <enum bitpos="2"    name="VK_IMAGE_ASPECT_STENCIL_BIT"/>
        <enum bitpos="3"    name="VK_IMAGE_ASPECT_METADATA_BIT"/>
    </enums>
    <enums name="VkSparseImageFormatFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"            comment="Image uses a single mip tail region for all array layers"/>
        <enum bitpos="1"    name="VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"          comment="Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels."/>
        <enum bitpos="2"    name="VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT" comment="Image uses a non-standard sparse image block dimensions"/>
    </enums>
    <enums name="VkSparseMemoryBindFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SPARSE_MEMORY_BIND_METADATA_BIT"                comment="Operation binds resource metadata to memory"/>
    </enums>
    <enums name="VkPipelineStageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"                 comment="Before subsequent commands are processed"/>
        <enum bitpos="1"    name="VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"               comment="Draw/DispatchIndirect command fetch"/>
        <enum bitpos="2"    name="VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"                comment="Vertex/index fetch"/>
        <enum bitpos="3"    name="VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"               comment="Vertex shading"/>
        <enum bitpos="4"    name="VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT"         comment="Tessellation control shading"/>
        <enum bitpos="5"    name="VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"      comment="Tessellation evaluation shading"/>
        <enum bitpos="6"    name="VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"             comment="Geometry shading"/>
        <enum bitpos="7"    name="VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"             comment="Fragment shading"/>
        <enum bitpos="8"    name="VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"        comment="Early fragment (depth and stencil) tests"/>
        <enum bitpos="9"    name="VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"         comment="Late fragment (depth and stencil) tests"/>
        <enum bitpos="10"   name="VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"     comment="Color attachment writes"/>
        <enum bitpos="11"   name="VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"              comment="Compute shading"/>
        <enum bitpos="12"   name="VK_PIPELINE_STAGE_TRANSFER_BIT"                    comment="Transfer/copy operations"/>
        <enum bitpos="13"   name="VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"              comment="After previous commands have completed"/>
        <enum bitpos="14"   name="VK_PIPELINE_STAGE_HOST_BIT"                        comment="Indicates host (CPU) is a source/sink of the dependency"/>
        <enum bitpos="15"   name="VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"                comment="All stages of the graphics pipeline"/>
        <enum bitpos="16"   name="VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"                comment="All stages supported on the queue"/>
    </enums>
    <enums name="VkCommandPoolCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"              comment="Command buffers have a short lifetime"/>
        <enum bitpos="1"    name="VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"   comment="Command buffers may release their memory individually"/>
    </enums>
    <enums name="VkCommandPoolResetFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"       comment="Release resources owned by the pool"/>
    </enums>
    <enums name="VkCommandBufferResetFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"     comment="Release resources owned by the buffer"/>
    </enums>
    <enums name="VkSampleCountFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SAMPLE_COUNT_1_BIT"                             comment="Sample count 1 supported"/>
        <enum bitpos="1"    name="VK_SAMPLE_COUNT_2_BIT"                             comment="Sample count 2 supported"/>
        <enum bitpos="2"    name="VK_SAMPLE_COUNT_4_BIT"                             comment="Sample count 4 supported"/>
        <enum bitpos="3"    name="VK_SAMPLE_COUNT_8_BIT"                             comment="Sample count 8 supported"/>
        <enum bitpos="4"    name="VK_SAMPLE_COUNT_16_BIT"                            comment="Sample count 16 supported"/>
        <enum bitpos="5"    name="VK_SAMPLE_COUNT_32_BIT"                            comment="Sample count 32 supported"/>
        <enum bitpos="6"    name="VK_SAMPLE_COUNT_64_BIT"                            comment="Sample count 64 supported"/>
    </enums>
    <enums name="VkAttachmentDescriptionFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"           comment="The attachment may alias physical memory of another attachment in the same render pass"/>
    </enums>
    <enums name="VkStencilFaceFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_STENCIL_FACE_FRONT_BIT"                         comment="Front face"/>
        <enum bitpos="1"    name="VK_STENCIL_FACE_BACK_BIT"                          comment="Back face"/>
        <enum value="0x00000003" name="VK_STENCIL_FRONT_AND_BACK"                    comment="Front and back faces"/>
    </enums>
    <enums name="VkDescriptorPoolCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT" comment="Descriptor sets may be freed individually"/>
    </enums>
    <enums name="VkDependencyFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_DEPENDENCY_BY_REGION_BIT"                       comment="Dependency is per pixel region "/>
    </enums>
        <!-- WSI extensions -->
    <enums name="VkPresentModeKHR" type="enum">
        <enum value="0"     name="VK_PRESENT_MODE_IMMEDIATE_KHR"/>
        <enum value="1"     name="VK_PRESENT_MODE_MAILBOX_KHR"/>
        <enum value="2"     name="VK_PRESENT_MODE_FIFO_KHR"/>
        <enum value="3"     name="VK_PRESENT_MODE_FIFO_RELAXED_KHR"/>
    </enums>
    <enums name="VkColorSpaceKHR" type="enum">
        <enum value="0"     name="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"/>
    </enums>
    <enums name="VkDisplayPlaneAlphaFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"/>
        <enum bitpos="1"    name="VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"/>
        <enum bitpos="2"    name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"/>
        <enum bitpos="3"    name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"/>
    </enums>
    <enums name="VkCompositeAlphaFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"/>
        <enum bitpos="1"    name="VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"/>
        <enum bitpos="2"    name="VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"/>
        <enum bitpos="3"    name="VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"/>
    </enums>
    <enums name="VkSurfaceTransformFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"/>
        <enum bitpos="1"    name="VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"/>
        <enum bitpos="2"    name="VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"/>
        <enum bitpos="3"    name="VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"/>
        <enum bitpos="4"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"/>
        <enum bitpos="5"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"/>
        <enum bitpos="6"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"/>
        <enum bitpos="7"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"/>
        <enum bitpos="8"    name="VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"/>
    </enums>
    <enums name="VkDebugReportFlagBitsEXT" type="bitmask">
        <enum bitpos="0"     name="VK_DEBUG_REPORT_INFORMATION_BIT_EXT"/>
        <enum bitpos="1"     name="VK_DEBUG_REPORT_WARNING_BIT_EXT"/>
        <enum bitpos="2"     name="VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"/>
        <enum bitpos="3"     name="VK_DEBUG_REPORT_ERROR_BIT_EXT"/>
        <enum bitpos="4"     name="VK_DEBUG_REPORT_DEBUG_BIT_EXT"/>
    </enums>
    <enums name="VkDebugReportObjectTypeEXT" type="enum">
        <enum value="0" name="VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"/>
        <enum value="1" name="VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"/>
        <enum value="2" name="VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"/>
        <enum value="3" name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"/>
        <enum value="4" name="VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"/>
        <enum value="5" name="VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"/>
        <enum value="6" name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"/>
        <enum value="7" name="VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"/>
        <enum value="8" name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"/>
        <enum value="9" name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"/>
        <enum value="10" name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"/>
        <enum value="11" name="VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"/>
        <enum value="12" name="VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"/>
        <enum value="13" name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"/>
        <enum value="14" name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"/>
        <enum value="15" name="VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"/>
        <enum value="16" name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"/>
        <enum value="17" name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"/>
        <enum value="18" name="VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"/>
        <enum value="19" name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"/>
        <enum value="20" name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"/>
        <enum value="21" name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"/>
        <enum value="22" name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"/>
        <enum value="23" name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"/>
        <enum value="24" name="VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"/>
        <enum value="25" name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"/>
        <enum value="26" name="VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"/>
        <enum value="27" name="VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"/>
        <enum value="28" name="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT"/>
        <enum value="29" name="VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT"/>
        <enum value="30" name="VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT"/>
        <enum value="31" name="VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT"/>
        <enum value="32" name="VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT"/>
    </enums>
    <enums name="VkDebugReportErrorEXT" type="enum">
        <enum value="0" name="VK_DEBUG_REPORT_ERROR_NONE_EXT"/>         <!-- Used for INFO & other non-error messages -->
        <enum value="1" name="VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT"/> <!-- Callbacks were not destroyed prior to calling DestroyInstance -->
    </enums>
    <enums name="VkRasterizationOrderAMD" type="enum">
        <enum value="0" name="VK_RASTERIZATION_ORDER_STRICT_AMD"/>      <!-- Rasterization order strictly follows API order -->
        <enum value="1" name="VK_RASTERIZATION_ORDER_RELAXED_AMD"/>     <!-- Rasterization order may not follow API order -->
    </enums>
    <enums name="VkExternalMemoryHandleTypeFlagBitsNV" type="bitmask">
        <enum bitpos="0" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"/>
        <enum bitpos="1" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"/>
        <enum bitpos="2" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"/>
        <enum bitpos="3" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"/>
    </enums>
    <enums name="VkExternalMemoryFeatureFlagBitsNV" type="bitmask">
        <enum bitpos="0" name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV"/>
        <enum bitpos="1" name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV"/>
        <enum bitpos="2" name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV"/>
    </enums>
    <enums name="VkValidationCheckEXT" type="enum">
        <enum value="0" name="VK_VALIDATION_CHECK_ALL_EXT"/>
        <!-- Placeholder for validation enums to be defined for VK_EXT_Validation_flags extension -->
    </enums>
    <enums name="VkIndirectCommandsLayoutUsageFlagBitsNVX" type="bitmask">
        <enum bitpos="0" name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX"/> <!-- sequences can be processed in implementation-dependent order -->
        <enum bitpos="1" name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX"/>    <!-- likely generated with a high difference in actual sequencesCount and maxSequencesCount -->
        <enum bitpos="2" name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX"/>    <!-- likely to contain draw/dispatch calls that are zero-sized -->
        <enum bitpos="3" name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX"/>   <!-- custom sequence index permutation (32-bit) is provided -->
    </enums>
    <enums name="VkObjectEntryUsageFlagBitsNVX" type="bitmask">
        <enum bitpos="0" name="VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX"/>
        <enum bitpos="1" name="VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX"/>
    </enums>
    <enums name="VkIndirectCommandsTokenTypeNVX" type="enum">
        <enum value="0" name="VK_INDIRECT_COMMANDS_TOKEN_PIPELINE_NVX"/>        <!-- array of 32bit tableEntry in the object table -->
        <enum value="1" name="VK_INDIRECT_COMMANDS_TOKEN_DESCRIPTOR_SET_NVX"/>  <!-- array of (32 bit tableEntry + variable count 32bit offsets) -->
        <enum value="2" name="VK_INDIRECT_COMMANDS_TOKEN_INDEX_BUFFER_NVX"/>    <!-- array of (32 bit tableEntry + optional 32bit offset) -->
        <enum value="3" name="VK_INDIRECT_COMMANDS_TOKEN_VERTEX_BUFFER_NVX"/>   <!-- array of (32 bit tableEntry + optional 32bit offset) -->
        <enum value="4" name="VK_INDIRECT_COMMANDS_TOKEN_PUSH_CONSTANT_NVX"/>   <!-- array of (32 bit tableEntry + variable count 32bit values ) -->
        <enum value="5" name="VK_INDIRECT_COMMANDS_TOKEN_DRAW_INDEXED_NVX"/>    <!-- array of VkDrawIndexedIndirectCommand -->
        <enum value="6" name="VK_INDIRECT_COMMANDS_TOKEN_DRAW_NVX"/>            <!-- array of VkDrawIndirectCommand -->
        <enum value="7" name="VK_INDIRECT_COMMANDS_TOKEN_DISPATCH_NVX"/>        <!-- array of VkDispatchIndirectCommand -->
    </enums>
    <enums name="VkObjectEntryTypeNVX" type="enum">
        <enum value="0" name="VK_OBJECT_ENTRY_DESCRIPTOR_SET_NVX"/>
        <enum value="1" name="VK_OBJECT_ENTRY_PIPELINE_NVX"/>
        <enum value="2" name="VK_OBJECT_ENTRY_INDEX_BUFFER_NVX"/>
        <enum value="3" name="VK_OBJECT_ENTRY_VERTEX_BUFFER_NVX"/>
        <enum value="4" name="VK_OBJECT_ENTRY_PUSH_CONSTANT_NVX"/>
    </enums>
    <!-- SECTION: Vulkan command definitions -->
    <commands>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INCOMPATIBLE_DRIVER">
            <proto><type>VkResult</type> <name>vkCreateInstance</name></proto>
            <param>const <type>VkInstanceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkInstance</type>* <name>pInstance</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyInstance</name></proto>
            <param optional="true" externsync="true"><type>VkInstance</type> <name>instance</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDevices</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPhysicalDeviceCount</name></param>
            <param optional="true" len="pPhysicalDeviceCount"><type>VkPhysicalDevice</type>* <name>pPhysicalDevices</name></param>
        </command>
        <command>
            <proto><type>PFN_vkVoidFunction</type> <name>vkGetDeviceProcAddr</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pName</name></param>
        </command>
        <command>
            <proto><type>PFN_vkVoidFunction</type> <name>vkGetInstanceProcAddr</name></proto>
            <param optional="true"><type>VkInstance</type> <name>instance</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pName</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceProperties</type>* <name>pProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pQueueFamilyPropertyCount</name></param>
            <param optional="true" len="pQueueFamilyPropertyCount"><type>VkQueueFamilyProperties</type>* <name>pQueueFamilyProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceMemoryProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceMemoryProperties</type>* <name>pMemoryProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceFeatures</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceFeatures</type>* <name>pFeatures</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkFormatProperties</type>* <name>pFormatProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceImageFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageType</type> <name>type</name></param>
            <param><type>VkImageTiling</type> <name>tiling</name></param>
            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
            <param optional="true"><type>VkImageCreateFlags</type> <name>flags</name></param>
            <param><type>VkImageFormatProperties</type>* <name>pImageFormatProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkCreateDevice</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkDeviceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDevice</type>* <name>pDevice</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDevice</name></proto>
            <param optional="true" externsync="true"><type>VkDevice</type> <name>device</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkEnumerateInstanceLayerProperties</name></proto>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT">
            <proto><type>VkResult</type> <name>vkEnumerateInstanceExtensionProperties</name></proto>
            <param optional="true" len="null-terminated">const <type>char</type>* <name>pLayerName</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkExtensionProperties</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkEnumerateDeviceLayerProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT">
            <proto><type>VkResult</type> <name>vkEnumerateDeviceExtensionProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="true" len="null-terminated">const <type>char</type>* <name>pLayerName</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkExtensionProperties</type>* <name>pProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDeviceQueue</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>uint32_t</type> <name>queueIndex</name></param>
            <param><type>VkQueue</type>* <name>pQueue</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkQueueSubmit</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param optional="true"><type>uint32_t</type> <name>submitCount</name></param>
            <param len="submitCount" externsync="pSubmits[].pWaitSemaphores[],pSubmits[].pSignalSemaphores[]">const <type>VkSubmitInfo</type>* <name>pSubmits</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkQueueWaitIdle</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkDeviceWaitIdle</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <implicitexternsyncparams>
                <param>all sname:VkQueue objects created from pname:device</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_TOO_MANY_OBJECTS">
            <proto><type>VkResult</type> <name>vkAllocateMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryAllocateInfo</type>* <name>pAllocateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDeviceMemory</type>* <name>pMemory</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkFreeMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED">
            <proto><type>VkResult</type> <name>vkMapMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkDeviceSize</type> <name>size</name></param>
            <param optional="true"><type>VkMemoryMapFlags</type> <name>flags</name></param>
            <param><type>void</type>** <name>ppData</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkUnmapMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkFlushMappedMemoryRanges</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>memoryRangeCount</name></param>
            <param len="memoryRangeCount">const <type>VkMappedMemoryRange</type>* <name>pMemoryRanges</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkInvalidateMappedMemoryRanges</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>memoryRangeCount</name></param>
            <param len="memoryRangeCount">const <type>VkMappedMemoryRange</type>* <name>pMemoryRanges</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDeviceMemoryCommitment</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type>* <name>pCommittedMemoryInBytes</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetBufferMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkBindBufferMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type> <name>memoryOffset</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetImageMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkBindImageMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkImage</type> <name>image</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type> <name>memoryOffset</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetImageSparseMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSparseMemoryRequirementCount</name></param>
            <param optional="true" len="pSparseMemoryRequirementCount"><type>VkSparseImageMemoryRequirements</type>* <name>pSparseMemoryRequirements</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceSparseImageFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageType</type> <name>type</name></param>
            <param><type>VkSampleCountFlagBits</type> <name>samples</name></param>
            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
            <param><type>VkImageTiling</type> <name>tiling</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkSparseImageFormatProperties</type>* <name>pProperties</name></param>
        </command>
        <command queues="sparse_binding" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkQueueBindSparse</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param optional="true"><type>uint32_t</type> <name>bindInfoCount</name></param>
            <param len="bindInfoCount" externsync="pBindInfo[].pWaitSemaphores[],pBindInfo[].pSignalSemaphores[],pBindInfo[].pBufferBinds[].buffer,pBindInfo[].pImageOpaqueBinds[].image,pBindInfo[].pImageBinds[].image">const <type>VkBindSparseInfo</type>* <name>pBindInfo</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateFence</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFenceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkFence</type>* <name>pFence</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyFence</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetFences</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>fenceCount</name></param>
            <param len="fenceCount" externsync="true">const <type>VkFence</type>* <name>pFences</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkGetFenceStatus</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkFence</type> <name>fence</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_TIMEOUT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkWaitForFences</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>fenceCount</name></param>
            <param len="fenceCount">const <type>VkFence</type>* <name>pFences</name></param>
            <param><type>VkBool32</type> <name>waitAll</name></param>
            <param><type>uint64_t</type> <name>timeout</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateSemaphore</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSemaphore</type>* <name>pSemaphore</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySemaphore</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkEventCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkEvent</type>* <name>pEvent</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkEvent</type> <name>event</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_EVENT_SET,VK_EVENT_RESET" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkGetEventStatus</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkSetEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkEvent</type> <name>event</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkEvent</type> <name>event</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateQueryPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkQueryPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkQueryPool</type>* <name>pQueryPool</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyQueryPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkQueryPool</type> <name>queryPool</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkGetQueryPoolResults</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
            <param><type>size_t</type> <name>dataSize</name></param>
            <param len="dataSize"><type>void</type>* <name>pData</name></param>
            <param><type>VkDeviceSize</type> <name>stride</name></param>
            <param optional="true"><type>VkQueryResultFlags</type> <name>flags</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateBuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkBuffer</type>* <name>pBuffer</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyBuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkBuffer</type> <name>buffer</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateBufferView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferViewCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkBufferView</type>* <name>pView</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyBufferView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkBufferView</type> <name>bufferView</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateImage</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkImage</type>* <name>pImage</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyImage</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkImage</type> <name>image</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetImageSubresourceLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param>const <type>VkImageSubresource</type>* <name>pSubresource</name></param>
            <param><type>VkSubresourceLayout</type>* <name>pLayout</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateImageView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageViewCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkImageView</type>* <name>pView</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyImageView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkImageView</type> <name>imageView</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
            <proto><type>VkResult</type> <name>vkCreateShaderModule</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkShaderModuleCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkShaderModule</type>* <name>pShaderModule</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyShaderModule</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkShaderModule</type> <name>shaderModule</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreatePipelineCache</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineCacheCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkPipelineCache</type>* <name>pPipelineCache</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyPipelineCache</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPipelineCacheData</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkMergePipelineCaches</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkPipelineCache</type> <name>dstCache</name></param>
            <param><type>uint32_t</type> <name>srcCacheCount</name></param>
            <param len="srcCacheCount">const <type>VkPipelineCache</type>* <name>pSrcCaches</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
            <proto><type>VkResult</type> <name>vkCreateGraphicsPipelines</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkGraphicsPipelineCreateInfo</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
            <proto><type>VkResult</type> <name>vkCreateComputePipelines</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkComputePipelineCreateInfo</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyPipeline</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPipeline</type> <name>pipeline</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreatePipelineLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkPipelineLayout</type>* <name>pPipelineLayout</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyPipelineLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPipelineLayout</type> <name>pipelineLayout</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_TOO_MANY_OBJECTS">
            <proto><type>VkResult</type> <name>vkCreateSampler</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSamplerCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSampler</type>* <name>pSampler</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySampler</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSampler</type> <name>sampler</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateDescriptorSetLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorSetLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDescriptorSetLayout</type>* <name>pSetLayout</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDescriptorSetLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDescriptorSetLayout</type> <name>descriptorSetLayout</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDescriptorPool</type>* <name>pDescriptorPool</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param optional="true"><type>VkDescriptorPoolResetFlags</type> <name>flags</name></param>
            <implicitexternsyncparams>
                <param>any sname:VkDescriptorSet objects allocated from pname:descriptorPool</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FRAGMENTED_POOL">
            <proto><type>VkResult</type> <name>vkAllocateDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pAllocateInfo::descriptorPool">const <type>VkDescriptorSetAllocateInfo</type>* <name>pAllocateInfo</name></param>
            <param len="pAllocateInfo::descriptorSetCount"><type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkFreeDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param><type>uint32_t</type> <name>descriptorSetCount</name></param>
            <param noautovalidity="true" externsync="true" len="descriptorSetCount">const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkUpdateDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>uint32_t</type> <name>descriptorWriteCount</name></param>
            <param len="descriptorWriteCount" externsync="pDescriptorWrites[].dstSet">const <type>VkWriteDescriptorSet</type>* <name>pDescriptorWrites</name></param>
            <param optional="true"><type>uint32_t</type> <name>descriptorCopyCount</name></param>
            <param len="descriptorCopyCount" externsync="pDescriptorCopies[].dstSet">const <type>VkCopyDescriptorSet</type>* <name>pDescriptorCopies</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateFramebuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFramebufferCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkFramebuffer</type>* <name>pFramebuffer</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyFramebuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkFramebuffer</type> <name>framebuffer</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateRenderPass</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkRenderPassCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkRenderPass</type>* <name>pRenderPass</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyRenderPass</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkRenderPass</type> <name>renderPass</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetRenderAreaGranularity</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkRenderPass</type> <name>renderPass</name></param>
            <param><type>VkExtent2D</type>* <name>pGranularity</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCommandPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkCommandPool</type>* <name>pCommandPool</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param optional="true"><type>VkCommandPoolResetFlags</type> <name>flags</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkAllocateCommandBuffers</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pAllocateInfo::commandPool">const <type>VkCommandBufferAllocateInfo</type>* <name>pAllocateInfo</name></param>
            <param len="pAllocateInfo::commandBufferCount"><type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkFreeCommandBuffers</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param><type>uint32_t</type> <name>commandBufferCount</name></param>
            <param noautovalidity="true" externsync="true" len="commandBufferCount">const <type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkBeginCommandBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCommandBufferBeginInfo</type>* <name>pBeginInfo</name></param>
            <implicitexternsyncparams>
                <param>the sname:VkCommandPool that pname:commandBuffer was allocated from</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkEndCommandBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <implicitexternsyncparams>
                <param>the sname:VkCommandPool that pname:commandBuffer was allocated from</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetCommandBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>VkCommandBufferResetFlags</type> <name>flags</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindPipeline</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetViewport</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstViewport</name></param>
            <param><type>uint32_t</type> <name>viewportCount</name></param>
            <param len="viewportCount" noautovalidity="true">const <type>VkViewport</type>* <name>pViewports</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetScissor</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstScissor</name></param>
            <param><type>uint32_t</type> <name>scissorCount</name></param>
            <param len="scissorCount">const <type>VkRect2D</type>* <name>pScissors</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetLineWidth</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>float</type> <name>lineWidth</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetDepthBias</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>float</type> <name>depthBiasConstantFactor</name></param>
            <param><type>float</type> <name>depthBiasClamp</name></param>
            <param><type>float</type> <name>depthBiasSlopeFactor</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetBlendConstants</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>float</type> <name>blendConstants</name>[4]</param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetDepthBounds</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>float</type> <name>minDepthBounds</name></param>
            <param><type>float</type> <name>maxDepthBounds</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetStencilCompareMask</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
            <param><type>uint32_t</type> <name>compareMask</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetStencilWriteMask</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
            <param><type>uint32_t</type> <name>writeMask</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetStencilReference</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
            <param><type>uint32_t</type> <name>reference</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindDescriptorSets</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>uint32_t</type> <name>firstSet</name></param>
            <param><type>uint32_t</type> <name>descriptorSetCount</name></param>
            <param len="descriptorSetCount">const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
            <param optional="true"><type>uint32_t</type> <name>dynamicOffsetCount</name></param>
            <param len="dynamicOffsetCount">const <type>uint32_t</type>* <name>pDynamicOffsets</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindIndexBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkIndexType</type> <name>indexType</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindVertexBuffers</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstBinding</name></param>
            <param><type>uint32_t</type> <name>bindingCount</name></param>
            <param len="bindingCount">const <type>VkBuffer</type>* <name>pBuffers</name></param>
            <param len="bindingCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDraw</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>vertexCount</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
            <param><type>uint32_t</type> <name>firstVertex</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawIndexed</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>indexCount</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
            <param><type>uint32_t</type> <name>firstIndex</name></param>
            <param><type>int32_t</type> <name>vertexOffset</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawIndirect</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>drawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawIndexedIndirect</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>drawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="compute">
            <proto><type>void</type> <name>vkCmdDispatch</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>x</name></param>
            <param><type>uint32_t</type> <name>y</name></param>
            <param><type>uint32_t</type> <name>z</name></param>
        </command>
        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="compute">
            <proto><type>void</type> <name>vkCmdDispatchIndirect</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdCopyBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkBufferCopy</type>* <name>pRegions</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdCopyImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkImageCopy</type>* <name>pRegions</name></param>
        </command>
        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdBlitImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkImageBlit</type>* <name>pRegions</name></param>
            <param><type>VkFilter</type> <name>filter</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdCopyBufferToImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdCopyImageToBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdUpdateBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>VkDeviceSize</type> <name>dataSize</name></param>
            <param len="dataSize">const <type>void</type>* <name>pData</name></param>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdFillBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>VkDeviceSize</type> <name>size</name></param>
            <param><type>uint32_t</type> <name>data</name></param>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdClearColorImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
            <param>const <type>VkClearColorValue</type>* <name>pColor</name></param>
            <param><type>uint32_t</type> <name>rangeCount</name></param>
            <param len="rangeCount">const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
        </command>
        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdClearDepthStencilImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
            <param>const <type>VkClearDepthStencilValue</type>* <name>pDepthStencil</name></param>
            <param><type>uint32_t</type> <name>rangeCount</name></param>
            <param len="rangeCount">const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdClearAttachments</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>attachmentCount</name></param>
            <param len="attachmentCount">const <type>VkClearAttachment</type>* <name>pAttachments</name></param>
            <param><type>uint32_t</type> <name>rectCount</name></param>
            <param len="rectCount">const <type>VkClearRect</type>* <name>pRects</name></param>
        </command>
        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdResolveImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkImageResolve</type>* <name>pRegions</name></param>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetEvent</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
            <param><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdResetEvent</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
            <param><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdWaitEvents</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>eventCount</name></param>
            <param len="eventCount">const <type>VkEvent</type>* <name>pEvents</name></param>
            <param><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
            <param><type>VkPipelineStageFlags</type> <name>dstStageMask</name></param>
            <param optional="true"><type>uint32_t</type> <name>memoryBarrierCount</name></param>
            <param len="memoryBarrierCount">const <type>VkMemoryBarrier</type>* <name>pMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>bufferMemoryBarrierCount</name></param>
            <param len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier</type>* <name>pBufferMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>imageMemoryBarrierCount</name></param>
            <param len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier</type>* <name>pImageMemoryBarriers</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdPipelineBarrier</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
            <param><type>VkPipelineStageFlags</type> <name>dstStageMask</name></param>
            <param optional="true"><type>VkDependencyFlags</type> <name>dependencyFlags</name></param>
            <param optional="true"><type>uint32_t</type> <name>memoryBarrierCount</name></param>
            <param len="memoryBarrierCount">const <type>VkMemoryBarrier</type>* <name>pMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>bufferMemoryBarrierCount</name></param>
            <param len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier</type>* <name>pBufferMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>imageMemoryBarrierCount</name></param>
            <param len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier</type>* <name>pImageMemoryBarriers</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBeginQuery</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
            <param optional="true"><type>VkQueryControlFlags</type> <name>flags</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdEndQuery</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdResetQueryPool</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdWriteTimestamp</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineStageFlagBits</type> <name>pipelineStage</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" pipeline="transfer">
            <proto><type>void</type> <name>vkCmdCopyQueryPoolResults</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>VkDeviceSize</type> <name>stride</name></param>
            <param optional="true"><type>VkQueryResultFlags</type> <name>flags</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdPushConstants</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>VkShaderStageFlags</type> <name>stageFlags</name></param>
            <param><type>uint32_t</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>size</name></param>
            <param len="size">const <type>void</type>* <name>pValues</name></param>
        </command>
        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdBeginRenderPass</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkRenderPassBeginInfo</type>* <name>pRenderPassBegin</name></param>
            <param><type>VkSubpassContents</type> <name>contents</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdNextSubpass</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkSubpassContents</type> <name>contents</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdEndRenderPass</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
        </command>
        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary">
            <proto><type>void</type> <name>vkCmdExecuteCommands</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>commandBufferCount</name></param>
            <param len="commandBufferCount">const <type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
            <proto><type>VkResult</type> <name>vkCreateAndroidSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkAndroidSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayPropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayPlanePropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetDisplayPlaneSupportedDisplaysKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>planeIndex</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pDisplayCount</name></param>
            <param optional="true" len="pDisplayCount"><type>VkDisplayKHR</type>* <name>pDisplays</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetDisplayModePropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayModePropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDisplayModeKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param externsync="true"><type>VkDisplayKHR</type> <name>display</name></param>
            <param>const <type>VkDisplayModeCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDisplayModeKHR</type>* <name>pMode</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetDisplayPlaneCapabilitiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param externsync="true"><type>VkDisplayModeKHR</type> <name>mode</name></param>
            <param><type>uint32_t</type> <name>planeIndex</name></param>
            <param><type>VkDisplayPlaneCapabilitiesKHR</type>* <name>pCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateDisplayPlaneSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkDisplaySurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkCreateSharedSwapchainsKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>swapchainCount</name></param>
            <param len="swapchainCount" externsync="pCreateInfos[].surface,pCreateInfos[].oldSwapchain">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="swapchainCount"><type>VkSwapchainKHR</type>* <name>pSwapchains</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateMirSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkMirSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceMirPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>MirConnection</type>* <name>connection</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param optional="true" externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param><type>VkBool32</type>* <name>pSupported</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param><type>VkSurfaceCapabilitiesKHR</type>* <name>pSurfaceCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceFormatsKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSurfaceFormatCount</name></param>
            <param optional="true" len="pSurfaceFormatCount"><type>VkSurfaceFormatKHR</type>* <name>pSurfaceFormats</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfacePresentModesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPresentModeCount</name></param>
            <param optional="true" len="pPresentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
            <proto><type>VkResult</type> <name>vkCreateSwapchainKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pCreateInfo.surface,pCreateInfo.oldSwapchain">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSwapchainKHR</type>* <name>pSwapchain</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySwapchainKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetSwapchainImagesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSwapchainImageCount</name></param>
            <param optional="true" len="pSwapchainImageCount"><type>VkImage</type>* <name>pSwapchainImages</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkAcquireNextImageKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param><type>uint64_t</type> <name>timeout</name></param>
            <param optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
            <param><type>uint32_t</type>* <name>pImageIndex</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkQueuePresentKHR</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param externsync="pPresentInfo.pWaitSemaphores[],pPresentInfo.pSwapchains[]">const <type>VkPresentInfoKHR</type>* <name>pPresentInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateWaylandSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkWaylandSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceWaylandPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param>struct <type>wl_display</type>* <name>display</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateWin32SurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkWin32SurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceWin32PresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateXlibSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkXlibSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceXlibPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>Display</type>* <name>dpy</name></param>
            <param><type>VisualID</type> <name>visualID</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateXcbSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkXcbSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceXcbPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>xcb_connection_t</type>* <name>connection</name></param>
            <param><type>xcb_visualid_t</type> <name>visual_id</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateDebugReportCallbackEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkDebugReportCallbackCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDebugReportCallbackEXT</type>* <name>pCallback</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDebugReportCallbackEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param externsync="true"><type>VkDebugReportCallbackEXT</type> <name>callback</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDebugReportMessageEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param><type>VkDebugReportFlagsEXT</type> <name>flags</name></param>
            <param><type>VkDebugReportObjectTypeEXT</type> <name>objectType</name></param>
            <param><type>uint64_t</type> <name>object</name></param>
            <param><type>size_t</type> <name>location</name></param>
            <param><type>int32_t</type> <name>messageCode</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pLayerPrefix</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pMessage</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkDebugMarkerSetObjectNameEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pNameInfo.object"><type>VkDebugMarkerObjectNameInfoEXT</type>* <name>pNameInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkDebugMarkerSetObjectTagEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pTagInfo.object"><type>VkDebugMarkerObjectTagInfoEXT</type>* <name>pTagInfo</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDebugMarkerBeginEXT</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkDebugMarkerMarkerInfoEXT</type>* <name>pMarkerInfo</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDebugMarkerEndEXT</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDebugMarkerInsertEXT</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkDebugMarkerMarkerInfoEXT</type>* <name>pMarkerInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageType</type> <name>type</name></param>
            <param><type>VkImageTiling</type> <name>tiling</name></param>
            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
            <param optional="true"><type>VkImageCreateFlags</type> <name>flags</name></param>
            <param optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>externalHandleType</name></param>
            <param><type>VkExternalImageFormatPropertiesNV</type>* <name>pExternalImageFormatProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
            <proto><type>VkResult</type> <name>vkGetMemoryWin32HandleNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleType</name></param>
            <param><type>HANDLE</type>* <name>pHandle</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawIndirectCountAMD</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkBuffer</type> <name>countBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary" pipeline="graphics">
            <proto><type>void</type> <name>vkCmdDrawIndexedIndirectCountAMD</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkBuffer</type> <name>countBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command queues="graphics,compute" renderpass="inside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdProcessCommandsNVX</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCmdProcessCommandsInfoNVX</type>* <name>pProcessCommandsInfo</name></param>
        </command>
        <command queues="graphics,compute" renderpass="inside" cmdbufferlevel="secondary">
            <proto><type>void</type> <name>vkCmdReserveSpaceForCommandsNVX</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCmdReserveSpaceForCommandsInfoNVX</type>* <name>pReserveSpaceInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateIndirectCommandsLayoutNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkIndirectCommandsLayoutCreateInfoNVX</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkIndirectCommandsLayoutNVX</type>* <name>pIndirectCommandsLayout</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyIndirectCommandsLayoutNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkIndirectCommandsLayoutNVX</type> <name>indirectCommandsLayout</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateObjectTableNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkObjectTableCreateInfoNVX</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkObjectTableNVX</type>* <name>pObjectTable</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyObjectTableNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkObjectTableNVX</type> <name>objectTable</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkRegisterObjectsNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkObjectTableNVX</type> <name>objectTable</name></param>
            <param><type>uint32_t</type> <name>objectCount</name></param>
            <param len="objectCount">const <type>VkObjectTableEntryNVX</type>* const*    <name>ppObjectTableEntries</name></param>
            <param len="objectCount">const <type>uint32_t</type>* <name>pObjectIndices</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkUnregisterObjectsNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkObjectTableNVX</type> <name>objectTable</name></param>
            <param><type>uint32_t</type> <name>objectCount</name></param>
            <param len="objectCount">const <type>VkObjectEntryTypeNVX</type>* <name>pObjectEntryTypes</name></param>
            <param len="objectCount">const <type>uint32_t</type>* <name>pObjectIndices</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkDeviceGeneratedCommandsFeaturesNVX</type>* <name>pFeatures</name></param>
            <param><type>VkDeviceGeneratedCommandsLimitsNVX</type>* <name>pLimits</name></param>
        </command>
    </commands>

    <!-- SECTION: Vulkan API interface definitions -->
    <feature api="vulkan" name="VK_VERSION_1_0" number="1.0">
        <require comment="Header boilerplate">
            <type name="vk_platform"/>
        </require>
        <require comment="API version">
            <type name="VK_API_VERSION"/>
            <type name="VK_API_VERSION_1_0"/>
            <type name="VK_VERSION_MAJOR"/>
            <type name="VK_VERSION_MINOR"/>
            <type name="VK_VERSION_PATCH"/>
            <type name="VK_HEADER_VERSION"/>
        </require>
        <require comment="API constants">
            <enum name="VK_LOD_CLAMP_NONE"/>
            <enum name="VK_REMAINING_MIP_LEVELS"/>
            <enum name="VK_REMAINING_ARRAY_LAYERS"/>
            <enum name="VK_WHOLE_SIZE"/>
            <enum name="VK_ATTACHMENT_UNUSED"/>
            <enum name="VK_TRUE"/>
            <enum name="VK_FALSE"/>
            <type name="VK_NULL_HANDLE"/>
            <enum name="VK_QUEUE_FAMILY_IGNORED"/>
            <enum name="VK_SUBPASS_EXTERNAL"/>
            <type name="VkPipelineCacheHeaderVersion"/>
        </require>
        <require comment="Device initialization">
            <command name="vkCreateInstance"/>
            <command name="vkDestroyInstance"/>
            <command name="vkEnumeratePhysicalDevices"/>
            <command name="vkGetPhysicalDeviceFeatures"/>
            <command name="vkGetPhysicalDeviceFormatProperties"/>
            <command name="vkGetPhysicalDeviceImageFormatProperties"/>
            <command name="vkGetPhysicalDeviceProperties"/>
            <command name="vkGetPhysicalDeviceQueueFamilyProperties"/>
            <command name="vkGetPhysicalDeviceMemoryProperties"/>
            <command name="vkGetInstanceProcAddr"/>
            <command name="vkGetDeviceProcAddr"/>
        </require>
        <require comment="Device commands">
            <command name="vkCreateDevice"/>
            <command name="vkDestroyDevice"/>
        </require>
        <require comment="Extension discovery commands">
            <command name="vkEnumerateInstanceExtensionProperties"/>
            <command name="vkEnumerateDeviceExtensionProperties"/>
        </require>
        <require comment="Layer discovery commands">
            <command name="vkEnumerateInstanceLayerProperties"/>
            <command name="vkEnumerateDeviceLayerProperties"/>
        </require>
        <require comment="queue commands">
            <command name="vkGetDeviceQueue"/>
            <command name="vkQueueSubmit"/>
            <command name="vkQueueWaitIdle"/>
            <command name="vkDeviceWaitIdle"/>
        </require>
        <require comment="Memory commands">
            <command name="vkAllocateMemory"/>
            <command name="vkFreeMemory"/>
            <command name="vkMapMemory"/>
            <command name="vkUnmapMemory"/>
            <command name="vkFlushMappedMemoryRanges"/>
            <command name="vkInvalidateMappedMemoryRanges"/>
            <command name="vkGetDeviceMemoryCommitment"/>
        </require>
        <require comment="Memory management API commands">
            <command name="vkBindBufferMemory"/>
            <command name="vkBindImageMemory"/>
            <command name="vkGetBufferMemoryRequirements"/>
            <command name="vkGetImageMemoryRequirements"/>
        </require>
        <require comment="Sparse resource memory management API commands">
            <command name="vkGetImageSparseMemoryRequirements"/>
            <command name="vkGetPhysicalDeviceSparseImageFormatProperties"/>
            <command name="vkQueueBindSparse"/>
        </require>
        <require comment="Fence commands">
            <command name="vkCreateFence"/>
            <command name="vkDestroyFence"/>
            <command name="vkResetFences"/>
            <command name="vkGetFenceStatus"/>
            <command name="vkWaitForFences"/>
        </require>
        <require comment="Queue semaphore commands">
            <command name="vkCreateSemaphore"/>
            <command name="vkDestroySemaphore"/>
        </require>
        <require comment="Event commands">
            <command name="vkCreateEvent"/>
            <command name="vkDestroyEvent"/>
            <command name="vkGetEventStatus"/>
            <command name="vkSetEvent"/>
            <command name="vkResetEvent"/>
        </require>
        <require comment="Query commands">
            <command name="vkCreateQueryPool"/>
            <command name="vkDestroyQueryPool"/>
            <command name="vkGetQueryPoolResults"/>
        </require>
        <require comment="Buffer commands">
            <command name="vkCreateBuffer"/>
            <command name="vkDestroyBuffer"/>
        </require>
        <require comment="Buffer view commands">
            <command name="vkCreateBufferView"/>
            <command name="vkDestroyBufferView"/>
        </require>
        <require comment="Image commands">
            <command name="vkCreateImage"/>
            <command name="vkDestroyImage"/>
            <command name="vkGetImageSubresourceLayout"/>
        </require>
        <require comment="Image view commands">
            <command name="vkCreateImageView"/>
            <command name="vkDestroyImageView"/>
        </require>
        <require comment="Shader commands">
            <command name="vkCreateShaderModule"/>
            <command name="vkDestroyShaderModule"/>
        </require>
        <require comment="Pipeline Cache commands">
            <command name="vkCreatePipelineCache"/>
            <command name="vkDestroyPipelineCache"/>
            <command name="vkGetPipelineCacheData"/>
            <command name="vkMergePipelineCaches"/>
        </require>
        <require comment="Pipeline commands">
            <command name="vkCreateGraphicsPipelines"/>
            <command name="vkCreateComputePipelines"/>
            <command name="vkDestroyPipeline"/>
        </require>
        <require comment="Pipeline layout commands">
            <command name="vkCreatePipelineLayout"/>
            <command name="vkDestroyPipelineLayout"/>
        </require>
        <require comment="Sampler commands">
            <command name="vkCreateSampler"/>
            <command name="vkDestroySampler"/>
        </require>
        <require comment="Descriptor set commands">
            <command name="vkCreateDescriptorSetLayout"/>
            <command name="vkDestroyDescriptorSetLayout"/>
            <command name="vkCreateDescriptorPool"/>
            <command name="vkDestroyDescriptorPool"/>
            <command name="vkResetDescriptorPool"/>
            <command name="vkAllocateDescriptorSets"/>
            <command name="vkFreeDescriptorSets"/>
            <command name="vkUpdateDescriptorSets"/>
        </require>
        <require comment="Pass commands">
            <command name="vkCreateFramebuffer"/>
            <command name="vkDestroyFramebuffer"/>
            <command name="vkCreateRenderPass"/>
            <command name="vkDestroyRenderPass"/>
            <command name="vkGetRenderAreaGranularity"/>
        </require>
        <require comment="Command pool commands">
            <command name="vkCreateCommandPool"/>
            <command name="vkDestroyCommandPool"/>
            <command name="vkResetCommandPool"/>
        </require>
        <require comment="Command buffer commands">
            <command name="vkAllocateCommandBuffers"/>
            <command name="vkFreeCommandBuffers"/>
            <command name="vkBeginCommandBuffer"/>
            <command name="vkEndCommandBuffer"/>
            <command name="vkResetCommandBuffer"/>
        </require>
        <require comment="Command buffer building commands">
            <command name="vkCmdBindPipeline"/>
            <command name="vkCmdSetViewport"/>
            <command name="vkCmdSetScissor"/>
            <command name="vkCmdSetLineWidth"/>
            <command name="vkCmdSetDepthBias"/>
            <command name="vkCmdSetBlendConstants"/>
            <command name="vkCmdSetDepthBounds"/>
            <command name="vkCmdSetStencilCompareMask"/>
            <command name="vkCmdSetStencilWriteMask"/>
            <command name="vkCmdSetStencilReference"/>
            <command name="vkCmdBindDescriptorSets"/>
            <command name="vkCmdBindIndexBuffer"/>
            <command name="vkCmdBindVertexBuffers"/>
            <command name="vkCmdDraw"/>
            <command name="vkCmdDrawIndexed"/>
            <command name="vkCmdDrawIndirect"/>
            <command name="vkCmdDrawIndexedIndirect"/>
            <command name="vkCmdDispatch"/>
            <command name="vkCmdDispatchIndirect"/>
            <command name="vkCmdCopyBuffer"/>
            <command name="vkCmdCopyImage"/>
            <command name="vkCmdBlitImage"/>
            <command name="vkCmdCopyBufferToImage"/>
            <command name="vkCmdCopyImageToBuffer"/>
            <command name="vkCmdUpdateBuffer"/>
            <command name="vkCmdFillBuffer"/>
            <command name="vkCmdClearColorImage"/>
            <command name="vkCmdClearDepthStencilImage"/>
            <command name="vkCmdClearAttachments"/>
            <command name="vkCmdResolveImage"/>
            <command name="vkCmdSetEvent"/>
            <command name="vkCmdResetEvent"/>
            <command name="vkCmdWaitEvents"/>
            <command name="vkCmdPipelineBarrier"/>
            <command name="vkCmdBeginQuery"/>
            <command name="vkCmdEndQuery"/>
            <command name="vkCmdResetQueryPool"/>
            <command name="vkCmdWriteTimestamp"/>
            <command name="vkCmdCopyQueryPoolResults"/>
            <command name="vkCmdPushConstants"/>
            <command name="vkCmdBeginRenderPass"/>
            <command name="vkCmdNextSubpass"/>
            <command name="vkCmdEndRenderPass"/>
            <command name="vkCmdExecuteCommands"/>
        </require>
        <require comment="Types not directly used by the API">
            <!-- Include <type name="typename"/> here for e.g. structs that
                 are not parameter types of commands, but still need to be
                 defined in the API.
             -->
            <type name="VkBufferMemoryBarrier"/>
            <type name="VkDispatchIndirectCommand"/>
            <type name="VkDrawIndexedIndirectCommand"/>
            <type name="VkDrawIndirectCommand"/>
            <type name="VkImageMemoryBarrier"/>
            <type name="VkMemoryBarrier"/>
        </require>
    </feature>

    <!-- SECTION: Vulkan extension interface definitions -->
    <extensions>
            <!-- WSI extensions -->
        <extension name="VK_KHR_surface" number="1" type="instance" supported="vulkan">
            <require>
                <enum value="25"                                        name="VK_KHR_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_surface&quot;"                name="VK_KHR_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" dir="-" extends="VkResult"             name="VK_ERROR_SURFACE_LOST_KHR"/>
                <enum offset="1" dir="-" extends="VkResult"             name="VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"/>
                <enum value="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"         name="VK_COLORSPACE_SRGB_NONLINEAR_KHR"/>
                <command name="vkDestroySurfaceKHR"/>
                <command name="vkGetPhysicalDeviceSurfaceSupportKHR"/>
                <command name="vkGetPhysicalDeviceSurfaceCapabilitiesKHR"/>
                <command name="vkGetPhysicalDeviceSurfaceFormatsKHR"/>
                <command name="vkGetPhysicalDeviceSurfacePresentModesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_swapchain" number="2" type="device" requires="VK_KHR_surface" supported="vulkan">
            <require>
                <enum value="68"                                        name="VK_KHR_SWAPCHAIN_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_swapchain&quot;"              name="VK_KHR_SWAPCHAIN_EXTENSION_NAME"/>
                <enum offset="0"         extends="VkStructureType"      name="VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"/>
                <enum offset="1"         extends="VkStructureType"      name="VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"/>
                <enum offset="2"         extends="VkImageLayout"        name="VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"/>
                <enum offset="3"         extends="VkResult"             name="VK_SUBOPTIMAL_KHR"/>
                <enum offset="4" dir="-" extends="VkResult"             name="VK_ERROR_OUT_OF_DATE_KHR"/>
                <command name="vkCreateSwapchainKHR"/>
                <command name="vkDestroySwapchainKHR"/>
                <command name="vkGetSwapchainImagesKHR"/>
                <command name="vkAcquireNextImageKHR"/>
                <command name="vkQueuePresentKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_display" number="3" type="instance" requires="VK_KHR_surface" supported="vulkan">
            <require>
                <enum value="21"                                        name="VK_KHR_DISPLAY_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_display&quot;"                name="VK_KHR_DISPLAY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkDisplayPlaneAlphaFlagsKHR"/>
                <type name="VkDisplayPlaneAlphaFlagBitsKHR"/>
                <type name="VkDisplayPropertiesKHR"/>
                <type name="VkDisplayModeParametersKHR"/>
                <type name="VkDisplayModePropertiesKHR"/>
                <type name="VkDisplayModeCreateInfoKHR"/>
                <type name="VkDisplayPlaneCapabilitiesKHR"/>
                <type name="VkDisplayPlanePropertiesKHR"/>
                <type name="VkDisplaySurfaceCreateInfoKHR"/>
                <command name="vkGetPhysicalDeviceDisplayPropertiesKHR"/>
                <command name="vkGetPhysicalDeviceDisplayPlanePropertiesKHR"/>
                <command name="vkGetDisplayPlaneSupportedDisplaysKHR"/>
                <command name="vkGetDisplayModePropertiesKHR"/>
                <command name="vkCreateDisplayModeKHR"/>
                <command name="vkGetDisplayPlaneCapabilitiesKHR"/>
                <command name="vkCreateDisplayPlaneSurfaceKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_display_swapchain" number="4" type="device" requires="VK_KHR_swapchain,VK_KHR_display" supported="vulkan">
            <require>
                <enum value="9"                                         name="VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_display_swapchain&quot;"      name="VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"/>
                <enum offset="1" dir="-" extends="VkResult"             name="VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"/>
                <type name="VkDisplayPresentInfoKHR"/>
                <command name="vkCreateSharedSwapchainsKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_xlib_surface" number="5" type="instance" requires="VK_KHR_surface" protect="VK_USE_PLATFORM_XLIB_KHR" supported="vulkan">
            <require>
                <enum value="6"                                         name="VK_KHR_XLIB_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_xlib_surface&quot;"           name="VK_KHR_XLIB_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkXlibSurfaceCreateFlagsKHR"/>
                <type name="VkXlibSurfaceCreateInfoKHR"/>
                <command name="vkCreateXlibSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceXlibPresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_xcb_surface" number="6" type="instance" requires="VK_KHR_surface" protect="VK_USE_PLATFORM_XCB_KHR" supported="vulkan">
            <require>
                <enum value="6"                                         name="VK_KHR_XCB_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_xcb_surface&quot;"            name="VK_KHR_XCB_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkXcbSurfaceCreateFlagsKHR"/>
                <type name="VkXcbSurfaceCreateInfoKHR"/>
                <command name="vkCreateXcbSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceXcbPresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_wayland_surface" number="7" type="instance" requires="VK_KHR_surface" protect="VK_USE_PLATFORM_WAYLAND_KHR" supported="vulkan">
            <require>
                <enum value="5"                                         name="VK_KHR_WAYLAND_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_wayland_surface&quot;"        name="VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkWaylandSurfaceCreateFlagsKHR"/>
                <type name="VkWaylandSurfaceCreateInfoKHR"/>
                <command name="vkCreateWaylandSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceWaylandPresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_mir_surface" number="8" type="instance" requires="VK_KHR_surface" protect="VK_USE_PLATFORM_MIR_KHR" supported="vulkan">
            <require>
                <enum value="4"                                         name="VK_KHR_MIR_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_mir_surface&quot;"            name="VK_KHR_MIR_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkMirSurfaceCreateFlagsKHR"/>
                <type name="VkMirSurfaceCreateInfoKHR"/>
                <command name="vkCreateMirSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceMirPresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_android_surface" number="9" type="instance" requires="VK_KHR_surface" protect="VK_USE_PLATFORM_ANDROID_KHR" supported="vulkan">
            <require>
                <enum value="6"                                         name="VK_KHR_ANDROID_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_android_surface&quot;"        name="VK_KHR_ANDROID_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkAndroidSurfaceCreateFlagsKHR"/>
                <type name="VkAndroidSurfaceCreateInfoKHR"/>
                <command name="vkCreateAndroidSurfaceKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_win32_surface" number="10" type="instance" requires="VK_KHR_surface" protect="VK_USE_PLATFORM_WIN32_KHR" supported="vulkan">
            <require>
                <enum value="5"                                         name="VK_KHR_WIN32_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_win32_surface&quot;"          name="VK_KHR_WIN32_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkWin32SurfaceCreateFlagsKHR"/>
                <type name="VkWin32SurfaceCreateInfoKHR"/>
                <command name="vkCreateWin32SurfaceKHR"/>
                <command name="vkGetPhysicalDeviceWin32PresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_ANDROID_native_buffer" number="11" supported="disabled">
            <require>
                <enum value="4"                                         name="VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION"/>
                <enum value="11"                                        name="VK_ANDROID_NATIVE_BUFFER_NUMBER"/>
                <enum value="&quot;VK_ANDROID_native_buffer&quot;"      name="VK_ANDROID_NATIVE_BUFFER_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_debug_report" number="12" type="instance" author="Google, Inc." contact="Courtney Goeltzenleuchter @courtney" supported="vulkan">
            <require>
                <enum value="4"                                         name="VK_EXT_DEBUG_REPORT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_debug_report&quot;"           name="VK_EXT_DEBUG_REPORT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"/>
                <enum offset="1" dir="-" extends="VkResult"             name="VK_ERROR_VALIDATION_FAILED_EXT"/>
                <enum value="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT" name="VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT"/>
                <type name="VkDebugReportObjectTypeEXT"/>
                <type name="VkDebugReportErrorEXT"/>
                <command name="vkCreateDebugReportCallbackEXT"/>
                <command name="vkDestroyDebugReportCallbackEXT"/>
                <command name="vkDebugReportMessageEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_glsl_shader" number="13" type="device" author="NVIDIA" contact="Piers Daniell @pdaniell" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_GLSL_SHADER_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_glsl_shader&quot;"             name="VK_NV_GLSL_SHADER_EXTENSION_NAME"/>
                <enum offset="0" dir="-" extends="VkResult"             name="VK_ERROR_INVALID_SHADER_NV"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_1" number="14" author="NVIDIA" contact="Piers Daniell @pdaniell" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NV_EXTENSION_1_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_1&quot;"             name="VK_NV_EXTENSION_1_EXTENSION_NAME"/>
                <enum offset="0" dir="-" extends="VkResult"             name="VK_NV_EXTENSION_1_ERROR"/>
            </require>
        </extension>
        <extension name="VK_KHR_sampler_mirror_clamp_to_edge" type="device" number="15" author="KHR" contact="Tobias Hector @tobias" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_sampler_mirror_clamp_to_edge&quot;"             name="VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME"/>
                <enum value="4" extends="VkSamplerAddressMode"          name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" comment="Note that this defines what was previously a core enum, and so uses the 'value' attribute rather than 'offset', and does not have a suffix. This is a special case, and should not be repeated"/>
            </require>
        </extension>
        <extension name="VK_IMG_filter_cubic" number="16" type="device" author="IMG" contact="Tobias Hector @tobias" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_IMG_FILTER_CUBIC_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_filter_cubic&quot;"           name="VK_IMG_FILTER_CUBIC_EXTENSION_NAME"/>
                <enum offset="0" extends="VkFilter"                     name="VK_FILTER_CUBIC_IMG"/>
                <enum bitpos="13" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG" comment="Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_17" number="17" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_17_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_17&quot;"           name="VK_AMD_EXTENSION_17_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_18" number="18" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_18_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_18&quot;"           name="VK_AMD_EXTENSION_18_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_rasterization_order" number="19" type="device" author="AMD" contact="Daniel Rakos @aqnuep" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_rasterization_order&quot;"    name="VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"/>
                <type name="VkRasterizationOrderAMD"/>
                <type name="VkPipelineRasterizationStateRasterizationOrderAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_20" number="20" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_20_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_20&quot;"           name="VK_AMD_EXTENSION_20_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_trinary_minmax" number="21" type="device" author="AMD" contact="quentin.lin@amd.com" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_trinary_minmax&quot;"  name="VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_explicit_vertex_parameter" number="22" type="device" author="AMD" contact="quentin.lin@amd.com" supported="vulkan">
            <require>
                <enum value="1"                                                   name="VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_explicit_vertex_parameter&quot;" name="VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_debug_marker" number="23" type="device" author="Baldur Karlsson" contact="baldurk@baldurk.org" supported="vulkan">
            <require>
                <enum value="3"                                         name="VK_EXT_DEBUG_MARKER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_debug_marker&quot;"           name="VK_EXT_DEBUG_MARKER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"/>
                <type name="VkDebugMarkerObjectNameInfoEXT"/>
                <type name="VkDebugMarkerObjectTagInfoEXT"/>
                <type name="VkDebugMarkerMarkerInfoEXT"/>
                <command name="vkDebugMarkerSetObjectTagEXT"/>
                <command name="vkDebugMarkerSetObjectNameEXT"/>
                <command name="vkCmdDebugMarkerBeginEXT"/>
                <command name="vkCmdDebugMarkerEndEXT"/>
                <command name="vkCmdDebugMarkerInsertEXT"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_24" number="24" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_24_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_24&quot;"           name="VK_AMD_EXTENSION_24_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_25" number="25" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_25_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_25&quot;"           name="VK_AMD_EXTENSION_25_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_gcn_shader" number="26" type="device" author="AMD" contact="dominik.witczak@amd.com" supported="vulkan">
            <require>
                <enum value="1"                                        name="VK_AMD_GCN_SHADER_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_gcn_shader&quot;"            name="VK_AMD_GCN_SHADER_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_dedicated_allocation" number="27" type="device" author="NVIDIA" contact="Jeff Bolz @jbolz" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_dedicated_allocation&quot;" name="VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"/>
                <type name="VkDedicatedAllocationImageCreateInfoNV"/>
                <type name="VkDedicatedAllocationBufferCreateInfoNV"/>
                <type name="VkDedicatedAllocationMemoryAllocateInfoNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_28" number="28" author="NVIDIA" contact="Piers Daniell @pdaniell" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_28_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_28&quot;"            name="VK_EXT_EXTENSION_28_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NVX_extension_29" number="29" author="NVIDIA" contact="Jeff Juliano @jjuliano" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NVX_EXTENSION_29_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_extension_29&quot;"           name="VK_NVX_EXTENSION_29_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NVX_extension_30" number="30" author="NVIDIA" contact="Jeff Juliano @jjuliano" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NVX_EXTENSION_30_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_extension_30&quot;"           name="VK_NVX_EXTENSION_30_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NVX_extension_31" number="31" author="NVIDIA" contact="Jeff Juliano @jjuliano" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NVX_EXTENSION_31_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_extension_31&quot;"           name="VK_NVX_EXTENSION_31_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_32" number="32" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_32_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_32&quot;"           name="VK_AMD_EXTENSION_32_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_33" number="33" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_33_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_33&quot;"           name="VK_AMD_EXTENSION_33_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_draw_indirect_count" number="34" type="device" author="AMD" contact="Daniel Rakos @aqnuep" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_draw_indirect_count&quot;"    name="VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME"/>
                <command name="vkCmdDrawIndirectCountAMD"/>
                <command name="vkCmdDrawIndexedIndirectCountAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_35" number="35" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_35_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_35&quot;"           name="VK_AMD_EXTENSION_35_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_negative_viewport_height" number="36" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_negative_viewport_height&quot;"           name="VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_gpu_shader_half_float" number="37" type="device" author="AMD" contact="Dominik Witczak @dominikwitczak_amd" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_gpu_shader_half_float&quot;"  name="VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_ballot" number="38" type="device" author="AMD" contact="Dominik Witczak @dominikwitczak_amd" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_AMD_SHADER_BALLOT_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_ballot&quot;"          name="VK_AMD_SHADER_BALLOT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_39" number="39" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_39_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_39&quot;"           name="VK_AMD_EXTENSION_39_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_40" number="40" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_40_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_40&quot;"           name="VK_AMD_EXTENSION_40_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_41" number="41" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_41_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_41&quot;"           name="VK_AMD_EXTENSION_41_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_42" number="42" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_42_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_42&quot;"           name="VK_AMD_EXTENSION_42_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_43" number="43" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_43_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_43&quot;"           name="VK_AMD_EXTENSION_43_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_44" number="44" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_44_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_44&quot;"           name="VK_AMD_EXTENSION_44_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_45" number="45" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_45_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_45&quot;"           name="VK_AMD_EXTENSION_45_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_46" number="46" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_46_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_46&quot;"           name="VK_AMD_EXTENSION_46_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_47" number="47" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_47_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_47&quot;"           name="VK_AMD_EXTENSION_47_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NVX_extension_48" number="48" author="NVIDIA" contact="James Jones @cubanismo" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NVX_EXTENSION_48_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_extension_48&quot;"           name="VK_NVX_EXTENSION_48_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_49" number="49" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_49_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_extension_49&quot;"        name="VK_GOOGLE_EXTENSION_49_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_50" number="50" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_50_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_extension_50&quot;"        name="VK_GOOGLE_EXTENSION_50_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NVX_extension_51" number="51" author="NVIDIA" contact="James Jones @cubanismo" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NVX_EXTENSION_51_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_extension_51&quot;"           name="VK_NVX_EXTENSION_51_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NVX_extension_52" number="52" author="NVIDIA" contact="James Jones @cubanismo" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NVX_EXTENSION_52_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_extension_52&quot;"           name="VK_NVX_EXTENSION_52_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_53" number="53" author="NVIDIA" contact="Jeff Bolz @jbolz" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NV_EXTENSION_53_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_53&quot;"            name="VK_NV_EXTENSION_53_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_54" number="54" author="NVIDIA" contact="Jeff Bolz @jbolz" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NV_EXTENSION_54_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_54&quot;"            name="VK_NV_EXTENSION_54_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_IMG_format_pvrtc" number="55" type="device" author="IMG" contact="Tobias Hector @tobias" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_IMG_FORMAT_PVRTC_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_format_pvrtc&quot;"           name="VK_IMG_FORMAT_PVRTC_EXTENSION_NAME"/>
                <enum offset="0" extends="VkFormat"                     name="VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG"/>
                <enum offset="1" extends="VkFormat"                     name="VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG"/>
                <enum offset="2" extends="VkFormat"                     name="VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG"/>
                <enum offset="3" extends="VkFormat"                     name="VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG"/>
                <enum offset="4" extends="VkFormat"                     name="VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG"/>
                <enum offset="5" extends="VkFormat"                     name="VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG"/>
                <enum offset="6" extends="VkFormat"                     name="VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG"/>
                <enum offset="7" extends="VkFormat"                     name="VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG"/>
            </require>
        </extension>
        <extension name="VK_NV_external_memory_capabilities" number="56" type="instance" author="NVIDIA" contact="James jones @cubanismo" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_memory_capabilities&quot;" name="VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME"/>
                <type name="VkExternalMemoryHandleTypeFlagsNV"/>
                <type name="VkExternalMemoryHandleTypeFlagBitsNV"/>
                <type name="VkExternalMemoryFeatureFlagsNV"/>
                <type name="VkExternalMemoryFeatureFlagBitsNV"/>
                <type name="VkExternalImageFormatPropertiesNV"/>
                <command name="vkGetPhysicalDeviceExternalImageFormatPropertiesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_external_memory" number="57" type="device" requires="VK_NV_external_memory_capabilities" author="NVIDIA" contact="James jones @cubanismo" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_EXTERNAL_MEMORY_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_memory&quot;"         name="VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"/>
                <type name="VkExternalMemoryImageCreateInfoNV"/>
                <type name="VkExportMemoryAllocateInfoNV"/>
            </require>
        </extension>
        <extension name="VK_NV_external_memory_win32" number="58" type="device" requires="VK_NV_external_memory_capabilities,VK_NV_external_memory" author="NVIDIA" contact="James jones @cubanismo" protect="VK_USE_PLATFORM_WIN32_KHR" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_memory_win32&quot;"   name="VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"/>
                <type name="VkImportMemoryWin32HandleInfoNV"/>
                <type name="VkExportMemoryWin32HandleInfoNV"/>
                <command name="vkGetMemoryWin32HandleNV"/>
            </require>
        </extension>
        <extension name="VK_NV_win32_keyed_mutex" number="59" type="device" requires="VK_NV_external_memory_capabilities,VK_NV_external_memory_win32" author="NVIDIA" contact="Carsten Rohde" protect="VK_USE_PLATFORM_WIN32_KHR" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_win32_keyed_mutex&quot;"       name="VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"/>
                <type name="VkWin32KeyedMutexAcquireReleaseInfoNV"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_60" number="60" author="KHR" contact="Jeff Bolz @jbolz" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_60_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_60&quot;"           name="VK_KHR_EXTENSION_60_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_61" number="61" author="KHR" contact="Jeff Bolz @jbolz" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_61_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_61&quot;"           name="VK_KHR_EXTENSION_61_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_validation_flags" number="62" type="instance" author="Google, Inc." contact="Tobin Ehlis @tobine" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_EXT_VALIDATION_FLAGS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_validation_flags&quot;"           name="VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"/>
                <type name="VkValidationFlagsEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_63" number="63" author="NVIDIA" contact="Mathias Heyer @mheyer" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NV_EXTENSION_63_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_63&quot;"            name="VK_NV_EXTENSION_63_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_64" number="64" author="KHR" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_64_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_64&quot;"           name="VK_KHR_EXTENSION_64_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_65" number="65" author="NVIDIA" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NV_EXTENSION_65_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_65&quot;"            name="VK_NV_EXTENSION_65_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_66" number="66" author="NVIDIA" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NV_EXTENSION_66_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_66&quot;"            name="VK_NV_EXTENSION_66_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_ARM_extension_01" number="67" type="device" author="ARM" contact="Jan-Harald Fredriksen @janharald" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_ARM_EXTENSION_01_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_extension_01&quot;"           name="VK_ARM_EXTENSION_01_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_ARM_extension_02" number="68" type="device" author="ARM" contact="Jan-Harald Fredriksen @janharald" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_ARM_EXTENSION_02_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_extension_02&quot;"           name="VK_ARM_EXTENSION_02_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_IMG_extension_69" number="69" type="device" author="IMG" contact="Tobias Hector @tobias" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_IMG_EXTENSION_69_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_extension_69&quot;"           name="VK_IMG_EXTENSION_69_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_70" number="70" author="KHR" contact="Piers Daniell @pdaniell" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_70_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_70&quot;"           name="VK_KHR_EXTENSION_70_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_71" number="71" author="KHR" contact="Jeff Bolz @jbolz" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_71_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_71&quot;"           name="VK_KHR_EXTENSION_71_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_72" number="72" author="KHR" contact="James Jones @cubanismo" supported="disable">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_72_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_72&quot;"           name="VK_KHR_EXTENSION_72_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_73" number="73" author="KHR" contact="James Jones @cubanismo" supported="disable">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_73_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_73&quot;"           name="VK_KHR_EXTENSION_73_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_74" number="74" author="KHR" contact="James Jones @cubanismo" supported="disable">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_74_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_74&quot;"           name="VK_KHR_EXTENSION_74_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_75" number="75" author="KHR" contact="James Jones @cubanismo" supported="disable">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_75_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_75&quot;"           name="VK_KHR_EXTENSION_75_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_76" number="76" author="KHR" contact="James Jones @cubanismo" supported="disable">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_76_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_76&quot;"           name="VK_KHR_EXTENSION_76_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_77" number="77" author="KHR" contact="James Jones @cubanismo" supported="disable">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_77_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_77&quot;"           name="VK_KHR_EXTENSION_77_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_78" number="78" author="KHR" contact="James Jones @cubanismo" supported="disable">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_78_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_78&quot;"           name="VK_KHR_EXTENSION_78_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_79" number="79" author="KHR" contact="James Jones @cubanismo" supported="disable">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_79_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_79&quot;"           name="VK_KHR_EXTENSION_79_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_80" number="80" author="KHR" contact="James Jones @cubanismo" supported="disable">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_80_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_80&quot;"           name="VK_KHR_EXTENSION_80_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_81" number="81" author="KHR" contact="Jeff Bolz @jbolz" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_81_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_81&quot;"           name="VK_KHR_EXTENSION_81_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_82" number="82" author="KHR" contact="Jeff Bolz @jbolz" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_82_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_82&quot;"           name="VK_KHR_EXTENSION_82_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_83" number="83" author="KHR" contact="Jan-Harald Fredriksen @janharald" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_KHR_EXTENSION_83_SPEC_VERSION"/>
                 <enum value="&quot;VK_KHR_extension_83&quot;"           name="VK_KHR_EXTENSION_83_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_KHR_extension_84" number="84" author="KHR" contact="Jan-Harald Fredriksen @janharald" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_KHR_EXTENSION_84_SPEC_VERSION"/>
                 <enum value="&quot;VK_KHR_extension_84&quot;"           name="VK_KHR_EXTENSION_84_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_KHR_extension_85" number="85" author="KHR" contact="Ian Elliott @ianelliott" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_KHR_EXTENSION_85_SPEC_VERSION"/>
                 <enum value="&quot;VK_KHR_extension_85&quot;"           name="VK_KHR_EXTENSION_85_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_KHR_extension_86" number="86" author="KHR" contact="Markus Tavenrath @mtavenrath" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_KHR_EXTENSION_86_SPEC_VERSION"/>
                 <enum value="&quot;VK_KHR_extension_86&quot;"           name="VK_KHR_EXTENSION_86_EXTENSION_NAME"/>
              </require>
         </extension>
        <extension name="VK_NVX_device_generated_commands" number="87" type="device" author="NVIDIA" contact="Christoph Kubisch @pixeljetstream" supported="vulkan">
          <require>
              <enum value="1"                                               name="VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION"/>
              <enum value="&quot;VK_NVX_device_generated_commands&quot;"    name="VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME"/>
              <enum offset="0" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX"/>
              <enum offset="1" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX"/>
              <enum offset="2" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX"/>
              <enum offset="3" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX"/>
              <enum offset="4" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX"/>
              <enum offset="5" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX"/>
              <enum bitpos="17" extends="VkPipelineStageFlagBits"           name="VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX"/>
              <enum bitpos="17" extends="VkAccessFlagBits"                  name="VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX"/>
              <enum bitpos="18" extends="VkAccessFlagBits"                  name="VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX"/>
              <type name="VkObjectTableNVX"/>
              <type name="VkIndirectCommandsLayoutNVX"/>
              <type name="VkIndirectCommandsLayoutUsageFlagsNVX"/>
              <type name="VkObjectEntryUsageFlagsNVX"/>
              <type name="VkIndirectCommandsLayoutUsageFlagBitsNVX"/>
              <type name="VkIndirectCommandsTokenTypeNVX"/>
              <type name="VkObjectEntryUsageFlagBitsNVX"/>
              <type name="VkObjectEntryTypeNVX"/>
              <type name="VkDeviceGeneratedCommandsFeaturesNVX"/>
              <type name="VkDeviceGeneratedCommandsLimitsNVX"/>
              <type name="VkIndirectCommandsTokenNVX"/>
              <type name="VkIndirectCommandsLayoutTokenNVX"/>
              <type name="VkIndirectCommandsLayoutCreateInfoNVX"/>
              <type name="VkCmdProcessCommandsInfoNVX"/>
              <type name="VkCmdReserveSpaceForCommandsInfoNVX"/>
              <type name="VkObjectTableCreateInfoNVX"/>
              <type name="VkObjectTableEntryNVX"/>
              <type name="VkObjectTablePipelineEntryNVX"/>
              <type name="VkObjectTableDescriptorSetEntryNVX"/>
              <type name="VkObjectTableVertexBufferEntryNVX"/>
              <type name="VkObjectTableIndexBufferEntryNVX"/>
              <type name="VkObjectTablePushConstantEntryNVX"/>
              <command name="vkCmdProcessCommandsNVX"/>
              <command name="vkCmdReserveSpaceForCommandsNVX"/>
              <command name="vkCreateIndirectCommandsLayoutNVX"/>
              <command name="vkDestroyIndirectCommandsLayoutNVX"/>
              <command name="vkCreateObjectTableNVX"/>
              <command name="vkDestroyObjectTableNVX"/>
              <command name="vkRegisterObjectsNVX"/>
              <command name="vkUnregisterObjectsNVX"/>
              <command name="vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX"/>
          </require>
        </extension>
         <extension name="VK_KHR_extension_88" number="88" author="NV" contact="Eric Werness @ewerness" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_KHR_EXTENSION_88_SPEC_VERSION"/>
                 <enum value="&quot;VK_KHR_extension_88&quot;"           name="VK_KHR_EXTENSION_88_EXTENSION_NAME"/>
              </require>
         </extension>
         <extension name="VK_EXT_extension_89" number="89" author="NV" contact="James Jones @cubanismo" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_EXT_EXTENSION_89_SPEC_VERSION"/>
                 <enum value="&quot;VK_EXT_extension_89&quot;"           name="VK_EXT_EXTENSION_89_EXTENSION_NAME"/>
              </require>
         </extension>
         <extension name="VK_EXT_extension_90" number="90" author="NV" contact="James Jones @cubanismo" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_EXT_EXTENSION_90_SPEC_VERSION"/>
                 <enum value="&quot;VK_EXT_extension_90&quot;"           name="VK_EXT_EXTENSION_90_EXTENSION_NAME"/>
              </require>
         </extension>
         <extension name="VK_EXT_extension_91" number="91" author="NV" contact="James Jones @cubanismo" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_EXT_EXTENSION_91_SPEC_VERSION"/>
                 <enum value="&quot;VK_EXT_extension_91&quot;"           name="VK_EXT_EXTENSION_91_EXTENSION_NAME"/>
              </require>
         </extension>
         <extension name="VK_EXT_extension_92" number="92" author="NV" contact="James Jones @cubanismo" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_EXT_EXTENSION_92_SPEC_VERSION"/>
                 <enum value="&quot;VK_EXT_extension_92&quot;"           name="VK_EXT_EXTENSION_92_EXTENSION_NAME"/>
              </require>
         </extension>
         <extension name="VK_KHR_extension_93" number="93" author="GOOGLE" contact="Ian Elliott @ianelliott" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_GOOGLE_EXTENSION_93_SPEC_VERSION"/>
                 <enum value="&quot;VK_GOOGLE_extension_93&quot;"        name="VK_GOOGLE_EXTENSION_93_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_KHR_extension_94" number="94" author="Codeplay" contact="Neil Henning @neil_henning" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_KHR_EXTENSION_94_SPEC_VERSION"/>
                 <enum value="&quot;VK_KHR_extension_94&quot;"           name="VK_KHR_EXTENSION_94_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_NV_extension_95" number="95" author="NVIDIA" contact="Daniel Koch @dgkoch" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_NV_EXTENSION_95_SPEC_VERSION"/>
                 <enum value="&quot;VK_NV_extension_95&quot;"            name="VK_NV_EXTENSION_95_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_NV_extension_96" number="96" author="NVIDIA" contact="Daniel Koch @dgkoch" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_NV_EXTENSION_96_SPEC_VERSION"/>
                 <enum value="&quot;VK_NV_extension_96&quot;"            name="VK_NV_EXTENSION_96_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_NV_extension_97" number="97" author="NVIDIA" contact="Daniel Koch @dgkoch" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_NV_EXTENSION_97_SPEC_VERSION"/>
                 <enum value="&quot;VK_NV_extension_97&quot;"            name="VK_NV_EXTENSION_97_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_NV_extension_98" number="98" author="NVIDIA" contact="Daniel Koch @dgkoch" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_NV_EXTENSION_98_SPEC_VERSION"/>
                 <enum value="&quot;VK_NV_extension_98&quot;"            name="VK_NV_EXTENSION_98_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_NV_extension_99" number="99" author="NVIDIA" contact="Daniel Koch @dgkoch" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_NV_EXTENSION_99_SPEC_VERSION"/>
                 <enum value="&quot;VK_NV_extension_99&quot;"            name="VK_NV_EXTENSION_99_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_NV_extension_100" number="100" author="NVIDIA" contact="Daniel Koch @dgkoch" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_NV_EXTENSION_100_SPEC_VERSION"/>
                 <enum value="&quot;VK_NV_extension_100&quot;"           name="VK_NV_EXTENSION_100_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_NV_extension_101" number="101" author="NVIDIA" contact="Daniel Koch @dgkoch" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_NV_EXTENSION_101_SPEC_VERSION"/>
                 <enum value="&quot;VK_NV_extension_101&quot;"           name="VK_NV_EXTENSION_101_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_NV_extension_102" number="102" author="NVIDIA" contact="Daniel Koch @dgkoch" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_NV_EXTENSION_102_SPEC_VERSION"/>
                 <enum value="&quot;VK_NV_extension_102&quot;"           name="VK_NV_EXTENSION_102_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_NV_extension_103" number="103" author="NVIDIA" contact="Daniel Koch @dgkoch" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_NV_EXTENSION_103_SPEC_VERSION"/>
                 <enum value="&quot;VK_NV_extension_103&quot;"           name="VK_NV_EXTENSION_103_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_NV_extension_104" number="104" author="NVIDIA" contact="Mathias Schott @mschott" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_NV_EXTENSION_104_SPEC_VERSION"/>
                 <enum value="&quot;VK_NV_extension_104&quot;"           name="VK_NV_EXTENSION_104_EXTENSION_NAME"/>
             </require>
         </extension>
         <extension name="VK_EXT_extension_105" number="105" author="GOOGLE" contact="Courtney Goeltzenleuchter @courtneygo" supported="disabled">
             <require>
                 <enum value="0"                                         name="VK_KHR_EXTENSION_105_SPEC_VERSION"/>
                 <enum value="&quot;VK_EXT_extension_105&quot;"           name="VK_KHR_EXTENSION_105_EXTENSION_NAME"/>
             </require>
         </extension>
    </extensions>
</registry>
