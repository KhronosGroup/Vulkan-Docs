<?xml version="1.0" encoding="UTF-8"?>
<registry>
    <comment>
Copyright (c) 2015-2016 The Khronos Group Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and/or associated documentation files (the
"Materials"), to deal in the Materials without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Materials, and to
permit persons to whom the Materials are furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Materials.

THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

------------------------------------------------------------------------

This file, vk.xml, is the Vulkan API Registry. It is a critically important
and normative part of the Vulkan Specification, including a canonical
machine-readable definition of the API, parameter and member validation
language incorporated into the Specification and reference pages, and other
material which is registered by Khronos, such as tags used by extension and
layer authors. The only authoritative version of vk.xml is the one
maintained in the master branch of the Khronos Vulkan Github project.
    </comment>

    <!-- SECTION: Vulkan vendor IDs for physical devices without PCI vendor IDs -->
    <vendorids>
        <vendorid name="KHR"    id="0x10000"            comment="This is the next available Khronos vendor ID"/>
        <vendorid name="VIV"    id="0x10001"            comment="Vivante vendor ID"/>
        <vendorid name="VSI"    id="0x10002"            comment="VeriSilicon vendor ID"/>
    </vendorids>

    <!-- SECTION: Vulkan vendor/author tags for extensions and layers -->
    <tags>
        <tag name="IMG"         author="Imagination Technologies"      contact="Michael Worcester @michaelworcester"/>
        <tag name="AMD"         author="Advanced Micro Devices, Inc."  contact="Daniel Rakos @aqnuep"/>
        <tag name="ARM"         author="ARM Limited"                   contact="Jan-Harald Fredriksen @janharald"/>
        <tag name="FSL"         author="Freescale Semiconductor, Inc." contact="Norbert Nopper @FslNopper"/>
        <tag name="BRCM"        author="Broadcom Corporation"          contact="Graeme Leese @gnl21"/>
        <tag name="NXP"         author="NXP Semiconductors N.V."       contact="Norbert Nopper @FslNopper"/>
        <tag name="NV"          author="NVIDIA Corporation"            contact="Daniel Koch @dgkoch"/>
        <tag name="NVX"         author="NVIDIA Corporation"            contact="Daniel Koch @dgkoch"/>
        <tag name="VIV"         author="Vivante Corporation"           contact="Yanjun Zhang @yanjunzhang"/>
        <tag name="VSI"         author="VeriSilicon Holdings Co., Ltd." contact="Yanjun Zhang @yanjunzhang"/>
        <tag name="KDAB"        author="KDAB"                          contact="Sean Harmer @seanharmer"/>
        <tag name="ANDROID"     author="Google, Inc."                  contact="Jesse Hall @jessehall"/>
        <tag name="CHROMIUM"    author="Google, Inc."                  contact="Jesse Hall @jessehall"/>
        <tag name="GOOGLE"      author="Google, Inc."                  contact="Jesse Hall @jessehall"/>
        <tag name="QCOM"        author="Qualcomm Technologies, Inc."   contact="Maurice Ribble @mribble"/>
        <tag name="LUNARG"      author="LunarG, Inc."                  contact="Karen Ghavam @KarenGhavam"/>
        <tag name="SAMSUNG"     author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
        <tag name="SEC"         author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
        <tag name="TIZEN"       author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
        <tag name="RENDERDOC"   author="RenderDoc (renderdoc.org)"     contact="baldurk@baldurk.org"/>
    </tags>

    <!-- SECTION: Vulkan type definitions -->
    <types>
        <type name="vk_platform" category="include">#include "vk_platform.h"</type>
            <!-- WSI extensions -->
        <type category="include">#include "<name>vulkan.h</name>"</type>
        <type category="include">#include &lt;<name>X11/Xlib.h</name>&gt;</type>
        <type category="include">#include &lt;<name>android/native_window.h</name>&gt;</type>
        <type category="include">#include &lt;<name>mir_toolkit/client_types.h</name>&gt;</type>
        <type category="include">#include &lt;<name>wayland-client.h</name>&gt;</type>
        <type category="include">#include &lt;<name>windows.h</name>&gt;</type>
        <type category="include">#include &lt;<name>xcb/xcb.h</name>&gt;</type>

        <type requires="X11/Xlib.h" name="Display"/>
        <type requires="X11/Xlib.h" name="VisualID"/>
        <type requires="X11/Xlib.h" name="Window"/>
        <type requires="android/native_window.h" name="ANativeWindow"/>
        <type requires="mir_toolkit/client_types.h" name="MirConnection"/>
        <type requires="mir_toolkit/client_types.h" name="MirSurface"/>
        <type requires="wayland-client.h" name="wl_display"/>
        <type requires="wayland-client.h" name="wl_surface"/>
        <type requires="windows.h" name="HINSTANCE"/>
        <type requires="windows.h" name="HWND"/>
        <type requires="xcb/xcb.h" name="xcb_connection_t"/>
        <type requires="xcb/xcb.h" name="xcb_visualid_t"/>
        <type requires="xcb/xcb.h" name="xcb_window_t"/>

        <type category="define">#define <name>VK_MAKE_VERSION</name>(major, minor, patch) \
    (((major) &lt;&lt; 22) | ((minor) &lt;&lt; 12) | (patch))</type>
        <type category="define">#define <name>VK_VERSION_MAJOR</name>(version) ((uint32_t)(version) &gt;&gt; 22)</type>
        <type category="define">#define <name>VK_VERSION_MINOR</name>(version) (((uint32_t)(version) &gt;&gt; 12) &amp; 0x3ff)</type>
        <type category="define">#define <name>VK_VERSION_PATCH</name>(version) ((uint32_t)(version) &amp; 0xfff)</type>

        <type category="define">// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
//#define <name>VK_API_VERSION</name> <type>VK_MAKE_VERSION</type>(1, 0, 0)</type>    <!-- The patch version here should never be set to anything other than 0 -->
        <type category="define">// Vulkan 1.0 version number
#define <name>VK_API_VERSION_1_0</name> <type>VK_MAKE_VERSION</type>(1, 0, 0)</type>    <!-- The patch version here should never be set to anything other than 0 -->
        <type category="define">// Version of this file
#define <name>VK_HEADER_VERSION</name> 13</type>

        <type category="define">
#define <name>VK_DEFINE_HANDLE</name>(object) typedef struct object##_T* object;</type>

        <type category="define" name="VK_DEFINE_NON_DISPATCHABLE_HANDLE">
#if defined(__LP64__) || defined(_WIN64) || defined(__x86_64__) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
        </type>

        <type category="define">
#define <name>VK_NULL_HANDLE</name> 0
        </type>

        <type category="basetype">typedef <type>uint32_t</type> <name>VkSampleMask</name>;</type>
        <type category="basetype">typedef <type>uint32_t</type> <name>VkBool32</name>;</type>
        <type category="basetype">typedef <type>uint32_t</type> <name>VkFlags</name>;</type>
        <type category="basetype">typedef <type>uint64_t</type> <name>VkDeviceSize</name>;</type>
        <!-- Basic C types, pulled in via vk_platform.h -->
        <type requires="vk_platform" name="void"/>
        <type requires="vk_platform" name="char"/>
        <type requires="vk_platform" name="float"/>
        <type requires="vk_platform" name="uint8_t"/>
        <type requires="vk_platform" name="uint32_t"/>
        <type requires="vk_platform" name="uint64_t"/>
        <type requires="vk_platform" name="int32_t"/>
        <type requires="vk_platform" name="size_t"/>
        <!-- Bitfield types -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkFramebufferCreateFlags</name>;</type>               <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPoolCreateFlags</name>;</type>                 <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkRenderPassCreateFlags</name>;</type>                <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSamplerCreateFlags</name>;</type>                   <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineLayoutCreateFlags</name>;</type>            <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCacheCreateFlags</name>;</type>             <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDepthStencilStateCreateFlags</name>;</type> <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDynamicStateCreateFlags</name>;</type>      <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineColorBlendStateCreateFlags</name>;</type>   <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineMultisampleStateCreateFlags</name>;</type>  <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationStateCreateFlags</name>;</type>       <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineViewportStateCreateFlags</name>;</type>     <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineTessellationStateCreateFlags</name>;</type> <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineInputAssemblyStateCreateFlags</name>;</type><!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineVertexInputStateCreateFlags</name>;</type>  <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineShaderStageCreateFlags</name>;</type>       <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorSetLayoutCreateFlags</name>;</type>       <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkBufferViewCreateFlags</name>;</type>                <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkInstanceCreateFlags</name>;</type>                  <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceCreateFlags</name>;</type>                    <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceQueueCreateFlags</name>;</type>               <!-- creation flags -->
        <type requires="VkQueueFlagBits"                  category="bitmask">typedef <type>VkFlags</type> <name>VkQueueFlags</name>;</type>                       <!-- Queue capabilities -->
        <type requires="VkMemoryPropertyFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryPropertyFlags</name>;</type>              <!-- Memory properties passed into vkAllocateMemory(). -->
        <type requires="VkMemoryHeapFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryHeapFlags</name>;</type>                  <!-- Memory heap flags -->
        <type requires="VkAccessFlagBits"                 category="bitmask">typedef <type>VkFlags</type> <name>VkAccessFlags</name>;</type>                      <!-- Memory access flags passed to barrier/dependency operations -->
        <type requires="VkBufferUsageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkBufferUsageFlags</name>;</type>                 <!-- Buffer usage flags -->
        <type requires="VkBufferCreateFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkBufferCreateFlags</name>;</type>                <!-- Buffer creation flags -->
        <type requires="VkShaderStageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkShaderStageFlags</name>;</type>                 <!-- Shader stage flags -->
        <type requires="VkImageUsageFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkImageUsageFlags</name>;</type>                  <!-- Image usage flags -->
        <type requires="VkImageCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageCreateFlags</name>;</type>                 <!-- Image creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkImageViewCreateFlags</name>;</type>             <!-- Image view creation flags (no bits yet) -->
        <type requires="VkPipelineCreateFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCreateFlags</name>;</type>              <!-- Pipeline creation flags -->
        <type requires="VkColorComponentFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkColorComponentFlags</name>;</type>              <!-- Color component flags -->
        <type requires="VkFenceCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkFenceCreateFlags</name>;</type>                 <!-- Fence creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreCreateFlags</name>;</type>             <!-- Semaphore creation flags -->
        <type requires="VkFormatFeatureFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkFormatFeatureFlags</name>;</type>               <!-- Format capability flags -->
        <type requires="VkQueryControlFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkQueryControlFlags</name>;</type>                <!-- Query control flags -->
        <type requires="VkQueryResultFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkQueryResultFlags</name>;</type>                 <!-- Query result flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkShaderModuleCreateFlags</name>;</type>          <!-- Shader module creation flags (no bits yet) -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkEventCreateFlags</name>;</type>                 <!-- Event creation flags  (no bits yet) -->
        <type requires="VkCommandPoolCreateFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolCreateFlags</name>;</type>               <!-- Command pool creation flags -->
        <type requires="VkCommandPoolResetFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolResetFlags</name>;</type>                <!-- Command pool reset flags -->
        <type requires="VkCommandBufferResetFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferResetFlags</name>;</type>              <!-- Command buffer reset flags -->
        <type requires="VkCommandBufferUsageFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferUsageFlags</name>;</type>              <!-- Command buffer usage flags -->
        <type requires="VkQueryPipelineStatisticFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPipelineStatisticFlags</name>;</type>      <!-- Pipeline statistics flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryMapFlags</name>;</type>                   <!-- Memory mapping flags (no bits yet) -->
        <type requires="VkImageAspectFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageAspectFlags</name>;</type>                 <!-- Bitfield of image aspects -->
        <type requires="VkSparseMemoryBindFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkSparseMemoryBindFlags</name>;</type>            <!-- Sparse memory bind flags -->
        <type requires="VkSparseImageFormatFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkSparseImageFormatFlags</name>;</type>           <!-- Sparse image memory requirements flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSubpassDescriptionFlags</name>;</type>          <!-- Subpass description flags -->
        <type requires="VkPipelineStageFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineStageFlags</name>;</type>               <!-- Pipeline stages -->
        <type requires="VkSampleCountFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkSampleCountFlags</name>;</type>                 <!-- Pipeline stages -->
        <type requires="VkAttachmentDescriptionFlagBits"  category="bitmask">typedef <type>VkFlags</type> <name>VkAttachmentDescriptionFlags</name>;</type>       <!-- Render pass attachment description flags -->
        <type requires="VkStencilFaceFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkStencilFaceFlags</name>;</type>                 <!-- Stencil face flags -->
        <type requires="VkCullModeFlagBits"               category="bitmask">typedef <type>VkFlags</type> <name>VkCullModeFlags</name>;</type>                    <!-- Cull mode flags -->
        <type requires="VkDescriptorPoolCreateFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorPoolCreateFlags</name>;</type>        <!-- Descriptor pool creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorPoolResetFlags</name>;</type>         <!-- Descriptor pool reset flags -->
        <type requires="VkDependencyFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkDependencyFlags</name>;</type>                  <!-- Pipeline barrier and subpass dependency flags -->
            <!-- WSI extensions -->
        <type requires="VkCompositeAlphaFlagBitsKHR"      category="bitmask">typedef <type>VkFlags</type> <name>VkCompositeAlphaFlagsKHR</name>;</type>
        <type requires="VkDisplayPlaneAlphaFlagBitsKHR"   category="bitmask">typedef <type>VkFlags</type> <name>VkDisplayPlaneAlphaFlagsKHR</name>;</type>
        <type requires="VkSurfaceTransformFlagBitsKHR"    category="bitmask">typedef <type>VkFlags</type> <name>VkSurfaceTransformFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSwapchainCreateFlagsKHR</name>;</type>          <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDisplayModeCreateFlagsKHR</name>;</type>        <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDisplaySurfaceCreateFlagsKHR</name>;</type>     <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkAndroidSurfaceCreateFlagsKHR</name>;</type>     <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMirSurfaceCreateFlagsKHR</name>;</type>         <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkWaylandSurfaceCreateFlagsKHR</name>;</type>     <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkWin32SurfaceCreateFlagsKHR</name>;</type>       <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkXlibSurfaceCreateFlagsKHR</name>;</type>        <!-- creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkXcbSurfaceCreateFlagsKHR</name>;</type>         <!-- creation flags -->

        <type requires="VkDebugReportFlagBitsEXT"      category="bitmask">typedef <type>VkFlags</type> <name>VkDebugReportFlagsEXT</name>;</type>

        <!-- Types which can be void pointers or class pointers, selected at compile time -->
        <type category="handle"><type>VK_DEFINE_HANDLE</type>(<name>VkInstance</name>)</type>
        <type category="handle" parent="VkInstance"><type>VK_DEFINE_HANDLE</type>(<name>VkPhysicalDevice</name>)</type>
        <type category="handle" parent="VkPhysicalDevice"><type>VK_DEFINE_HANDLE</type>(<name>VkDevice</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_HANDLE</type>(<name>VkQueue</name>)</type>
        <type category="handle" parent="VkCommandPool"><type>VK_DEFINE_HANDLE</type>(<name>VkCommandBuffer</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDeviceMemory</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCommandPool</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBuffer</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBufferView</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkImage</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkImageView</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkShaderModule</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipeline</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipelineLayout</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSampler</name>)</type>
        <type category="handle" parent="VkDescriptorPool"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorSet</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorSetLayout</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorPool</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkFence</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSemaphore</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkEvent</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkQueryPool</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkFramebuffer</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkRenderPass</name>)</type>
        <type category="handle" parent="VkDevice"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipelineCache</name>)</type>

        <!-- WSI extensions -->
        <type category="handle"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDisplayKHR</name>)</type>
        <type category="handle" parent="VkPhysicalDevice,VkDisplayKHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDisplayModeKHR</name>)</type>
        <type category="handle" parent="VkInstance"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSurfaceKHR</name>)</type>
        <type category="handle" parent="VkSurfaceKHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSwapchainKHR</name>)</type>
        <type category="handle" parent="VkInstance"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDebugReportCallbackEXT</name>)</type>

        <!-- Types generated from corresponding <enums> tags below -->
        <type name="VkAttachmentLoadOp" category="enum"/>
        <type name="VkAttachmentStoreOp" category="enum"/>
        <type name="VkBlendFactor" category="enum"/>
        <type name="VkBlendOp" category="enum"/>
        <type name="VkBorderColor" category="enum"/>
        <type name="VkFramebufferCreateFlagBits" category="enum"/>
        <type name="VkQueryPoolCreateFlagBits" category="enum"/>
        <type name="VkRenderPassCreateFlagBits" category="enum"/>
        <type name="VkSamplerCreateFlagBits" category="enum"/>
        <type name="VkPipelineCacheHeaderVersion" category="enum"/>
        <type name="VkPipelineLayoutCreateFlagBits" category="enum"/>
        <type name="VkPipelineCacheCreateFlagBits" category="enum"/>
        <type name="VkPipelineDepthStencilStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineDynamicStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineColorBlendStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineMultisampleStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineRasterizationStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineViewportStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineTessellationStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineInputAssemblyStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineVertexInputStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineShaderStageCreateFlagBits" category="enum"/>
        <type name="VkDescriptorSetLayoutCreateFlagBits" category="enum"/>
        <type name="VkBufferViewCreateFlagBits" category="enum"/>
        <type name="VkInstanceCreateFlagBits" category="enum"/>
        <type name="VkDeviceQueueCreateFlagBits" category="enum"/>
        <type name="VkBufferCreateFlagBits" category="enum"/>
        <type name="VkBufferUsageFlagBits" category="enum"/>
        <type name="VkColorComponentFlagBits" category="enum"/>
        <type name="VkComponentSwizzle" category="enum"/>
        <type name="VkCommandPoolCreateFlagBits" category="enum"/>
        <type name="VkCommandPoolResetFlagBits" category="enum"/>
        <type name="VkCommandBufferResetFlagBits" category="enum"/>
        <type name="VkCommandBufferLevel" category="enum"/>
        <type name="VkCommandBufferUsageFlagBits" category="enum"/>
        <type name="VkCompareOp" category="enum"/>
        <type name="VkCullModeFlagBits" category="enum"/>
        <type name="VkDescriptorType" category="enum"/>
        <type name="VkDeviceCreateFlagBits" category="enum"/>
        <type name="VkDynamicState" category="enum"/>
        <type name="VkFenceCreateFlagBits" category="enum"/>
        <type name="VkPolygonMode" category="enum"/>
        <type name="VkFormat" category="enum"/>
        <type name="VkFormatFeatureFlagBits" category="enum"/>
        <type name="VkFrontFace" category="enum"/>
        <type name="VkImageAspectFlagBits" category="enum"/>
        <type name="VkImageCreateFlagBits" category="enum"/>
        <type name="VkImageLayout" category="enum"/>
        <type name="VkImageTiling" category="enum"/>
        <type name="VkImageType" category="enum"/>
        <type name="VkImageUsageFlagBits" category="enum"/>
        <type name="VkImageViewType" category="enum"/>
        <type name="VkSharingMode" category="enum"/>
        <type name="VkIndexType" category="enum"/>
        <type name="VkLogicOp" category="enum"/>
        <type name="VkMemoryHeapFlagBits" category="enum"/>
        <type name="VkAccessFlagBits" category="enum"/>
        <type name="VkMemoryPropertyFlagBits" category="enum"/>
        <type name="VkPhysicalDeviceType" category="enum"/>
        <type name="VkPipelineBindPoint" category="enum"/>
        <type name="VkPipelineCreateFlagBits" category="enum"/>
        <type name="VkPrimitiveTopology" category="enum"/>
        <type name="VkQueryControlFlagBits" category="enum"/>
        <type name="VkQueryPipelineStatisticFlagBits" category="enum"/>
        <type name="VkQueryResultFlagBits" category="enum"/>
        <type name="VkQueryType" category="enum"/>
        <type name="VkQueueFlagBits" category="enum"/>
        <type name="VkSubpassContents" category="enum"/>
        <type name="VkResult" category="enum"/>
        <type name="VkShaderStageFlagBits" category="enum"/>
        <type name="VkSparseMemoryBindFlagBits" category="enum"/>
        <type name="VkStencilFaceFlagBits" category="enum"/>
        <type name="VkStencilOp" category="enum"/>
        <type name="VkStructureType" category="enum"/>
        <type name="VkSystemAllocationScope" category="enum"/>
        <type name="VkInternalAllocationType" category="enum"/>
        <type name="VkSamplerAddressMode" category="enum"/>
        <type name="VkFilter" category="enum"/>
        <type name="VkSamplerMipmapMode" category="enum"/>
        <type name="VkVertexInputRate" category="enum"/>
        <type name="VkPipelineStageFlagBits" category="enum"/>
        <type name="VkSparseImageFormatFlagBits" category="enum"/>
        <type name="VkSampleCountFlagBits" category="enum"/>
        <type name="VkAttachmentDescriptionFlagBits" category="enum"/>
        <type name="VkDescriptorPoolCreateFlagBits" category="enum"/>
        <type name="VkDependencyFlagBits" category="enum"/>
        <!-- WSI extensions -->
        <type name="VkColorSpaceKHR" category="enum"/>
        <type name="VkCompositeAlphaFlagBitsKHR" category="enum"/>
        <type name="VkDisplayPlaneAlphaFlagBitsKHR" category="enum"/>
        <type name="VkPresentModeKHR" category="enum"/>
        <type name="VkSurfaceTransformFlagBitsKHR" category="enum"/>
        <type name="VkDebugReportFlagBitsEXT" category="enum"/>
        <type name="VkDebugReportObjectTypeEXT" category="enum"/>
        <type name="VkDebugReportErrorEXT" category="enum"/>
        <type name="VkRasterizationOrderAMD" category="enum"/>

        <!-- The PFN_vk*Function types are used by VkAllocationCallbacks below -->
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkInternalAllocationNotification</name>)(
    <type>void</type>*                                       pUserData,
    <type>size_t</type>                                      size,
    <type>VkInternalAllocationType</type>                    allocationType,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkInternalFreeNotification</name>)(
    <type>void</type>*                                       pUserData,
    <type>size_t</type>                                      size,
    <type>VkInternalAllocationType</type>                    allocationType,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void* (VKAPI_PTR *<name>PFN_vkReallocationFunction</name>)(
    <type>void</type>*                                       pUserData,
    <type>void</type>*                                       pOriginal,
    <type>size_t</type>                                      size,
    <type>size_t</type>                                      alignment,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void* (VKAPI_PTR *<name>PFN_vkAllocationFunction</name>)(
    <type>void</type>*                                       pUserData,
    <type>size_t</type>                                      size,
    <type>size_t</type>                                      alignment,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkFreeFunction</name>)(
    <type>void</type>*                                       pUserData,
    <type>void</type>*                                       pMemory);</type>

    <!-- The PFN_vkVoidFunction type are used by VkGet*ProcAddr below -->
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkVoidFunction</name>)(void);</type>

    <!-- The PFN_vkDebugReportCallbackEXT type are used by the DEBUG_REPORT extension-->
        <type category="funcpointer">typedef VkBool32 (VKAPI_PTR *<name>PFN_vkDebugReportCallbackEXT</name>)(
    <type>VkDebugReportFlagsEXT</type>                       flags,
    <type>VkDebugReportObjectTypeEXT</type>                  objectType,
    <type>uint64_t</type>                                    object,
    <type>size_t</type>                                      location,
    <type>int32_t</type>                                     messageCode,
    const <type>char</type>*                                 pLayerPrefix,
    const <type>char</type>*                                 pMessage,
    <type>void</type>*                                       pUserData);</type>

        <!-- Struct types -->
        <type category="struct" name="VkOffset2D">
            <member><type>int32_t</type>        <name>x</name></member>
            <member><type>int32_t</type>        <name>y</name></member>
        </type>
        <type category="struct" name="VkOffset3D">
            <member><type>int32_t</type>        <name>x</name></member>
            <member><type>int32_t</type>        <name>y</name></member>
            <member><type>int32_t</type>        <name>z</name></member>
        </type>
        <type category="struct" name="VkExtent2D">
            <member><type>uint32_t</type>        <name>width</name></member>
            <member><type>uint32_t</type>        <name>height</name></member>
        </type>
        <type category="struct" name="VkExtent3D">
            <member><type>uint32_t</type>        <name>width</name></member>
            <member><type>uint32_t</type>        <name>height</name></member>
            <member><type>uint32_t</type>        <name>depth</name></member>
        </type>
        <type category="struct" name="VkViewport">
            <member><type>float</type>          <name>x</name></member>
            <member><type>float</type>          <name>y</name></member>
            <member><type>float</type>          <name>width</name></member>
            <member><type>float</type>          <name>height</name></member>
            <member><type>float</type>          <name>minDepth</name></member>
            <member><type>float</type>          <name>maxDepth</name></member>
            <validity>
                <usage>pname:width must: be greater than `0.0` and less than or equal to sname:VkPhysicalDeviceLimits::pname:maxViewportDimensions[0]</usage>
                <usage>pname:height must: be greater than `0.0` and less than or equal to sname:VkPhysicalDeviceLimits::pname:maxViewportDimensions[1]</usage>
                <usage>pname:x and pname:y must: each be between pname:viewportBoundsRange[0] and pname:viewportBoundsRange[1], inclusive</usage>
                <usage>pname:x + pname:width must: be less than or equal to pname:viewportBoundsRange[1]</usage>
                <usage>pname:y + pname:height must: be less than or equal to pname:viewportBoundsRange[1]</usage>
                <usage>pname:minDepth must: be between `0.0` and `1.0`, inclusive</usage>
                <usage>pname:maxDepth must: be between `0.0` and `1.0`, inclusive</usage>
            </validity>
        </type>
        <type category="struct" name="VkRect2D">
            <member><type>VkOffset2D</type>     <name>offset</name></member>
            <member><type>VkExtent2D</type>     <name>extent</name></member>
        </type>
        <type category="struct" name="VkRect3D">
            <member><type>VkOffset3D</type>     <name>offset</name></member>
            <member><type>VkExtent3D</type>     <name>extent</name></member>
        </type>
        <type category="struct" name="VkClearRect">
            <member><type>VkRect2D</type>       <name>rect</name></member>
            <member><type>uint32_t</type>       <name>baseArrayLayer</name></member>
            <member><type>uint32_t</type>       <name>layerCount</name></member>
        </type>
        <type category="struct" name="VkComponentMapping">
            <member><type>VkComponentSwizzle</type> <name>r</name></member>
            <member><type>VkComponentSwizzle</type> <name>g</name></member>
            <member><type>VkComponentSwizzle</type> <name>b</name></member>
            <member><type>VkComponentSwizzle</type> <name>a</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceProperties" returnedonly="true">
            <member><type>uint32_t</type>       <name>apiVersion</name></member>
            <member><type>uint32_t</type>       <name>driverVersion</name></member>
            <member><type>uint32_t</type>       <name>vendorID</name></member>
            <member><type>uint32_t</type>       <name>deviceID</name></member>
            <member><type>VkPhysicalDeviceType</type> <name>deviceType</name></member>
            <member><type>char</type>           <name>deviceName</name>[<enum>VK_MAX_PHYSICAL_DEVICE_NAME_SIZE</enum>]</member>
            <member><type>uint8_t</type>        <name>pipelineCacheUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member><type>VkPhysicalDeviceLimits</type> <name>limits</name></member>
            <member><type>VkPhysicalDeviceSparseProperties</type> <name>sparseProperties</name></member>
        </type>
        <type category="struct" name="VkExtensionProperties" returnedonly="true">
            <member><type>char</type>            <name>extensionName</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]</member> <!-- extension name -->
            <member><type>uint32_t</type>        <name>specVersion</name></member>                    <!-- version of the extension specification implemented -->
        </type>
        <type category="struct" name="VkLayerProperties" returnedonly="true">
            <member><type>char</type>            <name>layerName</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]</member> <!-- layer name -->
            <member><type>uint32_t</type>        <name>specVersion</name></member>                    <!-- version of the layer specification implemented -->
            <member><type>uint32_t</type>        <name>implementationVersion</name></member>                    <!-- build or release version of the layer's library -->
            <member><type>char</type>            <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member> <!-- Free-form description of the layer -->
        </type>
        <type category="struct" name="VkApplicationInfo">
            <member><type>VkStructureType</type> <name>sType</name></member>                          <!-- Type of structure. Should be VK_STRUCTURE_TYPE_APPLICATION_INFO -->
            <member>const <type>void</type>*     <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true" len="null-terminated">const <type>char</type>*     <name>pApplicationName</name></member>
            <member><type>uint32_t</type>        <name>applicationVersion</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*     <name>pEngineName</name></member>
            <member><type>uint32_t</type>        <name>engineVersion</name></member>
            <member><type>uint32_t</type>        <name>apiVersion</name></member>
            <validity>
                <usage>pname:apiVersion must: be zero, or otherwise it must: be a version that the implementation supports, or supports an effective substitute for</usage>
            </validity>
        </type>
        <type category="struct" name="VkAllocationCallbacks">
            <member optional="true"><type>void</type>*           <name>pUserData</name></member>
            <member><type>PFN_vkAllocationFunction</type>   <name>pfnAllocation</name></member>
            <member><type>PFN_vkReallocationFunction</type> <name>pfnReallocation</name></member>
            <member><type>PFN_vkFreeFunction</type>    <name>pfnFree</name></member>
            <member optional="true"><type>PFN_vkInternalAllocationNotification</type> <name>pfnInternalAllocation</name></member>
            <member optional="true"><type>PFN_vkInternalFreeNotification</type> <name>pfnInternalFree</name></member>
            <validity>
                <usage>pname:pfnAllocation must: be a pointer to a valid user-defined PFN_vkAllocationFunction</usage>
                <usage>pname:pfnReallocation must: be a pointer to a valid user-defined PFN_vkReallocationFunction</usage>
                <usage>pname:pfnFree must: be a pointer to a valid user-defined PFN_vkFreeFunction</usage>
                <usage>If either of pname:pfnInternalAllocation or pname:pfnInternalFree is not `NULL`, both must: be valid callbacks</usage>
            </validity>
        </type>
        <type category="struct" name="VkDeviceQueueCreateInfo">
            <member><type>VkStructureType</type> <name>sType</name></member>                          <!-- Should be VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO -->
            <member>const <type>void</type>*     <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkDeviceQueueCreateFlags</type>    <name>flags</name></member>              <!-- Reserved -->
            <member><type>uint32_t</type>        <name>queueFamilyIndex</name></member>
            <member><type>uint32_t</type>        <name>queueCount</name></member>
            <member len="queueCount">const <type>float</type>*    <name>pQueuePriorities</name></member>
            <validity>
                <usage>pname:queueFamilyIndex must: be less than pname:pQueueFamilyPropertyCount returned by fname:vkGetPhysicalDeviceQueueFamilyProperties</usage>
                <usage>pname:queueCount must: be less than or equal to the pname:queueCount member of the sname:VkQueueFamilyProperties structure, as returned by fname:vkGetPhysicalDeviceQueueFamilyProperties in the pname:pQueueFamilyProperties[pname:queueFamilyIndex]</usage>
                <usage>Each element of pname:pQueuePriorities must: be between `0.0` and `1.0` inclusive</usage>
            </validity>
        </type>
        <type category="struct" name="VkDeviceCreateInfo">
            <member><type>VkStructureType</type> <name>sType</name></member>                          <!-- Should be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO -->
            <member>const <type>void</type>*     <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkDeviceCreateFlags</type>    <name>flags</name></member>                   <!-- Reserved -->
            <member><type>uint32_t</type>        <name>queueCreateInfoCount</name></member>
            <member len="queueCreateInfoCount">const <type>VkDeviceQueueCreateInfo</type>* <name>pQueueCreateInfos</name></member>
            <member optional="true"><type>uint32_t</type>               <name>enabledLayerCount</name></member>
            <member len="enabledLayerCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledLayerNames</name></member>            <!-- Ordered list of layer names to be enabled -->
            <member optional="true"><type>uint32_t</type>               <name>enabledExtensionCount</name></member>
            <member len="enabledExtensionCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledExtensionNames</name></member>
            <member optional="true">const <type>VkPhysicalDeviceFeatures</type>* <name>pEnabledFeatures</name></member>
            <validity>
                <usage>pname:ppEnabledLayerNames must: either be sname:NULL or contain the same sequence of layer names that was enabled when creating the parent instance</usage>
                <usage>Any given element of pname:ppEnabledExtensionNames must: be the name of an extension present on the system, exactly matching a string returned in the sname:VkExtensionProperties structure by fname:vkEnumerateDeviceExtensionProperties</usage>
                <usage>If an extension listed in pname:ppEnabledExtensionNames is provided as part of a layer, then both the layer and extension must: be enabled to enable that extension</usage>
                <usage>The pname:queueFamilyIndex member of any given element of pname:pQueueCreateInfos must: be unique within pname:pQueueCreateInfos</usage>
            </validity>
        </type>
        <type category="struct" name="VkInstanceCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Should be VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkInstanceCreateFlags</type>  <name>flags</name></member>                          <!-- Reserved -->
            <member optional="true">const <type>VkApplicationInfo</type>* <name>pApplicationInfo</name></member>
            <member optional="true"><type>uint32_t</type>               <name>enabledLayerCount</name></member>
            <member len="enabledLayerCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledLayerNames</name></member>            <!-- Ordered list of layer names to be enabled -->
            <member optional="true"><type>uint32_t</type>               <name>enabledExtensionCount</name></member>
            <member len="enabledExtensionCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledExtensionNames</name></member>        <!-- Extension names to be enabled -->
            <validity>
                <usage>Any given element of pname:ppEnabledLayerNames must: be the name of a layer present on the system, exactly matching a string returned in the sname:VkLayerProperties structure by fname:vkEnumerateInstanceLayerProperties</usage>
                <usage>Any given element of pname:ppEnabledExtensionNames must: be the name of an extension present on the system, exactly matching a string returned in the sname:VkExtensionProperties structure by fname:vkEnumerateInstanceExtensionProperties</usage>
                <usage>If an extension listed in pname:ppEnabledExtensionNames is provided as part of a layer, then both the layer and extension must: be enabled to enable that extension</usage>
            </validity>
        </type>
        <type category="struct" name="VkQueueFamilyProperties" returnedonly="true">
            <member optional="true"><type>VkQueueFlags</type>           <name>queueFlags</name></member>                     <!-- Queue flags -->
            <member><type>uint32_t</type>               <name>queueCount</name></member>
            <member><type>uint32_t</type>               <name>timestampValidBits</name></member>
            <member><type>VkExtent3D</type>             <name>minImageTransferGranularity</name></member>    <!-- Minimum alignment requirement for image transfers -->
        </type>
        <type category="struct" name="VkPhysicalDeviceMemoryProperties" returnedonly="true">
            <member><type>uint32_t</type>               <name>memoryTypeCount</name></member>
            <member><type>VkMemoryType</type>           <name>memoryTypes</name>[<enum>VK_MAX_MEMORY_TYPES</enum>]</member>
            <member><type>uint32_t</type>               <name>memoryHeapCount</name></member>
            <member><type>VkMemoryHeap</type>           <name>memoryHeaps</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
        </type>
        <type category="struct" name="VkMemoryAllocateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDeviceSize</type>           <name>allocationSize</name></member>                 <!-- Size of memory allocation -->
            <member><type>uint32_t</type>               <name>memoryTypeIndex</name></member>                <!-- Index of the of the memory type to allocate from -->
            <validity>
                <usage>pname:allocationSize must: be less than or equal to the amount of memory available to the sname:VkMemoryHeap specified by pname:memoryTypeIndex and the calling command's sname:VkDevice</usage>
                <usage>pname:allocationSize must: be greater than `0`</usage>
            </validity>
        </type>
        <type category="struct" name="VkMemoryRequirements" returnedonly="true">
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>alignment</name></member>                      <!-- Specified in bytes -->
            <member><type>uint32_t</type>               <name>memoryTypeBits</name></member>                 <!-- Bitfield of the allowed memory type indices into memoryTypes[] for this object -->
        </type>
        <type category="struct" name="VkSparseImageFormatProperties" returnedonly="true">
            <member optional="true"><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>VkExtent3D</type>             <name>imageGranularity</name></member>
            <member optional="true"><type>VkSparseImageFormatFlags</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkSparseImageMemoryRequirements" returnedonly="true">
            <member><type>VkSparseImageFormatProperties</type> <name>formatProperties</name></member>
            <member><type>uint32_t</type>               <name>imageMipTailFirstLod</name></member>
            <member><type>VkDeviceSize</type>           <name>imageMipTailSize</name></member>               <!-- Specified in bytes, must be a multiple of sparse block size in bytes / alignment -->
            <member><type>VkDeviceSize</type>           <name>imageMipTailOffset</name></member>             <!-- Specified in bytes, must be a multiple of sparse block size in bytes / alignment -->
            <member><type>VkDeviceSize</type>           <name>imageMipTailStride</name></member>             <!-- Specified in bytes, must be a multiple of sparse block size in bytes / alignment -->
        </type>
        <type category="struct" name="VkMemoryType" returnedonly="true">
            <member optional="true"><type>VkMemoryPropertyFlags</type>  <name>propertyFlags</name></member>                  <!-- Memory properties of this memory type -->
            <member><type>uint32_t</type>               <name>heapIndex</name></member>                      <!-- Index of the memory heap allocations of this memory type are taken from -->
        </type>
        <type category="struct" name="VkMemoryHeap" returnedonly="true">
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Available memory in the heap-->
            <member optional="true"><type>VkMemoryHeapFlags</type>      <name>flags</name></member>                          <!-- Flags for the heap-->
        </type>
        <type category="struct" name="VkMappedMemoryRange">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDeviceMemory</type>         <name>memory</name></member>                            <!-- Mapped memory object -->
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Offset within the memory object where the range starts -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Size of the range within the memory object -->
            <validity>
                <usage>pname:memory must: currently be mapped</usage>
                <usage>If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:offset and pname:size must: specify a range contained within the currently mapped range of pname:memory</usage>
                <usage>If pname:size is equal to ename:VK_WHOLE_SIZE, pname:offset must: be within the currently mapped range of pname:memory</usage>
                <usage>pname:offset must: be a multiple of sname:VkPhysicalDeviceLimits::pname:nonCoherentAtomSize</usage>
                <usage>If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be a multiple of sname:VkPhysicalDeviceLimits::pname:nonCoherentAtomSize</usage>
            </validity>
        </type>
        <type category="struct" name="VkFormatProperties" returnedonly="true">
            <member optional="true"><type>VkFormatFeatureFlags</type>   <name>linearTilingFeatures</name></member>           <!-- Format features in case of linear tiling -->
            <member optional="true"><type>VkFormatFeatureFlags</type>   <name>optimalTilingFeatures</name></member>          <!-- Format features in case of optimal tiling -->
            <member optional="true"><type>VkFormatFeatureFlags</type>   <name>bufferFeatures</name></member>                 <!-- Format features supported by buffers -->
        </type>
        <type category="struct" name="VkImageFormatProperties" returnedonly="true">
            <member><type>VkExtent3D</type>             <name>maxExtent</name></member>                      <!-- max image dimensions for this resource type -->
            <member><type>uint32_t</type>               <name>maxMipLevels</name></member>                   <!-- max number of mipmap levels for this resource type -->
            <member><type>uint32_t</type>               <name>maxArrayLayers</name></member>                 <!-- max array size for this resource type -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampleCounts</name></member>                   <!-- supported sample counts for this resource type -->
            <member><type>VkDeviceSize</type>           <name>maxResourceSize</name></member>                <!-- max size (in bytes) of this resource type -->
        </type>
        <type category="struct" name="VkDescriptorBufferInfo">
            <member><type>VkBuffer</type>               <name>buffer</name></member>                         <!-- Buffer used for this descriptor slot when the descriptor is UNIFORM_BUFFER[_DYNAMIC] or STORAGE_BUFFER[_DYNAMIC]. VK_NULL_HANDLE otherwise. -->
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Base offset from buffer start in bytes to update in the descriptor set. -->
            <member><type>VkDeviceSize</type>           <name>range</name></member>                          <!-- Size in bytes of the buffer resource for this descriptor update. -->
            <validity>
                <usage>pname:offset must: be less than the size of pname:buffer</usage>
                <usage>If pname:range is not equal to ename:VK_WHOLE_SIZE, pname:range must: be greater than `0`</usage>
                <usage>If pname:range is not equal to ename:VK_WHOLE_SIZE, pname:range must: be less than or equal to the size of pname:buffer minus pname:offset</usage>
            </validity>
        </type>
        <type category="struct" name="VkDescriptorImageInfo">
            <member noautovalidity="true"><type>VkSampler</type>       <name>sampler</name></member>                        <!-- Sampler to write to the descriptor in case it's a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise. -->
            <member noautovalidity="true"><type>VkImageView</type>     <name>imageView</name></member>                      <!-- Image view to write to the descriptor in case it's a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise. -->
            <member noautovalidity="true"><type>VkImageLayout</type>   <name>imageLayout</name></member>                    <!-- Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE). -->
        </type>
        <type category="struct" name="VkWriteDescriptorSet">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDescriptorSet</type>        <name>dstSet</name></member>                        <!-- Destination descriptor set -->
            <member><type>uint32_t</type>               <name>dstBinding</name></member>                    <!-- Binding within the destination descriptor set to write -->
            <member><type>uint32_t</type>               <name>dstArrayElement</name></member>               <!-- Array element within the destination binding to write -->
            <member><type>uint32_t</type>               <name>descriptorCount</name></member>                          <!-- Number of descriptors to write (determines the size of the array pointed by pDescriptors) -->
            <member><type>VkDescriptorType</type>       <name>descriptorType</name></member>                 <!-- Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used) -->
            <member noautovalidity="true" len="descriptorCount">const <type>VkDescriptorImageInfo</type>* <name>pImageInfo</name></member>               <!-- Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types. -->
            <member noautovalidity="true" len="descriptorCount">const <type>VkDescriptorBufferInfo</type>* <name>pBufferInfo</name></member>             <!-- Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types. -->
            <member noautovalidity="true" len="descriptorCount">const <type>VkBufferView</type>*    <name>pTexelBufferView</name></member>               <!-- Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types. -->
            <validity>
                <usage>pname:dstBinding must: be a valid binding point within pname:dstSet</usage>
                <usage>pname:descriptorType must: match the type of pname:dstBinding within pname:dstSet</usage>
                <usage>The sum of pname:dstArrayElement and pname:descriptorCount must: be less than or equal to the number of array elements in the descriptor set binding specified by pname:dstBinding, and all applicable consecutive bindings, as described by &lt;&lt;descriptorsets-updates-consecutive&gt;&gt;</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, pname:pImageInfo must: be a pointer to an array of pname:descriptorCount valid sname:VkDescriptorImageInfo structures</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, pname:pTexelBufferView must: be a pointer to an array of pname:descriptorCount valid sname:VkBufferView handles</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, pname:pBufferInfo must: be a pointer to an array of pname:descriptorCount valid sname:VkDescriptorBufferInfo structures</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and pname:dstSet was not created with a layout that included immutable samplers for pname:dstBinding with pname:descriptorType, the pname:sampler member of any given element of pname:pImageInfo must: be a valid sname:VkSampler object</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the pname:imageView and pname:imageLayout members of any given element of pname:pImageInfo must: be a valid sname:VkImageView and elink:VkImageLayout, respectively</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the pname:offset member of any given element of pname:pBufferInfo must: be a multiple of sname:VkPhysicalDeviceLimits::pname:minUniformBufferOffsetAlignment</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the pname:offset member of any given element of pname:pBufferInfo must: be a multiple of sname:VkPhysicalDeviceLimits::pname:minStorageBufferOffsetAlignment</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the pname:buffer member of any given element of pname:pBufferInfo must: have been created with ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT set</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the pname:buffer member of any given element of pname:pBufferInfo must: have been created with ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT set</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the pname:range member of any given element of pname:pBufferInfo must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxUniformBufferRange</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the pname:range member of any given element of pname:pBufferInfo must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxStorageBufferRange</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, the sname:VkBuffer that any given element of pname:pTexelBufferView was created from must: have been created with ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT set</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, the sname:VkBuffer that any given element of pname:pTexelBufferView was created from must: have been created with ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set</usage>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the pname:imageView member of any given element of pname:pImageInfo must: have been created with the identity swizzle</usage>
            </validity>
        </type>
        <type category="struct" name="VkCopyDescriptorSet">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDescriptorSet</type>        <name>srcSet</name></member>                         <!-- Source descriptor set -->
            <member><type>uint32_t</type>               <name>srcBinding</name></member>                     <!-- Binding within the source descriptor set to copy from -->
            <member><type>uint32_t</type>               <name>srcArrayElement</name></member>                <!-- Array element within the source binding to copy from -->
            <member><type>VkDescriptorSet</type>        <name>dstSet</name></member>                        <!-- Destination descriptor set -->
            <member><type>uint32_t</type>               <name>dstBinding</name></member>                    <!-- Binding within the destination descriptor set to copy to -->
            <member><type>uint32_t</type>               <name>dstArrayElement</name></member>               <!-- Array element within the destination binding to copy to -->
            <member><type>uint32_t</type>               <name>descriptorCount</name></member>                <!-- Number of descriptors to write (determines the size of the array pointed by pDescriptors) -->
            <validity>
                <usage>pname:srcBinding must: be a valid binding within pname:srcSet</usage>
                <usage>The sum of pname:srcArrayElement and pname:descriptorCount must: be less than or equal to the number of array elements in the descriptor set binding specified by pname:srcBinding, and all applicable consecutive bindings, as described by &lt;&lt;descriptorsets-updates-consecutive&gt;&gt;</usage>
                <usage>pname:dstBinding must: be a valid binding within pname:dstSet</usage>
                <usage>The sum of pname:dstArrayElement and pname:descriptorCount must: be less than or equal to the number of array elements in the descriptor set binding specified by pname:dstBinding, and all applicable consecutive bindings, as described by &lt;&lt;descriptorsets-updates-consecutive&gt;&gt;</usage>
                <usage>If pname:srcSet is equal to pname:dstSet, then the source and destination ranges of descriptors mustnot: overlap, where the ranges may: include array elements from consecutive bindings as described by &lt;&lt;descriptorsets-updates-consecutive&gt;&gt;</usage>
            </validity>
        </type>
        <type category="struct" name="VkBufferCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>VkBufferCreateFlags</type>    <name>flags</name></member>                          <!-- Buffer creation flags -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Specified in bytes -->
            <member><type>VkBufferUsageFlags</type>     <name>usage</name></member>                          <!-- Buffer usage flags -->
            <member><type>VkSharingMode</type>          <name>sharingMode</name></member>
            <member optional="true"><type>uint32_t</type>               <name>queueFamilyIndexCount</name></member>
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name></member>
            <validity>
                <usage>pname:size must: be greater than `0`</usage>
                <usage>If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:pQueueFamilyIndices must: be a pointer to an array of pname:queueFamilyIndexCount basetype:uint32_t values</usage>
                <usage>If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:queueFamilyIndexCount must: be greater than `1`</usage>
                <usage>If the &lt;&lt;features-features-sparseBinding,sparse bindings&gt;&gt; feature is not enabled, pname:flags mustnot: contain ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT</usage>
                <usage>If the &lt;&lt;features-features-sparseResidencyBuffer,sparse buffer residency&gt;&gt; feature is not enabled, pname:flags mustnot: contain ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT</usage>
                <usage>If the &lt;&lt;features-features-sparseResidencyAliased,sparse aliased residency&gt;&gt; feature is not enabled, pname:flags mustnot: contain ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT</usage>
                <usage>If pname:flags contains ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT or ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT, it must: also contain ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT</usage>
            </validity>
        </type>
        <type category="struct" name="VkBufferViewCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>VkBufferViewCreateFlags</type><name>flags</name></member>                          <!-- Reserved -->
            <member><type>VkBuffer</type>               <name>buffer</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>                         <!-- Optionally specifies format of elements -->
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>range</name></member>                          <!-- View size specified in bytes -->
            <validity>
                <usage>pname:offset must: be less than the size of pname:buffer</usage>
                <usage>pname:offset must: be a multiple of sname:VkPhysicalDeviceLimits::pname:minTexelBufferOffsetAlignment</usage>
                <usage>If pname:range is not equal to ename:VK_WHOLE_SIZE:
                        ** pname:range must: be greater than `0`
                        ** pname:range must: be a multiple of the element size of pname:format
                        ** pname:range divided by the size of an element of pname:format, must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxTexelBufferElements
                        ** the sum of pname:offset and pname:range must: be less than or equal to the size of pname:buffer</usage>
                <usage>pname:buffer must: have been created with a pname:usage value containing at least one of ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</usage>
                <usage>If pname:buffer was created with pname:usage containing ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT, pname:format must: be supported for uniform texel buffers, as specified by the ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT flag in sname:VkFormatProperties::pname:bufferFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage>If pname:buffer was created with pname:usage containing ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, pname:format must: be supported for storage texel buffers, as specified by the ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT flag in sname:VkFormatProperties::pname:bufferFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
            </validity>
        </type>
        <type category="struct" name="VkImageSubresource">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>mipLevel</name></member>
            <member><type>uint32_t</type>               <name>arrayLayer</name></member>
            <validity>
                <usage>pname:mipLevel must: be less than the pname:mipLevels specified in slink:VkImageCreateInfo when the image was created</usage>
                <usage>pname:arrayLayer must: be less than the pname:arrayLayers specified in slink:VkImageCreateInfo when the image was created</usage>
            </validity>
        </type>
        <type category="struct" name="VkImageSubresourceLayers">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>mipLevel</name></member>
            <member><type>uint32_t</type>               <name>baseArrayLayer</name></member>
            <member><type>uint32_t</type>               <name>layerCount</name></member>
            <validity>
                <usage>If pname:aspectMask contains ename:VK_IMAGE_ASPECT_COLOR_BIT, it mustnot: contain either of ename:VK_IMAGE_ASPECT_DEPTH_BIT or ename:VK_IMAGE_ASPECT_STENCIL_BIT</usage>
                <usage>pname:aspectMask mustnot: contain ename:VK_IMAGE_ASPECT_METADATA_BIT</usage>
                <usage>pname:mipLevel must: be less than the pname:mipLevels specified in slink:VkImageCreateInfo when the image was created</usage>
                <usage>latexmath:[$(baseArrayLayer + layerCount)$] must: be less than or equal to the pname:arrayLayers specified in slink:VkImageCreateInfo when the image was created</usage>
            </validity>
        </type>
        <type category="struct" name="VkImageSubresourceRange">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>baseMipLevel</name></member>
            <member><type>uint32_t</type>               <name>levelCount</name></member>
            <member><type>uint32_t</type>               <name>baseArrayLayer</name></member>
            <member><type>uint32_t</type>               <name>layerCount</name></member>
            <validity>
                <usage>If pname:levelCount is not ename:VK_REMAINING_MIP_LEVELS, latexmath:[$(baseMipLevel + levelCount)$] must: be less than or equal to the pname:mipLevels specified in slink:VkImageCreateInfo when the image was created</usage>
                <usage>If pname:layerCount is not ename:VK_REMAINING_ARRAY_LAYERS, latexmath:[$(baseArrayLayer + layerCount)$] must: be less than or equal to the pname:arrayLayers specified in slink:VkImageCreateInfo when the image was created</usage>
            </validity>
        </type>
        <type category="struct" name="VkMemoryBarrier">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_MEMORY_BARRIER -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name></member>                  <!-- Memory accesses from the source of the dependency to synchronize -->
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name></member>                  <!-- Memory accesses from the destination of the dependency to synchronize -->
        </type>
        <type category="struct" name="VkBufferMemoryBarrier">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name></member>                  <!-- Memory accesses from the source of the dependency to synchronize -->
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name></member>                  <!-- Memory accesses from the destination of the dependency to synchronize -->
            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name></member>            <!-- Queue family to transition ownership from -->
            <member><type>uint32_t</type>               <name>dstQueueFamilyIndex</name></member>           <!-- Queue family to transition ownership to -->
            <member><type>VkBuffer</type>               <name>buffer</name></member>                         <!-- Buffer to sync -->
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Offset within the buffer to sync -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Amount of bytes to sync -->
            <validity>
                <usage>pname:offset must: be less than the size of pname:buffer</usage>
                <usage>If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be greater than `0`</usage>
                <usage>If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be less than or equal to than the size of pname:buffer minus pname:offset</usage>
                <usage>If pname:buffer was created with a sharing mode of ename:VK_SHARING_MODE_CONCURRENT, pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex must: both be ename:VK_QUEUE_FAMILY_IGNORED</usage>
                <usage>If pname:buffer was created with a sharing mode of ename:VK_SHARING_MODE_EXCLUSIVE, pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex must: either both be ename:VK_QUEUE_FAMILY_IGNORED, or both be a valid queue family (see &lt;&lt;devsandqueues-queueprops&gt;&gt;)</usage>
                <usage>If pname:buffer was created with a sharing mode of ename:VK_SHARING_MODE_EXCLUSIVE, and pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex are valid queue families, at least one of them must: be the same as the family of the queue that will execute this barrier</usage>
            </validity>
        </type>
        <type category="struct" name="VkImageMemoryBarrier">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name></member>                  <!-- Memory accesses from the source of the dependency to synchronize -->
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name></member>                  <!-- Memory accesses from the destination of the dependency to synchronize -->
            <member><type>VkImageLayout</type>          <name>oldLayout</name></member>                      <!-- Current layout of the image -->
            <member><type>VkImageLayout</type>          <name>newLayout</name></member>                      <!-- New layout to transition the image to -->
            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name></member>            <!-- Queue family to transition ownership from -->
            <member><type>uint32_t</type>               <name>dstQueueFamilyIndex</name></member>           <!-- Queue family to transition ownership to -->
            <member><type>VkImage</type>                <name>image</name></member>                          <!-- Image to sync -->
            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name></member>              <!-- Subresource range to sync -->
            <validity>
                <usage>pname:oldLayout must: be ename:VK_IMAGE_LAYOUT_UNDEFINED, ename:VK_IMAGE_LAYOUT_PREINITIALIZED or the current layout of the image region affected by the barrier</usage>
                <usage>pname:newLayout mustnot: be ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED</usage>
                <usage>If pname:image was created with a sharing mode of ename:VK_SHARING_MODE_CONCURRENT, pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex must: both be ename:VK_QUEUE_FAMILY_IGNORED</usage>
                <usage>If pname:image was created with a sharing mode of ename:VK_SHARING_MODE_EXCLUSIVE, pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex must: either both be ename:VK_QUEUE_FAMILY_IGNORED, or both be a valid queue family (see &lt;&lt;devsandqueues-queueprops&gt;&gt;)</usage>
                <usage>If pname:image was created with a sharing mode of ename:VK_SHARING_MODE_EXCLUSIVE, and pname:srcQueueFamilyIndex and pname:dstQueueFamilyIndex are valid queue families, at least one of them must: be the same as the family of the queue that will execute this barrier</usage>
                <usage>pname:subresourceRange must: be a valid image subresource range for the image (see &lt;&lt;resources-image-views&gt;&gt;)</usage>
                <usage>If pname:image has a depth/stencil format with both depth and stencil components, then pname:aspectMask member of pname:subresourceRange must: include both ename:VK_IMAGE_ASPECT_DEPTH_BIT and ename:VK_IMAGE_ASPECT_STENCIL_BIT</usage>
                <usage>If either pname:oldLayout or pname:newLayout is ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then pname:image must: have been created with ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT set</usage>
                <usage>If either pname:oldLayout or pname:newLayout is ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL then pname:image must: have been created with ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set</usage>
                <usage>If either pname:oldLayout or pname:newLayout is ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then pname:image must: have been created with ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set</usage>
                <usage>If either pname:oldLayout or pname:newLayout is ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then pname:image must: have been created with ename:VK_IMAGE_USAGE_SAMPLED_BIT or ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set</usage>
                <usage>If either pname:oldLayout or pname:newLayout is ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then pname:image must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT set</usage>
                <usage>If either pname:oldLayout or pname:newLayout is ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then pname:image must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT set</usage>
            </validity>
        </type>
        <type category="struct" name="VkImageCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>VkImageCreateFlags</type>     <name>flags</name></member>                          <!-- Image creation flags -->
            <member><type>VkImageType</type>            <name>imageType</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
            <member><type>uint32_t</type>               <name>mipLevels</name></member>
            <member><type>uint32_t</type>               <name>arrayLayers</name></member>
            <member><type>VkSampleCountFlagBits</type>  <name>samples</name></member>
            <member><type>VkImageTiling</type>          <name>tiling</name></member>
            <member><type>VkImageUsageFlags</type>      <name>usage</name></member>                          <!-- Image usage flags -->
            <member><type>VkSharingMode</type>          <name>sharingMode</name></member>                    <!-- Cross-queue-family sharing mode -->
            <member optional="true"><type>uint32_t</type>               <name>queueFamilyIndexCount</name></member>          <!-- Number of queue families to share across -->
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name></member>            <!-- Array of queue family indices to share across -->
            <member><type>VkImageLayout</type>          <name>initialLayout</name></member>                  <!-- Initial image layout for all subresources -->
            <validity>
                <usage>If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:pQueueFamilyIndices must: be a pointer to an array of pname:queueFamilyIndexCount basetype:uint32_t values</usage>
                <usage>If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:queueFamilyIndexCount must: be greater than `1`</usage>
                <usage>pname:format mustnot: be ename:VK_FORMAT_UNDEFINED</usage>
                <usage>The pname:width, pname:height, and pname:depth members of pname:extent must: all be greater than `0`</usage>
                <usage>pname:mipLevels must: be greater than `0`</usage>
                <usage>pname:arrayLayers must: be greater than `0`</usage>
                <usage>If pname:imageType is ename:VK_IMAGE_TYPE_1D, pname:extent.width must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxImageDimension1D, or sname:VkImageFormatProperties::pname:maxExtent.width (as returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage and pname:flags equal to those in this structure) - whichever is higher</usage>
                <usage>If pname:imageType is ename:VK_IMAGE_TYPE_2D and pname:flags does not contain ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, pname:extent.width and pname:extent.height must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxImageDimension2D, or sname:VkImageFormatProperties::pname:maxExtent.width/height (as returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage and pname:flags equal to those in this structure) - whichever is higher</usage>
                <usage>If pname:imageType is ename:VK_IMAGE_TYPE_2D and pname:flags contains ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, pname:extent.width and pname:extent.height must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxImageDimensionCube, or sname:VkImageFormatProperties::pname:maxExtent.width/height (as returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage and pname:flags equal to those in this structure) - whichever is higher</usage>
                <usage>If pname:imageType is ename:VK_IMAGE_TYPE_2D and pname:flags contains ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, pname:extent.width and pname:extent.height must: be equal</usage>
                <usage>If pname:imageType is ename:VK_IMAGE_TYPE_3D, pname:extent.width, pname:extent.height and pname:extent.depth must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxImageDimension3D, or sname:VkImageFormatProperties::pname:maxExtent.width/height/depth (as returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage and pname:flags equal to those in this structure) - whichever is higher</usage>
                <usage>If pname:imageType is ename:VK_IMAGE_TYPE_1D, both pname:extent.height and pname:extent.depth must: be `1`</usage>
                <usage>If pname:imageType is ename:VK_IMAGE_TYPE_2D, pname:extent.depth must: be `1`</usage>
                <usage>pname:mipLevels must: be less than or equal to latexmath:[$\lfloor\log_2(\max(\mathit{extent.width}, \mathit{extent.height}, \mathit{extent.depth}))\rfloor + 1$]</usage>
                <usage>If any of pname:extent.width, pname:extent.height or pname:extent.depth are greater than the equivalently named members of sname:VkPhysicalDeviceLimits::pname:maxImageDimension3D, pname:mipLevels must: be less than or equal to sname:VkImageFormatProperties::pname:maxMipLevels (as returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage and pname:flags equal to those in this structure)</usage>
                <usage>pname:arrayLayers must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxImageArrayLayers, or sname:VkImageFormatProperties::pname:maxArrayLayers (as returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage and pname:flags equal to those in this structure) - whichever is higher</usage>
                <usage>pname:samples must: be a bit value that is set in sname:VkPhysicalDeviceLimits::pname:sampleCounts returned by flink:vkGetPhysicalDeviceProperties, or sname:VkImageFormatProperties::pname:sampleCounts returned by fname:vkGetPhysicalDeviceImageFormatProperties with pname:format, pname:type, pname:tiling, pname:usage and pname:flags equal to those in this structure</usage>
                <usage>If pname:usage includes ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT or ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, pname:extent.width must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxFramebufferWidth</usage>
                <usage>If pname:usage includes ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT or ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, pname:extent.height must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxFramebufferHeight</usage>
                <usage>If pname:usage includes ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, pname:samples must: be a bit value that is set in sname:VkPhysicalDeviceLimits::pname:framebufferColorSampleCounts</usage>
                <usage>If pname:usage includes ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and pname:format includes a depth aspect, pname:samples must: be a bit value that is set in sname:VkPhysicalDeviceLimits::pname:framebufferDepthSampleCounts</usage>
                <usage>If pname:usage includes ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and pname:format includes a stencil aspect, pname:samples must: be a bit value that is set in sname:VkPhysicalDeviceLimits::pname:framebufferStencilSampleCounts</usage>
                <usage>If pname:usage includes ename:VK_IMAGE_USAGE_SAMPLED_BIT, and pname:format includes a color aspect, pname:samples must: be a bit value that is set in sname:VkPhysicalDeviceLimits::pname:sampledImageColorSampleCounts</usage>
                <usage>If pname:usage includes ename:VK_IMAGE_USAGE_SAMPLED_BIT, and pname:format includes a depth aspect, pname:samples must: be a bit value that is set in sname:VkPhysicalDeviceLimits::pname:sampledImageDepthSampleCounts</usage>
                <usage>If pname:usage includes ename:VK_IMAGE_USAGE_SAMPLED_BIT, and pname:format is an integer format, pname:samples must: be a bit value that is set in sname:VkPhysicalDeviceLimits::pname:sampledImageIntegerSampleCounts</usage>
                <usage>If pname:usage includes ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:samples must: be a bit value that is set in sname:VkPhysicalDeviceLimits::pname:storageImageSampleCounts</usage>
                <usage>If the &lt;&lt;features-features-textureCompressionETC2,ETC2 texture compression&gt;&gt; feature is not enabled, pname:format mustnot: be ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK, ename:VK_FORMAT_EAC_R11_UNORM_BLOCK, ename:VK_FORMAT_EAC_R11_SNORM_BLOCK, ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK, or ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK</usage>
                <usage>If the &lt;&lt;features-features-textureCompressionASTC_LDR,ASTC LDR texture compression&gt;&gt; feature is not enabled, pname:format mustnot: be ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK, ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK, ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK, ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK, ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK, ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK, ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK, ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK, ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK, ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK, ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK, ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK, ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK, or ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK</usage>
                <usage>If the &lt;&lt;features-features-textureCompressionBC,BC texture compression&gt;&gt; feature is not enabled, pname:format mustnot: be ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK, ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK, ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK, ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK, ename:VK_FORMAT_BC2_UNORM_BLOCK, ename:VK_FORMAT_BC2_SRGB_BLOCK, ename:VK_FORMAT_BC3_UNORM_BLOCK, ename:VK_FORMAT_BC3_SRGB_BLOCK, ename:VK_FORMAT_BC4_UNORM_BLOCK, ename:VK_FORMAT_BC4_SNORM_BLOCK, ename:VK_FORMAT_BC5_UNORM_BLOCK, ename:VK_FORMAT_BC5_SNORM_BLOCK, ename:VK_FORMAT_BC6H_UFLOAT_BLOCK, ename:VK_FORMAT_BC6H_SFLOAT_BLOCK, ename:VK_FORMAT_BC7_UNORM_BLOCK, or ename:VK_FORMAT_BC7_SRGB_BLOCK</usage>
                <usage>If the &lt;&lt;features-features-shaderStorageImageMultisample,multisampled storage images&gt;&gt; feature is not enabled, and pname:usage contains ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:samples must: be ename:VK_SAMPLE_COUNT_1_BIT</usage>
                <usage>If the &lt;&lt;features-features-sparseBinding,sparse bindings&gt;&gt; feature is not enabled, pname:flags mustnot: contain ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT</usage>
                <usage>If the &lt;&lt;features-features-sparseResidencyImage2D,sparse residency for 2D images&gt;&gt; feature is not enabled, and pname:imageType is ename:VK_IMAGE_TYPE_2D, pname:flags mustnot: contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</usage>
                <usage>If the &lt;&lt;features-features-sparseResidencyImage3D,sparse residency for 3D images&gt;&gt; feature is not enabled, and pname:imageType is ename:VK_IMAGE_TYPE_3D, pname:flags mustnot: contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</usage>
                <usage>If the &lt;&lt;features-features-sparseResidency2Samples,sparse residency for images with 2 samples&gt;&gt; feature is not enabled, pname:imageType is ename:VK_IMAGE_TYPE_2D, and pname:samples is ename:VK_SAMPLE_COUNT_2_BIT, pname:flags mustnot: contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</usage>
                <usage>If the &lt;&lt;features-features-sparseResidency4Samples,sparse residency for images with 4 samples&gt;&gt; feature is not enabled, pname:imageType is ename:VK_IMAGE_TYPE_2D, and pname:samples is ename:VK_SAMPLE_COUNT_4_BIT, pname:flags mustnot: contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</usage>
                <usage>If the &lt;&lt;features-features-sparseResidency8Samples,sparse residency for images with 8 samples&gt;&gt; feature is not enabled, pname:imageType is ename:VK_IMAGE_TYPE_2D, and pname:samples is ename:VK_SAMPLE_COUNT_8_BIT, pname:flags mustnot: contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</usage>
                <usage>If the &lt;&lt;features-features-sparseResidency16Samples,sparse residency for images with 16 samples&gt;&gt; feature is not enabled, pname:imageType is ename:VK_IMAGE_TYPE_2D, and pname:samples is ename:VK_SAMPLE_COUNT_16_BIT, pname:flags mustnot: contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</usage>
                <usage>If pname:tiling is ename:VK_IMAGE_TILING_LINEAR, and sname:VkFormatProperties::pname:linearTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, pname:usage mustnot: contain ename:VK_IMAGE_USAGE_SAMPLED_BIT</usage>
                <usage>If pname:tiling is ename:VK_IMAGE_TILING_LINEAR, and sname:VkFormatProperties::pname:linearTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT, pname:usage mustnot: contain ename:VK_IMAGE_USAGE_STORAGE_BIT</usage>
                <usage>If pname:tiling is ename:VK_IMAGE_TILING_LINEAR, and sname:VkFormatProperties::pname:linearTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT, pname:usage mustnot: contain ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</usage>
                <usage>If pname:tiling is ename:VK_IMAGE_TILING_LINEAR, and sname:VkFormatProperties::pname:linearTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:usage mustnot: contain ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</usage>
                <usage>If pname:tiling is ename:VK_IMAGE_TILING_OPTIMAL, and sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, pname:usage mustnot: contain ename:VK_IMAGE_USAGE_SAMPLED_BIT</usage>
                <usage>If pname:tiling is ename:VK_IMAGE_TILING_OPTIMAL, and sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT, pname:usage mustnot: contain ename:VK_IMAGE_USAGE_STORAGE_BIT</usage>
                <usage>If pname:tiling is ename:VK_IMAGE_TILING_OPTIMAL, and sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT, pname:usage mustnot: contain ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</usage>
                <usage>If pname:tiling is ename:VK_IMAGE_TILING_OPTIMAL, and sname:VkFormatProperties::pname:optimalTilingFeatures (as returned by fname:vkGetPhysicalDeviceFormatProperties with the same value of pname:format) does not include ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:usage mustnot: contain ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</usage>
                <usage>If pname:flags contains ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT or ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT, it must: also contain ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT</usage>
            </validity>
        </type>
        <type category="struct" name="VkSubresourceLayout" returnedonly="true">
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>rowPitch</name></member>                       <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>arrayPitch</name></member>                     <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>depthPitch</name></member>                     <!-- Specified in bytes -->
        </type>
        <type category="struct" name="VkImageViewCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkImageViewCreateFlags</type> <name>flags</name></member>                          <!-- Reserved -->
            <member><type>VkImage</type>                <name>image</name></member>
            <member><type>VkImageViewType</type>        <name>viewType</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkComponentMapping</type>     <name>components</name></member>
            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name></member>
            <validity>
                <usage>If pname:image was not created with ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT then pname:viewType mustnot: be ename:VK_IMAGE_VIEW_TYPE_CUBE or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</usage>
                <usage>If the &lt;&lt;features-features-imageCubeArray,image cubemap arrays&gt;&gt; feature is not enabled, pname:viewType mustnot: be ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</usage>
                <usage>If the &lt;&lt;features-features-textureCompressionETC2,ETC2 texture compression&gt;&gt; feature is not enabled, pname:format mustnot: be ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK, ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK, ename:VK_FORMAT_EAC_R11_UNORM_BLOCK, ename:VK_FORMAT_EAC_R11_SNORM_BLOCK, ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK, or ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK</usage>
                <usage>If the &lt;&lt;features-features-textureCompressionASTC_LDR,ASTC LDR texture compression&gt;&gt; feature is not enabled, pname:format mustnot: be ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK, ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK, ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK, ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK, ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK, ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK, ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK, ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK, ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK, ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK, ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK, ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK, ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK, ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK, ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK, or ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK</usage>
                <usage>If the &lt;&lt;features-features-textureCompressionBC,BC texture compression&gt;&gt; feature is not enabled, pname:format mustnot: be ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK, ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK, ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK, ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK, ename:VK_FORMAT_BC2_UNORM_BLOCK, ename:VK_FORMAT_BC2_SRGB_BLOCK, ename:VK_FORMAT_BC3_UNORM_BLOCK, ename:VK_FORMAT_BC3_SRGB_BLOCK, ename:VK_FORMAT_BC4_UNORM_BLOCK, ename:VK_FORMAT_BC4_SNORM_BLOCK, ename:VK_FORMAT_BC5_UNORM_BLOCK, ename:VK_FORMAT_BC5_SNORM_BLOCK, ename:VK_FORMAT_BC6H_UFLOAT_BLOCK, ename:VK_FORMAT_BC6H_SFLOAT_BLOCK, ename:VK_FORMAT_BC7_UNORM_BLOCK, or ename:VK_FORMAT_BC7_SRGB_BLOCK</usage>
                <usage>If pname:image was created with ename:VK_IMAGE_TILING_LINEAR and pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, pname:format must: be supported for sampled images, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage>If pname:image was created with ename:VK_IMAGE_TILING_LINEAR and pname:usage containing ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:format must: be supported for storage images, as specified by the ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage>If pname:image was created with ename:VK_IMAGE_TILING_LINEAR and pname:usage containing ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, pname:format must: be supported for color attachments, as specified by the ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage>If pname:image was created with ename:VK_IMAGE_TILING_LINEAR and pname:usage containing ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:format must: be supported for depth/stencil attachments, as specified by the ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage>If pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL and pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, pname:format must: be supported for sampled images, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT flag in sname:VkFormatProperties::pname:optimalTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage>If pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL and pname:usage containing ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:format must: be supported for storage images, as specified by the ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT flag in sname:VkFormatProperties::pname:optimalTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage>If pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL and pname:usage containing ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, pname:format must: be supported for color attachments, as specified by the ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT flag in sname:VkFormatProperties::pname:optimalTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage>If pname:image was created with ename:VK_IMAGE_TILING_OPTIMAL and pname:usage containing ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, pname:format must: be supported for depth/stencil attachments, as specified by the ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT flag in sname:VkFormatProperties::pname:optimalTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage>pname:subresourceRange must: be a valid image subresource range for pname:image (see &lt;&lt;resources-image-views&gt;&gt;)</usage>
                <usage>If pname:image was created with the ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, pname:format must: be compatible with the pname:format used to create pname:image, as defined in &lt;&lt;features-formats-compatibility-classes,Format Compatibility Classes&gt;&gt;</usage>
                <usage>If pname:image was not created with the ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, pname:format must: be identical to the pname:format used to create pname:image</usage>
                <usage>pname:subResourceRange and pname:viewType must: be compatible with the image, as described in the &lt;&lt;resources-image-views-compatibility,table below&gt;&gt;</usage>
            </validity>
        </type>
        <type category="struct" name="VkBufferCopy">
            <member><type>VkDeviceSize</type>           <name>srcOffset</name></member>                      <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>dstOffset</name></member>                     <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Specified in bytes -->
        </type>
        <type category="struct" name="VkSparseMemoryBind">
            <member><type>VkDeviceSize</type>           <name>resourceOffset</name></member>                 <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Specified in bytes -->
            <member optional="true"><type>VkDeviceMemory</type>         <name>memory</name></member>
            <member><type>VkDeviceSize</type>           <name>memoryOffset</name></member>                   <!-- Specified in bytes -->
            <member optional="true"><type>VkSparseMemoryBindFlags</type><name>flags</name></member>                          <!-- Reserved for future -->
            <validity>
                <usage>If pname:memory is not sname:VK_NULL_HANDLE, pname:memory and pname:memoryOffset must: match the memory requirements of the resource, as described in section &lt;&lt;resources-association&gt;&gt;</usage>
                <usage>If pname:memory is not sname:VK_NULL_HANDLE, pname:memory mustnot: have been created with a memory type that reports ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set</usage>
                <usage>pname:size must: be greater than `0`</usage>
                <usage>pname:resourceOffset must: be less than the size of the resource</usage>
                <usage>pname:size must: be less than or equal to the size of the resource minus pname:resourceOffset</usage>
                <usage>pname:memoryOffset must: be less than the size of pname:memory</usage>
                <usage>pname:size must: be less than or equal to the size of pname:memory minus pname:memoryOffset</usage>
            </validity>
        </type>
        <type category="struct" name="VkSparseImageMemoryBind">
            <member><type>VkImageSubresource</type>     <name>subresource</name></member>
            <member><type>VkOffset3D</type>             <name>offset</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
            <member optional="true"><type>VkDeviceMemory</type>         <name>memory</name></member>
            <member><type>VkDeviceSize</type>           <name>memoryOffset</name></member>                   <!-- Specified in bytes -->
            <member optional="true"><type>VkSparseMemoryBindFlags</type><name>flags</name></member>                          <!-- Reserved for future -->
            <validity>
                <usage>If the &lt;&lt;features-features-sparseResidencyAliased,sparse aliased residency&gt;&gt; feature is not enabled, and if any other resources are bound to ranges of pname:memory, the range of pname:memory being bound mustnot: overlap with those bound ranges</usage>
                <usage>pname:memory and pname:memoryOffset must: match the memory requirements of the calling command's pname:image, as described in section &lt;&lt;resources-association&gt;&gt;</usage>
                <usage>pname:subresource must: be a valid image subresource for pname:image (see &lt;&lt;resources-image-views&gt;&gt;)</usage>
                <usage>pname:offset.x must: be a multiple of the sparse image block width (sname:VkSparseImageFormatProperties::pname:imageGranularity.width) of the image</usage>
                <usage>pname:extent.width must: either be a multiple of the sparse image block width of the image, or else pname:extent.width + pname:offset.x must: equal the width of the image subresource</usage>
                <usage>pname:offset.y must: be a multiple of the sparse image block height (sname:VkSparseImageFormatProperties::pname:imageGranularity.height) of the image</usage>
                <usage>pname:extent.height must: either be a multiple of the sparse image block height of the image, or else pname:extent.height + pname:offset.y must: equal the height of the image subresource</usage>
                <usage>pname:offset.z must: be a multiple of the sparse image block depth (sname:VkSparseImageFormatProperties::pname:imageGranularity.depth) of the image</usage>
                <usage>pname:extent.depth must: either be a multiple of the sparse image block depth of the image, or else pname:extent.depth + pname:offset.z must: equal the depth of the image subresource</usage>
            </validity>
    </type>
        <type category="struct" name="VkSparseBufferMemoryBindInfo">
            <member><type>VkBuffer</type> <name>buffer</name></member>
            <member><type>uint32_t</type>               <name>bindCount</name></member>
            <member len="bindCount">const <type>VkSparseMemoryBind</type>* <name>pBinds</name></member>
        </type>
        <type category="struct" name="VkSparseImageOpaqueMemoryBindInfo">
            <member><type>VkImage</type> <name>image</name></member>
            <member><type>uint32_t</type>               <name>bindCount</name></member>
            <member len="bindCount">const <type>VkSparseMemoryBind</type>* <name>pBinds</name></member>
            <validity>
                <usage>For any given element of pname:pBinds, if the pname:flags member of that element contains ename:VK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range defined must: be within the mip tail region of the metadata aspect of pname:image</usage>
            </validity>
        </type>
        <type category="struct" name="VkSparseImageMemoryBindInfo">
            <member><type>VkImage</type> <name>image</name></member>
            <member><type>uint32_t</type>               <name>bindCount</name></member>
            <member len="bindCount">const <type>VkSparseImageMemoryBind</type>* <name>pBinds</name></member>
        </type>
        <type category="struct" name="VkBindSparseInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_BIND_SPARSE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member optional="true"><type>uint32_t</type>               <name>waitSemaphoreCount</name></member>
            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>*     <name>pWaitSemaphores</name></member>
            <member optional="true"><type>uint32_t</type>               <name>bufferBindCount</name></member>
            <member len="bufferBindCount">const <type>VkSparseBufferMemoryBindInfo</type>* <name>pBufferBinds</name></member>
            <member optional="true"><type>uint32_t</type>               <name>imageOpaqueBindCount</name></member>
            <member len="imageOpaqueBindCount">const <type>VkSparseImageOpaqueMemoryBindInfo</type>* <name>pImageOpaqueBinds</name></member>
            <member optional="true"><type>uint32_t</type>               <name>imageBindCount</name></member>
            <member len="imageBindCount">const <type>VkSparseImageMemoryBindInfo</type>* <name>pImageBinds</name></member>
            <member optional="true"><type>uint32_t</type>               <name>signalSemaphoreCount</name></member>
            <member len="signalSemaphoreCount">const <type>VkSemaphore</type>*     <name>pSignalSemaphores</name></member>
        </type>
        <type category="struct" name="VkImageCopy">
            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffset</name></member>                      <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>dstOffset</name></member>                     <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkExtent3D</type>             <name>extent</name></member>                         <!-- Specified in pixels for both compressed and uncompressed images -->
            <validity>
                <usage>The pname:aspectMask member of pname:srcSubresource and pname:dstSubresource must: match</usage>
                <usage>The pname:layerCount member of pname:srcSubresource and pname:dstSubresource must: match</usage>
                <usage>If either of the calling command's pname:srcImage or pname:dstImage parameters are of elink:VkImageType ename:VK_IMAGE_TYPE_3D, the pname:baseArrayLayer and pname:layerCount members of both pname:srcSubresource and pname:dstSubresource must: be `0` and `1`, respectively</usage>
                <usage>The pname:aspectMask member of pname:srcSubresource must: specify aspects present in the calling command's pname:srcImage</usage>
                <usage>The pname:aspectMask member of pname:dstSubresource must: specify aspects present in the calling command's pname:dstImage</usage>
                <usage>pname:srcOffset.x and (pname:extent.width + pname:srcOffset.x) must: both be greater than or equal to `0` and less than or equal to the source image subresource width</usage>
                <usage>pname:srcOffset.y and (pname:extent.height + pname:srcOffset.y) must: both be greater than or equal to `0` and less than or equal to the source image subresource height</usage>
                <usage>pname:srcOffset.z and (pname:extent.depth + pname:srcOffset.z) must: both be greater than or equal to `0` and less than or equal to the source image subresource depth</usage>
                <usage>pname:dstOffset.x and (pname:extent.width + pname:dstOffset.x) must: both be greater than or equal to `0` and less than or equal to the destination image subresource width</usage>
                <usage>pname:dstOffset.y and (pname:extent.height + pname:dstOffset.y) must: both be greater than or equal to `0` and less than or equal to the destination image subresource height</usage>
                <usage>pname:dstOffset.z and (pname:extent.depth + pname:dstOffset.z) must: both be greater than or equal to `0` and less than or equal to the destination image subresource depth</usage>
                <usage>If the calling command's pname:srcImage is a compressed format image:
                        ** all members of pname:srcOffset must: be a multiple of the corresponding dimensions of the compressed texel block
                        ** pname:extent.width must: be a multiple of the compressed texel block width or (pname:extent.width + pname:srcOffset.x) must: equal the source image subresource width
                        ** pname:extent.height must: be a multiple of the compressed texel block height or (pname:extent.height + pname:srcOffset.y) must: equal the source image subresource height
                        ** pname:extent.depth must: be a multiple of the compressed texel block depth or (pname:extent.depth + pname:srcOffset.z) must: equal the source image subresource depth</usage>
                <usage>If the calling command's pname:dstImage is a compressed format image:
                        ** all members of pname:dstOffset must: be a multiple of the corresponding dimensions of the compressed texel block
                        ** pname:extent.width must: be a multiple of the compressed texel block width or (pname:extent.width + pname:dstOffset.x) must: equal the destination image subresource width
                        ** pname:extent.height must: be a multiple of the compressed texel block height or (pname:extent.height + pname:dstOffset.y) must: equal the destination image subresource height
                        ** pname:extent.depth must: be a multiple of the compressed texel block depth or (pname:extent.depth + pname:dstOffset.z) must: equal the destination image subresource depth</usage>
                <usage>pname:srcOffset, pname:dstOffset, and pname:extent must: respect the image transfer granularity requirements of the queue family that it will be submitted against, as described in &lt;&lt;devsandqueues-physical-device-enumeration,Physical Device Enumeration&gt;&gt;</usage>
            </validity>
        </type>
        <type category="struct" name="VkImageBlit">
            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffsets</name>[2]</member>                      <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>dstOffsets</name>[2]</member>                     <!-- Specified in pixels for both compressed and uncompressed images -->
            <validity>
                <usage>The pname:aspectMask member of pname:srcSubresource and pname:dstSubresource must: match</usage>
                <usage>The pname:layerCount member of pname:srcSubresource and pname:dstSubresource must: match</usage>
                <usage>If either of the calling command's pname:srcImage or pname:dstImage parameters are of elink:VkImageType ename:VK_IMAGE_TYPE_3D, the pname:baseArrayLayer and pname:layerCount members of both pname:srcSubresource and pname:dstSubresource must: be `0` and `1`, respectively</usage>
                <usage>The pname:aspectMask member of pname:srcSubresource must: specify aspects present in the calling command's pname:srcImage</usage>
                <usage>The pname:aspectMask member of pname:dstSubresource must: specify aspects present in the calling command's pname:dstImage</usage>
                <usage>pname:srcOffset[0].x and pname:srcOffset[1].x must: both be greater than or equal to `0` and less than or equal to the source image subresource width</usage>
                <usage>pname:srcOffset[0].y and pname:srcOffset[1].y must: both be greater than or equal to `0` and less than or equal to the source image subresource height</usage>
                <usage>pname:srcOffset[0].z and pname:srcOffset[1].z must: both be greater than or equal to `0` and less than or equal to the source image subresource depth</usage>
                <usage>pname:dstOffset[0].x and pname:dstOffset[1].x must: both be greater than or equal to `0` and less than or equal to the destination image subresource width</usage>
                <usage>pname:dstOffset[0].y and pname:dstOffset[1].y must: both be greater than or equal to `0` and less than or equal to the destination image subresource height</usage>
                <usage>pname:dstOffset[0].z and pname:dstOffset[1].z must: both be greater than or equal to `0` and less than or equal to the destination image subresource depth</usage>
            </validity>
        </type>
        <type category="struct" name="VkBufferImageCopy">
            <member><type>VkDeviceSize</type>           <name>bufferOffset</name></member>                   <!-- Specified in bytes -->
            <member><type>uint32_t</type>               <name>bufferRowLength</name></member>                <!-- Specified in texels -->
            <member><type>uint32_t</type>               <name>bufferImageHeight</name></member>
            <member><type>VkImageSubresourceLayers</type> <name>imageSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>imageOffset</name></member>                    <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkExtent3D</type>             <name>imageExtent</name></member>                    <!-- Specified in pixels for both compressed and uncompressed images -->
            <validity>
                <usage>pname:bufferOffset must: be a multiple of the calling command's sname:VkImage parameter's texel size</usage>
                <usage>pname:bufferOffset must: be a multiple of `4`</usage>
                <usage>pname:bufferRowLength must: be `0`, or greater than or equal to the pname:width member of pname:imageExtent</usage>
                <usage>pname:bufferImageHeight must: be `0`, or greater than or equal to the pname:height member of pname:imageExtent</usage>
                <usage>pname:imageOffset.x and (pname:imageExtent.width + pname:imageOffset.x) must: both be greater than or equal to `0` and less than or equal to the image subresource width</usage>
                <usage>pname:imageOffset.y and (imageExtent.height + pname:imageOffset.y) must: both be greater than or equal to `0` and less than or equal to the image subresource height</usage>
                <usage>pname:imageOffset.z and (imageExtent.depth + pname:imageOffset.z) must: both be greater than or equal to `0` and less than or equal to the image subresource depth</usage>
                <usage>If the calling command's sname:VkImage parameter is a compressed format image:
                        ** pname:bufferRowLength must: be a multiple of the compressed texel block width
                        ** pname:bufferImageHeight must: be a multiple of the compressed texel block height
                        ** all members of pname:imageOffset must: be a multiple of the corresponding dimensions of the compressed texel block
                        ** pname:bufferOffset must: be a multiple of the compressed texel block size in bytes
                        ** pname:imageExtent.width must: be a multiple of the compressed texel block width or (pname:imageExtent.width + pname:imageOffset.x) must: equal the image subresource width
                        ** pname:imageExtent.height must: be a multiple of the compressed texel block height or (pname:imageExtent.height + pname:imageOffset.y) must: equal the image subresource height
                        ** pname:imageExtent.depth must: be a multiple of the compressed texel block depth or (pname:imageExtent.depth + pname:imageOffset.z) must: equal the image subresource depth</usage>
                <usage>pname:bufferOffset, pname:bufferRowLength, pname:bufferImageHeight and all members of pname:imageOffset and pname:imageExtent must: respect the image transfer granularity requirements of the queue family that it will be submitted against, as described in &lt;&lt;devsandqueues-physical-device-enumeration,Physical Device Enumeration&gt;&gt;</usage>
                <usage>The pname:aspectMask member of pname:imageSubresource must: specify aspects present in the calling command's sname:VkImage parameter</usage>
                <usage>The pname:aspectMask member of pname:imageSubresource must: only have a single bit set</usage>
                <usage>If the calling command's sname:VkImage parameter is of elink:VkImageType ename:VK_IMAGE_TYPE_3D, the pname:baseArrayLayer and pname:layerCount members of pname:imageSubresource must: be `0` and `1`, respectively</usage>
            </validity>
        </type>
        <type category="struct" name="VkImageResolve">
            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffset</name></member>
            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>dstOffset</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
            <validity>
                <usage>The pname:aspectMask member of pname:srcSubresource and pname:dstSubresource must: only contain ename:VK_IMAGE_ASPECT_COLOR_BIT</usage>
                <usage>The pname:layerCount member of pname:srcSubresource and pname:dstSubresource must: match</usage>
                <usage>If either of the calling command's pname:srcImage or pname:dstImage parameters are of elink:VkImageType ename:VK_IMAGE_TYPE_3D, the pname:baseArrayLayer and pname:layerCount members of both pname:srcSubresource and pname:dstSubresource must: be `0` and `1`, respectively</usage>
            </validity>
        </type>
        <type category="struct" name="VkShaderModuleCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkShaderModuleCreateFlags</type> <name>flags</name></member>                       <!-- Reserved -->
            <member><type>size_t</type>                 <name>codeSize</name></member>                       <!-- Specified in bytes -->
            <member len="latexmath:[$codeSize \over 4$]">const <type>uint32_t</type>*            <name>pCode</name></member>                          <!-- Binary code of size codeSize -->
            <validity>
                <usage>pname:codeSize must: be greater than 0</usage>
                <usage>pname:codeSize must: be a multiple of 4</usage>
                <usage>pname:pCode must: point to valid SPIR-V code, formatted and packed as described by https://www.khronos.org/registry/spir-v/specs/1.0/SPIRV.html[the SPIR-V Specification v1.0]</usage>
                <usage>pname:pCode must: adhere to the validation rules described by the &lt;&lt;spirvenv-module-validation, Validation Rules within a Module&gt;&gt; section of the &lt;&lt;spirvenv-capabilities,SPIR-V Environment&gt;&gt; appendix</usage>
                <usage>pname:pCode must: declare the code:Shader capability</usage>
                <usage>pname:pCode mustnot: declare any capability that is not supported by the API, as described by the &lt;&lt;spirvenv-module-validation, Capabilities&gt;&gt; section of the &lt;&lt;spirvenv-capabilities,SPIR-V Environment&gt;&gt; appendix</usage>
                <usage>If pname:pCode declares any of the capabilities that are listed as not required by the implementation, the relevant feature must: be enabled, as listed in the &lt;&lt;spirvenv-capabilities-table,SPIR-V Environment&gt;&gt; appendix</usage>
            </validity>
        </type>
        <type category="struct" name="VkDescriptorSetLayoutBinding">
            <member><type>uint32_t</type>               <name>binding</name></member>                        <!-- Binding number for this entry -->
            <member><type>VkDescriptorType</type>       <name>descriptorType</name></member>                 <!-- Type of the descriptors in this binding -->
            <member optional="true"><type>uint32_t</type> <name>descriptorCount</name></member>              <!-- Number of descriptors in this binding -->
            <member noautovalidity="true"><type>VkShaderStageFlags</type>     <name>stageFlags</name></member>                     <!-- Shader stages this binding is visible to -->
            <member noautovalidity="true" optional="true" len="descriptorCount">const <type>VkSampler</type>*       <name>pImmutableSamplers</name></member>             <!-- Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements) -->
            <validity>
                <usage>If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and pname:descriptorCount is not `0` and pname:pImmutableSamplers is not `NULL`, pname:pImmutableSamplers must: be a pointer to an array of pname:descriptorCount valid sname:VkSampler handles</usage>
                <usage>If pname:descriptorCount is not `0`, pname:stageFlags must: be a valid combination of elink:VkShaderStageFlagBits values</usage>
            </validity>
        </type>
        <type category="struct" name="VkDescriptorSetLayoutCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkDescriptorSetLayoutCreateFlags</type>    <name>flags</name></member>             <!-- Reserved -->
            <member optional="true"><type>uint32_t</type>               <name>bindingCount</name></member>                   <!-- Number of bindings in the descriptor set layout -->
            <member len="bindingCount">const <type>VkDescriptorSetLayoutBinding</type>* <name>pBindings</name></member>       <!-- Array of descriptor set layout bindings -->
        </type>
        <type category="struct" name="VkDescriptorPoolSize">
            <member><type>VkDescriptorType</type>       <name>type</name></member>
            <member><type>uint32_t</type>               <name>descriptorCount</name></member>
            <validity>
                <usage>pname:descriptorCount must: be greater than `0`</usage>
            </validity>
        </type>
        <type category="struct" name="VkDescriptorPoolCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkDescriptorPoolCreateFlags</type>  <name>flags</name></member>
            <member><type>uint32_t</type>               <name>maxSets</name></member>
            <member><type>uint32_t</type>               <name>poolSizeCount</name></member>
            <member len="poolSizeCount">const <type>VkDescriptorPoolSize</type>* <name>pPoolSizes</name></member>
            <validity>
                <usage>pname:maxSets must: be greater than `0`</usage>
            </validity>
        </type>
        <type category="struct" name="VkDescriptorSetAllocateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDescriptorPool</type> <name>descriptorPool</name></member>
            <member><type>uint32_t</type>               <name>descriptorSetCount</name></member>
            <member len="descriptorSetCount">const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name></member>
            <validity>
                <usage>pname:descriptorSetCount mustnot: be greater than the number of sets that are currently available for allocation in pname:descriptorPool</usage>
                <usage>pname:descriptorPool must: have enough free descriptor capacity remaining to allocate the descriptor sets of the specified layouts</usage>
            </validity>
        </type>
        <type category="struct" name="VkSpecializationMapEntry">
            <member><type>uint32_t</type>               <name>constantID</name></member>                     <!-- The SpecConstant ID specified in the BIL -->
            <member><type>uint32_t</type>               <name>offset</name></member>                         <!-- Offset of the value in the data block -->
            <member><type>size_t</type>                 <name>size</name></member>                           <!-- Size in bytes of the SpecConstant -->
        </type>
        <type category="struct" name="VkSpecializationInfo">
            <member optional="true"><type>uint32_t</type>               <name>mapEntryCount</name></member>                  <!-- Number of entries in the map -->
            <member len="mapEntryCount">const <type>VkSpecializationMapEntry</type>* <name>pMapEntries</name></member>                  <!-- Array of map entries -->
            <member optional="true"><type>size_t</type>                 <name>dataSize</name></member>                       <!-- Size in bytes of pData -->
            <member len="dataSize">const <type>void</type>*            <name>pData</name></member>                          <!-- Pointer to SpecConstant data -->
            <validity>
                <usage>The pname:offset member of any given element of pname:pMapEntries must: be less than pname:dataSize</usage>
                <usage>For any given element of pname:pMapEntries, pname:size must: be less than or equal to pname:dataSize minus pname:offset</usage>
            </validity>
        </type>
        <type category="struct" name="VkPipelineShaderStageCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineShaderStageCreateFlags</type>    <name>flags</name></member>             <!-- Reserved -->
            <member><type>VkShaderStageFlagBits</type>  <name>stage</name></member>                          <!-- Shader stage -->
            <member><type>VkShaderModule</type>         <name>module</name></member>                         <!-- Module containing entry point -->
            <member len="null-terminated">const <type>char</type>*            <name>pName</name></member>                          <!-- Null-terminated entry point name -->
            <member optional="true">const <type>VkSpecializationInfo</type>* <name>pSpecializationInfo</name></member>
            <validity>
                <usage>If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:stage mustnot: be ename:VK_SHADER_STAGE_GEOMETRY_BIT</usage>
                <usage>If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:stage mustnot: be ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT</usage>
                <usage>pname:stage mustnot: be ename:VK_SHADER_STAGE_ALL_GRAPHICS, or ename:VK_SHADER_STAGE_ALL</usage>
                <usage>pname:pName must: be the name of an code:OpEntryPoint in pname:module with an execution model that matches pname:stage</usage>
                <usage>If the identified entry point includes any variable in its interface that is declared with the code:ClipDistance code:BuiltIn decoration, that variable mustnot: have an array size greater than sname:VkPhysicalDeviceLimits::pname:maxClipDistances</usage>
                <usage>If the identified entry point includes any variable in its interface that is declared with the code:CullDistance code:BuiltIn decoration, that variable mustnot: have an array size greater than sname:VkPhysicalDeviceLimits::pname:maxCullDistances</usage>
                <usage>If the identified entry point includes any variables in its interface that are declared with the code:ClipDistance or code:CullDistance code:BuiltIn decoration, those variables mustnot: have array sizes which sum to more than sname:VkPhysicalDeviceLimits::pname:maxCombinedClipAndCullDistances</usage>
                <usage>If the identified entry point includes any variable in its interface that is declared with the code:SampleMask code:BuiltIn decoration, that variable mustnot: have an array size greater than sname:VkPhysicalDeviceLimits::pname:maxSampleMaskWords</usage>
                <usage>If pname:stage is ename:VK_SHADER_STAGE_VERTEX_BIT, the identified entry point mustnot: include any input variable in its interface that is decorated with code:CullDistance</usage>
                <usage>If pname:stage is ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, and the identified entry point has an code:OpExecutionMode instruction that specifies a patch size with code:OutputVertices, the patch size must: be greater than `0` and less than or equal to sname:VkPhysicalDeviceLimits::pname:maxTessellationPatchSize</usage>
                <usage>If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, the identified entry point must: have an code:OpExecutionMode instruction that specifies a maximum output vertex count that is greater than `0` and less than or equal to sname:VkPhysicalDeviceLimits::pname:maxGeometryOutputVertices</usage>
                <usage>If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, the identified entry point must: have an code:OpExecutionMode instruction that specifies an invocation count that is greater than `0` and less than or equal to sname:VkPhysicalDeviceLimits::pname:maxGeometryShaderInvocations</usage>
                <usage>If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, and the identified entry point writes to code:Layer for any primitive, it must: write the same value to code:Layer for all vertices of a given primitive</usage>
                <usage>If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, and the identified entry point writes to code:ViewportIndex for any primitive, it must: write the same value to code:ViewportIndex for all vertices of a given primitive</usage>
                <usage>If pname:stage is ename:VK_SHADER_STAGE_FRAGMENT_BIT, the identified entry point mustnot: include any output variables in its interface decorated with code:CullDistance</usage>
                <usage>If pname:stage is ename:VK_SHADER_STAGE_FRAGMENT_BIT, and the identified entry point writes to code:FragDepth in any execution path, it must: write to code:FragDepth in all execution paths</usage>
            </validity>
        </type>
        <type category="struct" name="VkComputePipelineCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name></member>                          <!-- Pipeline creation flags -->
            <member><type>VkPipelineShaderStageCreateInfo</type> <name>stage</name></member>
            <member><type>VkPipelineLayout</type>       <name>layout</name></member>                         <!-- Interface layout of the pipeline -->
            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name></member>             <!-- If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of -->
            <member><type>int32_t</type>                <name>basePipelineIndex</name></member>              <!-- If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of -->
            <validity>
                <usage>If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineIndex is not `-1`, pname:basePipelineHandle must: be sname:VK_NULL_HANDLE</usage>
                <usage>If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineIndex is not `-1`, it must: be a valid index into the calling command's pname:pCreateInfos parameter</usage>
                <usage>If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineHandle is not sname:VK_NULL_HANDLE, pname:basePipelineIndex must: be `-1`</usage>
                <usage>If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineHandle is not sname:VK_NULL_HANDLE, pname:basePipelineHandle must: be a valid sname:VkPipeline handle</usage>
                <usage>If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineHandle is not sname:VK_NULL_HANDLE, it must: be a valid handle to a compute sname:VkPipeline</usage>
                <usage>The pname:stage member of pname:stage must: be ename:VK_SHADER_STAGE_COMPUTE_BIT</usage>
                <usage>The shader code for the entry point identified by pname:stage and the rest of the state identified by this structure must: adhere to the pipeline linking rules described in the &lt;&lt;interfaces,Shader Interfaces&gt;&gt; chapter</usage>
                <usage>pname:layout must: be &lt;&lt;descriptorsets-pipelinelayout-consistency,consistent&gt;&gt; with all shaders specified in pname:pStages</usage>
            </validity>
        </type>
        <type category="struct" name="VkVertexInputBindingDescription">
            <member><type>uint32_t</type>               <name>binding</name></member>                        <!-- Vertex buffer binding id -->
            <member><type>uint32_t</type>               <name>stride</name></member>                         <!-- Distance between vertices in bytes (0 = no advancement) -->
            <member><type>VkVertexInputRate</type>      <name>inputRate</name></member>                      <!-- The rate at which the vertex data is consumed -->
            <validity>
                <usage>pname:binding must: be less than sname:VkPhysicalDeviceLimits::pname:maxVertexInputBindings</usage>
                <usage>pname:stride must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxVertexInputBindingStride</usage>
            </validity>
        </type>
        <type category="struct" name="VkVertexInputAttributeDescription">
            <member><type>uint32_t</type>               <name>location</name></member>                       <!-- location of the shader vertex attrib -->
            <member><type>uint32_t</type>               <name>binding</name></member>                        <!-- Vertex buffer binding id -->
            <member><type>VkFormat</type>               <name>format</name></member>                         <!-- format of source data -->
            <member><type>uint32_t</type>               <name>offset</name></member>                         <!-- Offset of first element in bytes from base of vertex -->
            <validity>
                <usage>pname:location must: be less than sname:VkPhysicalDeviceLimits::pname:maxVertexInputAttributes</usage>
                <usage>pname:binding must: be less than sname:VkPhysicalDeviceLimits::pname:maxVertexInputBindings</usage>
                <usage>pname:offset must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxVertexInputAttributeOffset</usage>
                <usage>pname:format must: be allowed as a vertex buffer format, as specified by the ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT flag in sname:VkFormatProperties::pname:bufferFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
            </validity>
        </type>
        <type category="struct" name="VkPipelineVertexInputStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Should be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineVertexInputStateCreateFlags</type>    <name>flags</name></member>        <!-- Reserved -->
            <member optional="true"><type>uint32_t</type>               <name>vertexBindingDescriptionCount</name></member>  <!-- number of bindings -->
            <member len="vertexBindingDescriptionCount">const <type>VkVertexInputBindingDescription</type>* <name>pVertexBindingDescriptions</name></member>
            <member optional="true"><type>uint32_t</type>               <name>vertexAttributeDescriptionCount</name></member> <!-- number of attributes -->
            <member len="vertexAttributeDescriptionCount">const <type>VkVertexInputAttributeDescription</type>* <name>pVertexAttributeDescriptions</name></member>
            <validity>
                <usage>pname:vertexBindingDescriptionCount must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxVertexInputBindings</usage>
                <usage>pname:vertexAttributeDescriptionCount must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxVertexInputAttributes</usage>
                <usage>For every pname:binding specified by any given element of pname:pVertexAttributeDescriptions, a sname:VkVertexInputBindingDescription must: exist in pname:pVertexBindingDescriptions with the same value of pname:binding</usage>
                <usage>All elements of pname:pVertexBindingDescriptions must: describe distinct binding numbers</usage>
                <usage>All elements of pname:pVertexAttributeDescriptions must: describe distinct attribute locations</usage>

            </validity>
        </type>
        <type category="struct" name="VkPipelineInputAssemblyStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_IINPUT_ASSEMBLY_STATE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineInputAssemblyStateCreateFlags</type>    <name>flags</name></member>      <!-- Reserved -->
            <member><type>VkPrimitiveTopology</type>    <name>topology</name></member>
            <member><type>VkBool32</type>               <name>primitiveRestartEnable</name></member>
            <validity>
                <usage>If pname:topology is ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST, ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST, ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, pname:primitiveRestartEnable must: be ename:VK_FALSE</usage>
                <usage>If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:topology mustnot: be any of ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY, ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY</usage>
                <usage>If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:topology mustnot: be ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST</usage>
            </validity>
        </type>
        <type category="struct" name="VkPipelineTessellationStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineTessellationStateCreateFlags</type>    <name>flags</name></member>        <!-- Reserved -->
            <member><type>uint32_t</type>               <name>patchControlPoints</name></member>
            <validity>
                <usage>pname:patchControlPoints must: be greater than zero and less than or equal to sname:VkPhysicalDeviceLimits::pname:maxTessellationPatchSize</usage>
            </validity>
        </type>
        <type category="struct" name="VkPipelineViewportStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineViewportStateCreateFlags</type>    <name>flags</name></member>           <!-- Reserved -->
            <member><type>uint32_t</type>               <name>viewportCount</name></member>
            <member noautovalidity="true" optional="true" len="viewportCount">const <type>VkViewport</type>*      <name>pViewports</name></member>
            <member><type>uint32_t</type>               <name>scissorCount</name></member>
            <member noautovalidity="true" optional="true" len="scissorCount">const <type>VkRect2D</type>*        <name>pScissors</name></member>
            <validity>
                <usage>If the &lt;&lt;features-features-multiViewport,multiple viewports&gt;&gt; feature is not enabled, pname:viewportCount must: be `1`</usage>
                <usage>If the &lt;&lt;features-features-multiViewport,multiple viewports&gt;&gt; feature is not enabled, pname:scissorCount must: be `1`</usage>
                <usage>pname:viewportCount must: be between `1` and sname:VkPhysicalDeviceLimits::pname:maxViewports, inclusive</usage>
                <usage>pname:scissorCount must: be between `1` and sname:VkPhysicalDeviceLimits::pname:maxViewports, inclusive</usage>
                <usage>pname:scissorCount and pname:viewportCount must: be identical</usage>
            </validity>
        </type>
        <type category="struct" name="VkPipelineRasterizationStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO -->
            <member validextensionstructs="VkPipelineRasterizationStateRasterizationOrderAMD">const <type>void</type>* <name>pNext</name></member> <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineRasterizationStateCreateFlags</type>    <name>flags</name></member>             <!-- Reserved -->
            <member><type>VkBool32</type>               <name>depthClampEnable</name></member>
            <member><type>VkBool32</type>               <name>rasterizerDiscardEnable</name></member>
            <member><type>VkPolygonMode</type>          <name>polygonMode</name></member>                       <!-- optional (GL45) -->
            <member optional="true"><type>VkCullModeFlags</type>        <name>cullMode</name></member>
            <member><type>VkFrontFace</type>            <name>frontFace</name></member>
            <member><type>VkBool32</type>               <name>depthBiasEnable</name></member>
            <member><type>float</type>                  <name>depthBiasConstantFactor</name></member>
            <member><type>float</type>                  <name>depthBiasClamp</name></member>
            <member><type>float</type>                  <name>depthBiasSlopeFactor</name></member>
            <member><type>float</type>                  <name>lineWidth</name></member>
            <validity>
                <usage>If the &lt;&lt;features-features-depthClamp,depth clamping&gt;&gt; feature is not enabled, pname:depthClampEnable must: be ename:VK_FALSE</usage>
                <usage>If the &lt;&lt;features-features-fillModeNonSolid,non-solid fill modes&gt;&gt; feature is not enabled, pname:polygonMode must: be ename:VK_POLYGON_MODE_FILL</usage>
            </validity>
        </type>
        <type category="struct" name="VkPipelineMultisampleStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineMultisampleStateCreateFlags</type>    <name>flags</name></member>        <!-- Reserved -->
            <member><type>VkSampleCountFlagBits</type>  <name>rasterizationSamples</name></member>           <!-- Number of samples used for rasterization -->
            <member><type>VkBool32</type>               <name>sampleShadingEnable</name></member>            <!-- optional (GL45) -->
            <member><type>float</type>                  <name>minSampleShading</name></member>               <!-- optional (GL45) -->
            <member optional="true" len="latexmath:[$\lceil{\mathit{rasterizationSamples} \over 32}\rceil$]">const <type>VkSampleMask</type>*    <name>pSampleMask</name></member>                    <!-- Array of sampleMask words -->
            <member><type>VkBool32</type>               <name>alphaToCoverageEnable</name></member>
            <member><type>VkBool32</type>               <name>alphaToOneEnable</name></member>
            <validity>
                <usage>If the &lt;&lt;features-features-sampleRateShading,sample rate shading&gt;&gt; feature is not enabled, pname:sampleShadingEnable must: be ename:VK_FALSE</usage>
                <usage>If the &lt;&lt;features-features-alphaToOne,alpha to one&gt;&gt; feature is not enabled, pname:alphaToOneEnable must: be ename:VK_FALSE</usage>
                <usage>pname:minSampleShading must: be in the range latexmath:[$[0,1\]$]</usage>
            </validity>
        </type>
        <type category="struct" name="VkPipelineColorBlendAttachmentState">
            <member><type>VkBool32</type>               <name>blendEnable</name></member>
            <member><type>VkBlendFactor</type>          <name>srcColorBlendFactor</name></member>
            <member><type>VkBlendFactor</type>          <name>dstColorBlendFactor</name></member>
            <member><type>VkBlendOp</type>              <name>colorBlendOp</name></member>
            <member><type>VkBlendFactor</type>          <name>srcAlphaBlendFactor</name></member>
            <member><type>VkBlendFactor</type>          <name>dstAlphaBlendFactor</name></member>
            <member><type>VkBlendOp</type>              <name>alphaBlendOp</name></member>
            <member optional="true"><type>VkColorComponentFlags</type>  <name>colorWriteMask</name></member>
            <validity>
                <usage>If the &lt;&lt;features-features-dualSrcBlend,dual source blending&gt;&gt; feature is not enabled, pname:srcColorBlendFactor mustnot: be ename:VK_BLEND_FACTOR_SRC1_COLOR, ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, ename:VK_BLEND_FACTOR_SRC1_ALPHA, or ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</usage>
                <usage>If the &lt;&lt;features-features-dualSrcBlend,dual source blending&gt;&gt; feature is not enabled, pname:dstColorBlendFactor mustnot: be ename:VK_BLEND_FACTOR_SRC1_COLOR, ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, ename:VK_BLEND_FACTOR_SRC1_ALPHA, or ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</usage>
                <usage>If the &lt;&lt;features-features-dualSrcBlend,dual source blending&gt;&gt; feature is not enabled, pname:srcAlphaBlendFactor mustnot: be ename:VK_BLEND_FACTOR_SRC1_COLOR, ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, ename:VK_BLEND_FACTOR_SRC1_ALPHA, or ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</usage>
                <usage>If the &lt;&lt;features-features-dualSrcBlend,dual source blending&gt;&gt; feature is not enabled, pname:dstAlphaBlendFactor mustnot: be ename:VK_BLEND_FACTOR_SRC1_COLOR, ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, ename:VK_BLEND_FACTOR_SRC1_ALPHA, or ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</usage>
            </validity>
        </type>
        <type category="struct" name="VkPipelineColorBlendStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineColorBlendStateCreateFlags</type>    <name>flags</name></member>         <!-- Reserved -->
            <member><type>VkBool32</type>               <name>logicOpEnable</name></member>
            <member noautovalidity="true"><type>VkLogicOp</type>              <name>logicOp</name></member>
            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name></member>                <!-- # of pAttachments -->
            <member len="attachmentCount">const <type>VkPipelineColorBlendAttachmentState</type>* <name>pAttachments</name></member>
            <member><type>float</type>                  <name>blendConstants</name>[4]</member>
            <validity>
                <usage>If the &lt;&lt;features-features-independentBlend,independent blending&gt;&gt; feature is not enabled, all elements of pname:pAttachments must: be identical</usage>
                <usage>If the &lt;&lt;features-features-logicOp,logic operations&gt;&gt; feature is not enabled, pname:logicOpEnable must: be ename:VK_FALSE</usage>
                <usage>If pname:logicOpEnable is ename:VK_TRUE, pname:logicOp must: be a valid elink:VkLogicOp value</usage>
            </validity>
        </type>
        <type category="struct" name="VkPipelineDynamicStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineDynamicStateCreateFlags</type>    <name>flags</name></member>            <!-- Reserved -->
            <member><type>uint32_t</type>               <name>dynamicStateCount</name></member>
            <member len="dynamicStateCount">const <type>VkDynamicState</type>*  <name>pDynamicStates</name></member>
        </type>
        <type category="struct" name="VkStencilOpState">
            <member><type>VkStencilOp</type>            <name>failOp</name></member>
            <member><type>VkStencilOp</type>            <name>passOp</name></member>
            <member><type>VkStencilOp</type>            <name>depthFailOp</name></member>
            <member><type>VkCompareOp</type>            <name>compareOp</name></member>
            <member><type>uint32_t</type>               <name>compareMask</name></member>
            <member><type>uint32_t</type>               <name>writeMask</name></member>
            <member><type>uint32_t</type>               <name>reference</name></member>
        </type>
        <type category="struct" name="VkPipelineDepthStencilStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineDepthStencilStateCreateFlags</type>    <name>flags</name></member>       <!-- Reserved -->
            <member><type>VkBool32</type>               <name>depthTestEnable</name></member>
            <member><type>VkBool32</type>               <name>depthWriteEnable</name></member>
            <member><type>VkCompareOp</type>            <name>depthCompareOp</name></member>
            <member><type>VkBool32</type>               <name>depthBoundsTestEnable</name></member>          <!-- optional (depth_bounds_test) -->
            <member><type>VkBool32</type>               <name>stencilTestEnable</name></member>
            <member><type>VkStencilOpState</type>       <name>front</name></member>
            <member><type>VkStencilOpState</type>       <name>back</name></member>
            <member><type>float</type>                  <name>minDepthBounds</name></member>
            <member><type>float</type>                  <name>maxDepthBounds</name></member>
            <validity>
                <usage>If the &lt;&lt;features-features-depthBounds,depth bounds testing&gt;&gt; feature is not enabled, pname:depthBoundsTestEnable must: be ename:VK_FALSE</usage>
            </validity>
        </type>
        <type category="struct" name="VkGraphicsPipelineCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name></member>                          <!-- Pipeline creation flags -->
            <member><type>uint32_t</type>               <name>stageCount</name></member>
            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name></member>        <!-- One entry for each active shader stage -->
            <member>const <type>VkPipelineVertexInputStateCreateInfo</type>* <name>pVertexInputState</name></member>
            <member>const <type>VkPipelineInputAssemblyStateCreateInfo</type>* <name>pInputAssemblyState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineTessellationStateCreateInfo</type>* <name>pTessellationState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineViewportStateCreateInfo</type>* <name>pViewportState</name></member>
            <member>const <type>VkPipelineRasterizationStateCreateInfo</type>* <name>pRasterizationState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineMultisampleStateCreateInfo</type>* <name>pMultisampleState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineDepthStencilStateCreateInfo</type>* <name>pDepthStencilState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineColorBlendStateCreateInfo</type>* <name>pColorBlendState</name></member>
            <member optional="true">const <type>VkPipelineDynamicStateCreateInfo</type>* <name>pDynamicState</name></member>
            <member><type>VkPipelineLayout</type>       <name>layout</name></member>                         <!-- Interface layout of the pipeline -->
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member><type>uint32_t</type>               <name>subpass</name></member>
            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name></member>             <!-- If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of -->
            <member><type>int32_t</type>                <name>basePipelineIndex</name></member>              <!-- If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of -->
            <validity>
                <usage>If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineIndex is not `-1`, pname:basePipelineHandle must: be sname:VK_NULL_HANDLE</usage>
                <usage>If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineIndex is not `-1`, it must: be a valid index into the calling command's pname:pCreateInfos parameter</usage>
                <usage>If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineHandle is not sname:VK_NULL_HANDLE, pname:basePipelineIndex must: be `-1`</usage>
                <usage>If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineHandle is not sname:VK_NULL_HANDLE, pname:basePipelineHandle must: be a valid sname:VkPipeline handle</usage>
                <usage>If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and pname:basePipelineHandle is not sname:VK_NULL_HANDLE, it must: be a valid handle to a graphics sname:VkPipeline</usage>
                <usage>The pname:stage member of each element of pname:pStages must: be unique</usage>
                <usage>The pname:stage member of one element of pname:pStages must: be ename:VK_SHADER_STAGE_VERTEX_BIT</usage>
                <usage>The pname:stage member of any given element of pname:pStages mustnot: be ename:VK_SHADER_STAGE_COMPUTE_BIT</usage>
                <usage>If pname:pStages includes a tessellation control shader stage, it must: include a tessellation evaluation shader stage</usage>
                <usage>If pname:pStages includes a tessellation evaluation shader stage, it must: include a tessellation control shader stage</usage>
                <usage>If pname:pStages includes a tessellation control shader stage and a tessellation evaluation shader stage, pname:pTessellationState mustnot: be `NULL`</usage>
                <usage>If pname:pStages includes both a tessellation control shader stage and a tessellation evaluation shader stage, the shader code of at least one must: contain an code:OpExecutionMode instruction that specifies the type of subdivision in the pipeline</usage>
                <usage>If pname:pStages includes both a tessellation control shader stage and a tessellation evaluation shader stage, and the shader code of both contain an code:OpExecutionMode instruction that specifies the type of subdivision in the pipeline, they must: both specify the same subdivision mode</usage>
                <usage>If pname:pStages includes both a tessellation control shader stage and a tessellation evaluation shader stage, the shader code of at least one must: contain an code:OpExecutionMode instruction that specifies the output patch size in the pipeline</usage>
                <usage>If pname:pStages includes both a tessellation control shader stage and a tessellation evaluation shader stage, and the shader code of both contain an code:OpExecutionMode instruction that specifies the out patch size in the pipeline, they must: both specify the same patch size</usage>
                <usage>If pname:pStages includes tessellation shader stages, the pname:topology member of pname:pInputAssembly must: be ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST</usage>
                <usage>If pname:pStages includes a geometry shader stage, and doesn't include any tessellation shader stages, its shader code must: contain an code:OpExecutionMode instruction that specifies an input primitive type that is &lt;&lt;shaders-geometry-execution, compatible&gt;&gt; with the primitive topology specified in pname:pInputAssembly</usage>
                <usage>If pname:pStages includes a geometry shader stage, and also includes tessellation shader stages, its shader code must: contain an code:OpExecutionMode instruction that specifies an input primitive type that is &lt;&lt;shaders-geometry-execution, compatible&gt;&gt; with the primitive topology that is output by the tessellation stages</usage>
                <usage>If pname:pStages includes a fragment shader stage and a geometry shader stage, and the fragment shader code reads from an input variable that is decorated with code:PrimitiveID, then the geometry shader code must: write to a matching output variable, decorated with code:PrimitiveID, in all execution paths</usage>
                <usage>If pname:pStages includes a fragment shader stage, its shader code mustnot: read from any input attachment that is defined as ename:VK_ATTACHMENT_UNUSED in pname:subpass</usage>
                <usage>The shader code for the entry points identified by pname:pStages, and the rest of the state identified by this structure must: adhere to the pipeline linking rules described in the &lt;&lt;interfaces,Shader Interfaces&gt;&gt; chapter</usage>
                <usage>If pname:subpass uses a depth/stencil attachment in pname:renderpass that has a layout of ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL in the sname:VkAttachmentReference defined by pname:subpass, and pname:pDepthStencilState is not `NULL`, the pname:depthWriteEnable member of pname:pDepthStencilState must: be ename:VK_FALSE</usage>
                <usage>If pname:subpass uses a depth/stencil attachment in pname:renderpass that has a layout of ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL in the sname:VkAttachmentReference defined by pname:subpass, and pname:pDepthStencilState is not `NULL`, the pname:failOp, pname:passOp and pname:depthFailOp members of each of the pname:front and pname:back members of pname:pDepthStencilState must: be ename:VK_STENCIL_OP_KEEP</usage>
                <usage>If pname:pColorBlendState is not `NULL`, the pname:blendEnable member of each element of the pname:pAttachment member of pname:pColorBlendState must: be ename:VK_FALSE if the pname:format of the attachment referred to in pname:subpass of pname:renderPass does not support color blend operations, as specified by the ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures or sname:VkFormatProperties::pname:optimalTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage>If pname:pColorBlendState is not `NULL`, The pname:attachmentCount member of pname:pColorBlendState must: be equal to the pname:colorAttachmentCount used to create pname:subpass</usage>
                <usage>If no element of the pname:pDynamicStates member of pname:pDynamicState is ename:VK_DYNAMIC_STATE_VIEWPORT, the pname:pViewports member of pname:pViewportState must: be a pointer to an array of pname:pViewportState->viewportCount sname:VkViewport structures</usage>
                <usage>If no element of the pname:pDynamicStates member of pname:pDynamicState is ename:VK_DYNAMIC_STATE_SCISSOR, the pname:pScissors member of pname:pViewportState must: be a pointer to an array of pname:pViewportState->scissorCount sname:VkRect2D structures</usage>
                <usage>If the wide lines feature is not enabled, and no element of the pname:pDynamicStates member of pname:pDynamicState is ename:VK_DYNAMIC_STATE_LINE_WIDTH, the pname:lineWidth member of pname:pRasterizationState must: be `1.0`</usage>
                <usage>If the pname:rasterizerDiscardEnable member of pname:pRasterizationState is ename:VK_FALSE, pname:pViewportState must: be a pointer to a valid sname:VkPipelineViewportStateCreateInfo structure</usage>
                <usage>If the pname:rasterizerDiscardEnable member of pname:pRasterizationState is ename:VK_FALSE, pname:pMultisampleState must: be a pointer to a valid sname:VkPipelineMultisampleStateCreateInfo structure</usage>
                <usage>If the pname:rasterizerDiscardEnable member of pname:pRasterizationState is ename:VK_FALSE, and pname:subpass uses a depth/stencil attachment, pname:pDepthStencilState must: be a pointer to a valid sname:VkPipelineDepthStencilStateCreateInfo structure</usage>
                <usage>If the pname:rasterizerDiscardEnable member of pname:pRasterizationState is ename:VK_FALSE, and pname:subpass uses color attachments, pname:pColorBlendState must: be a pointer to a valid sname:VkPipelineColorBlendStateCreateInfo structure</usage>
                <usage>If the depth bias clamping feature is not enabled, no element of the pname:pDynamicStates member of pname:pDynamicState is ename:VK_DYNAMIC_STATE_DEPTH_BIAS, and the pname:depthBiasEnable member of pname:pDepthStencil is ename:VK_TRUE, the pname:depthBiasClamp member of pname:pDepthStencil must: be `0.0`</usage>
                <usage>If no element of the pname:pDynamicStates member of pname:pDynamicState is ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the pname:depthBoundsTestEnable member of pname:pDepthStencil is ename:VK_TRUE, the pname:minDepthBounds and pname:maxDepthBounds members of pname:pDepthStencil must: be between `0.0` and `1.0`, inclusive</usage>
                <usage>pname:layout must: be &lt;&lt;descriptorsets-pipelinelayout-consistency,consistent&gt;&gt; with all shaders specified in pname:pStages</usage>
                <usage>If pname:subpass uses color and/or depth/stencil attachments, then the pname:rasterizationSamples member of pname:pMultisampleState must: be the same as the sample count for those subpass attachments</usage>
                <usage>If pname:subpass does not use any color and/or depth/stencil attachments, then the pname:rasterizationSamples member of pname:pMultisampleState must: follow the rules for a &lt;&lt;renderpass-noattachments, zero-attachment subpass&gt;&gt;</usage>
                <usage>pname:subpass must: be a valid subpass within pname:renderpass</usage>
            </validity>
        </type>
        <type category="struct" name="VkPipelineCacheCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineCacheCreateFlags</type>    <name>flags</name></member>                   <!-- Reserved -->
            <member optional="true"><type>size_t</type>                 <name>initialDataSize</name></member>                <!-- Size of initial data to populate cache, in bytes -->
            <member len="initialDataSize">const <type>void</type>*            <name>pInitialData</name></member>                    <!-- Initial data to populate cache -->
            <validity>
                <usage>If pname:initialDataSize is not `0`, it must: be equal to the size of pname:pInitialData, as returned by fname:vkGetPipelineCacheData when pname:pInitialData was originally retrieved</usage>
                <usage>If pname:initialDataSize is not `0`, pname:pInitialData must: have been retrieved from a previous call to fname:vkGetPipelineCacheData</usage>
            </validity>
        </type>
        <type category="struct" name="VkPushConstantRange">
            <member><type>VkShaderStageFlags</type>     <name>stageFlags</name></member>                     <!-- Which stages use the range -->
            <member><type>uint32_t</type>               <name>offset</name></member>                         <!-- Start of the range, in bytes -->
            <member><type>uint32_t</type>               <name>size</name></member>                           <!-- Size of the range, in bytes -->
            <validity>
                <usage>pname:offset must: be less than sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize</usage>
                <usage>pname:size must: be greater than `0`</usage>
                <usage>pname:size must: be a multiple of `4`</usage>
                <usage>pname:size must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize minus pname:offset</usage>
            </validity>
        </type>
        <type category="struct" name="VkPipelineLayoutCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkPipelineLayoutCreateFlags</type>    <name>flags</name></member>                  <!-- Reserved -->
            <member optional="true"><type>uint32_t</type>               <name>setLayoutCount</name></member>                 <!-- Number of descriptor sets interfaced by the pipeline -->
            <member len="setLayoutCount">const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name></member>              <!-- Array of setCount number of descriptor set layout objects defining the layout of the -->
            <member optional="true"><type>uint32_t</type>               <name>pushConstantRangeCount</name></member>         <!-- Number of push-constant ranges used by the pipeline -->
            <member len="pushConstantRangeCount">const <type>VkPushConstantRange</type>* <name>pPushConstantRanges</name></member>        <!-- Array of pushConstantRangeCount number of ranges used by various shader stages -->
            <validity>
                <usage>pname:setLayoutCount must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxBoundDescriptorSets</usage>
                <usage>The total number of descriptors of the type ename:VK_DESCRIPTOR_TYPE_SAMPLER and ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any given shader stage across all elements of pname:pSetLayouts must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorSamplers</usage>
                <usage>The total number of descriptors of the type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pname:pSetLayouts must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorUniformBuffers</usage>
                <usage>The total number of descriptors of the type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pname:pSetLayouts must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorStorageBuffers</usage>
                <usage>The total number of descriptors of the type ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any given shader stage across all elements of pname:pSetLayouts must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorSampledImages</usage>
                <usage>The total number of descriptors of the type ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any given shader stage across all elements of pname:pSetLayouts must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxPerStageDescriptorStorageImages</usage>
            </validity>
        </type>
        <type category="struct" name="VkSamplerCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkSamplerCreateFlags</type>   <name>flags</name></member>                          <!-- Reserved -->
            <member><type>VkFilter</type>               <name>magFilter</name></member>                      <!-- Filter mode for magnification -->
            <member><type>VkFilter</type>               <name>minFilter</name></member>                      <!-- Filter mode for minifiation -->
            <member><type>VkSamplerMipmapMode</type>    <name>mipmapMode</name></member>                     <!-- Mipmap selection mode -->
            <member><type>VkSamplerAddressMode</type>   <name>addressModeU</name></member>
            <member><type>VkSamplerAddressMode</type>   <name>addressModeV</name></member>
            <member><type>VkSamplerAddressMode</type>   <name>addressModeW</name></member>
            <member><type>float</type>                  <name>mipLodBias</name></member>
            <member><type>VkBool32</type>               <name>anisotropyEnable</name></member>
            <member><type>float</type>                  <name>maxAnisotropy</name></member>
            <member><type>VkBool32</type>               <name>compareEnable</name></member>
            <member noautovalidity="true"><type>VkCompareOp</type>            <name>compareOp</name></member>
            <member><type>float</type>                  <name>minLod</name></member>
            <member><type>float</type>                  <name>maxLod</name></member>
            <member noautovalidity="true"><type>VkBorderColor</type>          <name>borderColor</name></member>
            <member><type>VkBool32</type>               <name>unnormalizedCoordinates</name></member>
            <validity>
                <usage>The absolute value of pname:mipLodBias must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxSamplerLodBias</usage>
                <usage>If the &lt;&lt;features-features-samplerAnisotropy,anisotropic sampling&gt;&gt; feature is not enabled, pname:anisotropyEnable must: be ename:VK_FALSE</usage>
                <usage>If pname:anisotropyEnable is ename:VK_TRUE, pname:maxAnisotropy must: be between `1.0` and sname:VkPhysicalDeviceLimits::pname:maxSamplerAnisotropy, inclusive</usage>
                <usage>If pname:unnormalizedCoordinates is ename:VK_TRUE, pname:minFilter and pname:magFilter must: be equal</usage>
                <usage>If pname:unnormalizedCoordinates is ename:VK_TRUE, pname:mipmapMode must: be ename:VK_SAMPLER_MIPMAP_MODE_NEAREST</usage>
                <usage>If pname:unnormalizedCoordinates is ename:VK_TRUE, pname:minLod and pname:maxLod must: be zero</usage>
                <usage>If pname:unnormalizedCoordinates is ename:VK_TRUE, pname:addressModeU and pname:addressModeV must: each be either ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE or ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER</usage>
                <usage>If pname:unnormalizedCoordinates is ename:VK_TRUE, pname:anisotropyEnable must: be ename:VK_FALSE</usage>
                <usage>If pname:unnormalizedCoordinates is ename:VK_TRUE, pname:compareEnable must: be ename:VK_FALSE</usage>
                <usage>If any of pname:addressModeU, pname:addressModeV or pname:addressModeW are ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER, pname:borderColor must: be a valid elink:VkBorderColor value</usage>
                <usage>If the VK_KHR_mirror_clamp_to_edge extension is not enabled, pname:addressModeU, pname:addressModeV and pname:addressModeW mustnot: be ename:VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE</usage>
                <usage>If pname:compareEnable is ename:VK_TRUE, pname:compareOp must: be a valid elink:VkCompareOp value</usage>
            </validity>
        </type>
        <type category="struct" name="VkCommandPoolCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkCommandPoolCreateFlags</type>   <name>flags</name></member>                          <!-- Command pool creation flags -->
            <member><type>uint32_t</type>               <name>queueFamilyIndex</name></member>
            <validity>
                <usage>pname:queueFamilyIndex must: be the index of a queue family available in the calling command's pname:device parameter</usage>
            </validity>
         </type>
         <type category="struct" name="VkCommandBufferAllocateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkCommandPool</type>  <name>commandPool</name></member>
            <member><type>VkCommandBufferLevel</type>       <name>level</name></member>
            <member><type>uint32_t</type>               <name>commandBufferCount</name></member>
        </type>
        <type category="struct" name="VkCommandBufferInheritanceInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true" noautovalidity="true"><type>VkRenderPass</type>    <name>renderPass</name></member>                     <!-- Render pass for secondary command buffers -->
            <member><type>uint32_t</type>               <name>subpass</name></member>
            <member optional="true" noautovalidity="true"><type>VkFramebuffer</type>   <name>framebuffer</name></member>                    <!-- Framebuffer for secondary command buffers -->
            <member><type>VkBool32</type>               <name>occlusionQueryEnable</name></member>           <!-- Whether this secondary command buffer may be executed during an occlusion query -->
            <member optional="true" noautovalidity="true"><type>VkQueryControlFlags</type>    <name>queryFlags</name></member>                     <!-- Query flags used by this secondary command buffer, if executed during an occlusion query -->
            <member optional="true" noautovalidity="true"><type>VkQueryPipelineStatisticFlags</type> <name>pipelineStatistics</name></member>      <!-- Pipeline statistics that may be counted for this secondary command buffer -->
            <validity>
                <usage>If the &lt;&lt;features-features-inheritedQueries,inherited queries&gt;&gt; feature is not enabled, pname:occlusionQueryEnable must: be ename:VK_FALSE</usage>
                <usage>If the &lt;&lt;features-features-inheritedQueries,inherited queries&gt;&gt; feature is enabled, pname:queryFlags must: be a valid combination of elink:VkQueryControlFlagBits values</usage>
                <usage>If the &lt;&lt;features-features-pipelineStatisticsQuery,pipeline statistics queries&gt;&gt; feature is not enabled, pname:pipelineStatistics must: be code:0</usage>
            </validity>
        </type>
        <type category="struct" name="VkCommandBufferBeginInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkCommandBufferUsageFlags</type>  <name>flags</name></member>                          <!-- Command buffer usage flags -->
            <member optional="true" noautovalidity="true">const <type>VkCommandBufferInheritanceInfo</type>*       <name>pInheritanceInfo</name></member>                          <!-- Pointer to inheritance info for secondary command buffers -->
            <validity>
                <usage>If pname:flags contains ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the pname:renderPass member of pname:pInheritanceInfo must: be a valid sname:VkRenderPass</usage>
                <usage>If pname:flags contains ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the pname:subpass member of pname:pInheritanceInfo must: be a valid subpass index within the pname:renderPass member of pname:pInheritanceInfo</usage>
                <usage>If pname:flags contains ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the pname:framebuffer member of pname:pInheritanceInfo must: be either sname:VK_NULL_HANDLE, or a valid sname:VkFramebuffer that is compatible with the pname:renderPass member of pname:pInheritanceInfo</usage>
            </validity>
        </type>
        <type category="struct" name="VkRenderPassBeginInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member><type>VkFramebuffer</type>          <name>framebuffer</name></member>
            <member><type>VkRect2D</type>               <name>renderArea</name></member>
            <member optional="true"><type>uint32_t</type>               <name>clearValueCount</name></member>
            <member len="clearValueCount">const <type>VkClearValue</type>*    <name>pClearValues</name></member>
            <validity>
                <usage>pname:clearValueCount must: be greater than or equal to the number of attachments in pname:renderPass that specify a pname:loadOp of ename:VK_ATTACHMENT_LOAD_OP_CLEAR</usage>
            </validity>
        </type>
        <type category="union" name="VkClearColorValue" comment="// Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.">
            <member><type>float</type>                  <name>float32</name>[4]</member>
            <member><type>int32_t</type>                <name>int32</name>[4]</member>
            <member><type>uint32_t</type>               <name>uint32</name>[4]</member>
        </type>
        <type category="struct" name="VkClearDepthStencilValue">
            <member><type>float</type>                  <name>depth</name></member>
            <member><type>uint32_t</type>               <name>stencil</name></member>
        </type>
        <type category="union" name="VkClearValue" comment="// Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.">
            <member><type>VkClearColorValue</type>      <name>color</name></member>
            <member><type>VkClearDepthStencilValue</type> <name>depthStencil</name></member>
        </type>
        <type category="struct" name="VkClearAttachment">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>colorAttachment</name></member>
            <member><type>VkClearValue</type>           <name>clearValue</name></member>
            <validity>
                <usage>If pname:aspectMask includes ename:VK_IMAGE_ASPECT_COLOR_BIT, it mustnot: include ename:VK_IMAGE_ASPECT_DEPTH_BIT or ename:VK_IMAGE_ASPECT_STENCIL_BIT</usage>
                <usage>pname:aspectMask mustnot: include ename:VK_IMAGE_ASPECT_METADATA_BIT</usage>
            </validity>
        </type>
        <type category="struct" name="VkAttachmentDescription">
            <member optional="true"><type>VkAttachmentDescriptionFlags</type> <name>flags</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkSampleCountFlagBits</type>  <name>samples</name></member>
            <member><type>VkAttachmentLoadOp</type>     <name>loadOp</name></member>                         <!-- Load operation for color or depth data -->
            <member><type>VkAttachmentStoreOp</type>    <name>storeOp</name></member>                        <!-- Store operation for color or depth data -->
            <member><type>VkAttachmentLoadOp</type>     <name>stencilLoadOp</name></member>                  <!-- Load operation for stencil data -->
            <member><type>VkAttachmentStoreOp</type>    <name>stencilStoreOp</name></member>                 <!-- Store operation for stencil data -->
            <member><type>VkImageLayout</type>          <name>initialLayout</name></member>
            <member><type>VkImageLayout</type>          <name>finalLayout</name></member>
        </type>
        <type category="struct" name="VkAttachmentReference">
            <member><type>uint32_t</type>               <name>attachment</name></member>
            <member><type>VkImageLayout</type>          <name>layout</name></member>
        </type>
        <type category="struct" name="VkSubpassDescription">
            <member optional="true"><type>VkSubpassDescriptionFlags</type> <name>flags</name></member>
            <member><type>VkPipelineBindPoint</type>    <name>pipelineBindPoint</name></member>              <!-- Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now -->
            <member optional="true"><type>uint32_t</type>               <name>inputAttachmentCount</name></member>
            <member len="inputAttachmentCount">const <type>VkAttachmentReference</type>* <name>pInputAttachments</name></member>
            <member optional="true"><type>uint32_t</type>               <name>colorAttachmentCount</name></member>
            <member len="colorAttachmentCount">const <type>VkAttachmentReference</type>* <name>pColorAttachments</name></member>
            <member optional="true" len="colorAttachmentCount">const <type>VkAttachmentReference</type>* <name>pResolveAttachments</name></member>
            <member optional="true">const <type>VkAttachmentReference</type>* <name>pDepthStencilAttachment</name></member>
            <member optional="true"><type>uint32_t</type>               <name>preserveAttachmentCount</name></member>
            <member len="preserveAttachmentCount">const <type>uint32_t</type>* <name>pPreserveAttachments</name></member>
            <validity>
                <usage>pname:pipelineBindPoint must: be ename:VK_PIPELINE_BIND_POINT_GRAPHICS</usage>
                <usage>pname:colorCount must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxColorAttachments</usage>
                <usage>If the first use of an attachment in this render pass is as an input attachment, and the attachment is not also used as a color or depth/stencil attachment in the same subpass, then pname:loadOp mustnot: be ename:VK_ATTACHMENT_LOAD_OP_CLEAR</usage>
                <usage>If pname:pResolveAttachments is not `NULL`, for each resolve attachment that does not have the value ename:VK_ATTACHMENT_UNUSED, the corresponding color attachment mustnot: have the value ename:VK_ATTACHMENT_UNUSED</usage>
                <usage>If pname:pResolveAttachments is not `NULL`, the sample count of each element of pname:pColorAttachments must: be anything other than ename:VK_SAMPLE_COUNT_1_BIT</usage>
                <usage>Any given element of pname:pResolveAttachments must: have a sample count of ename:VK_SAMPLE_COUNT_1_BIT</usage>
                <usage>Any given element of pname:pResolveAttachments must: have the same elink:VkFormat as its corresponding color attachment</usage>
                <usage>All attachments in pname:pColorAttachments and pname:pDepthStencilAttachment that are not ename:VK_ATTACHMENT_UNUSED must: have the same sample count</usage>
                <usage>If any input attachments are ename:VK_ATTACHMENT_UNUSED, then any pipelines bound during the subpass mustnot: accesss those input attachments from the fragment shader</usage>
                <usage>The pname:attachment member of any element of pname:pPreserveAttachments mustnot: be ename:VK_ATTACHMENT_UNUSED</usage>
                <usage>Any given element of pname:pPreserveAttachments mustnot: also be an element of any other member of the subpass description</usage>
                <usage>If any attachment is used as both an input attachment and a color or depth/stencil attachment, then each use must: use the same pname:layout</usage>
            </validity>
        </type>
        <type category="struct" name="VkSubpassDependency">
            <member><type>uint32_t</type>               <name>srcSubpass</name></member>
            <member><type>uint32_t</type>               <name>dstSubpass</name></member>
            <member><type>VkPipelineStageFlags</type>   <name>srcStageMask</name></member>
            <member><type>VkPipelineStageFlags</type>   <name>dstStageMask</name></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name></member>                  <!-- Memory accesses from the source of the dependency to synchronize -->
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name></member>                  <!-- Memory accesses from the destination of the dependency to synchronize -->
            <member optional="true"><type>VkDependencyFlags</type>      <name>dependencyFlags</name></member>
            <validity>
                <usage>If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:srcStageMask mustnot: contain ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</usage>
                <usage>If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:dstStageMask mustnot: contain ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</usage>
                <usage>If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:srcStageMask mustnot: contain ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</usage>
                <usage>If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:dstStageMask mustnot: contain ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</usage>
                <usage>pname:srcSubpass must: be less than or equal to pname:dstSubpass, unless one of them is ename:VK_SUBPASS_EXTERNAL, to avoid cyclic dependencies and ensure a valid execution order</usage>
                <usage>pname:srcSubpass and pname:dstSubpass mustnot: both be equal to ename:VK_SUBPASS_EXTERNAL</usage>
            </validity>
        </type>
        <type category="struct" name="VkRenderPassCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkRenderPassCreateFlags</type>    <name>flags</name></member>                      <!-- Reserved -->
            <member optional="true"><type>uint32_t</type>   <name>attachmentCount</name></member>
            <member len="attachmentCount">const <type>VkAttachmentDescription</type>* <name>pAttachments</name></member>
            <member><type>uint32_t</type>               <name>subpassCount</name></member>
            <member len="subpassCount">const <type>VkSubpassDescription</type>* <name>pSubpasses</name></member>
            <member optional="true"><type>uint32_t</type>       <name>dependencyCount</name></member>
            <member len="dependencyCount">const <type>VkSubpassDependency</type>* <name>pDependencies</name></member>
            <validity>
                <usage>If any two subpasses operate on attachments with overlapping ranges of the same sname:VkDeviceMemory object, and at least one subpass writes to that area of sname:VkDeviceMemory, a subpass dependency must: be included (either directly or via some intermediate subpasses) between them</usage>
                <usage>If the pname:attachment member of any element of pname:pInputAttachments, pname:pColorAttachments, pname:pResolveAttachments or pname:pDepthStencilAttachment, or the attachment indexed by any element of pname:pPreserveAttachments in any given element of pname:pSubpasses is bound to a range of a sname:VkDeviceMemory object that overlaps with any other attachment in any subpass (including the same subpass), the sname:VkAttachmentDescription structures describing them must: include ename:VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT in pname:flags</usage>
                <usage>If the pname:attachment member of any element of pname:pInputAttachments, pname:pColorAttachments, pname:pResolveAttachments or pname:pDepthStencilAttachment, or any element of pname:pPreserveAttachments in any given element of pname:pSubpasses is not ename:VK_ATTACHMENT_UNUSED, it must: be less than pname:attachmentCount</usage>
                <usage>The value of any element of the pname:pPreserveAttachments member in any given element of pname:pSubpasses mustnot: be ename:VK_ATTACHMENT_UNUSED</usage>
            </validity>
        </type>
        <type category="struct" name="VkEventCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_EVENT_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkEventCreateFlags</type>     <name>flags</name></member>                          <!-- Event creation flags -->
        </type>
        <type category="struct" name="VkFenceCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_FENCE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkFenceCreateFlags</type>     <name>flags</name></member>                          <!-- Fence creation flags -->
        </type>
        <type category="struct" name="VkPhysicalDeviceFeatures">
            <member><type>VkBool32</type>               <name>robustBufferAccess</name></member>                <!-- out of bounds buffer accesses are well defined -->
            <member><type>VkBool32</type>               <name>fullDrawIndexUint32</name></member>               <!-- full 32-bit range of indices for indexed draw calls -->
            <member><type>VkBool32</type>               <name>imageCubeArray</name></member>                    <!-- image views which are arrays of cube maps -->
            <member><type>VkBool32</type>               <name>independentBlend</name></member>                  <!-- blending operations are controlled per-attachment -->
            <member><type>VkBool32</type>               <name>geometryShader</name></member>                    <!-- geometry stage -->
            <member><type>VkBool32</type>               <name>tessellationShader</name></member>                <!-- tessellation control and evaluation stage -->
            <member><type>VkBool32</type>               <name>sampleRateShading</name></member>                 <!-- per-sample shading and interpolation -->
            <member><type>VkBool32</type>               <name>dualSrcBlend</name></member>                      <!-- blend operations which take two sources -->
            <member><type>VkBool32</type>               <name>logicOp</name></member>                           <!-- logic operations -->
            <member><type>VkBool32</type>               <name>multiDrawIndirect</name></member>                 <!-- multi draw indirect -->
            <member><type>VkBool32</type>               <name>drawIndirectFirstInstance</name></member>         <!-- indirect draws can use non-zero firstInstance -->
            <member><type>VkBool32</type>               <name>depthClamp</name></member>                        <!-- depth clamping -->
            <member><type>VkBool32</type>               <name>depthBiasClamp</name></member>                    <!-- depth bias clamping -->
            <member><type>VkBool32</type>               <name>fillModeNonSolid</name></member>                  <!-- point and wireframe fill modes -->
            <member><type>VkBool32</type>               <name>depthBounds</name></member>                       <!-- depth bounds test -->
            <member><type>VkBool32</type>               <name>wideLines</name></member>                         <!-- lines with width greater than 1 -->
            <member><type>VkBool32</type>               <name>largePoints</name></member>                       <!-- points with size greater than 1 -->
            <member><type>VkBool32</type>               <name>alphaToOne</name></member>                        <!-- the fragment alpha component can be forced to maximum representable alpha value -->
            <member><type>VkBool32</type>               <name>multiViewport</name></member>                     <!-- viewport arrays -->
            <member><type>VkBool32</type>               <name>samplerAnisotropy</name></member>                 <!-- anisotropic sampler filtering -->
            <member><type>VkBool32</type>               <name>textureCompressionETC2</name></member>            <!-- ETC texture compression formats -->
            <member><type>VkBool32</type>               <name>textureCompressionASTC_LDR</name></member>        <!-- ASTC LDR texture compression formats -->
            <member><type>VkBool32</type>               <name>textureCompressionBC</name></member>              <!-- BC1-7 texture compressed formats -->
            <member><type>VkBool32</type>               <name>occlusionQueryPrecise</name></member>             <!-- precise occlusion queries returning actual sample counts -->
            <member><type>VkBool32</type>               <name>pipelineStatisticsQuery</name></member>           <!-- pipeline statistics query -->
            <member><type>VkBool32</type>               <name>vertexPipelineStoresAndAtomics</name></member>    <!-- stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages -->
            <member><type>VkBool32</type>               <name>fragmentStoresAndAtomics</name></member>          <!-- stores and atomic ops on storage buffers and images are supported in the fragment stage -->
            <member><type>VkBool32</type>               <name>shaderTessellationAndGeometryPointSize</name></member><!-- tessellation and geometry stages can export point size -->
            <member><type>VkBool32</type>               <name>shaderImageGatherExtended</name></member>         <!-- image gather with run-time values and independent offsets -->
            <member><type>VkBool32</type>               <name>shaderStorageImageExtendedFormats</name></member> <!-- the extended set of formats can be used for storage images -->
            <member><type>VkBool32</type>               <name>shaderStorageImageMultisample</name></member>     <!-- multisample images can be used for storage images -->
            <member><type>VkBool32</type>               <name>shaderStorageImageReadWithoutFormat</name></member>       <!-- read from storage image does not require format qualifier -->
            <member><type>VkBool32</type>               <name>shaderStorageImageWriteWithoutFormat</name></member>      <!-- write to storage image does not require format qualifier -->
            <member><type>VkBool32</type>               <name>shaderUniformBufferArrayDynamicIndexing</name></member>   <!-- arrays of uniform buffers can be accessed with dynamically uniform indices -->
            <member><type>VkBool32</type>               <name>shaderSampledImageArrayDynamicIndexing</name></member>    <!-- arrays of sampled images can be accessed with dynamically uniform indices -->
            <member><type>VkBool32</type>               <name>shaderStorageBufferArrayDynamicIndexing</name></member>   <!-- arrays of storage buffers can be accessed with dynamically uniform indices -->
            <member><type>VkBool32</type>               <name>shaderStorageImageArrayDynamicIndexing</name></member>    <!-- arrays of storage images can be accessed with dynamically uniform indices -->
            <member><type>VkBool32</type>               <name>shaderClipDistance</name></member>                <!-- clip distance in shaders -->
            <member><type>VkBool32</type>               <name>shaderCullDistance</name></member>                <!-- cull distance in shaders -->
            <member><type>VkBool32</type>               <name>shaderFloat64</name></member>                     <!-- 64-bit floats (doubles) in shaders -->
            <member><type>VkBool32</type>               <name>shaderInt64</name></member>                       <!-- 64-bit integers in shaders -->
            <member><type>VkBool32</type>               <name>shaderInt16</name></member>                       <!-- 16-bit integers in shaders -->
            <member><type>VkBool32</type>               <name>shaderResourceResidency</name></member>           <!-- shader can use texture operations that return resource residency information (requires sparseNonResident support) -->
            <member><type>VkBool32</type>               <name>shaderResourceMinLod</name></member>              <!-- shader can use texture operations that specify minimum resource level of detail -->
            <member><type>VkBool32</type>               <name>sparseBinding</name></member>                     <!-- Sparse resources support: Resource memory can be managed at opaque page level rather than object level -->
            <member><type>VkBool32</type>               <name>sparseResidencyBuffer</name></member>             <!-- Sparse resources support: GPU can access partially resident buffers  -->
            <member><type>VkBool32</type>               <name>sparseResidencyImage2D</name></member>            <!-- Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images  -->
            <member><type>VkBool32</type>               <name>sparseResidencyImage3D</name></member>            <!-- Sparse resources support: GPU can access partially resident 3D images  -->
            <member><type>VkBool32</type>               <name>sparseResidency2Samples</name></member>           <!-- Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples -->
            <member><type>VkBool32</type>               <name>sparseResidency4Samples</name></member>           <!-- Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples -->
            <member><type>VkBool32</type>               <name>sparseResidency8Samples</name></member>           <!-- Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples -->
            <member><type>VkBool32</type>               <name>sparseResidency16Samples</name></member>          <!-- Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples -->
            <member><type>VkBool32</type>               <name>sparseResidencyAliased</name></member>            <!-- Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in) -->
            <member><type>VkBool32</type>               <name>variableMultisampleRate</name></member>           <!-- multisample rate must be the same for all pipelines in a subpass -->
            <member><type>VkBool32</type>               <name>inheritedQueries</name></member>                  <!-- Queries may be inherited from primary to secondary command buffers -->
            <validity>
                <usage>If any member of this structure is ename:VK_FALSE, as returned by flink:vkGetPhysicalDeviceFeatures, then it must: be ename:VK_FALSE when passed as part of the sname:VkDeviceCreateInfo struct when creating a device</usage>
            </validity>
        </type>
        <type category="struct" name="VkPhysicalDeviceSparseProperties" returnedonly="true">
            <member><type>VkBool32</type>               <name>residencyStandard2DBlockShape</name></member> <!-- Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format) -->
            <member><type>VkBool32</type>               <name>residencyStandard2DMultisampleBlockShape</name></member> <!-- Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format) -->
            <member><type>VkBool32</type>               <name>residencyStandard3DBlockShape</name></member> <!-- Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format) -->
            <member><type>VkBool32</type>               <name>residencyAlignedMipSize</name></member>     <!-- Sparse resources support: Images with mip-level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail -->
            <member><type>VkBool32</type>               <name>residencyNonResidentStrict</name></member>  <!-- Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded -->
        </type>
        <type category="struct" name="VkPhysicalDeviceLimits" returnedonly="true">
                <!-- resource maximum sizes -->
            <member><type>uint32_t</type>               <name>maxImageDimension1D</name></member>               <!-- max 1D image dimension -->
            <member><type>uint32_t</type>               <name>maxImageDimension2D</name></member>               <!-- max 2D image dimension -->
            <member><type>uint32_t</type>               <name>maxImageDimension3D</name></member>               <!-- max 3D image dimension -->
            <member><type>uint32_t</type>               <name>maxImageDimensionCube</name></member>             <!-- max cubemap image dimension -->
            <member><type>uint32_t</type>               <name>maxImageArrayLayers</name></member>               <!-- max layers for image arrays -->
            <member><type>uint32_t</type>               <name>maxTexelBufferElements</name></member>            <!-- max texel buffer size (fstexels) -->
            <member><type>uint32_t</type>               <name>maxUniformBufferRange</name></member>             <!-- max uniform buffer range (bytes) -->
            <member><type>uint32_t</type>               <name>maxStorageBufferRange</name></member>             <!-- max storage buffer range (bytes) -->
            <member><type>uint32_t</type>               <name>maxPushConstantsSize</name></member>              <!-- max size of the push constants pool (bytes) -->
                <!-- memory limits -->
            <member><type>uint32_t</type>               <name>maxMemoryAllocationCount</name></member>          <!-- max number of device memory allocations supported -->
            <member><type>uint32_t</type>               <name>maxSamplerAllocationCount</name></member>         <!-- max number of samplers that can be allocated on a device -->
            <member><type>VkDeviceSize</type>           <name>bufferImageGranularity</name></member>            <!-- Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage -->
            <member><type>VkDeviceSize</type>           <name>sparseAddressSpaceSize</name></member>            <!-- Total address space available for sparse allocations (bytes) -->
                <!-- descriptor set limits -->
            <member><type>uint32_t</type>               <name>maxBoundDescriptorSets</name></member>                <!-- max number of descriptors sets that can be bound to a pipeline -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorSamplers</name></member>         <!-- max number of samplers allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorUniformBuffers</name></member>   <!-- max number of uniform buffers allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorStorageBuffers</name></member>   <!-- max number of storage buffers allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorSampledImages</name></member>    <!-- max number of sampled images allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorStorageImages</name></member>    <!-- max number of storage images allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorInputAttachments</name></member> <!-- max number of input attachments allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageResources</name></member>                  <!-- max number of resources allowed by a single stage -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetSamplers</name></member>              <!-- max number of samplers allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetUniformBuffers</name></member>        <!-- max number of uniform buffers allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetUniformBuffersDynamic</name></member> <!-- max number of dynamic uniform buffers allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetStorageBuffers</name></member>        <!-- max number of storage buffers allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetStorageBuffersDynamic</name></member> <!-- max number of dynamic storage buffers allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetSampledImages</name></member>         <!-- max number of sampled images allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetStorageImages</name></member>         <!-- max number of storage images allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetInputAttachments</name></member>      <!-- max number of input attachments allowed in all stages in a descriptor set -->
                <!-- vertex stage limits -->
            <member><type>uint32_t</type>               <name>maxVertexInputAttributes</name></member>          <!-- max number of vertex input attribute slots -->
            <member><type>uint32_t</type>               <name>maxVertexInputBindings</name></member>            <!-- max number of vertex input binding slots -->
            <member><type>uint32_t</type>               <name>maxVertexInputAttributeOffset</name></member>     <!-- max vertex input attribute offset added to vertex buffer offset -->
            <member><type>uint32_t</type>               <name>maxVertexInputBindingStride</name></member>       <!-- max vertex input binding stride -->
            <member><type>uint32_t</type>               <name>maxVertexOutputComponents</name></member>         <!-- max number of output components written by vertex shader -->
                <!-- tessellation control stage limits -->
            <member><type>uint32_t</type>               <name>maxTessellationGenerationLevel</name></member>                   <!-- max level supported by tessellation primitive generator -->
            <member><type>uint32_t</type>               <name>maxTessellationPatchSize</name></member>                  <!-- max patch size (vertices) -->
            <member><type>uint32_t</type>               <name>maxTessellationControlPerVertexInputComponents</name></member>    <!-- max number of input components per-vertex in TCS -->
            <member><type>uint32_t</type>               <name>maxTessellationControlPerVertexOutputComponents</name></member>   <!-- max number of output components per-vertex in TCS -->
            <member><type>uint32_t</type>               <name>maxTessellationControlPerPatchOutputComponents</name></member>    <!-- max number of output components per-patch in TCS -->
            <member><type>uint32_t</type>               <name>maxTessellationControlTotalOutputComponents</name></member>       <!-- max total number of per-vertex and per-patch output components in TCS -->
                <!-- tessellation evaluation stage limits -->
            <member><type>uint32_t</type>               <name>maxTessellationEvaluationInputComponents</name></member>  <!-- max number of input components per vertex in TES -->
            <member><type>uint32_t</type>               <name>maxTessellationEvaluationOutputComponents</name></member> <!-- max number of output components per vertex in TES -->
                <!-- geometry stage limits -->
            <member><type>uint32_t</type>               <name>maxGeometryShaderInvocations</name></member>      <!-- max invocation count supported in geometry shader -->
            <member><type>uint32_t</type>               <name>maxGeometryInputComponents</name></member>        <!-- max number of input components read in geometry stage -->
            <member><type>uint32_t</type>               <name>maxGeometryOutputComponents</name></member>       <!-- max number of output components written in geometry stage -->
            <member><type>uint32_t</type>               <name>maxGeometryOutputVertices</name></member>         <!-- max number of vertices that can be emitted in geometry stage -->
            <member><type>uint32_t</type>               <name>maxGeometryTotalOutputComponents</name></member>  <!-- max total number of components (all vertices) written in geometry stage -->
                <!-- fragment stage limits -->
            <member><type>uint32_t</type>               <name>maxFragmentInputComponents</name></member>        <!-- max number of input compontents read in fragment stage -->
            <member><type>uint32_t</type>               <name>maxFragmentOutputAttachments</name></member>      <!-- max number of output attachments written in fragment stage -->
            <member><type>uint32_t</type>               <name>maxFragmentDualSrcAttachments</name></member>     <!-- max number of output attachments written when using dual source blending -->
            <member><type>uint32_t</type>               <name>maxFragmentCombinedOutputResources</name></member><!-- max total number of storage buffers, storage images and output buffers -->
                <!-- compute stage limits -->
            <member><type>uint32_t</type>               <name>maxComputeSharedMemorySize</name></member>        <!-- max total storage size of work group local storage (bytes) -->
            <member><type>uint32_t</type>               <name>maxComputeWorkGroupCount</name>[3]</member>       <!-- max num of compute work groups that may be dispatched
                                                                                                                     by a single command (x,y,z) -->
            <member><type>uint32_t</type>               <name>maxComputeWorkGroupInvocations</name></member>    <!-- max total compute invocations in a single local work group -->
            <member><type>uint32_t</type>               <name>maxComputeWorkGroupSize</name>[3]</member>        <!-- max local size of a compute work group (x,y,z) -->

            <member><type>uint32_t</type>               <name>subPixelPrecisionBits</name></member>             <!-- number bits of subpixel precision in screen x and y-->
            <member><type>uint32_t</type>               <name>subTexelPrecisionBits</name></member>             <!-- number bits of precision for selecting texel weights-->
            <member><type>uint32_t</type>               <name>mipmapPrecisionBits</name></member>               <!-- number bits of precision for selecting mipmap weights -->

            <member><type>uint32_t</type>               <name>maxDrawIndexedIndexValue</name></member>          <!-- max index value for indexed draw calls (for 32-bit indices) -->
            <member><type>uint32_t</type>               <name>maxDrawIndirectCount</name></member>              <!-- max draw count for indirect draw calls -->

            <member><type>float</type>                  <name>maxSamplerLodBias</name></member>                 <!-- max absolute sampler level of detail bias -->
            <member><type>float</type>                  <name>maxSamplerAnisotropy</name></member>              <!-- max degree of sampler anisotropy -->

            <member><type>uint32_t</type>               <name>maxViewports</name></member>                      <!-- max number of active viewports -->
            <member><type>uint32_t</type>               <name>maxViewportDimensions</name>[2]</member>          <!-- max viewport dimensions (x,y) -->
            <member><type>float</type>                  <name>viewportBoundsRange</name>[2]</member>            <!-- viewport bounds range (min,max) -->
            <member><type>uint32_t</type>               <name>viewportSubPixelBits</name></member>              <!-- number bits of subpixel precision for viewport -->

            <member><type>size_t</type>                 <name>minMemoryMapAlignment</name></member>             <!-- min required alignment of pointers returned by MapMemory (bytes) -->
            <member><type>VkDeviceSize</type>           <name>minTexelBufferOffsetAlignment</name></member>     <!-- min required alignment for texel buffer offsets (bytes)  -->
            <member><type>VkDeviceSize</type>           <name>minUniformBufferOffsetAlignment</name></member>   <!-- min required alignment for uniform buffer sizes and offsets (bytes) -->
            <member><type>VkDeviceSize</type>           <name>minStorageBufferOffsetAlignment</name></member>   <!-- min required alignment for storage buffer offsets (bytes) -->

            <member><type>int32_t</type>                <name>minTexelOffset</name></member>                    <!-- min texel offset for OpTextureSampleOffset -->
            <member><type>uint32_t</type>               <name>maxTexelOffset</name></member>                    <!-- max texel offset for OpTextureSampleOffset -->
            <member><type>int32_t</type>                <name>minTexelGatherOffset</name></member>              <!-- min texel offset for OpTextureGatherOffset -->
            <member><type>uint32_t</type>               <name>maxTexelGatherOffset</name></member>              <!-- max texel offset for OpTextureGatherOffset -->
            <member><type>float</type>                  <name>minInterpolationOffset</name></member>            <!-- furthest negative offset for interpolateAtOffset -->
            <member><type>float</type>                  <name>maxInterpolationOffset</name></member>            <!-- furthest positive offset for interpolateAtOffset -->
            <member><type>uint32_t</type>               <name>subPixelInterpolationOffsetBits</name></member>   <!-- number of subpixel bits for interpolateAtOffset -->

            <member><type>uint32_t</type>               <name>maxFramebufferWidth</name></member>               <!-- max width for a framebuffer -->
            <member><type>uint32_t</type>               <name>maxFramebufferHeight</name></member>              <!-- max height for a framebuffer -->
            <member><type>uint32_t</type>               <name>maxFramebufferLayers</name></member>              <!-- max layer count for a layered framebuffer -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>framebufferColorSampleCounts</name></member>      <!-- supported color sample counts for a framebuffer -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>framebufferDepthSampleCounts</name></member>      <!-- supported depth sample counts for a framebuffer -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>framebufferStencilSampleCounts</name></member>    <!-- supported stencil sample counts for a framebuffer -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>framebufferNoAttachmentsSampleCounts</name></member> <!-- supported sample counts for a framebuffer with no attachments -->
            <member><type>uint32_t</type>               <name>maxColorAttachments</name></member>               <!-- max number of color attachments per subpass -->

            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageColorSampleCounts</name></member>     <!-- supported color sample counts for a non-integer sampled image -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageIntegerSampleCounts</name></member>   <!-- supported sample counts for an integer image -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageDepthSampleCounts</name></member>     <!-- supported depth sample counts for a sampled image -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageStencilSampleCounts</name></member>   <!-- supported stencil sample counts for a sampled image -->
            <member optional="true"><type>VkSampleCountFlags</type>     <name>storageImageSampleCounts</name></member>          <!-- supported sample counts for a storage image -->
            <member><type>uint32_t</type>               <name>maxSampleMaskWords</name></member>                <!-- max number of sample mask words -->

            <member><type>VkBool32</type>               <name>timestampComputeAndGraphics</name></member>       <!-- timestamps on graphics and compute queues -->
            <member><type>float</type>                  <name>timestampPeriod</name></member>                   <!-- number of nanoseconds it takes for timestamp query value to increment by 1 -->

            <member><type>uint32_t</type>               <name>maxClipDistances</name></member>                  <!-- max number of clip distances -->
            <member><type>uint32_t</type>               <name>maxCullDistances</name></member>                  <!-- max number of cull distances -->
            <member><type>uint32_t</type>               <name>maxCombinedClipAndCullDistances</name></member>   <!-- max combined number of user clipping -->

            <member><type>uint32_t</type>               <name>discreteQueuePriorities</name></member>           <!-- distinct queue priorities available  -->

            <member><type>float</type>                  <name>pointSizeRange</name>[2]</member>                 <!-- range (min,max) of supported point sizes -->
            <member><type>float</type>                  <name>lineWidthRange</name>[2]</member>                 <!-- range (min,max) of supported line widths -->
            <member><type>float</type>                  <name>pointSizeGranularity</name></member>              <!-- granularity of supported point sizes -->
            <member><type>float</type>                  <name>lineWidthGranularity</name></member>              <!-- granularity of supported line widths -->
            <member><type>VkBool32</type>               <name>strictLines</name></member>                       <!-- line rasterization follows preferred rules -->
            <member><type>VkBool32</type>               <name>standardSampleLocations</name></member>           <!-- supports standard sample locations for all supported sample counts -->
            <member><type>VkDeviceSize</type>           <name>optimalBufferCopyOffsetAlignment</name></member>  <!-- optimal offset of buffer copies -->
            <member><type>VkDeviceSize</type>           <name>optimalBufferCopyRowPitchAlignment</name></member><!-- optimal pitch of buffer copies -->
            <member><type>VkDeviceSize</type>           <name>nonCoherentAtomSize</name></member>               <!-- minimum size and alignment for non-coherent host-mapped device memory access -->
        </type>
        <type category="struct" name="VkSemaphoreCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkSemaphoreCreateFlags</type> <name>flags</name></member>                          <!-- Semaphore creation flags -->
        </type>
        <type category="struct" name="VkQueryPoolCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkQueryPoolCreateFlags</type> <name>flags</name></member>                          <!-- Reserved -->
            <member><type>VkQueryType</type>            <name>queryType</name></member>
            <member><type>uint32_t</type>               <name>queryCount</name></member>
            <member optional="true" noautovalidity="true"><type>VkQueryPipelineStatisticFlags</type> <name>pipelineStatistics</name></member>      <!-- Optional -->
            <validity>
                <usage>If the &lt;&lt;features-features-pipelineStatisticsQuery,pipeline statistics queries&gt;&gt; feature is not enabled, pname:queryType mustnot: be ename:VK_QUERY_TYPE_PIPELINE_STATISTICS</usage>
                <usage>If pname:queryType is ename:VK_QUERY_TYPE_PIPELINE_STATISTICS, pname:pipelineStatistics must: be a valid combination of elink:VkQueryPipelineStatisticFlagBits values</usage>
            </validity>
        </type>
        <type category="struct" name="VkFramebufferCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>VkFramebufferCreateFlags</type>    <name>flags</name></member>                     <!-- Reserved -->
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name></member>
            <member len="attachmentCount">const <type>VkImageView</type>*     <name>pAttachments</name></member>
            <member><type>uint32_t</type>               <name>width</name></member>
            <member><type>uint32_t</type>               <name>height</name></member>
            <member><type>uint32_t</type>               <name>layers</name></member>
            <validity>
                <usage>pname:attachmentCount must: be equal to the attachment count specified in pname:renderPass</usage>
                <usage>Any given element of pname:pAttachments that is used as a color attachment or resolve attachment by pname:renderPass must: have been created with a pname:usage value including ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</usage>
                <usage>Any given element of pname:pAttachments that is used as a depth/stencil attachment by pname:renderPass must: have been created with a pname:usage value including ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</usage>
                <usage>Any given element of pname:pAttachments that is used as an input attachment by pname:renderPass must: have been created with a pname:usage value including ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</usage>
                <usage>Any given element of pname:pAttachments must: have been created with an elink:VkFormat value that matches the elink:VkFormat specified by the corresponding sname:VkAttachmentDescription in pname:renderPass</usage>
                <usage>Any given element of pname:pAttachments must: have been created with a pname:samples value that matches the pname:samples value specified by the corresponding sname:VkAttachmentDescription in pname:renderPass</usage>
                <usage>Any given element of pname:pAttachments must: have dimensions at least as large as the corresponding framebuffer dimension</usage>
                <usage>Any given element of pname:pAttachments must: only specify a single mip-level</usage>
                <usage>Any given element of pname:pAttachments must: have been created with the identity swizzle</usage>
                <usage>pname:width must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxFramebufferWidth</usage>
                <usage>pname:height must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxFramebufferHeight</usage>
                <usage>pname:layers must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxFramebufferLayers</usage>
            </validity>
        </type>
        <type category="struct" name="VkDrawIndirectCommand">
            <member><type>uint32_t</type>               <name>vertexCount</name></member>
            <member><type>uint32_t</type>               <name>instanceCount</name></member>
            <member><type>uint32_t</type>               <name>firstVertex</name></member>
            <member><type>uint32_t</type>               <name>firstInstance</name></member>
            <validity>
                <usage>For a given vertex buffer binding, any attribute data fetched must: be entirely contained within the corresponding vertex buffer binding, as described in &lt;&lt;fxvertex-input&gt;&gt;</usage>
                <usage>If the &lt;&lt;features-features-drawIndirectFirstInstance,drawIndirectFirstInstance&gt;&gt; feature is not enabled, pname:firstInstance must: be code:0</usage>
            </validity>
        </type>
        <type category="struct" name="VkDrawIndexedIndirectCommand">
            <member><type>uint32_t</type>               <name>indexCount</name></member>
            <member><type>uint32_t</type>               <name>instanceCount</name></member>
            <member><type>uint32_t</type>               <name>firstIndex</name></member>
            <member><type>int32_t</type>                <name>vertexOffset</name></member>
            <member><type>uint32_t</type>               <name>firstInstance</name></member>
            <validity>
                <usage>For a given vertex buffer binding, any attribute data fetched must: be entirely contained within the corresponding vertex buffer binding, as described in &lt;&lt;fxvertex-input&gt;&gt;</usage>
                <usage>(pname:indexSize * (pname:firstIndex + pname:indexCount) + pname:offset) must: be less than or equal to the size of the currently bound index buffer, with pname:indexSize being based on the type specified by pname:indexType, where the index buffer, pname:indexType, and pname:offset are specified via fname:vkCmdBindIndexBuffer</usage>
                <usage>If the &lt;&lt;features-features-drawIndirectFirstInstance,drawIndirectFirstInstance&gt;&gt; feature is not enabled, pname:firstInstance must: be code:0</usage>
            </validity>
        </type>
        <type category="struct" name="VkDispatchIndirectCommand">
            <member><type>uint32_t</type>               <name>x</name></member>
            <member><type>uint32_t</type>               <name>y</name></member>
            <member><type>uint32_t</type>               <name>z</name></member>
            <validity>
                <usage>pname:x must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[0]</usage>
                <usage>pname:y must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[1]</usage>
                <usage>pname:z must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[2]</usage>
            </validity>
        </type>
        <type category="struct" name="VkSubmitInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Type of structure. Should be VK_STRUCTURE_TYPE_SUBMIT_INFO -->
            <member>const <type>void</type>*            <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member optional="true"><type>uint32_t</type>       <name>waitSemaphoreCount</name></member>
            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>*     <name>pWaitSemaphores</name></member>
            <member len="waitSemaphoreCount">const <type>VkPipelineStageFlags</type>*           <name>pWaitDstStageMask</name></member>
            <member optional="true"><type>uint32_t</type>       <name>commandBufferCount</name></member>
            <member len="commandBufferCount">const <type>VkCommandBuffer</type>*     <name>pCommandBuffers</name></member>
            <member optional="true"><type>uint32_t</type>       <name>signalSemaphoreCount</name></member>
            <member len="signalSemaphoreCount">const <type>VkSemaphore</type>*     <name>pSignalSemaphores</name></member>
            <validity>
                <usage>Any given element of pname:pSignalSemaphores must: currently be unsignaled</usage>
                <usage>Any given element of pname:pCommandBuffers must: either have been recorded with the ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, or not currently be executing on the device</usage>
                <usage>Any given element of pname:pCommandBuffers must: be in the executable state</usage>
                <usage>If any given element of pname:pCommandBuffers contains commands that execute secondary command buffers, those secondary command buffers must: have been recorded with the ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, or not currently be executing on the device</usage>
                <usage>If any given element of pname:pCommandBuffers was created with ename:VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, it mustnot: have been previously submitted without re-recording that command buffer</usage>
                <usage>If any given element of pname:pCommandBuffers contains commands that execute secondary command buffers created with ename:VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, each such secondary command buffer mustnot: have been previously submitted without re-recording that command buffer</usage>
                <usage>Any given element of pname:pCommandBuffers mustnot: contain commands that execute a secondary command buffer, if that secondary command buffer has been recorded in another primary command buffer after it was recorded into this sname:VkCommandBuffer</usage>
                <usage>Any given element of pname:pCommandBuffers must: have been created on a sname:VkCommandPool that was created for the same queue family that the calling command's pname:queue belongs to</usage>
                <usage>Any given element of pname:pCommandBuffers mustnot: have been created with ename:VK_COMMAND_BUFFER_LEVEL_SECONDARY</usage>
                <usage>Any given element of sname:VkSemaphore in pname:pWaitSemaphores must: refer to a prior signal of that sname:VkSemaphore that won't be consumed by any other wait on that semaphore</usage>
                <usage>If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, any given element of pname:pWaitDstStageMask mustnot: contain ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</usage>
                <usage>If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, any given element of pname:pWaitDstStageMask mustnot: contain ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</usage>
            </validity>
        </type>
        <!-- WSI extensions -->
        <type category="struct" name="VkDisplayPropertiesKHR">
            <member><type>VkDisplayKHR</type>                     <name>display</name></member>                  <!-- Handle of the display object -->
            <member len="null-terminated">const <type>char</type>*                      <name>displayName</name></member>              <!-- Name of the display -->
            <member><type>VkExtent2D</type>                       <name>physicalDimensions</name></member>       <!-- In millimeters? -->
            <member><type>VkExtent2D</type>                       <name>physicalResolution</name></member>       <!-- Max resolution for CRT? -->
            <member optional="true"><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name></member>      <!-- one or more bits from VkSurfaceTransformFlagsKHR -->
            <member><type>VkBool32</type>                         <name>planeReorderPossible</name></member>     <!-- VK_TRUE if the overlay plane's z-order can be changed on this display. -->
            <member><type>VkBool32</type>                         <name>persistentContent</name></member>        <!-- VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering. -->
        </type>
        <type category="struct" name="VkDisplayPlanePropertiesKHR">
            <member><type>VkDisplayKHR</type>                     <name>currentDisplay</name></member>           <!-- Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use. -->
            <member><type>uint32_t</type>                         <name>currentStackIndex</name></member>        <!-- Current z-order of the plane. -->
        </type>
        <type category="struct" name="VkDisplayModeParametersKHR">
            <member><type>VkExtent2D</type>                       <name>visibleRegion</name></member>            <!-- Visible scannout region. -->
            <member><type>uint32_t</type>                         <name>refreshRate</name></member>              <!-- Number of times per second the display is updated. -->
        </type>
        <type category="struct" name="VkDisplayModePropertiesKHR">
            <member><type>VkDisplayModeKHR</type>                 <name>displayMode</name></member>              <!-- Handle of this display mode. -->
            <member><type>VkDisplayModeParametersKHR</type>       <name>parameters</name></member>               <!-- The parameters this mode uses. -->
        </type>
        <type category="struct" name="VkDisplayModeCreateInfoKHR">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkDisplayModeCreateFlagsKHR</type>      <name>flags</name></member>                    <!-- Reserved -->
            <member><type>VkDisplayModeParametersKHR</type>       <name>parameters</name></member>               <!-- The parameters this mode uses. -->
            <validity>
                <usage>The pname:width and pname:height members of the pname:visibleRegion member of pname:parameters must: be greater than `0`</usage>
                <usage>The pname:refreshRate member of pname:parameters must: be greater than `0`</usage>
            </validity>
        </type>
        <type category="struct" name="VkDisplayPlaneCapabilitiesKHR">
            <member optional="true"><type>VkDisplayPlaneAlphaFlagsKHR</type>      <name>supportedAlpha</name></member>           <!-- Types of alpha blending supported, if any. -->
            <member><type>VkOffset2D</type>                       <name>minSrcPosition</name></member>           <!-- Does the plane have any position and extent restrictions? -->
            <member><type>VkOffset2D</type>                       <name>maxSrcPosition</name></member>
            <member><type>VkExtent2D</type>                       <name>minSrcExtent</name></member>
            <member><type>VkExtent2D</type>                       <name>maxSrcExtent</name></member>
            <member><type>VkOffset2D</type>                       <name>minDstPosition</name></member>
            <member><type>VkOffset2D</type>                       <name>maxDstPosition</name></member>
            <member><type>VkExtent2D</type>                       <name>minDstExtent</name></member>
            <member><type>VkExtent2D</type>                       <name>maxDstExtent</name></member>
        </type>
        <type category="struct" name="VkDisplaySurfaceCreateInfoKHR">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkDisplaySurfaceCreateFlagsKHR</type>   <name>flags</name></member>                    <!-- Reserved -->
            <member><type>VkDisplayModeKHR</type>                 <name>displayMode</name></member>              <!-- The mode to use when displaying this surface -->
            <member><type>uint32_t</type>                         <name>planeIndex</name></member>               <!-- The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount. -->
            <member><type>uint32_t</type>                         <name>planeStackIndex</name></member>          <!-- The z-order of the plane. -->
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>transform</name></member>                <!-- Transform to apply to the images as part of the scannout operation -->
            <member><type>float</type>                            <name>globalAlpha</name></member>              <!-- Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR -->
            <member><type>VkDisplayPlaneAlphaFlagBitsKHR</type>   <name>alphaMode</name></member>                <!-- What type of alpha blending to use.  Must be a bit from vkGetDisplayPlanePropertiesKHR::supportedAlpha. -->
            <member><type>VkExtent2D</type>                       <name>imageExtent</name></member>              <!-- size of the images to use with this surface -->
            <validity>
                <usage>pname:planeIndex must: be less than the number of display planes supported by the device as determined by calling fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR</usage>
                <usage>If the pname:planeReorderPossible member of the sname:VkDisplayPropertiesKHR structure returned by fname:vkGetPhysicalDeviceDisplayPropertiesKHR for the display corresponding to pname:displayMode is ename:VK_TRUE then pname:planeStackIndex must: be less than the number of display planes supported by the device as determined by calling fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR; otherwise pname:planeStackIndex must: equal the pname:currentStackIndex member of sname:VkDisplayPlanePropertiesKHR returned by fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR for the display plane corresponding to pname:displayMode</usage>
                <usage>If pname:alphaMode is ename:VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR then pname:globalAlpha must: be between `0` and `1`, inclusive</usage>
                <usage>pname:alphaMode must: be `0` or one of the bits present in the pname:supportedAlpha member of sname:VkDisplayPlaneCapabilitiesKHR returned by fname:vkGetDisplayPlaneCapabilitiesKHR for the display plane corresponding to pname:displayMode</usage>
                <usage>The pname:width and pname:height members of pname:imageExtent must: be less than the pname:maxImageDimensions2D member of sname:VkPhysicalDeviceLimits</usage>
            </validity>
        </type>
        <type category="struct" name="VkDisplayPresentInfoKHR">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member><type>VkRect2D</type>                         <name>srcRect</name></member>                  <!-- Rectangle within the presentable image to read pixel data from when presenting to the display. -->
            <member><type>VkRect2D</type>                         <name>dstRect</name></member>                  <!-- Rectangle within the current display mode's visible region to display srcRectangle in. -->
            <member><type>VkBool32</type>                         <name>persistent</name></member>               <!-- For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE. -->
            <validity>
                <usage>pname:srcRect must: specify a rectangular region that is a subset of the image being presented</usage>
                <usage>pname:dstRect must: specify a rectangular region that is a subset of the pname:visibleRegion parameter of the display mode the swapchain being presented uses</usage>
                <usage>If the pname:persistentContent member of the sname:VkDisplayPropertiesKHR structure returned by fname:vkGetPhysicalDeviceDisplayPropertiesKHR for the display the present operation targets then pname:persistent must: be ename:VK_FALSE</usage>
            </validity>
        </type>
        <type category="struct" name="VkSurfaceCapabilitiesKHR">
            <member><type>uint32_t</type>                         <name>minImageCount</name></member>            <!-- Supported minimum number of images for the surface -->
            <member><type>uint32_t</type>                         <name>maxImageCount</name></member>            <!-- Supported maximum number of images for the surface, 0 for unlimited -->
            <member><type>VkExtent2D</type>                       <name>currentExtent</name></member>            <!-- Current image width and height for the surface, (0, 0) if undefined -->
            <member><type>VkExtent2D</type>                       <name>minImageExtent</name></member>           <!-- Supported minimum image width and height for the surface -->
            <member><type>VkExtent2D</type>                       <name>maxImageExtent</name></member>           <!-- Supported maximum image width and height for the surface -->
            <member><type>uint32_t</type>                         <name>maxImageArrayLayers</name></member>      <!-- Supported maximum number of image layers for the surface -->
            <member optional="true"><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name></member>      <!-- 1 or more bits representing the transforms supported -->
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>currentTransform</name></member>         <!-- The surface's current transform relative to the device's natural orientation -->
            <member optional="true"><type>VkCompositeAlphaFlagsKHR</type>         <name>supportedCompositeAlpha</name></member>  <!-- 1 or more bits representing the alpha compositing modes supported -->
            <member optional="true"><type>VkImageUsageFlags</type>                <name>supportedUsageFlags</name></member>      <!-- Supported image usage flags for the surface -->
        </type>
        <type category="struct" name="VkAndroidSurfaceCreateInfoKHR">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkAndroidSurfaceCreateFlagsKHR</type>   <name>flags</name></member>    <!-- Reserved -->
            <member><type>ANativeWindow</type>*                   <name>window</name></member>
            <validity>
                <usage>pname:window mustnot: be in a connected state</usage>
            </validity>
        </type>
        <type category="struct" name="VkMirSurfaceCreateInfoKHR">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkMirSurfaceCreateFlagsKHR</type>   <name>flags</name></member>        <!-- Reserved -->
            <member><type>MirConnection</type>*                   <name>connection</name></member>
            <member><type>MirSurface</type>*                      <name>mirSurface</name></member>
        </type>
        <type category="struct" name="VkWaylandSurfaceCreateInfoKHR">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkWaylandSurfaceCreateFlagsKHR</type>   <name>flags</name></member>    <!-- Reserved -->
            <member>struct <type>wl_display</type>*               <name>display</name></member>
            <member>struct <type>wl_surface</type>*               <name>surface</name></member>
        </type>
        <type category="struct" name="VkWin32SurfaceCreateInfoKHR">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkWin32SurfaceCreateFlagsKHR</type>   <name>flags</name></member>      <!-- Reserved -->
            <member><type>HINSTANCE</type>                        <name>hinstance</name></member>
            <member><type>HWND</type>                             <name>hwnd</name></member>
        </type>
        <type category="struct" name="VkXlibSurfaceCreateInfoKHR">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkXlibSurfaceCreateFlagsKHR</type>   <name>flags</name></member>       <!-- Reserved -->
            <member><type>Display</type>*                         <name>dpy</name></member>
            <member><type>Window</type>                           <name>window</name></member>
        </type>
        <type category="struct" name="VkXcbSurfaceCreateInfoKHR">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkXcbSurfaceCreateFlagsKHR</type>   <name>flags</name></member>        <!-- Reserved -->
            <member><type>xcb_connection_t</type>*                <name>connection</name></member>
            <member><type>xcb_window_t</type>                     <name>window</name></member>
        </type>
        <type category="struct" name="VkSurfaceFormatKHR">
            <member><type>VkFormat</type>                         <name>format</name></member>                   <!-- Supported pair of rendering format -->
            <member><type>VkColorSpaceKHR</type>                  <name>colorSpace</name></member>               <!-- and colorspace for the surface -->
        </type>
        <type category="struct" name="VkSwapchainCreateInfoKHR">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>VkSwapchainCreateFlagsKHR</type>        <name>flags</name></member>                    <!-- Reserved -->
            <member><type>VkSurfaceKHR</type>                     <name>surface</name></member>                  <!-- The swapchain's target surface -->
            <member><type>uint32_t</type>                         <name>minImageCount</name></member>            <!-- Minimum number of presentation images the application needs -->
            <member><type>VkFormat</type>                         <name>imageFormat</name></member>              <!-- Format of the presentation images -->
            <member><type>VkColorSpaceKHR</type>                  <name>imageColorSpace</name></member>          <!-- Colorspace of the presentation images -->
            <member><type>VkExtent2D</type>                       <name>imageExtent</name></member>              <!-- Dimensions of the presentation images -->
            <member><type>uint32_t</type>                         <name>imageArrayLayers</name></member>         <!-- Determines the number of views for multiview/stereo presentation -->
            <member><type>VkImageUsageFlags</type>                <name>imageUsage</name></member>               <!-- Bits indicating how the presentation images will be used -->
            <member><type>VkSharingMode</type>                    <name>imageSharingMode</name></member>         <!-- Sharing mode used for the presentation images -->
            <member optional="true"><type>uint32_t</type>         <name>queueFamilyIndexCount</name></member>    <!-- Number of queue families having access to the images in case of concurrent sharing mode -->
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*                  <name>pQueueFamilyIndices</name></member>      <!-- Array of queue family indices having access to the images in case of concurrent sharing mode -->
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>preTransform</name></member>             <!-- The transform, relative to the device's natural orientation, applied to the image content prior to presentation -->
            <member><type>VkCompositeAlphaFlagBitsKHR</type>      <name>compositeAlpha</name></member>           <!-- The alpha blending mode used when compositing this surface with other surfaces in the window system -->
            <member><type>VkPresentModeKHR</type>                 <name>presentMode</name></member>              <!-- Which presentation mode to use for presents on this swap chain -->
            <member><type>VkBool32</type>                         <name>clipped</name></member>                  <!-- Specifies whether presentable images may be affected by window clip regions -->
            <member optional="true"><type>VkSwapchainKHR</type>   <name>oldSwapchain</name></member>             <!-- Existing swap chain to replace, if any -->
            <validity>
                <usage>pname:surface must: be a surface that is supported by the device as determined using fname:vkGetPhysicalDeviceSurfaceSupportKHR</usage>
                <usage>The native window referred to by pname:surface mustnot: already be associated with a swapchain other than pname:oldSwapchain, or with a non-Vulkan graphics API surface</usage>
                <usage>pname:minImageCount must: be greater than or equal to the value returned in the pname:minImageCount member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</usage>
                <usage>pname:minImageCount must: be less than or equal to the value returned in the pname:maxImageCount member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface if the returned pname:maxImageCount is not zero</usage>
                <usage>pname:imageFormat and pname:imageColorspace must: match the pname:format and pname:colorSpace members, respectively, of one of the sname:VkSurfaceFormatKHR structures returned by fname:vkGetPhysicalDeviceSurfaceFormatsKHR for the surface</usage>
                <usage>pname:imageExtent must: be between pname:minImageExtent and pname:maxImageExtent, inclusive, where pname:minImageExtent and pname:maxImageExtent are members of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</usage>
                <usage>pname:imageArrayLayers must: be greater than `0` and less than or equal to the pname:maxImageArrayLayers member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</usage>
                <usage>pname:imageUsage must: be a subset of the supported usage flags present in the pname:supportedUsageFlags member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</usage>
                <usage>If pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:pQueueFamilyIndices must: be a pointer to an array of pname:queueFamilyIndexCount basetype:uint32_t values</usage>
                <usage>If pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT, pname:queueFamilyIndexCount must: be greater than `1`</usage>
                <usage>pname:preTransform must: be one of the bits present in the pname:supportedTransforms member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</usage>
                <usage>pname:compositeAlpha must: be one of the bits present in the pname:supportedCompositeAlpha member of the sname:VkSurfaceCapabilitiesKHR structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</usage>
                <usage>pname:presentMode must: be one of the ename:VkPresentModeKHR values returned by fname:vkGetPhysicalDeviceSurfacePresentModesKHR for the surface</usage>
            </validity>
        </type>
        <type category="struct" name="VkPresentInfoKHR">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_PRESENT_INFO_KHR -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreCount</name></member>       <!-- Number of semaphores to wait for before presenting -->
            <member optional="true" len="waitSemaphoreCount">const <type>VkSemaphore</type>* <name>pWaitSemaphores</name></member> <!-- Semaphores to wait for before presenting -->
            <member><type>uint32_t</type>                         <name>swapchainCount</name></member>           <!-- Number of swap chains to present in this call -->
            <member len="swapchainCount">const <type>VkSwapchainKHR</type>* <name>pSwapchains</name></member>    <!-- Swapchains to present an image from -->
            <member len="swapchainCount">const <type>uint32_t</type>* <name>pImageIndices</name></member>        <!-- Indices of which swapchain images to present -->
            <member optional="true" len="swapchainCount"><type>VkResult</type>* <name>pResults</name></member>   <!-- Optional (i.e. if non-NULL) VkResult for each swapchain -->
            <validity>
                <usage>Any given element of pname:pImageIndices must: be the index of a presentable image acquired from the swapchain specified by the corresponding element of the pname:pSwapchains array</usage>
                <usage>Any given element of sname:VkSemaphore in pname:pWaitSemaphores must: refer to a prior signal of that sname:VkSemaphore that won't be consumed by any other wait on that semaphore</usage>
            </validity>
        </type>
        <type category="struct" name="VkDebugReportCallbackCreateInfoEXT">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member><type>VkDebugReportFlagsEXT</type>            <name>flags</name></member>                    <!-- Indicates which events call this callback-->
            <member><type>PFN_vkDebugReportCallbackEXT</type>     <name>pfnCallback</name></member>              <!-- Function pointer of a callback function-->
            <member optional="true"><type>void</type>*            <name>pUserData</name></member>                <!-- User data provided to callback function -->
        </type>
        <type category="struct" name="VkPipelineRasterizationStateRasterizationOrderAMD">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member><type>VkRasterizationOrderAMD</type>          <name>rasterizationOrder</name></member>       <!-- Rasterization order to use for the pipeline -->
        </type>
        <type category="struct" name="VkDebugMarkerObjectNameInfoEXT">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member><type>VkDebugReportObjectTypeEXT</type>       <name>objectType</name></member>               <!-- The type of the object -->
            <member><type>uint64_t</type>                         <name>object</name></member>                   <!-- The handle of the object, cast to uint64_t -->
            <member len="null-terminated">const <type>char</type>* <name>pObjectName</name></member>             <!-- Name to apply to the object -->
        </type>
        <type category="struct" name="VkDebugMarkerObjectTagInfoEXT">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member><type>VkDebugReportObjectTypeEXT</type>       <name>objectType</name></member>               <!-- The type of the object -->
            <member><type>uint64_t</type>                         <name>object</name></member>                   <!-- The handle of the object, cast to uint64_t -->
            <member><type>uint64_t</type>                         <name>tagName</name></member>                  <!-- The name of the tag to set on the object -->
            <member><type>size_t</type>                           <name>tagSize</name></member>                  <!-- The length in bytes of the tag data -->
            <member len="tagSize">const <type>void</type>*        <name>pTag</name></member>                     <!-- Tag data to attach to the object -->
        </type>
        <type category="struct" name="VkDebugMarkerMarkerInfoEXT">
            <member><type>VkStructureType</type>                  <name>sType</name></member>                    <!-- Must be VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT -->
            <member>const <type>void</type>*                      <name>pNext</name></member>                    <!-- Pointer to next structure -->
            <member len="null-terminated">const <type>char</type>* <name>pMarkerName</name></member>             <!-- Name of the debug marker -->
            <member optional="true"><type>float</type>            <name>color</name>[4]</member>                 <!-- Optional color for debug marker -->
        </type>
    </types>

    <!-- SECTION: Vulkan enumerant (token) definitions. -->

    <enums name="API Constants" comment="Misc. hardcoded constants - not an enumerated type">
            <!-- This is part of the header boilerplate -->
        <enum value="256"   name="VK_MAX_PHYSICAL_DEVICE_NAME_SIZE"/>
        <enum value="16"    name="VK_UUID_SIZE"/>
        <enum value="256"   name="VK_MAX_EXTENSION_NAME_SIZE"/>
        <enum value="256"   name="VK_MAX_DESCRIPTION_SIZE"/>
        <enum value="32"    name="VK_MAX_MEMORY_TYPES"/>
        <enum value="16"    name="VK_MAX_MEMORY_HEAPS"/> <!-- The maximum number of unique memory heaps, each of which supporting 1 or more memory types. -->
        <enum value="1000.0f" name="VK_LOD_CLAMP_NONE"/>
        <enum value="(~0U)" name="VK_REMAINING_MIP_LEVELS"/>
        <enum value="(~0U)" name="VK_REMAINING_ARRAY_LAYERS"/>
        <enum value="(~0ULL)" name="VK_WHOLE_SIZE"/>
        <enum value="(~0U)" name="VK_ATTACHMENT_UNUSED"/>
        <enum value="1"     name="VK_TRUE"/>
        <enum value="0"     name="VK_FALSE"/>
        <enum value="(~0U)" name="VK_QUEUE_FAMILY_IGNORED"/>
        <enum value="(~0U)" name="VK_SUBPASS_EXTERNAL"/>
    </enums>

    <!-- Unlike OpenGL, most tokens in Vulkan are actual typed enumerants in
         their own numeric namespaces. The "name" attribute is the C enum
         type name, and is pulled in from a <type> definition above
         (slightly clunky, but retains the type / enum distinction). "type"
         attributes of "enum" or "bitmask" indicate that these values should
         be generated inside an appropriate definition. -->

    <enums name="VkImageLayout" type="enum">
        <enum value="0"     name="VK_IMAGE_LAYOUT_UNDEFINED"                         comment="Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)"/>
        <enum value="1"     name="VK_IMAGE_LAYOUT_GENERAL"                           comment="General layout when image can be used for any kind of access"/>
        <enum value="2"     name="VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"          comment="Optimal layout when image is only used for color attachment read/write"/>
        <enum value="3"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"  comment="Optimal layout when image is only used for depth/stencil attachment read/write"/>
        <enum value="4"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"   comment="Optimal layout when image is used for read only depth/stencil attachment and shader access"/>
        <enum value="5"     name="VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"          comment="Optimal layout when image is used for read only shader access"/>
        <enum value="6"     name="VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"           comment="Optimal layout when image is used only as source of transfer operations"/>
        <enum value="7"     name="VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"      comment="Optimal layout when image is used only as destination of transfer operations"/>
        <enum value="8"     name="VK_IMAGE_LAYOUT_PREINITIALIZED"                    comment="Initial layout used when the data is populated by the CPU"/>
    </enums>
    <enums name="VkAttachmentLoadOp" type="enum">
        <enum value="0"     name="VK_ATTACHMENT_LOAD_OP_LOAD"/>
        <enum value="1"     name="VK_ATTACHMENT_LOAD_OP_CLEAR"/>
        <enum value="2"     name="VK_ATTACHMENT_LOAD_OP_DONT_CARE"/>
    </enums>
    <enums name="VkAttachmentStoreOp" type="enum">
        <enum value="0"     name="VK_ATTACHMENT_STORE_OP_STORE"/>
        <enum value="1"     name="VK_ATTACHMENT_STORE_OP_DONT_CARE"/>
    </enums>
    <enums name="VkImageType" type="enum">
        <enum value="0"     name="VK_IMAGE_TYPE_1D"/>
        <enum value="1"     name="VK_IMAGE_TYPE_2D"/>
        <enum value="2"     name="VK_IMAGE_TYPE_3D"/>
    </enums>
    <enums name="VkImageTiling" type="enum">
        <enum value="0"     name="VK_IMAGE_TILING_OPTIMAL"/>
        <enum value="1"     name="VK_IMAGE_TILING_LINEAR"/>
    </enums>
    <enums name="VkImageViewType" type="enum">
        <enum value="0"     name="VK_IMAGE_VIEW_TYPE_1D"/>
        <enum value="1"     name="VK_IMAGE_VIEW_TYPE_2D"/>
        <enum value="2"     name="VK_IMAGE_VIEW_TYPE_3D"/>
        <enum value="3"     name="VK_IMAGE_VIEW_TYPE_CUBE"/>
        <enum value="4"     name="VK_IMAGE_VIEW_TYPE_1D_ARRAY"/>
        <enum value="5"     name="VK_IMAGE_VIEW_TYPE_2D_ARRAY"/>
        <enum value="6"     name="VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"/>
    </enums>
    <enums name="VkCommandBufferLevel" type="enum">
        <enum value="0"     name="VK_COMMAND_BUFFER_LEVEL_PRIMARY"/>
        <enum value="1"     name="VK_COMMAND_BUFFER_LEVEL_SECONDARY"/>
    </enums>
    <enums name="VkComponentSwizzle" type="enum">
        <enum value="0"     name="VK_COMPONENT_SWIZZLE_IDENTITY"/>
        <enum value="1"     name="VK_COMPONENT_SWIZZLE_ZERO"/>
        <enum value="2"     name="VK_COMPONENT_SWIZZLE_ONE"/>
        <enum value="3"     name="VK_COMPONENT_SWIZZLE_R"/>
        <enum value="4"     name="VK_COMPONENT_SWIZZLE_G"/>
        <enum value="5"     name="VK_COMPONENT_SWIZZLE_B"/>
        <enum value="6"     name="VK_COMPONENT_SWIZZLE_A"/>
    </enums>
    <enums name="VkDescriptorType" type="enum">
        <enum value="0"     name="VK_DESCRIPTOR_TYPE_SAMPLER"/>
        <enum value="1"     name="VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"/>
        <enum value="2"     name="VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"/>
        <enum value="3"     name="VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"/>
        <enum value="4"     name="VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"/>
        <enum value="5"     name="VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"/>
        <enum value="6"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"/>
        <enum value="7"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"/>
        <enum value="8"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"/>
        <enum value="9"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"/>
        <enum value="10"    name="VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"/>
    </enums>
    <enums name="VkQueryType" type="enum">
        <enum value="0"     name="VK_QUERY_TYPE_OCCLUSION"/>
        <enum value="1"     name="VK_QUERY_TYPE_PIPELINE_STATISTICS"                 comment="Optional"/>
        <enum value="2"     name="VK_QUERY_TYPE_TIMESTAMP"/>
    </enums>
    <enums name="VkBorderColor" type="enum">
        <enum value="0"     name="VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"/>
        <enum value="1"     name="VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"/>
        <enum value="2"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"/>
        <enum value="3"     name="VK_BORDER_COLOR_INT_OPAQUE_BLACK"/>
        <enum value="4"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"/>
        <enum value="5"     name="VK_BORDER_COLOR_INT_OPAQUE_WHITE"/>
    </enums>
    <enums name="VkPipelineBindPoint" type="enum">
        <enum value="0"     name="VK_PIPELINE_BIND_POINT_GRAPHICS"/>
        <enum value="1"     name="VK_PIPELINE_BIND_POINT_COMPUTE"/>
    </enums>
    <enums name="VkPipelineCacheHeaderVersion" type="enum">
       <enum value="1"     name="VK_PIPELINE_CACHE_HEADER_VERSION_ONE"/>
    </enums>
    <enums name="VkPrimitiveTopology" type="enum">
        <enum value="0"     name="VK_PRIMITIVE_TOPOLOGY_POINT_LIST"/>
        <enum value="1"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST"/>
        <enum value="2"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"/>
        <enum value="3"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"/>
        <enum value="4"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"/>
        <enum value="5"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"/>
        <enum value="6"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"/>
        <enum value="7"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"/>
        <enum value="8"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"/>
        <enum value="9"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"/>
        <enum value="10"    name="VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"/>
    </enums>
    <enums name="VkSharingMode" type="enum">
        <enum value="0"     name="VK_SHARING_MODE_EXCLUSIVE"/>
        <enum value="1"     name="VK_SHARING_MODE_CONCURRENT"/>
    </enums>
    <enums name="VkIndexType" type="enum">
        <enum value="0"     name="VK_INDEX_TYPE_UINT16"/>
        <enum value="1"     name="VK_INDEX_TYPE_UINT32"/>
    </enums>
    <enums name="VkFilter" type="enum">
        <enum value="0"     name="VK_FILTER_NEAREST"/>
        <enum value="1"     name="VK_FILTER_LINEAR"/>
    </enums>
    <enums name="VkSamplerMipmapMode" type="enum">
        <enum value="0"     name="VK_SAMPLER_MIPMAP_MODE_NEAREST"                        comment="Choose nearest mip level"/>
        <enum value="1"     name="VK_SAMPLER_MIPMAP_MODE_LINEAR"                         comment="Linear filter between mip levels"/>
    </enums>
    <enums name="VkSamplerAddressMode" type="enum">
        <enum value="0"     name="VK_SAMPLER_ADDRESS_MODE_REPEAT"/>
        <enum value="1"     name="VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"/>
        <enum value="2"     name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"/>
        <enum value="3"     name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"/>
        <!-- <enum value="4"     name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" comment="Reserved for VK_KHR_sampler_mirror_clamp_to_edge, do not alias!"/> -->
    </enums>
    <enums name="VkCompareOp" type="enum">
        <enum value="0"     name="VK_COMPARE_OP_NEVER"/>
        <enum value="1"     name="VK_COMPARE_OP_LESS"/>
        <enum value="2"     name="VK_COMPARE_OP_EQUAL"/>
        <enum value="3"     name="VK_COMPARE_OP_LESS_OR_EQUAL"/>
        <enum value="4"     name="VK_COMPARE_OP_GREATER"/>
        <enum value="5"     name="VK_COMPARE_OP_NOT_EQUAL"/>
        <enum value="6"     name="VK_COMPARE_OP_GREATER_OR_EQUAL"/>
        <enum value="7"     name="VK_COMPARE_OP_ALWAYS"/>
    </enums>
    <enums name="VkPolygonMode" type="enum">
        <enum value="0"     name="VK_POLYGON_MODE_FILL"/>
        <enum value="1"     name="VK_POLYGON_MODE_LINE"/>
        <enum value="2"     name="VK_POLYGON_MODE_POINT"/>
    </enums>
    <enums name="VkCullModeFlagBits" type="bitmask">
        <enum value="0"     name="VK_CULL_MODE_NONE"/>
        <enum bitpos="0"    name="VK_CULL_MODE_FRONT_BIT"/>
        <enum bitpos="1"    name="VK_CULL_MODE_BACK_BIT"/>
        <enum value="0x00000003" name="VK_CULL_MODE_FRONT_AND_BACK"/>
    </enums>
    <enums name="VkFrontFace" type="enum">
        <enum value="0"     name="VK_FRONT_FACE_COUNTER_CLOCKWISE"/>
        <enum value="1"     name="VK_FRONT_FACE_CLOCKWISE"/>
    </enums>
    <enums name="VkBlendFactor" type="enum">
        <enum value="0"     name="VK_BLEND_FACTOR_ZERO"/>
        <enum value="1"     name="VK_BLEND_FACTOR_ONE"/>
        <enum value="2"     name="VK_BLEND_FACTOR_SRC_COLOR"/>
        <enum value="3"     name="VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"/>
        <enum value="4"     name="VK_BLEND_FACTOR_DST_COLOR"/>
        <enum value="5"     name="VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"/>
        <enum value="6"     name="VK_BLEND_FACTOR_SRC_ALPHA"/>
        <enum value="7"     name="VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"/>
        <enum value="8"     name="VK_BLEND_FACTOR_DST_ALPHA"/>
        <enum value="9"     name="VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"/>
        <enum value="10"    name="VK_BLEND_FACTOR_CONSTANT_COLOR"/>
        <enum value="11"    name="VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"/>
        <enum value="12"    name="VK_BLEND_FACTOR_CONSTANT_ALPHA"/>
        <enum value="13"    name="VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"/>
        <enum value="14"    name="VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"/>
        <enum value="15"    name="VK_BLEND_FACTOR_SRC1_COLOR"/>
        <enum value="16"    name="VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"/>
        <enum value="17"    name="VK_BLEND_FACTOR_SRC1_ALPHA"/>
        <enum value="18"    name="VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"/>
    </enums>
    <enums name="VkBlendOp" type="enum">
        <enum value="0"     name="VK_BLEND_OP_ADD"/>
        <enum value="1"     name="VK_BLEND_OP_SUBTRACT"/>
        <enum value="2"     name="VK_BLEND_OP_REVERSE_SUBTRACT"/>
        <enum value="3"     name="VK_BLEND_OP_MIN"/>
        <enum value="4"     name="VK_BLEND_OP_MAX"/>
    </enums>
    <enums name="VkStencilOp" type="enum">
        <enum value="0"     name="VK_STENCIL_OP_KEEP"/>
        <enum value="1"     name="VK_STENCIL_OP_ZERO"/>
        <enum value="2"     name="VK_STENCIL_OP_REPLACE"/>
        <enum value="3"     name="VK_STENCIL_OP_INCREMENT_AND_CLAMP"/>
        <enum value="4"     name="VK_STENCIL_OP_DECREMENT_AND_CLAMP"/>
        <enum value="5"     name="VK_STENCIL_OP_INVERT"/>
        <enum value="6"     name="VK_STENCIL_OP_INCREMENT_AND_WRAP"/>
        <enum value="7"     name="VK_STENCIL_OP_DECREMENT_AND_WRAP"/>
    </enums>
    <enums name="VkLogicOp" type="enum">
        <enum value="0"     name="VK_LOGIC_OP_CLEAR"/>
        <enum value="1"     name="VK_LOGIC_OP_AND"/>
        <enum value="2"     name="VK_LOGIC_OP_AND_REVERSE"/>
        <enum value="3"     name="VK_LOGIC_OP_COPY"/>
        <enum value="4"     name="VK_LOGIC_OP_AND_INVERTED"/>
        <enum value="5"     name="VK_LOGIC_OP_NO_OP"/>
        <enum value="6"     name="VK_LOGIC_OP_XOR"/>
        <enum value="7"     name="VK_LOGIC_OP_OR"/>
        <enum value="8"     name="VK_LOGIC_OP_NOR"/>
        <enum value="9"     name="VK_LOGIC_OP_EQUIVALENT"/>
        <enum value="10"    name="VK_LOGIC_OP_INVERT"/>
        <enum value="11"    name="VK_LOGIC_OP_OR_REVERSE"/>
        <enum value="12"    name="VK_LOGIC_OP_COPY_INVERTED"/>
        <enum value="13"    name="VK_LOGIC_OP_OR_INVERTED"/>
        <enum value="14"    name="VK_LOGIC_OP_NAND"/>
        <enum value="15"    name="VK_LOGIC_OP_SET"/>
    </enums>
    <enums name="VkInternalAllocationType" type="enum">
        <enum value="0"     name="VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"/>
    </enums>
    <enums name="VkSystemAllocationScope" type="enum">
        <enum value="0"     name="VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"/>
        <enum value="1"     name="VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"/>
        <enum value="2"     name="VK_SYSTEM_ALLOCATION_SCOPE_CACHE"/>
        <enum value="3"     name="VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"/>
        <enum value="4"     name="VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"/>
    </enums>
    <enums name="VkPhysicalDeviceType" type="enum">
        <enum value="0"     name="VK_PHYSICAL_DEVICE_TYPE_OTHER"/>
        <enum value="1"     name="VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"/>
        <enum value="2"     name="VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"/>
        <enum value="3"     name="VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"/>
        <enum value="4"     name="VK_PHYSICAL_DEVICE_TYPE_CPU"/>
    </enums>
    <enums name="VkVertexInputRate" type="enum">
        <enum value="0"     name="VK_VERTEX_INPUT_RATE_VERTEX"/>
        <enum value="1"     name="VK_VERTEX_INPUT_RATE_INSTANCE"/>
    </enums>
    <enums name="VkFormat" type="enum" comment="Vulkan format definitions">
        <enum value="0"     name="VK_FORMAT_UNDEFINED"/>
        <enum value="1"     name="VK_FORMAT_R4G4_UNORM_PACK8"/>
        <enum value="2"     name="VK_FORMAT_R4G4B4A4_UNORM_PACK16"/>
        <enum value="3"     name="VK_FORMAT_B4G4R4A4_UNORM_PACK16"/>
        <enum value="4"     name="VK_FORMAT_R5G6B5_UNORM_PACK16"/>
        <enum value="5"     name="VK_FORMAT_B5G6R5_UNORM_PACK16"/>
        <enum value="6"     name="VK_FORMAT_R5G5B5A1_UNORM_PACK16"/>
        <enum value="7"     name="VK_FORMAT_B5G5R5A1_UNORM_PACK16"/>
        <enum value="8"     name="VK_FORMAT_A1R5G5B5_UNORM_PACK16"/>
        <enum value="9"     name="VK_FORMAT_R8_UNORM"/>
        <enum value="10"    name="VK_FORMAT_R8_SNORM"/>
        <enum value="11"    name="VK_FORMAT_R8_USCALED"/>
        <enum value="12"    name="VK_FORMAT_R8_SSCALED"/>
        <enum value="13"    name="VK_FORMAT_R8_UINT"/>
        <enum value="14"    name="VK_FORMAT_R8_SINT"/>
        <enum value="15"    name="VK_FORMAT_R8_SRGB"/>
        <enum value="16"    name="VK_FORMAT_R8G8_UNORM"/>
        <enum value="17"    name="VK_FORMAT_R8G8_SNORM"/>
        <enum value="18"    name="VK_FORMAT_R8G8_USCALED"/>
        <enum value="19"    name="VK_FORMAT_R8G8_SSCALED"/>
        <enum value="20"    name="VK_FORMAT_R8G8_UINT"/>
        <enum value="21"    name="VK_FORMAT_R8G8_SINT"/>
        <enum value="22"    name="VK_FORMAT_R8G8_SRGB"/>
        <enum value="23"    name="VK_FORMAT_R8G8B8_UNORM"/>
        <enum value="24"    name="VK_FORMAT_R8G8B8_SNORM"/>
        <enum value="25"    name="VK_FORMAT_R8G8B8_USCALED"/>
        <enum value="26"    name="VK_FORMAT_R8G8B8_SSCALED"/>
        <enum value="27"    name="VK_FORMAT_R8G8B8_UINT"/>
        <enum value="28"    name="VK_FORMAT_R8G8B8_SINT"/>
        <enum value="29"    name="VK_FORMAT_R8G8B8_SRGB"/>
        <enum value="30"    name="VK_FORMAT_B8G8R8_UNORM"/>
        <enum value="31"    name="VK_FORMAT_B8G8R8_SNORM"/>
        <enum value="32"    name="VK_FORMAT_B8G8R8_USCALED"/>
        <enum value="33"    name="VK_FORMAT_B8G8R8_SSCALED"/>
        <enum value="34"    name="VK_FORMAT_B8G8R8_UINT"/>
        <enum value="35"    name="VK_FORMAT_B8G8R8_SINT"/>
        <enum value="36"    name="VK_FORMAT_B8G8R8_SRGB"/>
        <enum value="37"    name="VK_FORMAT_R8G8B8A8_UNORM"/>
        <enum value="38"    name="VK_FORMAT_R8G8B8A8_SNORM"/>
        <enum value="39"    name="VK_FORMAT_R8G8B8A8_USCALED"/>
        <enum value="40"    name="VK_FORMAT_R8G8B8A8_SSCALED"/>
        <enum value="41"    name="VK_FORMAT_R8G8B8A8_UINT"/>
        <enum value="42"    name="VK_FORMAT_R8G8B8A8_SINT"/>
        <enum value="43"    name="VK_FORMAT_R8G8B8A8_SRGB"/>
        <enum value="44"    name="VK_FORMAT_B8G8R8A8_UNORM"/>
        <enum value="45"    name="VK_FORMAT_B8G8R8A8_SNORM"/>
        <enum value="46"    name="VK_FORMAT_B8G8R8A8_USCALED"/>
        <enum value="47"    name="VK_FORMAT_B8G8R8A8_SSCALED"/>
        <enum value="48"    name="VK_FORMAT_B8G8R8A8_UINT"/>
        <enum value="49"    name="VK_FORMAT_B8G8R8A8_SINT"/>
        <enum value="50"    name="VK_FORMAT_B8G8R8A8_SRGB"/>
        <enum value="51"    name="VK_FORMAT_A8B8G8R8_UNORM_PACK32"/>
        <enum value="52"    name="VK_FORMAT_A8B8G8R8_SNORM_PACK32"/>
        <enum value="53"    name="VK_FORMAT_A8B8G8R8_USCALED_PACK32"/>
        <enum value="54"    name="VK_FORMAT_A8B8G8R8_SSCALED_PACK32"/>
        <enum value="55"    name="VK_FORMAT_A8B8G8R8_UINT_PACK32"/>
        <enum value="56"    name="VK_FORMAT_A8B8G8R8_SINT_PACK32"/>
        <enum value="57"    name="VK_FORMAT_A8B8G8R8_SRGB_PACK32"/>
        <enum value="58"    name="VK_FORMAT_A2R10G10B10_UNORM_PACK32"/>
        <enum value="59"    name="VK_FORMAT_A2R10G10B10_SNORM_PACK32"/>
        <enum value="60"    name="VK_FORMAT_A2R10G10B10_USCALED_PACK32"/>
        <enum value="61"    name="VK_FORMAT_A2R10G10B10_SSCALED_PACK32"/>
        <enum value="62"    name="VK_FORMAT_A2R10G10B10_UINT_PACK32"/>
        <enum value="63"    name="VK_FORMAT_A2R10G10B10_SINT_PACK32"/>
        <enum value="64"    name="VK_FORMAT_A2B10G10R10_UNORM_PACK32"/>
        <enum value="65"    name="VK_FORMAT_A2B10G10R10_SNORM_PACK32"/>
        <enum value="66"    name="VK_FORMAT_A2B10G10R10_USCALED_PACK32"/>
        <enum value="67"    name="VK_FORMAT_A2B10G10R10_SSCALED_PACK32"/>
        <enum value="68"    name="VK_FORMAT_A2B10G10R10_UINT_PACK32"/>
        <enum value="69"    name="VK_FORMAT_A2B10G10R10_SINT_PACK32"/>
        <enum value="70"    name="VK_FORMAT_R16_UNORM"/>
        <enum value="71"    name="VK_FORMAT_R16_SNORM"/>
        <enum value="72"    name="VK_FORMAT_R16_USCALED"/>
        <enum value="73"    name="VK_FORMAT_R16_SSCALED"/>
        <enum value="74"    name="VK_FORMAT_R16_UINT"/>
        <enum value="75"    name="VK_FORMAT_R16_SINT"/>
        <enum value="76"    name="VK_FORMAT_R16_SFLOAT"/>
        <enum value="77"    name="VK_FORMAT_R16G16_UNORM"/>
        <enum value="78"    name="VK_FORMAT_R16G16_SNORM"/>
        <enum value="79"    name="VK_FORMAT_R16G16_USCALED"/>
        <enum value="80"    name="VK_FORMAT_R16G16_SSCALED"/>
        <enum value="81"    name="VK_FORMAT_R16G16_UINT"/>
        <enum value="82"    name="VK_FORMAT_R16G16_SINT"/>
        <enum value="83"    name="VK_FORMAT_R16G16_SFLOAT"/>
        <enum value="84"    name="VK_FORMAT_R16G16B16_UNORM"/>
        <enum value="85"    name="VK_FORMAT_R16G16B16_SNORM"/>
        <enum value="86"    name="VK_FORMAT_R16G16B16_USCALED"/>
        <enum value="87"    name="VK_FORMAT_R16G16B16_SSCALED"/>
        <enum value="88"    name="VK_FORMAT_R16G16B16_UINT"/>
        <enum value="89"    name="VK_FORMAT_R16G16B16_SINT"/>
        <enum value="90"    name="VK_FORMAT_R16G16B16_SFLOAT"/>
        <enum value="91"    name="VK_FORMAT_R16G16B16A16_UNORM"/>
        <enum value="92"    name="VK_FORMAT_R16G16B16A16_SNORM"/>
        <enum value="93"    name="VK_FORMAT_R16G16B16A16_USCALED"/>
        <enum value="94"    name="VK_FORMAT_R16G16B16A16_SSCALED"/>
        <enum value="95"    name="VK_FORMAT_R16G16B16A16_UINT"/>
        <enum value="96"    name="VK_FORMAT_R16G16B16A16_SINT"/>
        <enum value="97"    name="VK_FORMAT_R16G16B16A16_SFLOAT"/>
        <enum value="98"    name="VK_FORMAT_R32_UINT"/>
        <enum value="99"    name="VK_FORMAT_R32_SINT"/>
        <enum value="100"   name="VK_FORMAT_R32_SFLOAT"/>
        <enum value="101"   name="VK_FORMAT_R32G32_UINT"/>
        <enum value="102"   name="VK_FORMAT_R32G32_SINT"/>
        <enum value="103"   name="VK_FORMAT_R32G32_SFLOAT"/>
        <enum value="104"   name="VK_FORMAT_R32G32B32_UINT"/>
        <enum value="105"   name="VK_FORMAT_R32G32B32_SINT"/>
        <enum value="106"   name="VK_FORMAT_R32G32B32_SFLOAT"/>
        <enum value="107"   name="VK_FORMAT_R32G32B32A32_UINT"/>
        <enum value="108"   name="VK_FORMAT_R32G32B32A32_SINT"/>
        <enum value="109"   name="VK_FORMAT_R32G32B32A32_SFLOAT"/>
        <enum value="110"   name="VK_FORMAT_R64_UINT"/>
        <enum value="111"   name="VK_FORMAT_R64_SINT"/>
        <enum value="112"   name="VK_FORMAT_R64_SFLOAT"/>
        <enum value="113"   name="VK_FORMAT_R64G64_UINT"/>
        <enum value="114"   name="VK_FORMAT_R64G64_SINT"/>
        <enum value="115"   name="VK_FORMAT_R64G64_SFLOAT"/>
        <enum value="116"   name="VK_FORMAT_R64G64B64_UINT"/>
        <enum value="117"   name="VK_FORMAT_R64G64B64_SINT"/>
        <enum value="118"   name="VK_FORMAT_R64G64B64_SFLOAT"/>
        <enum value="119"   name="VK_FORMAT_R64G64B64A64_UINT"/>
        <enum value="120"   name="VK_FORMAT_R64G64B64A64_SINT"/>
        <enum value="121"   name="VK_FORMAT_R64G64B64A64_SFLOAT"/>
        <enum value="122"   name="VK_FORMAT_B10G11R11_UFLOAT_PACK32"/>
        <enum value="123"   name="VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"/>
        <enum value="124"   name="VK_FORMAT_D16_UNORM"/>
        <enum value="125"   name="VK_FORMAT_X8_D24_UNORM_PACK32"/>
        <enum value="126"   name="VK_FORMAT_D32_SFLOAT"/>
        <enum value="127"   name="VK_FORMAT_S8_UINT"/>
        <enum value="128"   name="VK_FORMAT_D16_UNORM_S8_UINT"/>
        <enum value="129"   name="VK_FORMAT_D24_UNORM_S8_UINT"/>
        <enum value="130"   name="VK_FORMAT_D32_SFLOAT_S8_UINT"/>
        <enum value="131"   name="VK_FORMAT_BC1_RGB_UNORM_BLOCK"/>
        <enum value="132"   name="VK_FORMAT_BC1_RGB_SRGB_BLOCK"/>
        <enum value="133"   name="VK_FORMAT_BC1_RGBA_UNORM_BLOCK"/>
        <enum value="134"   name="VK_FORMAT_BC1_RGBA_SRGB_BLOCK"/>
        <enum value="135"   name="VK_FORMAT_BC2_UNORM_BLOCK"/>
        <enum value="136"   name="VK_FORMAT_BC2_SRGB_BLOCK"/>
        <enum value="137"   name="VK_FORMAT_BC3_UNORM_BLOCK"/>
        <enum value="138"   name="VK_FORMAT_BC3_SRGB_BLOCK"/>
        <enum value="139"   name="VK_FORMAT_BC4_UNORM_BLOCK"/>
        <enum value="140"   name="VK_FORMAT_BC4_SNORM_BLOCK"/>
        <enum value="141"   name="VK_FORMAT_BC5_UNORM_BLOCK"/>
        <enum value="142"   name="VK_FORMAT_BC5_SNORM_BLOCK"/>
        <enum value="143"   name="VK_FORMAT_BC6H_UFLOAT_BLOCK"/>
        <enum value="144"   name="VK_FORMAT_BC6H_SFLOAT_BLOCK"/>
        <enum value="145"   name="VK_FORMAT_BC7_UNORM_BLOCK"/>
        <enum value="146"   name="VK_FORMAT_BC7_SRGB_BLOCK"/>
        <enum value="147"   name="VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"/>
        <enum value="148"   name="VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"/>
        <enum value="149"   name="VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"/>
        <enum value="150"   name="VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"/>
        <enum value="151"   name="VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"/>
        <enum value="152"   name="VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"/>
        <enum value="153"   name="VK_FORMAT_EAC_R11_UNORM_BLOCK"/>
        <enum value="154"   name="VK_FORMAT_EAC_R11_SNORM_BLOCK"/>
        <enum value="155"   name="VK_FORMAT_EAC_R11G11_UNORM_BLOCK"/>
        <enum value="156"   name="VK_FORMAT_EAC_R11G11_SNORM_BLOCK"/>
        <enum value="157"   name="VK_FORMAT_ASTC_4x4_UNORM_BLOCK"/>
        <enum value="158"   name="VK_FORMAT_ASTC_4x4_SRGB_BLOCK"/>
        <enum value="159"   name="VK_FORMAT_ASTC_5x4_UNORM_BLOCK"/>
        <enum value="160"   name="VK_FORMAT_ASTC_5x4_SRGB_BLOCK"/>
        <enum value="161"   name="VK_FORMAT_ASTC_5x5_UNORM_BLOCK"/>
        <enum value="162"   name="VK_FORMAT_ASTC_5x5_SRGB_BLOCK"/>
        <enum value="163"   name="VK_FORMAT_ASTC_6x5_UNORM_BLOCK"/>
        <enum value="164"   name="VK_FORMAT_ASTC_6x5_SRGB_BLOCK"/>
        <enum value="165"   name="VK_FORMAT_ASTC_6x6_UNORM_BLOCK"/>
        <enum value="166"   name="VK_FORMAT_ASTC_6x6_SRGB_BLOCK"/>
        <enum value="167"   name="VK_FORMAT_ASTC_8x5_UNORM_BLOCK"/>
        <enum value="168"   name="VK_FORMAT_ASTC_8x5_SRGB_BLOCK"/>
        <enum value="169"   name="VK_FORMAT_ASTC_8x6_UNORM_BLOCK"/>
        <enum value="170"   name="VK_FORMAT_ASTC_8x6_SRGB_BLOCK"/>
        <enum value="171"   name="VK_FORMAT_ASTC_8x8_UNORM_BLOCK"/>
        <enum value="172"   name="VK_FORMAT_ASTC_8x8_SRGB_BLOCK"/>
        <enum value="173"   name="VK_FORMAT_ASTC_10x5_UNORM_BLOCK"/>
        <enum value="174"   name="VK_FORMAT_ASTC_10x5_SRGB_BLOCK"/>
        <enum value="175"   name="VK_FORMAT_ASTC_10x6_UNORM_BLOCK"/>
        <enum value="176"   name="VK_FORMAT_ASTC_10x6_SRGB_BLOCK"/>
        <enum value="177"   name="VK_FORMAT_ASTC_10x8_UNORM_BLOCK"/>
        <enum value="178"   name="VK_FORMAT_ASTC_10x8_SRGB_BLOCK"/>
        <enum value="179"   name="VK_FORMAT_ASTC_10x10_UNORM_BLOCK"/>
        <enum value="180"   name="VK_FORMAT_ASTC_10x10_SRGB_BLOCK"/>
        <enum value="181"   name="VK_FORMAT_ASTC_12x10_UNORM_BLOCK"/>
        <enum value="182"   name="VK_FORMAT_ASTC_12x10_SRGB_BLOCK"/>
        <enum value="183"   name="VK_FORMAT_ASTC_12x12_UNORM_BLOCK"/>
        <enum value="184"   name="VK_FORMAT_ASTC_12x12_SRGB_BLOCK"/>
    </enums>
    <enums name="VkStructureType" type="enum" comment="Structure type enumerant">
        <enum value="0"     name="VK_STRUCTURE_TYPE_APPLICATION_INFO"/>
        <enum value="1"     name="VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"/>
        <enum value="2"     name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"/>
        <enum value="3"     name="VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"/>
        <enum value="4"     name="VK_STRUCTURE_TYPE_SUBMIT_INFO"/>
        <enum value="5"     name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"/>
        <enum value="6"     name="VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"/>
        <enum value="7"     name="VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"/>
        <enum value="8"     name="VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"/>
        <enum value="9"     name="VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"/>
        <enum value="10"    name="VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"/>
        <enum value="11"    name="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"/>
        <enum value="12"    name="VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"/>
        <enum value="13"    name="VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"/>
        <enum value="14"    name="VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"/>
        <enum value="15"    name="VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"/>
        <enum value="16"    name="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"/>
        <enum value="17"    name="VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"/>
        <enum value="18"    name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"/>
        <enum value="19"    name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"/>
        <enum value="20"    name="VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"/>
        <enum value="21"    name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"/>
        <enum value="22"    name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"/>
        <enum value="23"    name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"/>
        <enum value="24"    name="VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"/>
        <enum value="25"    name="VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"/>
        <enum value="26"    name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"/>
        <enum value="27"    name="VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"/>
        <enum value="28"    name="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"/>
        <enum value="29"    name="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"/>
        <enum value="30"    name="VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"/>
        <enum value="31"    name="VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"/>
        <enum value="32"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"/>
        <enum value="33"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"/>
        <enum value="34"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"/>
        <enum value="35"    name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"/>
        <enum value="36"    name="VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"/>
        <enum value="37"    name="VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"/>
        <enum value="38"    name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"/>
        <enum value="39"    name="VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"/>
        <enum value="40"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"/>
        <enum value="41"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"/>
        <enum value="42"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"/>
        <enum value="43"    name="VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"/>
        <enum value="44"    name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"/>
        <enum value="45"    name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"/>
        <enum value="46"    name="VK_STRUCTURE_TYPE_MEMORY_BARRIER"/>
        <enum value="47"    name="VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"/> <!-- Reserved for internal use by the loader, layers, and ICDs -->
        <enum value="48"    name="VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"/> <!-- Reserved for internal use by the loader, layers, and ICDs -->
    </enums>
    <enums name="VkSubpassContents" type="enum">
        <enum value="0"     name="VK_SUBPASS_CONTENTS_INLINE"/>
        <enum value="1"     name="VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"/>
    </enums>
    <enums name="VkResult" type="enum" comment="Error and return codes">
        <!-- Return codes for successful operation execution (positive values) -->
        <enum value="0"     name="VK_SUCCESS" comment="Command completed successfully"/>
        <enum value="1"     name="VK_NOT_READY" comment="A fence or query has not yet completed"/>
        <enum value="2"     name="VK_TIMEOUT" comment="A wait operation has not completed in the specified time"/>
        <enum value="3"     name="VK_EVENT_SET" comment="An event is signaled"/>
        <enum value="4"     name="VK_EVENT_RESET" comment="An event is unsignaled"/>
        <enum value="5"     name="VK_INCOMPLETE" comment="A return array was too small for the result"/>
        <!-- Error codes (negative values) -->
        <enum value="-1"    name="VK_ERROR_OUT_OF_HOST_MEMORY" comment="A host memory allocation has failed"/>
        <enum value="-2"    name="VK_ERROR_OUT_OF_DEVICE_MEMORY" comment="A device memory allocation has failed"/>
        <enum value="-3"    name="VK_ERROR_INITIALIZATION_FAILED" comment="Initialization of a object has failed"/>
        <enum value="-4"    name="VK_ERROR_DEVICE_LOST" comment="The logical device has been lost. See &lt;&lt;devsandqueues-lost-device&gt;&gt;"/>
        <enum value="-5"    name="VK_ERROR_MEMORY_MAP_FAILED" comment="Mapping of a memory object has failed"/>
        <enum value="-6"    name="VK_ERROR_LAYER_NOT_PRESENT" comment="Layer specified does not exist"/>
        <enum value="-7"    name="VK_ERROR_EXTENSION_NOT_PRESENT" comment="Extension specified does not exist"/>
        <enum value="-8"    name="VK_ERROR_FEATURE_NOT_PRESENT" comment="Requested feature is not available on this device"/>
        <enum value="-9"    name="VK_ERROR_INCOMPATIBLE_DRIVER" comment="Unable to find a Vulkan driver"/>
        <enum value="-10"   name="VK_ERROR_TOO_MANY_OBJECTS" comment="Too many objects of the type have already been created"/>
        <enum value="-11"   name="VK_ERROR_FORMAT_NOT_SUPPORTED" comment="Requested format is not supported on this device"/>
            <unused start="-12"/>
    </enums>
    <enums name="VkDynamicState" type="enum">
        <enum value="0"    name="VK_DYNAMIC_STATE_VIEWPORT"/>
        <enum value="1"    name="VK_DYNAMIC_STATE_SCISSOR"/>
        <enum value="2"    name="VK_DYNAMIC_STATE_LINE_WIDTH"/>
        <enum value="3"    name="VK_DYNAMIC_STATE_DEPTH_BIAS"/>
        <enum value="4"    name="VK_DYNAMIC_STATE_BLEND_CONSTANTS"/>
        <enum value="5"    name="VK_DYNAMIC_STATE_DEPTH_BOUNDS"/>
        <enum value="6"    name="VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"/>
        <enum value="7"    name="VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"/>
        <enum value="8"    name="VK_DYNAMIC_STATE_STENCIL_REFERENCE"/>
    </enums>

    <!-- Flags -->
    <enums name="VkQueueFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUEUE_GRAPHICS_BIT"                             comment="Queue supports graphics operations"/>
        <enum bitpos="1"    name="VK_QUEUE_COMPUTE_BIT"                              comment="Queue supports compute operations"/>
        <enum bitpos="2"    name="VK_QUEUE_TRANSFER_BIT"                             comment="Queue supports transfer operations"/>
        <enum bitpos="3"    name="VK_QUEUE_SPARSE_BINDING_BIT"                       comment="Queue supports sparse resource memory management operations"/>
    </enums>
    <enums name="VkMemoryPropertyFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"               comment="If otherwise stated, then allocate memory on device"/>
        <enum bitpos="1"    name="VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"               comment="Memory is mappable by host"/>
        <enum bitpos="2"    name="VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"              comment="Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache"/>
        <enum bitpos="3"    name="VK_MEMORY_PROPERTY_HOST_CACHED_BIT"                comment="Memory will be cached by the host"/>
        <enum bitpos="4"    name="VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"           comment="Memory may be allocated by the driver when it is required"/>
    </enums>
    <enums name="VkMemoryHeapFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"                   comment="If set, heap represents device memory"/>
    </enums>
    <enums name="VkAccessFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_ACCESS_INDIRECT_COMMAND_READ_BIT"               comment="Controls coherency of indirect command reads"/>
        <enum bitpos="1"    name="VK_ACCESS_INDEX_READ_BIT"                          comment="Controls coherency of index reads"/>
        <enum bitpos="2"    name="VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"               comment="Controls coherency of vertex attribute reads"/>
        <enum bitpos="3"    name="VK_ACCESS_UNIFORM_READ_BIT"                        comment="Controls coherency of uniform buffer reads"/>
        <enum bitpos="4"    name="VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"               comment="Controls coherency of input attachment reads"/>
        <enum bitpos="5"    name="VK_ACCESS_SHADER_READ_BIT"                         comment="Controls coherency of shader reads"/>
        <enum bitpos="6"    name="VK_ACCESS_SHADER_WRITE_BIT"                        comment="Controls coherency of shader writes"/>
        <enum bitpos="7"    name="VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"               comment="Controls coherency of color attachment reads"/>
        <enum bitpos="8"    name="VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"              comment="Controls coherency of color attachment writes"/>
        <enum bitpos="9"    name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"       comment="Controls coherency of depth/stencil attachment reads"/>
        <enum bitpos="10"   name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"      comment="Controls coherency of depth/stencil attachment writes"/>
        <enum bitpos="11"   name="VK_ACCESS_TRANSFER_READ_BIT"                       comment="Controls coherency of transfer reads"/>
        <enum bitpos="12"   name="VK_ACCESS_TRANSFER_WRITE_BIT"                      comment="Controls coherency of transfer writes"/>
        <enum bitpos="13"   name="VK_ACCESS_HOST_READ_BIT"                           comment="Controls coherency of host reads"/>
        <enum bitpos="14"   name="VK_ACCESS_HOST_WRITE_BIT"                          comment="Controls coherency of host writes"/>
        <enum bitpos="15"   name="VK_ACCESS_MEMORY_READ_BIT"                         comment="Controls coherency of memory reads"/>
        <enum bitpos="16"   name="VK_ACCESS_MEMORY_WRITE_BIT"                        comment="Controls coherency of memory writes"/>
    </enums>
    <enums name="VkBufferUsageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_BUFFER_USAGE_TRANSFER_SRC_BIT"                  comment="Can be used as a source of transfer operations"/>
        <enum bitpos="1"    name="VK_BUFFER_USAGE_TRANSFER_DST_BIT"                  comment="Can be used as a destination of transfer operations"/>
        <enum bitpos="2"    name="VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"          comment="Can be used as TBO"/>
        <enum bitpos="3"    name="VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"          comment="Can be used as IBO"/>
        <enum bitpos="4"    name="VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"                comment="Can be used as UBO"/>
        <enum bitpos="5"    name="VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"                comment="Can be used as SSBO"/>
        <enum bitpos="6"    name="VK_BUFFER_USAGE_INDEX_BUFFER_BIT"                  comment="Can be used as source of fixed-function index fetch (index buffer)"/>
        <enum bitpos="7"    name="VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"                 comment="Can be used as source of fixed-function vertex fetch (VBO)"/>
        <enum bitpos="8"    name="VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"               comment="Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)"/>
    </enums>
    <enums name="VkBufferCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_BUFFER_CREATE_SPARSE_BINDING_BIT"               comment="Buffer should support sparse backing"/>
        <enum bitpos="1"    name="VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"             comment="Buffer should support sparse backing with partial residency"/>
        <enum bitpos="2"    name="VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"               comment="Buffer should support constent data access to physical memory ranges mapped into multiple locations of sparse buffers"/>
    </enums>
    <enums name="VkShaderStageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SHADER_STAGE_VERTEX_BIT"/>
        <enum bitpos="1"    name="VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"/>
        <enum bitpos="2"    name="VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"/>
        <enum bitpos="3"    name="VK_SHADER_STAGE_GEOMETRY_BIT"/>
        <enum bitpos="4"    name="VK_SHADER_STAGE_FRAGMENT_BIT"/>
        <enum bitpos="5"    name="VK_SHADER_STAGE_COMPUTE_BIT"/>
        <enum value="0x0000001F" name="VK_SHADER_STAGE_ALL_GRAPHICS"/>
        <enum value="0x7FFFFFFF" name="VK_SHADER_STAGE_ALL"/>
    </enums>
    <enums name="VkImageUsageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_USAGE_TRANSFER_SRC_BIT"                   comment="Can be used as a source of transfer operations"/>
        <enum bitpos="1"    name="VK_IMAGE_USAGE_TRANSFER_DST_BIT"                   comment="Can be used as a destination of transfer operations"/>
        <enum bitpos="2"    name="VK_IMAGE_USAGE_SAMPLED_BIT"                        comment="Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
        <enum bitpos="3"    name="VK_IMAGE_USAGE_STORAGE_BIT"                        comment="Can be used as storage image (STORAGE_IMAGE descriptor type)"/>
        <enum bitpos="4"    name="VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"               comment="Can be used as framebuffer color attachment"/>
        <enum bitpos="5"    name="VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"       comment="Can be used as framebuffer depth/stencil attachment"/>
        <enum bitpos="6"    name="VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"           comment="Image data not needed outside of rendering"/>
        <enum bitpos="7"    name="VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"               comment="Can be used as framebuffer input attachment"/>
    </enums>
    <enums name="VkImageCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_CREATE_SPARSE_BINDING_BIT"                comment="Image should support sparse backing"/>
        <enum bitpos="1"    name="VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"              comment="Image should support sparse backing with partial residency"/>
        <enum bitpos="2"    name="VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"                comment="Image should support constent data access to physical memory ranges mapped into multiple locations of sparse images"/>
        <enum bitpos="3"    name="VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"                comment="Allows image views to have different format than the base image"/>
        <enum bitpos="4"    name="VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"               comment="Allows creating image views with cube type from the created image"/>
    </enums>
    <enums name="VkPipelineCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"/>
        <enum bitpos="1"    name="VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"/>
        <enum bitpos="2"    name="VK_PIPELINE_CREATE_DERIVATIVE_BIT"/>
    </enums>
    <enums name="VkColorComponentFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COLOR_COMPONENT_R_BIT"/>
        <enum bitpos="1"    name="VK_COLOR_COMPONENT_G_BIT"/>
        <enum bitpos="2"    name="VK_COLOR_COMPONENT_B_BIT"/>
        <enum bitpos="3"    name="VK_COLOR_COMPONENT_A_BIT"/>
    </enums>
    <enums name="VkFenceCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_FENCE_CREATE_SIGNALED_BIT"/>
    </enums>
    <enums name="VkFormatFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"               comment="Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
        <enum bitpos="1"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"               comment="Format can be used for storage images (STORAGE_IMAGE descriptor type)"/>
        <enum bitpos="2"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"        comment="Format supports atomic operations in case it's used for storage images"/>
        <enum bitpos="3"    name="VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"        comment="Format can be used for uniform texel buffers (TBOs)"/>
        <enum bitpos="4"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"        comment="Format can be used for storage texel buffers (IBOs)"/>
        <enum bitpos="5"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT" comment="Format supports atomic operations in case it's used for storage texel buffers"/>
        <enum bitpos="6"    name="VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"               comment="Format can be used for vertex buffers (VBOs)"/>
        <enum bitpos="7"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"            comment="Format can be used for color attachment images"/>
        <enum bitpos="8"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"      comment="Format supports blending in case it's used for color attachment images"/>
        <enum bitpos="9"    name="VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"    comment="Format can be used for depth/stencil attachment images"/>
        <enum bitpos="10"   name="VK_FORMAT_FEATURE_BLIT_SRC_BIT"                    comment="Format can be used as the source image of blits with vkCmdBlitImage"/>
        <enum bitpos="11"   name="VK_FORMAT_FEATURE_BLIT_DST_BIT"                    comment="Format can be used as the destination image of blits with vkCmdBlitImage"/>
        <enum bitpos="12"   name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT" comment="Format can be filtered with VK_FILTER_LINEAR when being sampled"/>
    </enums>
    <enums name="VkQueryControlFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_CONTROL_PRECISE_BIT"                      comment="Require precise results to be collected by the query"/>
    </enums>
    <enums name="VkQueryResultFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_RESULT_64_BIT"                            comment="Results of the queries are written to the destination buffer as 64-bit values"/>
        <enum bitpos="1"    name="VK_QUERY_RESULT_WAIT_BIT"                          comment="Results of the queries are waited on before proceeding with the result copy"/>
        <enum bitpos="2"    name="VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"             comment="Besides the results of the query, the availability of the results is also written"/>
        <enum bitpos="3"    name="VK_QUERY_RESULT_PARTIAL_BIT"                       comment="Copy the partial results of the query even if the final results aren't available"/>
    </enums>
    <enums name="VkCommandBufferUsageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"/>
        <enum bitpos="1"    name="VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"/>
        <enum bitpos="2"    name="VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"      comment="Command buffer may be submitted/executed more than once simultaneously"/>
    </enums>
    <enums name="VkQueryPipelineStatisticFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"                    comment="Optional"/>
        <enum bitpos="1"    name="VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"                  comment="Optional"/>
        <enum bitpos="2"    name="VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"                  comment="Optional"/>
        <enum bitpos="3"    name="VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"                comment="Optional"/>
        <enum bitpos="4"    name="VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"                 comment="Optional"/>
        <enum bitpos="5"    name="VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"                       comment="Optional"/>
        <enum bitpos="6"    name="VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"                        comment="Optional"/>
        <enum bitpos="7"    name="VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"                comment="Optional"/>
        <enum bitpos="8"    name="VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"        comment="Optional"/>
        <enum bitpos="9"    name="VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT" comment="Optional"/>
        <enum bitpos="10"   name="VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"                 comment="Optional"/>
    </enums>
    <enums name="VkImageAspectFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_ASPECT_COLOR_BIT"/>
        <enum bitpos="1"    name="VK_IMAGE_ASPECT_DEPTH_BIT"/>
        <enum bitpos="2"    name="VK_IMAGE_ASPECT_STENCIL_BIT"/>
        <enum bitpos="3"    name="VK_IMAGE_ASPECT_METADATA_BIT"/>
    </enums>
    <enums name="VkSparseImageFormatFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"            comment="Image uses a single miptail region for all array layers"/>
        <enum bitpos="1"    name="VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"          comment="Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-miptail levels."/>
        <enum bitpos="2"    name="VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT" comment="Image uses a non-standard sparse image block dimensions"/>
    </enums>
    <enums name="VkSparseMemoryBindFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SPARSE_MEMORY_BIND_METADATA_BIT"                comment="Operation binds resource metadata to memory"/>
    </enums>
    <enums name="VkPipelineStageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"                 comment="Before subsequent commands are processed"/>
        <enum bitpos="1"    name="VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"               comment="Draw/DispatchIndirect command fetch"/>
        <enum bitpos="2"    name="VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"                comment="Vertex/index fetch"/>
        <enum bitpos="3"    name="VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"               comment="Vertex shading"/>
        <enum bitpos="4"    name="VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT"         comment="Tessellation control shading"/>
        <enum bitpos="5"    name="VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"      comment="Tessellation evaluation shading"/>
        <enum bitpos="6"    name="VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"             comment="Geometry shading"/>
        <enum bitpos="7"    name="VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"             comment="Fragment shading"/>
        <enum bitpos="8"    name="VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"        comment="Early fragment (depth and stencil) tests"/>
        <enum bitpos="9"    name="VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"         comment="Late fragment (depth and stencil) tests"/>
        <enum bitpos="10"   name="VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"     comment="Color attachment writes"/>
        <enum bitpos="11"   name="VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"              comment="Compute shading"/>
        <enum bitpos="12"   name="VK_PIPELINE_STAGE_TRANSFER_BIT"                    comment="Transfer/copy operations"/>
        <enum bitpos="13"   name="VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"              comment="After previous commands have completed"/>
        <enum bitpos="14"   name="VK_PIPELINE_STAGE_HOST_BIT"                        comment="Indicates host (CPU) is a source/sink of the dependency"/>
        <enum bitpos="15"   name="VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"                comment="All stages of the graphics pipeline"/>
        <enum bitpos="16"   name="VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"                comment="All stages supported on the queue"/>
    </enums>
    <enums name="VkCommandPoolCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"              comment="Command buffers have a short lifetime"/>
        <enum bitpos="1"    name="VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"   comment="Command buffers may release their memory individually"/>
    </enums>
    <enums name="VkCommandPoolResetFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"       comment="Release resources owned by the pool"/>
    </enums>
    <enums name="VkCommandBufferResetFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"     comment="Release resources owned by the buffer"/>
    </enums>
    <enums name="VkSampleCountFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SAMPLE_COUNT_1_BIT"                             comment="Sample count 1 supported"/>
        <enum bitpos="1"    name="VK_SAMPLE_COUNT_2_BIT"                             comment="Sample count 2 supported"/>
        <enum bitpos="2"    name="VK_SAMPLE_COUNT_4_BIT"                             comment="Sample count 4 supported"/>
        <enum bitpos="3"    name="VK_SAMPLE_COUNT_8_BIT"                             comment="Sample count 8 supported"/>
        <enum bitpos="4"    name="VK_SAMPLE_COUNT_16_BIT"                            comment="Sample count 16 supported"/>
        <enum bitpos="5"    name="VK_SAMPLE_COUNT_32_BIT"                            comment="Sample count 32 supported"/>
        <enum bitpos="6"    name="VK_SAMPLE_COUNT_64_BIT"                            comment="Sample count 64 supported"/>
    </enums>
    <enums name="VkAttachmentDescriptionFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"           comment="The attachment may alias physical memory of another attachment in the same render pass"/>
    </enums>
    <enums name="VkStencilFaceFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_STENCIL_FACE_FRONT_BIT"                         comment="Front face"/>
        <enum bitpos="1"    name="VK_STENCIL_FACE_BACK_BIT"                          comment="Back face"/>
        <enum value="0x00000003" name="VK_STENCIL_FRONT_AND_BACK"                    comment="Front and back faces"/>
    </enums>
    <enums name="VkDescriptorPoolCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT" comment="Descriptor sets may be freed individually"/>
    </enums>
    <enums name="VkDependencyFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_DEPENDENCY_BY_REGION_BIT"                       comment="Dependency is per pixel region "/>
    </enums>
        <!-- WSI extensions -->
    <enums name="VkPresentModeKHR" type="enum">
        <enum value="0"     name="VK_PRESENT_MODE_IMMEDIATE_KHR"/>
        <enum value="1"     name="VK_PRESENT_MODE_MAILBOX_KHR"/>
        <enum value="2"     name="VK_PRESENT_MODE_FIFO_KHR"/>
        <enum value="3"     name="VK_PRESENT_MODE_FIFO_RELAXED_KHR"/>
    </enums>
    <enums name="VkColorSpaceKHR" type="enum">
        <enum value="0"     name="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"/>
    </enums>
    <enums name="VkDisplayPlaneAlphaFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"/>
        <enum bitpos="1"    name="VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"/>
        <enum bitpos="2"    name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"/>
        <enum bitpos="3"    name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"/>
    </enums>
    <enums name="VkCompositeAlphaFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"/>
        <enum bitpos="1"    name="VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"/>
        <enum bitpos="2"    name="VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"/>
        <enum bitpos="3"    name="VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"/>
    </enums>
    <enums name="VkSurfaceTransformFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"/>
        <enum bitpos="1"    name="VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"/>
        <enum bitpos="2"    name="VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"/>
        <enum bitpos="3"    name="VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"/>
        <enum bitpos="4"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"/>
        <enum bitpos="5"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"/>
        <enum bitpos="6"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"/>
        <enum bitpos="7"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"/>
        <enum bitpos="8"    name="VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"/>
    </enums>
    <enums name="VkDebugReportFlagBitsEXT" type="bitmask">
        <enum bitpos="0"     name="VK_DEBUG_REPORT_INFORMATION_BIT_EXT"/>
        <enum bitpos="1"     name="VK_DEBUG_REPORT_WARNING_BIT_EXT"/>
        <enum bitpos="2"     name="VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"/>
        <enum bitpos="3"     name="VK_DEBUG_REPORT_ERROR_BIT_EXT"/>
        <enum bitpos="4"     name="VK_DEBUG_REPORT_DEBUG_BIT_EXT"/>
    </enums>
    <enums name="VkDebugReportObjectTypeEXT" type="enum">
        <enum value="0" name="VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"/>
        <enum value="1" name="VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"/>
        <enum value="2" name="VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"/>
        <enum value="3" name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"/>
        <enum value="4" name="VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"/>
        <enum value="5" name="VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"/>
        <enum value="6" name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"/>
        <enum value="7" name="VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"/>
        <enum value="8" name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"/>
        <enum value="9" name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"/>
        <enum value="10" name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"/>
        <enum value="11" name="VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"/>
        <enum value="12" name="VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"/>
        <enum value="13" name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"/>
        <enum value="14" name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"/>
        <enum value="15" name="VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"/>
        <enum value="16" name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"/>
        <enum value="17" name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"/>
        <enum value="18" name="VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"/>
        <enum value="19" name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"/>
        <enum value="20" name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"/>
        <enum value="21" name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"/>
        <enum value="22" name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"/>
        <enum value="23" name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"/>
        <enum value="24" name="VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"/>
        <enum value="25" name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"/>
        <enum value="26" name="VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"/>
        <enum value="27" name="VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"/>
        <enum value="28" name="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT"/>
    </enums>
    <enums name="VkDebugReportErrorEXT" type="enum">
        <enum value="0" name="VK_DEBUG_REPORT_ERROR_NONE_EXT"/>         <!-- Used for INFO & other non-error messages -->
        <enum value="1" name="VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT"/> <!-- Callbacks were not destroyed prior to calling DestroyInstance -->
    </enums>
    <enums name="VkRasterizationOrderAMD" type="enum">
        <enum value="0" name="VK_RASTERIZATION_ORDER_STRICT_AMD"/>      <!-- Rasterization order strictly follows API order -->
        <enum value="1" name="VK_RASTERIZATION_ORDER_RELAXED_AMD"/>     <!-- Rasterization order may not follow API order -->
    </enums>

    <!-- SECTION: Vulkan command definitions -->
    <commands>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INCOMPATIBLE_DRIVER">
            <proto><type>VkResult</type> <name>vkCreateInstance</name></proto>
            <param>const <type>VkInstanceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkInstance</type>* <name>pInstance</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyInstance</name></proto>
            <param optional="true" externsync="true"><type>VkInstance</type> <name>instance</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All child objects created using pname:instance must: have been destroyed prior to destroying pname:instance</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:instance was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:instance was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDevices</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPhysicalDeviceCount</name></param>
            <param optional="true" len="pPhysicalDeviceCount"><type>VkPhysicalDevice</type>* <name>pPhysicalDevices</name></param>
        </command>
        <command>
            <proto><type>PFN_vkVoidFunction</type> <name>vkGetDeviceProcAddr</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pName</name></param>
            <validity>
                <usage>pname:pName must: be the name of a supported command that has a first parameter of type sname:VkDevice, sname:VkQueue or sname:VkCommandBuffer, either in the core API or an enabled extension</usage>
            </validity>
        </command>
        <command>
            <proto><type>PFN_vkVoidFunction</type> <name>vkGetInstanceProcAddr</name></proto>
            <param optional="true"><type>VkInstance</type> <name>instance</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pName</name></param>
            <validity>
                <usage>If pname:instance is `NULL`, pname:pName must: be one of: fname:vkEnumerateInstanceExtensionProperties, fname:vkEnumerateInstanceLayerProperties or fname:vkCreateInstance</usage>
                <usage>If pname:instance is not `NULL`, pname:pName must: be the name of a core command or a command from an enabled extension, other than: fname:vkEnumerateInstanceExtensionProperties, fname:vkEnumerateInstanceLayerProperties or fname:vkCreateInstance</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceProperties</type>* <name>pProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pQueueFamilyPropertyCount</name></param>
            <param optional="true" len="pQueueFamilyPropertyCount"><type>VkQueueFamilyProperties</type>* <name>pQueueFamilyProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceMemoryProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceMemoryProperties</type>* <name>pMemoryProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceFeatures</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceFeatures</type>* <name>pFeatures</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkFormatProperties</type>* <name>pFormatProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceImageFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageType</type> <name>type</name></param>
            <param><type>VkImageTiling</type> <name>tiling</name></param>
            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
            <param optional="true"><type>VkImageCreateFlags</type> <name>flags</name></param>
            <param><type>VkImageFormatProperties</type>* <name>pImageFormatProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkCreateDevice</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkDeviceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDevice</type>* <name>pDevice</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDevice</name></proto>
            <param optional="true" externsync="true"><type>VkDevice</type> <name>device</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All child objects created on pname:device must: have been destroyed prior to destroying pname:device</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:device was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:device was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkEnumerateInstanceLayerProperties</name></proto>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkEnumerateInstanceExtensionProperties</name></proto>
            <param optional="true" len="null-terminated">const <type>char</type>* <name>pLayerName</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkExtensionProperties</type>* <name>pProperties</name></param>
            <validity>
                <usage>If pname:pLayerName is not `NULL`, it must: be the name of a layer returned by flink:vkEnumerateInstanceLayerProperties</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkEnumerateDeviceLayerProperties</name></proto>
            <param optional="false,true"><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkEnumerateDeviceExtensionProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="true" len="null-terminated">const <type>char</type>* <name>pLayerName</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkExtensionProperties</type>* <name>pProperties</name></param>
            <validity>
                <usage>If pname:pLayerName is not `NULL`, it must: be the name of a layer returned by flink:vkEnumerateDeviceLayerProperties</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDeviceQueue</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>uint32_t</type> <name>queueIndex</name></param>
            <param><type>VkQueue</type>* <name>pQueue</name></param>
            <validity>
                <usage>pname:queueFamilyIndex must: be one of the queue family indices specified when pname:device was created, via the sname:VkDeviceQueueCreateInfo structure</usage>
                <usage>pname:queueIndex must: be less than the number of queues created for the specified queue family index when pname:device was created, via the pname:queueCount member of the sname:VkDeviceQueueCreateInfo structure</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkQueueSubmit</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param optional="true"><type>uint32_t</type> <name>submitCount</name></param>
            <param len="submitCount" externsync="pSubmits[].pWaitSemaphores[],pSubmits[].pSignalSemaphores[]">const <type>VkSubmitInfo</type>* <name>pSubmits</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
            <validity>
                <usage>If pname:fence is not sname:VK_NULL_HANDLE, pname:fence must: be unsignaled</usage>
                <usage>If pname:fence is not sname:VK_NULL_HANDLE, pname:fence mustnot: be associated with any other queue command that has not yet completed execution on that queue</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkQueueWaitIdle</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkDeviceWaitIdle</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <implicitexternsyncparams>
                <param>all sname:VkQueue objects created from pname:device</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_TOO_MANY_OBJECTS">
            <proto><type>VkResult</type> <name>vkAllocateMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryAllocateInfo</type>* <name>pAllocateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDeviceMemory</type>* <name>pMemory</name></param>
            <validity>
                <usage>The number of currently valid memory objects, allocated from pname:device, must: be less than sname:VkPhysicalDeviceLimits::pname:maxMemoryAllocationCount</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkFreeMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All submitted commands that refer to pname:memory (via images or buffers) must: have completed execution</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED">
            <proto><type>VkResult</type> <name>vkMapMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkDeviceSize</type> <name>size</name></param>
            <param optional="true"><type>VkMemoryMapFlags</type> <name>flags</name></param>
            <param><type>void</type>** <name>ppData</name></param>
            <validity>
                <usage>pname:memory mustnot: currently be mapped</usage>
                <usage>pname:offset must: be less than the size of pname:memory</usage>
                <usage>If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be greater than `0`</usage>
                <usage>If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be less than or equal to the size of the pname:memory minus pname:offset</usage>
                <usage>pname:memory must: have been created with a memory type that reports ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkUnmapMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
            <validity>
                <usage>pname:memory must: currently be mapped</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkFlushMappedMemoryRanges</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>memoryRangeCount</name></param>
            <param len="memoryRangeCount">const <type>VkMappedMemoryRange</type>* <name>pMemoryRanges</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkInvalidateMappedMemoryRanges</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>memoryRangeCount</name></param>
            <param len="memoryRangeCount">const <type>VkMappedMemoryRange</type>* <name>pMemoryRanges</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDeviceMemoryCommitment</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type>* <name>pCommittedMemoryInBytes</name></param>
            <validity>
                <usage>pname:memory must: have been created with a memory type that reports ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetBufferMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkBindBufferMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type> <name>memoryOffset</name></param>
            <validity>
                <usage>pname:buffer mustnot: already be backed by a memory object</usage>
                <usage>pname:buffer mustnot: have been created with any sparse memory binding flags</usage>
                <usage>pname:memoryOffset must: be less than the size of pname:memory</usage>
                <usage>If pname:buffer was created with the ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, pname:memoryOffset must: be a multiple of sname:VkPhysicalDeviceLimits::pname:minTexelBufferOffsetAlignment</usage>
                <usage>If pname:buffer was created with the ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, pname:memoryOffset must: be a multiple of sname:VkPhysicalDeviceLimits::pname:minUniformBufferOffsetAlignment</usage>
                <usage>If pname:buffer was created with the ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT, pname:memoryOffset must: be a multiple of sname:VkPhysicalDeviceLimits::pname:minStorageBufferOffsetAlignment</usage>
                <usage>pname:memory must: have been allocated using one of the memory types allowed in the pname:memoryTypeBits member of the sname:VkMemoryRequirements structure returned from a call to fname:vkGetBufferMemoryRequirements with pname:buffer</usage>
                <usage>The size of pname:buffer must: be less than or equal to the size of pname:memory minus pname:memoryOffset</usage>
                <usage>pname:memoryOffset must: be an integer multiple of the pname:alignment member of the sname:VkMemoryRequirements structure returned from a call to fname:vkGetBufferMemoryRequirements with pname:buffer</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetImageMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkBindImageMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkImage</type> <name>image</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type> <name>memoryOffset</name></param>
            <validity>
                <usage>pname:image mustnot: already be backed by a memory object</usage>
                <usage>pname:image mustnot: have been created with any sparse memory binding flags</usage>
                <usage>pname:memoryOffset must: be less than the size of pname:memory</usage>
                <usage>pname:memory must: have been allocated using one of the memory types allowed in the pname:memoryTypeBits member of the sname:VkMemoryRequirements structure returned from a call to fname:vkGetImageMemoryRequirements with pname:image</usage>
                <usage>pname:memoryOffset must: be an integer multiple of the pname:alignment member of the sname:VkMemoryRequirements structure returned from a call to fname:vkGetImageMemoryRequirements with pname:image</usage>
                <usage>The pname:size member of the sname:VkMemoryRequirements structure returned from a call to fname:vkGetImageMemoryRequirements with pname:image must: be less than or equal to the size of pname:memory minus pname:memoryOffset</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetImageSparseMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSparseMemoryRequirementCount</name></param>
            <param optional="true" len="pSparseMemoryRequirementCount"><type>VkSparseImageMemoryRequirements</type>* <name>pSparseMemoryRequirements</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceSparseImageFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageType</type> <name>type</name></param>
            <param><type>VkSampleCountFlagBits</type> <name>samples</name></param>
            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
            <param><type>VkImageTiling</type> <name>tiling</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkSparseImageFormatProperties</type>* <name>pProperties</name></param>
            <validity>
                <usage>If pname:format is an integer format, samples must: be one of the bit flags specified in sname:VkPhysicalDeviceLimits::pname:sampledImageIntegerSampleCounts</usage>
                <usage>If pname:format is a non-integer color format, samples must: be one of the bit flags specified in sname:VkPhysicalDeviceLimits::pname:sampledImageColorSampleCounts</usage>
                <usage>If pname:format is a depth format, samples must: be one of the bit flags specified in sname:VkPhysicalDeviceLimits::pname:sampledImageDepthSampleCounts</usage>
                <usage>If pname:format is a stencil format, samples must: be one of the bit flags specified in sname:VkPhysicalDeviceLimits::pname:sampledImageStencilSampleCounts</usage>
                <usage>If pname:usage includes ename:VK_IMAGE_USAGE_STORAGE_BIT, samples must: be one of the bit flags specified in sname:VkPhysicalDeviceLimits::pname:storageImageSampleCounts</usage>
            </validity>
        </command>
        <command queues="sparse_binding" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkQueueBindSparse</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param optional="true"><type>uint32_t</type> <name>bindInfoCount</name></param>
            <param len="bindInfoCount" externsync="pBindInfo[].pWaitSemaphores[],pBindInfo[].pSignalSemaphores[],pBindInfo[].pBufferBinds[].buffer,pBindInfo[].pImageOpaqueBinds[].image,pBindInfo[].pImageBinds[].image">const <type>VkBindSparseInfo</type>* <name>pBindInfo</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
            <validity>
                <usage>pname:fence must: be unsignaled</usage>
                <usage>pname:fence mustnot: be associated with any other queue command that has not yet completed execution on that queue</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateFence</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFenceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkFence</type>* <name>pFence</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyFence</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>pname:fence mustnot: be associated with any queue command that has not yet completed execution on that queue</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:fence was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:fence was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetFences</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>fenceCount</name></param>
            <param len="fenceCount" externsync="true">const <type>VkFence</type>* <name>pFences</name></param>
            <validity>
                <usage>Any given element of pname:pFences mustnot: currently be associated with any queue command that has not yet completed execution on that queue</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkGetFenceStatus</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkFence</type> <name>fence</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_TIMEOUT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkWaitForFences</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>fenceCount</name></param>
            <param len="fenceCount">const <type>VkFence</type>* <name>pFences</name></param>
            <param><type>VkBool32</type> <name>waitAll</name></param>
            <param><type>uint64_t</type> <name>timeout</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateSemaphore</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSemaphore</type>* <name>pSemaphore</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySemaphore</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>pname:semaphore mustnot: be associated with any queue command that has not yet completed execution on that queue</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:semaphore was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:semaphore was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkEventCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkEvent</type>* <name>pEvent</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkEvent</type> <name>event</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All submitted commands that refer to pname:event must: have completed execution</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:event was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:event was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_EVENT_SET,VK_EVENT_RESET" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkGetEventStatus</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkSetEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkEvent</type> <name>event</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkEvent</type> <name>event</name></param>
            <validity>
                <usage>pname:event mustnot: be waited on by a fname:vkCmdWaitEvents command that is currently executing</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateQueryPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkQueryPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkQueryPool</type>* <name>pQueryPool</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyQueryPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkQueryPool</type> <name>queryPool</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All submitted commands that refer to pname:queryPool must: have completed execution</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:queryPool was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:queryPool was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
            <proto><type>VkResult</type> <name>vkGetQueryPoolResults</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
            <param><type>size_t</type> <name>dataSize</name></param>
            <param len="dataSize"><type>void</type>* <name>pData</name></param>
            <param><type>VkDeviceSize</type> <name>stride</name></param>
            <param optional="true"><type>VkQueryResultFlags</type> <name>flags</name></param>
            <validity>
                <usage>pname:firstQuery must: be less than the number of queries in pname:queryPool</usage>
                <usage>If ename:VK_QUERY_RESULT_64_BIT is not set in pname:flags then pname:pData and pname:stride must: be multiples of `4`</usage>
                <usage>If ename:VK_QUERY_RESULT_64_BIT is set in pname:flags then pname:pData and pname:stride must: be multiples of `8`</usage>
                <usage>The sum of pname:firstQuery and pname:queryCount must: be less than or equal to the number of queries in pname:queryPool</usage>
                <usage>pname:dataSize must: be large enough to contain the result of each query, as described &lt;&lt;queries-operation-memorylayout,here&gt;&gt;</usage>
                <usage>If the pname:queryType used to create pname:queryPool was ename:VK_QUERY_TYPE_TIMESTAMP, pname:flags mustnot: contain ename:VK_QUERY_RESULT_PARTIAL_BIT</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateBuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkBuffer</type>* <name>pBuffer</name></param>
            <validity>
                <usage>If the pname:flags member of pname:pCreateInfo includes ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT, creating this sname:VkBuffer mustnot: cause the total required sparse memory for all currently valid sparse resources on the device to exceed sname:VkPhysicalDeviceLimits::pname:sparseAddressSpaceSize</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyBuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkBuffer</type> <name>buffer</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All submitted commands that refer to pname:buffer, either directly or via a sname:VkBufferView, must: have completed execution</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:buffer was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:buffer was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateBufferView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferViewCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkBufferView</type>* <name>pView</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyBufferView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkBufferView</type> <name>bufferView</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All submitted commands that refer to pname:bufferView must: have completed execution</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:bufferView was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:bufferView was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateImage</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkImage</type>* <name>pImage</name></param>
            <validity>
                <usage>If the pname:flags member of pname:pCreateInfo includes ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT, creating this sname:VkImage mustnot: cause the total required sparse memory for all currently valid sparse resources on the device to exceed sname:VkPhysicalDeviceLimits::pname:sparseAddressSpaceSize</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyImage</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkImage</type> <name>image</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All submitted commands that refer to pname:image, either directly or via a sname:VkImageView, must: have completed execution</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:image was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:image was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetImageSubresourceLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param>const <type>VkImageSubresource</type>* <name>pSubresource</name></param>
            <param><type>VkSubresourceLayout</type>* <name>pLayout</name></param>
            <validity>
                <usage>pname:image must: have been created with pname:tiling equal to ename:VK_IMAGE_TILING_LINEAR</usage>
                <usage>The pname:aspectMask member of pname:pSubresource must: only have a single bit set</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateImageView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageViewCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkImageView</type>* <name>pView</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyImageView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkImageView</type> <name>imageView</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All submitted commands that refer to pname:imageView must: have completed execution</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:imageView was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:imageView was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateShaderModule</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkShaderModuleCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkShaderModule</type>* <name>pShaderModule</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyShaderModule</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkShaderModule</type> <name>shaderModule</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>If sname:VkAllocationCallbacks were provided when pname:shaderModule was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:shaderModule was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreatePipelineCache</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineCacheCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkPipelineCache</type>* <name>pPipelineCache</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyPipelineCache</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>If sname:VkAllocationCallbacks were provided when pname:pipelineCache was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:pipelineCache was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPipelineCacheData</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkMergePipelineCaches</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkPipelineCache</type> <name>dstCache</name></param>
            <param><type>uint32_t</type> <name>srcCacheCount</name></param>
            <param len="srcCacheCount">const <type>VkPipelineCache</type>* <name>pSrcCaches</name></param>
            <validity>
                <usage>pname:dstCache mustnot: appear in the list of source caches</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateGraphicsPipelines</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkGraphicsPipelineCreateInfo</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
            <validity>
                <usage>If the pname:flags member of any given element of pname:pCreateInfos contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the pname:basePipelineIndex member of that same element is not `-1`, pname:basePipelineIndex must: be less than the index into pname:pCreateInfos that corresponds to that element</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateComputePipelines</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkComputePipelineCreateInfo</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
            <validity>
                <usage>If the pname:flags member of any given element of pname:pCreateInfos contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the pname:basePipelineIndex member of that same element is not `-1`, pname:basePipelineIndex must: be less than the index into pname:pCreateInfos that corresponds to that element</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyPipeline</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPipeline</type> <name>pipeline</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All submitted commands that refer to pname:pipeline must: have completed execution</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:pipeline was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:pipeline was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreatePipelineLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkPipelineLayout</type>* <name>pPipelineLayout</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyPipelineLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPipelineLayout</type> <name>pipelineLayout</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>If sname:VkAllocationCallbacks were provided when pname:pipelineLayout was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:pipelineLayout was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_TOO_MANY_OBJECTS">
            <proto><type>VkResult</type> <name>vkCreateSampler</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSamplerCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSampler</type>* <name>pSampler</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySampler</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSampler</type> <name>sampler</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All submitted commands that refer to pname:sampler must: have completed execution</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:sampler was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:sampler was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateDescriptorSetLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorSetLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDescriptorSetLayout</type>* <name>pSetLayout</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDescriptorSetLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDescriptorSetLayout</type> <name>descriptorSetLayout</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>If sname:VkAllocationCallbacks were provided when pname:descriptorSetLayout was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:descriptorSetLayout was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDescriptorPool</type>* <name>pDescriptorPool</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All submitted commands that refer to pname:descriptorPool (via any allocated descriptor sets) must: have completed execution</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:descriptorPool was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:descriptorPool was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param optional="true"><type>VkDescriptorPoolResetFlags</type> <name>flags</name></param>
            <implicitexternsyncparams>
                <param>any sname:VkDescriptorSet objects allocated from pname:descriptorPool</param>
            </implicitexternsyncparams>
            <validity>
                <usage>All uses of pname:descriptorPool (via any allocated descriptor sets) must: have completed execution</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkAllocateDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pAllocateInfo->descriptorPool">const <type>VkDescriptorSetAllocateInfo</type>* <name>pAllocateInfo</name></param>
            <param len="pAllocateInfo->descriptorSetCount"><type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkFreeDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param><type>uint32_t</type> <name>descriptorSetCount</name></param>
            <param noautovalidity="true" externsync="true" len="descriptorSetCount">const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
            <validity>
                <usage>All submitted commands that refer to any element of pname:pDescriptorSets must: have completed execution</usage>
                <usage>pname:pDescriptorSets must: be a pointer to an array of pname:descriptorSetCount sname:VkDescriptorSet handles, each element of which must: either be a valid handle or sname:VK_NULL_HANDLE</usage>
                <usage>pname:descriptorPool must: have been created with the ename:VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT flag</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkUpdateDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>uint32_t</type> <name>descriptorWriteCount</name></param>
            <param len="descriptorWriteCount" externsync="pDescriptorWrites[].dstSet">const <type>VkWriteDescriptorSet</type>* <name>pDescriptorWrites</name></param>
            <param optional="true"><type>uint32_t</type> <name>descriptorCopyCount</name></param>
            <param len="descriptorCopyCount" externsync="pDescriptorCopies[].dstSet">const <type>VkCopyDescriptorSet</type>* <name>pDescriptorCopies</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateFramebuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFramebufferCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkFramebuffer</type>* <name>pFramebuffer</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyFramebuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkFramebuffer</type> <name>framebuffer</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All submitted commands that refer to pname:framebuffer must: have completed execution</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:framebuffer was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:framebuffer was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateRenderPass</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkRenderPassCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkRenderPass</type>* <name>pRenderPass</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyRenderPass</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkRenderPass</type> <name>renderPass</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All submitted commands that refer to pname:renderPass must: have completed execution</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:renderPass was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:renderPass was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetRenderAreaGranularity</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkRenderPass</type> <name>renderPass</name></param>
            <param><type>VkExtent2D</type>* <name>pGranularity</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCommandPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkCommandPool</type>* <name>pCommandPool</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All sname:VkCommandBuffer objects allocated from pname:commandPool mustnot: be pending execution</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:commandPool was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:commandPool was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param optional="true"><type>VkCommandPoolResetFlags</type> <name>flags</name></param>
            <validity>
                <usage>All sname:VkCommandBuffer objects allocated from pname:commandPool mustnot: currently be pending execution</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkAllocateCommandBuffers</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pAllocateInfo->commandPool">const <type>VkCommandBufferAllocateInfo</type>* <name>pAllocateInfo</name></param>
            <param len="pAllocateInfo->commandBufferCount"><type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkFreeCommandBuffers</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param><type>uint32_t</type> <name>commandBufferCount</name></param>
            <param noautovalidity="true" externsync="true" len="commandBufferCount">const <type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
            <validity>
                <usage>All elements of pname:pCommandBuffers mustnot: be pending execution</usage>
                <usage>pname:pCommandBuffers must: be a pointer to an array of pname:commandBufferCount sname:VkCommandBuffer handles, each element of which must: either be a valid handle or sname:VK_NULL_HANDLE</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkBeginCommandBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCommandBufferBeginInfo</type>* <name>pBeginInfo</name></param>
            <validity>
                <usage>pname:commandBuffer mustnot: be in the recording state</usage>
                <usage>pname:commandBuffer mustnot: currently be pending execution</usage>
                <usage>If pname:commandBuffer was allocated from a sname:VkCommandPool which did not have the ename:VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT flag set, pname:commandBuffer must: be in the initial state.</usage>
                <usage>If pname:commandBuffer is a secondary command buffer, the pname:pInheritanceInfo member of pname:pBeginInfo must: be a valid sname:VkCommandBufferInheritanceInfo structure</usage>
                <usage>If pname:commandBuffer is a secondary command buffer and either the pname:occlusionQueryEnable member of the pname:pInheritanceInfo member of pname:pBeginInfo is ename:VK_FALSE, or the precise occlusion queries feature is not enabled, the pname:queryFlags member of the pname:pInheritanceInfo member pname:pBeginInfo mustnot: contain ename:VK_QUERY_CONTROL_PRECISE_BIT</usage>

            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkEndCommandBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <validity>
                <usage>pname:commandBuffer must: be in the recording state</usage>
                <usage>fname:vkEndCommandBuffer mustnot: be called inside a render pass instance</usage>
                <usage>All queries made &lt;&lt;queries-operation-active,active&gt;&gt; during the recording of pname:commandBuffer must: have been made inactive</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkResetCommandBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>VkCommandBufferResetFlags</type> <name>flags</name></param>
            <validity>
                <usage>pname:commandBuffer mustnot: currently be pending execution</usage>
                <usage>pname:commandBuffer must: have been allocated from a pool that was created with the ename:VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</usage>
            </validity>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindPipeline</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
            <validity>
                <usage>If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_COMPUTE, the sname:VkCommandPool that pname:commandBuffer was allocated from must: support compute operations</usage>
                <usage>If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_GRAPHICS, the sname:VkCommandPool that pname:commandBuffer was allocated from must: support graphics operations</usage>
                <usage>If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_COMPUTE, pname:pipeline must: be a compute pipeline</usage>
                <usage>If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_GRAPHICS, pname:pipeline must: be a graphics pipeline</usage>
                <usage>If the &lt;&lt;features-features-variableMultisampleRate,variable multisample rate&gt;&gt; feature is not supported, pname:pipeline is a graphics pipeline, the current subpass has no attachments, and this is not the first call to this function with a graphics pipeline after transitioning to the current subpass, then the sample count specified by this pipeline must: match that set in the previous pipeline</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetViewport</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstViewport</name></param>
            <param><type>uint32_t</type> <name>viewportCount</name></param>
            <param len="viewportCount">const <type>VkViewport</type>* <name>pViewports</name></param>
            <validity>
                <usage>pname:firstViewport must: be less than sname:VkPhysicalDeviceLimits::pname:maxViewports</usage>
                <usage>The sum of pname:firstViewport and pname:viewportCount must: be between `1` and sname:VkPhysicalDeviceLimits::pname:maxViewports, inclusive</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetScissor</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstScissor</name></param>
            <param><type>uint32_t</type> <name>scissorCount</name></param>
            <param len="scissorCount">const <type>VkRect2D</type>* <name>pScissors</name></param>
            <validity>
                <usage>pname:firstScissor must: be less than sname:VkPhysicalDeviceLimits::pname:maxViewports</usage>
                <usage>The sum of pname:firstScissor and pname:scissorCount must: be between `1` and sname:VkPhysicalDeviceLimits::pname:maxViewports, inclusive</usage>
                <usage>The pname:x and pname:y members of pname:offset must: be greater than or equal to `0`</usage>
                <usage>Evaluation of (pname:offset.x + pname:extent.width) mustnot: cause a signed integer addition overflow</usage>
                <usage>Evaluation of (pname:offset.y + pname:extent.height) mustnot: cause a signed integer addition overflow</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetLineWidth</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>float</type> <name>lineWidth</name></param>
            <validity>
                <usage>If the &lt;&lt;features-features-wideLines,wide lines&gt;&gt; feature is not enabled, pname:lineWidth must: be `1.0`</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetDepthBias</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>float</type> <name>depthBiasConstantFactor</name></param>
            <param><type>float</type> <name>depthBiasClamp</name></param>
            <param><type>float</type> <name>depthBiasSlopeFactor</name></param>
            <validity>
                <usage>If the &lt;&lt;features-features-depthBiasClamp,depth bias clamping&gt;&gt; feature is not enabled, pname:depthBiasClamp must: be code:0.0</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetBlendConstants</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>float</type> <name>blendConstants</name>[4]</param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetDepthBounds</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>float</type> <name>minDepthBounds</name></param>
            <param><type>float</type> <name>maxDepthBounds</name></param>
            <validity>
                <usage>pname:minDepthBounds must: be between `0.0` and `1.0`, inclusive</usage>
                <usage>pname:maxDepthBounds must: be between `0.0` and `1.0`, inclusive</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetStencilCompareMask</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
            <param><type>uint32_t</type> <name>compareMask</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetStencilWriteMask</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
            <param><type>uint32_t</type> <name>writeMask</name></param>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetStencilReference</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
            <param><type>uint32_t</type> <name>reference</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindDescriptorSets</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>uint32_t</type> <name>firstSet</name></param>
            <param><type>uint32_t</type> <name>descriptorSetCount</name></param>
            <param len="descriptorSetCount">const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
            <param optional="true"><type>uint32_t</type> <name>dynamicOffsetCount</name></param>
            <param len="dynamicOffsetCount">const <type>uint32_t</type>* <name>pDynamicOffsets</name></param>
            <validity>
                <usage>Any given element of pname:pDescriptorSets must: have been created with a sname:VkDescriptorSetLayout that matches (is the same as, or defined identically to) the sname:VkDescriptorSetLayout at set _n_ in pname:layout, where _n_ is the sum of pname:firstSet and the index into pname:pDescriptorSets</usage>
                <usage>pname:dynamicOffsetCount must: be equal to the total number of dynamic descriptors in pname:pDescriptorSets</usage>
                <usage>pname:pipelineBindPoint must: be supported by the pname:commandBuffer's parent sname:VkCommandPool's queue family</usage>
                <usage>Any given element of pname:pDynamicOffsets must: satisfy the required alignment for the corresponding descriptor binding's descriptor type</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindIndexBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkIndexType</type> <name>indexType</name></param>
            <validity>
                <usage>pname:offset must: be less than the size of pname:buffer</usage>
                <usage>The sum of pname:offset, and the address of the range of sname:VkDeviceMemory object that's backing pname:buffer, must: be a multiple of the type indicated by pname:indexType</usage>
                <usage>pname:buffer must: have been created with the ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT flag</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBindVertexBuffers</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstBinding</name></param>
            <param><type>uint32_t</type> <name>bindingCount</name></param>
            <param len="bindingCount">const <type>VkBuffer</type>* <name>pBuffers</name></param>
            <param len="bindingCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
            <validity>
                <usage>pname:firstBinding must: be less than sname:VkPhysicalDeviceLimits::pname:maxVertexInputBindings</usage>
                <usage>The sum of pname:firstBinding and pname:bindingCount must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxVertexInputBindings</usage>
                <usage>All elements of pname:pOffsets must: be less than the size of the corresponding element in pname:pBuffers</usage>
                <usage>All elements of pname:pBuffers must: have been created with the ename:VK_BUFFER_USAGE_VERTEX_BUFFER_BIT flag</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDraw</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>vertexCount</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
            <param><type>uint32_t</type> <name>firstVertex</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
            <validity>
                <usage>For each set _n_ that is statically used by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout that is compatible for set _n_, with the sname:VkPipelineLayout used to create the current sname:VkPipeline, as described in &lt;&lt;descriptorsets-compatibility&gt;&gt;</usage>
                <usage>For each push constant that is statically used by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout that is compatible for push constants, with the sname:VkPipelineLayout used to create the current sname:VkPipeline, as described in &lt;&lt;descriptorsets-compatibility&gt;&gt;</usage>
                <usage>Descriptors in each bound descriptor set, specified via fname:vkCmdBindDescriptorSets, must: be valid if they are statically used by the currently bound sname:VkPipeline object, specified via fname:vkCmdBindPipeline</usage>
                <usage>All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must: have valid buffers bound</usage>
                <usage>For a given vertex buffer binding, any attribute data fetched must: be entirely contained within the corresponding vertex buffer binding, as described in &lt;&lt;fxvertex-input&gt;&gt;</usage>
                <usage>A valid graphics pipeline must: be bound to the current command buffer with ename:VK_PIPELINE_BIND_POINT_GRAPHICS</usage>
                <usage>If the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must: have been set on the current command buffer</usage>
                <usage>Every input attachment used by the current subpass must: be bound to the pipeline via a descriptor set</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it mustnot: be used to sample from any sname:VkImage with a sname:VkImageView of the type ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it mustnot: be used with any of the SPIR-V `OpImageSample*` or `OpImageSparseSample*` instructions with code:ImplicitLod, code:Dref or code:Proj in their name, in any shader stage</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it mustnot: be used with any of the SPIR-V `OpImageSample*` or `OpImageSparseSample*` instructions that includes a lod bias or any offset values, in any shader stage</usage>
                <usage>If the &lt;&lt;features-features-robustBufferAccess,robust buffer access&gt;&gt; feature is not enabled, and any shader stage in the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it mustnot: access values outside of the range of that buffer specified in the currently bound descriptor set</usage>
                <usage>If the &lt;&lt;features-features-robustBufferAccess,robust buffer access&gt;&gt; feature is not enabled, and any shader stage in the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it mustnot: access values outside of the range of that buffer specified in the currently bound descriptor set</usage>
                <usage>Any sname:VkImageView being sampled with ename:VK_FILTER_LINEAR as a result of this command must: be of a format which supports linear filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDrawIndexed</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>indexCount</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
            <param><type>uint32_t</type> <name>firstIndex</name></param>
            <param><type>int32_t</type> <name>vertexOffset</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
            <validity>
                <usage>For each set _n_ that is statically used by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout that is compatible for set _n_, with the sname:VkPipelineLayout used to create the current sname:VkPipeline, as described in &lt;&lt;descriptorsets-compatibility&gt;&gt;</usage>
                <usage>For each push constant that is statically used by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout that is compatible for push constants, with the sname:VkPipelineLayout used to create the current sname:VkPipeline, as described in &lt;&lt;descriptorsets-compatibility&gt;&gt;</usage>
                <usage>Descriptors in each bound descriptor set, specified via fname:vkCmdBindDescriptorSets, must: be valid if they are statically used by the currently bound sname:VkPipeline object, specified via fname:vkCmdBindPipeline</usage>
                <usage>All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must: have valid buffers bound</usage>
                <usage>For a given vertex buffer binding, any attribute data fetched must: be entirely contained within the corresponding vertex buffer binding, as described in &lt;&lt;fxvertex-input&gt;&gt;</usage>
                <usage>A valid graphics pipeline must: be bound to the current command buffer with ename:VK_PIPELINE_BIND_POINT_GRAPHICS</usage>
                <usage>If the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must: have been set on the current command buffer</usage>
                <usage>(pname:indexSize * (pname:firstIndex + pname:indexCount) + pname:offset) must: be less than or equal to the size of the currently bound index buffer, with indexSize being based on the type specified by pname:indexType, where the index buffer, pname:indexType, and pname:offset are specified via fname:vkCmdBindIndexBuffer</usage>
                <usage>Every input attachment used by the current subpass must: be bound to the pipeline via a descriptor set</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it mustnot: be used to sample from any sname:VkImage with a sname:VkImageView of the type ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it mustnot: be used with any of the SPIR-V `OpImageSample*` or `OpImageSparseSample*` instructions with code:ImplicitLod, code:Dref or code:Proj in their name, in any shader stage</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it mustnot: be used with any of the SPIR-V `OpImageSample*` or `OpImageSparseSample*` instructions that includes a lod bias or any offset values, in any shader stage</usage>
                <usage>If the &lt;&lt;features-features-robustBufferAccess,robust buffer access&gt;&gt; feature is not enabled, and any shader stage in the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it mustnot: access values outside of the range of that buffer specified in the currently bound descriptor set</usage>
                <usage>If the &lt;&lt;features-features-robustBufferAccess,robust buffer access&gt;&gt; feature is not enabled, and any shader stage in the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it mustnot: access values outside of the range of that buffer specified in the currently bound descriptor set</usage>
                <usage>Any sname:VkImageView being sampled with ename:VK_FILTER_LINEAR as a result of this command must: be of a format which supports linear filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDrawIndirect</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>drawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
            <validity>
                <usage>pname:offset must: be a multiple of `4`</usage>
                <usage>If pname:drawCount is greater than `1`, pname:stride must: be a multiple of `4` and must: be greater than or equal to sizeof(sname:VkDrawIndirectCommand)</usage>
                <usage>If the &lt;&lt;features-features-multiDrawIndirect,multi-draw indirect&gt;&gt; feature is not enabled, pname:drawCount must: be `0` or `1`</usage>
                <usage>If the &lt;&lt;features-features-drawIndirectFirstInstance,drawIndirectFirstInstance&gt;&gt; feature is not enabled, all the pname:firstInstance members of the sname:VkDrawIndirectCommand structures accessed by this command must: be code:0</usage>
                <usage>For each set _n_ that is statically used by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout that is compatible for set _n_, with the sname:VkPipelineLayout used to create the current sname:VkPipeline, as described in &lt;&lt;descriptorsets-compatibility&gt;&gt;</usage>
                <usage>For each push constant that is statically used by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout that is compatible for push constants, with the sname:VkPipelineLayout used to create the current sname:VkPipeline, as described in &lt;&lt;descriptorsets-compatibility&gt;&gt;</usage>
                <usage>Descriptors in each bound descriptor set, specified via fname:vkCmdBindDescriptorSets, must: be valid if they are statically used by the currently bound sname:VkPipeline object, specified via fname:vkCmdBindPipeline</usage>
                <usage>All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must: have valid buffers bound</usage>
                <usage>A valid graphics pipeline must: be bound to the current command buffer with ename:VK_PIPELINE_BIND_POINT_GRAPHICS</usage>
                <usage>If the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must: have been set on the current command buffer</usage>
                <usage>If pname:drawCount is equal to `1`, (pname:offset + sizeof(sname:VkDrawIndirectCommand)) must: be less than or equal to the size of pname:buffer</usage>
                <usage>If pname:drawCount is greater than `1`, (pname:stride x (pname:drawCount - 1) + pname:offset + sizeof(sname:VkDrawIndirectCommand)) must: be less than or equal to the size of pname:buffer</usage>
                <usage>pname:drawCount must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount</usage>
                <usage>Every input attachment used by the current subpass must: be bound to the pipeline via a descriptor set</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it mustnot: be used to sample from any sname:VkImage with a sname:VkImageView of the type ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it mustnot: be used with any of the SPIR-V `OpImageSample*` or `OpImageSparseSample*` instructions with code:ImplicitLod, code:Dref or code:Proj in their name, in any shader stage</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it mustnot: be used with any of the SPIR-V `OpImageSample*` or `OpImageSparseSample*` instructions that includes a lod bias or any offset values, in any shader stage</usage>
                <usage>If the &lt;&lt;features-features-robustBufferAccess,robust buffer access&gt;&gt; feature is not enabled, and any shader stage in the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it mustnot: access values outside of the range of that buffer specified in the currently bound descriptor set</usage>
                <usage>If the &lt;&lt;features-features-robustBufferAccess,robust buffer access&gt;&gt; feature is not enabled, and any shader stage in the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it mustnot: access values outside of the range of that buffer specified in the currently bound descriptor set</usage>
                <usage>Any sname:VkImageView being sampled with ename:VK_FILTER_LINEAR as a result of this command must: be of a format which supports linear filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDrawIndexedIndirect</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>drawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
            <validity>
                <usage>pname:offset must: be a multiple of `4`</usage>
                <usage>If pname:drawCount is greater than `1`, pname:stride must: be a multiple of `4` and must: be greater than or equal to sizeof(sname:VkDrawIndexedIndirectCommand)</usage>
                <usage>If the &lt;&lt;features-features-multiDrawIndirect,multi-draw indirect&gt;&gt; feature is not enabled, pname:drawCount must: be `0` or `1`</usage>
                <usage>If the &lt;&lt;features-features-drawIndirectFirstInstance,drawIndirectFirstInstance&gt;&gt; feature is not enabled, all the pname:firstInstance members of the sname:VkDrawIndexedIndirectCommand structures accessed by this command must: be code:0</usage>
                <usage>For each set _n_ that is statically used by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout that is compatible for set _n_, with the sname:VkPipelineLayout used to create the current sname:VkPipeline, as described in &lt;&lt;descriptorsets-compatibility&gt;&gt;</usage>
                <usage>For each push constant that is statically used by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a sname:VkPipelineLayout that is compatible for push constants, with the sname:VkPipelineLayout used to create the current sname:VkPipeline, as described in &lt;&lt;descriptorsets-compatibility&gt;&gt;</usage>
                <usage>Descriptors in each bound descriptor set, specified via fname:vkCmdBindDescriptorSets, must: be valid if they are statically used by the currently bound sname:VkPipeline object, specified via fname:vkCmdBindPipeline</usage>
                <usage>All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must: have valid buffers bound</usage>
                <usage>A valid graphics pipeline must: be bound to the current command buffer with ename:VK_PIPELINE_BIND_POINT_GRAPHICS</usage>
                <usage>If the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must: have been set on the current command buffer</usage>
                <usage>If pname:drawCount is equal to `1`, (pname:offset + sizeof(sname:VkDrawIndexedIndirectCommand)) must: be less than or equal to the size of pname:buffer</usage>
                <usage>If pname:drawCount is greater than `1`, (pname:stride x (pname:drawCount - 1) + pname:offset + sizeof(sname:VkDrawIndexedIndirectCommand)) must: be less than or equal to the size of pname:buffer</usage>
                <usage>pname:drawCount must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount</usage>
                <usage>Every input attachment used by the current subpass must: be bound to the pipeline via a descriptor set</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it mustnot: be used to sample from any sname:VkImage with a sname:VkImageView of the type ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it mustnot: be used with any of the SPIR-V `OpImageSample*` or `OpImageSparseSample*` instructions with code:ImplicitLod, code:Dref or code:Proj in their name, in any shader stage</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it mustnot: be used with any of the SPIR-V `OpImageSample*` or `OpImageSparseSample*` instructions that includes a lod bias or any offset values, in any shader stage</usage>
                <usage>If the &lt;&lt;features-features-robustBufferAccess,robust buffer access&gt;&gt; feature is not enabled, and any shader stage in the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it mustnot: access values outside of the range of that buffer specified in the currently bound descriptor set</usage>
                <usage>If the &lt;&lt;features-features-robustBufferAccess,robust buffer access&gt;&gt; feature is not enabled, and any shader stage in the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it mustnot: access values outside of the range of that buffer specified in the currently bound descriptor set</usage>
                <usage>Any sname:VkImageView being sampled with ename:VK_FILTER_LINEAR as a result of this command must: be of a format which supports linear filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
            </validity>
        </command>
        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDispatch</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>x</name></param>
            <param><type>uint32_t</type> <name>y</name></param>
            <param><type>uint32_t</type> <name>z</name></param>
            <validity>
                <usage>pname:x must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[0]</usage>
                <usage>pname:y must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[1]</usage>
                <usage>pname:z must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[2]</usage>
                <usage>For each set _n_ that is statically used by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE, a descriptor set must: have been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_COMPUTE, with a sname:VkPipelineLayout that is compatible for set _n_, with the sname:VkPipelineLayout used to create the current sname:VkPipeline, as described in &lt;&lt;descriptorsets-compatibility&gt;&gt;</usage>
                <usage>Descriptors in each bound descriptor set, specified via fname:vkCmdBindDescriptorSets, must: be valid if they are statically used by the currently bound sname:VkPipeline object, specified via fname:vkCmdBindPipeline</usage>
                <usage>A valid compute pipeline must: be bound to the current command buffer with ename:VK_PIPELINE_BIND_POINT_COMPUTE</usage>
                <usage>For each push constant that is statically used by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE, a push constant value must: have been set for ename:VK_PIPELINE_BIND_POINT_COMPUTE, with a sname:VkPipelineLayout that is compatible for push constants with the one used to create the current sname:VkPipeline, as described in &lt;&lt;descriptorsets-compatibility&gt;&gt;</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it mustnot: be used to sample from any sname:VkImage with a sname:VkImageView of the type ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it mustnot: be used with any of the SPIR-V `OpImageSample*` or `OpImageSparseSample*` instructions with code:ImplicitLod, code:Dref or code:Proj in their name, in any shader stage</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it mustnot: be used with any of the SPIR-V `OpImageSample*` or `OpImageSparseSample*` instructions that includes a lod bias or any offset values, in any shader stage</usage>
                <usage>If the &lt;&lt;features-features-robustBufferAccess,robust buffer access&gt;&gt; feature is not enabled, and any shader stage in the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE accesses a uniform buffer, it mustnot: access values outside of the range of that buffer specified in the currently bound descriptor set</usage>
                <usage>If the &lt;&lt;features-features-robustBufferAccess,robust buffer access&gt;&gt; feature is not enabled, and any shader stage in the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE accesses a storage buffer, it mustnot: access values outside of the range of that buffer specified in the currently bound descriptor set</usage>
                <usage>Any sname:VkImageView being sampled with ename:VK_FILTER_LINEAR as a result of this command must: be of a format which supports linear filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
            </validity>
        </command>
        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDispatchIndirect</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <validity>
                <usage>For each set _n_ that is statically used by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE, a descriptor set must: have been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_COMPUTE, with a sname:VkPipelineLayout that is compatible for set _n_, with the sname:VkPipelineLayout used to create the current sname:VkPipeline, as described in &lt;&lt;descriptorsets-compatibility&gt;&gt;</usage>
                <usage>Descriptors in each bound descriptor set, specified via fname:vkCmdBindDescriptorSets, must: be valid if they are statically used by the currently bound sname:VkPipeline object, specified via fname:vkCmdBindPipeline</usage>
                <usage>A valid compute pipeline must: be bound to the current command buffer with ename:VK_PIPELINE_BIND_POINT_COMPUTE</usage>
                <usage>pname:buffer must: have been created with the ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</usage>
                <usage>pname:offset must: be a multiple of `4`</usage>
                <usage>The sum of pname:offset and the size of sname:VkDispatchIndirectCommand must: be less than or equal to the size of pname:buffer</usage>
                <usage>For each push constant that is statically used by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE, a push constant value must: have been set for ename:VK_PIPELINE_BIND_POINT_COMPUTE, with a sname:VkPipelineLayout that is compatible for push constants with the one used to create the current sname:VkPipeline, as described in &lt;&lt;descriptorsets-compatibility&gt;&gt;</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it mustnot: be used to sample from any sname:VkImage with a sname:VkImageView of the type ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it mustnot: be used with any of the SPIR-V `OpImageSample*` or `OpImageSparseSample*` instructions with code:ImplicitLod, code:Dref or code:Proj in their name, in any shader stage</usage>
                <usage>If any sname:VkSampler object that is accessed from a shader by the sname:VkPipeline currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it mustnot: be used with any of the SPIR-V `OpImageSample*` or `OpImageSparseSample*` instructions that includes a lod bias or any offset values, in any shader stage</usage>
                <usage>If the &lt;&lt;features-features-robustBufferAccess,robust buffer access&gt;&gt; feature is not enabled, and any shader stage in the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE accesses a uniform buffer, it mustnot: access values outside of the range of that buffer specified in the currently bound descriptor set</usage>
                <usage>If the &lt;&lt;features-features-robustBufferAccess,robust buffer access&gt;&gt; feature is not enabled, and any shader stage in the sname:VkPipeline object currently bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE accesses a storage buffer, it mustnot: access values outside of the range of that buffer specified in the currently bound descriptor set</usage>
                <usage>Any sname:VkImageView being sampled with ename:VK_FILTER_LINEAR as a result of this command must: be of a format which supports linear filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
            </validity>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdCopyBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkBufferCopy</type>* <name>pRegions</name></param>
            <validity>
                <usage>The pname:size member of a given element of pname:pRegions must: be greater than `0`</usage>
                <usage>The pname:srcOffset member of a given element of pname:pRegions must: be less than the size of pname:srcBuffer</usage>
                <usage>The pname:dstOffset member of a given element of pname:pRegions must: be less than the size of pname:dstBuffer</usage>
                <usage>The pname:size member of a given element of pname:pRegions must: be less than or equal to the size of pname:srcBuffer minus pname:srcOffset</usage>
                <usage>The pname:size member of a given element of pname:pRegions must: be less than or equal to the size of pname:dstBuffer minus pname:dstOffset</usage>
                <usage>The union of the source regions, and the union of the destination regions, specified by the elements of pname:pRegions, mustnot: overlap in memory</usage>
                <usage>pname:srcBuffer must: have been created with ename:VK_BUFFER_USAGE_TRANSFER_SRC_BIT usage flag</usage>
                <usage>pname:dstBuffer must: have been created with ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag</usage>
            </validity>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdCopyImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkImageCopy</type>* <name>pRegions</name></param>
            <validity>
                <usage>The source region specified by a given element of pname:pRegions must: be a region that is contained within pname:srcImage</usage>
                <usage>The destination region specified by a given element of pname:pRegions must: be a region that is contained within pname:dstImage</usage>
                <usage>The union of all source regions, and the union of all destination regions, specified by the elements of pname:pRegions, mustnot: overlap in memory</usage>
                <usage>pname:srcImage must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag</usage>
                <usage>pname:srcImageLayout must: specify the layout of the image subresources of pname:srcImage specified in pname:pRegions at the time this command is executed on a sname:VkDevice</usage>
                <usage>pname:srcImageLayout must: be either of ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or ename:VK_IMAGE_LAYOUT_GENERAL</usage>
                <usage>pname:dstImage must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag</usage>
                <usage>pname:dstImageLayout must: specify the layout of the image subresources of pname:dstImage specified in pname:pRegions at the time this command is executed on a sname:VkDevice</usage>
                <usage>pname:dstImageLayout must: be either of ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or ename:VK_IMAGE_LAYOUT_GENERAL</usage>
                <usage>The elink:VkFormat of each of pname:srcImage and pname:dstImage must: be compatible, as defined &lt;&lt;copies-images-format-compatibility, below&gt;&gt;</usage>
                <usage>The sample count of pname:srcImage and pname:dstImage must: match</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBlitImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkImageBlit</type>* <name>pRegions</name></param>
            <param><type>VkFilter</type> <name>filter</name></param>
            <validity>
                <usage>The source region specified by a given element of pname:pRegions must: be a region that is contained within pname:srcImage</usage>
                <usage>The destination region specified by a given element of pname:pRegions must: be a region that is contained within pname:dstImage</usage>
                <usage>The union of all source regions, and the union of all destination regions, specified by the elements of pname:pRegions, mustnot: overlap in memory</usage>
                <usage>pname:srcImage must: use a format that supports ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT, which is indicated by sname:VkFormatProperties::pname:linearTilingFeatures (for linear tiled images) or sname:VkFormatProperties::pname:optimalTilingFeatures (for optimally tiled images) - as returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage>pname:srcImage must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag</usage>
                <usage>pname:srcImageLayout must: specify the layout of the image subresources of pname:srcImage specified in pname:pRegions at the time this command is executed on a sname:VkDevice</usage>
                <usage>pname:srcImageLayout must: be either of ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or ename:VK_IMAGE_LAYOUT_GENERAL</usage>
                <usage>pname:dstImage must: use a format that supports ename:VK_FORMAT_FEATURE_BLIT_DST_BIT, which is indicated by sname:VkFormatProperties::pname:linearTilingFeatures (for linear tiled images) or sname:VkFormatProperties::pname:optimalTilingFeatures (for optimally tiled images) - as returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage>pname:dstImage must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag</usage>
                <usage>pname:dstImageLayout must: specify the layout of the image subresources of pname:dstImage specified in pname:pRegions at the time this command is executed on a sname:VkDevice</usage>
                <usage>pname:dstImageLayout must: be either of ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or ename:VK_IMAGE_LAYOUT_GENERAL</usage>
                <usage>The sample count of pname:srcImage and pname:dstImage must: both be equal to ename:VK_SAMPLE_COUNT_1_BIT</usage>
                <usage>If either of pname:srcImage or pname:dstImage was created with a signed integer elink:VkFormat, the other must: also have been created with a signed integer elink:VkFormat</usage>
                <usage>If either of pname:srcImage or pname:dstImage was created with an unsigned integer elink:VkFormat, the other must: also have been created with an unsigned integer elink:VkFormat</usage>
                <usage>If either of pname:srcImage or pname:dstImage was created with a depth/stencil format, the other must: have exactly the same format</usage>
                <usage>If pname:srcImage was created with a depth/stencil format, pname:filter must: be ename:VK_FILTER_NEAREST</usage>
                <usage>If pname:filter is ename:VK_FILTER_LINEAR, pname:srcImage must: be of a format which supports linear filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
            </validity>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdCopyBufferToImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
            <validity>
                <usage>The buffer region specified by a given element of pname:pRegions must: be a region that is contained within pname:srcBuffer</usage>
                <usage>The image region specified by a given element of pname:pRegions must: be a region that is contained within pname:dstImage</usage>
                <usage>The union of all source regions, and the union of all destination regions, specified by the elements of pname:pRegions, mustnot: overlap in memory</usage>
                <usage>pname:srcBuffer must: have been created with ename:VK_BUFFER_USAGE_TRANSFER_SRC_BIT usage flag</usage>
                <usage>pname:dstImage must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag</usage>
                <usage>pname:dstImage must: have a sample count equal to ename:VK_SAMPLE_COUNT_1_BIT</usage>
                <usage>pname:dstImageLayout must: specify the layout of the image subresources of pname:dstImage specified in pname:pRegions at the time this command is executed on a sname:VkDevice</usage>
                <usage>pname:dstImageLayout must: be either of ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or ename:VK_IMAGE_LAYOUT_GENERAL</usage>
            </validity>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdCopyImageToBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
            <validity>
                <usage>The image region specified by a given element of pname:pRegions must: be a region that is contained within pname:srcImage</usage>
                <usage>The buffer region specified by a given element of pname:pRegions must: be a region that is contained within pname:dstBuffer</usage>
                <usage>The union of all source regions, and the union of all destination regions, specified by the elements of pname:pRegions, mustnot: overlap in memory</usage>
                <usage>pname:srcImage must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag</usage>
                <usage>pname:srcImage must: have a sample count equal to ename:VK_SAMPLE_COUNT_1_BIT</usage>
                <usage>pname:srcImageLayout must: specify the layout of the image subresources of pname:srcImage specified in pname:pRegions at the time this command is executed on a sname:VkDevice</usage>
                <usage>pname:srcImageLayout must: be either of ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or ename:VK_IMAGE_LAYOUT_GENERAL</usage>
                <usage>pname:dstBuffer must: have been created with ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag</usage>
            </validity>
        </command>
        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdUpdateBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>VkDeviceSize</type> <name>dataSize</name></param>
            <param len="latexmath:[$dataSize \over 4$]">const <type>uint32_t</type>* <name>pData</name></param>
            <validity>
                <usage>pname:dataSize must: be greater than `0`</usage>
                <usage>pname:dstOffset must: be less than the size of pname:dstBuffer</usage>
                <usage>pname:dataSize must: be less than or equal to the size of pname:dstBuffer minus pname:dstOffset</usage>
                <usage>pname:dstBuffer must: have been created with ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag</usage>
                <usage>pname:dstOffset must: be a multiple of `4`</usage>
                <usage>pname:dataSize must: be less than or equal to `65536`</usage>
                <usage>pname:dataSize must: be a multiple of `4`</usage>
            </validity>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdFillBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>VkDeviceSize</type> <name>size</name></param>
            <param><type>uint32_t</type> <name>data</name></param>
            <validity>
                <usage>pname:dstOffset must: be less than the size of pname:dstBuffer</usage>
                <usage>pname:dstOffset must: be a multiple of `4`</usage>
                <usage>If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be greater than `0`</usage>
                <usage>If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be less than or equal to the size of pname:dstBuffer minus pname:dstOffset</usage>
                <usage>If pname:size is not equal to ename:VK_WHOLE_SIZE, pname:size must: be a multiple of `4`</usage>
                <usage>pname:dstBuffer must: have been created with ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag</usage>
            </validity>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdClearColorImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
            <param>const <type>VkClearColorValue</type>* <name>pColor</name></param>
            <param><type>uint32_t</type> <name>rangeCount</name></param>
            <param len="rangeCount">const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
            <validity>
                <usage>pname:image must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag</usage>
                <usage>pname:imageLayout must: specify the layout of the image subresource ranges of pname:image specified in pname:pRanges at the time this command is executed on a sname:VkDevice</usage>
                <usage>pname:imageLayout must: be either of ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or ename:VK_IMAGE_LAYOUT_GENERAL</usage>
                <usage>The image range of any given element of pname:pRanges must: be an image subresource range that is contained within pname:image</usage>
                <usage>pname:image mustnot: have a compressed or depth/stencil format</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdClearDepthStencilImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
            <param>const <type>VkClearDepthStencilValue</type>* <name>pDepthStencil</name></param>
            <param><type>uint32_t</type> <name>rangeCount</name></param>
            <param len="rangeCount">const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
            <validity>
                <usage>pname:image must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag</usage>
                <usage>pname:imageLayout must: specify the layout of the image subresource ranges of pname:image specified in pname:pRanges at the time this command is executed on a sname:VkDevice</usage>
                <usage>pname:imageLayout must: be either of ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or ename:VK_IMAGE_LAYOUT_GENERAL</usage>
                <usage>The image range of any given element of pname:pRanges must: be an image subresource range that is contained within pname:image</usage>
                <usage>pname:image must: have a depth/stencil format</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdClearAttachments</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>attachmentCount</name></param>
            <param len="attachmentCount">const <type>VkClearAttachment</type>* <name>pAttachments</name></param>
            <param><type>uint32_t</type> <name>rectCount</name></param>
            <param len="rectCount">const <type>VkClearRect</type>* <name>pRects</name></param>
            <validity>
                <usage>If the pname:aspectMask member of any given element of pname:pAttachments contains ename:VK_IMAGE_ASPECT_COLOR_BIT, the pname:colorAttachment member of those elements must: refer to a valid color attachment in the current subpass</usage>
                <usage>The rectangular region specified by a given element of pname:pRects must: be contained within the render area of the current render pass instance</usage>
                <usage>The layers specified by a given element of pname:pRects must: be contained within every attachment that pname:pAttachments refers to</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdResolveImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkImageResolve</type>* <name>pRegions</name></param>
            <validity>
                <usage>The source region specified by a given element of pname:pRegions must: be a region that is contained within pname:srcImage</usage>
                <usage>The destination region specified by a given element of pname:pRegions must: be a region that is contained within pname:dstImage</usage>
                <usage>The union of all source regions, and the union of all destination regions, specified by the elements of pname:pRegions, mustnot: overlap in memory</usage>
                <usage>pname:srcImage must: have a sample count equal to any valid sample count value other than ename:VK_SAMPLE_COUNT_1_BIT</usage>
                <usage>pname:dstImage must: have a sample count equal to ename:VK_SAMPLE_COUNT_1_BIT</usage>
                <usage>pname:srcImageLayout must: specify the layout of the image subresources of pname:srcImage specified in pname:pRegions at the time this command is executed on a sname:VkDevice</usage>
                <usage>pname:srcImageLayout must: be either of ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or ename:VK_IMAGE_LAYOUT_GENERAL</usage>
                <usage>pname:dstImageLayout must: specify the layout of the image subresources of pname:dstImage specified in pname:pRegions at the time this command is executed on a sname:VkDevice</usage>
                <usage>pname:dstImageLayout must: be either of ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or ename:VK_IMAGE_LAYOUT_GENERAL</usage>
                <usage>If pname:dstImage was created with pname:tiling equal to ename:VK_IMAGE_TILING_LINEAR, pname:dstImage must: have been created with a pname:format that supports being a color attachment, as specified by the ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT flag in sname:VkFormatProperties::pname:linearTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage>If pname:dstImage was created with pname:tiling equal to ename:VK_IMAGE_TILING_OPTIMAL, pname:dstImage must: have been created with a pname:format that supports being a color attachment, as specified by the ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT flag in sname:VkFormatProperties::pname:optimalTilingFeatures returned by fname:vkGetPhysicalDeviceFormatProperties</usage>

            </validity>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdSetEvent</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
            <param><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
            <validity>
                <usage>If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:stageMask mustnot: contain ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</usage>
                <usage>If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:stageMask mustnot: contain ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</usage>
            </validity>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdResetEvent</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
            <param><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
            <validity>
                <usage>If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:stageMask mustnot: contain ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</usage>
                <usage>If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:stageMask mustnot: contain ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</usage>
                <usage>When this command executes, pname:event mustnot: be waited on by a fname:vkCmdWaitEvents command that is currently executing</usage>
            </validity>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdWaitEvents</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>eventCount</name></param>
            <param len="eventCount">const <type>VkEvent</type>* <name>pEvents</name></param>
            <param><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
            <param><type>VkPipelineStageFlags</type> <name>dstStageMask</name></param>
            <param optional="true"><type>uint32_t</type> <name>memoryBarrierCount</name></param>
            <param len="memoryBarrierCount">const <type>VkMemoryBarrier</type>* <name>pMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>bufferMemoryBarrierCount</name></param>
            <param len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier</type>* <name>pBufferMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>imageMemoryBarrierCount</name></param>
            <param len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier</type>* <name>pImageMemoryBarriers</name></param>
            <validity>
                <usage>pname:srcStageMask must: be the bitwise OR of the pname:stageMask parameter used in previous calls to fname:vkCmdSetEvent with any of the members of pname:pEvents and ename:VK_PIPELINE_STAGE_HOST_BIT if any of the members of pname:pEvents was set using fname:vkSetEvent</usage>
                <usage>If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:srcStageMask mustnot: contain ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</usage>
                <usage>If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:dstStageMask mustnot: contain ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</usage>
                <usage>If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:srcStageMask mustnot: contain ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</usage>
                <usage>If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:dstStageMask mustnot: contain ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</usage>
                <usage>If pname:pEvents includes one or more events that will be signaled by fname:vkSetEvent after pname:commandBuffer has been submitted to a queue, then fname:vkCmdWaitEvents mustnot: be called inside a render pass instance</usage>
            </validity>
        </command>
        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdPipelineBarrier</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
            <param><type>VkPipelineStageFlags</type> <name>dstStageMask</name></param>
            <param optional="true"><type>VkDependencyFlags</type> <name>dependencyFlags</name></param>
            <param optional="true"><type>uint32_t</type> <name>memoryBarrierCount</name></param>
            <param len="memoryBarrierCount">const <type>VkMemoryBarrier</type>* <name>pMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>bufferMemoryBarrierCount</name></param>
            <param len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier</type>* <name>pBufferMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>imageMemoryBarrierCount</name></param>
            <param len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier</type>* <name>pImageMemoryBarriers</name></param>
            <validity>
                <usage>If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:srcStageMask mustnot: contain ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</usage>
                <usage>If the &lt;&lt;features-features-geometryShader,geometry shaders&gt;&gt; feature is not enabled, pname:dstStageMask mustnot: contain ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</usage>
                <usage>If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:srcStageMask mustnot: contain ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</usage>
                <usage>If the &lt;&lt;features-features-tessellationShader,tessellation shaders&gt;&gt; feature is not enabled, pname:dstStageMask mustnot: contain ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</usage>
                <usage>If fname:vkCmdPipelineBarrier is called within a render pass instance, the render pass must: declare at least one self-dependency from the current subpass to itself - see &lt;&lt;synchronization-pipeline-barriers-subpass-self-dependencies,Subpass Self-dependency&gt;&gt;</usage>
            </validity>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdBeginQuery</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
            <param optional="true"><type>VkQueryControlFlags</type> <name>flags</name></param>
            <validity>
                <usage>The query identified by pname:queryPool and pname:query must: currently not be &lt;&lt;queries-operation-active,active&gt;&gt;</usage>
                <usage>The query identified by pname:queryPool and pname:query must: be unavailable</usage>
                <usage>If the &lt;&lt;features-features-occlusionQueryPrecise,precise occlusion queries&gt;&gt; feature is not enabled, or the pname:queryType used to create pname:queryPool was not ename:VK_QUERY_TYPE_OCCLUSION, pname:flags mustnot: contain ename:VK_QUERY_CONTROL_PRECISE_BIT</usage>
                <usage>pname:queryPool must: have been created with a pname:queryType that differs from that of any other queries that have been made &lt;&lt;queries-operation-active,active&gt;&gt;, and are currently still active within pname:commandBuffer</usage>
                <usage>pname:query must: be less than the number of queries in pname:queryPool</usage>
                <usage>If the pname:queryType used to create pname:queryPool was ename:VK_QUERY_TYPE_OCCLUSION, the sname:VkCommandPool that pname:commandBuffer was created from must: support graphics operations</usage>
                <usage>If the pname:queryType used to create pname:queryPool was ename:VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pname:pipelineStatistics indicate graphics operations, the sname:VkCommandPool that pname:commandBuffer was created from must: support graphics operations</usage>
                <usage>If the pname:queryType used to create pname:queryPool was ename:VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pname:pipelineStatistics indicate compute operations, the sname:VkCommandPool that pname:commandBuffer was created from must: support compute operations</usage>
            </validity>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdEndQuery</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
            <validity>
                <usage>The query identified by pname:queryPool and pname:query must: currently be &lt;&lt;queries-operation-active,active&gt;&gt;</usage>
                <usage>pname:query must: be less than the number of queries in pname:queryPool</usage>
            </validity>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdResetQueryPool</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
            <validity>
                <usage>pname:firstQuery must: be less than the number of queries in pname:queryPool</usage>
                <usage>The sum of pname:firstQuery and pname:queryCount must: be less than or equal to the number of queries in pname:queryPool</usage>
            </validity>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdWriteTimestamp</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineStageFlagBits</type> <name>pipelineStage</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
            <validity>
                <usage>The query identified by pname:queryPool and pname:query must: be _unavailable_</usage>
                <usage>The command pool's queue family must: support a non-zero pname:timestampValidBits</usage>
            </validity>
        </command>
        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdCopyQueryPoolResults</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>VkDeviceSize</type> <name>stride</name></param>
            <param optional="true"><type>VkQueryResultFlags</type> <name>flags</name></param>
            <validity>
                <usage>pname:dstOffset must: be less than the size of pname:dstBuffer</usage>
                <usage>pname:firstQuery must: be less than the number of queries in pname:queryPool</usage>
                <usage>The sum of pname:firstQuery and pname:queryCount must: be less than or equal to the number of queries in pname:queryPool</usage>
                <usage>If ename:VK_QUERY_RESULT_64_BIT is not set in pname:flags then pname:dstOffset and pname:stride must: be multiples of `4`</usage>
                <usage>If ename:VK_QUERY_RESULT_64_BIT is set in pname:flags then pname:dstOffset and pname:stride must: be multiples of `8`</usage>
                <usage>pname:dstBuffer must: have enough storage, from pname:dstOffset, to contain the result of each query, as described &lt;&lt;queries-operation-memorylayout,here&gt;&gt;</usage>
                <usage>pname:dstBuffer must: have been created with ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag</usage>
                <usage>If the pname:queryType used to create pname:queryPool was ename:VK_QUERY_TYPE_TIMESTAMP, pname:flags mustnot: contain ename:VK_QUERY_RESULT_PARTIAL_BIT</usage>
            </validity>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdPushConstants</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>VkShaderStageFlags</type> <name>stageFlags</name></param>
            <param><type>uint32_t</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>size</name></param>
            <param len="size">const <type>void</type>* <name>pValues</name></param>
            <validity>
                <usage>pname:stageFlags must: match exactly the shader stages used in pname:layout for the range specified by pname:offset and pname:size</usage>
                <usage>pname:offset must: be a multiple of `4`</usage>
                <usage>pname:size must: be a multiple of `4`</usage>
                <usage>pname:offset must: be less than sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize</usage>
                <usage>pname:size must: be less than or equal to sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize minus pname:offset</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary">
            <proto><type>void</type> <name>vkCmdBeginRenderPass</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkRenderPassBeginInfo</type>* <name>pRenderPassBegin</name></param>
            <param><type>VkSubpassContents</type> <name>contents</name></param>
            <validity>
                <usage>If any of the pname:initialLayout or pname:finalLayout member of the sname:VkAttachmentDescription structures or the pname:layout member of the sname:VkAttachmentReference structures specified when creating the render pass specified in the pname:renderPass member of pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then the corresponding attachment image of the framebuffer specified in the pname:framebuffer member of pname:pRenderPassBegin must: have been created with ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT set</usage>
                <usage>If any of the pname:initialLayout or pname:finalLayout member of the sname:VkAttachmentDescription structures or the pname:layout member of the sname:VkAttachmentReference structures specified when creating the render pass specified in the pname:renderPass member of pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image of the framebuffer specified in the pname:framebuffer member of pname:pRenderPassBegin must: have been created with ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set</usage>
                <usage>If any of the pname:initialLayout or pname:finalLayout member of the sname:VkAttachmentDescription structures or the pname:layout member of the sname:VkAttachmentReference structures specified when creating the render pass specified in the pname:renderPass member of pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then the corresponding attachment image of the framebuffer specified in the pname:framebuffer member of pname:pRenderPassBegin must: have been created with ename:VK_IMAGE_USAGE_SAMPLED_BIT or ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set</usage>
                <usage>If any of the pname:initialLayout or pname:finalLayout member of the sname:VkAttachmentDescription structures or the pname:layout member of the sname:VkAttachmentReference structures specified when creating the render pass specified in the pname:renderPass member of pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_BIT then the corresponding attachment image of the framebuffer specified in the pname:framebuffer member of pname:pRenderPassBegin must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT set</usage>
                <usage>If any of the pname:initialLayout or pname:finalLayout member of the sname:VkAttachmentDescription structures or the pname:layout member of the sname:VkAttachmentReference structures specified when creating the render pass specified in the pname:renderPass member of pname:pRenderPassBegin is ename:VK_IMAGE_LAYOUT_TRANSFER_DST_BIT then the corresponding attachment image of the framebuffer specified in the pname:framebuffer member of pname:pRenderPassBegin must: have been created with ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT set</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary">
            <proto><type>void</type> <name>vkCmdNextSubpass</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkSubpassContents</type> <name>contents</name></param>
            <validity>
              <usage>The current subpass index must: be less than the number of subpasses in the render pass minus one</usage>
            </validity>
        </command>
        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary">
            <proto><type>void</type> <name>vkCmdEndRenderPass</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <validity>
              <usage>The current subpass index must: be equal to the number of subpasses in the render pass minus one</usage>
            </validity>
        </command>
        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary">
            <proto><type>void</type> <name>vkCmdExecuteCommands</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>commandBufferCount</name></param>
            <param len="commandBufferCount">const <type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
            <validity>
                <usage>pname:commandBuffer must: have been created with a pname:level of ename:VK_COMMAND_BUFFER_LEVEL_PRIMARY</usage>
                <usage>Any given element of pname:pCommandBuffers must: have been created with a pname:level of ename:VK_COMMAND_BUFFER_LEVEL_SECONDARY</usage>
                <usage>Any given element of pname:pCommandBuffers mustnot: be already pending execution in pname:commandBuffer, or appear twice in pname:pCommandBuffers, unless it was created with the ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag</usage>
                <usage>Any given element of pname:pCommandBuffers mustnot: be already pending execution in any other sname:VkCommandBuffer, unless it was created with the ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag</usage>
                <usage>Any given element of pname:pCommandBuffers must: be in the executable state</usage>
                <usage>If fname:vkCmdExecuteCommands is being called within a render pass instance, that render pass instance must: have been begun with the pname:contents parameter of fname:vkCmdBeginRenderPass set to ename:VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS</usage>
                <usage>If fname:vkCmdExecuteCommands is being called within a render pass instance, any given element of pname:pCommandBuffers must: have been recorded with the ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</usage>
                <usage>If fname:vkCmdExecuteCommands is being called within a render pass instance, any given element of pname:pCommandBuffers must: have been recorded with the pname:subpass member of the pname:inheritanceInfo structure set to the index of the subpass which the given command buffer will be executed in</usage>
                <usage>If fname:vkCmdExecuteCommands is being called within a render pass instance, any given element of pname:pCommandBuffers must: have been recorded with a render pass that is compatible with the current render pass - see &lt;&lt;renderpass-compatibility&gt;&gt;</usage>
                <usage>If fname:vkCmdExecuteCommands is being called within a render pass instance, and any given element of pname:pCommandBuffers was recorded with the pname:framebuffer member of the sname:VkCommandBufferInheritanceInfo structure not equal to sname:VK_NULL_HANDLE, that sname:VkFramebuffer must: be compatible with the sname:VkFramebuffer used in the current render pass instance</usage>
                <usage>If the &lt;&lt;features-features-inheritedQueries,inherited queries&gt;&gt; feature is not enabled, pname:commandBuffer mustnot: have any queries &lt;&lt;queries-operation-active,active&gt;&gt;</usage>
                <usage>If pname:commandBuffer has a ename:VK_QUERY_TYPE_OCCLUSION query &lt;&lt;queries-operation-active,active&gt;&gt;, then each element of pname:pCommandBuffers must: have been recorded with sname:VkCommandBufferBeginInfo::pname:occlusionQueryEnable set to ename:VK_TRUE</usage>
                <usage>If pname:commandBuffer has a ename:VK_QUERY_TYPE_OCCLUSION query &lt;&lt;queries-operation-active,active&gt;&gt;, then each element of pname:pCommandBuffers must: have been recorded with sname:VkCommandBufferBeginInfo::pname:queryFlags having all bits set that are set for the query</usage>
                <usage>If pname:commandBuffer has a ename:VK_QUERY_TYPE_PIPELINE_STATISTICS query &lt;&lt;queries-operation-active,active&gt;&gt;, then each element of pname:pCommandBuffers must: have been recorded with sname:VkCommandBufferInheritanceInfo::pname:pipelineStatistics having all bits set that are set in the sname:VkQueryPool the query uses</usage>
                <usage>Any given element of pname:pCommandBuffers mustnot: begin any query types that are &lt;&lt;queries-operation-active,active&gt;&gt; in pname:commandBuffer</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
            <proto><type>VkResult</type> <name>vkCreateAndroidSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkAndroidSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayPropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayPlanePropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetDisplayPlaneSupportedDisplaysKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>planeIndex</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pDisplayCount</name></param>
            <param optional="true" len="pDisplayCount"><type>VkDisplayKHR</type>* <name>pDisplays</name></param>
            <validity>
                <usage>pname:planeIndex must: be less than the number of display planes supported by the device as determined by calling fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetDisplayModePropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayModePropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateDisplayModeKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param externsync="true"><type>VkDisplayKHR</type> <name>display</name></param>
            <param>const <type>VkDisplayModeCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDisplayModeKHR</type>* <name>pMode</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetDisplayPlaneCapabilitiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param externsync="true"><type>VkDisplayModeKHR</type> <name>mode</name></param>
            <param><type>uint32_t</type> <name>planeIndex</name></param>
            <param><type>VkDisplayPlaneCapabilitiesKHR</type>* <name>pCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateDisplayPlaneSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkDisplaySurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkCreateSharedSwapchainsKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>swapchainCount</name></param>
            <param len="swapchainCount" externsync="pCreateInfos[].surface,pCreateInfos[].oldSwapchain">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="swapchainCount"><type>VkSwapchainKHR</type>* <name>pSwapchains</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateMirSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkMirSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceMirPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>MirConnection</type>* <name>connection</name></param>
            <validity>
                <usage>pname:queueFamilyIndex must: be less than pname:pQueueFamilyPropertyCount returned by fname:vkGetPhysicalDeviceQueueFamilyProperties for the given pname:physicalDevice</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param optional="true" externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All sname:VkSwapchainKHR objects created for pname:surface must: have been destroyed prior to destroying pname:surface</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:surface was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:surface was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param><type>VkBool32</type>* <name>pSupported</name></param>
            <validity>
                <usage>pname:queueFamilyIndex must: be less than pname:pQueueFamilyPropertyCount returned by fname:vkGetPhysicalDeviceQueueFamilyProperties for the given pname:physicalDevice</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param><type>VkSurfaceCapabilitiesKHR</type>* <name>pSurfaceCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceFormatsKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSurfaceFormatCount</name></param>
            <param optional="true" len="pSurfaceFormatCount"><type>VkSurfaceFormatKHR</type>* <name>pSurfaceFormats</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfacePresentModesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPresentModeCount</name></param>
            <param optional="true" len="pPresentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
            <proto><type>VkResult</type> <name>vkCreateSwapchainKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pCreateInfo.surface,pCreateInfo.oldSwapchain">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSwapchainKHR</type>* <name>pSwapchain</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySwapchainKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
                <usage>All uses of presentable images acquired from pname:swapchain must: have completed execution</usage>
                <usage>If sname:VkAllocationCallbacks were provided when pname:swapchain was created, a compatible set of callbacks must: be provided here</usage>
                <usage>If no sname:VkAllocationCallbacks were provided when pname:swapchain was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkGetSwapchainImagesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSwapchainImageCount</name></param>
            <param optional="true" len="pSwapchainImageCount"><type>VkImage</type>* <name>pSwapchainImages</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkAcquireNextImageKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param><type>uint64_t</type> <name>timeout</name></param>
            <param optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
            <param><type>uint32_t</type>* <name>pImageIndex</name></param>
            <validity>
                <usage>If pname:semaphore is not sname:VK_NULL_HANDLE it must: be unsignaled</usage>
                <usage>If pname:fence is not sname:VK_NULL_HANDLE it must: be unsignaled and mustnot: be associated with any other queue command that has not yet completed execution on that queue</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR">
            <proto><type>VkResult</type> <name>vkQueuePresentKHR</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param externsync="pPresentInfo.pWaitSemaphores[],pPresentInfo.pSwapchains[]">const <type>VkPresentInfoKHR</type>* <name>pPresentInfo</name></param>
            <validity>
                <usage>Any given element of pname:pSwapchains member of pname:pPresentInfo must: be a swapchain that is created for a surface for which presentation is supported from pname:queue as determined using a call to fname:vkGetPhysicalDeviceSurfaceSupportKHR</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateWaylandSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkWaylandSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceWaylandPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param>struct <type>wl_display</type>* <name>display</name></param>
            <validity>
                <usage>pname:queueFamilyIndex must: be less than pname:pQueueFamilyPropertyCount returned by fname:vkGetPhysicalDeviceQueueFamilyProperties for the given pname:physicalDevice</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateWin32SurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkWin32SurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceWin32PresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <validity>
                <usage>pname:queueFamilyIndex must: be less than pname:pQueueFamilyPropertyCount returned by fname:vkGetPhysicalDeviceQueueFamilyProperties for the given pname:physicalDevice</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateXlibSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkXlibSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceXlibPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>Display</type>* <name>dpy</name></param>
            <param><type>VisualID</type> <name>visualID</name></param>
            <validity>
                <usage>pname:queueFamilyIndex must: be less than pname:pQueueFamilyPropertyCount returned by fname:vkGetPhysicalDeviceQueueFamilyProperties for the given pname:physicalDevice</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkCreateXcbSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkXcbSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceXcbPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>xcb_connection_t</type>* <name>connection</name></param>
            <param><type>xcb_visualid_t</type> <name>visual_id</name></param>
            <validity>
                <usage>pname:queueFamilyIndex must: be less than pname:pQueueFamilyPropertyCount returned by fname:vkGetPhysicalDeviceQueueFamilyProperties for the given pname:physicalDevice</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS">
            <proto><type>VkResult</type> <name>vkCreateDebugReportCallbackEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkDebugReportCallbackCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDebugReportCallbackEXT</type>* <name>pCallback</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDebugReportCallbackEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param externsync="true"><type>VkDebugReportCallbackEXT</type> <name>callback</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <validity>
               <usage>If sname:VkAllocationCallbacks were provided when pname:instance was created, a compatible set of callbacks must: be provided here</usage>
               <usage>If no sname:VkAllocationCallbacks were provided when pname:instance was created, pname:pAllocator must: be `NULL`</usage>
            </validity>
        </command>
        <command>
            <proto><type>void</type> <name>vkDebugReportMessageEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param><type>VkDebugReportFlagsEXT</type> <name>flags</name></param>
            <param><type>VkDebugReportObjectTypeEXT</type> <name>objectType</name></param>
            <param><type>uint64_t</type> <name>object</name></param>
            <param><type>size_t</type> <name>location</name></param>
            <param><type>int32_t</type> <name>messageCode</name></param>
            <param>const <type>char</type>* <name>pLayerPrefix</name></param>
            <param>const <type>char</type>* <name>pMessage</name></param>
            <validity>
               <usage>pname:instance must: be a valid sname:VkInstance handle</usage>
               <usage>pname:flags must: be a combination of one or more of sname:VkDebugReportFlagBitsEXT</usage>
               <usage>pname:objType must: be one of sname:VkDebugReportObjectTypeEXT, ename:VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT if pname:object is `NULL`</usage>
               <usage>pname:object may: be a Vulkan object</usage>
               <usage>pname:pLayerPrefix must: be a `NULL` terminated string.</usage>
               <usage>pname:pMsg must: be a `NULL` terminated string.</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkDebugMarkerSetObjectNameEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pNameInfo.object"><type>VkDebugMarkerObjectNameInfoEXT</type>* <name>pNameInfo</name></param>
            <validity>
               <usage>pname:pNameInfo.object must: be a Vulkan object</usage>
            </validity>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
            <proto><type>VkResult</type> <name>vkDebugMarkerSetObjectTagEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pTagInfo.object"><type>VkDebugMarkerObjectTagInfoEXT</type>* <name>pTagInfo</name></param>
            <validity>
               <usage>pname:pTagInfo.object must: be a Vulkan object</usage>
               <usage>pname:pTagInfo.tagName mustnot: be `0`</usage>
            </validity>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDebugMarkerBeginEXT</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkDebugMarkerMarkerInfoEXT</type>* <name>pMarkerInfo</name></param>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDebugMarkerEndEXT</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <validity>
              <usage>There must: be an outstanding flink:vkCmdDebugMarkerBeginEXT command prior to the fname:vkCmdDebugMarkerEndEXT on the queue that pname:commandBuffer is submitted to.</usage>
              <usage>If the matching flink:vkCmdDebugMarkerBeginEXT command was in a secondary command buffer, the fname:vkCmdDebugMarkerEndEXT must be in the same pname:commandBuffer.</usage>

            </validity>
        </command>
        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
            <proto><type>void</type> <name>vkCmdDebugMarkerInsertEXT</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkDebugMarkerMarkerInfoEXT</type>* <name>pMarkerInfo</name></param>
        </command>
    </commands>

    <!-- SECTION: Vulkan API interface definitions -->
    <feature api="vulkan" name="VK_VERSION_1_0" number="1.0">
        <require comment="Header boilerplate">
            <type name="vk_platform"/>
        </require>
        <require comment="API version">
            <type name="VK_API_VERSION"/>
            <type name="VK_API_VERSION_1_0"/>
            <type name="VK_VERSION_MAJOR"/>
            <type name="VK_VERSION_MINOR"/>
            <type name="VK_VERSION_PATCH"/>
            <type name="VK_HEADER_VERSION"/>
        </require>
        <require comment="API constants">
            <enum name="VK_LOD_CLAMP_NONE"/>
            <enum name="VK_REMAINING_MIP_LEVELS"/>
            <enum name="VK_REMAINING_ARRAY_LAYERS"/>
            <enum name="VK_WHOLE_SIZE"/>
            <enum name="VK_ATTACHMENT_UNUSED"/>
            <enum name="VK_TRUE"/>
            <enum name="VK_FALSE"/>
            <type name="VK_NULL_HANDLE"/>
            <enum name="VK_QUEUE_FAMILY_IGNORED"/>
            <enum name="VK_SUBPASS_EXTERNAL"/>
            <type name="VkPipelineCacheHeaderVersion"/>
        </require>
        <require comment="Device initialization">
            <command name="vkCreateInstance"/>
            <command name="vkDestroyInstance"/>
            <command name="vkEnumeratePhysicalDevices"/>
            <command name="vkGetPhysicalDeviceFeatures"/>
            <command name="vkGetPhysicalDeviceFormatProperties"/>
            <command name="vkGetPhysicalDeviceImageFormatProperties"/>
            <command name="vkGetPhysicalDeviceProperties"/>
            <command name="vkGetPhysicalDeviceQueueFamilyProperties"/>
            <command name="vkGetPhysicalDeviceMemoryProperties"/>
            <command name="vkGetInstanceProcAddr"/>
            <command name="vkGetDeviceProcAddr"/>
        </require>
        <require comment="Device commands">
            <command name="vkCreateDevice"/>
            <command name="vkDestroyDevice"/>
        </require>
        <require comment="Extension discovery commands">
            <command name="vkEnumerateInstanceExtensionProperties"/>
            <command name="vkEnumerateDeviceExtensionProperties"/>
        </require>
        <require comment="Layer discovery commands">
            <command name="vkEnumerateInstanceLayerProperties"/>
            <command name="vkEnumerateDeviceLayerProperties"/>
        </require>
        <require comment="queue commands">
            <command name="vkGetDeviceQueue"/>
            <command name="vkQueueSubmit"/>
            <command name="vkQueueWaitIdle"/>
            <command name="vkDeviceWaitIdle"/>
        </require>
        <require comment="Memory commands">
            <command name="vkAllocateMemory"/>
            <command name="vkFreeMemory"/>
            <command name="vkMapMemory"/>
            <command name="vkUnmapMemory"/>
            <command name="vkFlushMappedMemoryRanges"/>
            <command name="vkInvalidateMappedMemoryRanges"/>
            <command name="vkGetDeviceMemoryCommitment"/>
        </require>
        <require comment="Memory management API commands">
            <command name="vkBindBufferMemory"/>
            <command name="vkBindImageMemory"/>
            <command name="vkGetBufferMemoryRequirements"/>
            <command name="vkGetImageMemoryRequirements"/>
        </require>
        <require comment="Sparse resource memory management API commands">
            <command name="vkGetImageSparseMemoryRequirements"/>
            <command name="vkGetPhysicalDeviceSparseImageFormatProperties"/>
            <command name="vkQueueBindSparse"/>
        </require>
        <require comment="Fence commands">
            <command name="vkCreateFence"/>
            <command name="vkDestroyFence"/>
            <command name="vkResetFences"/>
            <command name="vkGetFenceStatus"/>
            <command name="vkWaitForFences"/>
        </require>
        <require comment="Queue semaphore commands">
            <command name="vkCreateSemaphore"/>
            <command name="vkDestroySemaphore"/>
        </require>
        <require comment="Event commands">
            <command name="vkCreateEvent"/>
            <command name="vkDestroyEvent"/>
            <command name="vkGetEventStatus"/>
            <command name="vkSetEvent"/>
            <command name="vkResetEvent"/>
        </require>
        <require comment="Query commands">
            <command name="vkCreateQueryPool"/>
            <command name="vkDestroyQueryPool"/>
            <command name="vkGetQueryPoolResults"/>
        </require>
        <require comment="Buffer commands">
            <command name="vkCreateBuffer"/>
            <command name="vkDestroyBuffer"/>
        </require>
        <require comment="Buffer view commands">
            <command name="vkCreateBufferView"/>
            <command name="vkDestroyBufferView"/>
        </require>
        <require comment="Image commands">
            <command name="vkCreateImage"/>
            <command name="vkDestroyImage"/>
            <command name="vkGetImageSubresourceLayout"/>
        </require>
        <require comment="Image view commands">
            <command name="vkCreateImageView"/>
            <command name="vkDestroyImageView"/>
        </require>
        <require comment="Shader commands">
            <command name="vkCreateShaderModule"/>
            <command name="vkDestroyShaderModule"/>
        </require>
        <require comment="Pipeline Cache commands">
            <command name="vkCreatePipelineCache"/>
            <command name="vkDestroyPipelineCache"/>
            <command name="vkGetPipelineCacheData"/>
            <command name="vkMergePipelineCaches"/>
        </require>

        <require comment="Pipeline commands">
            <command name="vkCreateGraphicsPipelines"/>
            <command name="vkCreateComputePipelines"/>
            <command name="vkDestroyPipeline"/>
        </require>
        <require comment="Pipeline layout commands">
            <command name="vkCreatePipelineLayout"/>
            <command name="vkDestroyPipelineLayout"/>
        </require>
        <require comment="Sampler commands">
            <command name="vkCreateSampler"/>
            <command name="vkDestroySampler"/>
        </require>
        <require comment="Descriptor set commands">
            <command name="vkCreateDescriptorSetLayout"/>
            <command name="vkDestroyDescriptorSetLayout"/>
            <command name="vkCreateDescriptorPool"/>
            <command name="vkDestroyDescriptorPool"/>
            <command name="vkResetDescriptorPool"/>
            <command name="vkAllocateDescriptorSets"/>
            <command name="vkFreeDescriptorSets"/>
            <command name="vkUpdateDescriptorSets"/>
        </require>
        <require comment="Pass commands">
            <command name="vkCreateFramebuffer"/>
            <command name="vkDestroyFramebuffer"/>
            <command name="vkCreateRenderPass"/>
            <command name="vkDestroyRenderPass"/>
            <command name="vkGetRenderAreaGranularity"/>
        </require>
        <require comment="Command pool commands">
            <command name="vkCreateCommandPool"/>
            <command name="vkDestroyCommandPool"/>
            <command name="vkResetCommandPool"/>
        </require>
        <require comment="Command buffer commands">
            <command name="vkAllocateCommandBuffers"/>
            <command name="vkFreeCommandBuffers"/>
            <command name="vkBeginCommandBuffer"/>
            <command name="vkEndCommandBuffer"/>
            <command name="vkResetCommandBuffer"/>
        </require>
        <require comment="Command buffer building commands">
            <command name="vkCmdBindPipeline"/>
            <command name="vkCmdSetViewport"/>
            <command name="vkCmdSetScissor"/>
            <command name="vkCmdSetLineWidth"/>
            <command name="vkCmdSetDepthBias"/>
            <command name="vkCmdSetBlendConstants"/>
            <command name="vkCmdSetDepthBounds"/>
            <command name="vkCmdSetStencilCompareMask"/>
            <command name="vkCmdSetStencilWriteMask"/>
            <command name="vkCmdSetStencilReference"/>
            <command name="vkCmdBindDescriptorSets"/>
            <command name="vkCmdBindIndexBuffer"/>
            <command name="vkCmdBindVertexBuffers"/>
            <command name="vkCmdDraw"/>
            <command name="vkCmdDrawIndexed"/>
            <command name="vkCmdDrawIndirect"/>
            <command name="vkCmdDrawIndexedIndirect"/>
            <command name="vkCmdDispatch"/>
            <command name="vkCmdDispatchIndirect"/>
            <command name="vkCmdCopyBuffer"/>
            <command name="vkCmdCopyImage"/>
            <command name="vkCmdBlitImage"/>
            <command name="vkCmdCopyBufferToImage"/>
            <command name="vkCmdCopyImageToBuffer"/>
            <command name="vkCmdUpdateBuffer"/>
            <command name="vkCmdFillBuffer"/>
            <command name="vkCmdClearColorImage"/>
            <command name="vkCmdClearDepthStencilImage"/>
            <command name="vkCmdClearAttachments"/>
            <command name="vkCmdResolveImage"/>
            <command name="vkCmdSetEvent"/>
            <command name="vkCmdResetEvent"/>
            <command name="vkCmdWaitEvents"/>
            <command name="vkCmdPipelineBarrier"/>
            <command name="vkCmdBeginQuery"/>
            <command name="vkCmdEndQuery"/>
            <command name="vkCmdResetQueryPool"/>
            <command name="vkCmdWriteTimestamp"/>
            <command name="vkCmdCopyQueryPoolResults"/>
            <command name="vkCmdPushConstants"/>
            <command name="vkCmdBeginRenderPass"/>
            <command name="vkCmdNextSubpass"/>
            <command name="vkCmdEndRenderPass"/>
            <command name="vkCmdExecuteCommands"/>
        </require>
        <require comment="Types not directly used by the API">
            <!-- Include <type name="typename"/> here for e.g. structs that
                 are not parameter types of commands, but still need to be
                 defined in the API.
             -->
            <type name="VkBufferMemoryBarrier"/>
            <type name="VkDispatchIndirectCommand"/>
            <type name="VkDrawIndexedIndirectCommand"/>
            <type name="VkDrawIndirectCommand"/>
            <type name="VkImageMemoryBarrier"/>
            <type name="VkMemoryBarrier"/>
        </require>
    </feature>

    <!-- SECTION: Vulkan extension interface definitions (none yet) -->
    <extensions>
            <!-- WSI extensions -->
        <extension name="VK_KHR_surface" number="1" supported="vulkan">
            <require>
                <enum value="25"                                        name="VK_KHR_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_surface&quot;"                name="VK_KHR_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" dir="-" extends="VkResult"             name="VK_ERROR_SURFACE_LOST_KHR"/>
                <enum offset="1" dir="-" extends="VkResult"             name="VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"/>
                <enum value="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"         name="VK_COLORSPACE_SRGB_NONLINEAR_KHR"/>
                <command name="vkDestroySurfaceKHR"/>
                <command name="vkGetPhysicalDeviceSurfaceSupportKHR"/>
                <command name="vkGetPhysicalDeviceSurfaceCapabilitiesKHR"/>
                <command name="vkGetPhysicalDeviceSurfaceFormatsKHR"/>
                <command name="vkGetPhysicalDeviceSurfacePresentModesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_swapchain" number="2" supported="vulkan">
            <require>
                <enum value="68"                                        name="VK_KHR_SWAPCHAIN_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_swapchain&quot;"              name="VK_KHR_SWAPCHAIN_EXTENSION_NAME"/>
                <enum offset="0"         extends="VkStructureType"      name="VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"/>
                <enum offset="1"         extends="VkStructureType"      name="VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"/>
                <enum offset="2"         extends="VkImageLayout"        name="VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"/>
                <enum offset="3"         extends="VkResult"             name="VK_SUBOPTIMAL_KHR"/>
                <enum offset="4" dir="-" extends="VkResult"             name="VK_ERROR_OUT_OF_DATE_KHR"/>
                <command name="vkCreateSwapchainKHR"/>
                <command name="vkDestroySwapchainKHR"/>
                <command name="vkGetSwapchainImagesKHR"/>
                <command name="vkAcquireNextImageKHR"/>
                <command name="vkQueuePresentKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_display" number="3" supported="vulkan">
            <require>
                <enum value="21"                                        name="VK_KHR_DISPLAY_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_display&quot;"                name="VK_KHR_DISPLAY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkDisplayPlaneAlphaFlagsKHR"/>
                <type name="VkDisplayPlaneAlphaFlagBitsKHR"/>
                <type name="VkDisplayPropertiesKHR"/>
                <type name="VkDisplayModeParametersKHR"/>
                <type name="VkDisplayModePropertiesKHR"/>
                <type name="VkDisplayModeCreateInfoKHR"/>
                <type name="VkDisplayPlaneCapabilitiesKHR"/>
                <type name="VkDisplayPlanePropertiesKHR"/>
                <type name="VkDisplaySurfaceCreateInfoKHR"/>
                <command name="vkGetPhysicalDeviceDisplayPropertiesKHR"/>
                <command name="vkGetPhysicalDeviceDisplayPlanePropertiesKHR"/>
                <command name="vkGetDisplayPlaneSupportedDisplaysKHR"/>
                <command name="vkGetDisplayModePropertiesKHR"/>
                <command name="vkCreateDisplayModeKHR"/>
                <command name="vkGetDisplayPlaneCapabilitiesKHR"/>
                <command name="vkCreateDisplayPlaneSurfaceKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_display_swapchain" number="4" supported="vulkan">
            <require>
                <enum value="9"                                         name="VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_display_swapchain&quot;"      name="VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"/>
                <enum offset="1" dir="-" extends="VkResult"             name="VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"/>
                <type name="VkDisplayPresentInfoKHR"/>
                <command name="vkCreateSharedSwapchainsKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_xlib_surface" number="5" protect="VK_USE_PLATFORM_XLIB_KHR" supported="vulkan">
            <require>
                <enum value="6"                                         name="VK_KHR_XLIB_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_xlib_surface&quot;"           name="VK_KHR_XLIB_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkXlibSurfaceCreateFlagsKHR"/>
                <type name="VkXlibSurfaceCreateInfoKHR"/>
                <command name="vkCreateXlibSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceXlibPresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_xcb_surface" number="6" protect="VK_USE_PLATFORM_XCB_KHR" supported="vulkan">
            <require>
                <enum value="6"                                         name="VK_KHR_XCB_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_xcb_surface&quot;"            name="VK_KHR_XCB_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkXcbSurfaceCreateFlagsKHR"/>
                <type name="VkXcbSurfaceCreateInfoKHR"/>
                <command name="vkCreateXcbSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceXcbPresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_wayland_surface" number="7" protect="VK_USE_PLATFORM_WAYLAND_KHR" supported="vulkan">
            <require>
                <enum value="5"                                         name="VK_KHR_WAYLAND_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_wayland_surface&quot;"        name="VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkWaylandSurfaceCreateFlagsKHR"/>
                <type name="VkWaylandSurfaceCreateInfoKHR"/>
                <command name="vkCreateWaylandSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceWaylandPresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_mir_surface" number="8" protect="VK_USE_PLATFORM_MIR_KHR" supported="vulkan">
            <require>
                <enum value="4"                                         name="VK_KHR_MIR_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_mir_surface&quot;"            name="VK_KHR_MIR_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkMirSurfaceCreateFlagsKHR"/>
                <type name="VkMirSurfaceCreateInfoKHR"/>
                <command name="vkCreateMirSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceMirPresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_android_surface" number="9" protect="VK_USE_PLATFORM_ANDROID_KHR" supported="vulkan">
            <require>
                <enum value="6"                                         name="VK_KHR_ANDROID_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_android_surface&quot;"        name="VK_KHR_ANDROID_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkAndroidSurfaceCreateFlagsKHR"/>
                <type name="VkAndroidSurfaceCreateInfoKHR"/>
                <command name="vkCreateAndroidSurfaceKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_win32_surface" number="10" protect="VK_USE_PLATFORM_WIN32_KHR" supported="vulkan">
            <require>
                <enum value="5"                                         name="VK_KHR_WIN32_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_win32_surface&quot;"          name="VK_KHR_WIN32_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkWin32SurfaceCreateFlagsKHR"/>
                <type name="VkWin32SurfaceCreateInfoKHR"/>
                <command name="vkCreateWin32SurfaceKHR"/>
                <command name="vkGetPhysicalDeviceWin32PresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_ANDROID_native_buffer" number="11" supported="disabled">
            <require>
                <enum value="4"                                         name="VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION"/>
                <enum value="11"                                        name="VK_ANDROID_NATIVE_BUFFER_NUMBER"/>
                <enum value="&quot;VK_ANDROID_native_buffer&quot;"      name="VK_ANDROID_NATIVE_BUFFER_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_debug_report" number="12" author="Google, Inc." contact="Courtney Goeltzenleuchter @courtney" supported="vulkan">
            <require>
                <enum value="2"                                         name="VK_EXT_DEBUG_REPORT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_debug_report&quot;"           name="VK_EXT_DEBUG_REPORT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"/>
                <enum offset="1" dir="-" extends="VkResult"             name="VK_ERROR_VALIDATION_FAILED_EXT"/>
                <enum value="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT" name="VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT"/>
                <type name="VkDebugReportObjectTypeEXT"/>
                <type name="VkDebugReportErrorEXT"/>
                <command name="vkCreateDebugReportCallbackEXT"/>
                <command name="vkDestroyDebugReportCallbackEXT"/>
                <command name="vkDebugReportMessageEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_glsl_shader" number="13" author="NVIDIA" contact="Piers Daniell @pdaniell" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_GLSL_SHADER_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_glsl_shader&quot;"             name="VK_NV_GLSL_SHADER_EXTENSION_NAME"/>
                <enum offset="0" dir="-" extends="VkResult"             name="VK_ERROR_INVALID_SHADER_NV"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_1" number="14" author="NVIDIA" contact="Piers Daniell @pdaniell" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NV_EXTENSION_1_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_1&quot;"             name="VK_NV_EXTENSION_1_EXTENSION_NAME"/>
                <enum offset="0" dir="-" extends="VkResult"             name="VK_NV_EXTENSION_1_ERROR"/>
            </require>
        </extension>
        <extension name="VK_KHR_sampler_mirror_clamp_to_edge" number="15" author="KHR" contact="Tobias Hector @tobias" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_sampler_mirror_clamp_to_edge&quot;"             name="VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME"/>
                <enum value="4" extends="VkSamplerAddressMode"          name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" comment="Note that this defines what was previously a core enum, and so uses the 'value' attribute rather than 'offset', and doesn't have a suffix. This is a special case, and should not be repeated"/>
            </require>
        </extension>
        <extension name="VK_IMG_filter_cubic" number="16" author="IMG" contact="Tobias Hector @tobias" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_IMG_FILTER_CUBIC_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_filter_cubic&quot;"           name="VK_IMG_FILTER_CUBIC_EXTENSION_NAME"/>
                <enum offset="0" extends="VkFilter"                     name="VK_FILTER_CUBIC_IMG"/>
                <enum bitpos="13" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG" comment="Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled"/>
                <usage command="vkCmdDraw">Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a result of this command must: be of a format which supports cubic filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage command="vkCmdDraw">Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a result of this command mustnot: have an elink:VkImageViewType of ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</usage>
                <usage command="vkCmdDrawIndexed">Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a result of this command must: be of a format which supports cubic filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage command="vkCmdDrawIndexed">Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a result of this command mustnot: have an elink:VkImageViewType of ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</usage>
                <usage command="vkCmdDrawIndirect">Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a result of this command must: be of a format which supports cubic filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage command="vkCmdDrawIndirect">Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a result of this command mustnot: have an elink:VkImageViewType of ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</usage>
                <usage command="vkCmdDrawIndexedIndirect">Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a result of this command must: be of a format which supports cubic filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage command="vkCmdDrawIndexedIndirect">Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a result of this command mustnot: have an elink:VkImageViewType of ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</usage>
                <usage command="vkCmdDispatch">Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a result of this command must: be of a format which supports cubic filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage command="vkCmdDispatch">Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a result of this command mustnot: have an elink:VkImageViewType of ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</usage>
                <usage command="vkCmdDispatchIndirect">Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a result of this command must: be of a format which supports cubic filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage command="vkCmdDispatchIndirect">Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a result of this command mustnot: have an elink:VkImageViewType of ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</usage>
                <usage command="vkCmdBlitImage">If pname:filter is ename:VK_FILTER_CUBIC_IMG, pname:srcImage must: be of a format which supports cubic filtering, as specified by the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in sname:VkFormatProperties::pname:linearTilingFeatures (for a linear image) or sname:VkFormatProperties::pname:optimalTilingFeatures(for an optimally tiled image) returned by fname:vkGetPhysicalDeviceFormatProperties</usage>
                <usage struct="VkSamplerCreateInfo">If either pname:magFilter or pname:minFilter is ename:VK_FILTER_CUBIC_IMG, pname:anisotropyEnable must: be ename:VK_FALSE</usage>
            </require>
        </extension>
        <extension name="VK_AMD_extension_1" number="17" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_1_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_1&quot;"            name="VK_AMD_EXTENSION_1_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_2" number="18" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_2_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_2&quot;"            name="VK_AMD_EXTENSION_2_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_rasterization_order" number="19" author="AMD" contact="Daniel Rakos @aqnuep" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_rasterization_order&quot;"    name="VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"/>
                <type name="VkRasterizationOrderAMD"/>
                <type name="VkPipelineRasterizationStateRasterizationOrderAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_4" number="20" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_4_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_4&quot;"            name="VK_AMD_EXTENSION_4_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_5" number="21" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_5_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_5&quot;"            name="VK_AMD_EXTENSION_5_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_6" number="22" author="AMD" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_6_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_6&quot;"            name="VK_AMD_EXTENSION_6_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_debug_marker" number="23" author="Baldur Karlsson" contact="baldurk@baldurk.org" supported="vulkan">
            <require>
                <enum value="3"                                         name="VK_EXT_DEBUG_MARKER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_debug_marker&quot;"           name="VK_EXT_DEBUG_MARKER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"/>
                <type name="VkDebugMarkerObjectNameInfoEXT"/>
                <type name="VkDebugMarkerObjectTagInfoEXT"/>
                <type name="VkDebugMarkerMarkerInfoEXT"/>
                <command name="vkDebugMarkerSetObjectTagEXT"/>
                <command name="vkDebugMarkerSetObjectNameEXT"/>
                <command name="vkCmdDebugMarkerBeginEXT"/>
                <command name="vkCmdDebugMarkerEndEXT"/>
                <command name="vkCmdDebugMarkerInsertEXT"/>
            </require>
        </extension>
    </extensions>
</registry>
