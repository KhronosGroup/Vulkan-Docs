// Copyright 2015-2024 The Khronos Group Inc.
//
// SPDX-License-Identifier: CC-BY-4.0

[[pipelines]]
= Pipelines

The following <<pipelines-block-diagram,figure>> shows a block diagram of
the Vulkan pipelines.
Some Vulkan commands specify geometric objects to be drawn or computational
work to be performed, while others specify state controlling how objects are
handled by the various pipeline stages, or control data transfer between
memory organized as images and buffers.
Commands are effectively sent through a processing pipeline, either a
_graphics pipeline_,
ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
a _ray tracing pipeline_,
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
or a _compute pipeline_.

ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
The graphics pipeline can be operated in two modes, as either _primitive
shading_ or _mesh shading_ pipeline.

*Primitive Shading*

endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]

The first stage of the <<pipelines-graphics,graphics pipeline>>
(<<drawing,Input Assembler>>) assembles vertices to form geometric
primitives such as points, lines, and triangles, based on a requested
primitive topology.
In the next stage (<<shaders-vertex,Vertex Shader>>) vertices can: be
transformed, computing positions and attributes for each vertex.
If <<tessellation,tessellation>> and/or <<geometry,geometry>> shaders are
supported, they can: then generate multiple primitives from a single input
primitive, possibly changing the primitive topology or generating additional
attribute data in the process.

ifdef::VK_HUAWEI_cluster_culling_shader[]
*Cluster Culling Shading*

When using the Cluster Culling Shader, a compute-like shader will perform
cluster-based culling, a set of new built-in output variables are used to
express visible cluster, in addition, a new built-in function is used to
emit these variables from the cluster culling shader to the Input
Assembler(IA) stage, then IA can use these variables to fetches vertices of
visible cluster and drive vertex shader to work.

endif::VK_HUAWEI_cluster_culling_shader[]

ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
*Mesh Shading*

When using the <<mesh,_mesh shading_>> pipeline input primitives are not
assembled implicitly, but explicitly through the (<<shaders-mesh,Mesh
Shader>>).
The work on the mesh pipeline is initiated by the application
<<drawing-mesh-shading,drawing>> a set of mesh tasks.

If an optional (<<shaders-task,Task Shader>>) is active, each task triggers
the execution of a task shader workgroup that will generate a new set of
tasks upon completion.
Each of these spawned tasks, or each of the original dispatched tasks if no
task shader is present, triggers the execution of a mesh shader workgroup
that produces an output mesh with a variable-sized number of primitives
assembled from vertices stored in the output mesh.

*Common*
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]

The final resulting primitives are <<vertexpostproc-clipping,clipped>> to a
clip volume in preparation for the next stage, <<primsrast,Rasterization>>.
The rasterizer produces a series of _fragments_ associated with a region of
the framebuffer, from a two-dimensional description of a point, line
segment, or triangle.
These fragments are processed by <<fragops,fragment operations>> to
determine whether generated values will be written to the framebuffer.
<<fragops-shader, Fragment shading>> determines the values to be written to
the framebuffer attachments.
Framebuffer operations then read and write the color and depth/stencil
attachments of the framebuffer for a given subpass of a <<renderpass,render
pass instance>>.
The attachments can: be used as input attachments in the fragment shader in
a later subpass of the same render pass.

The <<pipelines-compute,compute pipeline>> is a separate pipeline from the
graphics pipeline, which operates on one-, two-, or three-dimensional
workgroups which can: read from and write to buffer and image memory.

This ordering is meant only as a tool for describing Vulkan, not as a strict
rule of how Vulkan is implemented, and we present it only as a means to
organize the various operations of the pipelines.
Actual ordering guarantees between pipeline stages are explained in detail
in the <<synchronization-pipeline-stages-order, synchronization chapter>>.

[[pipelines-block-diagram]]
ifndef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
image::{images}/pipeline.svg[title="Block diagram of the Vulkan pipeline",align="center",opts="{imageopts}"]
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
image::{images}/pipelinemesh.svg[title="Block diagram of the Vulkan pipeline",align="center",opts="{imageopts}"]
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]

Each pipeline is controlled by a monolithic object created from a
description of all of the shader stages and any relevant fixed-function
stages.
<<interfaces,Linking>> the whole pipeline together allows the optimization
of shaders based on their input/outputs and eliminates expensive draw time
state validation.

A pipeline object is bound to the current state using
flink:vkCmdBindPipeline.
Any pipeline object state that is specified as <<pipelines-dynamic-state,
dynamic>> is not applied to the current state when the pipeline object is
bound, but is instead set by dynamic state setting commands.

ifdef::VK_NV_command_buffer_inheritance[]
If the <<features-commandBufferInheritance,pname:commandBufferInheritance>>
feature is not enabled, then no
endif::VK_NV_command_buffer_inheritance[]
ifndef::VK_NV_command_buffer_inheritance[]
No
endif::VK_NV_command_buffer_inheritance[]
state, including dynamic state, is inherited from one command buffer to
another.

ifdef::VK_NV_command_buffer_inheritance[]
If the <<features-commandBufferInheritance,pname:commandBufferInheritance>>
feature is enabled, then all graphics and compute state that is valid at the
end of the command buffer executed in a queue is inherited and valid at
beginning of the command buffer next executed in the same queue.
This applies to both primary and secondary command buffers, where a primary
command buffer submitted to a queue will inherit state from the previously
submitted command buffer to that queue, secondary command buffers will
inherit state from the primary or seconard command buffer they are executed
in, and after a seconard command buffer is executed, its state inherited by
the primary or secondary command buffer that executed it.
Command buffers executed in one queue do not inherit state from any command
buffers executed in another queue.
endif::VK_NV_command_buffer_inheritance[]

[open,refpage='VkPipeline',desc='Opaque handle to a pipeline object',type='handles']
--
Compute,
ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
ray tracing,
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
and graphics pipelines are each represented by sname:VkPipeline handles:

include::{generated}/api/handles/VkPipeline.adoc[]
--


[[pipelines-multiple]]
== Multiple Pipeline Creation

Multiple pipelines can: be created in a single call by commands such as
ifdef::VK_AMDX_shader_enqueue[flink:vkCreateExecutionGraphPipelinesAMDX,]
ifdef::VK_KHR_ray_tracing_pipeline[flink:vkCreateRayTracingPipelinesKHR,]
ifdef::VK_NV_ray_tracing[flink:vkCreateRayTracingPipelinesNV,]
flink:vkCreateComputePipelines, and flink:vkCreateGraphicsPipelines.

The creation commands are passed an array pname:pCreateInfos of
stext:Vk*PipelineCreateInfo structures specifying parameters of each
pipeline to be created, and return a corresponding array of handles in
pname:pPipelines.
Each element index _i_ of pname:pPipelines is created based on the
corresponding element _i_ of pname:pCreateInfos.

Applications can: group together similar pipelines to be created in a single
call, and implementations are encouraged to look for reuse opportunities
when creating a group.

When attempting to create many pipelines in a single command, it is possible
that creation may: fail for a subset of them.
In this case, the corresponding elements of pname:pPipelines will be set to
dlink:VK_NULL_HANDLE.
If creation fails for a pipeline despite valid arguments (for example, due
to out of memory errors), the elink:VkResult code returned by the pipeline
creation command will indicate why.
The implementation will attempt to create all pipelines, and only return
dlink:VK_NULL_HANDLE values for those that actually failed.

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
If creation fails for a pipeline that has the
ename:VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT set in its
stext:Vk*PipelineCreateInfo, pipelines at an index in the pname:pPipelines
array greater than or equal to that of the failing pipeline will be set to
dlink:VK_NULL_HANDLE.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]

If creation fails for multiple pipelines, the returned elink:VkResult must:
be the return value of any one of the pipelines which did not succeed.
An application can: reliably clean up from a failed call by iterating over
the pname:pPipelines array and destroying every element that is not
dlink:VK_NULL_HANDLE.

If the entire command fails and no pipelines are created, all elements of
pname:pPipelines will be set to dlink:VK_NULL_HANDLE.


[[pipelines-compute]]
== Compute Pipelines

Compute pipelines consist of a single static compute shader stage and the
pipeline layout.

The compute pipeline represents a compute shader and is created by calling
fname:vkCreateComputePipelines
ifndef::VKSC_VERSION_1_0[]
with pname:module and pname:pName selecting an entry point from a shader
module, where that entry point defines a valid compute shader, in the
slink:VkPipelineShaderStageCreateInfo structure contained within the
slink:VkComputePipelineCreateInfo structure.
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
with an offline compiled pipeline provided in pname:pipelineCache and the
pipeline identified by slink:VkPipelineOfflineCreateInfo structure in the
pname:pNext chain of slink:VkComputePipelineCreateInfo structure.
endif::VKSC_VERSION_1_0[]


[open,refpage='vkCreateComputePipelines',desc='Creates a new compute pipeline object',type='protos']
--
:refpage: vkCreateComputePipelines
:objectnameplural: compute pipelines
:objectnamecamelcase: computePipeline
:objectnamestruct: VkDeviceObjectReservationCreateInfo
:objectcount: pname:createInfoCount

To create compute pipelines, call:

include::{generated}/api/protos/vkCreateComputePipelines.adoc[]

  * pname:device is the logical device that creates the compute pipelines.
ifndef::VKSC_VERSION_1_0[]
  * pname:pipelineCache is either dlink:VK_NULL_HANDLE, indicating that
    pipeline caching is disabled; or the handle of a valid
    <<pipelines-cache,pipeline cache>> object, in which case use of that
    cache is enabled for the duration of the command.
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
  * pname:pipelineCache is the handle of a valid <<pipelines-cache,pipeline
    cache>> object.
endif::VKSC_VERSION_1_0[]
  * pname:createInfoCount is the length of the pname:pCreateInfos and
    pname:pPipelines arrays.
  * pname:pCreateInfos is a pointer to an array of
    slink:VkComputePipelineCreateInfo structures.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pPipelines is a pointer to an array of slink:VkPipeline handles in
    which the resulting compute pipeline objects are returned.

Pipelines are created and returned as described for <<pipelines-multiple,
Multiple Pipeline Creation>>.

ifdef::VKSC_VERSION_1_0[]
If a pipeline creation fails due to:

  * The identified pipeline not being present in pname:pipelineCache
  * The pname:pNext chain not including a slink:VkPipelineOfflineCreateInfo
    structure

the operation will continue as specified in <<pipelines-multiple, Multiple
Pipeline Creation>> and the command will return
ename:VK_ERROR_NO_PIPELINE_MATCH.
ifdef::hidden[]
// tag::scdeviation[]
  * flink:vkCreateComputePipelines returns ename:VK_ERROR_NO_PIPELINE_MATCH
    if the slink:VkComputePipelineCreateInfo::pname:pNext chain does not
    include a valid slink:VkPipelineOfflineCreateInfo structure <<SCID-1>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkCreateComputePipelines-device-09661]]
    pname:device must: support at least one queue family with the
    ename:VK_QUEUE_COMPUTE_BIT capability
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkCreateComputePipelines-flags-00695]]
    If the pname:flags member of any element of pname:pCreateInfos contains
    the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the
    pname:basePipelineIndex member of that same element is not `-1`,
    pname:basePipelineIndex must: be less than the index into
    pname:pCreateInfos that corresponds to that element
  * [[VUID-vkCreateComputePipelines-flags-00696]]
    If the pname:flags member of any element of pname:pCreateInfos contains
    the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline
    must: have been created with the
    ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set
endif::VKSC_VERSION_1_0[]
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * [[VUID-vkCreateComputePipelines-pipelineCache-02873]]
    If pname:pipelineCache was created with
    ename:VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT, host access
    to pname:pipelineCache must: be
    <<fundamentals-threadingbehavior,externally synchronized>>
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
include::{chapters}/commonvalidity/memory_reservation_request_count_common.adoc[]
include::{chapters}/commonvalidity/pipeline_create_common.adoc[]
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
  * flink:vkCreateComputePipelines::pname:pipelineCache must: not be
    dlink:VK_NULL_HANDLE <<SCID-1>>, <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/protos/vkCreateComputePipelines.adoc[]
--

[open,refpage='VkComputePipelineCreateInfo',desc='Structure specifying parameters of a newly created compute pipeline',type='structs']
--
:refpage: VkComputePipelineCreateInfo

The sname:VkComputePipelineCreateInfo structure is defined as:

include::{generated}/api/structs/VkComputePipelineCreateInfo.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkPipelineCreateFlagBits specifying
    how the pipeline will be generated.
  * pname:stage is a slink:VkPipelineShaderStageCreateInfo structure
    describing the compute shader.
  * pname:layout is the description of binding locations used by both the
    pipeline and descriptor sets used with the pipeline.
  * pname:basePipelineHandle is a pipeline to derive from.
ifdef::VKSC_VERSION_1_0[]
    This is not used in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]
  * pname:basePipelineIndex is an index into the pname:pCreateInfos
    parameter to use as a pipeline to derive from.
ifdef::VKSC_VERSION_1_0[]
    This is not used in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]

The parameters pname:basePipelineHandle and pname:basePipelineIndex are
described in more detail in <<pipelines-pipeline-derivatives,Pipeline
Derivatives>>.

ifdef::VK_KHR_maintenance5[]
If the pname:pNext chain includes a
slink:VkPipelineCreateFlags2CreateInfoKHR structure,
slink:VkPipelineCreateFlags2CreateInfoKHR::pname:flags from that structure
is used instead of pname:flags from this structure.
endif::VK_KHR_maintenance5[]

.Valid Usage
****
:pipelineType: compute
include::{chapters}/commonvalidity/pipeline_create_info_common.adoc[]
include::{chapters}/commonvalidity/compute_graph_pipeline_create_info_common.adoc[]
  * [[VUID-VkComputePipelineCreateInfo-stage-00701]]
    The pname:stage member of pname:stage must: be
    ename:VK_SHADER_STAGE_COMPUTE_BIT
  * [[VUID-VkComputePipelineCreateInfo-stage-00702]]
    The shader code for the entry point identified by pname:stage and the
    rest of the state identified by this structure must: adhere to the
    pipeline linking rules described in the <<interfaces,Shader Interfaces>>
    chapter
  * [[VUID-VkComputePipelineCreateInfo-layout-01687]]
    The number of resources in pname:layout accessible to the compute shader
    stage must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxPerStageResources
ifdef::VK_KHR_pipeline_library[]
  * [[VUID-VkComputePipelineCreateInfo-shaderEnqueue-09177]]
ifdef::VK_AMDX_shader_enqueue[]
    If <<features-shaderEnqueue,pname:shaderEnqueue>> is not enabled,
endif::VK_AMDX_shader_enqueue[]
    pname:flags must: not include ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
ifdef::VK_AMDX_shader_enqueue[]
  * [[VUID-VkComputePipelineCreateInfo-flags-09178]]
    If pname:flags does not include
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, the shader specified by
    pname:stage must: not declare the code:ShaderEnqueueAMDX capability
endif::VK_AMDX_shader_enqueue[]
endif::VK_KHR_pipeline_library[]
ifdef::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
  * [[VUID-VkComputePipelineCreateInfo-pipelineStageCreationFeedbackCount-06566]]
    If
    slink:VkPipelineCreationFeedbackCreateInfo::pname:pipelineStageCreationFeedbackCount
    is not `0`, it must: be `1`
endif::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
ifdef::VK_EXT_opacity_micromap[]
  * [[VUID-VkComputePipelineCreateInfo-flags-07367]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT
endif::VK_EXT_opacity_micromap[]
ifdef::VK_NV_displacement_micromap[]
  * [[VUID-VkComputePipelineCreateInfo-flags-07996]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV
endif::VK_NV_displacement_micromap[]
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkComputePipelineCreateInfo::pname:basePipelineHandle must: be
    dlink:VK_NULL_HANDLE <<SCID-8>>.
  * slink:VkComputePipelineCreateInfo::pname:basePipelineIndex must: be zero
    <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/structs/VkComputePipelineCreateInfo.adoc[]
--

[open,refpage='VkPipelineShaderStageCreateInfo',desc='Structure specifying parameters of a newly created pipeline shader stage',type='structs']
--
The sname:VkPipelineShaderStageCreateInfo structure is defined as:

include::{generated}/api/structs/VkPipelineShaderStageCreateInfo.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkPipelineShaderStageCreateFlagBits
    specifying how the pipeline shader stage will be generated.
  * pname:stage is a elink:VkShaderStageFlagBits value specifying a single
    pipeline stage.
ifdef::VK_EXT_graphics_pipeline_library,VK_EXT_shader_module_identifier,VK_KHR_maintenance5[]
  * pname:module is optionally a slink:VkShaderModule object containing the
    shader code for this stage.
endif::VK_EXT_graphics_pipeline_library,VK_EXT_shader_module_identifier,VK_KHR_maintenance5[]
ifndef::VK_EXT_graphics_pipeline_library,VK_EXT_shader_module_identifier,VK_KHR_maintenance5[]
  * pname:module is a slink:VkShaderModule object containing the shader code
    for this stage.
endif::VK_EXT_graphics_pipeline_library,VK_EXT_shader_module_identifier,VK_KHR_maintenance5[]
ifdef::VKSC_VERSION_1_0[]
    This is not used in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]
  * pname:pName is a pointer to a null-terminated UTF-8 string specifying
    the entry point name of the shader for this stage.
  * pname:pSpecializationInfo is a pointer to a slink:VkSpecializationInfo
    structure, as described in
    <<pipelines-specialization-constants,Specialization Constants>>, or
    `NULL`.

ifdef::VKSC_VERSION_1_0[]
In Vulkan SC, the pipeline compilation process occurs
<<pipelines-offline-compilation,offline>>.
Accordingly, pname:module must: be dlink:VK_NULL_HANDLE, and the pname:pName
and pname:pSpecializationInfo parameters are not used at runtime and should:
be ignored by the implementation.
If provided, the application must: set the pname:pName and
pname:pSpecializationInfo parameters to the values that were specified for
the offline compilation of this pipeline.
endif::VKSC_VERSION_1_0[]

ifndef::VKSC_VERSION_1_0[]
ifdef::VK_EXT_graphics_pipeline_library,VK_KHR_maintenance5[]
If pname:module is not dlink:VK_NULL_HANDLE, the shader code used by the
pipeline is defined by pname:module.
If pname:module is dlink:VK_NULL_HANDLE, the shader code is defined by the
chained slink:VkShaderModuleCreateInfo if present.
endif::VK_EXT_graphics_pipeline_library,VK_KHR_maintenance5[]
ifndef::VK_EXT_graphics_pipeline_library,VK_KHR_maintenance5[]
The shader code used by the pipeline is defined by pname:module.
endif::VK_EXT_graphics_pipeline_library,VK_KHR_maintenance5[]
endif::VKSC_VERSION_1_0[]

ifdef::VK_EXT_shader_module_identifier[]
If the <<features-shaderModuleIdentifier, pname:shaderModuleIdentifier>>
feature is enabled, applications can: omit shader code for pname:stage and
instead provide a module identifier.
This is done by including a
slink:VkPipelineShaderStageModuleIdentifierCreateInfoEXT struct with
pname:identifierSize not equal to 0 in the pname:pNext chain.
A shader stage created in this way is equivalent to one created using a
shader module with the same identifier.
The identifier allows an implementation to look up a pipeline without
consuming a valid SPIR-V module.
If a pipeline is not found, pipeline compilation is not possible and the
implementation must: fail as specified by
ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT.

When an identifier is used in lieu of a shader module, implementations may:
fail pipeline compilation with ename:VK_PIPELINE_COMPILE_REQUIRED for any
reason.

[NOTE]
====
The rationale for the relaxed requirement on implementations to return a
pipeline with slink:VkPipelineShaderStageModuleIdentifierCreateInfoEXT is
that layers or tools may intercept pipeline creation calls and require the
full SPIR-V context to operate correctly.
ICDs are not expected to fail pipeline compilation if the pipeline exists in
a cache somewhere.
====

ifdef::VK_KHR_pipeline_library[]
Applications can: use identifiers when creating pipelines with
ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR.
When creating such pipelines, ename:VK_SUCCESS may: be returned, but
subsequently fail when referencing the pipeline in a
slink:VkPipelineLibraryCreateInfoKHR struct.
Applications must: allow pipeline compilation to fail during link steps with
ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT as it may:
not be possible to determine if a pipeline can: be created from identifiers
until the link step.
endif::VK_KHR_pipeline_library[]
endif::VK_EXT_shader_module_identifier[]

.Valid Usage
****
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00704]]
    If the <<features-geometryShader, pname:geometryShader>> feature is not
    enabled, pname:stage must: not be ename:VK_SHADER_STAGE_GEOMETRY_BIT
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00705]]
    If the <<features-tessellationShader, pname:tessellationShader>> feature
    is not enabled, pname:stage must: not be
    ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-02091]]
    If the <<features-meshShader, pname:meshShaders>> feature is not
    enabled, pname:stage must: not be ename:VK_SHADER_STAGE_MESH_BIT_EXT
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-02092]]
    If the <<features-taskShader, pname:taskShaders>> feature is not
    enabled, pname:stage must: not be ename:VK_SHADER_STAGE_TASK_BIT_EXT
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]

ifdef::VK_HUAWEI_cluster_culling_shader[]
  * [[VUID-VkPipelineShaderStageCreateInfo-clustercullingShader-07813]]
    If the <<features-clustercullingShader, pname:clustercullingShader>>
    feature is not enabled, pname:stage must: not be
    ename:VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI
endif::VK_HUAWEI_cluster_culling_shader[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00706]]
    pname:stage must: not be ename:VK_SHADER_STAGE_ALL_GRAPHICS, or
    ename:VK_SHADER_STAGE_ALL
ifdef::VKSC_VERSION_1_0[]
  * [[VUID-VkPipelineShaderStageCreateInfo-module-05026]]
    pname:module must: be dlink:VK_NULL_HANDLE.
  * [[VUID-VkPipelineShaderStageCreateInfo-pName-05027]]
    If pname:pName is not `NULL`, it must: be the name of an
    code:OpEntryPoint in the SPIR-V shader module used for offline
    compilation of this pipeline with an execution model that matches
    pname:stage
endif::VKSC_VERSION_1_0[]
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkPipelineShaderStageCreateInfo-pName-00707]]
    pname:pName must: be the name of an code:OpEntryPoint in pname:module
    with an execution model that matches pname:stage
endif::VKSC_VERSION_1_0[]
  * [[VUID-VkPipelineShaderStageCreateInfo-maxClipDistances-00708]]
    If the identified entry point includes any variable in its interface
    that is declared with the code:ClipDistance code:BuiltIn decoration,
    that variable must: not have an array size greater than
    sname:VkPhysicalDeviceLimits::pname:maxClipDistances
  * [[VUID-VkPipelineShaderStageCreateInfo-maxCullDistances-00709]]
    If the identified entry point includes any variable in its interface
    that is declared with the code:CullDistance code:BuiltIn decoration,
    that variable must: not have an array size greater than
    sname:VkPhysicalDeviceLimits::pname:maxCullDistances
  * [[VUID-VkPipelineShaderStageCreateInfo-maxCombinedClipAndCullDistances-00710]]
    If the identified entry point includes variables in its interface that
    are declared with the code:ClipDistance code:BuiltIn decoration and
    variables in its interface that are declared with the code:CullDistance
    code:BuiltIn decoration, those variables must: not have array sizes
    which sum to more than
    sname:VkPhysicalDeviceLimits::pname:maxCombinedClipAndCullDistances
  * [[VUID-VkPipelineShaderStageCreateInfo-maxSampleMaskWords-00711]]
    If the identified entry point includes any variable in its interface
    that is declared with the code:SampleMask code:BuiltIn decoration, that
    variable must: not have an array size greater than
    sname:VkPhysicalDeviceLimits::pname:maxSampleMaskWords
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00713]]
    If pname:stage is ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, and the identified
    entry point has an code:OpExecutionMode instruction specifying a patch
    size with code:OutputVertices, the patch size must: be greater than `0`
    and less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxTessellationPatchSize
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00714]]
    If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, the identified
    entry point must: have an code:OpExecutionMode instruction specifying a
    maximum output vertex count that is greater than `0` and less than or
    equal to sname:VkPhysicalDeviceLimits::pname:maxGeometryOutputVertices
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00715]]
    If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, the identified
    entry point must: have an code:OpExecutionMode instruction specifying an
    invocation count that is greater than `0` and less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxGeometryShaderInvocations
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-02596]]
    If pname:stage is either ename:VK_SHADER_STAGE_VERTEX_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, or
    ename:VK_SHADER_STAGE_GEOMETRY_BIT, and the identified entry point
    writes to code:Layer for any primitive, it must: write the same value to
    code:Layer for all vertices of a given primitive
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-02597]]
    If pname:stage is either ename:VK_SHADER_STAGE_VERTEX_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, or
    ename:VK_SHADER_STAGE_GEOMETRY_BIT, and the identified entry point
    writes to code:ViewportIndex for any primitive, it must: write the same
    value to code:ViewportIndex for all vertices of a given primitive
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-06685]]
    If pname:stage is ename:VK_SHADER_STAGE_FRAGMENT_BIT, and the identified
    entry point writes to code:FragDepth in any execution path, all
    execution paths that are not exclusive to helper invocations must:
    either discard the fragment, or write or initialize the value of
    code:FragDepth
ifdef::VK_EXT_shader_stencil_export[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-06686]]
    If pname:stage is ename:VK_SHADER_STAGE_FRAGMENT_BIT, and the identified
    entry point writes to code:FragStencilRefEXT in any execution path, all
    execution paths that are not exclusive to helper invocations must:
    either discard the fragment, or write or initialize the value of
    code:FragStencilRefEXT
endif::VK_EXT_shader_stencil_export[]
ifdef::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
  * [[VUID-VkPipelineShaderStageCreateInfo-flags-02784]]
    If pname:flags has the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT
    flag set, the <<features-subgroupSizeControl,
    pname:subgroupSizeControl>> feature must: be enabled
  * [[VUID-VkPipelineShaderStageCreateInfo-flags-02785]]
    If pname:flags has the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT flag
    set, the <<features-computeFullSubgroups, pname:computeFullSubgroups>>
    feature must: be enabled
  * [[VUID-VkPipelineShaderStageCreateInfo-flags-08988]]
    If pname:flags includes
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT,
    pname:stage must: be
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
    one of ename:VK_SHADER_STAGE_MESH_BIT_EXT,
    ename:VK_SHADER_STAGE_TASK_BIT_EXT, or
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
    ename:VK_SHADER_STAGE_COMPUTE_BIT
  * [[VUID-VkPipelineShaderStageCreateInfo-pNext-02754]]
    If a slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure
    is included in the pname:pNext chain, pname:flags must: not have the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT
    flag set
  * [[VUID-VkPipelineShaderStageCreateInfo-pNext-02755]]
    If a slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure
    is included in the pname:pNext chain, the
    <<features-subgroupSizeControl, pname:subgroupSizeControl>> feature
    must: be enabled, and pname:stage must: be a valid bit specified in
    <<limits-requiredSubgroupSizeStages, pname:requiredSubgroupSizeStages>>
  * [[VUID-VkPipelineShaderStageCreateInfo-pNext-02756]]
    If a slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure
    is included in the pname:pNext chain and pname:stage is
    ename:VK_SHADER_STAGE_COMPUTE_BIT,
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[ename:VK_SHADER_STAGE_MESH_BIT_EXT, or ename:VK_SHADER_STAGE_TASK_BIT_EXT,]
    the local workgroup size of the shader must: be less than or equal to
    the product of
    slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo::pname:requiredSubgroupSize
    and <<limits-maxComputeWorkgroupSubgroups,
    pname:maxComputeWorkgroupSubgroups>>
  * [[VUID-VkPipelineShaderStageCreateInfo-pNext-02757]]
    If a slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure
    is included in the pname:pNext chain, and pname:flags has the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT flag
    set, the local workgroup size in the X dimension of the pipeline must:
    be a multiple of
    slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo::pname:requiredSubgroupSize
  * [[VUID-VkPipelineShaderStageCreateInfo-flags-02758]]
    If pname:flags has both the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT and
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT
    flags set, the local workgroup size in the X dimension of the pipeline
    must: be a multiple of <<limits-maxSubgroupSize, pname:maxSubgroupSize>>
  * [[VUID-VkPipelineShaderStageCreateInfo-flags-02759]]
    If pname:flags has the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT flag
    set and pname:flags does not have the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT
    flag set and no
    slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is
    included in the pname:pNext chain, the local workgroup size in the X
    dimension of the pipeline must: be a multiple of <<limits-subgroupSize,
    pname:subgroupSize>>
ifdef::VK_KHR_cooperative_matrix[]
  * [[VUID-VkPipelineShaderStageCreateInfo-module-08987]]
    If pname:module uses the code:OpTypeCooperativeMatrixKHR instruction
    with a code:Scope equal to code:Subgroup, then the local workgroup size
    in the X dimension of the pipeline must: be a multiple of
    <<limits-subgroupSize,pname:subgroupSize>>
endif::VK_KHR_cooperative_matrix[]
endif::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]

ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-08771]]
ifdef::VK_EXT_shader_module_identifier[]
    If a shader module identifier is not specified for this pname:stage,
endif::VK_EXT_shader_module_identifier[]
    pname:module must: be a valid slink:VkShaderModule
ifdef::VK_KHR_pipeline_binary[]
    , or the pname:pNext chain of the parent stext:Vk*CreateInfo structure
    must: set slink:VkPipelineBinaryInfoKHR::pname:binaryCount to a value
    greater than `0`,
endif::VK_KHR_pipeline_binary[]
ifdef::VK_EXT_graphics_pipeline_library,VK_KHR_maintenance5[]
    if none of the following features are enabled:
ifdef::VK_EXT_graphics_pipeline_library[]
  ** <<features-graphicsPipelineLibrary, pname:graphicsPipelineLibrary>>
endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_KHR_maintenance5[]
  ** <<features-maintenance5, pname:maintenance5>>
endif::VK_KHR_maintenance5[]
endif::VK_EXT_graphics_pipeline_library,VK_KHR_maintenance5[]

ifdef::VK_EXT_graphics_pipeline_library,VK_KHR_maintenance5[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-06845]]
ifdef::VK_EXT_shader_module_identifier[]
    If a shader module identifier is not specified for this pname:stage,
    pname:module must: be a valid slink:VkShaderModule, or
endif::VK_EXT_shader_module_identifier[]
ifndef::VK_EXT_shader_module_identifier[]
    If pname:module is dlink:VK_NULL_HANDLE]
endif::VK_EXT_shader_module_identifier[]
    there must: be a valid slink:VkShaderModuleCreateInfo structure in the
    pname:pNext chain
ifdef::VK_KHR_pipeline_binary[]
    , or the pname:pNext chain of the parent stext:Vk*CreateInfo structure
    must: set slink:VkPipelineBinaryInfoKHR::pname:binaryCount to a value
    greater than `0`,
endif::VK_KHR_pipeline_binary[]
endif::VK_EXT_graphics_pipeline_library,VK_KHR_maintenance5[]

ifdef::VK_EXT_shader_module_identifier[]
ifdef::VK_EXT_graphics_pipeline_library,VK_KHR_maintenance5[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-06844]]
    If a shader module identifier is specified for this pname:stage, the
    pname:pNext chain must: not include a slink:VkShaderModuleCreateInfo
    structure
endif::VK_EXT_graphics_pipeline_library,VK_KHR_maintenance5[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-06848]]
    If a shader module identifier is specified for this pname:stage,
    pname:module must: be dlink:VK_NULL_HANDLE
endif::VK_EXT_shader_module_identifier[]
  * [[VUID-VkPipelineShaderStageCreateInfo-pSpecializationInfo-06849]]
ifdef::VK_EXT_shader_module_identifier[]
    If a shader module identifier is not specified, the
endif::VK_EXT_shader_module_identifier[]
ifndef::VK_EXT_shader_module_identifier[The]
    shader code used by the pipeline must: be valid as described by the
    <<spirv-spec,Khronos SPIR-V Specification>> after applying the
    specializations provided in pname:pSpecializationInfo, if any, and then
    converting all specialization constants into fixed constants
endif::VKSC_VERSION_1_0[]
****

include::{generated}/validity/structs/VkPipelineShaderStageCreateInfo.adoc[]
--

[open,refpage='VkPipelineShaderStageCreateFlags',desc='Bitmask of VkPipelineShaderStageCreateFlagBits',type='flags']
--
include::{generated}/api/flags/VkPipelineShaderStageCreateFlags.adoc[]

tname:VkPipelineShaderStageCreateFlags is a bitmask type for setting a mask
of zero or more elink:VkPipelineShaderStageCreateFlagBits.
--

[open,refpage='VkPipelineShaderStageCreateFlagBits',desc='Bitmask controlling how a pipeline shader stage is created',type='enums']
--
Possible values of the pname:flags member of
slink:VkPipelineShaderStageCreateInfo specifying how a pipeline shader stage
is created, are:

include::{generated}/api/enums/VkPipelineShaderStageCreateFlagBits.adoc[]

ifdef::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
  * ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT
    specifies that the
    <<interfaces-builtin-variables-sgs,code:SubgroupSize>> may: vary in the
    shader stage.
  * ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT
    specifies that the subgroup sizes must: be launched with all invocations
    active in the
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[task, mesh, or]
    compute stage.

[NOTE]
====
If ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT
and ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT are
specified and <<limits-minSubgroupSize, pname:minSubgroupSize>> does not
equal <<limits-maxSubgroupSize, pname:maxSubgroupSize>> and no
<<pipelines-required-subgroup-size, required subgroup size>> is specified,
then the only way to guarantee that the 'X' dimension of the local workgroup
size is a multiple of <<interfaces-builtin-variables-sgs,
code:SubgroupSize>> is to make it a multiple of pname:maxSubgroupSize.
Under these conditions, you are guaranteed full subgroups but not any
particular subgroup size.
====

endif::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
--

[open,refpage='VkShaderStageFlagBits',desc='Bitmask specifying a pipeline stage',type='enums']
--
Bits which can: be set by commands and structures, specifying one or more
shader stages, are:

include::{generated}/api/enums/VkShaderStageFlagBits.adoc[]

  * ename:VK_SHADER_STAGE_VERTEX_BIT specifies the vertex stage.
  * ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT specifies the
    tessellation control stage.
  * ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT specifies the
    tessellation evaluation stage.
  * ename:VK_SHADER_STAGE_GEOMETRY_BIT specifies the geometry stage.
  * ename:VK_SHADER_STAGE_FRAGMENT_BIT specifies the fragment stage.
  * ename:VK_SHADER_STAGE_COMPUTE_BIT specifies the compute stage.
  * ename:VK_SHADER_STAGE_ALL_GRAPHICS is a combination of bits used as
    shorthand to specify all graphics stages defined above (excluding the
    compute stage).
  * ename:VK_SHADER_STAGE_ALL is a combination of bits used as shorthand to
    specify all shader stages supported by the device, including all
    additional stages which are introduced by extensions.
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * ename:VK_SHADER_STAGE_TASK_BIT_EXT specifies the task stage.
  * ename:VK_SHADER_STAGE_MESH_BIT_EXT specifies the mesh stage.
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
ifdef::VK_HUAWEI_cluster_culling_shader[]
  * ename:VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI specifies the cluster
    culling stage.
endif::VK_HUAWEI_cluster_culling_shader[]
ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
  * ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR specifies the ray generation stage.
  * ename:VK_SHADER_STAGE_ANY_HIT_BIT_KHR specifies the any-hit stage.
  * ename:VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR specifies the closest hit
    stage.
  * ename:VK_SHADER_STAGE_MISS_BIT_KHR specifies the miss stage.
  * ename:VK_SHADER_STAGE_INTERSECTION_BIT_KHR specifies the intersection
    stage.
  * ename:VK_SHADER_STAGE_CALLABLE_BIT_KHR specifies the callable stage.
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]

[NOTE]
====
ename:VK_SHADER_STAGE_ALL_GRAPHICS only includes the original five graphics
stages included in Vulkan 1.0, and not any stages added by extensions.
Thus, it may not have the desired effect in all cases.
====
--

[open,refpage='VkShaderStageFlags',desc='Bitmask of VkShaderStageFlagBits',type='flags']
--
include::{generated}/api/flags/VkShaderStageFlags.adoc[]

tname:VkShaderStageFlags is a bitmask type for setting a mask of zero or
more elink:VkShaderStageFlagBits.
--

ifdef::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
[open,refpage='VkPipelineShaderStageRequiredSubgroupSizeCreateInfo',desc='Structure specifying the required subgroup size of a newly created pipeline shader stage',type='structs',alias='VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT']
--
The sname:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is
defined as:

include::{generated}/api/structs/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.adoc[]

ifdef::VK_EXT_subgroup_size_control[]
or the equivalent

include::{generated}/api/structs/VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT.adoc[]
endif::VK_EXT_subgroup_size_control[]

ifdef::VK_EXT_shader_object[]
or the equiavlent

include::{generated}/api/structs/VkShaderRequiredSubgroupSizeCreateInfoEXT.adoc[]
endif::VK_EXT_shader_object[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[pipelines-required-subgroup-size]] pname:requiredSubgroupSize is an
    unsigned integer value specifying the required subgroup size for the
    newly created pipeline shader stage.

If a sname:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is
included in the pname:pNext chain of slink:VkPipelineShaderStageCreateInfo,
it specifies that the pipeline shader stage being compiled has a required
subgroup size.

ifdef::VK_EXT_shader_object[]
If a sname:VkShaderRequiredSubgroupSizeCreateInfoEXT structure is included
in the pname:pNext chain of slink:VkShaderCreateInfoEXT, it specifies that
the shader being compiled has a required subgroup size.
endif::VK_EXT_shader_object[]

.Valid Usage
****
  * [[VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-requiredSubgroupSize-02760]]
    pname:requiredSubgroupSize must: be a power-of-two integer
  * [[VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-requiredSubgroupSize-02761]]
    pname:requiredSubgroupSize must: be greater or equal to
    <<limits-minSubgroupSize, pname:minSubgroupSize>>
  * [[VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-requiredSubgroupSize-02762]]
    pname:requiredSubgroupSize must: be less than or equal to
    <<limits-maxSubgroupSize, pname:maxSubgroupSize>>
****

include::{generated}/validity/structs/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.adoc[]
--
endif::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]

ifdef::VK_HUAWEI_subpass_shading[]
[open,refpage='VkSubpassShadingPipelineCreateInfoHUAWEI',desc='Structure specifying parameters of a newly created subpass shading pipeline',type='structs']
--
A subpass shading pipeline is a compute pipeline which must: be called only
in a subpass of a render pass with work dimensions specified by render area
size.
The subpass shading pipeline shader is a compute shader allowed to access
input attachments specified in the calling subpass.
To create a subpass shading pipeline, call flink:vkCreateComputePipelines
with slink:VkSubpassShadingPipelineCreateInfoHUAWEI in the pname:pNext chain
of slink:VkComputePipelineCreateInfo.

The sname:VkSubpassShadingPipelineCreateInfoHUAWEI structure is defined as:

include::{generated}/api/structs/VkSubpassShadingPipelineCreateInfoHUAWEI.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:renderPass is a handle to a render pass object describing the
    environment in which the pipeline will be used.
    The pipeline must: only be used with a render pass instance compatible
    with the one provided.
    See <<renderpass-compatibility,Render Pass Compatibility>> for more
    information.
  * pname:subpass is the index of the subpass in the render pass where this
    pipeline will be used.

.Valid Usage
****
  * [[VUID-VkSubpassShadingPipelineCreateInfoHUAWEI-subpass-04946]]
    pname:subpass must: be created with
    ename:VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI bind point
****

include::{generated}/validity/structs/VkSubpassShadingPipelineCreateInfoHUAWEI.adoc[]
--

[open,refpage='vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI',desc='Query maximum supported subpass shading workgroup size for a give render pass',type='protos']
--
A subpass shading pipeline's workgroup size is a 2D vector with number of
power-of-two in width and height.
The maximum number of width and height is implementation-dependent, and may:
vary for different formats and sample counts of attachments in a render
pass.

To query the maximum workgroup size, call:

include::{generated}/api/protos/vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.adoc[]

  * pname:device is a handle to a local device object that was used to
    create the given render pass.
  * pname:renderPass is a handle to a render pass object describing the
    environment in which the pipeline will be used.
    The pipeline must: only be used with a render pass instance compatible
    with the one provided.
    See <<renderpass-compatibility,Render Pass Compatibility>> for more
    information.
  * pname:pMaxWorkgroupSize is a pointer to a slink:VkExtent2D structure.

include::{generated}/validity/protos/vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.adoc[]
--
endif::VK_HUAWEI_subpass_shading[]

ifdef::VK_EXT_pipeline_robustness[]
[open,refpage='VkPipelineRobustnessCreateInfoEXT',desc='Structure controlling the robustness of a newly created pipeline shader stage',type='structs']
--
The sname:VkPipelineRobustnessCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkPipelineRobustnessCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:storageBuffers sets the behavior of out of bounds accesses made to
    resources bound as:
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC
  * pname:uniformBuffers describes the behavior of out of bounds accesses
    made to resources bound as:
  ** ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC
ifdef::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]
  ** ename:VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK
endif::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]
  * pname:vertexInputs describes the behavior of out of bounds accesses made
    to vertex input attributes
  * pname:images describes the behavior of out of bounds accesses made to
    resources bound as:
  ** ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE

ifdef::VK_EXT_mutable_descriptor_type,VK_VALVE_mutable_descriptor_type[]
Resources bound as ename:VK_DESCRIPTOR_TYPE_MUTABLE_EXT will have the
robustness behavior that covers its active descriptor type.
endif::VK_EXT_mutable_descriptor_type,VK_VALVE_mutable_descriptor_type[]

The scope of the effect of sname:VkPipelineRobustnessCreateInfoEXT depends
on which structure's pname:pNext chain it is included in.

  * sname:VkGraphicsPipelineCreateInfo,
ifdef::VK_KHR_ray_tracing_pipeline[sname:VkRayTracingPipelineCreateInfoKHR,]
    sname:VkComputePipelineCreateInfo: +
    The robustness behavior described by
    sname:VkPipelineRobustnessCreateInfoEXT applies to all accesses through
    this pipeline
  * sname:VkPipelineShaderStageCreateInfo: +
    The robustness behavior described by
    sname:VkPipelineRobustnessCreateInfoEXT applies to all accesses
    emanating from the shader code of this shader stage

If sname:VkPipelineRobustnessCreateInfoEXT is specified for both a pipeline
and a pipeline stage, the sname:VkPipelineRobustnessCreateInfoEXT specified
for the pipeline stage will take precedence.

ifdef::VK_KHR_pipeline_library[]
When sname:VkPipelineRobustnessCreateInfoEXT is specified for a pipeline, it
only affects the subset of the pipeline that is specified by the create
info, as opposed to subsets linked from pipeline libraries.
ifdef::VK_EXT_graphics_pipeline_library[]
For slink:VkGraphicsPipelineCreateInfo, that subset is specified by
slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags.
endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_KHR_ray_tracing_pipeline[]
For slink:VkRayTracingPipelineCreateInfoKHR, that subset is specified by the
specific stages in slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages.
endif::VK_KHR_ray_tracing_pipeline[]
endif::VK_KHR_pipeline_library[]

.Valid Usage
****
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06926]]
    If the <<features-pipelineRobustness, pname:pipelineRobustness>> feature
    is not enabled, pname:storageBuffers must: be
    ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06927]]
    If the <<features-pipelineRobustness, pname:pipelineRobustness>> feature
    is not enabled, pname:uniformBuffers must: be
    ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06928]]
    If the <<features-pipelineRobustness, pname:pipelineRobustness>> feature
    is not enabled, pname:vertexInputs must: be
    ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06929]]
    If the <<features-pipelineRobustness, pname:pipelineRobustness>> feature
    is not enabled, pname:images must: be
    ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-robustImageAccess-06930]]
    If the <<features-robustImageAccess, pname:robustImageAccess>> feature
    is not supported, pname:images must: not be
    ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-robustBufferAccess2-06931]]
    If the <<features-robustBufferAccess2, pname:robustBufferAccess2>>
    feature is not supported, pname:storageBuffers must: not be
    ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-robustBufferAccess2-06932]]
    If the <<features-robustBufferAccess2, pname:robustBufferAccess2>>
    feature is not supported, pname:uniformBuffers must: not be
    ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-robustBufferAccess2-06933]]
    If the <<features-robustBufferAccess2, pname:robustBufferAccess2>>
    feature is not supported, pname:vertexInputs must: not be
    ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-robustImageAccess2-06934]]
    If the <<features-robustImageAccess2, pname:robustImageAccess2>> feature
    is not supported, pname:images must: not be
    ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT
****

include::{generated}/validity/structs/VkPipelineRobustnessCreateInfoEXT.adoc[]
--

[open,refpage='VkPipelineRobustnessBufferBehaviorEXT',desc='Enum controlling the robustness of buffer accesses in a pipeline stage',type='enums']
--
Possible values of the pname:storageBuffers, pname:uniformBuffers, and
pname:vertexInputs members of slink:VkPipelineRobustnessCreateInfoEXT are:

include::{generated}/api/enums/VkPipelineRobustnessBufferBehaviorEXT.adoc[]

  * ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT
    specifies that this pipeline stage follows the behavior of robustness
    features that are enabled on the device that created this pipeline
  * ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT specifies that
    buffer accesses by this pipeline stage to the relevant resource types
    must: not be out of bounds
  * ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT
    specifies that out of bounds accesses by this pipeline stage to the
    relevant resource types behave as if the <<features-robustBufferAccess,
    pname:robustBufferAccess>> feature is enabled
  * ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT
    specifies that out of bounds accesses by this pipeline stage to the
    relevant resource types behave as if the <<features-robustBufferAccess2,
    pname:robustBufferAccess2>> feature is enabled
--

[open,refpage='VkPipelineRobustnessImageBehaviorEXT',desc='Enum controlling the robustness of image accesses in a pipeline stage',type='enums']
--
Possible values of the pname:images member of
slink:VkPipelineRobustnessCreateInfoEXT are:

include::{generated}/api/enums/VkPipelineRobustnessImageBehaviorEXT.adoc[]

  * ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT specifies
    that this pipeline stage follows the behavior of robustness features
    that are enabled on the device that created this pipeline
  * ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT specifies that
    image accesses by this pipeline stage to the relevant resource types
    must: not be out of bounds
  * ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT
    specifies that out of bounds accesses by this pipeline stage to images
    behave as if the <<features-robustImageAccess, pname:robustImageAccess>>
    feature is enabled
  * ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT
    specifies that out of bounds accesses by this pipeline stage to images
    behave as if the <<features-robustImageAccess2,
    pname:robustImageAccess2>> feature is enabled
--
endif::VK_EXT_pipeline_robustness[]

ifdef::VK_EXT_shader_module_identifier[]
[open,refpage='VkPipelineShaderStageModuleIdentifierCreateInfoEXT',desc='Structure specifying an identifier for a shader module',type='structs']
--
An identifier can: be provided instead of shader code in an attempt to
compile pipelines without providing complete SPIR-V to the implementation.

The sname:VkPipelineShaderStageModuleIdentifierCreateInfoEXT structure is
defined as:

include::{generated}/api/structs/VkPipelineShaderStageModuleIdentifierCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:identifierSize is the size, in bytes, of the buffer pointed to by
    pname:pIdentifier.
  * pname:pIdentifier is a pointer to a buffer of opaque data specifying an
    identifier.

Any identifier can: be used.
If the pipeline being created with identifier requires compilation to
complete the pipeline creation call, pipeline compilation must: fail as
defined by ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT.

pname:pIdentifier and pname:identifierSize can: be obtained from an
slink:VkShaderModuleIdentifierEXT queried earlier.

.Valid Usage
****
  * [[VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-pNext-06850]]
    If this structure is included in a pname:pNext chain and
    pname:identifierSize is not equal to 0, the
    <<features-shaderModuleIdentifier, pname:shaderModuleIdentifier>>
    feature must: be enabled
  * [[VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-pNext-06851]]
    If this struct is included in a pname:pNext chain of
    slink:VkPipelineShaderStageCreateInfo and pname:identifierSize is not
    equal to 0, the pipeline must: be created with the
    ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT flag set
  * [[VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-identifierSize-06852]]
    pname:identifierSize must: be less-or-equal to
    ename:VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT
****

include::{generated}/validity/structs/VkPipelineShaderStageModuleIdentifierCreateInfoEXT.adoc[]
--
endif::VK_EXT_shader_module_identifier[]

ifdef::VK_NV_device_generated_commands_compute[]
If a compute pipeline is going to be used in <<device-generated-commands,
Device-Generated Commands>> by specifying its pipeline token with
slink:VkBindPipelineIndirectCommandNV, then that pipeline's associated
metadata must: be saved at a specified buffer device address for later use
in indirect command generation.
The buffer device address must: be specified at the time of compute pipeline
creation with slink:VkComputePipelineIndirectBufferInfoNV structure in the
pname:pNext chain of slink:VkComputePipelineCreateInfo.

[open,refpage='VkComputePipelineIndirectBufferInfoNV',desc='Structure describing the device address where pipeline\'s metadata will be saved',type='structs']
--
The sname:VkComputePipelineIndirectBufferInfoNV structure is defined as:

include::{generated}/api/structs/VkComputePipelineIndirectBufferInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:deviceAddress is the address where the pipeline's metadata will be
    stored.
  * pname:size is the size of pipeline's metadata that was queried using
    flink:vkGetPipelineIndirectMemoryRequirementsNV.
  * pname:pipelineDeviceAddressCaptureReplay is the device address where
    pipeline's metadata was originally saved and can now be used to
    re-populate pname:deviceAddress for replay.

If pname:pipelineDeviceAddressCaptureReplay is zero, no specific address is
requested.
If pname:pipelineDeviceAddressCaptureReplay is not zero, then it must: be an
address retrieved from an identically created pipeline on the same
implementation.
The pipeline metadata must: also be placed on an identically created buffer
and at the same offset using the flink:vkCmdUpdatePipelineIndirectBufferNV
command.

.Valid Usage
****
  * [[VUID-VkComputePipelineIndirectBufferInfoNV-deviceGeneratedComputePipelines-09009]]
    The <<features-deviceGeneratedComputePipelines,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::pname:deviceGeneratedComputePipelines>>
    feature must: be enabled
  * [[VUID-VkComputePipelineIndirectBufferInfoNV-flags-09010]]
    The pipeline creation flags in
    slink:VkComputePipelineCreateInfo::pname:flags must: include
    ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV
  * [[VUID-VkComputePipelineIndirectBufferInfoNV-deviceAddress-09011]]
    pname:deviceAddress must: be aligned to the
    slink:VkMemoryRequirements2::pname:alignment, as returned by
    flink:vkGetPipelineIndirectMemoryRequirementsNV
  * [[VUID-VkComputePipelineIndirectBufferInfoNV-deviceAddress-09012]]
    pname:deviceAddress must: have been allocated from a buffer that was
    created with usage ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT and
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT
  * [[VUID-VkComputePipelineIndirectBufferInfoNV-size-09013]]
    pname:size must: be greater than or equal to the
    slink:VkMemoryRequirements2::pname:size, as returned by
    flink:vkGetPipelineIndirectMemoryRequirementsNV
  * [[VUID-VkComputePipelineIndirectBufferInfoNV-pipelineDeviceAddressCaptureReplay-09014]]
    If pname:pipelineDeviceAddressCaptureReplay is non-zero then the
    <<features-deviceGeneratedComputePipelines,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::pname:deviceGeneratedComputeCaptureReplay>>
    feature must: be enabled
  * [[VUID-VkComputePipelineIndirectBufferInfoNV-pipelineDeviceAddressCaptureReplay-09015]]
    If pname:pipelineDeviceAddressCaptureReplay is non-zero then that
    address must: have been allocated with flag
    ename:VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT set
  * [[VUID-VkComputePipelineIndirectBufferInfoNV-pipelineDeviceAddressCaptureReplay-09016]]
    If pname:pipelineDeviceAddressCaptureReplay is non-zero, the
    pname:pipeline must: have been recreated for replay
  * [[VUID-VkComputePipelineIndirectBufferInfoNV-pipelineDeviceAddressCaptureReplay-09017]]
    pname:pipelineDeviceAddressCaptureReplay must: satisfy the
    pname:alignment and pname:size requirements similar to
    pname:deviceAddress
****

include::{generated}/validity/structs/VkComputePipelineIndirectBufferInfoNV.adoc[]
--

[open,refpage='vkCmdUpdatePipelineIndirectBufferNV',desc='Update the indirect compute pipeline\'s metadata',type='protos']
--
To save a compute pipeline's metadata at a device address call:

include::{generated}/api/protos/vkCmdUpdatePipelineIndirectBufferNV.adoc[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pipelineBindPoint is a elink:VkPipelineBindPoint value specifying
    the type of pipeline whose metadata will be saved.
  * pname:pipeline is the pipeline whose metadata will be saved.

fname:vkCmdUpdatePipelineIndirectBufferNV is only allowed outside of a
render pass.
This command is treated as a "`transfer`" operation for the purposes of
synchronization barriers.
The writes to the address must: be synchronized using stages
ename:VK_PIPELINE_STAGE_2_COPY_BIT and
ename:VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV and with access masks
ename:VK_ACCESS_MEMORY_WRITE_BIT and
ename:VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV respectively before using the
results in preprocessing.

.Valid Usage
****
  * [[VUID-vkCmdUpdatePipelineIndirectBufferNV-pipelineBindPoint-09018]]
    pname:pipelineBindPoint must: be ename:VK_PIPELINE_BIND_POINT_COMPUTE
  * [[VUID-vkCmdUpdatePipelineIndirectBufferNV-pipeline-09019]]
    pname:pipeline must: have been created with
    ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV flag set
  * [[VUID-vkCmdUpdatePipelineIndirectBufferNV-pipeline-09020]]
    pname:pipeline must: have been created with
    slink:VkComputePipelineIndirectBufferInfoNV structure specifying a valid
    address where its metadata will be saved
  * [[VUID-vkCmdUpdatePipelineIndirectBufferNV-deviceGeneratedComputePipelines-09021]]
    The <<features-deviceGeneratedComputePipelines,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::pname:deviceGeneratedComputePipelines>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkCmdUpdatePipelineIndirectBufferNV.adoc[]
--
endif::VK_NV_device_generated_commands_compute[]


[[pipelines-graphics]]
== Graphics Pipelines

Graphics pipelines consist of multiple shader stages, multiple
fixed-function pipeline stages, and a pipeline layout.

[open,refpage='vkCreateGraphicsPipelines',desc='Create graphics pipelines',type='protos']
--
:refpage: vkCreateGraphicsPipelines
:objectnameplural: graphics pipelines
:objectnamecamelcase: graphicsPipeline
:objectnamestruct: VkDeviceObjectReservationCreateInfo
:objectcount: pname:createInfoCount

To create graphics pipelines, call:

include::{generated}/api/protos/vkCreateGraphicsPipelines.adoc[]

  * pname:device is the logical device that creates the graphics pipelines.
ifndef::VKSC_VERSION_1_0[]
  * pname:pipelineCache is either dlink:VK_NULL_HANDLE, indicating that
    pipeline caching is disabled; or the handle of a valid
    <<pipelines-cache,pipeline cache>> object, in which case use of that
    cache is enabled for the duration of the command.
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
  * pname:pipelineCache is the handle of a valid <<pipelines-cache,pipeline
    cache>> object.
endif::VKSC_VERSION_1_0[]
  * pname:createInfoCount is the length of the pname:pCreateInfos and
    pname:pPipelines arrays.
  * pname:pCreateInfos is a pointer to an array of
    slink:VkGraphicsPipelineCreateInfo structures.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pPipelines is a pointer to an array of slink:VkPipeline handles in
    which the resulting graphics pipeline objects are returned.

The slink:VkGraphicsPipelineCreateInfo structure includes an array of
slink:VkPipelineShaderStageCreateInfo structures for each of the desired
active shader stages, as well as creation information for all relevant
fixed-function stages, and a pipeline layout.

Pipelines are created and returned as described for <<pipelines-multiple,
Multiple Pipeline Creation>>.

ifdef::VKSC_VERSION_1_0[]
If a pipeline creation fails due to:

  * The identified pipeline not being present in pname:pipelineCache
  * The pname:pNext chain not including a slink:VkPipelineOfflineCreateInfo
    structure

the operation will continue as specified in <<pipelines-multiple, Multiple
Pipeline Creation>> and the command will return
ename:VK_ERROR_NO_PIPELINE_MATCH.
ifdef::hidden[]
// tag::scdeviation[]
  * flink:vkCreateGraphicsPipelines returns ename:VK_ERROR_NO_PIPELINE_MATCH
    if the slink:VkGraphicsPipelineCreateInfo::pname:pNext chain does not
    include a valid slink:VkPipelineOfflineCreateInfo structure <<SCID-1>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkCreateGraphicsPipelines-device-09662]]
    pname:device must: support at least one queue family with the
    ename:VK_QUEUE_GRAPHICS_BIT capability
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkCreateGraphicsPipelines-flags-00720]]
    If the pname:flags member of any element of pname:pCreateInfos contains
    the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the
    pname:basePipelineIndex member of that same element is not `-1`,
    pname:basePipelineIndex must: be less than the index into
    pname:pCreateInfos that corresponds to that element
  * [[VUID-vkCreateGraphicsPipelines-flags-00721]]
    If the pname:flags member of any element of pname:pCreateInfos contains
    the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline
    must: have been created with the
    ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set
endif::VKSC_VERSION_1_0[]
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * [[VUID-vkCreateGraphicsPipelines-pipelineCache-02876]]
    If pname:pipelineCache was created with
    ename:VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT, host access
    to pname:pipelineCache must: be
    <<fundamentals-threadingbehavior,externally synchronized>>
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
include::{chapters}/commonvalidity/memory_reservation_request_count_common.adoc[]
include::{chapters}/commonvalidity/pipeline_create_common.adoc[]
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
  * flink:vkCreateGraphicsPipelines::pname:pipelineCache must: not be
    dlink:VK_NULL_HANDLE <<SCID-1>>, <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
[NOTE]
====
An implicit cache may be provided by the implementation or a layer.
For this reason, it is still valid to set
ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT on
pname:flags for any element of pname:pCreateInfos while passing
dlink:VK_NULL_HANDLE for pname:pipelineCache.
====
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]

include::{generated}/validity/protos/vkCreateGraphicsPipelines.adoc[]
--

[open,refpage='VkGraphicsPipelineCreateInfo',desc='Structure specifying parameters of a newly created graphics pipeline',type='structs']
--
:refpage: VkGraphicsPipelineCreateInfo

The sname:VkGraphicsPipelineCreateInfo structure is defined as:

include::{generated}/api/structs/VkGraphicsPipelineCreateInfo.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkPipelineCreateFlagBits specifying
    how the pipeline will be generated.
  * pname:stageCount is the number of entries in the pname:pStages array.
  * pname:pStages is a pointer to an array of pname:stageCount
    slink:VkPipelineShaderStageCreateInfo structures describing the set of
    the shader stages to be included in the graphics pipeline.
  * pname:pVertexInputState is a pointer to a
    slink:VkPipelineVertexInputStateCreateInfo structure.
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
    It is ignored if the pipeline includes a mesh shader stage.
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
ifdef::VK_EXT_vertex_input_dynamic_state[]
    It can: be `NULL` if the pipeline is created with the
    ename:VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state set.
endif::VK_EXT_vertex_input_dynamic_state[]
  * pname:pInputAssemblyState is a pointer to a
    slink:VkPipelineInputAssemblyStateCreateInfo structure which determines
    input assembly behavior for vertex shading, as described in <<drawing,
    Drawing Commands>>.
ifdef::VK_EXT_extended_dynamic_state3[]
    [[pipelines-pInputAssemblyState-null]] If the
    `apiext:VK_EXT_extended_dynamic_state3` extension is enabled, it can: be
    `NULL` if the pipeline is created with both
    ename:VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE, and
    ename:VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY dynamic states set and
    <<limits-dynamicPrimitiveTopologyUnrestricted,
    pname:dynamicPrimitiveTopologyUnrestricted>> is ename:VK_TRUE.
endif::VK_EXT_extended_dynamic_state3[]
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
    It is ignored if the pipeline includes a mesh shader stage.
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * pname:pTessellationState is a pointer to a
    slink:VkPipelineTessellationStateCreateInfo structure defining
    tessellation state used by tessellation shaders.
ifdef::VK_EXT_extended_dynamic_state2[]
    It can: be `NULL` if the pipeline is created with the
    ename:VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state set.
endif::VK_EXT_extended_dynamic_state2[]
  * pname:pViewportState is a pointer to a
    slink:VkPipelineViewportStateCreateInfo structure defining viewport
    state used when rasterization is enabled.
ifdef::VK_EXT_extended_dynamic_state3[]
    [[pipelines-pViewportState-null]] If the
    `apiext:VK_EXT_extended_dynamic_state3` extension is enabled, it can: be
    `NULL` if the pipeline is created with both
    ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT, and
    ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic states set.
endif::VK_EXT_extended_dynamic_state3[]
  * pname:pRasterizationState is a pointer to a
    slink:VkPipelineRasterizationStateCreateInfo structure defining
    rasterization state.
ifdef::VK_EXT_extended_dynamic_state3[]
    [[pipelines-pRasterizationState-null]] If the
    `apiext:VK_EXT_extended_dynamic_state3` extension is enabled, it can: be
    `NULL` if the pipeline is created with all of
    ename:VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT,
    ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE,
    ename:VK_DYNAMIC_STATE_POLYGON_MODE_EXT,
    ename:VK_DYNAMIC_STATE_CULL_MODE, ename:VK_DYNAMIC_STATE_FRONT_FACE,
    ename:VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE,
    ename:VK_DYNAMIC_STATE_DEPTH_BIAS, and ename:VK_DYNAMIC_STATE_LINE_WIDTH
    dynamic states set.
endif::VK_EXT_extended_dynamic_state3[]
  * pname:pMultisampleState is a pointer to a
    slink:VkPipelineMultisampleStateCreateInfo structure defining
    multisample state used when rasterization is enabled.
ifdef::VK_EXT_extended_dynamic_state3[]
    [[pipelines-pMultisampleState-null]] If the
    `apiext:VK_EXT_extended_dynamic_state3` extension is enabled, it can: be
    `NULL` if the pipeline is created with all of
    ename:VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT,
    ename:VK_DYNAMIC_STATE_SAMPLE_MASK_EXT, and
    ename:VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT dynamic states set,
    and either <<features-alphaToOne,alphaToOne>> is disabled on the device
    or ename:VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT is set, in which case
    slink:VkPipelineMultisampleStateCreateInfo::pname:sampleShadingEnable is
    assumed to be ename:VK_FALSE.
endif::VK_EXT_extended_dynamic_state3[]
  * pname:pDepthStencilState is a pointer to a
    slink:VkPipelineDepthStencilStateCreateInfo structure defining
    depth/stencil state used when rasterization is enabled for depth or
    stencil attachments accessed during rendering.
ifdef::VK_EXT_extended_dynamic_state3[]
    [[pipelines-pDepthStencilState-null]] If the
    `apiext:VK_EXT_extended_dynamic_state3` extension is enabled, it can: be
    `NULL` if the pipeline is created with all of
    ename:VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE,
    ename:VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE,
    ename:VK_DYNAMIC_STATE_DEPTH_COMPARE_OP,
    ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE,
    ename:VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE,
    ename:VK_DYNAMIC_STATE_STENCIL_OP, and
    ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS dynamic states set.
endif::VK_EXT_extended_dynamic_state3[]
  * pname:pColorBlendState is a pointer to a
    slink:VkPipelineColorBlendStateCreateInfo structure defining color blend
    state used when rasterization is enabled for any color attachments
    accessed during rendering.
ifdef::VK_EXT_extended_dynamic_state3[]
    [[pipelines-pColorBlendState-null]] If the
    `apiext:VK_EXT_extended_dynamic_state3` extension is enabled, it can: be
    `NULL` if the pipeline is created with all of
    ename:VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT,
    ename:VK_DYNAMIC_STATE_LOGIC_OP_EXT,
    ename:VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT,
    ename:VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT,
    ename:VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, and
    ename:VK_DYNAMIC_STATE_BLEND_CONSTANTS dynamic states set.
endif::VK_EXT_extended_dynamic_state3[]
  * pname:pDynamicState is a pointer to a
    slink:VkPipelineDynamicStateCreateInfo structure defining which
    properties of the pipeline state object are dynamic and can: be changed
    independently of the pipeline state.
    This can: be `NULL`, which means no state in the pipeline is considered
    dynamic.
  * pname:layout is the description of binding locations used by both the
    pipeline and descriptor sets used with the pipeline.
  * pname:renderPass is a handle to a render pass object describing the
    environment in which the pipeline will be used.
    The pipeline must: only be used with a render pass instance compatible
    with the one provided.
    See <<renderpass-compatibility,Render Pass Compatibility>> for more
    information.
  * pname:subpass is the index of the subpass in the render pass where this
    pipeline will be used.
  * pname:basePipelineHandle is a pipeline to derive from.
ifdef::VKSC_VERSION_1_0[]
    This is not used in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]
  * pname:basePipelineIndex is an index into the pname:pCreateInfos
    parameter to use as a pipeline to derive from.
ifdef::VKSC_VERSION_1_0[]
    This is not used in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]

The parameters pname:basePipelineHandle and pname:basePipelineIndex are
described in more detail in <<pipelines-pipeline-derivatives,Pipeline
Derivatives>>.

ifdef::VK_NV_glsl_shader[]
If any shader stage fails to compile,
ifdef::VK_EXT_debug_report[]
the compile log will be reported back to the application, and
endif::VK_EXT_debug_report[]
ename:VK_ERROR_INVALID_SHADER_NV will be generated.
endif::VK_NV_glsl_shader[]

ifdef::VK_EXT_extended_dynamic_state3[]
[NOTE]
====
With `apiext:VK_EXT_extended_dynamic_state3`, it is possible that many of
the sname:VkGraphicsPipelineCreateInfo members above can: be `NULL` because
all their state is dynamic and therefore ignored.
This is optional so the application can: still use a valid pointer if it
needs to set the pname:pNext or pname:flags fields to specify state for
other extensions.
====
endif::VK_EXT_extended_dynamic_state3[]

[[pipelines-graphics-subsets]]
The state required for a graphics pipeline is divided into
<<pipelines-graphics-subsets-vertex-input, vertex input state>>,
<<pipelines-graphics-subsets-pre-rasterization,pre-rasterization shader
state>>, <<pipelines-graphics-subsets-fragment-shader,fragment shader
state>>, and <<pipelines-graphics-subsets-fragment-output,fragment output
state>>.

[[pipelines-graphics-subsets-vertex-input]]
.Vertex Input State
Vertex input state is defined by:

  * slink:VkPipelineVertexInputStateCreateInfo
  * slink:VkPipelineInputAssemblyStateCreateInfo

ifndef::VK_EXT_mesh_shader[]
This state must: be specified to create a
<<pipelines-graphics-subsets-complete,complete graphics pipeline>>.
endif::VK_EXT_mesh_shader[]

ifdef::VK_EXT_mesh_shader[]
If
ifdef::VK_EXT_graphics_pipeline_library[]
this pipeline specifies
<<pipelines-graphics-subsets-pre-rasterization,pre-rasterization state>>
either directly or by including it as a pipeline library and its
endif::VK_EXT_graphics_pipeline_library[]
pname:pStages includes a vertex shader, this state must: be specified to
create a <<pipelines-graphics-subsets-complete,complete graphics pipeline>>.
endif::VK_EXT_mesh_shader[]

ifdef::VK_EXT_graphics_pipeline_library[]
If a pipeline includes
ename:VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT in
slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags either explicitly
or as a default, and either the conditions requiring this state for a
<<pipelines-graphics-subsets-complete,complete graphics pipeline>> are met
or this pipeline does not specify
<<pipelines-graphics-subsets-pre-rasterization,pre-rasterization state>> in
any way, that pipeline must: specify this state directly.
endif::VK_EXT_graphics_pipeline_library[]


[[pipelines-graphics-subsets-pre-rasterization]]
.Pre-Rasterization Shader State
Pre-rasterization shader state is defined by:

  * slink:VkPipelineShaderStageCreateInfo entries for:
  ** Vertex shaders
  ** Tessellation control shaders
  ** Tessellation evaluation shaders
  ** Geometry shaders
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  ** Task shaders
  ** Mesh shaders
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
ifdef::VK_EXT_graphics_pipeline_library[]
  * Within the slink:VkPipelineLayout, all descriptor sets with
    pre-rasterization shader bindings if
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT was specified.
  ** If ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT was not
     specified, the full pipeline layout must: be specified.
endif::VK_EXT_graphics_pipeline_library[]
ifndef::VK_EXT_graphics_pipeline_library[]
  * Within the slink:VkPipelineLayout, the full pipeline layout must: be
    specified.
endif::VK_EXT_graphics_pipeline_library[]
  * slink:VkPipelineViewportStateCreateInfo
  * slink:VkPipelineRasterizationStateCreateInfo
  * slink:VkPipelineTessellationStateCreateInfo
  * slink:VkRenderPass and pname:subpass parameter
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * The pname:viewMask parameter of slink:VkPipelineRenderingCreateInfo
    (formats are ignored)
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_EXT_discard_rectangles[]
  * slink:VkPipelineDiscardRectangleStateCreateInfoEXT
endif::VK_EXT_discard_rectangles[]
ifdef::VK_KHR_fragment_shading_rate[]
  * slink:VkPipelineFragmentShadingRateStateCreateInfoKHR
endif::VK_KHR_fragment_shading_rate[]

This state must: be specified to create a
<<pipelines-graphics-subsets-complete,complete graphics pipeline>>.

ifdef::VK_EXT_graphics_pipeline_library[]
If either the pname:pNext chain includes a
slink:VkGraphicsPipelineLibraryCreateInfoEXT structure with
ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT
included in pname:flags, or it is not specified and would default to include
that value, this state must: be specified in the pipeline.
endif::VK_EXT_graphics_pipeline_library[]


[[pipelines-graphics-subsets-fragment-shader]]
.Fragment Shader State
Fragment shader state is defined by:

  * A slink:VkPipelineShaderStageCreateInfo entry for the fragment shader
ifdef::VK_EXT_graphics_pipeline_library[]
  * Within the slink:VkPipelineLayout, all descriptor sets with fragment
    shader bindings if
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT was specified.
  ** If ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT was not
     specified, the full pipeline layout must: be specified.
endif::VK_EXT_graphics_pipeline_library[]
ifndef::VK_EXT_graphics_pipeline_library[]
  * Within the slink:VkPipelineLayout, the full pipeline layout must: be
    specified.
endif::VK_EXT_graphics_pipeline_library[]
  * slink:VkPipelineMultisampleStateCreateInfo
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
    if <<primsrast-sampleshading, sample shading>> is enabled or
    pname:renderpass is not dlink:VK_NULL_HANDLE
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * slink:VkPipelineDepthStencilStateCreateInfo
  * slink:VkRenderPass and pname:subpass parameter
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * The pname:viewMask parameter of slink:VkPipelineRenderingCreateInfo
    (formats are ignored)
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_KHR_fragment_shading_rate[]
  * slink:VkPipelineFragmentShadingRateStateCreateInfoKHR
ifdef::VK_NV_fragment_shading_rate_enums[]
  * slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV
endif::VK_NV_fragment_shading_rate_enums[]
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_NV_representative_fragment_test[]
  * slink:VkPipelineRepresentativeFragmentTestStateCreateInfoNV
endif::VK_NV_representative_fragment_test[]
ifdef::VK_KHR_fragment_shading_rate[]
  * Inclusion/omission of the
    ename:VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
    flag
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_EXT_fragment_density_map[]
  * Inclusion/omission of the
    ename:VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
    flag
endif::VK_EXT_fragment_density_map[]
ifdef::VK_KHR_dynamic_rendering_local_read[]
  * slink:VkRenderingInputAttachmentIndexInfoKHR
endif::VK_KHR_dynamic_rendering_local_read[]

If
ifdef::VK_EXT_graphics_pipeline_library[]
a pipeline specifies
<<pipelines-graphics-subsets-pre-rasterization,pre-rasterization state>>
either directly or by including it as a pipeline library and
endif::VK_EXT_graphics_pipeline_library[]
pname:rasterizerDiscardEnable is set to ename:VK_FALSE
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
or ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE is used,
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
ifdef::VK_EXT_graphics_pipeline_library[]
endif::VK_EXT_graphics_pipeline_library[]
this state must: be specified to create a
<<pipelines-graphics-subsets-complete,complete graphics pipeline>>.

ifdef::VK_EXT_graphics_pipeline_library[]
If a pipeline includes
ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT in
slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags either explicitly
or as a default, and either the conditions requiring this state for a
<<pipelines-graphics-subsets-complete,complete graphics pipeline>> are met
or this pipeline does not specify
<<pipelines-graphics-subsets-pre-rasterization,pre-rasterization state>> in
any way, that pipeline must: specify this state directly.
endif::VK_EXT_graphics_pipeline_library[]


[[pipelines-graphics-subsets-fragment-output]]
.Fragment Output State
Fragment output state is defined by:

  * slink:VkPipelineColorBlendStateCreateInfo
  * slink:VkRenderPass and pname:subpass parameter
  * slink:VkPipelineMultisampleStateCreateInfo
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * slink:VkPipelineRenderingCreateInfo
ifdef::VK_AMD_mixed_attachment_samples[]
  * slink:VkAttachmentSampleCountInfoAMD
endif::VK_AMD_mixed_attachment_samples[]
ifdef::VK_NV_framebuffer_mixed_samples[]
  * slink:VkAttachmentSampleCountInfoNV
endif::VK_NV_framebuffer_mixed_samples[]
ifdef::VK_ANDROID_external_format_resolve[]
  * slink:VkExternalFormatANDROID
endif::VK_ANDROID_external_format_resolve[]
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_EXT_attachment_feedback_loop_layout[]
  * Inclusion/omission of the
    ename:VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT and
    ename:VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
    flags
endif::VK_EXT_attachment_feedback_loop_layout[]
ifdef::VK_EXT_legacy_dithering[]
  * Inclusion/omission of the
    ename:VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT flag
endif::VK_EXT_legacy_dithering[]
ifdef::VK_KHR_dynamic_rendering_local_read[]
  * slink:VkRenderingAttachmentLocationInfoKHR
endif::VK_KHR_dynamic_rendering_local_read[]

If
ifdef::VK_EXT_graphics_pipeline_library[]
a pipeline specifies
<<pipelines-graphics-subsets-pre-rasterization,pre-rasterization state>>
either directly or by including it as a pipeline library and
endif::VK_EXT_graphics_pipeline_library[]
pname:rasterizerDiscardEnable is set to ename:VK_FALSE
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
or ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE is used,
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
ifdef::VK_EXT_graphics_pipeline_library[]
endif::VK_EXT_graphics_pipeline_library[]
this state must: be specified to create a
<<pipelines-graphics-subsets-complete,complete graphics pipeline>>.

ifdef::VK_EXT_graphics_pipeline_library[]
If a pipeline includes
ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT in
slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags either explicitly
or as a default, and either the conditions requiring this state for a
<<pipelines-graphics-subsets-complete,complete graphics pipeline>> are met
or this pipeline does not specify
<<pipelines-graphics-subsets-pre-rasterization,pre-rasterization state>> in
any way, that pipeline must: specify this state directly.
endif::VK_EXT_graphics_pipeline_library[]


[[pipelines-graphics-subsets-dynamic-state]]
.Dynamic State
Dynamic state values set via pname:pDynamicState must: be ignored if the
state they correspond to is not otherwise statically set by one of the state
subsets used to create the pipeline.
ifdef::VK_EXT_graphics_pipeline_library[]
Additionally, setting dynamic state values must: not modify whether state in
a linked library is static or dynamic; this is set and unchangeable when the
library is created.
endif::VK_EXT_graphics_pipeline_library[]
For example, if a pipeline only included
<<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
state>>, then any dynamic state value corresponding to depth or stencil
testing has no effect.
ifdef::VK_EXT_graphics_pipeline_library[]
Any linked library that has dynamic state enabled that same dynamic state
must: also be enabled in all the other linked libraries to which that
dynamic state applies.
endif::VK_EXT_graphics_pipeline_library[]

[[pipelines-graphics-subsets-complete]]
.Complete Graphics Pipelines

A complete graphics pipeline always includes
<<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
state>>, with other subsets included depending on that state as specified in
the above sections.

ifdef::VK_EXT_graphics_pipeline_library[]
.Graphics Pipeline Library Layouts

If different subsets are linked together with pipeline layouts created with
ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, the final
effective pipeline layout is effectively the union of the linked pipeline
layouts.
When binding descriptor sets for this pipeline, the pipeline layout used
must: be compatible with this union.
This pipeline layout can: be overridden when linking with
ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT by providing a
slink:VkPipelineLayout that is <<descriptorsets-compatibility,compatible>>
with this union other than
ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, or when linking
without ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT by providing
a slink:VkPipelineLayout that is fully
<<descriptorsets-compatibility,compatible>> with this union.
endif::VK_EXT_graphics_pipeline_library[]

ifdef::VK_KHR_maintenance5[]
If the pname:pNext chain includes a
slink:VkPipelineCreateFlags2CreateInfoKHR structure,
slink:VkPipelineCreateFlags2CreateInfoKHR::pname:flags from that structure
is used instead of pname:flags from this structure.
endif::VK_KHR_maintenance5[]

ifdef::VKSC_VERSION_1_0[]
In Vulkan SC, the pipeline compilation process occurs
<<pipelines-offline-compilation,offline>> and the pname:pStages are not
needed at runtime and may: be omitted.
If omitted, pname:stageCount must: be set to `0` and pname:pStages must: be
`NULL`.
If provided, the values must: match the values specified to the offline
compiler.
endif::VKSC_VERSION_1_0[]

.Valid Usage
****
:pipelineType: graphics
include::{chapters}/commonvalidity/pipeline_create_info_common.adoc[]
  * [[VUID-VkGraphicsPipelineCreateInfo-stage-02096]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> the pname:stage member of one element
    of pname:pStages must: be ename:VK_SHADER_STAGE_VERTEX_BIT
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
    or ename:VK_SHADER_STAGE_MESH_BIT_EXT
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-02095]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> the geometric shader stages provided in
    pname:pStages must: be either from the mesh shading pipeline
    (pname:stage is ename:VK_SHADER_STAGE_TASK_BIT_EXT or
    ename:VK_SHADER_STAGE_MESH_BIT_EXT) or from the primitive shading
    pipeline (pname:stage is ename:VK_SHADER_STAGE_VERTEX_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, or
    ename:VK_SHADER_STAGE_GEOMETRY_BIT)
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-09631]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and pname:pStages contains both
    ename:VK_SHADER_STAGE_TASK_BIT_EXT and
    ename:VK_SHADER_STAGE_MESH_BIT_EXT, then the mesh shader's entry point
    must: not declare a variable with a code:DrawIndex code:BuiltIn
    decoration
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
ifdef::VK_NV_mesh_shader+VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-TaskNV-07063]]
    The shader stages for ename:VK_SHADER_STAGE_TASK_BIT_EXT or
    ename:VK_SHADER_STAGE_MESH_BIT_EXT must: use either the code:TaskNV and
    code:MeshNV {ExecutionModel} or the code:TaskEXT and code:MeshEXT
    {ExecutionModel}, but must: not use both
endif::VK_NV_mesh_shader+VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00729]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and pname:pStages includes a
    tessellation control shader stage, it must: include a tessellation
    evaluation shader stage
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00730]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and pname:pStages includes a
    tessellation evaluation shader stage, it must: include a tessellation
    control shader stage
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-09022]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and pname:pStages includes a
    tessellation control shader stage,
ifdef::VK_EXT_extended_dynamic_state3[]
    and the `apiext:VK_EXT_extended_dynamic_state3` extension is not enabled
    or the ename:VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state is
    not set,
endif::VK_EXT_extended_dynamic_state3[]
    pname:pTessellationState must: be a valid pointer to a valid
    slink:VkPipelineTessellationStateCreateInfo structure
ifdef::VK_EXT_extended_dynamic_state3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pTessellationState-09023]]
    If pname:pTessellationState is not `NULL` it must: be a pointer to a
    valid slink:VkPipelineTessellationStateCreateInfo structure
endif::VK_EXT_extended_dynamic_state3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00732]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and pname:pStages includes tessellation
    shader stages, the shader code of at least one stage must: contain an
    code:OpExecutionMode instruction specifying the type of subdivision in
    the pipeline
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00733]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and pname:pStages includes tessellation
    shader stages, and the shader code of both stages contain an
    code:OpExecutionMode instruction specifying the type of subdivision in
    the pipeline, they must: both specify the same subdivision mode
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00734]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and pname:pStages includes tessellation
    shader stages, the shader code of at least one stage must: contain an
    code:OpExecutionMode instruction specifying the output patch size in the
    pipeline
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00735]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and pname:pStages includes tessellation
    shader stages, and the shader code of both contain an
    code:OpExecutionMode instruction specifying the out patch size in the
    pipeline, they must: both specify the same patch size
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-08888]]
    If the pipeline is being created with
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and <<pipelines-graphics-subsets-vertex-input, vertex input
    state>> and pname:pStages includes tessellation shader stages,
ifdef::VK_EXT_extended_dynamic_state3[]
    and either ename:VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY dynamic state is
    not enabled or
    <<limits-dynamicPrimitiveTopologyUnrestricted,pname:dynamicPrimitiveTopologyUnrestricted>>
    is ename:VK_FALSE,
endif::VK_EXT_extended_dynamic_state3[]
    the pname:topology member of pname:pInputAssembly must: be
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST
  * [[VUID-VkGraphicsPipelineCreateInfo-topology-08889]]
    If the pipeline is being created with
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and <<pipelines-graphics-subsets-vertex-input, vertex input
    state>> and the pname:topology member of pname:pInputAssembly is
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
ifdef::VK_EXT_extended_dynamic_state3[]
    and either ename:VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY dynamic state is
    not enabled or
    <<limits-dynamicPrimitiveTopologyUnrestricted,pname:dynamicPrimitiveTopologyUnrestricted>>
    is ename:VK_FALSE,
endif::VK_EXT_extended_dynamic_state3[]
    then pname:pStages must: include tessellation shader stages
  * [[VUID-VkGraphicsPipelineCreateInfo-TessellationEvaluation-07723]]
    If the pipeline is being created with a code:TessellationEvaluation
    {ExecutionModel}, no code:Geometry {ExecutionModel}, uses the
    code:PointMode {ExecutionMode}, and
    <<features-shaderTessellationAndGeometryPointSize,
    pname:shaderTessellationAndGeometryPointSize>> is enabled, a
    code:PointSize decorated variable must: be written to
ifdef::VK_KHR_maintenance5[]
    if <<features-maintenance5, pname:maintenance5>> is not enabled
endif::VK_KHR_maintenance5[]
  * [[VUID-VkGraphicsPipelineCreateInfo-topology-08773]]
    If the pipeline is being created with a code:Vertex {ExecutionModel} and
    no code:TessellationEvaluation or code:Geometry {ExecutionModel}, and
    the pname:topology member of pname:pInputAssembly is
    ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
ifdef::VK_EXT_extended_dynamic_state3[]
    and either ename:VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY dynamic state is
    not enabled or
    <<limits-dynamicPrimitiveTopologyUnrestricted,pname:dynamicPrimitiveTopologyUnrestricted>>
    is ename:VK_FALSE,
endif::VK_EXT_extended_dynamic_state3[]
    a code:PointSize decorated variable must: be written to
ifdef::VK_KHR_maintenance5[]
    if <<features-maintenance5, pname:maintenance5>> is not enabled
endif::VK_KHR_maintenance5[]
ifdef::VK_KHR_maintenance5[]
  * [[VUID-VkGraphicsPipelineCreateInfo-maintenance5-08775]]
    If <<features-maintenance5, pname:maintenance5>> is enabled and a
    code:PointSize decorated variable is written to, all execution paths
    must: write to a code:PointSize decorated variable
endif::VK_KHR_maintenance5[]
  * [[VUID-VkGraphicsPipelineCreateInfo-TessellationEvaluation-07724]]
    If the pipeline is being created with a code:TessellationEvaluation
    {ExecutionModel}, no code:Geometry {ExecutionModel}, uses the
    code:PointMode {ExecutionMode}, and
    <<features-shaderTessellationAndGeometryPointSize,
    pname:shaderTessellationAndGeometryPointSize>> is not enabled, a
    code:PointSize decorated variable must: not be written to
  * [[VUID-VkGraphicsPipelineCreateInfo-shaderTessellationAndGeometryPointSize-08776]]
    If the pipeline is being created with a code:Geometry {ExecutionModel},
    uses the code:OutputPoints {ExecutionMode}, and
    <<features-shaderTessellationAndGeometryPointSize,
    pname:shaderTessellationAndGeometryPointSize>> is enabled, a
    code:PointSize decorated variable must: be written to for every vertex
    emitted
ifdef::VK_KHR_maintenance5[]
    if <<features-maintenance5, pname:maintenance5>> is not enabled
endif::VK_KHR_maintenance5[]
  * [[VUID-VkGraphicsPipelineCreateInfo-Geometry-07726]]
    If the pipeline is being created with a code:Geometry {ExecutionModel},
    uses the code:OutputPoints {ExecutionMode}, and
    <<features-shaderTessellationAndGeometryPointSize,
    pname:shaderTessellationAndGeometryPointSize>> is not enabled, a
    code:PointSize decorated variable must: not be written to
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00738]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and pname:pStages includes a geometry
    shader stage, and does not include any tessellation shader stages, its
    shader code must: contain an code:OpExecutionMode instruction specifying
    an input primitive type that is <<shaders-geometry-execution,
    compatible>> with the primitive topology specified in
    pname:pInputAssembly
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00739]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and pname:pStages includes a geometry
    shader stage, and also includes tessellation shader stages, its shader
    code must: contain an code:OpExecutionMode instruction specifying an
    input primitive type that is <<shaders-geometry-execution, compatible>>
    with the primitive topology that is output by the tessellation stages
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00740]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>,
    it includes both a fragment shader and a geometry shader, and the
    fragment shader code reads from an input variable that is decorated with
    code:PrimitiveId, then the geometry shader code must: write to a
    matching output variable, decorated with code:PrimitiveId, in all
    execution paths
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-PrimitiveId-06264]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, it includes a mesh shader and the
    fragment shader code reads from an input variable that is decorated with
    code:PrimitiveId, then the mesh shader code must: write to a matching
    output variable, decorated with code:PrimitiveId, in all execution paths
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06038]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE and the pipeline is
    being created with <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> the fragment shader must: not read from any
    input attachment that is defined as ename:VK_ATTACHMENT_UNUSED in
    pname:subpass
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00742]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and multiple pre-rasterization shader
    stages are included in pname:pStages, the shader code for the entry
    points identified by those pname:pStages and the rest of the state
    identified by this structure must: adhere to the pipeline linking rules
    described in the <<interfaces,Shader Interfaces>> chapter
  * [[VUID-VkGraphicsPipelineCreateInfo-None-04889]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>,
    the fragment shader and last
    <<pipelines-graphics-subsets-pre-rasterization,pre-rasterization shader
    stage>> and any relevant state must: adhere to the pipeline linking
    rules described in the <<interfaces,Shader Interfaces>> chapter
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06041]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, and the pipeline is
    being created with <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, then for each color attachment in the
    subpass, if the <<potential-format-features,potential format features>>
    of the format of the corresponding attachment description do not contain
    ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the
    pname:blendEnable member of the corresponding element of the
    pname:pAttachments member of pname:pColorBlendState must: be
    ename:VK_FALSE
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-07609]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipelines-graphics-subsets-fragment-output, fragment
    output interface state>>, the pname:pColorBlendState pointer is not
    `NULL`, the pname:attachmentCount member of pname:pColorBlendState is
    not ignored, and the subpass uses color attachments, the
    pname:attachmentCount member of pname:pColorBlendState must: be equal to
    the pname:colorAttachmentCount used to create pname:subpass
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04130]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and pname:pViewportState->pViewports
    is not dynamic, then pname:pViewportState->pViewports must: be a valid
    pointer to an array of pname:pViewportState->viewportCount valid
    sname:VkViewport structures
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04131]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and pname:pViewportState->pScissors is
    not dynamic, then pname:pViewportState->pScissors must: be a valid
    pointer to an array of pname:pViewportState->scissorCount sname:VkRect2D
    structures
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00749]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and the <<features-wideLines,
    pname:wideLines>> feature is not enabled, and no element of the
    pname:pDynamicStates member of pname:pDynamicState is
    ename:VK_DYNAMIC_STATE_LINE_WIDTH, the pname:lineWidth member of
    pname:pRasterizationState must: be `1.0`
  * [[VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-09024]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
    the ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state is
    enabled or
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
    the pname:rasterizerDiscardEnable member of pname:pRasterizationState is
    ename:VK_FALSE,
ifdef::VK_EXT_extended_dynamic_state3[]
    and <<pipelines-pViewportState-null,related dynamic state is not set>>,
endif::VK_EXT_extended_dynamic_state3[]
    pname:pViewportState must: be a valid pointer to a valid
    slink:VkPipelineViewportStateCreateInfo structure
ifdef::VK_EXT_extended_dynamic_state3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pViewportState-09025]]
    If pname:pViewportState is not `NULL` it must: be a valid pointer to a
    valid slink:VkPipelineViewportStateCreateInfo structure
endif::VK_EXT_extended_dynamic_state3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pMultisampleState-09026]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>,
ifdef::VK_EXT_extended_dynamic_state3[]
    and the `apiext:VK_EXT_extended_dynamic_state3` extension is not enabled
    or any of the ename:VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT,
    ename:VK_DYNAMIC_STATE_SAMPLE_MASK_EXT, or
    ename:VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT dynamic states is
    not set, or <<features-alphaToOne,alphaToOne>> is enabled on the device
    and ename:VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT is not set,
endif::VK_EXT_extended_dynamic_state3[]
    pname:pMultisampleState must: be a valid pointer to a valid
    slink:VkPipelineMultisampleStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-pMultisampleState-09027]]
    If pname:pMultisampleState is not `NULL` it must: be a valid pointer to
    a valid slink:VkPipelineMultisampleStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-alphaToCoverageEnable-08891]]
    If the pipeline is being created with
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>,
    the
    slink:VkPipelineMultisampleStateCreateInfo::pname:alphaToCoverageEnable
    is not ignored and is ename:VK_TRUE, then the
    <<interfaces-fragmentoutput, Fragment Output Interface>> must: contain a
    variable for the alpha code:Component word in code:Location 0 at
    code:Index 0
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-09028]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipelines-graphics-subsets-fragment-shader, fragment
    shader state>>, and pname:subpass uses a depth/stencil attachment,
ifdef::VK_EXT_extended_dynamic_state3[]
    and <<pipelines-pDepthStencilState-null,related dynamic state is not
    set>>,
endif::VK_EXT_extended_dynamic_state3[]
    pname:pDepthStencilState must: be a valid pointer to a valid
    slink:VkPipelineDepthStencilStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-pDepthStencilState-09029]]
    If pname:pDepthStencilState is not `NULL` it must: be a valid pointer to
    a valid slink:VkPipelineDepthStencilStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-09030]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipelines-graphics-subsets-fragment-output, fragment
    output interface state>>, and pname:subpass uses color attachments,
ifdef::VK_EXT_extended_dynamic_state3[]
    and <<pipelines-pColorBlendState-null,related dynamic state is not
    set>>,
endif::VK_EXT_extended_dynamic_state3[]
    pname:pColorBlendState must: be a valid pointer to a valid
    slink:VkPipelineColorBlendStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00754]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, the <<features-depthBiasClamp,
    pname:depthBiasClamp>> feature is not enabled, no element of the
    pname:pDynamicStates member of pname:pDynamicState is
    ename:VK_DYNAMIC_STATE_DEPTH_BIAS, and the pname:depthBiasEnable member
    of pname:pRasterizationState is ename:VK_TRUE, the pname:depthBiasClamp
    member of pname:pRasterizationState must: be `0.0`
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-02510]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>>,
ifdef::VK_EXT_depth_range_unrestricted[]
    the `apiext:VK_EXT_depth_range_unrestricted` extension is not enabled
endif::VK_EXT_depth_range_unrestricted[]
    and no element of the pname:pDynamicStates member of pname:pDynamicState
    is ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the
    pname:depthBoundsTestEnable member of pname:pDepthStencilState is
    ename:VK_TRUE, the pname:minDepthBounds and pname:maxDepthBounds members
    of pname:pDepthStencilState must: be between `0.0` and `1.0`, inclusive
ifdef::VK_EXT_sample_locations[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07610]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> or <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, and pname:rasterizationSamples and
    pname:sampleLocationsInfo are not dynamic, and
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    included in the pname:pNext chain of pname:pMultisampleState is
    ename:VK_TRUE, pname:sampleLocationsInfo.sampleLocationGridSize.width
    must: evenly divide
    slink:VkMultisamplePropertiesEXT::pname:sampleLocationGridSize.width as
    returned by flink:vkGetPhysicalDeviceMultisamplePropertiesEXT with a
    pname:samples parameter equaling pname:rasterizationSamples
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07611]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> or <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, and pname:rasterizationSamples and
    pname:sampleLocationsInfo are not dynamic, and
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    the included in the pname:pNext chain of pname:pMultisampleState is
    ename:VK_TRUE or ename:VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT is
    used, pname:sampleLocationsInfo.sampleLocationGridSize.height must:
    evenly divide
    slink:VkMultisamplePropertiesEXT::pname:sampleLocationGridSize.height as
    returned by flink:vkGetPhysicalDeviceMultisamplePropertiesEXT with a
    pname:samples parameter equaling pname:rasterizationSamples
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07612]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> or <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, and pname:rasterizationSamples and
    pname:sampleLocationsInfo are not dynamic, and
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    included in the pname:pNext chain of pname:pMultisampleState is
    ename:VK_TRUE or ename:VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT is
    used, pname:sampleLocationsInfo.sampleLocationsPerPixel must: equal
    pname:rasterizationSamples
  * [[VUID-VkGraphicsPipelineCreateInfo-sampleLocationsEnable-01524]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>>, and the pname:sampleLocationsEnable member of a
    slink:VkPipelineSampleLocationsStateCreateInfoEXT structure included in
    the pname:pNext chain of pname:pMultisampleState is ename:VK_TRUE, the
    fragment shader code must: not statically use the extended instruction
    code:InterpolateAtSample
endif::VK_EXT_sample_locations[]
ifdef::VK_EXT_multisampled_render_to_single_sampled[]
  * [[VUID-VkGraphicsPipelineCreateInfo-multisampledRenderToSingleSampled-06853]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, and none of the
    `apiext:VK_AMD_mixed_attachment_samples` extension, the
    `apiext:VK_NV_framebuffer_mixed_samples` extension, or the
    <<features-multisampledRenderToSingleSampled,
    pname:multisampledRenderToSingleSampled>> feature are enabled,
    pname:rasterizationSamples is not dynamic, and if pname:subpass uses
    color and/or depth/stencil attachments, then the
    pname:rasterizationSamples member of pname:pMultisampleState must: be
    the same as the sample count for those subpass attachments
endif::VK_EXT_multisampled_render_to_single_sampled[]
ifdef::VK_AMD_mixed_attachment_samples[]
  * [[VUID-VkGraphicsPipelineCreateInfo-subpass-01505]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, and the
    `apiext:VK_AMD_mixed_attachment_samples` extension is enabled,
    pname:rasterizationSamples is not dynamic, and if pname:subpass uses
    color and/or depth/stencil attachments, then the
    pname:rasterizationSamples member of pname:pMultisampleState must: equal
    the maximum of the sample counts of those subpass attachments
endif::VK_AMD_mixed_attachment_samples[]
ifdef::VK_EXT_multisampled_render_to_single_sampled[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06854]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, the
    `apiext:VK_EXT_multisampled_render_to_single_sampled` extension is
    enabled, pname:rasterizationSamples is not dynamic, and pname:subpass
    has a slink:VkMultisampledRenderToSingleSampledInfoEXT structure
    included in the slink:VkSubpassDescription2::pname:pNext chain with
    pname:multisampledRenderToSingleSampledEnable equal to ename:VK_TRUE,
    then the pname:rasterizationSamples member of pname:pMultisampleState
    must: be equal to
    slink:VkMultisampledRenderToSingleSampledInfoEXT::pname:rasterizationSamples
endif::VK_EXT_multisampled_render_to_single_sampled[]
ifdef::VK_NV_framebuffer_mixed_samples[]
  * [[VUID-VkGraphicsPipelineCreateInfo-subpass-01411]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, the
    `apiext:VK_NV_framebuffer_mixed_samples` extension is enabled,
    pname:rasterizationSamples is not dynamic, and if pname:subpass has a
    depth/stencil attachment and depth test, stencil test, or depth bounds
    test are enabled, then the pname:rasterizationSamples member of
    pname:pMultisampleState must: be the same as the sample count of the
    depth/stencil attachment
  * [[VUID-VkGraphicsPipelineCreateInfo-subpass-01412]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, the
    `apiext:VK_NV_framebuffer_mixed_samples` extension is enabled,
    pname:rasterizationSamples is not dynamic, and if pname:subpass has any
    color attachments, then the pname:rasterizationSamples member of
    pname:pMultisampleState must: be greater than or equal to the sample
    count for those subpass attachments
endif::VK_NV_framebuffer_mixed_samples[]
ifdef::VK_NV_coverage_reduction_mode[]
  * [[VUID-VkGraphicsPipelineCreateInfo-coverageReductionMode-02722]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, the
    `apiext:VK_NV_coverage_reduction_mode` extension is enabled, and
    pname:rasterizationSamples is not dynamic, the coverage reduction mode
    specified by
    slink:VkPipelineCoverageReductionStateCreateInfoNV::pname:coverageReductionMode,
    the pname:rasterizationSamples member of pname:pMultisampleState and the
    sample counts for the color and depth/stencil attachments (if the
    subpass has them) must: be a valid combination returned by
    fname:vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV
endif::VK_NV_coverage_reduction_mode[]
  * [[VUID-VkGraphicsPipelineCreateInfo-subpass-00758]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, pname:rasterizationSamples is not
    dynamic, and pname:subpass does not use any color and/or depth/stencil
    attachments, then the pname:rasterizationSamples member of
    pname:pMultisampleState must: follow the rules for a
    <<renderpass-noattachments, zero-attachment subpass>>
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06046]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, pname:subpass must: be
    a valid subpass within pname:renderPass
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06047]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, pname:subpass viewMask is not `0`, and
    pname:multiviewTessellationShader is not enabled, then pname:pStages
    must: not include tessellation shaders
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06048]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, pname:subpass viewMask is not `0`, and
    pname:multiviewGeometryShader is not enabled, then pname:pStages must:
    not include a geometry shader
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06050]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE and the pipeline is
    being created with <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and pname:subpass viewMask is not `0`,
    then all of the shaders in the pipeline must: not include variables
    decorated with the code:Layer built-in decoration in their interfaces
ifdef::VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-07064]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, pname:subpass viewMask is not `0`, and
    pname:multiviewMeshShader is not enabled, then pname:pStages must: not
    include a mesh shader
endif::VK_EXT_mesh_shader[]
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-00764]]
    pname:flags must: not contain the ename:VK_PIPELINE_CREATE_DISPATCH_BASE
    flag
endif::VK_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2,VK_KHR_create_renderpass2[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-01565]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> and an input attachment was referenced by an
    pname:aspectMask at pname:renderPass creation time, the fragment shader
    must: only read from the aspects that were specified for that input
    attachment
endif::VK_VERSION_1_1,VK_KHR_maintenance2,VK_KHR_create_renderpass2[]
  * [[VUID-VkGraphicsPipelineCreateInfo-layout-01688]]
    The number of resources in pname:layout accessible to each shader stage
    that is used by the pipeline must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxPerStageResources
ifdef::VK_NV_clip_space_w_scaling[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01715]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and no element of the
    pname:pDynamicStates member of pname:pDynamicState is
    ename:VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV, and the
    pname:viewportWScalingEnable member of a
    slink:VkPipelineViewportWScalingStateCreateInfoNV structure, included in
    the pname:pNext chain of pname:pViewportState, is ename:VK_TRUE, the
    pname:pViewportWScalings member of the
    slink:VkPipelineViewportWScalingStateCreateInfoNV must: be a pointer to
    an array of
    slink:VkPipelineViewportWScalingStateCreateInfoNV::pname:viewportCount
    valid slink:VkViewportWScalingNV structures
endif::VK_NV_clip_space_w_scaling[]
ifdef::VK_NV_scissor_exclusive[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04056]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and no element of the
    pname:pDynamicStates member of pname:pDynamicState is
    ename:VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV, and if
    pname:pViewportState->pNext chain includes a
    slink:VkPipelineViewportExclusiveScissorStateCreateInfoNV structure, and
    if its pname:exclusiveScissorCount member is not `0`, then its
    pname:pExclusiveScissors member must: be a valid pointer to an array of
    pname:exclusiveScissorCount slink:VkRect2D structures
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07854]]
    If ename:VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV is included in the
    pname:pDynamicStates array then the implementation must: support at
    least pname:specVersion `2` of the `apiext:VK_NV_scissor_exclusive`
    extension
endif::VK_NV_scissor_exclusive[]
ifdef::VK_NV_shading_rate_image[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04057]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and no element of the
    pname:pDynamicStates member of pname:pDynamicState is
    ename:VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV, and if
    pname:pViewportState->pNext chain includes a
    slink:VkPipelineViewportShadingRateImageStateCreateInfoNV structure,
    then its pname:pShadingRatePalettes member must: be a valid pointer to
    an array of pname:viewportCount valid slink:VkShadingRatePaletteNV
    structures
endif::VK_NV_shading_rate_image[]
ifdef::VK_EXT_discard_rectangles[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04058]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and no element of the
    pname:pDynamicStates member of pname:pDynamicState is
    ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT, and if pname:pNext chain
    includes a slink:VkPipelineDiscardRectangleStateCreateInfoEXT structure,
    and if its pname:discardRectangleCount member is not `0`, then its
    pname:pDiscardRectangles member must: be a valid pointer to an array of
    pname:discardRectangleCount slink:VkRect2D structures
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07855]]
    If ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT is included in
    the pname:pDynamicStates array then the implementation must: support at
    least pname:specVersion `2` of the `apiext:VK_EXT_discard_rectangles`
    extension
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07856]]
    If ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT is included in the
    pname:pDynamicStates array then the implementation must: support at
    least pname:specVersion `2` of the `apiext:VK_EXT_discard_rectangles`
    extension
endif::VK_EXT_discard_rectangles[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-02097]]
    If the pipeline requires <<pipelines-graphics-subsets-vertex-input,
    vertex input state>>, and pname:pVertexInputState is not dynamic, then
    pname:pVertexInputState must: be a valid pointer to a valid
    slink:VkPipelineVertexInputStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-Input-07904]]
    If the pipeline is being created with
    <<pipelines-graphics-subsets-vertex-input, vertex input state>> and
    pname:pVertexInputState is not dynamic, then all variables with the
    code:Input storage class decorated with code:Location in the code:Vertex
    {ExecutionModel} code:OpEntryPoint must: contain a location in
    slink:VkVertexInputAttributeDescription::pname:location
  * [[VUID-VkGraphicsPipelineCreateInfo-Input-08733]]
    If the pipeline requires <<pipelines-graphics-subsets-vertex-input,
    vertex input state>> and pname:pVertexInputState is not dynamic, then
    the numeric type associated with all code:Input variables of the
    corresponding code:Location in the code:Vertex {ExecutionModel}
    code:OpEntryPoint must: be the same as
    slink:VkVertexInputAttributeDescription::pname:format
  * [[VUID-VkGraphicsPipelineCreateInfo-pVertexInputState-08929]]
    If the pipeline is being created with
    <<pipelines-graphics-subsets-vertex-input, vertex input state>> and
    pname:pVertexInputState is not dynamic, and
    slink:VkVertexInputAttributeDescription::pname:format has a 64-bit
    component, then the scalar width associated with all code:Input
    variables of the corresponding code:Location in the code:Vertex
    {ExecutionModel} code:OpEntryPoint must: be 64-bit
  * [[VUID-VkGraphicsPipelineCreateInfo-pVertexInputState-08930]]
    If the pipeline is being created with
    <<pipelines-graphics-subsets-vertex-input, vertex input state>> and
    pname:pVertexInputState is not dynamic, and the scalar width associated
    with a code:Location decorated code:Input variable in the code:Vertex
    {ExecutionModel} code:OpEntryPoint is 64-bit, then the corresponding
    slink:VkVertexInputAttributeDescription::pname:format must: have a
    64-bit component
  * [[VUID-VkGraphicsPipelineCreateInfo-pVertexInputState-09198]]
    If the pipeline is being created with
    <<pipelines-graphics-subsets-vertex-input, vertex input state>> and
    pname:pVertexInputState is not dynamic, and
    slink:VkVertexInputAttributeDescription::pname:format has a 64-bit
    component, then all code:Input variables at the corresponding
    code:Location in the code:Vertex {ExecutionModel} code:OpEntryPoint
    must: not use components that are not present in the format
  * [[VUID-VkGraphicsPipelineCreateInfo-dynamicPrimitiveTopologyUnrestricted-09031]]
    If the pipeline requires <<pipelines-graphics-subsets-vertex-input,
    vertex input state>>,
ifdef::VK_EXT_extended_dynamic_state3[]
    and <<pipelines-pInputAssemblyState-null,related dynamic state is not
    set>>,
endif::VK_EXT_extended_dynamic_state3[]
    pname:pInputAssemblyState must: be a valid pointer to a valid
    slink:VkPipelineInputAssemblyStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-pInputAssemblyState-09032]]
    If pname:pInputAssemblyState is not `NULL` it must: be a valid pointer
    to a valid slink:VkPipelineInputAssemblyStateCreateInfo structure
ifdef::VK_EXT_transform_feedback[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-02317]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, the code:Xfb execution mode can: be
    specified by no more than one shader stage in pname:pStages
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-02318]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and any shader stage in pname:pStages
    specifies code:Xfb execution mode it must: be the last
    <<pipelines-graphics-subsets-pre-rasterization,pre-rasterization shader
    stage>>
  * [[VUID-VkGraphicsPipelineCreateInfo-rasterizationStream-02319]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and a
    slink:VkPipelineRasterizationStateStreamCreateInfoEXT::pname:rasterizationStream
    value other than zero is specified, all variables in the output
    interface of the entry point being compiled decorated with
    code:Position, code:PointSize, code:ClipDistance, or code:CullDistance
    must: be decorated with identical code:Stream values that match the
    pname:rasterizationStream
  * [[VUID-VkGraphicsPipelineCreateInfo-rasterizationStream-02320]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and
    slink:VkPipelineRasterizationStateStreamCreateInfoEXT::pname:rasterizationStream
    is zero, or not specified, all variables in the output interface of the
    entry point being compiled decorated with code:Position, code:PointSize,
    code:ClipDistance, or code:CullDistance must: be decorated with a
    code:Stream value of zero, or must: not specify the code:Stream
    decoration
  * [[VUID-VkGraphicsPipelineCreateInfo-geometryStreams-02321]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and the last
    <<pipelines-graphics-subsets-pre-rasterization,pre-rasterization shader
    stage>> is a geometry shader, and that geometry shader uses the
    code:GeometryStreams capability, then
    sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT::pname:geometryStreams
    feature must: be enabled
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-None-02322]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and there are any mesh shader stages
    in the pipeline there must: not be any shader stage in the pipeline with
    a code:Xfb execution mode
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
endif::VK_EXT_transform_feedback[]
ifdef::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
  * [[VUID-VkGraphicsPipelineCreateInfo-lineRasterizationMode-02766]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and at least one of
    <<pipelines-graphics-subsets-fragment-output, fragment output interface
    state>> or <<pipelines-graphics-subsets-fragment-shader, fragment shader
    state>>, and pname:pMultisampleState is not `NULL`, the
    pname:lineRasterizationMode member of a
    slink:VkPipelineRasterizationLineStateCreateInfoKHR structure included
    in the pname:pNext chain of pname:pRasterizationState is
    ename:VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR or
    ename:VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR, then the
    pname:alphaToCoverageEnable, pname:alphaToOneEnable, and
    pname:sampleShadingEnable members of pname:pMultisampleState must: all
    be ename:VK_FALSE
  * [[VUID-VkGraphicsPipelineCreateInfo-stippledLineEnable-02767]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, the pname:stippledLineEnable member of
    slink:VkPipelineRasterizationLineStateCreateInfoKHR is ename:VK_TRUE,
    and no element of the pname:pDynamicStates member of pname:pDynamicState
    is ename:VK_DYNAMIC_STATE_LINE_STIPPLE_EXT, then the
    pname:lineStippleFactor member of
    slink:VkPipelineRasterizationLineStateCreateInfoKHR must: be in the
    range [eq]#[1,256]#
endif::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03372]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03373]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03374]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03375]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03376]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03377]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03577]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_ray_tracing_motion_blur[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-04947]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03378]]
    If
ifdef::VK_EXT_extended_dynamic_state[]
    the <<features-extendedDynamicState, pname:extendedDynamicState>>
    feature is not enabled,
endif::VK_EXT_extended_dynamic_state[]
ifdef::VK_VERSION_1_3+VK_EXT_extended_dynamic_state[and]
ifdef::VK_VERSION_1_3[]
    the value of slink:VkApplicationInfo::pname:apiVersion used to create
    the slink:VkInstance is less than Version 1.3
endif::VK_VERSION_1_3[]
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to ename:VK_DYNAMIC_STATE_CULL_MODE,
    ename:VK_DYNAMIC_STATE_FRONT_FACE,
    ename:VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY,
    ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT,
    ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT,
    ename:VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE,
    ename:VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE,
    ename:VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE,
    ename:VK_DYNAMIC_STATE_DEPTH_COMPARE_OP,
    ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE,
    ename:VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE, or
    ename:VK_DYNAMIC_STATE_STENCIL_OP
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03379]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and
    ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is included in the
    pname:pDynamicStates array then pname:viewportCount must: be zero
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03380]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and
    ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT is included in the
    pname:pDynamicStates array then pname:scissorCount must: be zero
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04132]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and
    ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is included in the
    pname:pDynamicStates array then ename:VK_DYNAMIC_STATE_VIEWPORT must:
    not be present
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04133]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and
    ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT is included in the
    pname:pDynamicStates array then ename:VK_DYNAMIC_STATE_SCISSOR must: not
    be present
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07065]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and includes a mesh shader, there
    must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to ename:VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY, or
    ename:VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04868]]
    If
ifdef::VK_EXT_extended_dynamic_state[]
    the <<features-extendedDynamicState2, pname:extendedDynamicState2>>
    feature is not enabled,
endif::VK_EXT_extended_dynamic_state[]
ifdef::VK_VERSION_1_3+VK_EXT_extended_dynamic_state[and]
ifdef::VK_VERSION_1_3[]
    the value of slink:VkApplicationInfo::pname:apiVersion used to create
    the slink:VkInstance is less than Version 1.3
endif::VK_VERSION_1_3[]
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to ename:VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE,
    ename:VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE, or
    ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04869]]
    If the <<features-extendedDynamicState2LogicOp,
    pname:extendedDynamicState2LogicOp>> feature is not enabled, there must:
    be no element of the pname:pDynamicStates member of pname:pDynamicState
    set to ename:VK_DYNAMIC_STATE_LOGIC_OP_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04870]]
    If the <<features-extendedDynamicState2PatchControlPoints,
    pname:extendedDynamicState2PatchControlPoints>> feature is not enabled,
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07066]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and includes a mesh shader, there
    must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE, or
    ename:VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
ifdef::VK_NV_device_generated_commands[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-02877]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV, then the
    <<features-deviceGeneratedCommands, pname:deviceGeneratedCommands>>
    feature must: be enabled
ifdef::VK_EXT_transform_feedback[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-02966]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and pname:flags includes
    ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV, then all stages must:
    not specify code:Xfb execution mode
endif::VK_EXT_transform_feedback[]
  * [[VUID-VkGraphicsPipelineCreateInfo-libraryCount-06648]]
    If the pipeline is not created with a
    <<pipelines-graphics-subsets-complete, complete set of state>>,
ifdef::VK_EXT_graphics_pipeline_library[]
    or slink:VkPipelineLibraryCreateInfoKHR::pname:libraryCount is not `0`,
endif::VK_EXT_graphics_pipeline_library[]
    slink:VkGraphicsPipelineShaderGroupsCreateInfoNV::pname:groupCount and
    slink:VkGraphicsPipelineShaderGroupsCreateInfoNV::pname:pipelineCount
    must: be `0`
  * [[VUID-VkGraphicsPipelineCreateInfo-libraryCount-06649]]
    If the pipeline is created with a <<pipelines-graphics-subsets-complete,
    complete set of state>>,
ifdef::VK_EXT_graphics_pipeline_library[]
    and slink:VkPipelineLibraryCreateInfoKHR::pname:libraryCount is `0`,
endif::VK_EXT_graphics_pipeline_library[]
    and the pname:pNext chain includes an instance of
    slink:VkGraphicsPipelineShaderGroupsCreateInfoNV,
    slink:VkGraphicsPipelineShaderGroupsCreateInfoNV::pname:groupCount must:
    be greater than `0`
endif::VK_NV_device_generated_commands[]
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pipelineCreationCacheControl-02878]]
    If the <<features-pipelineCreationCacheControl,
    pname:pipelineCreationCacheControl>> feature is not enabled, pname:flags
    must: not include
    ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT or
    ename:VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifdef::VK_EXT_pipeline_protected_access[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pipelineProtectedAccess-07368]]
    If the <<features-pipelineProtectedAccess,
    pname:pipelineProtectedAccess>> feature is not enabled, pname:flags
    must: not include ename:VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT
    or ename:VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-07369]]
    pname:flags must: not include both
    ename:VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT and
    ename:VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT
endif::VK_EXT_pipeline_protected_access[]
ifdef::VK_KHR_fragment_shading_rate[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04494]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.width
    must: be greater than or equal to `1`
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04495]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.height
    must: be greater than or equal to `1`
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04496]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.width
    must: be a power-of-two value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04497]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.height
    must: be a power-of-two value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04498]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.width
    must: be less than or equal to `4`
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04499]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.height
    must: be less than or equal to `4`
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04500]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, and the
    <<features-pipelineFragmentShadingRate,
    pname:pipelineFragmentShadingRate>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.width
    and
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.height
    must: both be equal to `1`
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06567]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:combinerOps[0]
    must: be a valid elink:VkFragmentShadingRateCombinerOpKHR value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06568]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:combinerOps[1]
    must: be a valid elink:VkFragmentShadingRateCombinerOpKHR value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04501]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, and the
    <<features-primitiveFragmentShadingRate,
    pname:primitiveFragmentShadingRate>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:combinerOps[0]
    must: be ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04502]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, and the
    <<features-attachmentFragmentShadingRate,
    pname:attachmentFragmentShadingRate>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:combinerOps[1]
    must: be ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
  * [[VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04503]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and the
    <<limits-primitiveFragmentShadingRateWithMultipleViewports,
    pname:primitiveFragmentShadingRateWithMultipleViewports>> limit is not
    supported, ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is not included in
    pname:pDynamicState->pDynamicStates, and
    slink:VkPipelineViewportStateCreateInfo::pname:viewportCount is greater
    than `1`, entry points specified in pname:pStages must: not write to the
    code:PrimitiveShadingRateKHR built-in
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
  * [[VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04504]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and the
    <<limits-primitiveFragmentShadingRateWithMultipleViewports,
    pname:primitiveFragmentShadingRateWithMultipleViewports>> limit is not
    supported, and entry points specified in pname:pStages write to the
    code:ViewportIndex built-in, they must: not also write to the
    code:PrimitiveShadingRateKHR built-in
ifdef::VK_NV_viewport_array2[]
  * [[VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04505]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and the
    <<limits-primitiveFragmentShadingRateWithMultipleViewports,
    pname:primitiveFragmentShadingRateWithMultipleViewports>> limit is not
    supported, and entry points specified in pname:pStages write to the
    code:ViewportMaskNV built-in, they must: not also write to the
    code:PrimitiveShadingRateKHR built-in
endif::VK_NV_viewport_array2[]
  * [[VUID-VkGraphicsPipelineCreateInfo-fragmentShadingRateNonTrivialCombinerOps-04506]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>,
    the <<limits-fragmentShadingRateNonTrivialCombinerOps,
    pname:fragmentShadingRateNonTrivialCombinerOps>> limit is not supported,
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, elements of
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:combinerOps
    must: be ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or
    ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_NV_fragment_shading_rate_enums[]
  * [[VUID-VkGraphicsPipelineCreateInfo-None-06569]]
     If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
     fragment shader state>>
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:shadingRateType
    must: be a valid elink:VkFragmentShadingRateTypeNV value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06570]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:shadingRate
    must: be a valid elink:VkFragmentShadingRateNV value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06571]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:combinerOps[0]
    must: be a valid elink:VkFragmentShadingRateCombinerOpKHR value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06572]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:combinerOps[1]
    must: be a valid elink:VkFragmentShadingRateCombinerOpKHR value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04569]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, and the
    <<features-fragmentShadingRateEnums, pname:fragmentShadingRateEnums>>
    feature is not enabled,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:shadingRateType
    must: be equal to ename:VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04570]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, and the
    <<features-pipelineFragmentShadingRate,
    pname:pipelineFragmentShadingRate>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:shadingRate
    must: be equal to
    ename:VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04571]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, and the
    <<features-primitiveFragmentShadingRate,
    pname:primitiveFragmentShadingRate>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:combinerOps[0]
    must: be ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04572]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, and the
    <<features-attachmentFragmentShadingRate,
    pname:attachmentFragmentShadingRate>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:combinerOps[1]
    must: be ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-fragmentShadingRateNonTrivialCombinerOps-04573]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>>, and the
    <<limits-fragmentShadingRateNonTrivialCombinerOps,
    pname:fragmentShadingRateNonTrivialCombinerOps>> limit is not supported
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, elements of
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:combinerOps
    must: be ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or
    ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-None-04574]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>>, and the
    <<features-supersampleFragmentShadingRates,
    pname:supersampleFragmentShadingRates>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:shadingRate
    must: not be equal to
    ename:VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV,
    ename:VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV,
    ename:VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV, or
    ename:VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-None-04575]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>>, and the
    <<features-noInvocationFragmentShadingRates,
    pname:noInvocationFragmentShadingRates>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:shadingRate
    must: not be equal to ename:VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV
endif::VK_NV_fragment_shading_rate_enums[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03578]]
    All elements of the pname:pDynamicStates member of pname:pDynamicState
    must: not be ename:VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_EXT_vertex_input_dynamic_state[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04807]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> and the
    <<features-vertexInputDynamicState, pname:vertexInputDynamicState>>
    feature is not enabled, there must: be no element of the
    pname:pDynamicStates member of pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_VERTEX_INPUT_EXT
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07067]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and includes a mesh shader, there
    must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to ename:VK_DYNAMIC_STATE_VERTEX_INPUT_EXT
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
endif::VK_EXT_vertex_input_dynamic_state[]
ifdef::VK_EXT_color_write_enable[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04800]]
    If the <<features-colorWriteEnable, pname:colorWriteEnable>> feature is
    not enabled, there must: be no element of the pname:pDynamicStates
    member of pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT
endif::VK_EXT_color_write_enable[]
ifdef::VK_QCOM_render_pass_shader_resolve[]
  * [[VUID-VkGraphicsPipelineCreateInfo-rasterizationSamples-04899]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>>, and the
    `apiext:VK_QCOM_render_pass_shader_resolve` extension is enabled,
    pname:rasterizationSamples is not dynamic, and if subpass has any input
    attachments, and if the subpass description contains
    ename:VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM, then the sample
    count of the input attachments must: equal pname:rasterizationSamples
  * [[VUID-VkGraphicsPipelineCreateInfo-sampleShadingEnable-04900]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>>, and the
    `apiext:VK_QCOM_render_pass_shader_resolve` extension is enabled, and if
    the subpass description contains
    ename:VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM, then
    pname:sampleShadingEnable must: be false
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-04901]]
    If pname:flags includes
    ename:VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM, then the subpass
    must: be the last subpass in a subpass dependency chain
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-04902]]
    If pname:flags includes
    ename:VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM, and if
    pname:pResolveAttachments is not `NULL`, then each resolve attachment
    must: be ename:VK_ATTACHMENT_UNUSED
endif::VK_QCOM_render_pass_shader_resolve[]
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-dynamicRendering-06576]]
    If the <<features-dynamicRendering, pname:dynamicRendering>> feature is
    not enabled and the pipeline requires
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, <<pipelines-graphics-subsets-fragment-shader, fragment shader
    state>>, or <<pipelines-graphics-subsets-fragment-output, fragment
    output interface state>>, pname:renderPass must: not be
    dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-multiview-06577]]
    If the <<features-multiview, pname:multiview>> feature is not enabled,
    the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>,
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>,
    or <<pipelines-graphics-subsets-fragment-output, fragment output
    interface state>>, and pname:renderPass is dlink:VK_NULL_HANDLE,
    slink:VkPipelineRenderingCreateInfo::pname:viewMask must: be `0`
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06578]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>,
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>,
    or <<pipelines-graphics-subsets-fragment-output, fragment output
    interface state>>, and pname:renderPass is dlink:VK_NULL_HANDLE, the
    index of the most significant bit in
    slink:VkPipelineRenderingCreateInfo::pname:viewMask must: be less than
    <<limits-maxMultiviewViewCount, pname:maxMultiviewViewCount>>
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06579]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, and pname:renderPass is
    dlink:VK_NULL_HANDLE, and
    slink:VkPipelineRenderingCreateInfo::pname:colorAttachmentCount is not
    0, slink:VkPipelineRenderingCreateInfo::pname:pColorAttachmentFormats
    must: be a valid pointer to an array of pname:colorAttachmentCount valid
    elink:VkFormat values
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06580]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, and pname:renderPass is
    dlink:VK_NULL_HANDLE, each element of
    slink:VkPipelineRenderingCreateInfo::pname:pColorAttachmentFormats must:
    be a valid elink:VkFormat value
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06582]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, pname:renderPass is
    dlink:VK_NULL_HANDLE, and any element of
    slink:VkPipelineRenderingCreateInfo::pname:pColorAttachmentFormats is
    not ename:VK_FORMAT_UNDEFINED, that format must: be a format with
    <<potential-format-features, potential format features>> that include
    ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT
ifdef::VK_NV_linear_color_attachment[]
    or ename:VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV
endif::VK_NV_linear_color_attachment[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06583]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, and pname:renderPass is
    dlink:VK_NULL_HANDLE,
    slink:VkPipelineRenderingCreateInfo::pname:depthAttachmentFormat must:
    be a valid elink:VkFormat value
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06584]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, and pname:renderPass is
    dlink:VK_NULL_HANDLE,
    slink:VkPipelineRenderingCreateInfo::pname:stencilAttachmentFormat must:
    be a valid elink:VkFormat value
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06585]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, pname:renderPass is
    dlink:VK_NULL_HANDLE, and
    slink:VkPipelineRenderingCreateInfo::pname:depthAttachmentFormat is not
    ename:VK_FORMAT_UNDEFINED, it must: be a format with
    <<potential-format-features, potential format features>> that include
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06586]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, pname:renderPass is
    dlink:VK_NULL_HANDLE, and
    slink:VkPipelineRenderingCreateInfo::pname:stencilAttachmentFormat is
    not ename:VK_FORMAT_UNDEFINED, it must: be a format with
    <<potential-format-features, potential format features>> that include
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06587]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, pname:renderPass is
    dlink:VK_NULL_HANDLE, and
    slink:VkPipelineRenderingCreateInfo::pname:depthAttachmentFormat is not
    ename:VK_FORMAT_UNDEFINED, it must: be a format that includes a depth
    component
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06588]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, pname:renderPass is
    dlink:VK_NULL_HANDLE, and
    slink:VkPipelineRenderingCreateInfo::pname:stencilAttachmentFormat is
    not ename:VK_FORMAT_UNDEFINED, it must: be a format that includes a
    stencil component
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06589]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, pname:renderPass is
    dlink:VK_NULL_HANDLE,
    slink:VkPipelineRenderingCreateInfo::pname:depthAttachmentFormat is not
    ename:VK_FORMAT_UNDEFINED, and
    slink:VkPipelineRenderingCreateInfo::pname:stencilAttachmentFormat is
    not ename:VK_FORMAT_UNDEFINED, pname:depthAttachmentFormat must: equal
    pname:stencilAttachmentFormat
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-09033]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipelines-graphics-subsets-fragment-shader, fragment
    shader state>> and <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, and either of
    slink:VkPipelineRenderingCreateInfo::pname:depthAttachmentFormat or
    slink:VkPipelineRenderingCreateInfo::pname:stencilAttachmentFormat are
    not ename:VK_FORMAT_UNDEFINED,
ifdef::VK_EXT_extended_dynamic_state3[]
    and the `apiext:VK_EXT_extended_dynamic_state3` extension is not enabled
    or any of the ename:VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE,
    ename:VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE,
    ename:VK_DYNAMIC_STATE_DEPTH_COMPARE_OP,
    ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE,
    ename:VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE,
    ename:VK_DYNAMIC_STATE_STENCIL_OP, or
    ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS dynamic states are not set,
endif::VK_EXT_extended_dynamic_state3[]
    pname:pDepthStencilState must: be a valid pointer to a valid
    slink:VkPipelineDepthStencilStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-pDepthStencilState-09034]]
    If pname:pDepthStencilState is not `NULL` it must: be a valid pointer to
    a valid slink:VkPipelineDepthStencilStateCreateInfo structure
ifdef::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-09035]]
    If pname:renderPass is dlink:VK_NULL_HANDLE and the pipeline is being
    created with <<pipelines-graphics-subsets-fragment-shader, fragment
    shader state>> but not <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>,
ifdef::VK_EXT_extended_dynamic_state3[]
    and the `apiext:VK_EXT_extended_dynamic_state3` extension is not
    enabled, or any of the ename:VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE,
    ename:VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE,
    ename:VK_DYNAMIC_STATE_DEPTH_COMPARE_OP,
    ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE,
    ename:VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE,
    ename:VK_DYNAMIC_STATE_STENCIL_OP, or
    ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS dynamic states are not set,
endif::VK_EXT_extended_dynamic_state3[]
    pname:pDepthStencilState must: be a valid pointer to a valid
    slink:VkPipelineDepthStencilStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-pDepthStencilState-09036]]
    If pname:pDepthStencilState is not `NULL` it must: be a valid pointer to
    a valid slink:VkPipelineDepthStencilStateCreateInfo structure
endif::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-09037]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipelines-graphics-subsets-fragment-output, fragment
    output interface state>>, and any element of
    slink:VkPipelineRenderingCreateInfo::pname:pColorAttachmentFormats is
    not ename:VK_FORMAT_UNDEFINED,
ifdef::VK_EXT_extended_dynamic_state3[]
    and the `apiext:VK_EXT_extended_dynamic_state3` extension is not
    enabled, or any of the ename:VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT,
    ename:VK_DYNAMIC_STATE_LOGIC_OP_EXT,
    ename:VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT,
    ename:VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT,
    ename:VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, or
    ename:VK_DYNAMIC_STATE_BLEND_CONSTANTS dynamic states are not set,
endif::VK_EXT_extended_dynamic_state3[]
    pname:pColorBlendState must: be a valid pointer to a valid
    slink:VkPipelineColorBlendStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-pColorBlendState-09038]]
    If pname:pColorBlendState is not `NULL` it must: be a valid pointer to a
    valid slink:VkPipelineColorBlendStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06055]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, pname:pColorBlendState is
    not dynamic, and the pipeline is being created with
    <<pipelines-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:pColorBlendState->attachmentCount must: be equal to
    slink:VkPipelineRenderingCreateInfo::pname:colorAttachmentCount
ifdef::VK_KHR_multiview,VK_VERSION_1_1[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06057]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>,
    slink:VkPipelineRenderingCreateInfo::pname:viewMask is not `0`, and the
    <<features-multiview-tess, pname:multiviewTessellationShader>> feature
    is not enabled, then pname:pStages must: not include tessellation
    shaders
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06058]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>,
    slink:VkPipelineRenderingCreateInfo::pname:viewMask is not `0`, and the
    <<features-multiview-gs, pname:multiviewGeometryShader>> feature is not
    enabled, then pname:pStages must: not include a geometry shader
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06059]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and
    slink:VkPipelineRenderingCreateInfo::pname:viewMask is not `0`, all of
    the shaders in the pipeline must: not include variables decorated with
    the code:Layer built-in decoration in their interfaces
ifdef::VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-07720]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and
    slink:VkPipelineRenderingCreateInfo::pname:viewMask is not `0`, and
    pname:multiviewMeshShader is not enabled, then pname:pStages must: not
    include a mesh shader
endif::VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06061]]
    If
ifdef::VK_KHR_dynamic_rendering_local_read[]
    the <<features-dynamicRenderingLocalRead,
    pname:dynamicRenderingLocalRead>> feature is not enabled,
endif::VK_KHR_dynamic_rendering_local_read[]
    the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>>, and pname:renderPass is dlink:VK_NULL_HANDLE,
    fragment shaders in pname:pStages must: not include the
    code:InputAttachment capability
ifdef::VK_EXT_shader_tile_image[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-08710]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> and pname:renderPass is not
    dlink:VK_NULL_HANDLE, fragment shaders in pname:pStages must: not
    include any of the code:TileImageColorReadAccessEXT,
    code:TileImageDepthReadAccessEXT, or code:TileImageStencilReadAccessEXT
    capabilities
endif::VK_EXT_shader_tile_image[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06062]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>> and pname:renderPass is
    dlink:VK_NULL_HANDLE, for each color attachment format defined by the
    pname:pColorAttachmentFormats member of
    slink:VkPipelineRenderingCreateInfo, if its
    <<potential-format-features,potential format features>> do not contain
    ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the
    pname:blendEnable member of the corresponding element of the
    pname:pAttachments member of pname:pColorBlendState must: be
    ename:VK_FALSE
endif::VK_KHR_multiview,VK_VERSION_1_1[]
ifdef::VK_AMD_mixed_attachment_samples,VK_NV_framebuffer_mixed_samples[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06063]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>> and pname:renderPass is
    dlink:VK_NULL_HANDLE, if the pname:pNext chain includes
    slink:VkAttachmentSampleCountInfoAMD or
    sname:VkAttachmentSampleCountInfoNV, the pname:colorAttachmentCount
    member of that structure must: be equal to the value of
    slink:VkPipelineRenderingCreateInfo::pname:colorAttachmentCount
endif::VK_AMD_mixed_attachment_samples,VK_NV_framebuffer_mixed_samples[]
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_EXT_rasterization_order_attachment_access,VK_ARM_rasterization_order_attachment_access[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06591]]
    If pname:pStages includes a fragment shader stage, and the fragment
    shader declares the code:EarlyFragmentTests execution mode, the
    pname:flags member of slink:VkPipelineDepthStencilStateCreateInfo must:
    not include
    ename:VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT
    or
    ename:VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06482]]
    If
ifdef::VK_KHR_dynamic_rendering_local_read[]
    the <<features-dynamicRenderingLocalRead,
    pname:dynamicRenderingLocalRead>> feature is not enabled,
endif::VK_KHR_dynamic_rendering_local_read[]
    the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, and the pname:flags member of
    slink:VkPipelineColorBlendStateCreateInfo includes
    ename:VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT,
    pname:renderPass must: not be dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-None-09526]]
    If
ifdef::VK_KHR_dynamic_rendering_local_read[]
    the <<features-dynamicRenderingLocalRead,
    pname:dynamicRenderingLocalRead>> feature is not enabled,
endif::VK_KHR_dynamic_rendering_local_read[]
    the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, and the pname:flags member of
    slink:VkPipelineDepthStencilStateCreateInfo includes
    ename:VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT
    or
    ename:VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT,
    pname:renderPass must: not be dlink:VK_NULL_HANDLE
ifdef::VK_AMD_mixed_attachment_samples,VK_NV_framebuffer_mixed_samples[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pColorAttachmentSamples-06592]]
    If the <<pipelines-graphics-subsets-fragment-output, fragment output
    interface state>>, elements of the pname:pColorAttachmentSamples member
    of slink:VkAttachmentSampleCountInfoAMD or
    slink:VkAttachmentSampleCountInfoNV must: be valid
    elink:VkSampleCountFlagBits values
  * [[VUID-VkGraphicsPipelineCreateInfo-depthStencilAttachmentSamples-06593]]
    If the <<pipelines-graphics-subsets-fragment-output, fragment output
    interface state>> and the pname:depthStencilAttachmentSamples member of
    slink:VkAttachmentSampleCountInfoAMD or
    slink:VkAttachmentSampleCountInfoNV is not 0, it must: be a valid
    elink:VkSampleCountFlagBits value
endif::VK_AMD_mixed_attachment_samples,VK_NV_framebuffer_mixed_samples[]
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-09527]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-output,
    fragment output interface state>>, pname:renderPass is not
    dlink:VK_NULL_HANDLE, and the pname:flags member of
    slink:VkPipelineColorBlendStateCreateInfo includes
    ename:VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT
    pname:subpass must: have been created with
    ename:VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-09528]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>>, pname:renderPass is not dlink:VK_NULL_HANDLE,
    and the pname:flags member of
    slink:VkPipelineDepthStencilStateCreateInfo includes
    ename:VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT,
    pname:subpass must: have been created with
    ename:VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-09529]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>>, pname:renderPass is not dlink:VK_NULL_HANDLE,
    and the pname:flags member of
    slink:VkPipelineDepthStencilStateCreateInfo includes
    ename:VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT,
    pname:subpass must: have been created with
    ename:VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT
endif::VK_EXT_rasterization_order_attachment_access,VK_ARM_rasterization_order_attachment_access[]
ifdef::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pipelineStageCreationFeedbackCount-06594]]
    If
    slink:VkPipelineCreationFeedbackCreateInfo::pname:pipelineStageCreationFeedbackCount
    is not `0`, it must: be equal to pname:stageCount
endif::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
ifdef::VK_NVX_multiview_per_view_attributes[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06595]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>,
    and
    slink:VkMultiviewPerViewAttributesInfoNVX::pname:perViewAttributesPositionXOnly
    is ename:VK_TRUE then
    slink:VkMultiviewPerViewAttributesInfoNVX::pname:perViewAttributes must:
    also be ename:VK_TRUE
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06596]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes the other flag, the value of
    slink:VkMultiviewPerViewAttributesInfoNVX::pname:perViewAttributes
    specified in both this pipeline and the library must: be equal
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06597]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, the value of
    slink:VkMultiviewPerViewAttributesInfoNVX::pname:perViewAttributes
    specified in both libraries must: be equal
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06598]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes the other flag, the value of
    slink:VkMultiviewPerViewAttributesInfoNVX::pname:perViewAttributesPositionXOnly
    specified in both this pipeline and the library must: be equal
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06599]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, the value of
    slink:VkMultiviewPerViewAttributesInfoNVX::pname:perViewAttributesPositionXOnly
    specified in both libraries must: be equal
endif::VK_NVX_multiview_per_view_attributes[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-06600]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>,
    pname:pStages must: be a valid pointer to an array of pname:stageCount
    valid slink:VkPipelineShaderStageCreateInfo structures
  * [[VUID-VkGraphicsPipelineCreateInfo-stageCount-09587]]
    If the pipeline does not require
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> or <<pipelines-graphics-subsets-fragment-shader, fragment shader
    state>>, pname:stageCount must: be zero
  * [[VUID-VkGraphicsPipelineCreateInfo-pRasterizationState-06601]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>,
ifdef::VK_EXT_extended_dynamic_state3[]
    and <<pipelines-pRasterizationState-null,related dynamic state is not
    set>>,
endif::VK_EXT_extended_dynamic_state3[]
    pname:pRasterizationState must: be a valid pointer to a valid
    slink:VkPipelineRasterizationStateCreateInfo structure
ifdef::VK_EXT_extended_dynamic_state3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pRasterizationState-09039]]
    If
ifdef::VK_EXT_graphics_pipeline_library[]
    slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    and
endif::VK_EXT_graphics_pipeline_library[]
    <<pipelines-pMultisampleState-null,related dynamic state is not set>>,
    then pname:pMultisampleState must: be a valid pointer to a valid
    slink:VkPipelineMultisampleStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-pRasterizationState-09040]]
    If pname:pRasterizationState is not `NULL` it must: be a valid pointer
    to a valid slink:VkPipelineRasterizationStateCreateInfo structure
endif::VK_EXT_extended_dynamic_state3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-layout-06602]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> or
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, pname:layout must: be a valid slink:VkPipelineLayout handle
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06603]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>,
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>,
    or <<pipelines-graphics-subsets-fragment-output, fragment output
    state>>,
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
    and pname:renderPass is not dlink:VK_NULL_HANDLE,
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
    pname:renderPass must: be a valid slink:VkRenderPass handle
  * [[VUID-VkGraphicsPipelineCreateInfo-stageCount-09530]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, pname:stageCount must: be greater than
    `0`
ifdef::VK_KHR_pipeline_library[]
  * [[VUID-VkGraphicsPipelineCreateInfo-graphicsPipelineLibrary-06606]]
ifdef::VK_EXT_graphics_pipeline_library[]
    If the <<features-graphicsPipelineLibrary,
    pname:graphicsPipelineLibrary>> feature is not enabled,
endif::VK_EXT_graphics_pipeline_library[]
    pname:flags must: not include ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
endif::VK_KHR_pipeline_library[]
ifdef::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06608]]
    If the pipeline defines, or includes as libraries, all the state subsets
    required for a <<pipelines-graphics-subsets-complete, complete graphics
    pipeline>>, pname:flags must: not include
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06609]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT, pipeline
    libraries included via slink:VkPipelineLibraryCreateInfoKHR must: have
    been created with
    ename:VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-09245]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT,
    pname:flags must: also include ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06610]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT,
    pipeline libraries included via slink:VkPipelineLibraryCreateInfoKHR
    must: have been created with
    ename:VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06611]]
    Any pipeline libraries included via
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries must: not include
    any <<pipelines-graphics-subsets, state subset>> already defined by this
    structure or defined by any other pipeline library in
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06612]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes the other flag, and pname:layout was not created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then the
    pname:layout used by this pipeline and the library must: be _identically
    defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06613]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and the
    pname:layout specified by either library was not created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then the
    pname:layout used by each library must: be _identically defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06614]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes the
    other subset, and pname:layout was created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then the
    pname:layout used by the library must: also have been created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06615]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and the
    pname:layout specified by either library was created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then the
    pname:layout used by both libraries must: have been created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06616]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes the
    other subset, and pname:layout was created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, elements of
    the pname:pSetLayouts array which pname:layout was created with that are
    not dlink:VK_NULL_HANDLE must: be _identically defined_ to the element
    at the same index of pname:pSetLayouts used to create the library's
    pname:layout
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06617]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and the
    pname:layout specified by either library was created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, elements of
    the pname:pSetLayouts array which either pname:layout was created with
    that are not dlink:VK_NULL_HANDLE must: be _identically defined_ to the
    element at the same index of pname:pSetLayouts used to create the other
    library's pname:layout
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06618]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes the other flag, any descriptor set layout _N_ specified by
    pname:layout in both this pipeline and the library which include
    bindings accessed by shader stages in each must: be _identically
    defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06619]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, any
    descriptor set layout _N_ specified by pname:layout in both libraries
    which include bindings accessed by shader stages in each must: be
    _identically defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06620]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes the other flag, push constants specified in pname:layout in
    both this pipeline and the library which are available to shader stages
    in each must: be _identically defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06621]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, push
    constants specified in pname:layout in both this pipeline and the
    library which are available to shader stages in each must: be
    _identically defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06679]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes the
    other subset, any element of the pname:pSetLayouts array when
    pname:layout was created and the corresponding element of the
    pname:pSetLayouts array used to create the library's pname:layout must:
    not both be dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06681]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and any
    element of the pname:pSetLayouts array used to create each library's
    pname:layout was dlink:VK_NULL_HANDLE, then the corresponding element of
    the pname:pSetLayouts array used to create the other library's
    pname:layout must: not be dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06756]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes the
    other subset, and any element of the pname:pSetLayouts array which
    pname:layout was created with was dlink:VK_NULL_HANDLE, then the
    corresponding element of the pname:pSetLayouts array used to create the
    library's pname:layout must: not have shader bindings for shaders in the
    other subset
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06757]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes the
    other subset, and any element of the pname:pSetLayouts array used to
    create the library's pname:layout was dlink:VK_NULL_HANDLE, then the
    corresponding element of the pname:pSetLayouts array used to create this
    pipeline's pname:layout must: not have shader bindings for shaders in
    the other subset
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06758]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and any
    element of the pname:pSetLayouts array used to create each library's
    pname:layout was dlink:VK_NULL_HANDLE, then the corresponding element of
    the pname:pSetLayouts array used to create the other library's
    pname:layout must: not have shader bindings for shaders in the other
    subset
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06682]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    both
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, pname:layout
    must: have been created with no elements of the pname:pSetLayouts array
    set to dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06683]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    pname:pRasterizationState->rasterizerDiscardEnable is ename:VK_TRUE,
    pname:layout must: have been created with no elements of the
    pname:pSetLayouts array set to dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06684]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes at
    least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    and an element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes one of the other flags, the value of pname:subpass must: be
    equal to that used to create the library
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06623]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes at least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    and another element of
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes one of
    the other flags, the value of pname:subpass used to create each library
    must: be identical
  * [[VUID-VkGraphicsPipelineCreateInfo-renderpass-06624]]
    If pname:renderpass is not dlink:VK_NULL_HANDLE,
    slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes at
    least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    and an element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes one of the other flags, pname:renderPass must: be compatible
    with that used to create the library
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderpass-06625]]
    If pname:renderpass is dlink:VK_NULL_HANDLE,
    slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes at
    least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    and an element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes one of the other flags, the value of pname:renderPass used to
    create that library must: also be dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06626]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes at
    least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes one of the other flags, and pname:renderPass is
    dlink:VK_NULL_HANDLE, the value of
    slink:VkPipelineRenderingCreateInfo::pname:viewMask used by this
    pipeline and that specified by the library must: be identical
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06627]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes at least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    another element of
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes one of
    the other flags, and pname:renderPass was dlink:VK_NULL_HANDLE for both
    libraries, the value of
    slink:VkPipelineRenderingCreateInfo::pname:viewMask set by each library
    must: be identical
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06628]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes at least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    and another element of
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes one of
    the other flags, the pname:renderPass objects used to create each
    library must: be compatible or all equal to dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-renderpass-06631]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, the pipeline requires
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>,
ifdef::VK_EXT_extended_dynamic_state3[]
    and the `apiext:VK_EXT_extended_dynamic_state3` extension is not enabled
    or any of the ename:VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT,
    ename:VK_DYNAMIC_STATE_SAMPLE_MASK_EXT, or
    ename:VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT dynamic states is
    not set, or <<features-alphaToOne,alphaToOne>> is enabled on the device
    and ename:VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT is not set,
endif::VK_EXT_extended_dynamic_state3[]
    then pname:pMultisampleState must: be a valid pointer to a valid
    slink:VkPipelineMultisampleStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-Input-06632]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> with a fragment shader that either enables
    <<primsrast-sampleshading, sample shading>> or decorates any variable in
    the code:Input storage class with code:Sample,
ifdef::VK_EXT_extended_dynamic_state3[]
    and the `apiext:VK_EXT_extended_dynamic_state3` extension is not enabled
    or any of the ename:VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT,
    ename:VK_DYNAMIC_STATE_SAMPLE_MASK_EXT, or
    ename:VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT dynamic states is
    not set, or <<features-alphaToOne,alphaToOne>> is enabled on the device
    and ename:VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT is not set,
endif::VK_EXT_extended_dynamic_state3[]
    then pname:pMultisampleState must: be a valid pointer to a valid
    slink:VkPipelineMultisampleStateCreateInfo structure
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06633]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT with a
    pname:pMultisampleState that was not `NULL`, and an element of
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries was created with
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    pname:pMultisampleState must: be _identically defined_ to that used to
    create the library
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06634]]
    If an element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    was created with
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT with a
    pname:pMultisampleState that was not `NULL`, and if
    slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    pname:pMultisampleState must: be _identically defined_ to that used to
    create the library
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06635]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    was created with
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT with a
    pname:pMultisampleState that was not `NULL`, and if a different element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries was created
    with
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    the pname:pMultisampleState used to create each library must: be
    _identically defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06636]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    was created with
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT and
    a value of pname:pMultisampleState->sampleShadingEnable equal
    ename:VK_TRUE, and if a different element of
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries was created with
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, the
    pname:pMultisampleState used to create each library must: be
    _identically defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06637]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    pname:pMultisampleState->sampleShadingEnable is ename:VK_TRUE, and an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries was
    created with ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT,
    pname:pMultisampleState must: be _identically defined_ to that used to
    create the library
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-09567]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    was created with
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT and
    a value of pname:pMultisampleState->sampleShadingEnable equal
    ename:VK_TRUE, and if
    slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT,
    pname:pMultisampleState must: be _identically defined_ to that used to
    create the library
ifdef::VK_KHR_fragment_shading_rate[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06638]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes the other flag, values specified in
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR for both this
    pipeline and that library must: be identical
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06639]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, values
    specified in slink:VkPipelineFragmentShadingRateStateCreateInfoKHR for
    both this pipeline and that library must: be identical
endif::VK_KHR_fragment_shading_rate[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06640]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT,
    pname:pStages must: be a valid pointer to an array of pname:stageCount
    valid slink:VkPipelineShaderStageCreateInfo structures
ifndef::VK_EXT_extended_dynamic_state3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06641]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    pname:pRasterizationState must: be a valid pointer to a valid
    slink:VkPipelineRasterizationStateCreateInfo structure
endif::VK_EXT_extended_dynamic_state3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06642]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, pname:layout
    must: be a valid slink:VkPipelineLayout handle
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06643]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    and pname:renderPass is not dlink:VK_NULL_HANDLE, pname:renderPass must:
    be a valid slink:VkRenderPass handle
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06644]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT,
    pname:stageCount must: be greater than `0`
ifdef::VK_KHR_pipeline_executable_properties[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06645]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags is
    non-zero, if pname:flags includes
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR, any
    libraries must: have also been created with
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06646]]
    If slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes more
    than one library, and any library was created with
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR, all
    libraries must: have also been created with
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06647]]
    If slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes at
    least one library,
    slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags is non-zero,
    and any library was created with
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR,
    pname:flags must: include
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
endif::VK_KHR_pipeline_executable_properties[]
  * [[VUID-VkGraphicsPipelineCreateInfo-None-07826]]
    If the pipeline includes a <<pipelines-graphics-subsets-complete,
    complete set of state>>, and there are no libraries included in
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries, then
    slink:VkPipelineLayout must: be a valid pipeline layout
  * [[VUID-VkGraphicsPipelineCreateInfo-layout-07827]]
    If the pipeline includes a <<pipelines-graphics-subsets-complete,
    complete set of state>> specified entirely by libraries, and each
    library was created with a slink:VkPipelineLayout created without
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then
    pname:layout must: be <<descriptorsets-compatibility,compatible>> with
    the layouts in those libraries
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06729]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT, the pipeline
    includes a <<pipelines-graphics-subsets-complete, complete set of
    state>> specified entirely by libraries, and each library was created
    with a slink:VkPipelineLayout created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then
    pname:layout must: be <<descriptorsets-compatibility,compatible>> with
    the union of the libraries' pipeline layouts other than the
    inclusion/exclusion of
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06730]]
    If pname:flags does not include
    ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT, the pipeline
    includes a <<pipelines-graphics-subsets-complete, complete set of
    state>> specified entirely by libraries, and each library was created
    with a slink:VkPipelineLayout created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then
    pname:layout must: be <<descriptorsets-compatibility, compatible>> with
    the union of the libraries' pipeline layouts
endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_EXT_conservative_rasterization[]
  * [[VUID-VkGraphicsPipelineCreateInfo-conservativePointAndLineRasterization-08892]]
    If <<limits-conservativePointAndLineRasterization,
    pname:conservativePointAndLineRasterization>> is not supported; the
    pipeline is being created with
    <<pipelines-graphics-subsets-vertex-input, vertex input state>> and
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>; the pipeline does not include a geometry shader; and the value
    of slink:VkPipelineInputAssemblyStateCreateInfo::pname:topology is
    ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST, or
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
ifdef::VK_EXT_extended_dynamic_state3[]
    and either ename:VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY dynamic state is
    not enabled or
    <<limits-dynamicPrimitiveTopologyUnrestricted,pname:dynamicPrimitiveTopologyUnrestricted>>
    is ename:VK_FALSE,
endif::VK_EXT_extended_dynamic_state3[]
    then
    slink:VkPipelineRasterizationConservativeStateCreateInfoEXT::pname:conservativeRasterizationMode
    must: be ename:VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-conservativePointAndLineRasterization-06760]]
    If <<limits-conservativePointAndLineRasterization,
    pname:conservativePointAndLineRasterization>> is not supported, the
    pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and the pipeline includes a geometry
    shader with either the code:OutputPoints or code:OutputLineStrip
    execution modes,
    slink:VkPipelineRasterizationConservativeStateCreateInfoEXT::pname:conservativeRasterizationMode
    must: be ename:VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
ifdef::VK_NV_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-conservativePointAndLineRasterization-06761]]
    If <<limits-conservativePointAndLineRasterization,
    pname:conservativePointAndLineRasterization>> is not supported, the
    pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and the pipeline includes a mesh
    shader with either the code:OutputPoints or code:OutputLinesNV execution
    modes,
    slink:VkPipelineRasterizationConservativeStateCreateInfoEXT::pname:conservativeRasterizationMode
    must: be ename:VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
endif::VK_NV_mesh_shader[]
endif::VK_EXT_conservative_rasterization[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-06894]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> but not
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>,
    elements of pname:pStages must: not have pname:stage set to
    ename:VK_SHADER_STAGE_FRAGMENT_BIT
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-06895]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> but not
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, elements of pname:pStages must: not have pname:stage set to a
    shader stage which participates in pre-rasterization
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-06896]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, all elements of pname:pStages must:
    have a pname:stage set to a shader stage which participates in
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>> or
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>
  * [[VUID-VkGraphicsPipelineCreateInfo-stage-06897]]
    If the pipeline requires <<pipelines-graphics-subsets-fragment-shader,
    fragment shader state>> and/or
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, any value of pname:stage must: not be set in more than one
    element of pname:pStages
ifdef::VK_EXT_extended_dynamic_state3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3TessellationDomainOrigin-07370]]
    If the <<features-extendedDynamicState3TessellationDomainOrigin,
    pname:extendedDynamicState3TessellationDomainOrigin>> feature is not
    enabled, there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3DepthClampEnable-07371]]
    If the <<features-extendedDynamicState3DepthClampEnable,
    pname:extendedDynamicState3DepthClampEnable>> feature is not enabled,
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to ename:VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3PolygonMode-07372]]
    If the <<features-extendedDynamicState3PolygonMode,
    pname:extendedDynamicState3PolygonMode>> feature is not enabled, there
    must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to ename:VK_DYNAMIC_STATE_POLYGON_MODE_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3RasterizationSamples-07373]]
    If the <<features-extendedDynamicState3RasterizationSamples,
    pname:extendedDynamicState3RasterizationSamples>> feature is not
    enabled, there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3SampleMask-07374]]
    If the <<features-extendedDynamicState3SampleMask,
    pname:extendedDynamicState3SampleMask>> feature is not enabled, there
    must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to ename:VK_DYNAMIC_STATE_SAMPLE_MASK_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3AlphaToCoverageEnable-07375]]
    If the <<features-extendedDynamicState3AlphaToCoverageEnable,
    pname:extendedDynamicState3AlphaToCoverageEnable>> feature is not
    enabled, there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3AlphaToOneEnable-07376]]
    If the <<features-extendedDynamicState3AlphaToOneEnable,
    pname:extendedDynamicState3AlphaToOneEnable>> feature is not enabled,
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3LogicOpEnable-07377]]
    If the <<features-extendedDynamicState3LogicOpEnable,
    pname:extendedDynamicState3LogicOpEnable>> feature is not enabled, there
    must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to ename:VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ColorBlendEnable-07378]]
    If the <<features-extendedDynamicState3ColorBlendEnable,
    pname:extendedDynamicState3ColorBlendEnable>> feature is not enabled,
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to ename:VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ColorBlendEquation-07379]]
    If the <<features-extendedDynamicState3ColorBlendEquation,
    pname:extendedDynamicState3ColorBlendEquation>> feature is not enabled,
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ColorWriteMask-07380]]
    If the <<features-extendedDynamicState3ColorWriteMask,
    pname:extendedDynamicState3ColorWriteMask>> feature is not enabled,
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to ename:VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3RasterizationStream-07381]]
    If the <<features-extendedDynamicState3RasterizationStream,
    pname:extendedDynamicState3RasterizationStream>> feature is not enabled,
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ConservativeRasterizationMode-07382]]
    If the <<features-extendedDynamicState3ConservativeRasterizationMode,
    pname:extendedDynamicState3ConservativeRasterizationMode>> feature is
    not enabled, there must: be no element of the pname:pDynamicStates
    member of pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ExtraPrimitiveOverestimationSize-07383]]
    If the <<features-extendedDynamicState3ExtraPrimitiveOverestimationSize,
    pname:extendedDynamicState3ExtraPrimitiveOverestimationSize>> feature is
    not enabled, there must: be no element of the pname:pDynamicStates
    member of pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT
ifdef::VK_EXT_conservative_rasterization[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-09639]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, pname:pDynamicState includes
    ename:VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT, and
    pname:pDynamicState does not include
    ename:VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT,
    pname:pRasterizationState must: include a
    slink:VkPipelineRasterizationConservativeStateCreateInfoEXT in its
    pname:pNext chain
endif::VK_EXT_conservative_rasterization[]
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3DepthClipEnable-07384]]
    If the <<features-extendedDynamicState3DepthClipEnable,
    pname:extendedDynamicState3DepthClipEnable>> feature is not enabled,
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to ename:VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3SampleLocationsEnable-07385]]
    If the <<features-extendedDynamicState3SampleLocationsEnable,
    pname:extendedDynamicState3SampleLocationsEnable>> feature is not
    enabled, there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ColorBlendAdvanced-07386]]
    If the <<features-extendedDynamicState3ColorBlendAdvanced,
    pname:extendedDynamicState3ColorBlendAdvanced>> feature is not enabled,
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ProvokingVertexMode-07387]]
    If the <<features-extendedDynamicState3ProvokingVertexMode,
    pname:extendedDynamicState3ProvokingVertexMode>> feature is not enabled,
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3LineRasterizationMode-07388]]
    If the <<features-extendedDynamicState3LineRasterizationMode,
    pname:extendedDynamicState3LineRasterizationMode>> feature is not
    enabled, there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3LineStippleEnable-07389]]
    If the <<features-extendedDynamicState3LineStippleEnable,
    pname:extendedDynamicState3LineStippleEnable>> feature is not enabled,
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3DepthClipNegativeOneToOne-07390]]
    If the <<features-extendedDynamicState3DepthClipNegativeOneToOne,
    pname:extendedDynamicState3DepthClipNegativeOneToOne>> feature is not
    enabled, there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ViewportWScalingEnable-07391]]
    If the <<features-extendedDynamicState3ViewportWScalingEnable,
    pname:extendedDynamicState3ViewportWScalingEnable>> feature is not
    enabled, there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ViewportSwizzle-07392]]
    If the <<features-extendedDynamicState3ViewportSwizzle,
    pname:extendedDynamicState3ViewportSwizzle>> feature is not enabled,
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to ename:VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageToColorEnable-07393]]
    If the <<features-extendedDynamicState3CoverageToColorEnable,
    pname:extendedDynamicState3CoverageToColorEnable>> feature is not
    enabled, there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageToColorLocation-07394]]
    If the <<features-extendedDynamicState3CoverageToColorLocation,
    pname:extendedDynamicState3CoverageToColorLocation>> feature is not
    enabled, there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageModulationMode-07395]]
    If the <<features-extendedDynamicState3CoverageModulationMode,
    pname:extendedDynamicState3CoverageModulationMode>> feature is not
    enabled, there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageModulationTableEnable-07396]]
    If the <<features-extendedDynamicState3CoverageModulationTableEnable,
    pname:extendedDynamicState3CoverageModulationTableEnable>> feature is
    not enabled, there must: be no element of the pname:pDynamicStates
    member of pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageModulationTable-07397]]
    If the <<features-extendedDynamicState3CoverageModulationTable,
    pname:extendedDynamicState3CoverageModulationTable>> feature is not
    enabled, there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageReductionMode-07398]]
    If the <<features-extendedDynamicState3CoverageReductionMode,
    pname:extendedDynamicState3CoverageReductionMode>> feature is not
    enabled, there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3RepresentativeFragmentTestEnable-07399]]
    If the <<features-extendedDynamicState3RepresentativeFragmentTestEnable,
    pname:extendedDynamicState3RepresentativeFragmentTestEnable>> feature is
    not enabled, there must: be no element of the pname:pDynamicStates
    member of pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ShadingRateImageEnable-07400]]
    If the <<features-extendedDynamicState3ShadingRateImageEnable,
    pname:extendedDynamicState3ShadingRateImageEnable>> feature is not
    enabled, there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV
endif::VK_EXT_extended_dynamic_state3[]
ifdef::VK_EXT_opacity_micromap[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-07401]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT
endif::VK_EXT_opacity_micromap[]
ifdef::VK_NV_displacement_micromap[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-07997]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV
endif::VK_NV_displacement_micromap[]
ifdef::VK_QCOM_multiview_per_view_viewports[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07730]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and no element of the
    pname:pDynamicStates member of pname:pDynamicState is
    ename:VK_DYNAMIC_STATE_VIEWPORT or
    ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT, and if
    <<features-multiviewPerViewViewports, pname:multiviewPerViewViewports>>
    is enabled, then the index of the most significant bit in each element
    of slink:VkRenderPassMultiviewCreateInfo::pname:pViewMasks must: be less
    than pname:pViewportState->viewportCount
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07731]]
    If the pipeline requires <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and no element of the
    pname:pDynamicStates member of pname:pDynamicState is
    ename:VK_DYNAMIC_STATE_SCISSOR or
    ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT, and if
    <<features-multiviewPerViewViewports, pname:multiviewPerViewViewports>>
    is enabled, then the index of the most significant bit in each element
    of slink:VkRenderPassMultiviewCreateInfo::pname:pViewMasks must: be less
    than pname:pViewportState->scissorCount
endif::VK_QCOM_multiview_per_view_viewports[]
ifdef::VK_EXT_shader_tile_image[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-08711]]
    If pname:pStages includes a fragment shader stage,
    ename:VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE is not set in
    slink:VkPipelineDynamicStateCreateInfo::pname:pDynamicStates, and the
    fragment shader declares the code:EarlyFragmentTests execution mode and
    uses code:OpDepthAttachmentReadEXT, the pname:depthWriteEnable member of
    slink:VkPipelineDepthStencilStateCreateInfo must: be ename:VK_FALSE
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-08712]]
    If pname:pStages includes a fragment shader stage,
    ename:VK_DYNAMIC_STATE_STENCIL_WRITE_MASK is not set in
    slink:VkPipelineDynamicStateCreateInfo::pname:pDynamicStates, and the
    fragment shader declares the code:EarlyFragmentTests execution mode and
    uses code:OpStencilAttachmentReadEXT, the value of
    slink:VkStencilOpState::pname:writeMask for both pname:front and
    pname:back in slink:VkPipelineDepthStencilStateCreateInfo must: be `0`
endif::VK_EXT_shader_tile_image[]
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-08744]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline requires
    <<pipelines-graphics-subsets-fragment-output, fragment output state>> or
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>,
    the pipeline enables <<primsrast-sampleshading, sample shading>>,
    pname:rasterizationSamples is not dynamic, and the pname:pNext chain
    includes a slink:VkPipelineRenderingCreateInfo structure,
    pname:rasterizationSamples must: be a valid elink:VkSampleCountFlagBits
    value that is set in pname:imageCreateSampleCounts (as defined in
    <<resources-image-creation-limits,Image Creation Limits>>) for every
    element of pname:depthAttachmentFormat, pname:stencilAttachmentFormat
    and the pname:pColorAttachmentFormats array which is not
    ename:VK_FORMAT_UNDEFINED
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifndef::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkGraphicsPipelineCreateInfo-None-08893]]
    The pipeline must: be created with
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-08894]]
    If pname:pStages includes a vertex shader stage, the pipeline must: be
    created with <<pipelines-graphics-subsets-vertex-input, vertex input
    state>>
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-08896]]
    If
ifdef::VK_EXT_extended_dynamic_state2,VK_VERSION_1_3[]
    pname:pDynamicState->pDynamicStates includes
    ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE, or if it does not and
endif::VK_EXT_extended_dynamic_state2,VK_VERSION_1_3[]
    pname:pRasterizationState->rasterizerDiscardEnable is ename:VK_FALSE,
    the pipeline must: be created with
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and <<pipelines-graphics-subsets-fragment-output,fragment output
    interface state>>
endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-08897]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT,
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> is specified either in a library or by the inclusion of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    and that state includes a vertex shader stage in pname:pStages, the
    pipeline must: define <<pipelines-graphics-subsets-vertex-input, vertex
    input state>>
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-08898]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT, and
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> is not specified, the pipeline must: define
    <<pipelines-graphics-subsets-vertex-input, vertex input state>>
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-08899]]
    If pname:flags does not include
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR,
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> is specified either in a library or by the inclusion of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    and that state includes a vertex shader stage in pname:pStages, the
    pipeline must: either define <<pipelines-graphics-subsets-vertex-input,
    vertex input state>> or include that state in a linked pipeline library
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-08900]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT the
    pipeline must: define <<pipelines-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-08901]]
    If pname:flags does not include
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, the pipeline must: either
    define <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization
    shader state>> or include that state in a linked pipeline library
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-08903]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT,
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> is specified either in a library or by the inclusion of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    and that state
ifdef::VK_EXT_extended_dynamic_state2,VK_VERSION_1_3[]
    either includes ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE or
endif::VK_EXT_extended_dynamic_state2,VK_VERSION_1_3[]
    has pname:pRasterizationState->rasterizerDiscardEnable set to
    ename:VK_FALSE, the pipeline must: define
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-08904]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> is not specified, the pipeline must: define
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-08906]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT,
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> is specified either in a library or by the inclusion of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    and that state
ifdef::VK_EXT_extended_dynamic_state2,VK_VERSION_1_3[]
    either includes ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE or
endif::VK_EXT_extended_dynamic_state2,VK_VERSION_1_3[]
    has pname:pRasterizationState->rasterizerDiscardEnable set to
    ename:VK_FALSE, the pipeline must: define
    <<pipelines-graphics-subsets-fragment-output,fragment output interface
    state>>
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-08907]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> is not specified, the pipeline must: define
    <<pipelines-graphics-subsets-fragment-output,fragment output interface
    state>>
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-08909]]
    If pname:flags does not include
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR,
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> is specified either in a library or by the inclusion of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    and that state
ifdef::VK_EXT_extended_dynamic_state2,VK_VERSION_1_3[]
    either includes ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE or
endif::VK_EXT_extended_dynamic_state2,VK_VERSION_1_3[]
    has pname:pRasterizationState->rasterizerDiscardEnable set to
    ename:VK_FALSE, the pipeline must: define
    <<pipelines-graphics-subsets-fragment-output,fragment output interface
    state>> and <<pipelines-graphics-subsets-fragment-shader, fragment
    shader state>> or include those states in linked pipeline libraries
endif::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkGraphicsPipelineCreateInfo-None-09043]]
    If
ifdef::VK_EXT_extended_dynamic_state3[]
    pname:pDynamicState->pDynamicStates does not include
    ename:VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, and
endif::VK_EXT_extended_dynamic_state3[]
    the format of any color attachment is
    ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32, the pname:colorWriteMask member
    of the corresponding element of pname:pColorBlendState->pAttachments
    must: either include all of ename:VK_COLOR_COMPONENT_R_BIT,
    ename:VK_COLOR_COMPONENT_G_BIT, and ename:VK_COLOR_COMPONENT_B_BIT, or
    none of them
ifdef::VK_ANDROID_external_format_resolve[]
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09301]]
    If the <<features-externalFormatResolve, pname:externalFormatResolve>>
    feature is enabled, the pipeline requires
    <<pipelines-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkExternalFormatANDROID::pname:externalFormat is not `0`,
    slink:VkPipelineRenderingCreateInfo::pname:viewMask must: be `0`
  * [[VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09304]]
    If the <<features-externalFormatResolve, pname:externalFormatResolve>>
    feature is enabled, the pipeline requires
    <<pipelines-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is dlink:VK_NULL_HANDLE,
    slink:VkExternalFormatANDROID::pname:externalFormat is not `0`, and
    pname:rasterizationSamples is not dynamic,
    slink:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples
    must: be `1`
  * [[VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09305]]
    If the <<features-externalFormatResolve, pname:externalFormatResolve>>
    feature is enabled, the pipeline requires
    <<pipelines-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkExternalFormatANDROID::pname:externalFormat is not `0`, and
    pname:blendEnable is not dynamic, the pname:blendEnable member of each
    element of pname:pColorBlendState->pAttachments must: be ename:VK_FALSE
ifdef::VK_KHR_fragment_shading_rate[]
  * [[VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09306]]
    If the <<features-externalFormatResolve, pname:externalFormatResolve>>
    feature is enabled, the pipeline requires
    <<pipelines-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkExternalFormatANDROID::pname:externalFormat is not `0`, and
    pname:pDynamicState->pDynamicStates does not include
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:width must:
    be `1`
  * [[VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09307]]
    If the <<features-externalFormatResolve, pname:externalFormatResolve>>
    feature is enabled, the pipeline requires
    <<pipelines-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkExternalFormatANDROID::pname:externalFormat is not `0`, and
    pname:pDynamicState->pDynamicStates does not include
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:height
    must: be `1`
  * [[VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09308]]
    If the <<features-externalFormatResolve, pname:externalFormatResolve>>
    feature is enabled, the pipeline requires
    <<pipelines-graphics-subsets-fragment-output, pre-rasterization shader
    state>> and <<pipelines-graphics-subsets-fragment-output, fragment
    output interface state>>, pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkExternalFormatANDROID::pname:externalFormat is not `0`, the last
    <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization shader
    stage>> must: not statically use a variable with the
    code:PrimitiveShadingRateKHR built-in
endif::VK_KHR_fragment_shading_rate[]
  * [[VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09309]]
    If the <<features-externalFormatResolve, pname:externalFormatResolve>>
    feature is enabled, the pipeline requires
    <<pipelines-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkExternalFormatANDROID::pname:externalFormat is not `0`,
    slink:VkPipelineRenderingCreateInfo::pname:colorAttachmentCount must: be
    `1`
  * [[VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09310]]
    If the <<features-externalFormatResolve, pname:externalFormatResolve>>
    feature is enabled, the pipeline requires
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and <<pipelines-graphics-subsets-fragment-output, fragment output
    interface state>>, pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkExternalFormatANDROID::pname:externalFormat is not `0`, the
    fragment shader must: not declare the code:DepthReplacing or
    code:StencilRefReplacingEXT execution modes
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09313]]
    If the <<features-externalFormatResolve, pname:externalFormatResolve>>
    feature is enabled, the pipeline requires
    <<pipelines-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is not dlink:VK_NULL_HANDLE, pname:subpass
    includes an external format resolve attachment, and
    pname:rasterizationSamples is not dynamic,
    slink:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples
    must: be ename:VK_SAMPLE_COUNT_1_BIT
  * [[VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09314]]
    If the <<features-externalFormatResolve, pname:externalFormatResolve>>
    feature is enabled, the pipeline requires
    <<pipelines-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is not dlink:VK_NULL_HANDLE, pname:subpass
    includes an external format resolve attachment, and pname:blendEnable is
    not dynamic, the pname:blendEnable member of each element of
    pname:pColorBlendState->pAttachments must: be ename:VK_FALSE
ifdef::VK_KHR_fragment_shading_rate[]
  * [[VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09315]]
    If the <<features-externalFormatResolve, pname:externalFormatResolve>>
    feature is enabled, the pipeline requires
    <<pipelines-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is not dlink:VK_NULL_HANDLE, pname:subpass
    includes an external format resolve attachment, and
    pname:pDynamicState->pDynamicStates does not include
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:width must:
    be `1`
  * [[VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09316]]
    If the <<features-externalFormatResolve, pname:externalFormatResolve>>
    feature is enabled, the pipeline requires
    <<pipelines-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is not dlink:VK_NULL_HANDLE, pname:subpass
    includes an external format resolve attachment, and
    pname:pDynamicState->pDynamicStates does not include
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:height
    must: be `1`
  * [[VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09317]]
    If the <<features-externalFormatResolve, pname:externalFormatResolve>>
    feature is enabled, the pipeline requires
    <<pipelines-graphics-subsets-fragment-output, pre-rasterization shader
    state>> and <<pipelines-graphics-subsets-fragment-output, fragment
    output interface state>>, pname:renderPass is not dlink:VK_NULL_HANDLE,
    and pname:subpass includes an external format resolve attachment, the
    last <<pipelines-graphics-subsets-pre-rasterization, pre-rasterization
    shader stage>> must: not statically use a variable with the
    code:PrimitiveShadingRateKHR built-in
endif::VK_KHR_fragment_shading_rate[]
endif::VK_ANDROID_external_format_resolve[]
ifdef::VK_KHR_dynamic_rendering_local_read[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-09531]]
    If the pipeline is being created with
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and <<pipelines-graphics-subsets-fragment-output, fragment output
    state>>, the value of pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkRenderingInputAttachmentIndexInfoKHR is included,
    slink:VkRenderingInputAttachmentIndexInfoKHR::pname:colorAttachmentCount
    must: be equal to
    slink:VkPipelineRenderingCreateInfo::pname:colorAttachmentCount
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-09652]]
    If the pipeline is being created with
    <<pipelines-graphics-subsets-fragment-shader, fragment shader state>>
    and <<pipelines-graphics-subsets-fragment-output, fragment output
    state>>, the value of pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkRenderingInputAttachmentIndexInfoKHR is not included, the
    fragment shader must: not contain any input attachments with a
    code:InputAttachmentIndex greater than or equal to
    slink:VkPipelineRenderingCreateInfo::pname:colorAttachmentCount
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-09532]]
    If the pipeline is being created with
    <<pipelines-graphics-subsets-fragment-output, fragment output state>>,
    and the value of pname:renderPass is dlink:VK_NULL_HANDLE,
    slink:VkRenderingAttachmentLocationInfoKHR::pname:colorAttachmentCount
    must: be equal to
    slink:VkPipelineRenderingCreateInfo::pname:colorAttachmentCount
endif::VK_KHR_dynamic_rendering_local_read[]
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkGraphicsPipelineCreateInfo::pname:basePipelineHandle must: be
    dlink:VK_NULL_HANDLE <<SCID-8>>.
  * slink:VkGraphicsPipelineCreateInfo::pname:basePipelineIndex must: be
    zero <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/structs/VkGraphicsPipelineCreateInfo.adoc[]
--

ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
[open,refpage='VkPipelineRenderingCreateInfo',desc='Structure specifying attachment formats',type='structs',alias='VkPipelineRenderingCreateInfoKHR']
--
The sname:VkPipelineRenderingCreateInfo structure is defined as:

include::{generated}/api/structs/VkPipelineRenderingCreateInfo.adoc[]

ifdef::VK_KHR_dynamic_rendering[]
or the equivalent

include::{generated}/api/structs/VkPipelineRenderingCreateInfoKHR.adoc[]
endif::VK_KHR_dynamic_rendering[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:viewMask is the viewMask used for rendering.
  * pname:colorAttachmentCount is the number of entries in
    pname:pColorAttachmentFormats
  * pname:pColorAttachmentFormats is a pointer to an array of elink:VkFormat
    values defining the format of color attachments used in this pipeline.
  * pname:depthAttachmentFormat is a elink:VkFormat value defining the
    format of the depth attachment used in this pipeline.
  * pname:stencilAttachmentFormat is a elink:VkFormat value defining the
    format of the stencil attachment used in this pipeline.

When a pipeline is created without a slink:VkRenderPass, if the pname:pNext
chain of slink:VkGraphicsPipelineCreateInfo includes this structure, it
specifies the view mask and format of attachments used for rendering.
If this structure is not specified, and the pipeline does not include a
slink:VkRenderPass, pname:viewMask and pname:colorAttachmentCount are `0`,
and pname:depthAttachmentFormat and pname:stencilAttachmentFormat are
ename:VK_FORMAT_UNDEFINED.
If a graphics pipeline is created with a valid slink:VkRenderPass,
parameters of this structure are ignored.

If pname:depthAttachmentFormat, pname:stencilAttachmentFormat, or any
element of pname:pColorAttachmentFormats is ename:VK_FORMAT_UNDEFINED, it
indicates that the corresponding attachment is unused within the render
pass.
Valid formats indicate that an attachment can: be used - but it is still
valid to set the attachment to `NULL` when beginning rendering.

ifdef::VK_ANDROID_external_format_resolve[]
If the render pass is going to be used with an external format resolve
attachment, a slink:VkExternalFormatANDROID structure must: also be included
in the pname:pNext chain of slink:VkGraphicsPipelineCreateInfo, defining the
external format of the resolve attachment that will be used.
endif::VK_ANDROID_external_format_resolve[]

.Valid Usage
****
  * [[VUID-VkPipelineRenderingCreateInfo-colorAttachmentCount-09533]]
    pname:colorAttachmentCount must: be less than or equal to
    <<limits-maxColorAttachments,pname:maxColorAttachments>>
****

include::{generated}/validity/structs/VkPipelineRenderingCreateInfo.adoc[]
--
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]

ifdef::VK_KHR_maintenance5[]
[open,refpage='VkPipelineCreateFlags2CreateInfoKHR',desc='Extended pipeline create flags',type='structs']
--
The sname:VkPipelineCreateFlags2CreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkPipelineCreateFlags2CreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkPipelineCreateFlagBits2KHR
    specifying how a pipeline will be generated.

If this structure is included in the pname:pNext chain of a pipeline
creation structure, pname:flags is used instead of the corresponding
pname:flags value passed in that creation structure, allowing additional
creation flags to be specified.

include::{generated}/validity/structs/VkPipelineCreateFlags2CreateInfoKHR.adoc[]
--

[open,refpage='VkPipelineCreateFlagBits2KHR',desc='Bitmask controlling how a pipeline is created',type='enums']
--
Bits which can: be set in
slink:VkPipelineCreateFlags2CreateInfoKHR::pname:flags, specifying how a
pipeline is created, are:

include::{generated}/api/enums/VkPipelineCreateFlagBits2KHR.adoc[]

// Note - when editing this section, make sure that any relevant changes
// are mirrored in VkPipelineCreateFlagBits2KHR/VkPipelineCreateFlagBits

  * ename:VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR specifies that
    the created pipeline will not be optimized.
    Using this flag may: reduce the time taken to create the pipeline.
  * ename:VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR specifies that the
    pipeline to be created is allowed to be the parent of a pipeline that
    will be created in a subsequent pipeline creation call.
  * ename:VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR specifies that the
    pipeline to be created will be a child of a previously created parent
    pipeline.
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * ename:VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR
    specifies that any shader input variables decorated as code:ViewIndex
    will be assigned values as if they were decorated as code:DeviceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
  * ename:VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR specifies that a
    compute pipeline can: be used with flink:vkCmdDispatchBase with a
    non-zero base workgroup.
endif::VK_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_NV_ray_tracing[]
  * ename:VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV specifies that a
    pipeline is created with all shaders in the deferred state.
    Before using the pipeline the application must: call
    flink:vkCompileDeferredNV exactly once on each shader in the pipeline
    before using the pipeline.
endif::VK_NV_ray_tracing[]
ifdef::VK_KHR_pipeline_executable_properties[]
  * ename:VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR specifies that the
    shader compiler should capture statistics for the pipeline executables
    produced by the compile process which can: later be retrieved by calling
    flink:vkGetPipelineExecutableStatisticsKHR.
    Enabling this flag must: not affect the final compiled pipeline but may:
    disable pipeline caching or otherwise affect pipeline creation time.
  * ename:VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
    specifies that the shader compiler should capture the internal
    representations of pipeline executables produced by the compile process
    which can: later be retrieved by calling
    flink:vkGetPipelineExecutableInternalRepresentationsKHR.
    Enabling this flag must: not affect the final compiled pipeline but may:
    disable pipeline caching or otherwise affect pipeline creation time.
ifdef::VK_KHR_pipeline_library[]
    When capturing IR from pipelines created with pipeline libraries, there
    is no guarantee that IR from libraries can: be retrieved from the linked
    pipeline.
    Applications should: retrieve IR from each library, and any linked
    pipelines, separately.
endif::VK_KHR_pipeline_library[]
endif::VK_KHR_pipeline_executable_properties[]
ifdef::VK_KHR_pipeline_library[]
  * ename:VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR specifies that the pipeline
    cannot: be used directly, and instead defines a _pipeline library_ that
    can: be combined with other pipelines using the
    slink:VkPipelineLibraryCreateInfoKHR structure.
ifdef::VK_KHR_ray_tracing_pipeline,VK_EXT_graphics_pipeline_library[]
    This is available in
ifdef::VK_KHR_ray_tracing_pipeline[ray tracing]
ifdef::VK_KHR_ray_tracing_pipeline+VK_EXT_graphics_pipeline_library[and]
ifdef::VK_EXT_graphics_pipeline_library[graphics]
    pipelines.
endif::VK_KHR_ray_tracing_pipeline,VK_EXT_graphics_pipeline_library[]
endif::VK_KHR_pipeline_library[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * ename:VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR
    specifies that an any-hit shader will always be present when an any-hit
    shader would be executed.
    A NULL any-hit shader is an any-hit shader which is effectively
    ename:VK_SHADER_UNUSED_KHR, such as from a shader group consisting
    entirely of zeros.
  * ename:VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
    specifies that a closest hit shader will always be present when a
    closest hit shader would be executed.
    A NULL closest hit shader is a closest hit shader which is effectively
    ename:VK_SHADER_UNUSED_KHR, such as from a shader group consisting
    entirely of zeros.
  * ename:VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
    specifies that a miss shader will always be present when a miss shader
    would be executed.
    A NULL miss shader is a miss shader which is effectively
    ename:VK_SHADER_UNUSED_KHR, such as from a shader group consisting
    entirely of zeros.
  * ename:VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
    specifies that an intersection shader will always be present when an
    intersection shader would be executed.
    A NULL intersection shader is an intersection shader which is
    effectively ename:VK_SHADER_UNUSED_KHR, such as from a shader group
    consisting entirely of zeros.
  * ename:VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR specifies
    that triangle primitives will be skipped during traversal using
    <<glossary-pipeline-trace-ray, pipeline trace ray>> instructions.
  * ename:VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR specifies that
    AABB primitives will be skipped during traversal using
    <<glossary-pipeline-trace-ray, pipeline trace ray>> instructions.
  * ename:VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
    specifies that the shader group handles can: be saved and reused on a
    subsequent run (e.g. for trace capture and replay).
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_device_generated_commands[]
  * ename:VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV specifies that the
    pipeline can be used in combination with <<device-generated-commands>>.
endif::VK_NV_device_generated_commands[]
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * ename:VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR
    specifies that pipeline creation will fail if a compile is required for
    creation of a valid slink:VkPipeline object;
    ename:VK_PIPELINE_COMPILE_REQUIRED will be returned by pipeline
    creation, and the slink:VkPipeline will be set to dlink:VK_NULL_HANDLE.
  * When creating multiple pipelines,
    ename:VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR specifies
    that control will be returned to the application if any individual
    pipeline returns a result which is not ename:VK_SUCCESS rather than
    continuing to create additional pipelines.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifdef::VK_NV_ray_tracing_motion_blur[]
  * ename:VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV specifies
    that the pipeline is allowed to use code:OpTraceRayMotionNV.
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_KHR_fragment_shading_rate[]
  * ename:VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
    specifies that the pipeline will be used with a fragment shading rate
    attachment.
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_EXT_fragment_density_map[]
  * ename:VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
    specifies that the pipeline will be used with a fragment density map
    attachment.
endif::VK_EXT_fragment_density_map[]
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_EXT_graphics_pipeline_library[]
  * ename:VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT specifies that
    pipeline libraries being linked into this library should: have link time
    optimizations applied.
    If this bit is omitted, implementations should: instead perform linking
    as rapidly as possible.
  * ename:VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT
    specifies that pipeline libraries should retain any information
    necessary to later perform an optimal link with
    ename:VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT.
endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_EXT_descriptor_buffer[]
  * ename:VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT specifies that a
    pipeline will be used with <<descriptorbuffers,descriptor buffers>>,
    rather than <<descriptorsets,descriptor sets>>.
endif::VK_EXT_descriptor_buffer[]
ifdef::VK_EXT_attachment_feedback_loop_layout[]
  * ename:VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
    specifies that the pipeline may: be used with an attachment feedback
    loop including color attachments.
  * ename:VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
    specifies that the pipeline may: be used with an attachment feedback
    loop including depth-stencil attachments.
endif::VK_EXT_attachment_feedback_loop_layout[]
ifdef::VK_EXT_opacity_micromap[]
  * ename:VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT
    specifies that the ray tracing pipeline can: be used with acceleration
    structures which reference an opacity micromap array.
endif::VK_EXT_opacity_micromap[]
ifdef::VK_NV_displacement_micromap[]
  * ename:VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV
    specifies that the ray tracing pipeline can: be used with acceleration
    structures which reference a displacement micromap array.
endif::VK_NV_displacement_micromap[]
ifdef::VK_EXT_pipeline_protected_access[]
  * ename:VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT specifies that
    the pipeline must: not be bound to a protected command buffer.
  * ename:VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT specifies that
    the pipeline must: not be bound to an unprotected command buffer.
endif::VK_EXT_pipeline_protected_access[]
ifdef::VK_KHR_pipeline_binary[]
  * ename:VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR specifies that
    sname:VkPipelineBinaryKHR objects can: be created from the pipeline.
    If ename:VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR is used,
    implementations should: not store pipeline data to an internal cache, if
    such a cache exists as stated by
    <<limits-pipelineBinaryInternalCache,pname:pipelineBinaryInternalCache>>.
    If
    <<limits-pipelineBinaryPrefersInternalCache,pname:pipelineBinaryPrefersInternalCache>>
    is ename:VK_TRUE, applications should: not use
    ename:VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR.
endif::VK_KHR_pipeline_binary[]
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_EXT_legacy_dithering[]
  * ename:VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT specifies
    that the pipeline will be used in a render pass that is begun with
    ename:VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT.
endif::VK_EXT_legacy_dithering[]
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]

It is valid to set both ename:VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR
and ename:VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR.
This allows a pipeline to be both a parent and possibly a child in a
pipeline hierarchy.
See <<pipelines-pipeline-derivatives,Pipeline Derivatives>> for more
information.

ifdef::VK_EXT_graphics_pipeline_library[]
When an implementation is looking up a pipeline in a
<<pipelines-cache,pipeline cache>>, if that pipeline is being created using
linked libraries, implementations should: always return an equivalent
pipeline created with
ename:VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT if available,
whether or not that bit was specified.

[NOTE]
====
Using ename:VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT (or not)
when linking pipeline libraries is intended as a performance tradeoff
between host and device.
If the bit is omitted, linking should be faster and produce a pipeline more
rapidly, but performance of the pipeline on the target device may be
reduced.
If the bit is included, linking may be slower but should produce a pipeline
with device performance comparable to a monolithically created pipeline.
Using both options can allow latency-sensitive applications to generate a
suboptimal but usable pipeline quickly, and then perform an optimal link in
the background, substituting the result for the suboptimally linked pipeline
as soon as it is available.
====
endif::VK_EXT_graphics_pipeline_library[]
--

[open,refpage='VkPipelineCreateFlags2KHR',desc='Bitmask of VkPipelineCreateFlagBits2KHR',type='flags']
--
include::{generated}/api/flags/VkPipelineCreateFlags2KHR.adoc[]

tname:VkPipelineCreateFlags2KHR is a bitmask type for setting a mask of zero
or more elink:VkPipelineCreateFlagBits2KHR.
--
endif::VK_KHR_maintenance5[]

[open,refpage='VkPipelineCreateFlagBits',desc='Bitmask controlling how a pipeline is created',type='enums']
--
Bits which can: be set in

  * slink:VkGraphicsPipelineCreateInfo::pname:flags
  * slink:VkComputePipelineCreateInfo::pname:flags
ifdef::VK_KHR_ray_tracing_pipeline[]
  * slink:VkRayTracingPipelineCreateInfoKHR::pname:flags
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_ray_tracing[]
  * slink:VkRayTracingPipelineCreateInfoNV::pname:flags
endif::VK_NV_ray_tracing[]

specify how a pipeline is created, and are:

include::{generated}/api/enums/VkPipelineCreateFlagBits.adoc[]

// Note - when editing this section, make sure that any relevant changes
// are mirrored in VkPipelineCreateFlagBits2KHR/VkPipelineCreateFlagBits

  * ename:VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT specifies that the
    created pipeline will not be optimized.
    Using this flag may: reduce the time taken to create the pipeline.
ifndef::VKSC_VERSION_1_0[]
  * ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT specifies that the
    pipeline to be created is allowed to be the parent of a pipeline that
    will be created in a subsequent pipeline creation call.
  * ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT specifies that the pipeline to
    be created will be a child of a previously created parent pipeline.
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scremoved[]
  * elink:VkPipelineCreateFlagBits
  ** ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT <<SCID-8>>
  ** ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT <<SCID-8>>
// end::scremoved[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * ename:VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT specifies that
    any shader input variables decorated as code:ViewIndex will be assigned
    values as if they were decorated as code:DeviceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
  * ename:VK_PIPELINE_CREATE_DISPATCH_BASE specifies that a compute pipeline
    can: be used with flink:vkCmdDispatchBase with a non-zero base
    workgroup.
endif::VK_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_NV_ray_tracing[]
  * ename:VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV specifies that a pipeline
    is created with all shaders in the deferred state.
    Before using the pipeline the application must: call
    flink:vkCompileDeferredNV exactly once on each shader in the pipeline
    before using the pipeline.
endif::VK_NV_ray_tracing[]
ifdef::VK_KHR_pipeline_executable_properties[]
  * ename:VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR specifies that the
    shader compiler should capture statistics for the pipeline executables
    produced by the compile process which can: later be retrieved by calling
    flink:vkGetPipelineExecutableStatisticsKHR.
    Enabling this flag must: not affect the final compiled pipeline but may:
    disable pipeline caching or otherwise affect pipeline creation time.
  * ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
    specifies that the shader compiler should capture the internal
    representations of pipeline executables produced by the compile process
    which can: later be retrieved by calling
    flink:vkGetPipelineExecutableInternalRepresentationsKHR.
    Enabling this flag must: not affect the final compiled pipeline but may:
    disable pipeline caching or otherwise affect pipeline creation time.
ifdef::VK_KHR_pipeline_library[]
    When capturing IR from pipelines created with pipeline libraries, there
    is no guarantee that IR from libraries can: be retrieved from the linked
    pipeline.
    Applications should: retrieve IR from each library, and any linked
    pipelines, separately.
endif::VK_KHR_pipeline_library[]
endif::VK_KHR_pipeline_executable_properties[]
ifdef::VK_KHR_pipeline_library[]
  * ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR specifies that the pipeline
    cannot: be used directly, and instead defines a _pipeline library_ that
    can: be combined with other pipelines using the
    slink:VkPipelineLibraryCreateInfoKHR structure.
ifdef::VK_KHR_ray_tracing_pipeline,VK_EXT_graphics_pipeline_library[]
    This is available in
ifdef::VK_KHR_ray_tracing_pipeline[ray tracing]
ifdef::VK_KHR_ray_tracing_pipeline+VK_EXT_graphics_pipeline_library[and]
ifdef::VK_EXT_graphics_pipeline_library[graphics]
    pipelines.
endif::VK_KHR_ray_tracing_pipeline,VK_EXT_graphics_pipeline_library[]
endif::VK_KHR_pipeline_library[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR
    specifies that an any-hit shader will always be present when an any-hit
    shader would be executed.
    A NULL any-hit shader is an any-hit shader which is effectively
    ename:VK_SHADER_UNUSED_KHR, such as from a shader group consisting
    entirely of zeros.
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
    specifies that a closest hit shader will always be present when a
    closest hit shader would be executed.
    A NULL closest hit shader is a closest hit shader which is effectively
    ename:VK_SHADER_UNUSED_KHR, such as from a shader group consisting
    entirely of zeros.
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
    specifies that a miss shader will always be present when a miss shader
    would be executed.
    A NULL miss shader is a miss shader which is effectively
    ename:VK_SHADER_UNUSED_KHR, such as from a shader group consisting
    entirely of zeros.
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
    specifies that an intersection shader will always be present when an
    intersection shader would be executed.
    A NULL intersection shader is an intersection shader which is
    effectively ename:VK_SHADER_UNUSED_KHR, such as from a shader group
    consisting entirely of zeros.
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR specifies
    that triangle primitives will be skipped during traversal using
    <<glossary-pipeline-trace-ray, pipeline trace ray>> instructions.
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR specifies that
    AABB primitives will be skipped during traversal using
    <<glossary-pipeline-trace-ray, pipeline trace ray>> instructions.
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
    specifies that the shader group handles can: be saved and reused on a
    subsequent run (e.g. for trace capture and replay).
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_device_generated_commands[]
  * ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV specifies that the
    pipeline can be used in combination with <<device-generated-commands>>.
endif::VK_NV_device_generated_commands[]
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT specifies
    that pipeline creation will fail if a compile is required for creation
    of a valid slink:VkPipeline object; ename:VK_PIPELINE_COMPILE_REQUIRED
    will be returned by pipeline creation, and the slink:VkPipeline will be
    set to dlink:VK_NULL_HANDLE.
  * When creating multiple pipelines,
    ename:VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT specifies that
    control will be returned to the application if any individual pipeline
    returns a result which is not ename:VK_SUCCESS rather than continuing to
    create additional pipelines.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifdef::VK_NV_ray_tracing_motion_blur[]
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV specifies that
    the pipeline is allowed to use code:OpTraceRayMotionNV.
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_KHR_fragment_shading_rate[]
  * ename:VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
    specifies that the pipeline will be used with a fragment shading rate
    attachment and dynamic rendering.
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_EXT_fragment_density_map[]
  * ename:VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
    specifies that the pipeline will be used with a fragment density map
    attachment and dynamic rendering.
endif::VK_EXT_fragment_density_map[]
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_EXT_graphics_pipeline_library[]
  * ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT specifies that
    pipeline libraries being linked into this library should: have link time
    optimizations applied.
    If this bit is omitted, implementations should: instead perform linking
    as rapidly as possible.
  * ename:VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT
    specifies that pipeline libraries should retain any information
    necessary to later perform an optimal link with
    ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT.
endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_EXT_descriptor_buffer[]
  * ename:VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT specifies that a
    pipeline will be used with <<descriptorbuffers,descriptor buffers>>,
    rather than <<descriptorsets,descriptor sets>>.
endif::VK_EXT_descriptor_buffer[]
ifdef::VK_EXT_attachment_feedback_loop_layout[]
  * ename:VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
    specifies that the pipeline may: be used with an attachment feedback
    loop including color attachments.
ifdef::VK_EXT_attachment_feedback_loop_dynamic_state[]
    It is ignored if
    ename:VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT is set in
    pname:pDynamicStates.
endif::VK_EXT_attachment_feedback_loop_dynamic_state[]
  * ename:VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
    specifies that the pipeline may: be used with an attachment feedback
    loop including depth-stencil attachments.
ifdef::VK_EXT_attachment_feedback_loop_dynamic_state[]
    It is ignored if
    ename:VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT is set in
    pname:pDynamicStates.
endif::VK_EXT_attachment_feedback_loop_dynamic_state[]
endif::VK_EXT_attachment_feedback_loop_layout[]
ifdef::VK_EXT_opacity_micromap[]
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT specifies
    that the ray tracing pipeline can: be used with acceleration structures
    which reference an opacity micromap array.
endif::VK_EXT_opacity_micromap[]
ifdef::VK_NV_displacement_micromap[]
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV
    specifies that the ray tracing pipeline can: be used with acceleration
    structures which reference a displacement micromap array.
endif::VK_NV_displacement_micromap[]
ifdef::VK_EXT_pipeline_protected_access[]
  * ename:VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT specifies that the
    pipeline must: not be bound to a protected command buffer.
  * ename:VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT specifies that
    the pipeline must: not be bound to an unprotected command buffer.
endif::VK_EXT_pipeline_protected_access[]

ifndef::VKSC_VERSION_1_0[]
It is valid to set both ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT and
ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT.
This allows a pipeline to be both a parent and possibly a child in a
pipeline hierarchy.
See <<pipelines-pipeline-derivatives,Pipeline Derivatives>> for more
information.
endif::VKSC_VERSION_1_0[]

ifdef::VK_EXT_graphics_pipeline_library[]
When an implementation is looking up a pipeline in a
<<pipelines-cache,pipeline cache>>, if that pipeline is being created using
linked libraries, implementations should: always return an equivalent
pipeline created with
ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT if available,
whether or not that bit was specified.

[NOTE]
====
Using ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT (or not) when
linking pipeline libraries is intended as a performance tradeoff between
host and device.
If the bit is omitted, linking should be faster and produce a pipeline more
rapidly, but performance of the pipeline on the target device may be
reduced.
If the bit is included, linking may be slower but should produce a pipeline
with device performance comparable to a monolithically created pipeline.
Using both options can allow latency-sensitive applications to generate a
suboptimal but usable pipeline quickly, and then perform an optimal link in
the background, substituting the result for the suboptimally linked pipeline
as soon as it is available.
====
endif::VK_EXT_graphics_pipeline_library[]
--

[open,refpage='VkPipelineCreateFlags',desc='Bitmask of VkPipelineCreateFlagBits',type='flags']
--
include::{generated}/api/flags/VkPipelineCreateFlags.adoc[]

tname:VkPipelineCreateFlags is a bitmask type for setting a mask of zero or
more elink:VkPipelineCreateFlagBits.
--

ifdef::VK_KHR_pipeline_binary[]
[open,refpage='VkPipelineBinaryInfoKHR',desc='Structure specifying pipeline binaries to use during pipeline creation',type='structs']
--
The sname:VkPipelineBinaryInfoKHR structure is defined as:

include::{generated}/api/structs/VkPipelineBinaryInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:binaryCount is the number of elements in the
    pname:pPipelineBinaries array.
  * pname:pPipelineBinaries is a pointer to an array of
    slink:VkPipelineBinaryKHR handles.

If a sname:VkPipelineBinaryInfoKHR structure with a pname:binaryCount
greater than 0 is included in the pname:pNext chain of any
stext:Vk*PipelineCreateInfo structure when creating a pipeline,
implementations must: use the data in pname:pPipelineBinaries instead of
recalculating it.
Any shader module identifiers or shader modules declared in
slink:VkPipelineShaderStageCreateInfo instances are ignored.

If this structure is not included in the pname:pNext chain, it is equivalent
to specifying this structure with a pname:binaryCount of `0`.

.Valid Usage
****
  * [[VUID-VkPipelineBinaryInfoKHR-binaryCount-09603]]
    pname:binaryCount and the order of the elements in
    pname:pPipelineBinaries must: exactly match that returned by
    flink:vkCreatePipelineBinariesKHR for the matching
    stext:Vk*PipelineCreateInfo structure and its pname:pNext chain,
    ignoring the presence of the sname:VkPipelineBinaryInfoKHR structure,
    the presence of the ename:VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR
    flag, and absence of any shader module identifiers or shader modules,
    for the same <<global-pipeline-key,global pipeline key>>, from either:
  ** slink:VkPipelineBinaryCreateInfoKHR::pname:pPipelineCreateInfo, or
  ** slink:VkPipelineBinaryCreateInfoKHR::pname:pipeline
****

include::{generated}/validity/structs/VkPipelineBinaryInfoKHR.adoc[]
--
endif::VK_KHR_pipeline_binary[]

ifdef::VK_EXT_graphics_pipeline_library[]
[open,refpage='VkGraphicsPipelineLibraryCreateInfoEXT',desc='Structure specifying the subsets of the graphics pipeline being compiled',type='structs']
--
The sname:VkGraphicsPipelineLibraryCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkGraphicsPipelineLibraryCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkGraphicsPipelineLibraryFlagBitsEXT
    specifying the subsets of the graphics pipeline that are being compiled.

If a sname:VkGraphicsPipelineLibraryCreateInfoEXT structure is included in
the pname:pNext chain of slink:VkGraphicsPipelineCreateInfo, it specifies
the <<pipelines-graphics-subsets,subsets of the graphics pipeline>> being
created, excluding any subsets from linked pipeline libraries.
If the pipeline is created with pipeline libraries, state from those
libraries is aggregated with said subset.

If this structure is omitted, and either
slink:VkGraphicsPipelineCreateInfo::pname:flags includes
ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR or the
slink:VkGraphicsPipelineCreateInfo::pname:pNext chain includes a
slink:VkPipelineLibraryCreateInfoKHR structure with a pname:libraryCount
greater than `0`, it is as if pname:flags is `0`.
Otherwise if this structure is omitted, it is as if pname:flags includes all
possible subsets of the graphics pipeline (i.e. a
<<pipelines-graphics-subsets-complete,complete graphics pipeline>>).

include::{generated}/validity/structs/VkGraphicsPipelineLibraryCreateInfoEXT.adoc[]
--

[open,refpage='VkGraphicsPipelineLibraryFlagsEXT', desc='Bitmask of VkGraphicsPipelineLibraryFlagBitsEXT', type='flags']
--
include::{generated}/api/flags/VkGraphicsPipelineLibraryFlagsEXT.adoc[]

tname:VkGraphicsPipelineLibraryFlagsEXT is a bitmask type for setting a mask
of zero or more elink:VkGraphicsPipelineLibraryFlagBitsEXT.
--

[open,refpage='VkGraphicsPipelineLibraryFlagBitsEXT',desc='Bitmask specifying the subset of a graphics pipeline to compile',type='enums']
--
Possible values of the pname:flags member of
slink:VkGraphicsPipelineLibraryCreateInfoEXT, specifying the subsets of a
graphics pipeline to compile are:

include::{generated}/api/enums/VkGraphicsPipelineLibraryFlagBitsEXT.adoc[]

  * ename:VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT
    specifies that a pipeline will include
    <<pipelines-graphics-subsets-vertex-input,vertex input interface
    state>>.
  * ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT
    specifies that a pipeline will include
    <<pipelines-graphics-subsets-pre-rasterization,pre-rasterization shader
    state>>.
  * ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT specifies
    that a pipeline will include
    <<pipelines-graphics-subsets-fragment-shader,fragment shader state>>.
  * ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT
    specifies that a pipeline will include
    <<pipelines-graphics-subsets-fragment-output,fragment output interface
    state>>.
--
endif::VK_EXT_graphics_pipeline_library[]

[open,refpage='VkPipelineDynamicStateCreateInfo',desc='Structure specifying parameters of a newly created pipeline dynamic state',type='structs']
--
The sname:VkPipelineDynamicStateCreateInfo structure is defined as:

include::{generated}/api/structs/VkPipelineDynamicStateCreateInfo.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:dynamicStateCount is the number of elements in the
    pname:pDynamicStates array.
  * pname:pDynamicStates is a pointer to an array of elink:VkDynamicState
    values specifying which pieces of pipeline state will use the values
    from dynamic state commands rather than from pipeline state creation
    information.

.Valid Usage
****
  * [[VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-01442]]
    Each element of pname:pDynamicStates must: be unique
****

include::{generated}/validity/structs/VkPipelineDynamicStateCreateInfo.adoc[]
--

[open,refpage='VkPipelineDynamicStateCreateFlags',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkPipelineDynamicStateCreateFlags.adoc[]

tname:VkPipelineDynamicStateCreateFlags is a bitmask type for setting a
mask, but is currently reserved for future use.
--

[open,refpage='VkDynamicState',desc='Indicate which dynamic state is taken from dynamic state commands',type='enums']
--
The source of different pieces of dynamic state is specified by the
slink:VkPipelineDynamicStateCreateInfo::pname:pDynamicStates property of the
currently active pipeline, each of whose elements must: be one of the
values:

include::{generated}/api/enums/VkDynamicState.adoc[]

  * ename:VK_DYNAMIC_STATE_VIEWPORT specifies that the pname:pViewports
    state in slink:VkPipelineViewportStateCreateInfo will be ignored and
    must: be set dynamically with flink:vkCmdSetViewport before any drawing
    commands.
    The number of viewports used by a pipeline is still specified by the
    pname:viewportCount member of slink:VkPipelineViewportStateCreateInfo.
  * ename:VK_DYNAMIC_STATE_SCISSOR specifies that the pname:pScissors state
    in slink:VkPipelineViewportStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetScissor before any drawing commands.
    The number of scissor rectangles used by a pipeline is still specified
    by the pname:scissorCount member of
    slink:VkPipelineViewportStateCreateInfo.
  * ename:VK_DYNAMIC_STATE_LINE_WIDTH specifies that the pname:lineWidth
    state in slink:VkPipelineRasterizationStateCreateInfo will be ignored
    and must: be set dynamically with flink:vkCmdSetLineWidth before any
    drawing commands that generate line primitives for the rasterizer.
  * ename:VK_DYNAMIC_STATE_DEPTH_BIAS specifies that
ifdef::VK_EXT_depth_bias_control[]
    any instance of slink:VkDepthBiasRepresentationInfoEXT included in the
    pname:pNext chain of slink:VkPipelineRasterizationStateCreateInfo as
    well as
endif::VK_EXT_depth_bias_control[]
    the pname:depthBiasConstantFactor, pname:depthBiasClamp and
    pname:depthBiasSlopeFactor states in
    slink:VkPipelineRasterizationStateCreateInfo will be ignored and must:
    be set dynamically with flink:vkCmdSetDepthBias
ifdef::VK_EXT_depth_bias_control[or flink:vkCmdSetDepthBias2EXT]
    before any draws are performed with <<primsrast-depthbias-enable, depth
    bias enabled>>.
  * ename:VK_DYNAMIC_STATE_BLEND_CONSTANTS specifies that the
    pname:blendConstants state in slink:VkPipelineColorBlendStateCreateInfo
    will be ignored and must: be set dynamically with
    flink:vkCmdSetBlendConstants before any draws are performed with a
    pipeline state with sname:VkPipelineColorBlendAttachmentState member
    pname:blendEnable set to ename:VK_TRUE and any of the blend functions
    using a constant blend color.
  * ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS specifies that the
    pname:minDepthBounds and pname:maxDepthBounds states of
    slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetDepthBounds before any draws are
    performed with a pipeline state with
    slink:VkPipelineDepthStencilStateCreateInfo member
    pname:depthBoundsTestEnable set to ename:VK_TRUE.
  * ename:VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK specifies that the
    pname:compareMask state in slink:VkPipelineDepthStencilStateCreateInfo
    for both pname:front and pname:back will be ignored and must: be set
    dynamically with flink:vkCmdSetStencilCompareMask before any draws are
    performed with a pipeline state with
    slink:VkPipelineDepthStencilStateCreateInfo member
    pname:stencilTestEnable set to ename:VK_TRUE
  * ename:VK_DYNAMIC_STATE_STENCIL_WRITE_MASK specifies that the
    pname:writeMask state in slink:VkPipelineDepthStencilStateCreateInfo for
    both pname:front and pname:back will be ignored and must: be set
    dynamically with flink:vkCmdSetStencilWriteMask before any draws are
    performed with a pipeline state with
    slink:VkPipelineDepthStencilStateCreateInfo member
    pname:stencilTestEnable set to ename:VK_TRUE
  * ename:VK_DYNAMIC_STATE_STENCIL_REFERENCE specifies that the
    pname:reference state in slink:VkPipelineDepthStencilStateCreateInfo for
    both pname:front and pname:back will be ignored and must: be set
    dynamically with flink:vkCmdSetStencilReference before any draws are
    performed with a pipeline state with
    slink:VkPipelineDepthStencilStateCreateInfo member
    pname:stencilTestEnable set to ename:VK_TRUE
ifdef::VK_NV_clip_space_w_scaling[]
  * ename:VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV specifies that the
    pname:pViewportWScalings state in
    slink:VkPipelineViewportWScalingStateCreateInfoNV will be ignored and
    must: be set dynamically with flink:vkCmdSetViewportWScalingNV before
    any draws are performed with a pipeline state with
    slink:VkPipelineViewportWScalingStateCreateInfoNV member
    pname:viewportScalingEnable set to ename:VK_TRUE
endif::VK_NV_clip_space_w_scaling[]
ifdef::VK_EXT_discard_rectangles[]
  * ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT specifies that the
    pname:pDiscardRectangles state in
    slink:VkPipelineDiscardRectangleStateCreateInfoEXT will be ignored and
    must: be set dynamically with flink:vkCmdSetDiscardRectangleEXT before
    any draw or clear commands.
  * ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT specifies that the
    presence of the slink:VkPipelineDiscardRectangleStateCreateInfoEXT
    structure in the slink:VkGraphicsPipelineCreateInfo chain with a
    pname:discardRectangleCount greater than zero does not implicitly enable
    discard rectangles and they must: be enabled dynamically with
    flink:vkCmdSetDiscardRectangleEnableEXT before any draw commands.
    This is available on implementations that support at least
    pname:specVersion `2` of the `apiext:VK_EXT_discard_rectangles`
    extension.
  * ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT specifies that the
    pname:discardRectangleMode state in
    slink:VkPipelineDiscardRectangleStateCreateInfoEXT will be ignored and
    must: be set dynamically with flink:vkCmdSetDiscardRectangleModeEXT
    before any draw commands.
    This is available on implementations that support at least
    pname:specVersion `2` of the `apiext:VK_EXT_discard_rectangles`
    extension.
endif::VK_EXT_discard_rectangles[]
ifdef::VK_EXT_sample_locations[]
  * ename:VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT specifies that the
    pname:sampleLocationsInfo state in
    slink:VkPipelineSampleLocationsStateCreateInfoEXT will be ignored and
    must: be set dynamically with flink:vkCmdSetSampleLocationsEXT before
    any draw or clear commands.
    Enabling custom sample locations is still indicated by the
    pname:sampleLocationsEnable member of
    slink:VkPipelineSampleLocationsStateCreateInfoEXT.
endif::VK_EXT_sample_locations[]
ifdef::VK_NV_scissor_exclusive[]
  * ename:VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV specifies that the
    pname:pExclusiveScissors state in
    slink:VkPipelineViewportExclusiveScissorStateCreateInfoNV will be
    ignored and must: be set dynamically with
    flink:vkCmdSetExclusiveScissorNV before any drawing commands.
  * ename:VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV specifies that the
    exclusive scissors must: be explicitly enabled with
    flink:vkCmdSetExclusiveScissorEnableNV and the
    pname:exclusiveScissorCount value in
    slink:VkPipelineViewportExclusiveScissorStateCreateInfoNV will not
    implicitly enable them.
    This is available on implementations that support at least
    pname:specVersion `2` of the `apiext:VK_NV_scissor_exclusive` extension.
endif::VK_NV_scissor_exclusive[]
ifdef::VK_NV_shading_rate_image[]
  * ename:VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV specifies that
    the pname:pShadingRatePalettes state in
    slink:VkPipelineViewportShadingRateImageStateCreateInfoNV will be
    ignored and must: be set dynamically with
    flink:vkCmdSetViewportShadingRatePaletteNV before any drawing commands.
  * ename:VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV specifies that
    the coarse sample order state in
    slink:VkPipelineViewportCoarseSampleOrderStateCreateInfoNV will be
    ignored and must: be set dynamically with
    flink:vkCmdSetCoarseSampleOrderNV before any drawing commands.
endif::VK_NV_shading_rate_image[]
ifdef::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
  * ename:VK_DYNAMIC_STATE_LINE_STIPPLE_EXT specifies that the
    pname:lineStippleFactor and pname:lineStipplePattern state in
    slink:VkPipelineRasterizationLineStateCreateInfoKHR will be ignored and
    must: be set dynamically with flink:vkCmdSetLineStippleKHR before any
    draws are performed with a pipeline state with
    slink:VkPipelineRasterizationLineStateCreateInfoKHR member
    pname:stippledLineEnable set to ename:VK_TRUE.
endif::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
  * ename:VK_DYNAMIC_STATE_CULL_MODE specifies that the pname:cullMode state
    in slink:VkPipelineRasterizationStateCreateInfo will be ignored and
    must: be set dynamically with flink:vkCmdSetCullMode before any drawing
    commands.
  * ename:VK_DYNAMIC_STATE_FRONT_FACE specifies that the pname:frontFace
    state in slink:VkPipelineRasterizationStateCreateInfo will be ignored
    and must: be set dynamically with flink:vkCmdSetFrontFace before any
    drawing commands.
  * ename:VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY specifies that the
    pname:topology state in slink:VkPipelineInputAssemblyStateCreateInfo
    only specifies the <<drawing-primitive-topology-class, topology class>>,
    and the specific topology order and adjacency must: be set dynamically
    with flink:vkCmdSetPrimitiveTopology before any drawing commands.
  * ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT specifies that the
    pname:viewportCount and pname:pViewports state in
    slink:VkPipelineViewportStateCreateInfo will be ignored and must: be set
    dynamically with flink:vkCmdSetViewportWithCount before any draw call.
  * ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT specifies that the
    pname:scissorCount and pname:pScissors state in
    slink:VkPipelineViewportStateCreateInfo will be ignored and must: be set
    dynamically with flink:vkCmdSetScissorWithCount before any draw call.
  * ename:VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE specifies that the
    pname:stride state in slink:VkVertexInputBindingDescription will be
    ignored and must: be set dynamically with flink:vkCmdBindVertexBuffers2
    before any draw call.
  * ename:VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE specifies that the
    pname:depthTestEnable state in
    slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetDepthTestEnable before any draw call.
  * ename:VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE specifies that the
    pname:depthWriteEnable state in
    slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetDepthWriteEnable before any draw
    call.
  * ename:VK_DYNAMIC_STATE_DEPTH_COMPARE_OP specifies that the
    pname:depthCompareOp state in
    slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetDepthCompareOp before any draw call.
  * ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE specifies that the
    pname:depthBoundsTestEnable state in
    slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetDepthBoundsTestEnable before any draw
    call.
  * ename:VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE specifies that the
    pname:stencilTestEnable state in
    slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetStencilTestEnable before any draw
    call.
  * ename:VK_DYNAMIC_STATE_STENCIL_OP specifies that the pname:failOp,
    pname:passOp, pname:depthFailOp, and pname:compareOp states in
    sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and
    pname:back will be ignored and must: be set dynamically with
    flink:vkCmdSetStencilOp before any draws are performed with a pipeline
    state with sname:VkPipelineDepthStencilStateCreateInfo member
    pname:stencilTestEnable set to ename:VK_TRUE
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
ifdef::VK_EXT_extended_dynamic_state2[]
  * ename:VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT specifies that the
    pname:patchControlPoints state in
    slink:VkPipelineTessellationStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetPatchControlPointsEXT before any
    drawing commands.
endif::VK_EXT_extended_dynamic_state2[]
  * ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE specifies that the
    pname:rasterizerDiscardEnable state in
    slink:VkPipelineRasterizationStateCreateInfo will be ignored and must:
    be set dynamically with flink:vkCmdSetRasterizerDiscardEnable before any
    drawing commands.
  * ename:VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE specifies that the
    pname:depthBiasEnable state in
    slink:VkPipelineRasterizationStateCreateInfo will be ignored and must:
    be set dynamically with flink:vkCmdSetDepthBiasEnable before any drawing
    commands.
ifdef::VK_EXT_extended_dynamic_state2[]
  * ename:VK_DYNAMIC_STATE_LOGIC_OP_EXT specifies that the pname:logicOp
    state in slink:VkPipelineColorBlendStateCreateInfo will be ignored and
    must: be set dynamically with flink:vkCmdSetLogicOpEXT before any
    drawing commands.
endif::VK_EXT_extended_dynamic_state2[]
  * ename:VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE specifies that the
    pname:primitiveRestartEnable state in
    slink:VkPipelineInputAssemblyStateCreateInfo will be ignored and must:
    be set dynamically with flink:vkCmdSetPrimitiveRestartEnable before any
    drawing commands.
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
ifdef::VK_KHR_fragment_shading_rate[]
  * ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR specifies that state in
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR
ifdef::VK_NV_fragment_shading_rate_enums[]
    and slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV
endif::VK_NV_fragment_shading_rate_enums[]
    will be ignored and must: be set dynamically with
    flink:vkCmdSetFragmentShadingRateKHR
ifdef::VK_NV_fragment_shading_rate_enums[]
    or flink:vkCmdSetFragmentShadingRateEnumNV
endif::VK_NV_fragment_shading_rate_enums[]
    before any drawing commands.
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * ename:VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR specifies
    that the default stack size computation for the pipeline will be ignored
    and must: be set dynamically with
    flink:vkCmdSetRayTracingPipelineStackSizeKHR before any ray tracing
    calls are performed.
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_EXT_vertex_input_dynamic_state[]
  * ename:VK_DYNAMIC_STATE_VERTEX_INPUT_EXT specifies that the
    pname:pVertexInputState state will be ignored and must: be set
    dynamically with flink:vkCmdSetVertexInputEXT before any drawing
    commands
endif::VK_EXT_vertex_input_dynamic_state[]
ifdef::VK_EXT_color_write_enable[]
  * ename:VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT specifies that the
    pname:pColorWriteEnables state in
    slink:VkPipelineColorWriteCreateInfoEXT will be ignored and must: be set
    dynamically with flink:vkCmdSetColorWriteEnableEXT before any draw call.
endif::VK_EXT_color_write_enable[]
ifdef::VK_EXT_extended_dynamic_state3[]
  * ename:VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT specifies that the
    pname:domainOrigin state in
    slink:VkPipelineTessellationDomainOriginStateCreateInfo will be ignored
    and must: be set dynamically with
    flink:vkCmdSetTessellationDomainOriginEXT before any draw call.
  * ename:VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT specifies that the
    pname:depthClampEnable state in
    slink:VkPipelineRasterizationStateCreateInfo will be ignored and must:
    be set dynamically with flink:vkCmdSetDepthClampEnableEXT before any
    draw call.
  * ename:VK_DYNAMIC_STATE_POLYGON_MODE_EXT specifies that the
    pname:polygonMode state in slink:VkPipelineRasterizationStateCreateInfo
    will be ignored and must: be set dynamically with
    flink:vkCmdSetPolygonModeEXT before any draw call.
  * ename:VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT specifies that the
    pname:rasterizationSamples state in
    slink:VkPipelineMultisampleStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetRasterizationSamplesEXT before any
    draw call.
  * ename:VK_DYNAMIC_STATE_SAMPLE_MASK_EXT specifies that the
    pname:pSampleMask state in slink:VkPipelineMultisampleStateCreateInfo
    will be ignored and must: be set dynamically with
    flink:vkCmdSetSampleMaskEXT before any draw call.
  * ename:VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT specifies that the
    pname:alphaToCoverageEnable state in
    slink:VkPipelineMultisampleStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetAlphaToCoverageEnableEXT before any
    draw call.
  * ename:VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT specifies that the
    pname:alphaToOneEnable state in
    slink:VkPipelineMultisampleStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetAlphaToOneEnableEXT before any draw
    call.
  * ename:VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT specifies that the
    pname:logicOpEnable state in slink:VkPipelineColorBlendStateCreateInfo
    will be ignored and must: be set dynamically with
    flink:vkCmdSetLogicOpEnableEXT before any draw call.
  * ename:VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT specifies that the
    pname:blendEnable state in slink:VkPipelineColorBlendAttachmentState
    will be ignored and must: be set dynamically with
    flink:vkCmdSetColorBlendEnableEXT before any draw call.
  * ename:VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT specifies that the
    pname:srcColorBlendFactor, pname:dstColorBlendFactor,
    pname:colorBlendOp, pname:srcAlphaBlendFactor,
    pname:dstAlphaBlendFactor, and pname:alphaBlendOp states in
    slink:VkPipelineColorBlendAttachmentState will be ignored and must: be
    set dynamically with flink:vkCmdSetColorBlendEquationEXT before any draw
    call.
  * ename:VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT specifies that the
    pname:colorWriteMask state in slink:VkPipelineColorBlendAttachmentState
    will be ignored and must: be set dynamically with
    flink:vkCmdSetColorWriteMaskEXT before any draw call.
ifdef::VK_EXT_transform_feedback[]
  * ename:VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT specifies that the
    pname:rasterizationStream state in
    slink:VkPipelineRasterizationStateStreamCreateInfoEXT will be ignored
    and must: be set dynamically with flink:vkCmdSetRasterizationStreamEXT
    before any draw call.
endif::VK_EXT_transform_feedback[]
ifdef::VK_EXT_conservative_rasterization[]
  * ename:VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT specifies
    that the pname:conservativeRasterizationMode state in
    slink:VkPipelineRasterizationConservativeStateCreateInfoEXT will be
    ignored and must: be set dynamically with
    flink:vkCmdSetConservativeRasterizationModeEXT before any draw call.
  * ename:VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT specifies
    that the pname:extraPrimitiveOverestimationSize state in
    slink:VkPipelineRasterizationConservativeStateCreateInfoEXT will be
    ignored and must: be set dynamically with
    flink:vkCmdSetExtraPrimitiveOverestimationSizeEXT before any draw call.
endif::VK_EXT_conservative_rasterization[]
ifdef::VK_EXT_depth_clip_enable[]
  * ename:VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT specifies that the
    pname:depthClipEnable state in
    slink:VkPipelineRasterizationDepthClipStateCreateInfoEXT will be ignored
    and must: be set dynamically with flink:vkCmdSetDepthClipEnableEXT
    before any draw call.
endif::VK_EXT_depth_clip_enable[]
ifdef::VK_EXT_sample_locations[]
  * ename:VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT specifies that the
    pname:sampleLocationsEnable state in
    slink:VkPipelineSampleLocationsStateCreateInfoEXT will be ignored and
    must: be set dynamically with flink:vkCmdSetSampleLocationsEnableEXT
    before any draw call.
endif::VK_EXT_sample_locations[]
ifdef::VK_EXT_blend_operation_advanced[]
  * ename:VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT specifies that the
    pname:colorBlendOp state in slink:VkPipelineColorBlendAttachmentState,
    and pname:srcPremultiplied, pname:dstPremultiplied, and
    pname:blendOverlap states in
    slink:VkPipelineColorBlendAdvancedStateCreateInfoEXT will be ignored and
    must: be set dynamically with flink:vkCmdSetColorBlendAdvancedEXT before
    any draw call.
endif::VK_EXT_blend_operation_advanced[]
ifdef::VK_EXT_provoking_vertex[]
  * ename:VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT specifies that the
    pname:provokingVertexMode state in
    slink:VkPipelineRasterizationProvokingVertexStateCreateInfoEXT will be
    ignored and must: be set dynamically with
    flink:vkCmdSetProvokingVertexModeEXT before any draw call.
endif::VK_EXT_provoking_vertex[]
ifdef::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
  * ename:VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT specifies that the
    pname:lineRasterizationMode state in
    slink:VkPipelineRasterizationLineStateCreateInfoKHR will be ignored and
    must: be set dynamically with flink:vkCmdSetLineRasterizationModeEXT
    before any draw call.
  * ename:VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT specifies that the
    pname:stippledLineEnable state in
    slink:VkPipelineRasterizationLineStateCreateInfoKHR will be ignored and
    must: be set dynamically with flink:vkCmdSetLineStippleEnableEXT before
    any draw call.
endif::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
ifdef::VK_EXT_depth_clip_control[]
  * ename:VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT specifies that
    the pname:negativeOneToOne state in
    slink:VkPipelineViewportDepthClipControlCreateInfoEXT will be ignored
    and must: be set dynamically with
    flink:vkCmdSetDepthClipNegativeOneToOneEXT before any draw call.
endif::VK_EXT_depth_clip_control[]
ifdef::VK_NV_clip_space_w_scaling[]
  * ename:VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV specifies that the
    pname:viewportWScalingEnable state in
    slink:VkPipelineViewportWScalingStateCreateInfoNV will be ignored and
    must: be set dynamically with flink:vkCmdSetViewportWScalingEnableNV
    before any draw call.
endif::VK_NV_clip_space_w_scaling[]
ifdef::VK_NV_viewport_swizzle[]
  * ename:VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV specifies that the
    pname:viewportCount, and pname:pViewportSwizzles states in
    slink:VkPipelineViewportSwizzleStateCreateInfoNV will be ignored and
    must: be set dynamically with flink:vkCmdSetViewportSwizzleNV before any
    draw call.
endif::VK_NV_viewport_swizzle[]
ifdef::VK_NV_fragment_coverage_to_color[]
  * ename:VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV specifies that the
    pname:coverageToColorEnable state in
    slink:VkPipelineCoverageToColorStateCreateInfoNV will be ignored and
    must: be set dynamically with flink:vkCmdSetCoverageToColorEnableNV
    before any draw call.
  * ename:VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV specifies that the
    pname:coverageToColorLocation state in
    slink:VkPipelineCoverageToColorStateCreateInfoNV will be ignored and
    must: be set dynamically with flink:vkCmdSetCoverageToColorLocationNV
    before any draw call.
endif::VK_NV_fragment_coverage_to_color[]
ifdef::VK_NV_framebuffer_mixed_samples[]
  * ename:VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV specifies that the
    pname:coverageModulationMode state in
    slink:VkPipelineCoverageModulationStateCreateInfoNV will be ignored and
    must: be set dynamically with flink:vkCmdSetCoverageModulationModeNV
    before any draw call.
  * ename:VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV specifies
    that the pname:coverageModulationTableEnable state in
    slink:VkPipelineCoverageModulationStateCreateInfoNV will be ignored and
    must: be set dynamically with
    flink:vkCmdSetCoverageModulationTableEnableNV before any draw call.
  * ename:VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV specifies that the
    pname:coverageModulationTableCount, and pname:pCoverageModulationTable
    states in slink:VkPipelineCoverageModulationStateCreateInfoNV will be
    ignored and must: be set dynamically with
    flink:vkCmdSetCoverageModulationTableNV before any draw call.
endif::VK_NV_framebuffer_mixed_samples[]
ifdef::VK_NV_shading_rate_image[]
  * ename:VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV specifies that the
    pname:shadingRateImageEnable state in
    slink:VkPipelineViewportShadingRateImageStateCreateInfoNV will be
    ignored and must: be set dynamically with
    flink:vkCmdSetShadingRateImageEnableNV before any draw call.
endif::VK_NV_shading_rate_image[]
ifdef::VK_NV_representative_fragment_test[]
  * ename:VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV specifies
    that the pname:representativeFragmentTestEnable state in
    slink:VkPipelineRepresentativeFragmentTestStateCreateInfoNV will be
    ignored and must: be set dynamically with
    flink:vkCmdSetRepresentativeFragmentTestEnableNV before any draw call.
endif::VK_NV_representative_fragment_test[]
ifdef::VK_NV_coverage_reduction_mode[]
  * ename:VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV specifies that the
    pname:coverageReductionMode state in
    slink:VkPipelineCoverageReductionStateCreateInfoNV will be ignored and
    must: be set dynamically with flink:vkCmdSetCoverageReductionModeNV
    before any draw call.
endif::VK_NV_coverage_reduction_mode[]
ifdef::VK_EXT_attachment_feedback_loop_dynamic_state[]
  * ename:VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT specifies
    that the ename:VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
    and
    ename:VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
    flags will be ignored and must: be set dynamically with
    flink:vkCmdSetAttachmentFeedbackLoopEnableEXT before any draw call.
endif::VK_EXT_attachment_feedback_loop_dynamic_state[]
endif::VK_EXT_extended_dynamic_state3[]
--


=== Valid Combinations of Stages for Graphics Pipelines

ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
Primitive processing can be handled either on a per primitive basis by the
vertex, tessellation, and geometry shader stages, or on a per mesh basis
using task and mesh shader stages.
If the pipeline includes a mesh shader stage, it uses the mesh pipeline,
otherwise it uses the primitive pipeline.

If a task shader is omitted, the task shading stage is skipped.
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]

If tessellation shader stages are omitted, the tessellation shading and
fixed-function stages of the pipeline are skipped.

If a geometry shader is omitted, the geometry shading stage is skipped.

If a fragment shader is omitted, fragment color outputs have undefined:
values, and the fragment depth value is determined by <<fragops, Fragment
Operations>> state.
This can: be useful for depth-only rendering.

ifdef::VKSC_VERSION_1_0[]
Presence of a shader stage in a pipeline is derived from the
<<pipelines-cache,pipeline cache>> entry identified by
slink:VkPipelineOfflineCreateInfo::pname:pipelineIdentifier.
endif::VKSC_VERSION_1_0[]
ifndef::VKSC_VERSION_1_0[]
Presence of a shader stage in a pipeline is indicated by including a valid
slink:VkPipelineShaderStageCreateInfo with pname:module and pname:pName
selecting an entry point from a shader module, where that entry point is
valid for the stage specified by pname:stage.
endif::VKSC_VERSION_1_0[]

Presence of some of the fixed-function stages in the pipeline is implicitly
derived from enabled shaders and provided state.
For example, the fixed-function tessellator is always present when the
pipeline has valid Tessellation Control and Tessellation Evaluation shaders.

.For example:
  * Depth/stencil-only rendering in a subpass with no color attachments
  ** Active Pipeline Shader Stages
  *** Vertex Shader
  ** Required: Fixed-Function Pipeline Stages
  *** slink:VkPipelineVertexInputStateCreateInfo
  *** slink:VkPipelineInputAssemblyStateCreateInfo
  *** slink:VkPipelineViewportStateCreateInfo
  *** slink:VkPipelineRasterizationStateCreateInfo
  *** slink:VkPipelineMultisampleStateCreateInfo
  *** slink:VkPipelineDepthStencilStateCreateInfo
  * Color-only rendering in a subpass with no depth/stencil attachment
  ** Active Pipeline Shader Stages
  *** Vertex Shader
  *** Fragment Shader
  ** Required: Fixed-Function Pipeline Stages
  *** slink:VkPipelineVertexInputStateCreateInfo
  *** slink:VkPipelineInputAssemblyStateCreateInfo
  *** slink:VkPipelineViewportStateCreateInfo
  *** slink:VkPipelineRasterizationStateCreateInfo
  *** slink:VkPipelineMultisampleStateCreateInfo
  *** slink:VkPipelineColorBlendStateCreateInfo
  * Rendering pipeline with tessellation and geometry shaders
  ** Active Pipeline Shader Stages
  *** Vertex Shader
  *** Tessellation Control Shader
  *** Tessellation Evaluation Shader
  *** Geometry Shader
  *** Fragment Shader
  ** Required: Fixed-Function Pipeline Stages
  *** slink:VkPipelineVertexInputStateCreateInfo
  *** slink:VkPipelineInputAssemblyStateCreateInfo
  *** slink:VkPipelineTessellationStateCreateInfo
  *** slink:VkPipelineViewportStateCreateInfo
  *** slink:VkPipelineRasterizationStateCreateInfo
  *** slink:VkPipelineMultisampleStateCreateInfo
  *** slink:VkPipelineDepthStencilStateCreateInfo
  *** slink:VkPipelineColorBlendStateCreateInfo
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * Rendering pipeline with task and mesh shaders
  ** Active Pipeline Shader Stages
  *** Task Shader
  *** Mesh Shader
  *** Fragment Shader
  ** Required: Fixed-Function Pipeline Stages
  *** slink:VkPipelineViewportStateCreateInfo
  *** slink:VkPipelineRasterizationStateCreateInfo
  *** slink:VkPipelineMultisampleStateCreateInfo
  *** slink:VkPipelineDepthStencilStateCreateInfo
  *** slink:VkPipelineColorBlendStateCreateInfo
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]


ifdef::VK_NV_device_generated_commands[]
[[graphics-shadergroups]]
=== Graphics Pipeline Shader Groups

Graphics pipelines can contain multiple shader groups that can be bound
individually.
Each shader group behaves as if it was a pipeline using the shader group's
state.
When the pipeline is bound by regular means, it behaves as if the state of
group `0` is active, use flink:vkCmdBindPipelineShaderGroupNV to bind an
individual shader group.

The primary purpose of shader groups is allowing the device to bind
different pipeline state using <<device-generated-commands>>.

[open,refpage='VkGraphicsPipelineShaderGroupsCreateInfoNV',desc='Structure specifying parameters of a newly created multi shader group pipeline',type='structs']
--
The sname:VkGraphicsPipelineShaderGroupsCreateInfoNV structure is defined
as:

include::{generated}/api/structs/VkGraphicsPipelineShaderGroupsCreateInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:groupCount is the number of elements in the pname:pGroups array.
  * pname:pGroups is a pointer to an array of
    slink:VkGraphicsShaderGroupCreateInfoNV structures specifying which
    state of the original slink:VkGraphicsPipelineCreateInfo each shader
    group overrides.
  * pname:pipelineCount is the number of elements in the pname:pPipelines
    array.
  * pname:pPipelines is a pointer to an array of graphics sname:VkPipeline
    structures which are referenced within the created pipeline, including
    all their shader groups.

When referencing shader groups by index, groups defined in the referenced
pipelines are treated as if they were defined as additional entries in
pname:pGroups.
They are appended in the order they appear in the pname:pPipelines array and
in the pname:pGroups array when those pipelines were defined.

The application must: maintain the lifetime of all such referenced pipelines
based on the pipelines that make use of them.

.Valid Usage
****
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-groupCount-02879]]
    pname:groupCount must: be at least `1` and as maximum
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:maxGraphicsShaderGroupCount
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-groupCount-02880]]
    The sum of pname:groupCount including those groups added from referenced
    pname:pPipelines must: also be as maximum
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:maxGraphicsShaderGroupCount
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02881]]
    The state of the first element of pname:pGroups must: match its
    equivalent within the parent's slink:VkGraphicsPipelineCreateInfo
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02882]]
    Each element of pname:pGroups must: in combination with the rest of the
    pipeline state yield a valid state configuration
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02884]]
    All elements of pname:pGroups must: use the same shader stage
    combinations
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
    unless any mesh shader stage is used, then either combination of task
    and mesh or just mesh shader is valid
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02885]]
    Mesh and regular primitive shading stages cannot be mixed across
    pname:pGroups
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pPipelines-02886]]
    Each element of pname:pPipelines must: have been created with identical
    state to the pipeline currently created except the state that can be
    overridden by slink:VkGraphicsShaderGroupCreateInfoNV
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-deviceGeneratedCommands-02887]]
    The <<features-deviceGeneratedCommands, pname:deviceGeneratedCommands>>
    feature must: be enabled
****

include::{generated}/validity/structs/VkGraphicsPipelineShaderGroupsCreateInfoNV.adoc[]
--

[open,refpage='VkGraphicsShaderGroupCreateInfoNV',desc='Structure specifying override parameters for each shader group',type='structs']
--
The sname:VkGraphicsShaderGroupCreateInfoNV structure provides the state
overrides for each shader group.
Each shader group behaves like a pipeline that was created from its state as
well as the remaining parent's state.
It is defined as:

include::{generated}/api/structs/VkGraphicsShaderGroupCreateInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:stageCount is the number of entries in the pname:pStages array.
  * pname:pStages is a pointer to an array
    slink:VkPipelineShaderStageCreateInfo structures specifying the set of
    the shader stages to be included in this shader group.
  * pname:pVertexInputState is a pointer to a
    slink:VkPipelineVertexInputStateCreateInfo structure.
  * pname:pTessellationState is a pointer to a
    slink:VkPipelineTessellationStateCreateInfo structure, and is ignored if
    the shader group does not include a tessellation control shader stage
    and tessellation evaluation shader stage.

.Valid Usage
****
  * [[VUID-VkGraphicsShaderGroupCreateInfoNV-stageCount-02888]]
    For pname:stageCount, the same restrictions as in
    slink:VkGraphicsPipelineCreateInfo::pname:stageCount apply
  * [[VUID-VkGraphicsShaderGroupCreateInfoNV-pStages-02889]]
    For pname:pStages, the same restrictions as in
    slink:VkGraphicsPipelineCreateInfo::pname:pStages apply
  * [[VUID-VkGraphicsShaderGroupCreateInfoNV-pVertexInputState-02890]]
    For pname:pVertexInputState, the same restrictions as in
    slink:VkGraphicsPipelineCreateInfo::pname:pVertexInputState apply
  * [[VUID-VkGraphicsShaderGroupCreateInfoNV-pTessellationState-02891]]
    For pname:pTessellationState, the same restrictions as in
    slink:VkGraphicsPipelineCreateInfo::pname:pTessellationState apply
****

include::{generated}/validity/structs/VkGraphicsShaderGroupCreateInfoNV.adoc[]
--
endif::VK_NV_device_generated_commands[]


ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
[[pipelines-ray-tracing]]
== Ray Tracing Pipelines

Ray tracing pipelines consist of multiple shader stages, fixed-function
traversal stages, and a pipeline layout.

[open,refpage='VK_SHADER_UNUSED_KHR',desc='Sentinel for an unused shader index',type='consts',alias='VK_SHADER_UNUSED_NV']
--
ename:VK_SHADER_UNUSED_KHR is a special shader index used to indicate that a
ray generation, miss, or callable shader member is not used.

include::{generated}/api/enums/VK_SHADER_UNUSED_KHR.adoc[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/enums/VK_SHADER_UNUSED_NV.adoc[]
endif::VK_NV_ray_tracing[]
--

ifdef::VK_NV_ray_tracing[]
[open,refpage='vkCreateRayTracingPipelinesNV',desc='Creates a new ray tracing pipeline object',type='protos']
--
:refpage: vkCreateRayTracingPipelinesNV

To create ray tracing pipelines, call:

include::{generated}/api/protos/vkCreateRayTracingPipelinesNV.adoc[]

  * pname:device is the logical device that creates the ray tracing
    pipelines.
ifndef::VKSC_VERSION_1_0[]
  * pname:pipelineCache is either dlink:VK_NULL_HANDLE, indicating that
    pipeline caching is disabled, or the handle of a valid
    <<pipelines-cache,pipeline cache>> object, in which case use of that
    cache is enabled for the duration of the command.
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
  * pname:pipelineCache is the handle of a valid <<pipelines-cache,pipeline
    cache>> object.
endif::VKSC_VERSION_1_0[]
  * pname:createInfoCount is the length of the pname:pCreateInfos and
    pname:pPipelines arrays.
  * pname:pCreateInfos is a pointer to an array of
    slink:VkRayTracingPipelineCreateInfoNV structures.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pPipelines is a pointer to an array in which the resulting ray
    tracing pipeline objects are returned.

Pipelines are created and returned as described for <<pipelines-multiple,
Multiple Pipeline Creation>>.

ifdef::VKSC_VERSION_1_0[]
If a pipeline creation fails due to:

  * The identified pipeline not being present in pname:pipelineCache
  * The pname:pNext chain not including a slink:VkPipelineOfflineCreateInfo
    structure

the operation will continue as specified in <<pipelines-multiple, Multiple
Pipeline Creation>> and the command will return
ename:VK_ERROR_NO_PIPELINE_MATCH.
ifdef::hidden[]
// tag::scdeviation[]
ifdef::VK_NV_ray_tracing[]
  * flink:vkCreateRayTracingPipelinesNV returns
    ename:VK_ERROR_NO_PIPELINE_MATCH if the
    slink:VkRayTracingPipelineCreateInfoNV::pname:pNext chain does not
    include a valid slink:VkPipelineOfflineCreateInfo structure <<SCID-1>>.
endif::VK_NV_ray_tracing[]
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

.Valid Usage
****
include::{chapters}/commonvalidity/create_ray_tracing_pipelines_common.adoc[]
include::{chapters}/commonvalidity/pipeline_create_common.adoc[]
  * [[VUID-vkCreateRayTracingPipelinesNV-pNext-10150]]
    If a slink:VkPipelineCreateFlags2CreateInfoKHR structure is included in
    the pname:pNext chain of any element of pname:pCreateInfos,
    ename:VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR flag must: not be set
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
ifdef::VK_NV_ray_tracing[]
  * flink:vkCreateRayTracingPipelinesNV::pname:pipelineCache must: not be
    dlink:VK_NULL_HANDLE <<SCID-1>>, <<SCID-8>>.
endif::VK_NV_ray_tracing[]
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/protos/vkCreateRayTracingPipelinesNV.adoc[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='vkCreateRayTracingPipelinesKHR',desc='Creates a new ray tracing pipeline object',type='protos']
--
:refpage: vkCreateRayTracingPipelinesKHR

To create ray tracing pipelines, call:

include::{generated}/api/protos/vkCreateRayTracingPipelinesKHR.adoc[]

  * pname:device is the logical device that creates the ray tracing
    pipelines.
  * pname:deferredOperation is dlink:VK_NULL_HANDLE or the handle of a valid
    slink:VkDeferredOperationKHR <<deferred-host-operations-requesting,
    request deferral>> object for this command.
ifndef::VKSC_VERSION_1_0[]
  * pname:pipelineCache is either dlink:VK_NULL_HANDLE, indicating that
    pipeline caching is disabled, or the handle of a valid
    <<pipelines-cache,pipeline cache>> object, in which case use of that
    cache is enabled for the duration of the command.
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
  * pname:pipelineCache is the handle of a valid <<pipelines-cache,pipeline
    cache>> object.
endif::VKSC_VERSION_1_0[]
  * pname:createInfoCount is the length of the pname:pCreateInfos and
    pname:pPipelines arrays.
  * pname:pCreateInfos is a pointer to an array of
    slink:VkRayTracingPipelineCreateInfoKHR structures.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pPipelines is a pointer to an array in which the resulting ray
    tracing pipeline objects are returned.

The ename:VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS error is returned if the
implementation is unable to reuse the shader group handles provided in
slink:VkRayTracingShaderGroupCreateInfoKHR::pname:pShaderGroupCaptureReplayHandle
when
slink:VkPhysicalDeviceRayTracingPipelineFeaturesKHR::pname:rayTracingPipelineShaderGroupHandleCaptureReplay
is enabled.

Pipelines are created and returned as described for <<pipelines-multiple,
Multiple Pipeline Creation>>.

ifdef::VKSC_VERSION_1_0[]
If a pipeline creation fails due to:

  * The identified pipeline not being present in pname:pipelineCache
  * The pname:pNext chain not including a slink:VkPipelineOfflineCreateInfo
    structure

the operation will continue as specified in <<pipelines-multiple, Multiple
Pipeline Creation>> and the command will return
ename:VK_ERROR_NO_PIPELINE_MATCH.
ifdef::hidden[]
// tag::scdeviation[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * flink:vkCreateRayTracingPipelinesKHR returns
    ename:VK_ERROR_NO_PIPELINE_MATCH if the
    slink:VkRayTracingPipelineCreateInfoKHR::pname:pNext chain does not
    include a valid slink:VkPipelineOfflineCreateInfo structure <<SCID-1>>.
endif::VK_KHR_ray_tracing_pipeline[]
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

.Valid Usage
****
include::{chapters}/commonvalidity/create_ray_tracing_pipelines_common.adoc[]
include::{chapters}/commonvalidity/deferred_operations_common.adoc[]
include::{chapters}/commonvalidity/pipeline_create_common.adoc[]
  * [[VUID-vkCreateRayTracingPipelinesKHR-rayTracingPipeline-03586]]
    The <<features-rayTracingPipeline, pname:rayTracingPipeline>> feature
    must: be enabled
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifdef::VK_KHR_deferred_host_operations[]
  * [[VUID-vkCreateRayTracingPipelinesKHR-deferredOperation-03587]]
    If pname:deferredOperation is not dlink:VK_NULL_HANDLE, the pname:flags
    member of elements of pname:pCreateInfos must: not include
    ename:VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT
endif::VK_KHR_deferred_host_operations[]
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * flink:vkCreateRayTracingPipelinesKHR::pname:pipelineCache must: not be
    dlink:VK_NULL_HANDLE <<SCID-1>>, <<SCID-8>>.
endif::VK_KHR_ray_tracing_pipeline[]
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/protos/vkCreateRayTracingPipelinesKHR.adoc[]
--
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_NV_ray_tracing[]
[open,refpage='VkRayTracingPipelineCreateInfoNV',desc='Structure specifying parameters of a newly created ray tracing pipeline',type='structs']
--
:refpage: VkRayTracingPipelineCreateInfoNV

The sname:VkRayTracingPipelineCreateInfoNV structure is defined as:

include::{generated}/api/structs/VkRayTracingPipelineCreateInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkPipelineCreateFlagBits specifying
    how the pipeline will be generated.
  * pname:stageCount is the number of entries in the pname:pStages array.
  * pname:pStages is a pointer to an array of
    slink:VkPipelineShaderStageCreateInfo structures specifying the set of
    the shader stages to be included in the ray tracing pipeline.
  * pname:groupCount is the number of entries in the pname:pGroups array.
  * pname:pGroups is a pointer to an array of
    slink:VkRayTracingShaderGroupCreateInfoNV structures describing the set
    of the shader stages to be included in each shader group in the ray
    tracing pipeline.
  * pname:maxRecursionDepth is the <<ray-tracing-recursion-depth, maximum
    recursion depth>> of shaders executed by this pipeline.
  * pname:layout is the description of binding locations used by both the
    pipeline and descriptor sets used with the pipeline.
  * pname:basePipelineHandle is a pipeline to derive from.
ifdef::VKSC_VERSION_1_0[]
    This is not used in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]
  * pname:basePipelineIndex is an index into the pname:pCreateInfos
    parameter to use as a pipeline to derive from.
ifdef::VKSC_VERSION_1_0[]
    This is not used in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]

The parameters pname:basePipelineHandle and pname:basePipelineIndex are
described in more detail in <<pipelines-pipeline-derivatives,Pipeline
Derivatives>>.

ifdef::VK_KHR_maintenance5[]
If the pname:pNext chain includes a
slink:VkPipelineCreateFlags2CreateInfoKHR structure,
slink:VkPipelineCreateFlags2CreateInfoKHR::pname:flags from that structure
is used instead of pname:flags from this structure.
endif::VK_KHR_maintenance5[]

.Valid Usage
****
:pipelineType: ray tracing
include::{chapters}/commonvalidity/pipeline_create_info_common.adoc[]
include::{chapters}/commonvalidity/ray_tracing_pipeline_create_info_common.adoc[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-stage-06232]]
    The pname:stage member of at least one element of pname:pStages must: be
    ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR
ifdef::VK_KHR_pipeline_library[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03456]]
    pname:flags must: not include ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
endif::VK_KHR_pipeline_library[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-maxRecursionDepth-03457]]
    pname:maxRecursionDepth must: be less than or equal to
    slink:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxRecursionDepth
ifdef::VK_KHR_ray_tracing_pipeline[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03458]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03459]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03460]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03461]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03462]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03463]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03588]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_ray_tracing_motion_blur[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-04948]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-02957]]
    pname:flags must: not include both
    ename:VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV and
    ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT at the
    same time
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifdef::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-pipelineStageCreationFeedbackCount-06651]]
    If
    slink:VkPipelineCreationFeedbackCreateInfo::pname:pipelineStageCreationFeedbackCount
    is not `0`, it must: be equal to pname:stageCount
endif::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-stage-06898]]
    The pname:stage value in all pname:pStages elements must: be one of
    ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR,
    ename:VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
    ename:VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
    ename:VK_SHADER_STAGE_MISS_BIT_KHR,
    ename:VK_SHADER_STAGE_INTERSECTION_BIT_KHR, or
    ename:VK_SHADER_STAGE_CALLABLE_BIT_KHR
ifdef::VK_EXT_opacity_micromap[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-07402]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT
endif::VK_EXT_opacity_micromap[]
ifdef::VK_NV_displacement_micromap[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-07998]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV
endif::VK_NV_displacement_micromap[]
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
ifdef::VK_NV_ray_tracing[]
  * slink:VkRayTracingPipelineCreateInfoNV::pname:basePipelineHandle must:
    be dlink:VK_NULL_HANDLE <<SCID-8>>.
  * slink:VkRayTracingPipelineCreateInfoNV::pname:basePipelineIndex must: be
    zero <<SCID-8>>.
endif::VK_NV_ray_tracing[]
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/structs/VkRayTracingPipelineCreateInfoNV.adoc[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='VkRayTracingPipelineCreateInfoKHR',desc='Structure specifying parameters of a newly created ray tracing pipeline',type='structs']
--
:refpage: VkRayTracingPipelineCreateInfoKHR

The sname:VkRayTracingPipelineCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkRayTracingPipelineCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkPipelineCreateFlagBits specifying
    how the pipeline will be generated.
  * pname:stageCount is the number of entries in the pname:pStages array.
  * pname:pStages is a pointer to an array of pname:stageCount
    slink:VkPipelineShaderStageCreateInfo structures describing the set of
    the shader stages to be included in the ray tracing pipeline.
  * pname:groupCount is the number of entries in the pname:pGroups array.
  * pname:pGroups is a pointer to an array of pname:groupCount
    slink:VkRayTracingShaderGroupCreateInfoKHR structures describing the set
    of the shader stages to be included in each shader group in the ray
    tracing pipeline.
  * pname:maxPipelineRayRecursionDepth is the <<ray-tracing-recursion-depth,
    maximum recursion depth>> of shaders executed by this pipeline.
  * pname:pLibraryInfo is a pointer to a
    slink:VkPipelineLibraryCreateInfoKHR structure defining pipeline
    libraries to include.
  * pname:pLibraryInterface is a pointer to a
    slink:VkRayTracingPipelineInterfaceCreateInfoKHR structure defining
    additional information when using pipeline libraries.
  * pname:pDynamicState is a pointer to a
    slink:VkPipelineDynamicStateCreateInfo structure, and is used to
    indicate which properties of the pipeline state object are dynamic and
    can: be changed independently of the pipeline state.
    This can: be `NULL`, which means no state in the pipeline is considered
    dynamic.
  * pname:layout is the description of binding locations used by both the
    pipeline and descriptor sets used with the pipeline.
  * pname:basePipelineHandle is a pipeline to derive from.
ifdef::VKSC_VERSION_1_0[]
    This is not used in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]
  * pname:basePipelineIndex is an index into the pname:pCreateInfos
    parameter to use as a pipeline to derive from.
ifdef::VKSC_VERSION_1_0[]
    This is not used in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]

The parameters pname:basePipelineHandle and pname:basePipelineIndex are
described in more detail in <<pipelines-pipeline-derivatives,Pipeline
Derivatives>>.

ifdef::VK_KHR_pipeline_library[]
When ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR is specified, this pipeline
defines a _pipeline library_ which cannot: be bound as a ray tracing
pipeline directly.
Instead, pipeline libraries define common shaders and shader groups which
can: be included in future pipeline creation.

If pipeline libraries are included in pname:pLibraryInfo, shaders defined in
those libraries are treated as if they were defined as additional entries in
pname:pStages, appended in the order they appear in the pname:pLibraries
array and in the pname:pStages array when those libraries were defined.

When referencing shader groups in order to obtain a shader group handle,
groups defined in those libraries are treated as if they were defined as
additional entries in pname:pGroups, appended in the order they appear in
the pname:pLibraries array and in the pname:pGroups array when those
libraries were defined.
The shaders these groups reference are set when the pipeline library is
created, referencing those specified in the pipeline library, not in the
pipeline that includes it.
endif::VK_KHR_pipeline_library[]

The default stack size for a pipeline if
ename:VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR is not provided
is computed as described in <<ray-tracing-pipeline-stack, Ray Tracing
Pipeline Stack>>.

ifdef::VK_KHR_maintenance5[]
If the pname:pNext chain includes a
slink:VkPipelineCreateFlags2CreateInfoKHR structure,
slink:VkPipelineCreateFlags2CreateInfoKHR::pname:flags from that structure
is used instead of pname:flags from this structure.
endif::VK_KHR_maintenance5[]

.Valid Usage
****
:pipelineType: ray tracing
include::{chapters}/commonvalidity/pipeline_create_info_common.adoc[]
include::{chapters}/commonvalidity/ray_tracing_pipeline_create_info_common.adoc[]
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-stage-03425]]
    If pname:flags does not include
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, the pname:stage member of at
    least one element of pname:pStages, including those implicitly added by
    pname:pLibraryInfo, must: be ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-maxPipelineRayRecursionDepth-03589]]
    pname:maxPipelineRayRecursionDepth must: be less than or equal to
    slink:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:maxRayRecursionDepth
ifdef::VK_KHR_pipeline_library[]
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-03465]]
    If pname:flags includes ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR,
    pname:pLibraryInterface must: not be `NULL`
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03590]]
    If pname:pLibraryInfo is not `NULL` and its pname:libraryCount member is
    greater than `0`, pname:pLibraryInterface must: not be `NULL`
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pLibraries-03591]]
    Each element of pname:pLibraryInfo->pLibraries must: have been created
    with the value of pname:maxPipelineRayRecursionDepth equal to that in
    this pipeline
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03592]]
    If pname:pLibraryInfo is not `NULL`, each element of its
    pname:pLibraries member must: have been created with a pname:layout that
    is compatible with the pname:layout in this pipeline
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03593]]
    If pname:pLibraryInfo is not `NULL`, each element of its
    pname:pLibraries member must: have been created with values of the
    pname:maxPipelineRayPayloadSize and pname:maxPipelineRayHitAttributeSize
    members of pname:pLibraryInterface equal to those in this pipeline
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-03594]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR,
    each element of pname:pLibraryInfo->pLibraries must: have been created
    with the
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
    bit set
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-04718]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR, each element of
    pname:pLibraryInfo->pLibraries must: have been created with the
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR bit set
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-04719]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR, each
    element of pname:pLibraryInfo->pLibraries must: have been created with
    the ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR bit set
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-04720]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR,
    each element of pname:pLibraryInfo->pLibraries must: have been created
    with the
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR bit
    set
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-04721]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR,
    each element of pname:pLibraryInfo->pLibraries must: have been created
    with the
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
    bit set
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-04722]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR,
    each element of pname:pLibraryInfo->pLibraries must: have been created
    with the
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
    bit set
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-04723]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR, each
    element of pname:pLibraryInfo->pLibraries must: have been created with
    the ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
    bit set
endif::VK_KHR_pipeline_library[]
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03595]]
    If the `apiext:VK_KHR_pipeline_library` extension is not enabled,
    pname:pLibraryInfo and pname:pLibraryInterface must: be `NULL`
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-03470]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR,
    for any element of pname:pGroups with a pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, the
    pname:anyHitShader of that element must: not be
    ename:VK_SHADER_UNUSED_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-03471]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR,
    for any element of pname:pGroups with a pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, the
    pname:closestHitShader of that element must: not be
    ename:VK_SHADER_UNUSED_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-rayTraversalPrimitiveCulling-03596]]
    If the <<features-rayTraversalPrimitiveCulling,
    pname:rayTraversalPrimitiveCulling>> feature is not enabled, pname:flags
    must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-rayTraversalPrimitiveCulling-03597]]
    If the <<features-rayTraversalPrimitiveCulling,
    pname:rayTraversalPrimitiveCulling>> feature is not enabled, pname:flags
    must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-06546]]
    pname:flags must: not include both
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR and
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-03598]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR,
    <<features-rayTracingPipelineShaderGroupHandleCaptureReplay,
    pname:rayTracingPipelineShaderGroupHandleCaptureReplay>> must: be
    enabled
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-rayTracingPipelineShaderGroupHandleCaptureReplay-03599]]
    If
    slink:VkPhysicalDeviceRayTracingPipelineFeaturesKHR::pname:rayTracingPipelineShaderGroupHandleCaptureReplay
    is ename:VK_TRUE and the pname:pShaderGroupCaptureReplayHandle member of
    any element of pname:pGroups is not `NULL`, pname:flags must: include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-07999]]
    If pname:pLibraryInfo is `NULL` or its pname:libraryCount is `0`,
    pname:stageCount must: not be `0`
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-08700]]
    If pname:flags does not include ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
    and either pname:pLibraryInfo is `NULL` or its pname:libraryCount is
    `0`, pname:groupCount must: not be `0`
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pDynamicStates-03602]]
    Any element of the pname:pDynamicStates member of pname:pDynamicState
    must: be ename:VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR
ifdef::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pipelineStageCreationFeedbackCount-06652]]
    If
    slink:VkPipelineCreationFeedbackCreateInfo::pname:pipelineStageCreationFeedbackCount
    is not `0`, it must: be equal to pname:stageCount
endif::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-stage-06899]]
    The pname:stage value in all pname:pStages elements must: be one of
    ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR,
    ename:VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
    ename:VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
    ename:VK_SHADER_STAGE_MISS_BIT_KHR,
    ename:VK_SHADER_STAGE_INTERSECTION_BIT_KHR, or
    ename:VK_SHADER_STAGE_CALLABLE_BIT_KHR
ifdef::VK_EXT_opacity_micromap[]
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-07403]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT, each
    element of pname:pLibraryInfo->pLibraries must: have been created with
    the ename:VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT bit
    set
endif::VK_EXT_opacity_micromap[]
ifdef::VK_NV_displacement_micromap[]
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-08701]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV, each
    element of pname:pLibraryInfo->pLibraries must: have been created with
    the ename:VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV
    bit set
endif::VK_NV_displacement_micromap[]
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * slink:VkRayTracingPipelineCreateInfoKHR::pname:flags must: not contain
    the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag <<SCID-8>>.
  * slink:VkRayTracingPipelineCreateInfoKHR::pname:basePipelineHandle must:
    be dlink:VK_NULL_HANDLE <<SCID-8>>.
  * slink:VkRayTracingPipelineCreateInfoKHR::pname:basePipelineIndex must:
    be zero <<SCID-8>>.
endif::VK_KHR_ray_tracing_pipeline[]
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/structs/VkRayTracingPipelineCreateInfoKHR.adoc[]
--
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_NV_ray_tracing[]
[open,refpage='VkRayTracingShaderGroupCreateInfoNV',desc='Structure specifying shaders in a shader group',type='structs']
--
:refpage: VkRayTracingShaderGroupCreateInfoNV

The sname:VkRayTracingShaderGroupCreateInfoNV structure is defined as:

include::{generated}/api/structs/VkRayTracingShaderGroupCreateInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:type is the type of hit group specified in this structure.
  * pname:generalShader is the index of the ray generation, miss, or
    callable shader from
    slink:VkRayTracingPipelineCreateInfoNV::pname:pStages in the group if
    the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV, and
    ename:VK_SHADER_UNUSED_NV otherwise.
  * pname:closestHitShader is the optional index of the closest hit shader
    from slink:VkRayTracingPipelineCreateInfoNV::pname:pStages in the group
    if the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV or
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV, and
    ename:VK_SHADER_UNUSED_NV otherwise.
  * pname:anyHitShader is the optional index of the any-hit shader from
    slink:VkRayTracingPipelineCreateInfoNV::pname:pStages in the group if
    the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV or
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV, and
    ename:VK_SHADER_UNUSED_NV otherwise.
  * pname:intersectionShader is the index of the intersection shader from
    slink:VkRayTracingPipelineCreateInfoNV::pname:pStages in the group if
    the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV, and
    ename:VK_SHADER_UNUSED_NV otherwise.

.Valid Usage
****
  * [[VUID-VkRayTracingShaderGroupCreateInfoNV-type-02413]]
    If pname:type is ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV then
    pname:generalShader must: be a valid index into
    slink:VkRayTracingPipelineCreateInfoNV::pname:pStages referring to a
    shader of ename:VK_SHADER_STAGE_RAYGEN_BIT_NV,
    ename:VK_SHADER_STAGE_MISS_BIT_NV, or
    ename:VK_SHADER_STAGE_CALLABLE_BIT_NV
  * [[VUID-VkRayTracingShaderGroupCreateInfoNV-type-02414]]
    If pname:type is ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV then
    pname:closestHitShader, pname:anyHitShader, and pname:intersectionShader
    must: be ename:VK_SHADER_UNUSED_NV
  * [[VUID-VkRayTracingShaderGroupCreateInfoNV-type-02415]]
    If pname:type is
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV then
    pname:intersectionShader must: be a valid index into
    slink:VkRayTracingPipelineCreateInfoNV::pname:pStages referring to a
    shader of ename:VK_SHADER_STAGE_INTERSECTION_BIT_NV
  * [[VUID-VkRayTracingShaderGroupCreateInfoNV-type-02416]]
    If pname:type is
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV then
    pname:intersectionShader must: be ename:VK_SHADER_UNUSED_NV
  * [[VUID-VkRayTracingShaderGroupCreateInfoNV-closestHitShader-02417]]
    pname:closestHitShader must: be either ename:VK_SHADER_UNUSED_NV or a
    valid index into slink:VkRayTracingPipelineCreateInfoNV::pname:pStages
    referring to a shader of ename:VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV
  * [[VUID-VkRayTracingShaderGroupCreateInfoNV-anyHitShader-02418]]
    pname:anyHitShader must: be either ename:VK_SHADER_UNUSED_NV or a valid
    index into slink:VkRayTracingPipelineCreateInfoNV::pname:pStages
    referring to a shader of ename:VK_SHADER_STAGE_ANY_HIT_BIT_NV
****

include::{generated}/validity/structs/VkRayTracingShaderGroupCreateInfoNV.adoc[]
--

endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='VkRayTracingShaderGroupCreateInfoKHR',desc='Structure specifying shaders in a shader group',type='structs']
--
:refpage: VkRayTracingShaderGroupCreateInfoKHR

The sname:VkRayTracingShaderGroupCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkRayTracingShaderGroupCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:type is the type of hit group specified in this structure.
  * pname:generalShader is the index of the ray generation, miss, or
    callable shader from
    slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages in the group if
    the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR, and
    ename:VK_SHADER_UNUSED_KHR otherwise.
  * pname:closestHitShader is the optional index of the closest hit shader
    from slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages in the group
    if the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, and
    ename:VK_SHADER_UNUSED_KHR otherwise.
  * pname:anyHitShader is the optional index of the any-hit shader from
    slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages in the group if
    the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, and
    ename:VK_SHADER_UNUSED_KHR otherwise.
  * pname:intersectionShader is the index of the intersection shader from
    slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages in the group if
    the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, and
    ename:VK_SHADER_UNUSED_KHR otherwise.
  * pname:pShaderGroupCaptureReplayHandle is `NULL` or a pointer to replay
    information for this shader group queried from
    flink:vkGetRayTracingCaptureReplayShaderGroupHandlesKHR, as described in
    <<ray-tracing-capture-replay, Ray Tracing Capture Replay>>.
    Ignored if
    slink:VkPhysicalDeviceRayTracingPipelineFeaturesKHR::pname:rayTracingPipelineShaderGroupHandleCaptureReplay
    is ename:VK_FALSE.

ifdef::VK_EXT_pipeline_library_group_handles[]
If the pipeline is created with ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR and
the <<features-pipelineLibraryGroupHandles,pipelineLibraryGroupHandles>>
feature is enabled, pname:pShaderGroupCaptureReplayHandle is inherited by
all pipelines which link against this pipeline and remains bitwise identical
for any pipeline which references this pipeline library.
endif::VK_EXT_pipeline_library_group_handles[]

.Valid Usage
****
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03474]]
    If pname:type is ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR then
    pname:generalShader must: be a valid index into
    slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages referring to a
    shader of ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR,
    ename:VK_SHADER_STAGE_MISS_BIT_KHR, or
    ename:VK_SHADER_STAGE_CALLABLE_BIT_KHR
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03475]]
    If pname:type is ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR then
    pname:closestHitShader, pname:anyHitShader, and pname:intersectionShader
    must: be ename:VK_SHADER_UNUSED_KHR
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03476]]
    If pname:type is
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR then
    pname:intersectionShader must: be a valid index into
    slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages referring to a
    shader of ename:VK_SHADER_STAGE_INTERSECTION_BIT_KHR
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03477]]
    If pname:type is
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR then
    pname:intersectionShader must: be ename:VK_SHADER_UNUSED_KHR
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-closestHitShader-03478]]
    pname:closestHitShader must: be either ename:VK_SHADER_UNUSED_KHR or a
    valid index into slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages
    referring to a shader of ename:VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-anyHitShader-03479]]
    pname:anyHitShader must: be either ename:VK_SHADER_UNUSED_KHR or a valid
    index into slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages
    referring to a shader of ename:VK_SHADER_STAGE_ANY_HIT_BIT_KHR
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-rayTracingPipelineShaderGroupHandleCaptureReplayMixed-03603]]
    If
    slink:VkPhysicalDeviceRayTracingPipelineFeaturesKHR::pname:rayTracingPipelineShaderGroupHandleCaptureReplayMixed
    is ename:VK_FALSE then pname:pShaderGroupCaptureReplayHandle must: not
    be provided if it has not been provided on a previous call to ray
    tracing pipeline creation
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-rayTracingPipelineShaderGroupHandleCaptureReplayMixed-03604]]
    If
    slink:VkPhysicalDeviceRayTracingPipelineFeaturesKHR::pname:rayTracingPipelineShaderGroupHandleCaptureReplayMixed
    is ename:VK_FALSE then the caller must: guarantee that no ray tracing
    pipeline creation commands with pname:pShaderGroupCaptureReplayHandle
    provided execute simultaneously with ray tracing pipeline creation
    commands without pname:pShaderGroupCaptureReplayHandle provided
****

include::{generated}/validity/structs/VkRayTracingShaderGroupCreateInfoKHR.adoc[]
--
endif::VK_KHR_ray_tracing_pipeline[]

[open,refpage='VkRayTracingShaderGroupTypeKHR',desc='Shader group types',type='enums',alias='VkRayTracingShaderGroupTypeNV']
--
:refpage: VkRayTracingShaderGroupTypeKHR

Possible values of pname:type in sname:VkRayTracingShaderGroupCreateInfoKHR
are:

include::{generated}/api/enums/VkRayTracingShaderGroupTypeKHR.adoc[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/enums/VkRayTracingShaderGroupTypeNV.adoc[]
endif::VK_NV_ray_tracing[]

  * ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR indicates a shader
    group with a single ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR,
    ename:VK_SHADER_STAGE_MISS_BIT_KHR, or
    ename:VK_SHADER_STAGE_CALLABLE_BIT_KHR shader in it.
  * ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR specifies
    a shader group that only hits triangles and must: not contain an
    intersection shader, only closest hit and any-hit shaders.
  * ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR
    specifies a shader group that only intersects with custom geometry and
    must: contain an intersection shader and may: contain closest hit and
    any-hit shaders.

[NOTE]
====
For current group types, the hit group type could be inferred from the
presence or absence of the intersection shader, but we provide the type
explicitly for future hit groups that do not have that property.
====
--

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='VkRayTracingPipelineInterfaceCreateInfoKHR',desc='Structure specifying additional interface information when using libraries',type='structs']
--
:refpage: VkRayTracingPipelineInterfaceCreateInfoKHR

The sname:VkRayTracingPipelineInterfaceCreateInfoKHR structure is defined
as:

include::{generated}/api/structs/VkRayTracingPipelineInterfaceCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:maxPipelineRayPayloadSize is the maximum payload size in bytes
    used by any shader in the pipeline.
  * pname:maxPipelineRayHitAttributeSize is the maximum attribute structure
    size in bytes used by any shader in the pipeline.

pname:maxPipelineRayPayloadSize is calculated as the maximum number of bytes
used by any block declared in the code:RayPayloadKHR or
code:IncomingRayPayloadKHR storage classes.
pname:maxPipelineRayHitAttributeSize is calculated as the maximum number of
bytes used by any block declared in the code:HitAttributeKHR storage class.
As variables in these storage classes do not have explicit offsets, the size
should be calculated as if each variable has a
<<interfaces-alignment-requirements, scalar alignment>> equal to the largest
scalar alignment of any of the block's members.

[NOTE]
====
There is no explicit upper limit for pname:maxPipelineRayPayloadSize, but in
practice it should be kept as small as possible.
Similar to invocation local memory, it must be allocated for each shader
invocation and for devices which support many simultaneous invocations, this
storage can rapidly be exhausted, resulting in failure.
====

.Valid Usage
****
  * [[VUID-VkRayTracingPipelineInterfaceCreateInfoKHR-maxPipelineRayHitAttributeSize-03605]]
    pname:maxPipelineRayHitAttributeSize must: be less than or equal to
    slink:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:maxRayHitAttributeSize
****

include::{generated}/validity/structs/VkRayTracingPipelineInterfaceCreateInfoKHR.adoc[]
--
endif::VK_KHR_ray_tracing_pipeline[]

[open,refpage='vkGetRayTracingShaderGroupHandlesKHR',desc='Query ray tracing pipeline shader group handles',type='protos',alias='vkGetRayTracingShaderGroupHandlesNV']
--
:refpage: vkGetRayTracingShaderGroupHandlesKHR

To query the opaque handles of shaders in the ray tracing pipeline, call:

ifdef::VK_KHR_ray_tracing_pipeline[]
include::{generated}/api/protos/vkGetRayTracingShaderGroupHandlesKHR.adoc[]
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_KHR_ray_tracing_pipeline+VK_NV_ray_tracing[or the equivalent command]

ifdef::VK_NV_ray_tracing[]
include::{generated}/api/protos/vkGetRayTracingShaderGroupHandlesNV.adoc[]
endif::VK_NV_ray_tracing[]

  * pname:device is the logical device containing the ray tracing pipeline.
  * pname:pipeline is the ray tracing pipeline object containing the
    shaders.
  * pname:firstGroup is the index of the first group to retrieve a handle
    for from the
ifdef::VK_KHR_ray_tracing_pipeline[]
slink:VkRayTracingPipelineCreateInfoKHR::pname:pGroups
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_KHR_ray_tracing_pipeline+VK_NV_ray_tracing[or]
ifdef::VK_NV_ray_tracing[]
slink:VkRayTracingPipelineCreateInfoNV::pname:pGroups
endif::VK_NV_ray_tracing[]
    array.
  * pname:groupCount is the number of shader handles to retrieve.
  * pname:dataSize is the size in bytes of the buffer pointed to by
    pname:pData.
  * pname:pData is a pointer to an application-allocated buffer where the
    results will be written.

On success, an array of pname:groupCount shader handles will be written to
pname:pData, with each element being of size
slink:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:shaderGroupHandleSize.

ifdef::VK_EXT_pipeline_library_group_handles[]
If pname:pipeline was created with ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
and the <<features-pipelineLibraryGroupHandles,pipelineLibraryGroupHandles>>
feature is enabled applications can: query group handles from that pipeline,
even if the pipeline is a library and is never bound to a command buffer.
These group handles remain bitwise identical for any pname:pipeline which
references the pipeline library.
Group indices are assigned as-if the pipeline was created without
ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR.
endif::VK_EXT_pipeline_library_group_handles[]

.Valid Usage
****
  * [[VUID-vkGetRayTracingShaderGroupHandlesKHR-pipeline-04619]]
    pname:pipeline must: be a ray tracing pipeline
  * [[VUID-vkGetRayTracingShaderGroupHandlesKHR-firstGroup-04050]]
    pname:firstGroup must: be less than the number of shader groups in
    pname:pipeline
  * [[VUID-vkGetRayTracingShaderGroupHandlesKHR-firstGroup-02419]]
    The sum of pname:firstGroup and pname:groupCount must: be less than or
    equal to the number of shader groups in pname:pipeline
  * [[VUID-vkGetRayTracingShaderGroupHandlesKHR-dataSize-02420]]
    pname:dataSize must: be at least
    [eq]#slink:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:shaderGroupHandleSize
    {times} pname:groupCount#
ifdef::VK_KHR_pipeline_library[]
  * [[VUID-vkGetRayTracingShaderGroupHandlesKHR-pipeline-07828]]
ifdef::VK_EXT_pipeline_library_group_handles[]
    If the
    <<features-pipelineLibraryGroupHandles,pipelineLibraryGroupHandles>>
    feature is not enabled,
endif::VK_EXT_pipeline_library_group_handles[]
    pname:pipeline must: not have been created with
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
endif::VK_KHR_pipeline_library[]
****

include::{generated}/validity/protos/vkGetRayTracingShaderGroupHandlesKHR.adoc[]
--

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='vkGetRayTracingCaptureReplayShaderGroupHandlesKHR',desc='Query opaque capture replay data for pipeline shader group handles',type='protos']
--
:refpage: vkGetRayTracingCaptureReplayShaderGroupHandlesKHR

To query the opaque capture data of shader groups in a ray tracing pipeline,
call:

include::{generated}/api/protos/vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.adoc[]

  * pname:device is the logical device containing the ray tracing pipeline.
  * pname:pipeline is the ray tracing pipeline object containing the
    shaders.
  * pname:firstGroup is the index of the first group to retrieve a handle
    for from the slink:VkRayTracingPipelineCreateInfoKHR::pname:pGroups
    array.
  * pname:groupCount is the number of shader handles to retrieve.
  * pname:dataSize is the size in bytes of the buffer pointed to by
    pname:pData.
  * pname:pData is a pointer to an application-allocated buffer where the
    results will be written.

On success, an array of pname:groupCount shader handles will be written to
pname:pData, with each element being of size
slink:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:shaderGroupHandleCaptureReplaySize.

Once queried, this opaque data can: be provided at pipeline creation time
(in a subsequent execution), using
slink:VkRayTracingShaderGroupCreateInfoKHR::pname:pShaderGroupCaptureReplayHandle,
as described in <<ray-tracing-capture-replay, Ray Tracing Capture Replay>>.

ifdef::VK_EXT_pipeline_library_group_handles[]
If pname:pipeline was created with ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
and the <<features-pipelineLibraryGroupHandles,pipelineLibraryGroupHandles>>
feature is enabled applications can: query capture replay group handles from
that pipeline.
The capture replay handle remains bitwise identical for any pname:pipeline
which references the pipeline library.
Group indices are assigned as-if the pipeline was created without
ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR.
endif::VK_EXT_pipeline_library_group_handles[]

.Valid Usage
****
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-04620]]
    pname:pipeline must: be a ray tracing pipeline
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-firstGroup-04051]]
    pname:firstGroup must: be less than the number of shader groups in
    pname:pipeline
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-firstGroup-03483]]
    The sum of pname:firstGroup and pname:groupCount must: be less than or
    equal to the number of shader groups in pname:pipeline
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-dataSize-03484]]
    pname:dataSize must: be at least
    [eq]#slink:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:shaderGroupHandleCaptureReplaySize
    {times} pname:groupCount#
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-rayTracingPipelineShaderGroupHandleCaptureReplay-03606]]
    sname:VkPhysicalDeviceRayTracingPipelineFeaturesKHR::pname:rayTracingPipelineShaderGroupHandleCaptureReplay
    must: be enabled to call this function
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-03607]]
    pname:pipeline must: have been created with a pname:flags that included
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
ifdef::VK_KHR_pipeline_library[]
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-07829]]
ifdef::VK_EXT_pipeline_library_group_handles[]
    If the
    <<features-pipelineLibraryGroupHandles,pipelineLibraryGroupHandles>>
    feature is not enabled,
endif::VK_EXT_pipeline_library_group_handles[]
    pname:pipeline must: not have been created with
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
endif::VK_KHR_pipeline_library[]
****

include::{generated}/validity/protos/vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.adoc[]
--
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_NV_ray_tracing[]
Ray tracing pipelines can: contain more shaders than a graphics or compute
pipeline, so to allow parallel compilation of shaders within a pipeline, an
application can: choose to defer compilation until a later point in time.

[open,refpage='vkCompileDeferredNV',desc='Deferred compilation of shaders',type='protos']
--
:refpage: vkCompileDeferredNV

To compile a deferred shader in a pipeline call:

include::{generated}/api/protos/vkCompileDeferredNV.adoc[]

  * pname:device is the logical device containing the ray tracing pipeline.
  * pname:pipeline is the ray tracing pipeline object containing the
    shaders.
  * pname:shader is the index of the shader to compile.

.Valid Usage
****
  * [[VUID-vkCompileDeferredNV-pipeline-04621]]
    pname:pipeline must: be a ray tracing pipeline
  * [[VUID-vkCompileDeferredNV-pipeline-02237]]
    pname:pipeline must: have been created with
    ename:VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV
  * [[VUID-vkCompileDeferredNV-shader-02238]]
    pname:shader must: not have been called as a deferred compile before
****

include::{generated}/validity/protos/vkCompileDeferredNV.adoc[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='vkGetRayTracingShaderGroupStackSizeKHR',desc='Query ray tracing pipeline shader group shader stack size',type='protos']
--
To query the pipeline stack size of shaders in a shader group in the ray
tracing pipeline, call:

include::{generated}/api/protos/vkGetRayTracingShaderGroupStackSizeKHR.adoc[]

  * pname:device is the logical device containing the ray tracing pipeline.
  * pname:pipeline is the ray tracing pipeline object containing the shaders
    groups.
  * pname:group is the index of the shader group to query.
  * pname:groupShader is the type of shader from the group to query.

The return value is the ray tracing pipeline stack size in bytes for the
specified shader as called from the specified shader group.

.Valid Usage
****
  * [[VUID-vkGetRayTracingShaderGroupStackSizeKHR-pipeline-04622]]
    pname:pipeline must: be a ray tracing pipeline
  * [[VUID-vkGetRayTracingShaderGroupStackSizeKHR-group-03608]]
    The value of pname:group must: be less than the number of shader groups
    in pname:pipeline
  * [[VUID-vkGetRayTracingShaderGroupStackSizeKHR-groupShader-03609]]
    The shader identified by pname:groupShader in pname:group must: not be
    ename:VK_SHADER_UNUSED_KHR
****

include::{generated}/validity/protos/vkGetRayTracingShaderGroupStackSizeKHR.adoc[]
--

[open,refpage='VkShaderGroupShaderKHR',desc='Shader group shaders',type='enums']
--
Possible values of pname:groupShader in
flink:vkGetRayTracingShaderGroupStackSizeKHR are:

include::{generated}/api/enums/VkShaderGroupShaderKHR.adoc[]

  * ename:VK_SHADER_GROUP_SHADER_GENERAL_KHR uses the shader specified in
    the group with
    slink:VkRayTracingShaderGroupCreateInfoKHR::pname:generalShader
  * ename:VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR uses the shader specified
    in the group with
    slink:VkRayTracingShaderGroupCreateInfoKHR::pname:closestHitShader
  * ename:VK_SHADER_GROUP_SHADER_ANY_HIT_KHR uses the shader specified in
    the group with
    slink:VkRayTracingShaderGroupCreateInfoKHR::pname:anyHitShader
  * ename:VK_SHADER_GROUP_SHADER_INTERSECTION_KHR uses the shader specified
    in the group with
    slink:VkRayTracingShaderGroupCreateInfoKHR::pname:intersectionShader
--

[open,refpage='vkCmdSetRayTracingPipelineStackSizeKHR',desc='Set the stack size dynamically for a ray tracing pipeline',type='protos']
--
:refpage: vkCmdSetRayTracingPipelineStackSizeKHR

To <<pipelines-dynamic-state, dynamically set>> the stack size for a ray
tracing pipeline, call:

include::{generated}/api/protos/vkCmdSetRayTracingPipelineStackSizeKHR.adoc[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pipelineStackSize is the stack size to use for subsequent ray
    tracing trace commands.

This command sets the stack size for subsequent ray tracing commands when
the ray tracing pipeline is created with
ename:VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR set in
slink:VkPipelineDynamicStateCreateInfo::pname:pDynamicStates.
Otherwise, the stack size is computed as described in
<<ray-tracing-pipeline-stack, Ray Tracing Pipeline Stack>>.

.Valid Usage
****
  * [[VUID-vkCmdSetRayTracingPipelineStackSizeKHR-pipelineStackSize-03610]]
    pname:pipelineStackSize must: be large enough for any dynamic execution
    through the shaders in the ray tracing pipeline used by a subsequent
    trace call
****
include::{generated}/validity/protos/vkCmdSetRayTracingPipelineStackSizeKHR.adoc[]
--
endif::VK_KHR_ray_tracing_pipeline[]
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]


[[pipelines-destruction]]
== Pipeline Destruction

[open,refpage='vkDestroyPipeline',desc='Destroy a pipeline object',type='protos']
--
To destroy a pipeline, call:

include::{generated}/api/protos/vkDestroyPipeline.adoc[]

  * pname:device is the logical device that destroys the pipeline.
  * pname:pipeline is the handle of the pipeline to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyPipeline-pipeline-00765]]
    All submitted commands that refer to pname:pipeline must: have completed
    execution
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkDestroyPipeline-pipeline-00766]]
    If sname:VkAllocationCallbacks were provided when pname:pipeline was
    created, a compatible set of callbacks must: be provided here
  * [[VUID-vkDestroyPipeline-pipeline-00767]]
    If no sname:VkAllocationCallbacks were provided when pname:pipeline was
    created, pname:pAllocator must: be `NULL`
endif::VKSC_VERSION_1_0[]
****

include::{generated}/validity/protos/vkDestroyPipeline.adoc[]
--


[[pipelines-pipeline-derivatives]]
== Pipeline Derivatives

A pipeline derivative is a child pipeline created from a parent pipeline,
where the child and parent are expected to have much commonality.

ifndef::VKSC_VERSION_1_0[]
The goal of derivative pipelines is that they be cheaper to create using the
parent as a starting point, and that it be more efficient (on either host or
device) to switch/bind between children of the same parent.

A derivative pipeline is created by setting the
ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag in the
stext:Vk*PipelineCreateInfo structure.
If this is set, then exactly one of pname:basePipelineHandle or
pname:basePipelineIndex members of the structure must: have a valid
handle/index, and specifies the parent pipeline.
If pname:basePipelineHandle is used, the parent pipeline must: have already
been created.
If pname:basePipelineIndex is used, then the parent is being created in the
same command.
dlink:VK_NULL_HANDLE acts as the invalid handle for
pname:basePipelineHandle, and -1 is the invalid index for
pname:basePipelineIndex.
If pname:basePipelineIndex is used, the base pipeline must: appear earlier
in the array.
The base pipeline must: have been created with the
ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set.
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
Pipeline derivatives are not supported in Vulkan SC due to the use of
read-only offline generated pipeline caches <<SCID-8>>.
endif::VKSC_VERSION_1_0[]


[[pipelines-cache]]
== Pipeline Cache

[open,refpage='VkPipelineCache',desc='Opaque handle to a pipeline cache object',type='handles']
--
ifndef::VKSC_VERSION_1_0[]
Pipeline cache objects allow the result of pipeline construction to be
reused between pipelines and between runs of an application.
Reuse between pipelines is achieved by passing the same pipeline cache
object when creating multiple related pipelines.
Reuse across runs of an application is achieved by retrieving pipeline cache
contents in one run of an application, saving the contents, and using them
to preinitialize a pipeline cache on a subsequent run.
The contents of the pipeline cache objects are managed by the
implementation.
Applications can: manage the host memory consumed by a pipeline cache object
and control the amount of data retrieved from a pipeline cache object.
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
Pipeline cache objects allow the application to load multiple binary
pipeline objects generated by an offline cache creation tool into pipeline
cache objects.
The cache can then be used during pipeline creation to load offline pipeline
data.
endif::VKSC_VERSION_1_0[]

Pipeline cache objects are represented by sname:VkPipelineCache handles:

include::{generated}/api/handles/VkPipelineCache.adoc[]
--


[[pipelines-cache-create]]
=== Creating a Pipeline Cache

[open,refpage='vkCreatePipelineCache',desc='Creates a new pipeline cache',type='protos']
--
:refpage: vkCreatePipelineCache
:objectnameplural: pipeline caches
:objectnamecamelcase: pipelineCache
:objectnamestruct: VkDeviceObjectReservationCreateInfo
:objectcount: 1

To create pipeline cache objects, call:

include::{generated}/api/protos/vkCreatePipelineCache.adoc[]

  * pname:device is the logical device that creates the pipeline cache
    object.
  * pname:pCreateInfo is a pointer to a slink:VkPipelineCacheCreateInfo
    structure containing initial parameters for the pipeline cache object.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pPipelineCache is a pointer to a slink:VkPipelineCache handle in
    which the resulting pipeline cache object is returned.

ifndef::VKSC_VERSION_1_0[]
[NOTE]
====
Applications can: track and manage the total host memory size of a pipeline
cache object using the pname:pAllocator.
Applications can: limit the amount of data retrieved from a pipeline cache
object in fname:vkGetPipelineCacheData.
Implementations should: not internally limit the total number of entries
added to a pipeline cache object or the total host memory consumed.
====
endif::VKSC_VERSION_1_0[]

ifdef::VKSC_VERSION_1_0[]
If the pipeline cache data pointed to by
slink:VkPipelineCacheCreateInfo::pname:pInitialData is not compatible with
the device, pipeline cache creation will fail and
ename:VK_ERROR_INVALID_PIPELINE_CACHE_DATA will be returned.
endif::VKSC_VERSION_1_0[]

Once created, a pipeline cache can: be passed to the
flink:vkCreateGraphicsPipelines
ifdef::VK_KHR_ray_tracing_pipeline[flink:vkCreateRayTracingPipelinesKHR,]
ifdef::VK_NV_ray_tracing[flink:vkCreateRayTracingPipelinesNV,]
and flink:vkCreateComputePipelines commands.
ifndef::VKSC_VERSION_1_0[]
If the pipeline cache passed into these commands is not
dlink:VK_NULL_HANDLE, the implementation will query it for possible reuse
opportunities and update it with new content.
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
The pipeline cache passed into these commands will be queried by the
implementation for matching pipelines on pipeline creation.
After the cache is created, its contents cannot be updated.
endif::VKSC_VERSION_1_0[]
The use of the pipeline cache object in these commands is internally
synchronized, and the same pipeline cache object can: be used in multiple
threads simultaneously.

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
If pname:flags of pname:pCreateInfo includes
ename:VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT, all commands
that modify the returned pipeline cache object must: be
<<fundamentals-threadingbehavior,externally synchronized>>.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]

ifndef::VKSC_VERSION_1_0[]
[NOTE]
====
Implementations should: make every effort to limit any critical sections to
the actual accesses to the cache, which is expected to be significantly
shorter than the duration of the ftext:vkCreate*Pipelines commands.
====
endif::VKSC_VERSION_1_0[]

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

ifdef::VKSC_VERSION_1_0[]
.Valid Usage
****
  * [[VUID-vkCreatePipelineCache-pCreateInfo-05045]]
    The values of the pname:flags, pname:initialDataSize, and
    pname:pInitialData members of the structure pointed to by
    pname:pCreateInfo and the data pointed to by
    pname:pCreateInfo->pInitialData must: be the same as specified in one of
    the elements of the pname:pPipelineCacheCreateInfos array member of a
    slink:VkDeviceObjectReservationCreateInfo structure specified in the
    pname:pNext chain of the slink:VkDeviceCreateInfo structure pname:device
    was created with
include::{chapters}/commonvalidity/memory_reservation_request_count_common.adoc[]
****
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/protos/vkCreatePipelineCache.adoc[]
--

[open,refpage='VkPipelineCacheCreateInfo',desc='Structure specifying parameters of a newly created pipeline cache',type='structs']
--
The sname:VkPipelineCacheCreateInfo structure is defined as:

include::{generated}/api/structs/VkPipelineCacheCreateInfo.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control,VKSC_VERSION_1_0[]
  * pname:flags is a bitmask of elink:VkPipelineCacheCreateFlagBits
    specifying the behavior of the pipeline cache.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control,VKSC_VERSION_1_0[]
ifndef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control,VKSC_VERSION_1_0[]
  * pname:flags is reserved for future use.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control,VKSC_VERSION_1_0[]
  * pname:initialDataSize is the number of bytes in pname:pInitialData.
ifndef::VKSC_VERSION_1_0[]
    If pname:initialDataSize is zero, the pipeline cache will initially be
    empty.
  * pname:pInitialData is a pointer to previously retrieved pipeline cache
    data.
    If the pipeline cache data is incompatible (as defined below) with the
    device, the pipeline cache will be initially empty.
    If pname:initialDataSize is zero, pname:pInitialData is ignored.
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
  * pname:pInitialData is a pointer to pipeline cache data that has been
    generated offline.
    If the pipeline cache data is incompatible (as defined below) with the
    device, ename:VK_ERROR_INVALID_PIPELINE_CACHE_DATA is returned.
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkPipelineCacheCreateInfo::pname:pInitialData must: point to a
    valid pipeline cache that has been generated offline <<SCID-1>>,
    <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

.Valid Usage
****
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkPipelineCacheCreateInfo-initialDataSize-00768]]
    If pname:initialDataSize is not `0`, it must: be equal to the size of
    pname:pInitialData, as returned by fname:vkGetPipelineCacheData when
    pname:pInitialData was originally retrieved
  * [[VUID-VkPipelineCacheCreateInfo-initialDataSize-00769]]
    If pname:initialDataSize is not `0`, pname:pInitialData must: have been
    retrieved from a previous call to fname:vkGetPipelineCacheData
endif::VKSC_VERSION_1_0[]
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * [[VUID-VkPipelineCacheCreateInfo-pipelineCreationCacheControl-02892]]
    If the <<features-pipelineCreationCacheControl,
    pname:pipelineCreationCacheControl>> feature is not enabled, pname:flags
    must: not include
    ename:VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifdef::VKSC_VERSION_1_0[]
  * [[VUID-VkPipelineCacheCreateInfo-flags-05043]]
    pname:flags must: include ename:VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT
  * [[VUID-VkPipelineCacheCreateInfo-flags-05044]]
    pname:flags must: include
    ename:VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT
  * [[VUID-VkPipelineCacheCreateInfo-pInitialData-05139]]
    The pipeline cache data pointed to by pname:pInitialData must: not
    contain any pipelines with duplicate pipeline identifiers.
endif::VKSC_VERSION_1_0[]
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkPipelineCacheCreateInfo::pname:initialDataSize must: not be `0`
    <<SCID-1>>, <<SCID-8>>.
  * slink:VkPipelineCacheCreateInfo::pname:pInitialData must: not be `NULL`
    <<SCID-1>>, <<SCID-8>>.
  * slink:VkPipelineCacheCreateInfo::pname:flags must: include
    ename:VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT <<SCID-1>>, <<SCID-8>>.
  * slink:VkPipelineCacheCreateInfo::pname:flags must: include
    ename:VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT <<SCID-2>>.
  * The contents of slink:VkPipelineCacheCreateInfo, including the data
    pointed to by slink:VkPipelineCacheCreateInfo::pname:pInitialData,
    passed to flink:vkCreatePipelineCache must: be the same as specified in
    one of the
    slink:VkDeviceObjectReservationCreateInfo::pname:pPipelineCacheCreateInfos
    structures when the device was created <<SCID-1>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/structs/VkPipelineCacheCreateInfo.adoc[]
--

[open,refpage='VkPipelineCacheCreateFlags', desc='Bitmask of VkPipelineCreateFlagBits', type='flags']
--
include::{generated}/api/flags/VkPipelineCacheCreateFlags.adoc[]

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control,VKSC_VERSION_1_0[]
tname:VkPipelineCacheCreateFlags is a bitmask type for setting a mask of
zero or more elink:VkPipelineCacheCreateFlagBits.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control,VKSC_VERSION_1_0[]
ifndef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control,VKSC_VERSION_1_0[]
tname:VkPipelineCacheCreateFlags is a bitmask type for setting a mask, but
is currently reserved for future use.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control,VKSC_VERSION_1_0[]
--

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control,VKSC_VERSION_1_0[]
[open,refpage='VkPipelineCacheCreateFlagBits',desc='Bitmask specifying the behavior of the pipeline cache',type='enums']
--
Bits which can: be set in slink:VkPipelineCacheCreateInfo::pname:flags,
specifying behavior of the pipeline cache, are:

include::{generated}/api/enums/VkPipelineCacheCreateFlagBits.adoc[]

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * ename:VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT specifies
    that all commands that modify the created slink:VkPipelineCache will be
    <<fundamentals-threadingbehavior,externally synchronized>>.
    When set, the implementation may: skip any unnecessary processing needed
    to support simultaneous modification from multiple threads where
    allowed.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifdef::VKSC_VERSION_1_0[]
  * ename:VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT specifies that the new
    pipeline cache will be read-only.
  * ename:VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT specifies
    that the application will maintain the contents of the memory pointed to
    by pname:pInitialData for the lifetime of the pipeline cache object
    created, avoiding the need for the implementation to make a copy of the
    data.
    The memory pointed to by pname:pInitialData can: be modified or released
    by the application only after any pipeline cache objects created using
    it have been destroyed.
ifdef::hidden[]
// tag::scaddition[]
  * extending elink:VkPipelineCacheCreateFlagBits
  ** ename:VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT <<SCID-1>>, <<SCID-8>>
  ** ename:VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT <<SCID-2>>
// end::scaddition[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]
--
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control,VKSC_VERSION_1_0[]

ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scremoved[]
  * fname:vkMergePipelineCaches, fname:vkGetPipelineCacheData <<SCID-1>>,
    <<SCID-8>>
// end::scremoved[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]
ifndef::VKSC_VERSION_1_0[]


[[pipelines-cache-merge]]
=== Merging Pipeline Caches

[open,refpage='vkMergePipelineCaches',desc='Combine the data stores of pipeline caches',type='protos']
--
Pipeline cache objects can: be merged using the command:

include::{generated}/api/protos/vkMergePipelineCaches.adoc[]

  * pname:device is the logical device that owns the pipeline cache objects.
  * pname:dstCache is the handle of the pipeline cache to merge results
    into.
  * pname:srcCacheCount is the length of the pname:pSrcCaches array.
  * pname:pSrcCaches is a pointer to an array of pipeline cache handles,
    which will be merged into pname:dstCache.
    The previous contents of pname:dstCache are included after the merge.

[NOTE]
====
The details of the merge operation are implementation-dependent, but
implementations should: merge the contents of the specified pipelines and
prune duplicate entries.
====

.Valid Usage
****
  * [[VUID-vkMergePipelineCaches-dstCache-00770]]
    pname:dstCache must: not appear in the list of source caches
****

include::{generated}/validity/protos/vkMergePipelineCaches.adoc[]
--
endif::VKSC_VERSION_1_0[]


ifndef::VKSC_VERSION_1_0[]
[[pipelines-cache-retrieval]]
=== Retrieving Pipeline Cache Data

[open,refpage='vkGetPipelineCacheData',desc='Get the data store from a pipeline cache',type='protos']
--
Data can: be retrieved from a pipeline cache object using the command:

include::{generated}/api/protos/vkGetPipelineCacheData.adoc[]

  * pname:device is the logical device that owns the pipeline cache.
  * pname:pipelineCache is the pipeline cache to retrieve data from.
  * pname:pDataSize is a pointer to a code:size_t value related to the
    amount of data in the pipeline cache, as described below.
  * pname:pData is either `NULL` or a pointer to a buffer.

If pname:pData is `NULL`, then the maximum size of the data that can: be
retrieved from the pipeline cache, in bytes, is returned in pname:pDataSize.
Otherwise, pname:pDataSize must: point to a variable set by the application
to the size of the buffer, in bytes, pointed to by pname:pData, and on
return the variable is overwritten with the amount of data actually written
to pname:pData.
If pname:pDataSize is less than the maximum size that can: be retrieved by
the pipeline cache, at most pname:pDataSize bytes will be written to
pname:pData, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all of the pipeline cache was
returned.

Any data written to pname:pData is valid and can: be provided as the
pname:pInitialData member of the slink:VkPipelineCacheCreateInfo structure
passed to fname:vkCreatePipelineCache.

Two calls to fname:vkGetPipelineCacheData with the same parameters must:
retrieve the same data unless a command that modifies the contents of the
cache is called between them.

The initial bytes written to pname:pData must: be a header as described in
the <<pipelines-cache-header, Pipeline Cache Header>> section.

If pname:pDataSize is less than what is necessary to store this header,
nothing will be written to pname:pData and zero will be written to
pname:pDataSize.

include::{generated}/validity/protos/vkGetPipelineCacheData.adoc[]
--
endif::VKSC_VERSION_1_0[]


[[pipelines-cache-header]]
=== Pipeline Cache Header

ifdef::VKSC_VERSION_1_0[]
Applications must: load data from <<pipelines-offline-compilation,offline
compiled>> pipeline caches into pipeline cache objects.
The results of pipeline compilations may: depend on the vendor ID, device
ID, driver version, and other details of the target device.
To allow detection of pipeline cache data that is incompatible with the
device, the pipeline cache data must: begin with a valid pipeline cache
header.
endif::VKSC_VERSION_1_0[]

ifndef::VKSC_VERSION_1_0[]
Applications can: store the data retrieved from the pipeline cache, and use
these data, possibly in a future run of the application, to populate new
pipeline cache objects.
The results of pipeline compiles, however, may: depend on the vendor ID,
device ID, driver version, and other details of the device.
To enable applications to detect when previously retrieved data is
incompatible with the device, the pipeline cache data must: begin with a
valid pipeline cache header.
endif::VKSC_VERSION_1_0[]

[NOTE]
====
Structures described in this section are not part of the Vulkan API and are
only used to describe the representation of data elements in pipeline cache
data.
Accordingly, the valid usage clauses defined for structures defined in this
section do not define valid usage conditions for APIs accepting pipeline
cache data as input, as providing invalid pipeline cache data as input to
any Vulkan API commands will result
ifndef::VKSC_VERSION_1_0[]
in the provided pipeline cache data being ignored.
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
in the runtime error ename:VK_ERROR_INVALID_PIPELINE_CACHE_DATA.
endif::VKSC_VERSION_1_0[]
====

[open,refpage='VkPipelineCacheHeaderVersionOne',desc='Structure describing the layout of the pipeline cache header',type='structs']
--
Version one of the pipeline cache header is defined as:

include::{generated}/api/structs/VkPipelineCacheHeaderVersionOne.adoc[]

  * pname:headerSize is the length in bytes of the pipeline cache header.
  * pname:headerVersion is a elink:VkPipelineCacheHeaderVersion value
    specifying the version of the header.
    A consumer of the pipeline cache should: use the cache version to
    interpret the remainder of the cache header.
  * pname:vendorID is the sname:VkPhysicalDeviceProperties::pname:vendorID
    of the implementation.
  * pname:deviceID is the sname:VkPhysicalDeviceProperties::pname:deviceID
    of the implementation.
  * pname:pipelineCacheUUID is the
    sname:VkPhysicalDeviceProperties::pname:pipelineCacheUUID of the
    implementation.

Unlike most structures declared by the Vulkan API, all fields of this
structure are written with the least significant byte first, regardless of
host byte-order.

The C language specification does not define the packing of structure
members.
This layout assumes tight structure member packing, with members laid out in
the order listed in the structure, and the intended size of the structure is
32 bytes.
If a compiler produces code that diverges from that pattern, applications
must: employ another method to set values at the correct offsets.

.Valid Usage
****
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkPipelineCacheHeaderVersionOne-headerSize-04967]]
    pname:headerSize must: be 32
  * [[VUID-VkPipelineCacheHeaderVersionOne-headerVersion-04968]]
    pname:headerVersion must: be ename:VK_PIPELINE_CACHE_HEADER_VERSION_ONE
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
  * [[VUID-VkPipelineCacheHeaderVersionOne-headerSize-05075]]
    pname:headerSize must: be 56
  * [[VUID-VkPipelineCacheHeaderVersionOne-headerVersion-05076]]
    pname:headerVersion must: be
    ename:VK_PIPELINE_CACHE_HEADER_VERSION_SAFETY_CRITICAL_ONE
endif::VKSC_VERSION_1_0[]
  * [[VUID-VkPipelineCacheHeaderVersionOne-headerSize-08990]]
    pname:headerSize must: not exceed the size of the pipeline cache
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkPipelineCacheHeaderVersionOne::pname:headerSize must: be 56
    <<SCID-1>>.
  * slink:VkPipelineCacheHeaderVersionOne::pname:headerVersion must: be
    ename:VK_PIPELINE_CACHE_HEADER_VERSION_SAFETY_CRITICAL_ONE <<SCID-1>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/structs/VkPipelineCacheHeaderVersionOne.adoc[]
--

[open,refpage='VkPipelineCacheHeaderVersion',desc='Encode pipeline cache version',type='enums',xrefs='vkCreatePipelineCache vkGetPipelineCacheData']
--
Possible values of the pname:headerVersion value of the pipeline cache
header are:

include::{generated}/api/enums/VkPipelineCacheHeaderVersion.adoc[]

  * ename:VK_PIPELINE_CACHE_HEADER_VERSION_ONE specifies version one of the
    pipeline cache, described by slink:VkPipelineCacheHeaderVersionOne.
ifdef::VKSC_VERSION_1_0[]
  * ename:VK_PIPELINE_CACHE_HEADER_VERSION_SAFETY_CRITICAL_ONE specifies
    version one of the pipeline cache for Vulkan SC, described by
    slink:VkPipelineCacheHeaderVersionSafetyCriticalOne.
endif::VKSC_VERSION_1_0[]
--

ifdef::VKSC_VERSION_1_0[]
[open,refpage='VkPipelineCacheHeaderVersionSafetyCriticalOne',desc='Structure describing the layout of the pipeline cache header for safety critical',type='structs']
--
Version one of the pipeline cache header for Vulkan SC is defined as:

include::{generated}/api/structs/VkPipelineCacheHeaderVersionSafetyCriticalOne.adoc[]

  * pname:headerVersionOne is a slink:VkPipelineCacheHeaderVersionOne
    structure.
  * pname:validationVersion is a elink:VkPipelineCacheValidationVersion enum
    value specifying the version of any validation information that is
    included in this pipeline cache.
  * pname:implementationData is 4 bytes of padding to ensure structure
    members are consistently aligned on all platforms.
    The contents of this field may: be used for implementation-specific
    information.
  * pname:pipelineIndexCount is the number of entries contained in the
    pipeline cache index.
  * pname:pipelineIndexStride is the number of bytes between consecutive
    pipeline cache index entries.
  * pname:pipelineIndexOffset is the offset in bytes from the beginning of
    the pipeline cache header to the pipeline cache index.

The <<pipelines-cache-index, pipeline cache index>> consists of
pname:pipelineIndexCount slink:VkPipelineCacheSafetyCriticalIndexEntry
structures containing an index of all the pipelines in this cache.
The pipeline cache index is located starting at pname:pipelineIndexOffset
bytes into the cache and the location of pipeline code:i is calculated as:
[eq]#pname:pipelineIndexOffset + code:i {times} pname:pipelineIndexStride#.
The slink:VkPipelineCacheSafetyCriticalIndexEntry structures may: not be
tightly packed, enabling additional implementation-specific data to be
stored with each entry, or for future extensibility.

[NOTE]
====
Because the pipeline cache index is keyed by pipeline identifier,
applications and offline compilers must ensure that there are no pipelines
with identical pipeline identifiers in the same pipeline cache.
====

Unlike most structures declared by the Vulkan API, all fields of this
structure are written with the least significant byte first, regardless of
host byte-order.

The C language specification does not define the packing of structure
members.
This layout assumes tight structure member packing, with members laid out in
the order listed in the structure, and the intended size of the structure is
56 bytes.
If a compiler produces code that diverges from that pattern, applications
must: employ another method to set values at the correct offsets.

.Valid Usage
****
  * [[VUID-VkPipelineCacheHeaderVersionSafetyCriticalOne-validationVersion-05077]]
    pname:validationVersion must: be
    ename:VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE
  * [[VUID-VkPipelineCacheHeaderVersionSafetyCriticalOne-pipelineIndexStride-05078]]
    pname:pipelineIndexStride must: be greater than or equal to 56 (the size
    of the slink:VkPipelineCacheSafetyCriticalIndexEntry structure)
  * [[VUID-VkPipelineCacheHeaderVersionSafetyCriticalOne-pipelineIndexOffset-05079]]
    [eq]#pname:pipelineIndexOffset + pname:pipelineIndexCount {times}
    pname:pipelineIndexStride# must: not exceed the size of the pipeline
    cache
****

include::{generated}/validity/structs/VkPipelineCacheHeaderVersionSafetyCriticalOne.adoc[]
--

[open,refpage='VkPipelineCacheValidationVersion',desc='Encode pipeline cache validation version',type='enums']
--
The elink:VkPipelineCacheValidationVersion enumeration determines the
contents of the pipeline cache validation information.
Possible values are:

include::{generated}/api/enums/VkPipelineCacheValidationVersion.adoc[]

  * ename:VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE specifies
    version one of the pipeline cache validation information for Vulkan SC.
--

[[pipelines-cache-index]]
[open,refpage='VkPipelineCacheSafetyCriticalIndexEntry',desc='Structure describing the pipeline cache index entry',type='structs']
--
Each pipeline cache index entry consists of a
sname:VkPipelineCacheSafetyCriticalIndexEntry structure:

include::{generated}/api/structs/VkPipelineCacheSafetyCriticalIndexEntry.adoc[]

  * pname:pipelineIdentifier is the <<pipelines-identifier, pipeline
    identifier>> indicating which pipeline the information is associated
    with.
  * pname:pipelineMemorySize is the number of bytes of pipeline memory
    required for this pipeline.
    This is the minimum value that can: be successfully used for
    slink:VkPipelineOfflineCreateInfo::pname:poolEntrySize when this
    pipeline is used.
  * pname:jsonSize is the size in bytes of the pipeline JSON data
    representing the pipeline state for this pipeline.
    This value may: be zero, indicating the JSON data is not present in the
    pipeline cache for this pipeline.
  * pname:jsonOffset is the offset in bytes from the beginning of the
    pipeline cache header to the pipeline JSON data for this pipeline.
    This value must: be zero if the JSON data is not present in the pipeline
    cache for this pipeline.
  * pname:stageIndexCount is the number of entries in the pipeline cache
    stage validation index for this pipeline.
    This value may: be zero, indicating that no stage validation information
    is present in the pipeline cache for this pipeline.
  * pname:stageIndexStride is the number of bytes between consecutive stage
    validation index entries.
  * pname:stageIndexOffset is the offset in bytes from the beginning of the
    pipeline cache header to the <<pipelines-cache-stage-validation-index,
    stage validation index>> for this pipeline.
    This value must: be zero if no stage validation information is present
    for this pipeline.

The JSON data and the stage validation index are optionally: included in the
pipeline cache index entry.
They are only intended to be used for validation and debugging.
If present they must: include both the JSON data and the corresponding
SPIR-V modules that were used by the offline compiler to compile the
pipeline cache entry.

The data at pname:jsonOffset consists of a byte stream of pname:jsonSize
bytes of UTF-8 encoded JSON that was used by the
<<pipelines-offline-compilation, offline pipeline compiler>> to create this
pipeline cache entry.

The <<pipelines-cache-stage-validation-index, stage validation index>>
consists of pname:stageIndexCount
slink:VkPipelineCacheStageValidationIndexEntry structures which provide the
SPIR-V modules used by this pipeline and these are provided in the same
order as provided to the slink:VkPipelineShaderStageCreateInfo structure(s)
in the stext:Vk*PipelineCreateInfo structure for this pipeline.
The stage validation index is located at pname:stageIndexOffset bytes into
the cache and the location of stage code:i is calculated as:
[eq]#pname:stageIndexOffset {plus} code:i {times} pname:stageIndexStride#.
The slink:VkPipelineCacheStageValidationIndexEntry structures may: not be
tightly packed, enabling additional implementation-specific data to be
stored with each entry, or for future extensibility.

Unlike most structures declared by the Vulkan API, all fields of this
structure are written with the least significant byte first, regardless of
host byte-order.

The C language specification does not define the packing of structure
members.
This layout assumes tight structure member packing, with members laid out in
the order listed in the structure, and the intended size of the structure is
56 bytes.
If a compiler produces code that diverges from that pattern, applications
must: employ another method to set values at the correct offsets.

.Valid Usage
****
  * [[VUID-VkPipelineCacheSafetyCriticalIndexEntry-jsonSize-05080]]
    If pname:jsonSize is 0, pname:jsonOffset must: be 0
  * [[VUID-VkPipelineCacheSafetyCriticalIndexEntry-jsonSize-05081]]
    If pname:jsonSize is 0, pname:stageIndexCount must: be 0
  * [[VUID-VkPipelineCacheSafetyCriticalIndexEntry-jsonSize-08991]]
    If pname:jsonSize is not 0, [eq]#pname:jsonOffset {plus} pname:jsonSize#
    must: not exceed the size of the pipeline cache
  * [[VUID-VkPipelineCacheSafetyCriticalIndexEntry-stageIndexCount-05082]]
    If pname:stageIndexCount is 0, pname:stageIndexOffset and
    pname:stageIndexStride must: be 0
  * [[VUID-VkPipelineCacheSafetyCriticalIndexEntry-stageIndexCount-05083]]
    If pname:stageIndexCount is not 0, pname:stageIndexStride must: be
    greater than or equal to 16 (the size of the
    slink:VkPipelineCacheStageValidationIndexEntry structure)
  * [[VUID-VkPipelineCacheSafetyCriticalIndexEntry-stageIndexCount-05084]]
    If pname:stageIndexCount is not 0, [eq]#pname:stageIndexOffset {plus}
    pname:stageIndexCount {times} pname:stageIndexStride# must: not exceed
    the size of the pipeline cache
****

include::{generated}/validity/structs/VkPipelineCacheSafetyCriticalIndexEntry.adoc[]
--

[[pipelines-cache-stage-validation-index]]
[open,refpage='VkPipelineCacheStageValidationIndexEntry',desc='Structure describing the pipeline cache stage validation index',type='structs']
--
Each pipeline cache stage validation index entry consists of a
sname:VkPipelineCacheStageValidationIndexEntry structure:

include::{generated}/api/structs/VkPipelineCacheStageValidationIndexEntry.adoc[]

  * pname:codeSize is the size in bytes of the SPIR-V module for this
    pipeline stage.
  * pname:codeOffset is the offset in bytes from the beginning of the
    pipeline cache header to the SPIR-V module for this pipeline stage.

The data at pname:codeOffset consists of pname:codeSize bytes of SPIR-V
module as described in <<spirvenv, Appendix A>> that was used by the
<<pipelines-offline-compilation, offline pipeline compiler>> for this shader
stage when creating this pipeline cache entry.

Unlike most structures declared by the Vulkan API, all fields of this
structure are written with the least significant byte first, regardless of
host byte-order.

The C language specification does not define the packing of structure
members.
This layout assumes tight structure member packing, with members laid out in
the order listed in the structure, and the intended size of the structure is
16 bytes.
If a compiler produces code that diverges from that pattern, applications
must: employ another method to set values at the correct offsets.

.Valid Usage
****
  * [[VUID-VkPipelineCacheStageValidationIndexEntry-codeSize-05085]]
    pname:codeSize must: be greater than 0
  * [[VUID-VkPipelineCacheStageValidationIndexEntry-codeSize-05086]]
    pname:codeSize must: be a multiple of 4
  * [[VUID-VkPipelineCacheStageValidationIndexEntry-codeOffset-05087]]
    [eq]#pname:codeOffset {plus} pname:codeSize# must: not exceed the size
    of the pipeline cache
****

include::{generated}/validity/structs/VkPipelineCacheStageValidationIndexEntry.adoc[]
--

ifdef::hidden[]
// tag::scaddition[]
  * extending elink:VkPipelineCacheHeaderVersion
  ** ename:VK_PIPELINE_CACHE_HEADER_VERSION_SAFETY_CRITICAL_ONE <<SCID-1>>,
     <<SCID-8>>
  * slink:VkPipelineCacheHeaderVersionSafetyCriticalOne <<SCID-1>>,
    <<SCID-8>>
  * elink:VkPipelineCacheValidationVersion <<SCID-1>>, <<SCID-8>>
  * slink:VkPipelineCacheSafetyCriticalIndexEntry <<SCID-1>>, <<SCID-8>>
  * slink:VkPipelineCacheStageValidationIndexEntry<<SCID-1>>, <<SCID-8>>
// end::scaddition[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]


[[pipelines-cache-destroy]]
=== Destroying a Pipeline Cache

[open,refpage='vkDestroyPipelineCache',desc='Destroy a pipeline cache object',type='protos']
--
To destroy a pipeline cache, call:

include::{generated}/api/protos/vkDestroyPipelineCache.adoc[]

  * pname:device is the logical device that destroys the pipeline cache
    object.
  * pname:pipelineCache is the handle of the pipeline cache to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

ifndef::VKSC_VERSION_1_0[]
.Valid Usage
****
  * [[VUID-vkDestroyPipelineCache-pipelineCache-00771]]
    If sname:VkAllocationCallbacks were provided when pname:pipelineCache
    was created, a compatible set of callbacks must: be provided here
  * [[VUID-vkDestroyPipelineCache-pipelineCache-00772]]
    If no sname:VkAllocationCallbacks were provided when pname:pipelineCache
    was created, pname:pAllocator must: be `NULL`
****
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/protos/vkDestroyPipelineCache.adoc[]
--


ifdef::VKSC_VERSION_1_0[]
[[pipelines-offline-compilation]]
== Offline Pipeline Compilation

In Vulkan SC, the pipeline compilation process occurs offline <<SCID-8>>.

The <<shader-modules,SPIR-V shader module>> and pipeline state are supplied
to an offline pipeline cache compiler which creates a pipeline cache entry
for the pipeline.
The set of pipeline cache entries are combined offline into one or more
<<pipelines-cache, pipeline caches>>.
At application runtime, the offline generated pipeline cache is provided to
device creation as part of the slink:VkDeviceObjectReservationCreateInfo
structure and then loaded into a slink:VkPipelineCache object by the
application.
The device, pipeline, and pipeline cache creation functions can: extract
implementation-specific information from the pipeline cache.
The specific pipeline to be loaded from the cache is specified at pipeline
creation time using a <<pipelines-identifier,pipeline identifier>>.
The pipeline state that is provided at runtime to pipeline creation must:
match the state that was specified to the offline pipeline cache compiler
when the pipeline cache entry was created offline (with the exception of the
slink:VkPipelineShaderStageCreateInfo structure).

In order to assist with the specification of pipeline state for the offline
pipeline cache compiler, Khronos has defined a _pipeline JSON schema_ to
represent the pipeline state required to compile a SPIR-V module to
device-specific machine code and a set of utilities to help with reading and
writing of the JSON files.
See https://github.com/KhronosGroup/VulkanSC-Docs/wiki/JSON-schema for more
information.


[[pipelines-memory-reservation]]
== Pipeline Memory Reservation

Pipeline memory is allocated from a pool that is reserved at device creation
time.
The offline pipeline cache compiler writes the pipeline memory size
requirements for each pipeline into the pipeline's
slink:VkPipelineCacheSafetyCriticalIndexEntry::pname:pipelineMemorySize
entry in the <<pipelines-cache-index,pipeline cache index>>.
The offline pipeline cache compiler may: also report it separately.
The elements of
slink:VkDeviceObjectReservationCreateInfo::pname:pPipelinePoolSizes are
requests for pname:poolEntryCount pool entries each of pool size
pname:poolEntrySize, and any pipeline with a
slink:VkPipelineCacheSafetyCriticalIndexEntry::pname:pipelineMemorySize less
than or equal to slink:VkPipelineOfflineCreateInfo::pname:poolEntrySize can:
be placed in one of those pool entries.
The application should: request a set of pool sizes that best suits its
anticipated worst-case usage.

On implementations where
slink:VkPhysicalDeviceVulkanSC10Properties::pname:recyclePipelineMemory is
ename:VK_FALSE, the memory for the pipeline pool is not recycled when a
pipeline is destroyed, and once an entry has been used it cannot: be reused.
On implementations where
slink:VkPhysicalDeviceVulkanSC10Properties::pname:recyclePipelineMemory is
ename:VK_TRUE, the memory for the pipeline pool is recycled when a pipeline
is destroyed, and the entry it was using becomes available to be reused.


[[pipelines-identifier]]
== Pipeline Identifier

A _pipeline identifier_ is an identifier that can be used to identify a
specific pipeline independently from the pipeline description, shader stages
and any relevant fixed-function stages, that were used to create the
pipeline object.

The slink:VkPipelineOfflineCreateInfo structure allows an identifier to be
specified for the pipeline at pipeline creation via the pname:pNext field of
the slink:VkGraphicsPipelineCreateInfo,
ifdef::VK_KHR_ray_tracing_pipeline[slink:VkRayTracingPipelineCreateInfoKHR,]
ifdef::VK_NV_ray_tracing[slink:VkRayTracingPipelineCreateInfoNV,]
and slink:VkComputePipelineCreateInfo structures.
If a sname:VkPipelineOfflineCreateInfo structure is not included in the
pname:pNext chain then pipeline creation will fail and
ename:VK_ERROR_NO_PIPELINE_MATCH will be returned by the corresponding
ftext:vkCreate*Pipelines command.

The identifier must: be used by the implementation to match against the
existing content of the pipeline cache at pipeline creation.
This is required for Vulkan SC where pipelines are generated offline and
there is no shader code in the pipeline cache to match at runtime.

[NOTE]
====
The identifier values must be specified or generated during the offline
pipeline cache generation and embedded in to the pipeline cache blob.
====

[open,refpage='VkPipelineOfflineCreateInfo',desc='Structure specifying pipeline UUID and pipeline pool size to use',type='structs']
--
The sname:VkPipelineOfflineCreateInfo structure is defined as:

include::{generated}/api/structs/VkPipelineOfflineCreateInfo.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipelineIdentifier is an array of ename:VK_UUID_SIZE code:uint8_t
    values representing an identifier for the pipeline.
  * pname:matchControl is a elink:VkPipelineMatchControl value specifying
    the type of identifier being used and how the match should be performed.
  * pname:poolEntrySize is the size of the entry in pipeline memory to use
    for this pipeline.
    It must: be a size that was requested via slink:VkPipelinePoolSize when
    the device was created.

If a match in the pipeline cache is not found then
ename:VK_ERROR_NO_PIPELINE_MATCH will be returned to the application.

If pname:poolEntrySize is too small for the pipeline, or the number of
entries for the requested pool size exceeds the reserved count for that pool
size, pipeline creation will fail and ename:VK_ERROR_OUT_OF_POOL_MEMORY will
be returned by the corresponding ftext:vkCreate*Pipelines command.

.Valid Usage
****
  * [[VUID-VkPipelineOfflineCreateInfo-poolEntrySize-05028]]
    pname:poolEntrySize must: be one of the sizes requested via
    slink:VkPipelinePoolSize when the device was created
  * [[VUID-VkPipelineOfflineCreateInfo-recyclePipelineMemory-05029]]
    If
    slink:VkPhysicalDeviceVulkanSC10Properties::pname:recyclePipelineMemory
    is ename:VK_TRUE, the number of currently existing pipelines created
    with this same value of pname:poolEntrySize plus 1 must: be less than or
    equal to the sum of the slink:VkPipelinePoolSize::pname:poolEntryCount
    values with the same value of pname:poolEntrySize
  * [[VUID-VkPipelineOfflineCreateInfo-recyclePipelineMemory-05030]]
    If
    slink:VkPhysicalDeviceVulkanSC10Properties::pname:recyclePipelineMemory
    is ename:VK_FALSE, the total number of pipelines ever created with this
    same value of pname:poolEntrySize plus 1 must: be less than or equal to
    the sum of the slink:VkPipelinePoolSize::pname:poolEntryCount values
    with the same value of pname:poolEntrySize
****
ifdef::hidden[]
// tag::scaddition[]
  * slink:VkPipelineOfflineCreateInfo <<SCID-1>>, <<SCID-8>>
  * elink:VkPipelineMatchControl <<SCID-1>>
// end::scaddition[]
endif::hidden[]

include::{generated}/validity/structs/VkPipelineOfflineCreateInfo.adoc[]
--

[open,refpage='VkPipelineMatchControl',desc='Describes the type of Identifier and Match being used',type='enums',xrefs='VkPipelineOfflineCreateInfo']
--
Possible values of the pname:matchControl member of
sname:VkPipelineOfflineCreateInfo

include::{generated}/api/enums/VkPipelineMatchControl.adoc[]

are:

  * ename:VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH specifies
    that the identifier is a UUID generated by the application and the
    identifiers must: be an exact match.
--
endif::VKSC_VERSION_1_0[]


ifdef::VK_KHR_pipeline_binary[]
[[pipelines-binaries]]
== Pipeline Binaries

[open,refpage='VkPipelineBinaryKHR',desc='Opaque handle to a pipeline binary object',type='handles']
--
Pipeline binary objects allow the result of pipeline construction to be
reused between pipelines and between runs of an application.
Reuse is achieved by extracting pipeline binaries from a slink:VkPipeline
object, associating them with a corresponding slink:VkPipelineBinaryKeyKHR
and then adding a slink:VkPipelineBinaryInfoKHR to the pname:pNext chain of
any stext:Vk*PipelineCreateInfo when creating a pipeline.
Pipeline binaries can be reused between runs by extracting
sname:VkPipelineBinaryDataKHR from sname:VkPipelineBinaryKHR objects, saving
the contents, and then using them to create a sname:VkPipelineBinaryKHR
object on subsequent runs.

When creating a pipeline that includes slink:VkPipelineBinaryInfoKHR in the
pname:pNext chain, or has the
ename:VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR flag set, the use of
slink:VkPipelineCache objects is not allowed.

Pipeline binary objects are represented by sname:VkPipelineBinaryKHR
handles:

include::{generated}/api/handles/VkPipelineBinaryKHR.adoc[]
--

[[pipelines-binaries-generatekeys]]
=== Generating the Pipeline Key

[open,refpage='vkGetPipelineKeyKHR',desc='Generate the pipeline key from pipeline creation info',type='protos']
--
To generate the key for a particular pipeline creation info, call:

include::{generated}/api/protos/vkGetPipelineKeyKHR.adoc[]

  * pname:device is the logical device that creates the pipeline object.
  * pname:pPipelineCreateInfo is `NULL` or a pointer to a
    slink:VkPipelineCreateInfoKHR structure.
  * pname:pPipelineKey is a pointer to a slink:VkPipelineBinaryKeyKHR
    structure in which the resulting key is returned.

[[global-pipeline-key]]
If pname:pPipelineCreateInfo is `NULL`, then the implementation must: return
the global key that applies to all pipelines.
If the key obtained in this way changes between saving and restoring data
obtained from flink:vkGetPipelineBinaryDataKHR in a different
slink:VkDevice, then the application must: assume that the restored data is
invalid and cannot be passed to flink:vkCreatePipelineBinariesKHR.
Otherwise the application can: assume the data is still valid.

If pname:pPipelineCreateInfo is not `NULL`, the key obtained functions as a
method to compare two pipeline creation info structures.
Implementations may: not compare parts of a pipeline creation info which
would not contribute to the final binary output.
If a shader module identifier is used instead of a shader module, the
pname:pPipelineKey generated must: be equal to the key generated when using
the shader module from which the identifier was queried.
If the content of two pname:pPipelineKey are equal, pipelines created with
the two pname:pPipelineCreateInfo->pname:pNext create infos must: produce
the same slink:VkPipelineBinaryKHR contents.

The pipeline key is distinct from pipeline binary key.
Pipeline binary keys can: only be obtained after compilation.
The pipeline key is intended to optionally allow associating pipeline create
info with multiple pipeline binary keys.

.Valid Usage
****
  * [[VUID-vkGetPipelineKeyKHR-pNext-09605]]
    The pname:pNext chain of pname:pPipelineCreateInfo must: not set
    slink:VkPipelineBinaryInfoKHR::pname:binaryCount to a value greater than
    `0`
****
include::{generated}/validity/protos/vkGetPipelineKeyKHR.adoc[]
--

[open,refpage='VkPipelineCreateInfoKHR',desc='Structure specifying a pipeline createinfo chain',type='structs']
--
The sname:VkPipelineCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkPipelineCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is a pointer to a structure extending this structure.

.Valid Usage
****
  * [[VUID-VkPipelineCreateInfoKHR-pNext-09604]]
    pname:pNext must: be pointer to a valid instance of
    slink:VkGraphicsPipelineCreateInfo,
ifdef::VK_AMDX_shader_enqueue[slink:VkExecutionGraphPipelineCreateInfoAMDX,]
ifdef::VK_KHR_ray_tracing_pipeline[slink:VkRayTracingPipelineCreateInfoKHR,]
    or slink:VkComputePipelineCreateInfo
****
include::{generated}/validity/structs/VkPipelineCreateInfoKHR.adoc[]
--

[open,refpage='VkPipelineBinaryKeyKHR',desc='Structure specifying a key to a pipeline binary',type='structs']
--
The sname:VkPipelineBinaryKeyKHR structure is defined as:

include::{generated}/api/structs/VkPipelineBinaryKeyKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:keySize is the size, in bytes, of valid data returned in
    pname:key.
  * pname:key is a buffer of opaque data specifying a pipeline binary key.

Any returned values beyond the first pname:keySize bytes are undefined:.
Implementations must: return a pname:keySize greater than 0, and
less-or-equal to ename:VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR.

Two keys are considered equal if pname:keySize is equal and the first
pname:keySize bytes of pname:key compare equal.

Implementations may: return a different pname:keySize for different
binaries.

Implementations should: ensure that pname:keySize is large enough to
uniquely identify a pipeline binary.

include::{generated}/validity/structs/VkPipelineBinaryKeyKHR.adoc[]
--

[open,refpage='VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR',desc='Maximum length of binary key',type='consts']
--
ename:VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR is the length in bytes of a binary
key, as returned in slink:VkPipelineBinaryKeyKHR::pname:keySize.

include::{generated}/api/enums/VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR.adoc[]
--

[[pipelines-binaries-create]]
=== Creating Pipeline Binaries

[open,refpage='vkCreatePipelineBinariesKHR',desc='Create pipeline binaries from a pipeline or previously retrieved data',type='protos']
--
To create pipeline binary objects, call:

include::{generated}/api/protos/vkCreatePipelineBinariesKHR.adoc[]

  * pname:device is the logical device that creates the pipeline binary
    objects.
  * pname:pCreateInfo is a pointer to a slink:VkPipelineBinaryCreateInfoKHR
    structure that contains the data to create the pipeline binaries from.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pBinaries is a pointer to a slink:VkPipelineBinaryHandlesInfoKHR
    structure in which the resulting pipeline binaries are returned.

The implementation will attempt to create all pipeline binaries.
If creation fails for any pipeline binary, then:

  - The corresponding entry in the pname:pPipelineBinaries output array will
    be filled with dlink:VK_NULL_HANDLE.
  - The ename:VkResult returned by flink:vkCreatePipelineBinariesKHR will
    contain the error value for the first entry in the output array in
    pname:pBinaries containing dlink:VK_NULL_HANDLE.

include::{generated}/validity/protos/vkCreatePipelineBinariesKHR.adoc[]
--

[open,refpage='VkPipelineBinaryHandlesInfoKHR',desc='Structure containing newly created pipeline binaries',type='structs']
--
The sname:VkPipelineBinaryHandlesInfoKHR structure is defined as:

include::{generated}/api/structs/VkPipelineBinaryHandlesInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipelineBinaryCount is the number of binaries associated with this
    pipeline or the number of entries in the pname:pPipelineBinaries array.
  * pname:pPipelineBinaries is `NULL` or a pointer to an array of
    slink:VkPipelineBinaryKHR handles in which the resulting pipeline
    binaries are returned.

If pname:pPipelineBinaries is `NULL`, the number of binaries that would be
created is returned in pname:pipelineBinaryCount.
Otherwise, pname:pipelineBinaryCount must: be set to the number of entries
in the pname:pPipelineBinaries array, and on return from
flink:vkCreatePipelineBinariesKHR pname:pipelineBinaryCount is overwritten
with the number of handles actually written to pname:pPipelineBinaries.
If the value of pname:pipelineBinaryCount is less than the number of
binaries that would have been created, at most pname:pipelineBinaryCount
handles will be written to pname:pPipelineBinaries and ename:VK_INCOMPLETE
will be returned instead of ename:VK_SUCCESS, to indicate that
pname:pPipelineBinaries was not large enough to create all the binaries.

include::{generated}/validity/structs/VkPipelineBinaryHandlesInfoKHR.adoc[]
--

[open,refpage='VkPipelineBinaryCreateInfoKHR',desc='Structure specifying where to retrieve data for pipeline binary creation',type='structs']
--
The sname:VkPipelineBinaryCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkPipelineBinaryCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pKeysAndDataInfo is `NULL` or a pointer to a
    slink:VkPipelineBinaryKeysAndDataKHR structure that contains keys and
    data to create the pipeline binaries from.
  * pname:pipeline is dlink:VK_NULL_HANDLE or a sname:VkPipeline that
    contains data to create the pipeline binaries from.
  * pname:pPipelineCreateInfo is `NULL` or a pointer to a
    slink:VkPipelineCreateInfoKHR structure with the pipeline creation info.
    This is used to probe the implementation's internal cache for pipeline
    binaries.

When pname:pPipelineCreateInfo is not `NULL`, an implementation will attempt
to retrieve pipeline binary data from an internal cache external to the
application if
<<limits-pipelineBinaryInternalCache,pname:pipelineBinaryInternalCache>> is
ename:VK_TRUE.
Applications can: use this to determine if a pipeline can: be created
without compilation.
If the implementation fails to create a pipeline binary due to missing an
internal cache entry, ename:VK_PIPELINE_BINARY_MISSING_KHR is returned.
If creation succeeds, the resulting binary can: be used to create a
pipeline.
ename:VK_PIPELINE_BINARY_MISSING_KHR may: be returned for any reason in this
situation, even if creating a pipeline binary with the same parameters that
succeeded earlier.

If
<<limits-pipelineBinaryPrecompiledInternalCache,pname:pipelineBinaryPrecompiledInternalCache>>
is ename:VK_TRUE, the implementation may: be able to create pipeline
binaries even when pname:pPipelineCreateInfo has not been used to create
binaries before by the application.

[NOTE]
====
On some platforms, internal pipeline caches may be pre-populated before
running the application.
====

.Valid Usage
****
  * [[VUID-VkPipelineBinaryCreateInfoKHR-pipeline-09607]]
    If pname:pipeline is not dlink:VK_NULL_HANDLE, pname:pipeline must: have
    been created with ename:VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR
  * [[VUID-VkPipelineBinaryCreateInfoKHR-pipeline-09608]]
    If pname:pipeline is not dlink:VK_NULL_HANDLE,
    flink:vkReleaseCapturedPipelineDataKHR must: not have been called on
    pname:pipeline prior to this command
  * [[VUID-VkPipelineBinaryCreateInfoKHR-pipelineBinaryInternalCache-09609]]
    If
    <<limits-pipelineBinaryInternalCache,pname:pipelineBinaryInternalCache>>
    is ename:VK_FALSE pPipelineCreateInfo must: be `NULL`
  * [[VUID-VkPipelineBinaryCreateInfoKHR-device-09610]]
    If pname:device was created with
    slink:VkDevicePipelineBinaryInternalCacheControlKHR::pname:disableInternalCache
    set to ename:VK_TRUE, pname:pPipelineCreateInfo must: be `NULL`
  * [[VUID-VkPipelineBinaryCreateInfoKHR-pKeysAndDataInfo-09619]]
    One and only one of pname:pKeysAndDataInfo, pname:pipeline, or
    pname:pPipelineCreateInfo must: be non-`NULL`
  * [[VUID-VkPipelineBinaryCreateInfoKHR-pPipelineCreateInfo-09606]]
    If pname:pPipelineCreateInfo is not `NULL`, the pname:pNext chain of
    pname:pPipelineCreateInfo must: not set
    slink:VkPipelineBinaryInfoKHR::pname:binaryCount to a value greater than
    `0`
****

include::{generated}/validity/structs/VkPipelineBinaryCreateInfoKHR.adoc[]
--

[open,refpage='VkPipelineBinaryKeysAndDataKHR',desc='Structure specifying arrays of key and data pairs',type='structs']
--
The sname:VkPipelineBinaryKeysAndDataKHR structure is defined as:

include::{generated}/api/structs/VkPipelineBinaryKeysAndDataKHR.adoc[]

  * pname:binaryCount is the size of the pname:pPipelineBinaryKeys and
    pname:pPipelineBinaryData arrays
  * pname:pPipelineBinaryKeys is a pointer to an array of
    slink:VkPipelineBinaryKeyKHR structures containing the pipeline binary
    keys
  * pname:pPipelineBinaryData is a pointer to an array of
    slink:VkPipelineBinaryDataKHR structures containing the pipeline binary
    data

include::{generated}/validity/structs/VkPipelineBinaryKeysAndDataKHR.adoc[]
--

[open,refpage='VkPipelineBinaryDataKHR',desc='Structure specifying data and length of a pipeline binary',type='structs']
--
The sname:VkPipelineBinaryDataKHR structure is defined as:

include::{generated}/api/structs/VkPipelineBinaryDataKHR.adoc[]

  * pname:dataSize is the size of the pname:pData buffer in bytes.
  * pname:pData is a pointer to a buffer of pname:size bytes that contains
    pipeline binary data obtained from fname:vkGetPipelineBinaryDataKHR.

include::{generated}/validity/structs/VkPipelineBinaryDataKHR.adoc[]
--

[[pipelines-binaries-retrieval]]
=== Retrieving Pipeline Binary Data

[open,refpage='vkGetPipelineBinaryDataKHR',desc='Get the data store from a pipeline binary',type='protos']
--
Data can: be retrieved from a pipeline binary object using the command:

include::{generated}/api/protos/vkGetPipelineBinaryDataKHR.adoc[]

  * pname:device is the logical device that created the pipeline binary.
  * pname:pInfo is a pointer to a slink:VkPipelineBinaryDataInfoKHR
    structure which describes the pipeline binary to get data from.
  * pname:pPipelineBinaryKey is a pointer to a slink:VkPipelineBinaryKeyKHR
    structure where the key for this binary will be written.
  * pname:pPipelineBinaryDataSize is a pointer to a code:size_t value
    related to the amount of data in the pipeline binary, as described
    below.
  * pname:pPipelineBinaryData is either `NULL` or a pointer to a buffer.

If pname:pPipelineBinaryData is `NULL`, then the size of the data, in bytes,
that is required to store the binary is returned in
pname:pPipelineBinaryDataSize.
Otherwise, pname:pPipelineBinaryDataSize must: contain the size of the
buffer, in bytes, pointed to by pname:pPipelineBinaryData, and on return
pname:pPipelineBinaryDataSize is overwritten with the size of the data, in
bytes, that is required to store the binary.
If pname:pPipelineBinaryDataSize is less than the size that is required to
store the binary, nothing is written to pname:pPipelineBinaryData and
ename:VK_ERROR_NOT_ENOUGH_SPACE_KHR will be returned, instead of
ename:VK_SUCCESS.

If <<limits-pipelineBinaryCompressedData,pipelineBinaryCompressedData>> is
ename:VK_FALSE, implementations should: not return compressed pipeline
binary data to the application.

include::{generated}/validity/protos/vkGetPipelineBinaryDataKHR.adoc[]
--

[open,refpage='VkPipelineBinaryDataInfoKHR',desc='Structure specifying a pipeline binary to retrieve binary data from',type='structs']
--
The sname:VkPipelineBinaryDataInfoKHR structure is defined as:

include::{generated}/api/structs/VkPipelineBinaryDataInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipelineBinary is the pipeline binary to get data from.

include::{generated}/validity/structs/VkPipelineBinaryDataInfoKHR.adoc[]
--

[[pipelines-binaries-release-captured]]
=== Releasing Captured Pipeline Binary Data

[open,refpage='vkReleaseCapturedPipelineDataKHR',desc='Release captured pipeline binary data',type='protos']
--
To release pipeline resources captured with
ename:VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR, call:

include::{generated}/api/protos/vkReleaseCapturedPipelineDataKHR.adoc[]

  * pname:device is the logical device that created the pipeline object.
  * pname:pInfo is a pointer to a slink:VkReleaseCapturedPipelineDataInfoKHR
    structure which describes the pipeline to release the data from.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

The implementation may: free any resources captured as a result of creating
the pipeline with ename:VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR and put
the pipeline into a state as if
ename:VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR had not been provided at
pipeline creation time.

[NOTE]
====
Any resources captured as a result of creating the pipeline with
ename:VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR are implicitly freed by
flink:vkDestroyPipeline.
====

.Valid Usage
****
  * [[VUID-vkReleaseCapturedPipelineDataKHR-pipeline-09611]]
    If sname:VkAllocationCallbacks were provided when pname:pipeline was
    created, a compatible set of callbacks must: be provided in
    pname:pAllocator
  * [[VUID-vkReleaseCapturedPipelineDataKHR-pipeline-09612]]
    If no slink:VkAllocationCallbacks were provided when pname:pipeline was
    created, pname:pAllocator must: be `NULL`
****

include::{generated}/validity/protos/vkReleaseCapturedPipelineDataKHR.adoc[]
--

[open,refpage='VkReleaseCapturedPipelineDataInfoKHR',desc='Structure specifying a pipeline whose captured data is to be released',type='structs']
--
The sname:VkReleaseCapturedPipelineDataInfoKHR structure is defined as:

include::{generated}/api/structs/VkReleaseCapturedPipelineDataInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipeline the handle of the pipeline object to release the data
    from.

.Valid Usage
****
  * [[VUID-VkReleaseCapturedPipelineDataInfoKHR-pipeline-09613]]
    pname:pipeline must: have been created with
    ename:VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR
  * [[VUID-VkReleaseCapturedPipelineDataInfoKHR-pipeline-09618]]
    pname:pipeline must: not have been used in a previous call to
    fname:vkReleaseCapturedPipelineDataKHR
****

include::{generated}/validity/structs/VkReleaseCapturedPipelineDataInfoKHR.adoc[]
--

[[pipelines-binaries-destroy]]
=== Destroying Pipeline Binaries

[open,refpage='vkDestroyPipelineBinaryKHR',desc='Destroy a pipeline binary',type='protos']
--
To destroy a slink:VkPipelineBinaryKHR, call:

include::{generated}/api/protos/vkDestroyPipelineBinaryKHR.adoc[]

  * pname:device is the logical device that created the pipeline binary
    object.
  * pname:pipelineBinary is the handle of the pipeline binary object to
    destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyPipelineBinaryKHR-pipelineBinary-09614]]
    If sname:VkAllocationCallbacks were provided when pname:pipelineBinary
    was created, a compatible set of callbacks must: be provided here.
  * [[VUID-vkDestroyPipelineBinaryKHR-pipelineBinary-09615]]
    If no slink:VkAllocationCallbacks were provided when
    pname:pipelineBinary was created, pname:pAllocator must: be `NULL`
****

include::{generated}/validity/protos/vkDestroyPipelineBinaryKHR.adoc[]
--
endif::VK_KHR_pipeline_binary[]


[[pipelines-specialization-constants]]
== Specialization Constants

ifndef::VKSC_VERSION_1_0[]
Specialization constants are a mechanism whereby constants in a SPIR-V
module can: have their constant value specified at the time the
sname:VkPipeline is created.
This allows a SPIR-V module to have constants that can: be modified while
executing an application that uses the Vulkan API.

[NOTE]
====
Specialization constants are useful to allow a compute shader to have its
local workgroup size changed at runtime by the user, for example.
====

endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
Specialization constants are a mechanism whereby constants in a SPIR-V
module can: have their constant value specified at the time the
sname:VkPipeline is compiled offline.
This allows a SPIR-V module to have constants that can: be modified at
compilation time rather than in the SPIR-V source.
The pname:pSpecializationInfo parameters are not used at runtime and should:
be ignored by the implementation.
If provided, the application must: set the pname:pSpecializationInfo
parameters to the values that were specified for the offline compilation of
this pipeline.

[NOTE]
====
Specialization constants are useful to allow a compute shader to have its
local workgroup size changed at pipeline compilation time, for example.
====
endif::VKSC_VERSION_1_0[]

Each slink:VkPipelineShaderStageCreateInfo structure contains a
pname:pSpecializationInfo member, which can: be `NULL` to indicate no
specialization constants, or point to a sname:VkSpecializationInfo
structure.

[open,refpage='VkSpecializationInfo',desc='Structure specifying specialization information',type='structs']
--
The sname:VkSpecializationInfo structure is defined as:

include::{generated}/api/structs/VkSpecializationInfo.adoc[]

  * pname:mapEntryCount is the number of entries in the pname:pMapEntries
    array.
  * pname:pMapEntries is a pointer to an array of
    sname:VkSpecializationMapEntry structures, which map constant IDs to
    offsets in pname:pData.
  * pname:dataSize is the byte size of the pname:pData buffer.
  * pname:pData contains the actual constant values to specialize with.

.Valid Usage
****
  * [[VUID-VkSpecializationInfo-offset-00773]]
    The pname:offset member of each element of pname:pMapEntries must: be
    less than pname:dataSize
  * [[VUID-VkSpecializationInfo-pMapEntries-00774]]
    The pname:size member of each element of pname:pMapEntries must: be less
    than or equal to pname:dataSize minus pname:offset
  * [[VUID-VkSpecializationInfo-constantID-04911]]
    The pname:constantID value of each element of pname:pMapEntries must: be
    unique within pname:pMapEntries
****

include::{generated}/validity/structs/VkSpecializationInfo.adoc[]
--

[open,refpage='VkSpecializationMapEntry',desc='Structure specifying a specialization map entry',type='structs']
--
The sname:VkSpecializationMapEntry structure is defined as:

include::{generated}/api/structs/VkSpecializationMapEntry.adoc[]

  * pname:constantID is the ID of the specialization constant in SPIR-V.
  * pname:offset is the byte offset of the specialization constant value
    within the supplied data buffer.
  * pname:size is the byte size of the specialization constant value within
    the supplied data buffer.

If a pname:constantID value is not a specialization constant ID used in the
shader, that map entry does not affect the behavior of the pipeline.

.Valid Usage
****
  * [[VUID-VkSpecializationMapEntry-constantID-00776]]
    For a pname:constantID specialization constant declared in a shader,
    pname:size must: match the byte size of the pname:constantID.
    If the specialization constant is of type code:boolean, pname:size must:
    be the byte size of basetype:VkBool32
****

include::{generated}/validity/structs/VkSpecializationMapEntry.adoc[]
--

In human readable SPIR-V:

[source,glsl]
----
OpDecorate %x SpecId 13 ; decorate .x component of WorkgroupSize with ID 13
OpDecorate %y SpecId 42 ; decorate .y component of WorkgroupSize with ID 42
OpDecorate %z SpecId 3  ; decorate .z component of WorkgroupSize with ID 3
OpDecorate %wgsize BuiltIn WorkgroupSize ; decorate WorkgroupSize onto constant
%i32 = OpTypeInt 32 0 ; declare an unsigned 32-bit type
%uvec3 = OpTypeVector %i32 3 ; declare a 3 element vector type of unsigned 32-bit
%x = OpSpecConstant %i32 1 ; declare the .x component of WorkgroupSize
%y = OpSpecConstant %i32 1 ; declare the .y component of WorkgroupSize
%z = OpSpecConstant %i32 1 ; declare the .z component of WorkgroupSize
%wgsize = OpSpecConstantComposite %uvec3 %x %y %z ; declare WorkgroupSize
----

From the above we have three specialization constants, one for each of the
x, y & z elements of the WorkgroupSize vector.

Now to specialize the above via the specialization constants mechanism:

[source,c++]
----
const VkSpecializationMapEntry entries[] =
{
    {
        .constantID = 13,
        .offset = 0 * sizeof(uint32_t),
        .size = sizeof(uint32_t)
    },
    {
        .constantID = 42,
        .offset = 1 * sizeof(uint32_t),
        .size = sizeof(uint32_t)
    },
    {
        .constantID = 3,
        .offset = 2 * sizeof(uint32_t),
        .size = sizeof(uint32_t)
    }
};

const uint32_t data[] = { 16, 8, 4 }; // our workgroup size is 16x8x4

const VkSpecializationInfo info =
{
    .mapEntryCount = 3,
    .pMapEntries  = entries,
    .dataSize = 3 * sizeof(uint32_t),
    .pData = data,
};
----

Then when calling flink:vkCreateComputePipelines, and passing the
sname:VkSpecializationInfo we defined as the pname:pSpecializationInfo
parameter of slink:VkPipelineShaderStageCreateInfo, we will create a compute
pipeline with the runtime specified local workgroup size.

Another example would be that an application has a SPIR-V module that has
some platform-dependent constants they wish to use.

In human readable SPIR-V:

// [source,glsl]
[source,glsl]
----
OpDecorate %1 SpecId 0  ; decorate our signed 32-bit integer constant
OpDecorate %2 SpecId 12 ; decorate our 32-bit floating-point constant
%i32 = OpTypeInt 32 1   ; declare a signed 32-bit type
%float = OpTypeFloat 32 ; declare a 32-bit floating-point type
%1 = OpSpecConstant %i32 -1 ; some signed 32-bit integer constant
%2 = OpSpecConstant %float 0.5 ; some 32-bit floating-point constant
----

From the above we have two specialization constants, one is a signed 32-bit
integer and the second is a 32-bit floating-point value.

Now to specialize the above via the specialization constants mechanism:

[source,c++]
----
struct SpecializationData {
    int32_t data0;
    float data1;
};

const VkSpecializationMapEntry entries[] =
{
    {
        .constantID = 0,
        .offset = offsetof(SpecializationData, data0),
        .size = sizeof(SpecializationData::data0)
    },
    {
        .constantID = 12,
        .offset = offsetof(SpecializationData, data1),
        .size = sizeof(SpecializationData::data1)
    }
};

SpecializationData data;
data.data0 = -42;    // set the data for the 32-bit integer
data.data1 = 42.0f;  // set the data for the 32-bit floating-point

const VkSpecializationInfo info =
{
    .mapEntryCount = 2,
    .pMapEntries = entries,
    .dataSize = sizeof(data),
    .pdata = &data,
};
----

It is legal for a SPIR-V module with specializations to be compiled into a
pipeline where no specialization information was provided.
SPIR-V specialization constants contain default values such that if a
specialization is not provided, the default value will be used.
In the examples above, it would be valid for an application to only
specialize some of the specialization constants within the SPIR-V module,
and let the other constants use their default values encoded within the
OpSpecConstant declarations.


ifdef::VK_KHR_pipeline_library[]
[[pipelines-library]]
== Pipeline Libraries

A pipeline library is a special pipeline that was created using the
ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR and cannot be bound, instead it
defines a set of pipeline state which can be linked into other pipelines.
ifdef::VK_KHR_ray_tracing_pipeline[]
For ray tracing pipelines this includes shaders and shader groups.
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_EXT_graphics_pipeline_library[]
For graphics pipelines this includes distinct library types defined by
elink:VkGraphicsPipelineLibraryFlagBitsEXT.
endif::VK_EXT_graphics_pipeline_library[]
The application must: maintain the lifetime of a pipeline library based on
the pipelines that link with it.

This linkage is achieved by using the following structure within the
appropriate creation mechanisms:

[open,refpage='VkPipelineLibraryCreateInfoKHR',desc='Structure specifying pipeline libraries to use when creating a pipeline',type='structs']
--
The sname:VkPipelineLibraryCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkPipelineLibraryCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:libraryCount is the number of pipeline libraries in
    pname:pLibraries.
  * pname:pLibraries is a pointer to an array of slink:VkPipeline structures
    specifying pipeline libraries to use when creating a pipeline.

.Valid Usage
****
  * [[VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-03381]]
    Each element of pname:pLibraries must: have been created with
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
ifdef::VK_EXT_shader_module_identifier[]
  * [[VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-06855]]
    If any library in pname:pLibraries was created with a shader stage with
    slink:VkPipelineShaderStageModuleIdentifierCreateInfoEXT and
    pname:identifierSize not equal to 0, the pipeline must: be created with
    the ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT flag
    set
endif::VK_EXT_shader_module_identifier[]
ifdef::VK_EXT_descriptor_buffer[]
  * [[VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-08096]]
    If any element of pname:pLibraries was created with
    ename:VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, all elements must:
    have been created with
    ename:VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT
endif::VK_EXT_descriptor_buffer[]
ifdef::VK_EXT_pipeline_protected_access[]
  * [[VUID-VkPipelineLibraryCreateInfoKHR-pipeline-07404]]
    If pname:pipeline is being created with
    ename:VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT, every element of
    pname:pLibraries must: have been created with
    ename:VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT
  * [[VUID-VkPipelineLibraryCreateInfoKHR-pipeline-07405]]
    If pname:pipeline is being created without
    ename:VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT, every element of
    pname:pLibraries must: have been created without
    ename:VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT
  * [[VUID-VkPipelineLibraryCreateInfoKHR-pipeline-07406]]
    If pname:pipeline is being created with
    ename:VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT, every element of
    pname:pLibraries must: have been created with
    ename:VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT
  * [[VUID-VkPipelineLibraryCreateInfoKHR-pipeline-07407]]
    If pname:pipeline is being created without
    ename:VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT, every element of
    pname:pLibraries must: have been created without
    ename:VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT
endif::VK_EXT_pipeline_protected_access[]
****

include::{generated}/validity/structs/VkPipelineLibraryCreateInfoKHR.adoc[]
--

Pipelines created with ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR libraries
can: depend on other pipeline libraries in
slink:VkPipelineLibraryCreateInfoKHR.

A pipeline library is considered in-use, as long as one of the linking
pipelines is in-use.
This applies recursively if a pipeline library includes other pipeline
libraries.

endif::VK_KHR_pipeline_library[]


[[pipelines-binding]]
== Pipeline Binding

[open,refpage='vkCmdBindPipeline',desc='Bind a pipeline object to a command buffer',type='protos']
--
Once a pipeline has been created, it can: be bound to the command buffer
using the command:

include::{generated}/api/protos/vkCmdBindPipeline.adoc[]

  * pname:commandBuffer is the command buffer that the pipeline will be
    bound to.
  * pname:pipelineBindPoint is a elink:VkPipelineBindPoint value specifying
    to which bind point the pipeline is bound.
    Binding one does not disturb the others.
  * pname:pipeline is the pipeline to be bound.

[[pipelines-bindpoint-commands]]
Once bound, a pipeline binding affects subsequent commands that interact
with the given pipeline type in the command buffer until a different
pipeline of the same type is bound to the bind
ifdef::VK_EXT_shader_object[]
point, or until the pipeline bind point is disturbed by binding a
<<shaders-objects, shader object>> as described in
<<shaders-objects-pipeline-interaction, Interaction with Pipelines>>.
endif::VK_EXT_shader_object[]
ifndef::VK_EXT_shader_object[]
point.
endif::VK_EXT_shader_object[]
Commands that do not interact with the <<shaders-binding,given pipeline>>
type must: not be affected by the pipeline state.

.Valid Usage
****
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-00777]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_COMPUTE, the
    sname:VkCommandPool that pname:commandBuffer was allocated from must:
    support compute operations
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-00778]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_GRAPHICS, the
    sname:VkCommandPool that pname:commandBuffer was allocated from must:
    support graphics operations
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-00779]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_COMPUTE,
    pname:pipeline must: be a compute pipeline
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-00780]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_GRAPHICS,
    pname:pipeline must: be a graphics pipeline
  * [[VUID-vkCmdBindPipeline-pipeline-00781]]
    If the <<features-variableMultisampleRate,
    pname:variableMultisampleRate>> feature is not supported, pname:pipeline
    is a graphics pipeline, the current subpass <<renderpass-noattachments,
    uses no attachments>>, and this is not the first call to this function
    with a graphics pipeline after transitioning to the current subpass,
    then the sample count specified by this pipeline must: match that set in
    the previous pipeline
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdBindPipeline-variableSampleLocations-01525]]
    If
    slink:VkPhysicalDeviceSampleLocationsPropertiesEXT::pname:variableSampleLocations
    is ename:VK_FALSE, and pname:pipeline is a graphics pipeline created
    with a slink:VkPipelineSampleLocationsStateCreateInfoEXT structure
    having its pname:sampleLocationsEnable member set to ename:VK_TRUE but
    without ename:VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT enabled then the
    current render pass instance must: have been begun by specifying a
    slink:VkRenderPassSampleLocationsBeginInfoEXT structure whose
    pname:pPostSubpassSampleLocations member contains an element with a
    pname:subpassIndex matching the current subpass index and the
    pname:sampleLocationsInfo member of that element must: match the
    pname:sampleLocationsInfo specified in
    slink:VkPipelineSampleLocationsStateCreateInfoEXT when the pipeline was
    created
endif::VK_EXT_sample_locations[]
ifdef::VK_EXT_transform_feedback[]
  * [[VUID-vkCmdBindPipeline-None-02323]]
    This command must: not be recorded when transform feedback is active
endif::VK_EXT_transform_feedback[]
ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-02391]]
    If pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, the sname:VkCommandPool
    that pname:commandBuffer was allocated from must: support compute
    operations
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-02392]]
    If pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, pname:pipeline must: be a
    ray tracing pipeline
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-06721]]
    If pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, pname:commandBuffer must:
    not be a protected command buffer
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
ifdef::VK_EXT_pipeline_protected_access[]
  * [[VUID-vkCmdBindPipeline-pipelineProtectedAccess-07408]]
    If the <<features-pipelineProtectedAccess,
    pname:pipelineProtectedAccess>> feature is enabled, and
    pname:commandBuffer is a protected command buffer, pname:pipeline must:
    have been created without
    ename:VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT
  * [[VUID-vkCmdBindPipeline-pipelineProtectedAccess-07409]]
    If the <<features-pipelineProtectedAccess,
    pname:pipelineProtectedAccess>> feature is enabled, and
    pname:commandBuffer is not a protected command buffer, pname:pipeline
    must: have been created without
    ename:VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT
endif::VK_EXT_pipeline_protected_access[]
ifdef::VK_KHR_pipeline_library[]
  * [[VUID-vkCmdBindPipeline-pipeline-03382]]
    pname:pipeline must: not have been created with
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR set
endif::VK_KHR_pipeline_library[]
ifdef::VK_NV_inherited_viewport_scissor[]
  * [[VUID-vkCmdBindPipeline-commandBuffer-04808]]
    If pname:commandBuffer is a secondary command buffer with
    slink:VkCommandBufferInheritanceViewportScissorInfoNV::pname:viewportScissor2D
    enabled and pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, then the pname:pipeline must:
    have been created with ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT or
    ename:VK_DYNAMIC_STATE_VIEWPORT, and
    ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT or
    ename:VK_DYNAMIC_STATE_SCISSOR enabled
endif::VK_NV_inherited_viewport_scissor[]
ifdef::VK_NV_inherited_viewport_scissor,VK_EXT_discard_rectangles[]
  * [[VUID-vkCmdBindPipeline-commandBuffer-04809]]
    If pname:commandBuffer is a secondary command buffer with
    slink:VkCommandBufferInheritanceViewportScissorInfoNV::pname:viewportScissor2D
    enabled and pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS and pname:pipeline was created
    with slink:VkPipelineDiscardRectangleStateCreateInfoEXT structure and
    its pname:discardRectangleCount member is not `0`, or the pipeline was
    created with ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT
    enabled, then the pipeline must: have been created with
    ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT enabled
endif::VK_NV_inherited_viewport_scissor,VK_EXT_discard_rectangles[]
ifdef::VK_EXT_provoking_vertex[]
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-04881]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_GRAPHICS and
    the <<limits-provokingVertexModePerPipeline,
    pname:provokingVertexModePerPipeline>> limit is ename:VK_FALSE, then
    pipeline's
    slink:VkPipelineRasterizationProvokingVertexStateCreateInfoEXT::pname:provokingVertexMode
    must: be the same as that of any other pipelines previously bound to
    this bind point within the current render pass instance, including any
    pipeline already bound when beginning the render pass instance
endif::VK_EXT_provoking_vertex[]
ifdef::VK_HUAWEI_subpass_shading[]
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-04949]]
    If pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI, the
    sname:VkCommandPool that pname:commandBuffer was allocated from must:
    support compute operations
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-04950]]
    If pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI, pname:pipeline
    must: be a subpass shading pipeline
endif::VK_HUAWEI_subpass_shading[]
****

include::{generated}/validity/protos/vkCmdBindPipeline.adoc[]
--

[open,refpage='VkPipelineBindPoint',desc='Specify the bind point of a pipeline object to a command buffer',type='enums']
--
Possible values of flink:vkCmdBindPipeline::pname:pipelineBindPoint,
specifying the bind point of a pipeline object, are:

include::{generated}/api/enums/VkPipelineBindPoint.adoc[]

  * ename:VK_PIPELINE_BIND_POINT_COMPUTE specifies binding as a compute
    pipeline.
  * ename:VK_PIPELINE_BIND_POINT_GRAPHICS specifies binding as a graphics
    pipeline.
ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
  * ename:VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR specifies binding as a ray
    tracing pipeline.
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
ifdef::VK_HUAWEI_subpass_shading[]
  * ename:VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI specifies binding as
    a subpass shading pipeline.
endif::VK_HUAWEI_subpass_shading[]
ifdef::VK_AMDX_shader_enqueue[]
  * ename:VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX specifies binding as
    an <<executiongraphs, execution graph pipeline>>.
endif::VK_AMDX_shader_enqueue[]
--

ifdef::VK_NV_device_generated_commands[]
[open,refpage='vkCmdBindPipelineShaderGroupNV',desc='Bind a pipeline object's shader group to a command buffer',type='protos']
--
For pipelines that were created with the support of multiple shader groups
(see <<graphics-shadergroups,Graphics Pipeline Shader Groups>>), the regular
fname:vkCmdBindPipeline command will bind Shader Group `0`.
To explicitly bind a shader group use:

include::{generated}/api/protos/vkCmdBindPipelineShaderGroupNV.adoc[]

  * pname:commandBuffer is the command buffer that the pipeline will be
    bound to.
  * pname:pipelineBindPoint is a elink:VkPipelineBindPoint value specifying
    the bind point to which the pipeline will be bound.
  * pname:pipeline is the pipeline to be bound.
  * pname:groupIndex is the shader group to be bound.


.Valid Usage
****
  * [[VUID-vkCmdBindPipelineShaderGroupNV-groupIndex-02893]]
    pname:groupIndex must: be `0` or less than the effective
    slink:VkGraphicsPipelineShaderGroupsCreateInfoNV::pname:groupCount
    including the referenced pipelines
  * [[VUID-vkCmdBindPipelineShaderGroupNV-pipelineBindPoint-02894]]
    The pname:pipelineBindPoint must: be
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdBindPipelineShaderGroupNV-groupIndex-02895]]
    The same restrictions as flink:vkCmdBindPipeline apply as if the bound
    pipeline was created only with the Shader Group from the
    pname:groupIndex information
  * [[VUID-vkCmdBindPipelineShaderGroupNV-deviceGeneratedCommands-02896]]
    The <<features-deviceGeneratedCommands, pname:deviceGeneratedCommands>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkCmdBindPipelineShaderGroupNV.adoc[]
--
endif::VK_NV_device_generated_commands[]


ifdef::VK_EXT_shader_object[]
[[pipelines-shader-object-interaction]]
=== Interaction With Shader Objects

If the <<features-shaderObject, pname:shaderObject>> feature is enabled,
applications can: use both pipelines and <<shaders-objects, shader objects>>
at the same time.
The interaction between pipelines and shader objects is described in
<<shaders-objects-pipeline-interaction, Interaction with Pipelines>>.
endif::VK_EXT_shader_object[]


[[pipelines-dynamic-state]]
== Dynamic State

When a pipeline object is bound, any pipeline object state that is not
specified as dynamic is applied to the command buffer state.
Pipeline object state that is specified as dynamic is not applied to the
command buffer state at this time.

[[dynamic-state-lifetime]]
Instead, dynamic state can: be modified at any time and persists for the
lifetime of the command buffer, or until modified by another dynamic state
setting command, or made invalid by binding a pipeline in which that state
is statically specified.

ifdef::VK_NV_command_buffer_inheritance[]
If the <<features-commandBufferInheritance,pname:commandBufferInheritance>>
feature is enabled, all valid state from the previously executed command
buffer in the queue is inherited into the next command buffer executed in
the same queue.
This inherited state does not need to be set again before draw or dispatch
commands.
endif::VK_NV_command_buffer_inheritance[]

[[dynamic-state-current-value]]
When a pipeline object is bound, the following applies to each state
parameter:

  * If the state is not specified as dynamic in the new pipeline object,
    then that command buffer state is overwritten by the state in the new
    pipeline object.
    Before any draw or dispatch call with this pipeline there must: not have
    been any calls to any of the corresponding dynamic state setting
    commands after this pipeline was bound.
  * If the state is specified as dynamic in the new pipeline object, then
    that command buffer state is not disturbed.
    Before any draw or dispatch call with this pipeline there must: have
    been at least one call to each of the corresponding dynamic state
    setting commands.
    The state-setting commands must: be recorded after command buffer
    recording was begun, or after the last command binding a pipeline object
    with that state specified as static, whichever was the latter.
  * If the state is not included (corresponding pointer in
    slink:VkGraphicsPipelineCreateInfo was `NULL` or was ignored) in the new
    pipeline object, then that command buffer state is not disturbed.
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
    For example, mesh shading pipelines do not include vertex input state
    and therefore do not disturb any such command buffer state.
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]

Dynamic state that does not affect the result of operations can: be left
undefined:.

[NOTE]
====
For example, if blending is disabled by the pipeline object state then the
dynamic color blend constants do not need to be specified in the command
buffer, even if this state is specified as dynamic in the pipeline object.
====

[NOTE]
====
Applications running on Vulkan implementations advertising an
slink:VkPhysicalDeviceDriverProperties::pname:conformanceVersion less than
1.3.8.0 should be aware that rebinding the currently bound pipeline object
may not reapply static state.
====


ifdef::VK_AMD_shader_info,VK_KHR_pipeline_executable_properties,VK_EXT_pipeline_properties[]
[[pipelines-shader-information]]
== Pipeline Properties and Shader Information
endif::VK_AMD_shader_info,VK_KHR_pipeline_executable_properties,VK_EXT_pipeline_properties[]

ifdef::VK_KHR_pipeline_executable_properties[]
[open,refpage='vkGetPipelineExecutablePropertiesKHR',desc='Get the executables associated with a pipeline',type='protos']
--
When a pipeline is created, its state and shaders are compiled into zero or
more device-specific executables, which are used when executing commands
against that pipeline.
To query the properties of these pipeline executables, call:

include::{generated}/api/protos/vkGetPipelineExecutablePropertiesKHR.adoc[]

  * pname:device is the device that created the pipeline.
  * pname:pPipelineInfo describes the pipeline being queried.
  * pname:pExecutableCount is a pointer to an integer related to the number
    of pipeline executables available or queried, as described below.
  * pname:pProperties is either `NULL` or a pointer to an array of
    slink:VkPipelineExecutablePropertiesKHR structures.

If pname:pProperties is `NULL`, then the number of pipeline executables
associated with the pipeline is returned in pname:pExecutableCount.
Otherwise, pname:pExecutableCount must: point to a variable set by the
application to the number of elements in the pname:pProperties array, and on
return the variable is overwritten with the number of structures actually
written to pname:pProperties.
If pname:pExecutableCount is less than the number of pipeline executables
associated with the pipeline, at most pname:pExecutableCount structures will
be written, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all the available properties were
returned.

.Valid Usage
****
  * [[VUID-vkGetPipelineExecutablePropertiesKHR-pipelineExecutableInfo-03270]]
    The <<features-pipelineExecutableInfo, pname:pipelineExecutableInfo>>
    feature must: be enabled
  * [[VUID-vkGetPipelineExecutablePropertiesKHR-pipeline-03271]]
    The pname:pipeline member of pname:pPipelineInfo must: have been created
    with pname:device
****

include::{generated}/validity/protos/vkGetPipelineExecutablePropertiesKHR.adoc[]
--

[open,refpage='VkPipelineExecutablePropertiesKHR',desc='Structure describing a pipeline executable',type='structs']
--
The sname:VkPipelineExecutablePropertiesKHR structure is defined as:

include::{generated}/api/structs/VkPipelineExecutablePropertiesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:stages is a bitmask of zero or more elink:VkShaderStageFlagBits
    indicating which shader stages (if any) were principally used as inputs
    to compile this pipeline executable.
  * pname:name is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a short human
    readable name for this pipeline executable.
  * pname:description is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a human readable
    description for this pipeline executable.
  * pname:subgroupSize is the subgroup size with which this pipeline
    executable is dispatched.

Not all implementations have a 1:1 mapping between shader stages and
pipeline executables and some implementations may: reduce a given shader
stage to fixed function hardware programming such that no pipeline
executable is available.
No guarantees are provided about the mapping between shader stages and
pipeline executables and pname:stages should: be considered a best effort
hint.
Because the application cannot: rely on the pname:stages field to provide an
exact description, pname:name and pname:description provide a human readable
name and description which more accurately describes the given pipeline
executable.

include::{generated}/validity/structs/VkPipelineExecutablePropertiesKHR.adoc[]
--
endif::VK_KHR_pipeline_executable_properties[]

ifdef::VK_EXT_pipeline_properties[]
[open,refpage='vkGetPipelinePropertiesEXT',desc='Query pipeline properties',type='protos']
--
To query the pipeline properties call:

include::{generated}/api/protos/vkGetPipelinePropertiesEXT.adoc[]

  * pname:device is the logical device that created the pipeline.
  * pname:pPipelineInfo is a pointer to a slink:VkPipelineInfoEXT structure
    which describes the pipeline being queried.
  * pname:pPipelineProperties is a pointer to a slink:VkBaseOutStructure
    structure in which the pipeline properties will be written.

To query a pipeline's pname:pipelineIdentifier pass a
slink:VkPipelinePropertiesIdentifierEXT structure in
pname:pPipelineProperties.
Each pipeline is associated with a pname:pipelineIdentifier and the
identifier is implementation specific.

.Valid Usage
****
  * [[VUID-vkGetPipelinePropertiesEXT-pipeline-06738]]
    The pname:pipeline member of pname:pPipelineInfo must: have been created
    with pname:device
  * [[VUID-vkGetPipelinePropertiesEXT-pPipelineProperties-06739]]
    pname:pPipelineProperties must: be a valid pointer to a
    slink:VkPipelinePropertiesIdentifierEXT structure
  * [[VUID-vkGetPipelinePropertiesEXT-None-06766]]
    The <<features-pipelinePropertiesIdentifier,
    pname:pipelinePropertiesIdentifier>> feature must: be enabled
****

include::{generated}/validity/protos/vkGetPipelinePropertiesEXT.adoc[]
--

[open,refpage='VkPipelinePropertiesIdentifierEXT',desc='Structure used to retrieve pipeline properties',type='structs']
--
The sname:VkPipelinePropertiesIdentifierEXT structure is defined as:

include::{generated}/api/structs/VkPipelinePropertiesIdentifierEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipelineIdentifier is an array of ename:VK_UUID_SIZE code:uint8_t
    values into which the pipeline identifier will be written.

include::{generated}/validity/structs/VkPipelinePropertiesIdentifierEXT.adoc[]
--
endif::VK_EXT_pipeline_properties[]

// This structure is used by both vkGetPipelineExecutablePropertiesKHR and
// vkGetPipelinePropertiesEXT above, placing it in a nonstandard position.
ifdef::VK_KHR_pipeline_executable_properties,VK_EXT_pipeline_properties[]
[open,refpage='VkPipelineInfoKHR',desc='Structure describing a pipeline',type='structs',alias='VkPipelineInfoEXT']
--
The sname:VkPipelineInfoKHR structure is defined as:

include::{generated}/api/structs/VkPipelineInfoKHR.adoc[]

ifdef::VK_EXT_pipeline_properties[]
or the equivalent

include::{generated}/api/structs/VkPipelineInfoEXT.adoc[]
endif::VK_EXT_pipeline_properties[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipeline is a sname:VkPipeline handle.

include::{generated}/validity/structs/VkPipelineInfoKHR.adoc[]
--
endif::VK_KHR_pipeline_executable_properties,VK_EXT_pipeline_properties[]

ifdef::VK_KHR_pipeline_executable_properties[]
[open,refpage='vkGetPipelineExecutableStatisticsKHR',desc='Get compile time statistics associated with a pipeline executable',type='protos']
--
Each pipeline executable may: have a set of statistics associated with it
that are generated by the pipeline compilation process.
These statistics may: include things such as instruction counts, amount of
spilling (if any), maximum number of simultaneous threads, or anything else
which may: aid developers in evaluating the expected performance of a
shader.
To query the compile time statistics associated with a pipeline executable,
call:

include::{generated}/api/protos/vkGetPipelineExecutableStatisticsKHR.adoc[]

  * pname:device is the device that created the pipeline.
  * pname:pExecutableInfo describes the pipeline executable being queried.
  * pname:pStatisticCount is a pointer to an integer related to the number
    of statistics available or queried, as described below.
  * pname:pStatistics is either `NULL` or a pointer to an array of
    slink:VkPipelineExecutableStatisticKHR structures.

If pname:pStatistics is `NULL`, then the number of statistics associated
with the pipeline executable is returned in pname:pStatisticCount.
Otherwise, pname:pStatisticCount must: point to a variable set by the
application to the number of elements in the pname:pStatistics array, and on
return the variable is overwritten with the number of structures actually
written to pname:pStatistics.
If pname:pStatisticCount is less than the number of statistics associated
with the pipeline executable, at most pname:pStatisticCount structures will
be written, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all the available statistics were
returned.

.Valid Usage
****
  * [[VUID-vkGetPipelineExecutableStatisticsKHR-pipelineExecutableInfo-03272]]
    The <<features-pipelineExecutableInfo, pname:pipelineExecutableInfo>>
    feature must: be enabled
  * [[VUID-vkGetPipelineExecutableStatisticsKHR-pipeline-03273]]
    The pname:pipeline member of pname:pExecutableInfo must: have been
    created with pname:device
  * [[VUID-vkGetPipelineExecutableStatisticsKHR-pipeline-03274]]
    The pname:pipeline member of pname:pExecutableInfo must: have been
    created with ename:VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR
****

include::{generated}/validity/protos/vkGetPipelineExecutableStatisticsKHR.adoc[]
--

[open,refpage='VkPipelineExecutableInfoKHR',desc='Structure describing a pipeline executable to query for associated statistics or internal representations',type='structs']
--
The sname:VkPipelineExecutableInfoKHR structure is defined as:

include::{generated}/api/structs/VkPipelineExecutableInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipeline is the pipeline to query.
  * pname:executableIndex is the index of the pipeline executable to query
    in the array of executable properties returned by
    flink:vkGetPipelineExecutablePropertiesKHR.

.Valid Usage
****
  * [[VUID-VkPipelineExecutableInfoKHR-executableIndex-03275]]
    pname:executableIndex must: be less than the number of pipeline
    executables associated with pname:pipeline as returned in the
    pname:pExecutableCount parameter of
    fname:vkGetPipelineExecutablePropertiesKHR
****

include::{generated}/validity/structs/VkPipelineExecutableInfoKHR.adoc[]
--

[open,refpage='VkPipelineExecutableStatisticKHR',desc='Structure describing a compile time pipeline executable statistic',type='structs']
--
The sname:VkPipelineExecutableStatisticKHR structure is defined as:

include::{generated}/api/structs/VkPipelineExecutableStatisticKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:name is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a short human
    readable name for this statistic.
  * pname:description is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a human readable
    description for this statistic.
  * pname:format is a elink:VkPipelineExecutableStatisticFormatKHR value
    specifying the format of the data found in pname:value.
  * pname:value is the value of this statistic.

include::{generated}/validity/structs/VkPipelineExecutableStatisticKHR.adoc[]
--

[open,refpage='VkPipelineExecutableStatisticFormatKHR',desc='Enum describing a pipeline executable statistic's data format',type='enums']
--
The ename:VkPipelineExecutableStatisticFormatKHR enum is defined as:

include::{generated}/api/enums/VkPipelineExecutableStatisticFormatKHR.adoc[]

  * ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR specifies that
    the statistic is returned as a 32-bit boolean value which must: be
    either ename:VK_TRUE or ename:VK_FALSE and should: be read from the
    fname:b32 field of sname:VkPipelineExecutableStatisticValueKHR.
  * ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR specifies that
    the statistic is returned as a signed 64-bit integer and should: be read
    from the fname:i64 field of sname:VkPipelineExecutableStatisticValueKHR.
  * ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR specifies that
    the statistic is returned as an unsigned 64-bit integer and should: be
    read from the fname:u64 field of
    sname:VkPipelineExecutableStatisticValueKHR.
  * ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR specifies that
    the statistic is returned as a 64-bit floating-point value and should:
    be read from the fname:f64 field of
    sname:VkPipelineExecutableStatisticValueKHR.
--

[open,refpage='VkPipelineExecutableStatisticValueKHR',desc='A union describing a pipeline executable statistic's value',type='structs']
--
The sname:VkPipelineExecutableStatisticValueKHR union is defined as:

include::{generated}/api/structs/VkPipelineExecutableStatisticValueKHR.adoc[]

  * pname:b32 is the 32-bit boolean value if the
    ename:VkPipelineExecutableStatisticFormatKHR is
    ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR.
  * pname:i64 is the signed 64-bit integer value if the
    ename:VkPipelineExecutableStatisticFormatKHR is
    ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR.
  * pname:u64 is the unsigned 64-bit integer value if the
    ename:VkPipelineExecutableStatisticFormatKHR is
    ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR.
  * pname:f64 is the 64-bit floating-point value if the
    ename:VkPipelineExecutableStatisticFormatKHR is
    ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR.

include::{generated}/validity/structs/VkPipelineExecutableStatisticValueKHR.adoc[]
--

[open,refpage='vkGetPipelineExecutableInternalRepresentationsKHR',desc='Get internal representations of the pipeline executable',type='protos']
--
Each pipeline executable may: have one or more text or binary internal
representations associated with it which are generated as part of the
compile process.
These may: include the final shader assembly, a binary form of the compiled
shader, or the shader compiler's internal representation at any number of
intermediate compile steps.
To query the internal representations associated with a pipeline executable,
call:

include::{generated}/api/protos/vkGetPipelineExecutableInternalRepresentationsKHR.adoc[]

  * pname:device is the device that created the pipeline.
  * pname:pExecutableInfo describes the pipeline executable being queried.
  * pname:pInternalRepresentationCount is a pointer to an integer related to
    the number of internal representations available or queried, as
    described below.
  * pname:pInternalRepresentations is either `NULL` or a pointer to an array
    of slink:VkPipelineExecutableInternalRepresentationKHR structures.

If pname:pInternalRepresentations is `NULL`, then the number of internal
representations associated with the pipeline executable is returned in
pname:pInternalRepresentationCount.
Otherwise, pname:pInternalRepresentationCount must: point to a variable set
by the application to the number of elements in the
pname:pInternalRepresentations array, and on return the variable is
overwritten with the number of structures actually written to
pname:pInternalRepresentations.
If pname:pInternalRepresentationCount is less than the number of internal
representations associated with the pipeline executable, at most
pname:pInternalRepresentationCount structures will be written, and
ename:VK_INCOMPLETE will be returned instead of ename:VK_SUCCESS, to
indicate that not all the available representations were returned.

While the details of the internal representations remain
implementation-dependent, the implementation should: order the internal
representations in the order in which they occur in the compiled pipeline
with the final shader assembly (if any) last.

.Valid Usage
****
  * [[VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pipelineExecutableInfo-03276]]
    The <<features-pipelineExecutableInfo, pname:pipelineExecutableInfo>>
    feature must: be enabled
  * [[VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pipeline-03277]]
    The pname:pipeline member of pname:pExecutableInfo must: have been
    created with pname:device
  * [[VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pipeline-03278]]
    The pname:pipeline member of pname:pExecutableInfo must: have been
    created with
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
****

include::{generated}/validity/protos/vkGetPipelineExecutableInternalRepresentationsKHR.adoc[]
--

[open,refpage='VkPipelineExecutableInternalRepresentationKHR',desc='Structure describing the textual form of a pipeline executable internal representation',type='structs']
--
The sname:VkPipelineExecutableInternalRepresentationKHR structure is defined
as:

include::{generated}/api/structs/VkPipelineExecutableInternalRepresentationKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:name is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a short human
    readable name for this internal representation.
  * pname:description is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a human readable
    description for this internal representation.
  * pname:isText specifies whether the returned data is text or opaque data.
    If pname:isText is ename:VK_TRUE then the data returned in pname:pData
    is text and is guaranteed to be a null-terminated UTF-8 string.
  * pname:dataSize is an integer related to the size, in bytes, of the
    internal representation's data, as described below.
  * pname:pData is either `NULL` or a pointer to a block of data into which
    the implementation will write the internal representation.

If pname:pData is `NULL`, then the size, in bytes, of the internal
representation data is returned in pname:dataSize.
Otherwise, pname:dataSize must: be the size of the buffer, in bytes, pointed
to by pname:pData and on return pname:dataSize is overwritten with the
number of bytes of data actually written to pname:pData including any
trailing null character.
If pname:dataSize is less than the size, in bytes, of the internal
representation's data, at most pname:dataSize bytes of data will be written
to pname:pData, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all the available representation was
returned.

If pname:isText is ename:VK_TRUE and pname:pData is not `NULL` and
pname:dataSize is not zero, the last byte written to pname:pData will be a
null character.

include::{generated}/validity/structs/VkPipelineExecutableInternalRepresentationKHR.adoc[]
--
endif::VK_KHR_pipeline_executable_properties[]


ifdef::VK_AMD_shader_info[]
include::{chapters}/VK_AMD_shader_info.adoc[]
endif::VK_AMD_shader_info[]


// These includes have their own section headers

ifdef::VK_AMD_pipeline_compiler_control[]
include::{chapters}/VK_AMD_pipeline_compiler_control.adoc[]
endif::VK_AMD_pipeline_compiler_control[]

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_feedback[]
include::{chapters}/VK_EXT_pipeline_creation_feedback/pipelines.adoc[]
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_feedback[]
