// Copyright 2015-2024 The Khronos Group Inc.
//
// SPDX-License-Identifier: CC-BY-4.0

// This text fragment is used many times in the Features chapter.
ifdef::hidden[]
// tag::features[]
If the sname:{refpage} structure is included in the pname:pNext chain of the
slink:VkPhysicalDeviceFeatures2 structure passed to
flink:vkGetPhysicalDeviceFeatures2, it is filled in to indicate whether each
corresponding feature is supported.
sname:{refpage} can: also be used in the pname:pNext chain of
slink:VkDeviceCreateInfo to selectively enable these features.
// end::features[]
endif::hidden[]


[[features]]
= Features

_Features_ describe functionality which is not supported on all
implementations.
Features are properties of the physical device.
Features are optional:, and must: be explicitly enabled before use.
Support for features is reported and enabled on a per-feature basis.

ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
[NOTE]
.Note
====
Features are reported via the basic slink:VkPhysicalDeviceFeatures
structure, as well as the extensible structure
sname:VkPhysicalDeviceFeatures2, which was added in the
`apiext:VK_KHR_get_physical_device_properties2` extension and included in
Vulkan 1.1.
When new features are added in future Vulkan versions or extensions, each
extension should: introduce one new feature structure, if needed.
This structure can: be added to the pname:pNext chain of the
sname:VkPhysicalDeviceFeatures2 structure.
====
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

For convenience, new core versions of Vulkan may: introduce new unified
feature structures for features promoted from extensions.
At the same time, the extension's original feature structure (if any) is
also promoted to the core API, and is an alias of the extension's structure.
This results in multiple names for the same feature: in the original
extension's feature structure and the promoted structure alias, in the
unified feature structure.
When a feature was implicitly supported and enabled in the extension, but an
explicit name was added during promotion, then the extension itself acts as
an alias for the feature as listed in the table below.

All aliases of the same feature in the core API must: be reported
consistently: either all must: be reported as supported, or none of them.
When a promoted extension is available, any corresponding feature aliases
must: be supported.

[[features-extension-aliases]]
.Extension Feature Aliases

// Jon 1.3 TBD - add any appropriate extensions promoted to 1.3
[width="100%",options="header"]
|====
| Extension                                    | Feature(s)
ifdef::VK_VERSION_1_2[]
ifdef::VK_KHR_shader_draw_parameters[]
| `apiext:VK_KHR_shader_draw_parameters`       | <<features-shaderDrawParameters, pname:shaderDrawParameters>>
endif::VK_KHR_shader_draw_parameters[]
ifdef::VK_KHR_draw_indirect_count[]
| `apiext:VK_KHR_draw_indirect_count`          | <<features-drawIndirectCount, pname:drawIndirectCount>>
endif::VK_KHR_draw_indirect_count[]
ifdef::VK_KHR_sampler_mirror_clamp_to_edge[]
| `apiext:VK_KHR_sampler_mirror_clamp_to_edge` | <<features-samplerMirrorClampToEdge, pname:samplerMirrorClampToEdge>>
endif::VK_KHR_sampler_mirror_clamp_to_edge[]
ifdef::VK_EXT_descriptor_indexing[]
| `apiext:VK_EXT_descriptor_indexing`          | <<features-descriptorIndexing, pname:descriptorIndexing>>
endif::VK_EXT_descriptor_indexing[]
ifdef::VK_EXT_sampler_filter_minmax[]
| `apiext:VK_EXT_sampler_filter_minmax`        | <<features-samplerFilterMinmax, pname:samplerFilterMinmax>>
endif::VK_EXT_sampler_filter_minmax[]
ifdef::VK_EXT_shader_viewport_index_layer[]
| `apiext:VK_EXT_shader_viewport_index_layer`  | <<features-shaderOutputViewportIndex, pname:shaderOutputViewportIndex>>, <<features-shaderOutputLayer, pname:shaderOutputLayer>>
endif::VK_EXT_shader_viewport_index_layer[]
endif::VK_VERSION_1_2[]
|====

[open,refpage='vkGetPhysicalDeviceFeatures',desc='Reports capabilities of a physical device',type='protos']
--
To query supported features, call:

include::{generated}/api/protos/vkGetPhysicalDeviceFeatures.adoc[]

  * pname:physicalDevice is the physical device from which to query the
    supported features.
  * pname:pFeatures is a pointer to a slink:VkPhysicalDeviceFeatures
    structure in which the physical device features are returned.
    For each feature, a value of ename:VK_TRUE specifies that the feature is
    supported on this physical device, and ename:VK_FALSE specifies that the
    feature is not supported.

include::{generated}/validity/protos/vkGetPhysicalDeviceFeatures.adoc[]
--

Fine-grained features used by a logical device must: be enabled at
sname:VkDevice creation time.
If a feature is enabled that the physical device does not support,
sname:VkDevice creation will fail and return
ename:VK_ERROR_FEATURE_NOT_PRESENT.

The fine-grained features are enabled by passing a pointer to the
sname:VkPhysicalDeviceFeatures structure via the pname:pEnabledFeatures
member of the slink:VkDeviceCreateInfo structure that is passed into the
fname:vkCreateDevice call.
If a member of pname:pEnabledFeatures is set to ename:VK_TRUE or
ename:VK_FALSE, then the device will be created with the indicated feature
enabled or disabled, respectively.
ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
Features can: also be enabled by using the slink:VkPhysicalDeviceFeatures2
structure.
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

If an application wishes to enable all features supported by a device, it
can: simply pass in the sname:VkPhysicalDeviceFeatures structure that was
previously returned by fname:vkGetPhysicalDeviceFeatures.
To disable an individual feature, the application can: set the desired
member to ename:VK_FALSE in the same structure.
Setting pname:pEnabledFeatures to `NULL`
ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
and not including a slink:VkPhysicalDeviceFeatures2 in the pname:pNext chain
of slink:VkDeviceCreateInfo
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
is equivalent to setting all members of the structure to ename:VK_FALSE.

[NOTE]
.Note
====
Some features, such as pname:robustBufferAccess, may: incur a runtime
performance cost.
Application writers should: carefully consider the implications of enabling
all supported features.
====

ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
[open,refpage='vkGetPhysicalDeviceFeatures2',desc='Reports capabilities of a physical device',type='protos']
--
To query supported features defined by the core or extensions, call:

ifdef::VK_VERSION_1_1[]
include::{generated}/api/protos/vkGetPhysicalDeviceFeatures2.adoc[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_get_physical_device_properties2[or the equivalent command]

ifdef::VK_KHR_get_physical_device_properties2[]
include::{generated}/api/protos/vkGetPhysicalDeviceFeatures2KHR.adoc[]
endif::VK_KHR_get_physical_device_properties2[]

  * pname:physicalDevice is the physical device from which to query the
    supported features.
  * pname:pFeatures is a pointer to a slink:VkPhysicalDeviceFeatures2
    structure in which the physical device features are returned.

Each structure in pname:pFeatures and its pname:pNext chain contains members
corresponding to fine-grained features.
fname:vkGetPhysicalDeviceFeatures2 writes each member to a boolean value
indicating whether that feature is supported.

include::{generated}/validity/protos/vkGetPhysicalDeviceFeatures2.adoc[]
--

[open,refpage='VkPhysicalDeviceFeatures2',desc='Structure describing the fine-grained features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFeatures2 structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceFeatures2.adoc[]

ifdef::VK_KHR_get_physical_device_properties2[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceFeatures2KHR.adoc[]
endif::VK_KHR_get_physical_device_properties2[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:features is a slink:VkPhysicalDeviceFeatures structure describing
    the fine-grained features of the Vulkan 1.0 API.

The pname:pNext chain of this structure is used to extend the structure with
features defined by extensions.
This structure can: be used in flink:vkGetPhysicalDeviceFeatures2 or can: be
included in the pname:pNext chain of a slink:VkDeviceCreateInfo structure,
in which case it controls which features are enabled on the device in lieu
of pname:pEnabledFeatures.

include::{generated}/validity/structs/VkPhysicalDeviceFeatures2.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

[open,refpage='VkPhysicalDeviceFeatures',desc='Structure describing the fine-grained features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceFeatures.adoc[]

This structure describes the following features:

  * [[features-robustBufferAccess]] pname:robustBufferAccess specifies that
    accesses to buffers are bounds-checked against the range of the buffer
    descriptor (as determined by sname:VkDescriptorBufferInfo::pname:range,
    slink:VkBufferViewCreateInfo::pname:range, or the size of the buffer).
    Out of bounds accesses must: not cause application termination, and the
    effects of shader loads, stores, and atomics must: conform to an
    implementation-dependent behavior as described below.
  ** A buffer access is considered to be out of bounds if any of the
     following are true:
  *** The pointer was formed by code:OpImageTexelPointer and the coordinate
      is less than zero or greater than or equal to the number of whole
      elements in the bound range.
  *** The pointer was not formed by code:OpImageTexelPointer and the object
      pointed to is not wholly contained within the bound range.
ifdef::VK_VERSION_1_1,VK_KHR_variable_pointers[]
      This includes accesses performed via _variable pointers_ where the
      buffer descriptor being accessed cannot be statically determined.
      Uninitialized pointers and pointers equal to code:OpConstantNull are
      treated as pointing to a zero-sized object, so all accesses through
      such pointers are considered to be out of bounds.
endif::VK_VERSION_1_1,VK_KHR_variable_pointers[]
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
      Buffer accesses through buffer device addresses are not
      bounds-checked.
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
ifdef::VK_NV_cooperative_matrix[]
  *** If the <<features-cooperativeMatrixRobustBufferAccess-NV,
      sname:VkPhysicalDeviceCooperativeMatrixFeaturesNV::pname:cooperativeMatrixRobustBufferAccess>>
      feature is not enabled, then accesses using
      code:OpCooperativeMatrixLoadNV and code:OpCooperativeMatrixStoreNV
      may: not be bounds-checked.
endif::VK_NV_cooperative_matrix[]
ifdef::VK_KHR_cooperative_matrix[]
  *** If the <<features-cooperativeMatrixRobustBufferAccess,
      sname:VkPhysicalDeviceCooperativeMatrixFeaturesKHR::pname:cooperativeMatrixRobustBufferAccess>>
      feature is not enabled, then accesses using
      code:OpCooperativeMatrixLoadKHR and code:OpCooperativeMatrixStoreKHR
      may: not be bounds-checked.
endif::VK_KHR_cooperative_matrix[]
+
[NOTE]
.Note
====
If a SPIR-V code:OpLoad instruction loads a structure and the tail end of
the structure is out of bounds, then all members of the structure are
considered out of bounds even if the members at the end are not statically
used.
====

  *** If
ifdef::VK_EXT_robustness2[]
      <<features-robustBufferAccess2, pname:robustBufferAccess2>> is not
      enabled and
endif::VK_EXT_robustness2[]
      any buffer access is determined to be out of bounds, then any other
      access of the same type (load, store, or atomic) to the same buffer
      that accesses an address less than 16 bytes away from the out of
      bounds address may: also be considered out of bounds.
  *** If the access is a load that reads from the same memory locations as a
      prior store in the same shader invocation, with no other intervening
      accesses to the same memory locations in that shader invocation, then
      the result of the load may: be the value stored by the store
      instruction, even if the access is out of bounds.
      If the load is code:Volatile, then an out of bounds load must: return
      the appropriate out of bounds value.
ifdef::VK_EXT_robustness2[]
  ** Accesses to descriptors written with a dlink:VK_NULL_HANDLE resource or
     view are not considered to be out of bounds.
     Instead, each type of descriptor access defines a specific behavior for
     accesses to a null descriptor.
endif::VK_EXT_robustness2[]
  ** Out-of-bounds buffer loads will return any of the following values:
ifdef::VK_EXT_robustness2[]
  *** If the access is to a uniform buffer and
      <<features-robustBufferAccess2, pname:robustBufferAccess2>> is
      enabled, loads of offsets between the end of the descriptor range and
      the end of the descriptor range rounded up to a multiple of
      <<limits-robustUniformBufferAccessSizeAlignment,
      pname:robustUniformBufferAccessSizeAlignment>> bytes must: return
      either zero values or the contents of the memory at the offset being
      loaded.
      Loads of offsets past the descriptor range rounded up to a multiple of
      <<limits-robustUniformBufferAccessSizeAlignment,
      pname:robustUniformBufferAccessSizeAlignment>> bytes must: return zero
      values.
  *** If the access is to a storage buffer and
      <<features-robustBufferAccess2, pname:robustBufferAccess2>> is
      enabled, loads of offsets between the end of the descriptor range and
      the end of the descriptor range rounded up to a multiple of
      <<limits-robustStorageBufferAccessSizeAlignment,
      pname:robustStorageBufferAccessSizeAlignment>> bytes must: return
      either zero values or the contents of the memory at the offset being
      loaded.
      Loads of offsets past the descriptor range rounded up to a multiple of
      <<limits-robustStorageBufferAccessSizeAlignment,
      pname:robustStorageBufferAccessSizeAlignment>> bytes must: return zero
      values.
      Similarly, stores to addresses between the end of the descriptor range
      and the end of the descriptor range rounded up to a multiple of
      <<limits-robustStorageBufferAccessSizeAlignment,
      pname:robustStorageBufferAccessSizeAlignment>> bytes may: be
      discarded.
  *** Non-atomic accesses to storage buffers that are a multiple of 32 bits
      may: be decomposed into 32-bit accesses that are individually
      bounds-checked.
  *** If the access is to an index buffer and
      <<features-robustBufferAccess2, pname:robustBufferAccess2>> is
      enabled, zero values must: be returned.
  *** If the access is to a uniform texel buffer or storage texel buffer and
      <<features-robustBufferAccess2, pname:robustBufferAccess2>> is
      enabled, zero values must: be returned, and then
      <<textures-conversion-to-rgba,Conversion to RGBA>> is applied based on
      the buffer view's format.
endif::VK_EXT_robustness2[]
  *** Values from anywhere within the memory range(s) bound to the buffer
      (possibly including bytes of memory past the end of the buffer, up to
      the end of the bound range).
  *** Zero values, or [eq]#(0,0,0,x)# vectors for vector reads where x is a
      valid value represented in the type of the vector components and may:
      be any of:
  **** 0, 1, or the maximum representable positive integer value, for signed
       or unsigned integer components
  **** 0.0 or 1.0, for floating-point components
  ** Out-of-bounds writes may: modify values within the memory range(s)
     bound to the buffer, but must: not modify any other memory.
ifdef::VK_EXT_robustness2[]
  *** If <<features-robustBufferAccess2, pname:robustBufferAccess2>> is
      enabled, out of bounds writes must: not modify any memory.
endif::VK_EXT_robustness2[]
  ** Out-of-bounds atomics may: modify values within the memory range(s)
     bound to the buffer, but must: not modify any other memory, and return
     an undefined: value.
ifdef::VK_EXT_robustness2[]
  *** If <<features-robustBufferAccess2, pname:robustBufferAccess2>> is
      enabled, out of bounds atomics must: not modify any memory, and return
      an undefined: value.
  ** If <<features-robustBufferAccess2, pname:robustBufferAccess2>> is
     disabled, vertex
endif::VK_EXT_robustness2[]
ifndef::VK_EXT_robustness2[]
  ** Vertex
endif::VK_EXT_robustness2[]
     input attributes are considered out of bounds if the offset of the
     attribute in the bound vertex buffer range plus the size of the
     attribute is greater than either:
+
  *** code:vertexBufferRangeSize, if [eq]#code:bindingStride == 0#; or
  *** [eq]#(code:vertexBufferRangeSize - (code:vertexBufferRangeSize %
      code:bindingStride))#
+
where code:vertexBufferRangeSize is the byte size of the memory range bound
to the vertex buffer binding and code:bindingStride is the byte stride of
the corresponding vertex input binding.
Further, if any vertex input attribute using a specific vertex input binding
is out of bounds, then all vertex input attributes using that vertex input
binding for that vertex shader invocation are considered out of bounds.
  *** If a vertex input attribute is out of bounds, it will be assigned one
      of the following values:
  **** Values from anywhere within the memory range(s) bound to the buffer,
       converted according to the format of the attribute.
  **** Zero values, format converted according to the format of the
       attribute.
  **** Zero values, or [eq]#(0,0,0,x)# vectors, as described above.
ifdef::VK_EXT_robustness2[]
  ** If <<features-robustBufferAccess2, pname:robustBufferAccess2>> is
     enabled, vertex input attributes are considered out of bounds if the
     offset of the attribute in the bound vertex buffer range plus the size
     of the attribute is greater than the byte size of the memory range
     bound to the vertex buffer binding.
  *** If a vertex input attribute is out of bounds, the
      <<fxvertex-input-extraction,raw data>> extracted are zero values, and
      missing G, B, or A components are <<fxvertex-input-extraction,filled
      with [eq]#(0,0,1)#>>.
endif::VK_EXT_robustness2[]
  ** If pname:robustBufferAccess is not enabled, applications must: not
     perform out of bounds accesses
ifdef::VK_EXT_pipeline_robustness[]
     except under the conditions enabled by the
     <<features-pipelineRobustness, pname:pipelineRobustness>> feature
endif::VK_EXT_pipeline_robustness[]
     .
  * [[features-fullDrawIndexUint32]] pname:fullDrawIndexUint32 specifies the
    full 32-bit range of indices is supported for indexed draw calls when
    using a elink:VkIndexType of ename:VK_INDEX_TYPE_UINT32.
    pname:maxDrawIndexedIndexValue is the maximum index value that may: be
    used (aside from the primitive restart index, which is always 2^32^-1
    when the elink:VkIndexType is ename:VK_INDEX_TYPE_UINT32).
    If this feature is supported, pname:maxDrawIndexedIndexValue must: be
    2^32^-1; otherwise it must: be no smaller than 2^24^-1.
    See <<limits-maxDrawIndexedIndexValue, pname:maxDrawIndexedIndexValue>>.
  * [[features-imageCubeArray]] pname:imageCubeArray specifies whether image
    views with a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY can: be created, and that the
    corresponding code:SampledCubeArray and code:ImageCubeArray SPIR-V
    capabilities can: be used in shader code.
  * [[features-independentBlend]] pname:independentBlend specifies whether
    the sname:VkPipelineColorBlendAttachmentState settings are controlled
    independently per-attachment.
    If this feature is not enabled, the
    sname:VkPipelineColorBlendAttachmentState settings for all color
    attachments must: be identical.
    Otherwise, a different sname:VkPipelineColorBlendAttachmentState can: be
    provided for each bound color attachment.
  * [[features-geometryShader]] pname:geometryShader specifies whether
    geometry shaders are supported.
    If this feature is not enabled, the ename:VK_SHADER_STAGE_GEOMETRY_BIT
    and ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT enum values must: not be
    used.
    This also specifies whether shader modules can: declare the
    code:Geometry capability.
  * [[features-tessellationShader]] pname:tessellationShader specifies
    whether tessellation control and evaluation shaders are supported.
    If this feature is not enabled, the
    ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, and
    ename:VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO enum
    values must: not be used.
    This also specifies whether shader modules can: declare the
    code:Tessellation capability.
  * [[features-sampleRateShading]] pname:sampleRateShading specifies whether
    <<primsrast-sampleshading,Sample Shading>> and multisample interpolation
    are supported.
    If this feature is not enabled, the pname:sampleShadingEnable member of
    the slink:VkPipelineMultisampleStateCreateInfo structure must: be set to
    ename:VK_FALSE and the pname:minSampleShading member is ignored.
    This also specifies whether shader modules can: declare the
    code:SampleRateShading capability.
  * [[features-dualSrcBlend]] pname:dualSrcBlend specifies whether blend
    operations which take two sources are supported.
    If this feature is not enabled, the ename:VK_BLEND_FACTOR_SRC1_COLOR,
    ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
    ename:VK_BLEND_FACTOR_SRC1_ALPHA, and
    ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA enum values must: not be used
    as source or destination blending factors.
    See <<framebuffer-dsb>>.
  * [[features-logicOp]] pname:logicOp specifies whether logic operations
    are supported.
    If this feature is not enabled, the pname:logicOpEnable member of the
    slink:VkPipelineColorBlendStateCreateInfo structure must: be set to
    ename:VK_FALSE, and the pname:logicOp member is ignored.
  * [[features-multiDrawIndirect]] pname:multiDrawIndirect specifies whether
    multiple draw indirect is supported.
    If this feature is not enabled, the pname:drawCount parameter to the
    fname:vkCmdDrawIndirect and fname:vkCmdDrawIndexedIndirect commands
    must: be 0 or 1.
    The pname:maxDrawIndirectCount member of the
    sname:VkPhysicalDeviceLimits structure must: also be 1 if this feature
    is not supported.
    See <<limits-maxDrawIndirectCount, pname:maxDrawIndirectCount>>.
  * [[features-drawIndirectFirstInstance]] pname:drawIndirectFirstInstance
    specifies whether indirect drawing calls support the pname:firstInstance
    parameter.
    If this feature is not enabled, the pname:firstInstance member of all
    sname:VkDrawIndirectCommand and sname:VkDrawIndexedIndirectCommand
    structures that are provided to the fname:vkCmdDrawIndirect and
    fname:vkCmdDrawIndexedIndirect commands must: be 0.
  * [[features-depthClamp]] pname:depthClamp specifies whether depth
    clamping is supported.
    If this feature is not enabled, the pname:depthClampEnable member of the
    slink:VkPipelineRasterizationStateCreateInfo structure must: be set to
    ename:VK_FALSE.
    Otherwise, setting pname:depthClampEnable to ename:VK_TRUE will enable
    depth clamping.
  * [[features-depthBiasClamp]] pname:depthBiasClamp specifies whether depth
    bias clamping is supported.
    If this feature is not enabled, the pname:depthBiasClamp member of the
    slink:VkPipelineRasterizationStateCreateInfo structure must: be set to
    0.0 unless the ename:VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state is
    enabled, and the pname:depthBiasClamp parameter to
    fname:vkCmdSetDepthBias must: be set to 0.0.
  * [[features-fillModeNonSolid]] pname:fillModeNonSolid specifies whether
    point and wireframe fill modes are supported.
    If this feature is not enabled, the ename:VK_POLYGON_MODE_POINT and
    ename:VK_POLYGON_MODE_LINE enum values must: not be used.
  * [[features-depthBounds]] pname:depthBounds specifies whether depth
    bounds tests are supported.
    If this feature is not enabled, the pname:depthBoundsTestEnable member
    of the slink:VkPipelineDepthStencilStateCreateInfo structure must: be
    set to ename:VK_FALSE.
    When pname:depthBoundsTestEnable is set to ename:VK_FALSE, the
    pname:minDepthBounds and pname:maxDepthBounds members of the
    slink:VkPipelineDepthStencilStateCreateInfo structure are ignored.
  * [[features-wideLines]] pname:wideLines specifies whether lines with
    width other than 1.0 are supported.
    If this feature is not enabled, the pname:lineWidth member of the
    slink:VkPipelineRasterizationStateCreateInfo structure must: be set to
    1.0 unless the ename:VK_DYNAMIC_STATE_LINE_WIDTH dynamic state is
    enabled, and the pname:lineWidth parameter to fname:vkCmdSetLineWidth
    must: be set to 1.0.
    When this feature is supported, the range and granularity of supported
    line widths are indicated by the pname:lineWidthRange and
    pname:lineWidthGranularity members of the sname:VkPhysicalDeviceLimits
    structure, respectively.
  * [[features-largePoints]] pname:largePoints specifies whether points with
    size greater than 1.0 are supported.
    If this feature is not enabled, only a point size of 1.0 written by a
    shader is supported.
    The range and granularity of supported point sizes are indicated by the
    pname:pointSizeRange and pname:pointSizeGranularity members of the
    sname:VkPhysicalDeviceLimits structure, respectively.
  * [[features-alphaToOne]] pname:alphaToOne specifies whether the
    implementation is able to replace the alpha value of the fragment shader
    color output in the <<fragops-covg, Multisample Coverage>> fragment
    operation.
    If this feature is not enabled, then the pname:alphaToOneEnable member
    of the slink:VkPipelineMultisampleStateCreateInfo structure must: be set
    to ename:VK_FALSE.
    Otherwise setting pname:alphaToOneEnable to ename:VK_TRUE will enable
    alpha-to-one behavior.
  * [[features-multiViewport]] pname:multiViewport specifies whether more
    than one viewport is supported.
    If this feature is not enabled:
  ** The pname:viewportCount and pname:scissorCount members of the
     slink:VkPipelineViewportStateCreateInfo structure must: be set to 1.
  ** The pname:firstViewport and pname:viewportCount parameters to the
     fname:vkCmdSetViewport command must: be set to 0 and 1, respectively.
  ** The pname:firstScissor and pname:scissorCount parameters to the
     fname:vkCmdSetScissor command must: be set to 0 and 1, respectively.
ifdef::VK_NV_scissor_exclusive[]
  ** The pname:exclusiveScissorCount member of the
     slink:VkPipelineViewportExclusiveScissorStateCreateInfoNV structure
     must: be set to 0 or 1.
  ** The pname:firstExclusiveScissor and pname:exclusiveScissorCount
     parameters to the fname:vkCmdSetExclusiveScissorNV command must: be set
     to 0 and 1, respectively.
endif::VK_NV_scissor_exclusive[]
  * [[features-samplerAnisotropy]] pname:samplerAnisotropy specifies whether
    anisotropic filtering is supported.
    If this feature is not enabled, the pname:anisotropyEnable member of the
    slink:VkSamplerCreateInfo structure must: be ename:VK_FALSE.
  * [[features-textureCompressionETC2]] pname:textureCompressionETC2
    specifies whether all of the ETC2 and EAC compressed texture formats are
    supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
  ** ename:VK_FORMAT_EAC_R11_UNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11_SNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

  * [[features-textureCompressionASTC_LDR]] pname:textureCompressionASTC_LDR
    specifies whether all of the ASTC LDR compressed texture formats are
    supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

  * [[features-textureCompressionBC]] pname:textureCompressionBC specifies
    whether all of the BC compressed texture formats are supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK
  ** ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK
  ** ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK
  ** ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK
  ** ename:VK_FORMAT_BC2_UNORM_BLOCK
  ** ename:VK_FORMAT_BC2_SRGB_BLOCK
  ** ename:VK_FORMAT_BC3_UNORM_BLOCK
  ** ename:VK_FORMAT_BC3_SRGB_BLOCK
  ** ename:VK_FORMAT_BC4_UNORM_BLOCK
  ** ename:VK_FORMAT_BC4_SNORM_BLOCK
  ** ename:VK_FORMAT_BC5_UNORM_BLOCK
  ** ename:VK_FORMAT_BC5_SNORM_BLOCK
  ** ename:VK_FORMAT_BC6H_UFLOAT_BLOCK
  ** ename:VK_FORMAT_BC6H_SFLOAT_BLOCK
  ** ename:VK_FORMAT_BC7_UNORM_BLOCK
  ** ename:VK_FORMAT_BC7_SRGB_BLOCK
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

  * [[features-occlusionQueryPrecise]] pname:occlusionQueryPrecise specifies
    whether occlusion queries returning actual sample counts are supported.
    Occlusion queries are created in a sname:VkQueryPool by specifying the
    pname:queryType of ename:VK_QUERY_TYPE_OCCLUSION in the
    slink:VkQueryPoolCreateInfo structure which is passed to
    fname:vkCreateQueryPool.
    If this feature is enabled, queries of this type can: enable
    ename:VK_QUERY_CONTROL_PRECISE_BIT in the pname:flags parameter to
    fname:vkCmdBeginQuery.
    If this feature is not supported, the implementation supports only
    boolean occlusion queries.
    When any samples are passed, boolean queries will return a non-zero
    result value, otherwise a result value of zero is returned.
    When this feature is enabled and ename:VK_QUERY_CONTROL_PRECISE_BIT is
    set, occlusion queries will report the actual number of samples passed.
  * [[features-pipelineStatisticsQuery]] pname:pipelineStatisticsQuery
    specifies whether the pipeline statistics queries are supported.
    If this feature is not enabled, queries of type
    ename:VK_QUERY_TYPE_PIPELINE_STATISTICS cannot: be created, and none of
    the elink:VkQueryPipelineStatisticFlagBits bits can: be set in the
    pname:pipelineStatistics member of the slink:VkQueryPoolCreateInfo
    structure.
  * [[features-vertexPipelineStoresAndAtomics]]
    pname:vertexPipelineStoresAndAtomics specifies whether storage buffers
    and images support stores and atomic operations in the vertex,
    tessellation, and geometry shader stages.
    If this feature is not enabled, all storage image, storage texel buffer,
    and storage buffer variables used by these stages in shader modules
    must: be decorated with the code:NonWritable decoration (or the
    code:readonly memory qualifier in GLSL).
  * [[features-fragmentStoresAndAtomics]] pname:fragmentStoresAndAtomics
    specifies whether storage buffers and images support stores and atomic
    operations in the fragment shader stage.
    If this feature is not enabled, all storage image, storage texel buffer,
    and storage buffer variables used by the fragment stage in shader
    modules must: be decorated with the code:NonWritable decoration (or the
    code:readonly memory qualifier in GLSL).
  * [[features-shaderTessellationAndGeometryPointSize]]
    pname:shaderTessellationAndGeometryPointSize specifies whether the
    code:PointSize built-in decoration is available in the tessellation
    control, tessellation evaluation, and geometry shader stages.
    If this feature is not enabled, members decorated with the
    code:PointSize built-in decoration must: not be read from or written to
    and all points written from a tessellation or geometry shader will have
    a size of 1.0.
    This also specifies whether shader modules can: declare the
    code:TessellationPointSize capability for tessellation control and
    evaluation shaders, or if the shader modules can: declare the
    code:GeometryPointSize capability for geometry shaders.
    An implementation supporting this feature must: also support one or both
    of the <<features-tessellationShader, pname:tessellationShader>> or
    <<features-geometryShader, pname:geometryShader>> features.
  * [[features-shaderImageGatherExtended]] pname:shaderImageGatherExtended
    specifies whether the extended set of image gather instructions are
    available in shader code.
    If this feature is not enabled, the code:OpImage*Gather instructions do
    not support the code:Offset and code:ConstOffsets operands.
    This also specifies whether shader modules can: declare the
    code:ImageGatherExtended capability.
  * [[features-shaderStorageImageExtendedFormats]]
    pname:shaderStorageImageExtendedFormats specifies whether all the
    "`storage image extended formats`" below are supported; if this feature
    is supported, then the ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_R16G16_SFLOAT
  ** ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32
  ** ename:VK_FORMAT_R16_SFLOAT
  ** ename:VK_FORMAT_R16G16B16A16_UNORM
  ** ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32
  ** ename:VK_FORMAT_R16G16_UNORM
  ** ename:VK_FORMAT_R8G8_UNORM
  ** ename:VK_FORMAT_R16_UNORM
  ** ename:VK_FORMAT_R8_UNORM
  ** ename:VK_FORMAT_R16G16B16A16_SNORM
  ** ename:VK_FORMAT_R16G16_SNORM
  ** ename:VK_FORMAT_R8G8_SNORM
  ** ename:VK_FORMAT_R16_SNORM
  ** ename:VK_FORMAT_R8_SNORM
  ** ename:VK_FORMAT_R16G16_SINT
  ** ename:VK_FORMAT_R8G8_SINT
  ** ename:VK_FORMAT_R16_SINT
  ** ename:VK_FORMAT_R8_SINT
  ** ename:VK_FORMAT_A2B10G10R10_UINT_PACK32
  ** ename:VK_FORMAT_R16G16_UINT
  ** ename:VK_FORMAT_R8G8_UINT
  ** ename:VK_FORMAT_R16_UINT
  ** ename:VK_FORMAT_R8_UINT
+
[NOTE]
.Note
====
pname:shaderStorageImageExtendedFormats feature only adds a guarantee of
format support, which is specified for the whole physical device.
Therefore enabling or disabling the feature via flink:vkCreateDevice has no
practical effect.

To query for additional properties, or if the feature is not supported,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats, as usual rules allow.

ename:VK_FORMAT_R32G32_UINT, ename:VK_FORMAT_R32G32_SINT, and
ename:VK_FORMAT_R32G32_SFLOAT from code:StorageImageExtendedFormats SPIR-V
capability, are already covered by core Vulkan
<<formats-mandatory-features-32bit,mandatory format support>>.
====

  * [[features-shaderStorageImageMultisample]]
    pname:shaderStorageImageMultisample specifies whether multisampled
    storage images are supported.
    If this feature is not enabled, images that are created with a
    pname:usage that includes ename:VK_IMAGE_USAGE_STORAGE_BIT must: be
    created with pname:samples equal to ename:VK_SAMPLE_COUNT_1_BIT.
    This also specifies whether shader modules can: declare the
    code:StorageImageMultisample and code:ImageMSArray capabilities.
  * [[features-shaderStorageImageReadWithoutFormat]]
    pname:shaderStorageImageReadWithoutFormat specifies whether storage
    images and storage texel buffers require a format qualifier to be
    specified when reading.
ifdef::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
    pname:shaderStorageImageReadWithoutFormat applies only to formats listed
    in the <<formats-without-shader-storage-format,storage without format>>
    list.
endif::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
  * [[features-shaderStorageImageWriteWithoutFormat]]
    pname:shaderStorageImageWriteWithoutFormat specifies whether storage
    images and storage texel buffers require a format qualifier to be
    specified when writing.
ifdef::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
    pname:shaderStorageImageWriteWithoutFormat applies only to formats
    listed in the <<formats-without-shader-storage-format,storage without
    format>> list.
endif::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
  * [[features-shaderUniformBufferArrayDynamicIndexing]]
    pname:shaderUniformBufferArrayDynamicIndexing specifies whether arrays
    of uniform buffers can: be indexed by _dynamically uniform_ integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also specifies whether shader modules can: declare the
    code:UniformBufferArrayDynamicIndexing capability.
  * [[features-shaderSampledImageArrayDynamicIndexing]]
    pname:shaderSampledImageArrayDynamicIndexing specifies whether arrays of
    samplers or sampled images can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must: be indexed only by constant
    integral expressions when aggregated into arrays in shader code.
    This also specifies whether shader modules can: declare the
    code:SampledImageArrayDynamicIndexing capability.
  * [[features-shaderStorageBufferArrayDynamicIndexing]]
    pname:shaderStorageBufferArrayDynamicIndexing specifies whether arrays
    of storage buffers can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also specifies whether shader modules can: declare the
    code:StorageBufferArrayDynamicIndexing capability.
  * [[features-shaderStorageImageArrayDynamicIndexing]]
    pname:shaderStorageImageArrayDynamicIndexing specifies whether arrays of
    storage images can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must: be indexed only by constant
    integral expressions when aggregated into arrays in shader code.
    This also specifies whether shader modules can: declare the
    code:StorageImageArrayDynamicIndexing capability.
  * [[features-shaderClipDistance]] pname:shaderClipDistance specifies
    whether clip distances are supported in shader code.
    If this feature is not enabled, any members decorated with the
    code:ClipDistance built-in decoration must: not be read from or written
    to in shader modules.
    This also specifies whether shader modules can: declare the
    code:ClipDistance capability.
  * [[features-shaderCullDistance]] pname:shaderCullDistance specifies
    whether cull distances are supported in shader code.
    If this feature is not enabled, any members decorated with the
    code:CullDistance built-in decoration must: not be read from or written
    to in shader modules.
    This also specifies whether shader modules can: declare the
    code:CullDistance capability.
  * [[features-shaderFloat64]] pname:shaderFloat64 specifies whether 64-bit
    floats (doubles) are supported in shader code.
    If this feature is not enabled, 64-bit floating-point types must: not be
    used in shader code.
    This also specifies whether shader modules can: declare the code:Float64
    capability.
    Declaring and using 64-bit floats is enabled for all storage classes
    that SPIR-V allows with the code:Float64 capability.
  * [[features-shaderInt64]] pname:shaderInt64 specifies whether 64-bit
    integers (signed and unsigned) are supported in shader code.
    If this feature is not enabled, 64-bit integer types must: not be used
    in shader code.
    This also specifies whether shader modules can: declare the code:Int64
    capability.
    Declaring and using 64-bit integers is enabled for all storage classes
    that SPIR-V allows with the code:Int64 capability.
  * [[features-shaderInt16]] pname:shaderInt16 specifies whether 16-bit
    integers (signed and unsigned) are supported in shader code.
    If this feature is not enabled, 16-bit integer types must: not be used
    in shader code.
    This also specifies whether shader modules can: declare the code:Int16
    capability.
    However, this only enables a subset of the storage classes that SPIR-V
    allows for the code:Int16 SPIR-V capability: Declaring and using 16-bit
    integers in the code:Private,
ifndef::VK_KHR_workgroup_memory_explicit_layout[]
    code:Workgroup,
endif::VK_KHR_workgroup_memory_explicit_layout[]
ifdef::VK_KHR_workgroup_memory_explicit_layout[]
    code:Workgroup (for non-Block variables),
endif::VK_KHR_workgroup_memory_explicit_layout[]
    and code:Function storage classes is enabled, while declaring them in
    the interface storage classes (e.g., code:UniformConstant, code:Uniform,
    code:StorageBuffer, code:Input, code:Output, and code:PushConstant) is
    not enabled.
  * [[features-shaderResourceResidency]] pname:shaderResourceResidency
    specifies whether image operations that return resource residency
    information are supported in shader code.
    If this feature is not enabled, the code:OpImageSparse* instructions
    must: not be used in shader code.
    This also specifies whether shader modules can: declare the
    code:SparseResidency capability.
    The feature requires at least one of the ptext:sparseResidency* features
    to be supported.
ifdef::VKSC_VERSION_1_0[This must: be ename:VK_FALSE in Vulkan SC <<SCID-8>>.]
  * [[features-shaderResourceMinLod]] pname:shaderResourceMinLod specifies
    whether image operations specifying the minimum resource LOD are
    supported in shader code.
    If this feature is not enabled, the code:MinLod image operand must: not
    be used in shader code.
    This also specifies whether shader modules can: declare the code:MinLod
    capability.
  * [[features-sparseBinding]] pname:sparseBinding specifies whether
    resource memory can: be managed at opaque sparse block level instead of
    at the object level.
    If this feature is not enabled, resource memory must: be bound only on a
    per-object basis using the fname:vkBindBufferMemory and
    fname:vkBindImageMemory commands.
    In this case, buffers and images must: not be created with
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT and
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in the pname:flags member
    of the slink:VkBufferCreateInfo and slink:VkImageCreateInfo structures,
    respectively.
    Otherwise resource memory can: be managed as described in
    <<sparsememory-sparseresourcefeatures,Sparse Resource Features>>.
ifdef::VKSC_VERSION_1_0[This must: be ename:VK_FALSE in Vulkan SC <<SCID-8>>.]
  * [[features-sparseResidencyBuffer]] pname:sparseResidencyBuffer specifies
    whether the device can: access partially resident buffers.
    If this feature is not enabled, buffers must: not be created with
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags
    member of the slink:VkBufferCreateInfo structure.
ifdef::VKSC_VERSION_1_0[This must: be ename:VK_FALSE in Vulkan SC <<SCID-8>>.]
  * [[features-sparseResidencyImage2D]] pname:sparseResidencyImage2D
    specifies whether the device can: access partially resident 2D images
    with 1 sample per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_1_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
ifdef::VKSC_VERSION_1_0[This must: be ename:VK_FALSE in Vulkan SC <<SCID-8>>.]
  * [[features-sparseResidencyImage3D]] pname:sparseResidencyImage3D
    specifies whether the device can: access partially resident 3D images.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_3D must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
ifdef::VKSC_VERSION_1_0[This must: be ename:VK_FALSE in Vulkan SC <<SCID-8>>.]
  * [[features-sparseResidency2Samples]] pname:sparseResidency2Samples
    specifies whether the physical device can: access partially resident 2D
    images with 2 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_2_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
ifdef::VKSC_VERSION_1_0[This must: be ename:VK_FALSE in Vulkan SC <<SCID-8>>.]
  * [[features-sparseResidency4Samples]] pname:sparseResidency4Samples
    specifies whether the physical device can: access partially resident 2D
    images with 4 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_4_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
ifdef::VKSC_VERSION_1_0[This must: be ename:VK_FALSE in Vulkan SC <<SCID-8>>.]
  * [[features-sparseResidency8Samples]] pname:sparseResidency8Samples
    specifies whether the physical device can: access partially resident 2D
    images with 8 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_8_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
ifdef::VKSC_VERSION_1_0[This must: be ename:VK_FALSE in Vulkan SC <<SCID-8>>.]
  * [[features-sparseResidency16Samples]] pname:sparseResidency16Samples
    specifies whether the physical device can: access partially resident 2D
    images with 16 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_16_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
ifdef::VKSC_VERSION_1_0[This must: be ename:VK_FALSE in Vulkan SC <<SCID-8>>.]
  * [[features-sparseResidencyAliased]] pname:sparseResidencyAliased
    specifies whether the physical device can: correctly access data aliased
    into multiple locations.
    If this feature is not enabled, the
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT and
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT enum values must: not be used
    in pname:flags members of the slink:VkBufferCreateInfo and
    slink:VkImageCreateInfo structures, respectively.
ifdef::VKSC_VERSION_1_0[This must: be ename:VK_FALSE in Vulkan SC <<SCID-8>>.]
  * [[features-variableMultisampleRate]] pname:variableMultisampleRate
    specifies whether all pipelines that will be bound to a command buffer
    during a <<renderpass-noattachments, subpass which uses no attachments>>
    must: have the same value for
    slink:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples.
    If set to ename:VK_TRUE, the implementation supports variable
    multisample rates in a subpass which uses no attachments.
    If set to ename:VK_FALSE, then all pipelines bound in such a subpass
    must: have the same multisample rate.
    This has no effect in situations where a subpass uses any attachments.
  * [[features-inheritedQueries]] pname:inheritedQueries specifies whether a
    secondary command buffer may: be executed while a query is active.

ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkPhysicalDeviceFeatures::pname:shaderResourceResidency must: be
    reported as ename:VK_FALSE <<SCID-8>>.
  * slink:VkPhysicalDeviceFeatures::pname:sparseBinding must: be reported as
    ename:VK_FALSE <<SCID-8>>.
  * slink:VkPhysicalDeviceFeatures::pname:sparseResidencyBuffer must: be
    reported as ename:VK_FALSE <<SCID-8>>.
  * slink:VkPhysicalDeviceFeatures::pname:sparseResidencyImage2D must: be
    reported as ename:VK_FALSE <<SCID-8>>.
  * slink:VkPhysicalDeviceFeatures::pname:sparseResidencyImage3D must: be
    reported as ename:VK_FALSE <<SCID-8>>.
  * slink:VkPhysicalDeviceFeatures::pname:sparseResidency2Samples must: be
    reported as ename:VK_FALSE <<SCID-8>>.
  * slink:VkPhysicalDeviceFeatures::pname:sparseResidency4Samples must: be
    reported as ename:VK_FALSE <<SCID-8>>.
  * slink:VkPhysicalDeviceFeatures::pname:sparseResidency8Samples must: be
    reported as ename:VK_FALSE <<SCID-8>>.
  * slink:VkPhysicalDeviceFeatures::pname:sparseResidency16Samples must: be
    reported as ename:VK_FALSE <<SCID-8>>.
  * slink:VkPhysicalDeviceFeatures::pname:sparseResidencyAliased must: be
    reported as ename:VK_FALSE <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/structs/VkPhysicalDeviceFeatures.adoc[]
--

ifdef::VK_VERSION_1_2[]
[open,refpage='VkPhysicalDeviceVulkan11Features',desc='Structure describing the Vulkan 1.1 features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceVulkan11Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVulkan11Features.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

:anchor-prefix:
include::{chapters}/features.adoc[tag=VK_KHR_16bit_storage-features]
include::{chapters}/features.adoc[tag=VK_KHR_multiview-features]
include::{chapters}/features.adoc[tag=VK_KHR_variable_pointers-features]
include::{chapters}/features.adoc[tag=VK_KHR_protected_memory-features]
include::{chapters}/features.adoc[tag=VK_KHR_sampler_ycbcr_conversion-features]
include::{chapters}/features.adoc[tag=VK_KHR_shader_draw_parameters-features]

:refpage: VkPhysicalDeviceVulkan11Features
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceVulkan11Features.adoc[]
--

[open,refpage='VkPhysicalDeviceVulkan12Features',desc='Structure describing the Vulkan 1.2 features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceVulkan12Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVulkan12Features.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

:anchor-prefix:
  * [[features-samplerMirrorClampToEdge]] pname:samplerMirrorClampToEdge
    indicates whether the implementation supports the
    ename:VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE sampler address mode.
    If this feature is not enabled, the
    ename:VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE sampler address mode
    must: not be used.
  * [[features-drawIndirectCount]] pname:drawIndirectCount indicates whether
    the implementation supports the flink:vkCmdDrawIndirectCount and
    flink:vkCmdDrawIndexedIndirectCount functions.
    If this feature is not enabled, these functions must: not be used.
include::{chapters}/features.adoc[tag=VK_KHR_8bit_storage-features]
include::{chapters}/features.adoc[tag=VK_KHR_shader_atomic_int64-features]
include::{chapters}/features.adoc[tag=VK_KHR_shader_float16_int8-features]
  * [[features-descriptorIndexing]] pname:descriptorIndexing indicates
    whether the implementation supports the minimum set of descriptor
    indexing features as described in the <<features-requirements, Feature
    Requirements>> section.
    Enabling the pname:descriptorIndexing member when flink:vkCreateDevice
    is called does not imply the other minimum descriptor indexing features
    are also enabled.
    Those other descriptor indexing features must: be enabled individually
    as needed by the application.
include::{chapters}/features.adoc[tag=VK_EXT_descriptor_indexing-features]
  * [[features-samplerFilterMinmax]] pname:samplerFilterMinmax indicates
    whether the implementation supports a minimum set of required formats
    supporting min/max filtering as defined by the
    <<limits-filterMinmaxSingleComponentFormats-minimum-requirements,
    pname:filterMinmaxSingleComponentFormats>> property minimum
    requirements.
    If this feature is not enabled, then
    slink:VkSamplerReductionModeCreateInfo must: only use
    ename:VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE.
include::{chapters}/features.adoc[tag=VK_EXT_scalar_block_layout-features]
include::{chapters}/features.adoc[tag=VK_KHR_imageless_framebuffer-features]
include::{chapters}/features.adoc[tag=VK_KHR_uniform_buffer_standard_layout-features]
include::{chapters}/features.adoc[tag=VK_KHR_shader_subgroup_extended_types-features]
include::{chapters}/features.adoc[tag=VK_KHR_separate_depth_stencil_layouts-features]
include::{chapters}/features.adoc[tag=VK_EXT_host_query_reset-features]
include::{chapters}/features.adoc[tag=VK_KHR_timeline_semaphore-features]
include::{chapters}/features.adoc[tag=VK_EXT_buffer_device_address-features]
include::{chapters}/features.adoc[tag=VK_KHR_vulkan_memory_model-features]
  * [[features-shaderOutputViewportIndex]] pname:shaderOutputViewportIndex
    indicates whether the implementation supports the
    code:ShaderViewportIndex SPIR-V capability enabling variables decorated
    with the code:ViewportIndex built-in to be exported from
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[mesh,]
    vertex or tessellation evaluation shaders.
    If this feature is not enabled, the code:ViewportIndex built-in
    decoration must: not be used on outputs in
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[mesh,]
    vertex or tessellation evaluation shaders.
  * [[features-shaderOutputLayer]] pname:shaderOutputLayer indicates whether
    the implementation supports the code:ShaderLayer SPIR-V capability
    enabling variables decorated with the code:Layer built-in to be exported
    from
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[mesh,]
    vertex or tessellation evaluation shaders.
    If this feature is not enabled, the code:Layer built-in decoration must:
    not be used on outputs in
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[mesh,]
    vertex or tessellation evaluation shaders.
  * [[features-subgroupBroadcastDynamicId]] If
    pname:subgroupBroadcastDynamicId is ename:VK_TRUE, the "`Id`" operand of
    code:OpGroupNonUniformBroadcast can: be dynamically uniform within a
    subgroup, and the "`Index`" operand of
    code:OpGroupNonUniformQuadBroadcast can: be dynamically uniform within
    the derivative group.
    If it is ename:VK_FALSE, these operands must: be constants.

:refpage: VkPhysicalDeviceVulkan12Features
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceVulkan12Features.adoc[]
--
endif::VK_VERSION_1_2[]

ifdef::VK_VERSION_1_3[]
[open,refpage='VkPhysicalDeviceVulkan13Features',desc='Structure describing the Vulkan 1.3 features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceVulkan13Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVulkan13Features.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

:anchor-prefix:
include::{chapters}/features.adoc[tag=VK_EXT_image_robustness-features]
include::{chapters}/features.adoc[tag=VK_EXT_inline_uniform_block-features]
include::{chapters}/features.adoc[tag=VK_EXT_pipeline_creation_cache_control-features]
include::{chapters}/features.adoc[tag=VK_EXT_private_data-features]
include::{chapters}/features.adoc[tag=VK_EXT_shader_demote_to_helper_invocation-features]
include::{chapters}/features.adoc[tag=VK_KHR_shader_terminate_invocation-features]
include::{chapters}/features.adoc[tag=VK_EXT_subgroup_size_control-features]
include::{chapters}/features.adoc[tag=VK_KHR_synchronization2-features]
include::{chapters}/features.adoc[tag=VK_EXT_texture_compression_astc_hdr-features]
include::{chapters}/features.adoc[tag=VK_KHR_zero_initialize_workgroup_memory-features]
include::{chapters}/features.adoc[tag=VK_KHR_dynamic_rendering-features]
include::{chapters}/features.adoc[tag=VK_KHR_shader_integer_dot_product-features]
include::{chapters}/features.adoc[tag=VK_KHR_maintenance4-features]

:refpage: VkPhysicalDeviceVulkan13Features
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceVulkan13Features.adoc[]
--
endif::VK_VERSION_1_3[]

ifdef::VK_VERSION_1_1,VK_KHR_variable_pointers[]
[open,refpage='VkPhysicalDeviceVariablePointersFeatures',desc='Structure describing variable pointers features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceVariablePointerFeatures VkPhysicalDeviceVariablePointersFeaturesKHR VkPhysicalDeviceVariablePointerFeaturesKHR']
--
The sname:VkPhysicalDeviceVariablePointersFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVariablePointersFeatures.adoc[]

ifndef::VKSC_VERSION_1_0[]
ifdef::VK_VERSION_1_1[]
include::{generated}/api/structs/VkPhysicalDeviceVariablePointerFeatures.adoc[]
endif::VK_VERSION_1_1[]
endif::VKSC_VERSION_1_0[]

ifdef::VK_KHR_variable_pointers[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceVariablePointersFeaturesKHR.adoc[]

include::{generated}/api/structs/VkPhysicalDeviceVariablePointerFeaturesKHR.adoc[]
endif::VK_KHR_variable_pointers[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_variable_pointers-features[]
  * [[{anchor-prefix}features-variablePointersStorageBuffer]]
    pname:variablePointersStorageBuffer specifies whether the implementation
    supports the SPIR-V code:VariablePointersStorageBuffer capability.
    When this feature is not enabled, shader modules must: not declare the
    `SPV_KHR_variable_pointers` extension or the
    code:VariablePointersStorageBuffer capability.
  * [[{anchor-prefix}features-variablePointers]] pname:variablePointers
    specifies whether the implementation supports the SPIR-V
    code:VariablePointers capability.
    When this feature is not enabled, shader modules must: not declare the
    code:VariablePointers capability.
// end::VK_KHR_variable_pointers-features[]

:refpage: VkPhysicalDeviceVariablePointersFeatures
include::{chapters}/features.adoc[tag=features]

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceVariablePointersFeatures-variablePointers-01431]]
    If pname:variablePointers is enabled then
    pname:variablePointersStorageBuffer must: also be enabled
****

include::{generated}/validity/structs/VkPhysicalDeviceVariablePointersFeatures.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_variable_pointers[]

ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
[open,refpage='VkPhysicalDeviceMultiviewFeatures',desc='Structure describing multiview features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMultiviewFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMultiviewFeatures.adoc[]

ifdef::VK_KHR_multiview[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceMultiviewFeaturesKHR.adoc[]
endif::VK_KHR_multiview[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_multiview-features[]
  * [[{anchor-prefix}features-multiview]] pname:multiview specifies whether
    the implementation supports multiview rendering within a render pass.
    If this feature is not enabled, the view mask of each subpass must:
    always be zero.
  * [[{anchor-prefix}features-multiview-gs]] pname:multiviewGeometryShader
    specifies whether the implementation supports multiview rendering within
    a render pass, with <<geometry,geometry shaders>>.
    If this feature is not enabled, then a pipeline compiled against a
    subpass with a non-zero view mask must: not include a geometry shader.
  * [[{anchor-prefix}features-multiview-tess]]
    pname:multiviewTessellationShader specifies whether the implementation
    supports multiview rendering within a render pass, with
    <<tessellation,tessellation shaders>>.
    If this feature is not enabled, then a pipeline compiled against a
    subpass with a non-zero view mask must: not include any tessellation
    shaders.
// end::VK_KHR_multiview-features[]

:refpage: VkPhysicalDeviceMultiviewFeatures
include::{chapters}/features.adoc[tag=features]

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceMultiviewFeatures-multiviewGeometryShader-00580]]
    If pname:multiviewGeometryShader is enabled then pname:multiview must:
    also be enabled
  * [[VUID-VkPhysicalDeviceMultiviewFeatures-multiviewTessellationShader-00581]]
    If pname:multiviewTessellationShader is enabled then pname:multiview
    must: also be enabled
****

include::{generated}/validity/structs/VkPhysicalDeviceMultiviewFeatures.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_multiview[]

ifdef::VK_EXT_shader_atomic_float[]
[open,refpage='VkPhysicalDeviceShaderAtomicFloatFeaturesEXT',desc='Structure describing features supported by VK_EXT_shader_atomic_float',type='structs']
--
The slink:VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// tag::VK_EXT_shader_atomic_float-features[]
  * [[features-shaderBufferFloat32Atomics]] pname:shaderBufferFloat32Atomics
    indicates whether shaders can: perform 32-bit floating-point load, store
    and exchange atomic operations on storage buffers.
  * [[features-shaderBufferFloat32AtomicAdd]]
    pname:shaderBufferFloat32AtomicAdd indicates whether shaders can:
    perform 32-bit floating-point add atomic operations on storage buffers.
  * [[features-shaderBufferFloat64Atomics]] pname:shaderBufferFloat64Atomics
    indicates whether shaders can: perform 64-bit floating-point load, store
    and exchange atomic operations on storage buffers.
  * [[features-shaderBufferFloat64AtomicAdd]]
    pname:shaderBufferFloat64AtomicAdd indicates whether shaders can:
    perform 64-bit floating-point add atomic operations on storage buffers.
  * [[features-shaderSharedFloat32Atomics]] pname:shaderSharedFloat32Atomics
    indicates whether shaders can: perform 32-bit floating-point load, store
    and exchange atomic operations on shared
ifdef::VK_EXT_mesh_shader[]
    and payload
endif::VK_EXT_mesh_shader[]
    memory.
  * [[features-shaderSharedFloat32AtomicAdd]]
    pname:shaderSharedFloat32AtomicAdd indicates whether shaders can:
    perform 32-bit floating-point add atomic operations on shared
ifdef::VK_EXT_mesh_shader[]
    and payload
endif::VK_EXT_mesh_shader[]
    memory.
  * [[features-shaderSharedFloat64Atomics]] pname:shaderSharedFloat64Atomics
    indicates whether shaders can: perform 64-bit floating-point load, store
    and exchange atomic operations on shared
ifdef::VK_EXT_mesh_shader[]
    and payload
endif::VK_EXT_mesh_shader[]
    memory.
  * [[features-shaderSharedFloat64AtomicAdd]]
    pname:shaderSharedFloat64AtomicAdd indicates whether shaders can:
    perform 64-bit floating-point add atomic operations on shared
ifdef::VK_EXT_mesh_shader[]
    and payload
endif::VK_EXT_mesh_shader[]
    memory.
  * [[features-shaderImageFloat32Atomics]] pname:shaderImageFloat32Atomics
    indicates whether shaders can: perform 32-bit floating-point load, store
    and exchange atomic image operations.
  * [[features-shaderImageFloat32AtomicAdd]]
    pname:shaderImageFloat32AtomicAdd indicates whether shaders can: perform
    32-bit floating-point add atomic image operations.
  * [[features-sparseImageFloat32Atomics]] pname:sparseImageFloat32Atomics
    indicates whether 32-bit floating-point load, store and exchange atomic
    operations can: be used on sparse images.
  * [[features-sparseImageFloat32AtomicAdd]]
    pname:sparseImageFloat32AtomicAdd indicates whether 32-bit
    floating-point add atomic operations can: be used on sparse images.
// end::VK_EXT_shader_atomic_float-features[]

:refpage: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.adoc[]
--
endif::VK_EXT_shader_atomic_float[]

ifdef::VK_EXT_shader_atomic_float2[]
[open,refpage='VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT',desc='Structure describing features supported by VK_EXT_shader_atomic_float2',type='structs']
--
The slink:VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// tag::VK_EXT_shader_atomic_float2-features[]
  * [[features-shaderBufferFloat16Atomics]] pname:shaderBufferFloat16Atomics
    indicates whether shaders can: perform 16-bit floating-point load,
    store, and exchange atomic operations on storage buffers.
  * [[features-shaderBufferFloat16AtomicAdd]]
    pname:shaderBufferFloat16AtomicAdd indicates whether shaders can:
    perform 16-bit floating-point add atomic operations on storage buffers.
  * [[features-shaderBufferFloat16AtomicMinMax]]
    pname:shaderBufferFloat16AtomicMinMax indicates whether shaders can:
    perform 16-bit floating-point min and max atomic operations on storage
    buffers.
  * [[features-shaderBufferFloat32AtomicMinMax]]
    pname:shaderBufferFloat32AtomicMinMax indicates whether shaders can:
    perform 32-bit floating-point min and max atomic operations on storage
    buffers.
  * [[features-shaderBufferFloat64AtomicMinMax]]
    pname:shaderBufferFloat64AtomicMinMax indicates whether shaders can:
    perform 64-bit floating-point min and max atomic operations on storage
    buffers.
  * [[features-shaderSharedFloat16Atomics]] pname:shaderSharedFloat16Atomics
    indicates whether shaders can: perform 16-bit floating-point load, store
    and exchange atomic operations on shared
ifdef::VK_EXT_mesh_shader[]
    and payload
endif::VK_EXT_mesh_shader[]
    memory.
  * [[features-shaderSharedFloat16AtomicAdd]]
    pname:shaderSharedFloat16AtomicAdd indicates whether shaders can:
    perform 16-bit floating-point add atomic operations on shared
ifdef::VK_EXT_mesh_shader[]
    and payload
endif::VK_EXT_mesh_shader[]
    memory.
  * [[features-shaderSharedFloat16AtomicMinMax]]
    pname:shaderSharedFloat16AtomicMinMax indicates whether shaders can:
    perform 16-bit floating-point min and max atomic operations on shared
ifdef::VK_EXT_mesh_shader[]
    and payload
endif::VK_EXT_mesh_shader[]
    memory.
  * [[features-shaderSharedFloat32AtomicMinMax]]
    pname:shaderSharedFloat32AtomicMinMax indicates whether shaders can:
    perform 32-bit floating-point min and max atomic operations on shared
ifdef::VK_EXT_mesh_shader[]
    and payload
endif::VK_EXT_mesh_shader[]
    memory.
  * [[features-shaderSharedFloat64AtomicMinMax]]
    pname:shaderSharedFloat64AtomicMinMax indicates whether shaders can:
    perform 64-bit floating-point min and max atomic operations on shared
ifdef::VK_EXT_mesh_shader[]
    and payload
endif::VK_EXT_mesh_shader[]
    memory.
  * [[features-shaderImageFloat32AtomicMinMax]]
    pname:shaderImageFloat32AtomicMinMax indicates whether shaders can:
    perform 32-bit floating-point min and max atomic image operations.
  * [[features-sparseImageFloat32AtomicMinMax]]
    pname:sparseImageFloat32AtomicMinMax indicates whether 32-bit
    floating-point min and max atomic operations can: be used on sparse
    images.
// end::VK_EXT_shader_atomic_float2-features[]

:refpage: VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.adoc[]
--
endif::VK_EXT_shader_atomic_float2[]

ifdef::VK_VERSION_1_2,VK_KHR_shader_atomic_int64[]
[open,refpage='VkPhysicalDeviceShaderAtomicInt64Features',desc='Structure describing features supported by VK_KHR_shader_atomic_int64',type='structs',alias='VkPhysicalDeviceShaderAtomicInt64FeaturesKHR']
--
The slink:VkPhysicalDeviceShaderAtomicInt64Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderAtomicInt64Features.adoc[]

ifdef::VK_KHR_shader_atomic_int64[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.adoc[]
endif::VK_KHR_shader_atomic_int64[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_shader_atomic_int64-features[]
  * [[{anchor-prefix}features-shaderBufferInt64Atomics]]
    pname:shaderBufferInt64Atomics indicates whether shaders can: perform
    64-bit unsigned and signed integer atomic operations on buffers.
  * [[{anchor-prefix}features-shaderSharedInt64Atomics]]
    pname:shaderSharedInt64Atomics indicates whether shaders can: perform
    64-bit unsigned and signed integer atomic operations on shared
ifdef::VK_EXT_mesh_shader[]
    and payload
endif::VK_EXT_mesh_shader[]
    memory.
// end::VK_KHR_shader_atomic_int64-features[]

:refpage: VkPhysicalDeviceShaderAtomicInt64Features
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderAtomicInt64Features.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_shader_atomic_int64[]

ifdef::VK_EXT_shader_image_atomic_int64[]
[open,refpage='VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT',desc='Structure describing features supported by VK_EXT_shader_image_atomic_int64',type='structs']
--
The slink:VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderImageInt64Atomics]] pname:shaderImageInt64Atomics
    indicates whether shaders can: support 64-bit unsigned and signed
    integer atomic operations on images.
  * [[features-sparseImageInt64Atomics]] pname:sparseImageInt64Atomics
    indicates whether 64-bit integer atomics can: be used on sparse images.

:refpage: VkPhysicalDeviceShaderAtomicInt64FeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.adoc[]
--
endif::VK_EXT_shader_image_atomic_int64[]

ifdef::VK_VERSION_1_2,VK_KHR_8bit_storage[]
[open,refpage='VkPhysicalDevice8BitStorageFeatures',desc='Structure describing features supported by VK_KHR_8bit_storage',type='structs',alias='VkPhysicalDevice8BitStorageFeaturesKHR']
--
The slink:VkPhysicalDevice8BitStorageFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDevice8BitStorageFeatures.adoc[]

ifdef::VK_KHR_8bit_storage[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDevice8BitStorageFeaturesKHR.adoc[]
endif::VK_KHR_8bit_storage[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_8bit_storage-features[]
  * [[{anchor-prefix}features-storageBuffer8BitAccess]]
    pname:storageBuffer8BitAccess indicates whether objects in the
    code:StorageBuffer,
ifdef::VK_KHR_ray_tracing_pipeline[code:ShaderRecordBufferKHR,]
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    or code:PhysicalStorageBuffer
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    storage class with the code:Block decoration can: have 8-bit integer
    members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:StorageBuffer8BitAccess capability.
  * [[{anchor-prefix}features-uniformAndStorageBuffer8BitAccess]]
    pname:uniformAndStorageBuffer8BitAccess indicates whether objects in the
    code:Uniform storage class with the code:Block decoration can: have
    8-bit integer members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:UniformAndStorageBuffer8BitAccess capability.
  * [[{anchor-prefix}features-storagePushConstant8]]
    pname:storagePushConstant8 indicates whether objects in the
    code:PushConstant storage class can: have 8-bit integer members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:StoragePushConstant8 capability.
// end::VK_KHR_8bit_storage-features[]

:refpage: VkPhysicalDevice8BitStorageFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevice8BitStorageFeatures.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_8bit_storage[]

ifdef::VK_VERSION_1_1,VK_KHR_16bit_storage[]
[open,refpage='VkPhysicalDevice16BitStorageFeatures',desc='Structure describing features supported by VK_KHR_16bit_storage',type='structs']
--
The slink:VkPhysicalDevice16BitStorageFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDevice16BitStorageFeatures.adoc[]

ifdef::VK_KHR_16bit_storage[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDevice16BitStorageFeaturesKHR.adoc[]
endif::VK_KHR_16bit_storage[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_16bit_storage-features[]
  * [[{anchor-prefix}features-storageBuffer16BitAccess]]
    pname:storageBuffer16BitAccess specifies whether objects in the
    code:StorageBuffer,
ifdef::VK_KHR_ray_tracing_pipeline[code:ShaderRecordBufferKHR,]
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    or code:PhysicalStorageBuffer
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    storage class with the code:Block decoration can: have 16-bit integer
    and 16-bit floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:StorageBuffer16BitAccess capability.
  * [[{anchor-prefix}features-uniformAndStorageBuffer16BitAccess]]
    pname:uniformAndStorageBuffer16BitAccess specifies whether objects in
    the code:Uniform storage class with the code:Block decoration can: have
    16-bit integer and 16-bit floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:UniformAndStorageBuffer16BitAccess capability.
  * [[{anchor-prefix}features-storagePushConstant16]]
    pname:storagePushConstant16 specifies whether objects in the
    code:PushConstant storage class can: have 16-bit integer and 16-bit
    floating-point members.
    If this feature is not enabled, 16-bit integer or floating-point members
    must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:StoragePushConstant16 capability.
  * [[{anchor-prefix}features-storageInputOutput16]]
    pname:storageInputOutput16 specifies whether objects in the code:Input
    and code:Output storage classes can: have 16-bit integer and 16-bit
    floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:StorageInputOutput16 capability.
// end::VK_KHR_16bit_storage-features[]

:refpage: VkPhysicalDevice16BitStorageFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevice16BitStorageFeatures.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_16bit_storage[]

ifdef::VK_VERSION_1_2,VK_KHR_shader_float16_int8[]
[open,refpage='VkPhysicalDeviceShaderFloat16Int8Features',desc='Structure describing features supported by VK_KHR_shader_float16_int8',type='structs',alias='VkPhysicalDeviceShaderFloat16Int8FeaturesKHR VkPhysicalDeviceFloat16Int8FeaturesKHR']
--
The sname:VkPhysicalDeviceShaderFloat16Int8Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderFloat16Int8Features.adoc[]

ifdef::VK_KHR_shader_float16_int8[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceShaderFloat16Int8FeaturesKHR.adoc[]

include::{generated}/api/structs/VkPhysicalDeviceFloat16Int8FeaturesKHR.adoc[]
endif::VK_KHR_shader_float16_int8[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_shader_float16_int8-features[]
  * [[{anchor-prefix}features-shaderFloat16]] pname:shaderFloat16 indicates
    whether 16-bit floats (halfs) are supported in shader code.
    This also indicates whether shader modules can: declare the code:Float16
    capability.
    However, this only enables a subset of the storage classes that SPIR-V
    allows for the code:Float16 SPIR-V capability: Declaring and using
    16-bit floats in the code:Private,
ifndef::VK_KHR_workgroup_memory_explicit_layout[]
    code:Workgroup,
endif::VK_KHR_workgroup_memory_explicit_layout[]
ifdef::VK_KHR_workgroup_memory_explicit_layout[]
    code:Workgroup (for non-Block variables),
endif::VK_KHR_workgroup_memory_explicit_layout[]
    and code:Function storage classes is enabled, while declaring them in
    the interface storage classes (e.g., code:UniformConstant, code:Uniform,
    code:StorageBuffer, code:Input, code:Output, and code:PushConstant) is
    not enabled.
  * [[{anchor-prefix}features-shaderInt8]] pname:shaderInt8 indicates
    whether 8-bit integers (signed and unsigned) are supported in shader
    code.
    This also indicates whether shader modules can: declare the code:Int8
    capability.
    However, this only enables a subset of the storage classes that SPIR-V
    allows for the code:Int8 SPIR-V capability: Declaring and using 8-bit
    integers in the code:Private,
ifndef::VK_KHR_workgroup_memory_explicit_layout[]
    code:Workgroup,
endif::VK_KHR_workgroup_memory_explicit_layout[]
ifdef::VK_KHR_workgroup_memory_explicit_layout[]
    code:Workgroup (for non-Block variables),
endif::VK_KHR_workgroup_memory_explicit_layout[]
    and code:Function storage classes is enabled, while declaring them in
    the interface storage classes (e.g., code:UniformConstant, code:Uniform,
    code:StorageBuffer, code:Input, code:Output, and code:PushConstant) is
    not enabled.
// end::VK_KHR_shader_float16_int8-features[]

:refpage: VkPhysicalDeviceShaderFloat16Int8Features
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderFloat16Int8Features.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_shader_float16_int8[]

ifdef::VK_KHR_shader_clock[]
[open,refpage='VkPhysicalDeviceShaderClockFeaturesKHR',desc='Structure describing features supported by VK_KHR_shader_clock',type='structs']
--
The slink:VkPhysicalDeviceShaderClockFeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderClockFeaturesKHR.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderSubgroupClock]] pname:shaderSubgroupClock indicates
    whether shaders can: perform code:Subgroup scoped clock reads.
  * [[features-shaderDeviceClock]] pname:shaderDeviceClock indicates whether
    shaders can: perform code:Device scoped clock reads.

:refpage: VkPhysicalDeviceShaderClockFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderClockFeaturesKHR.adoc[]
--
endif::VK_KHR_shader_clock[]

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
[open,refpage='VkPhysicalDeviceSamplerYcbcrConversionFeatures',desc='Structure describing {YCbCr} conversion features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR']
--
The sname:VkPhysicalDeviceSamplerYcbcrConversionFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceSamplerYcbcrConversionFeatures.adoc[]

ifdef::VK_KHR_sampler_ycbcr_conversion[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.adoc[]
endif::VK_KHR_sampler_ycbcr_conversion[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_sampler_ycbcr_conversion-features[]
  * [[{anchor-prefix}features-samplerYcbcrConversion]]
    pname:samplerYcbcrConversion specifies whether the implementation
    supports <<samplers-YCbCr-conversion,sampler {YCbCr} conversion>>.
    If pname:samplerYcbcrConversion is ename:VK_FALSE, sampler {YCbCr}
    conversion is not supported, and samplers using sampler {YCbCr}
    conversion must: not be used.
// end::VK_KHR_sampler_ycbcr_conversion-features[]

:refpage: VkPhysicalDeviceSamplerYcbcrConversionFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceSamplerYcbcrConversionFeatures.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

ifdef::VK_VERSION_1_1[]
[open,refpage='VkPhysicalDeviceProtectedMemoryFeatures',desc='Structure describing protected memory features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceProtectedMemoryFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceProtectedMemoryFeatures.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_protected_memory-features[]
  * [[{anchor-prefix}features-protectedMemory]] pname:protectedMemory
    specifies whether <<memory-protected-memory, protected memory>> is
    supported.
// end::VK_KHR_protected_memory-features[]

:refpage: VkPhysicalDeviceProtectedMemoryFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceProtectedMemoryFeatures.adoc[]
--
endif::VK_VERSION_1_1[]

ifdef::VK_EXT_blend_operation_advanced[]
[open,refpage='VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT',desc='Structure describing advanced blending features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-advancedBlendCoherentOperations]]
    pname:advancedBlendCoherentOperations specifies whether blending using
    <<framebuffer-blend-advanced,advanced blend operations>> is guaranteed
    to execute atomically and in <<drawing-primitive-order, primitive
    order>>.
    If this is ename:VK_TRUE,
    ename:VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT is treated the
    same as ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT, and advanced blending
    needs no additional synchronization over basic blending.
    If this is ename:VK_FALSE, then memory dependencies are required to
    guarantee order between two advanced blending operations that occur on
    the same sample.

:refpage: VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.adoc[]
--
endif::VK_EXT_blend_operation_advanced[]

ifdef::VK_EXT_conditional_rendering[]
[open,refpage='VkPhysicalDeviceConditionalRenderingFeaturesEXT',desc='Structure describing if a secondary command buffer can be executed if conditional rendering is active in the primary command buffer',type='structs']
--
The sname:VkPhysicalDeviceConditionalRenderingFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceConditionalRenderingFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-conditionalRendering]] pname:conditionalRendering specifies
    whether conditional rendering is supported.
  * [[features-inheritedConditionalRendering]]
    pname:inheritedConditionalRendering specifies whether a secondary
    command buffer can: be executed while conditional rendering is active in
    the primary command buffer.

:refpage: VkPhysicalDeviceConditionalRenderingFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceConditionalRenderingFeaturesEXT.adoc[]
--
endif::VK_EXT_conditional_rendering[]

ifdef::VK_VERSION_1_1[]
[open,refpage='VkPhysicalDeviceShaderDrawParametersFeatures',desc='Structure describing shader draw parameter features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceShaderDrawParameterFeatures']
--
The sname:VkPhysicalDeviceShaderDrawParametersFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderDrawParametersFeatures.adoc[]

ifndef::VKSC_VERSION_1_0[]
include::{generated}/api/structs/VkPhysicalDeviceShaderDrawParameterFeatures.adoc[]
endif::VKSC_VERSION_1_0[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_shader_draw_parameters-features[]
  * [[{anchor-prefix}features-shaderDrawParameters]]
    pname:shaderDrawParameters specifies whether the implementation supports
    the SPIR-V code:DrawParameters capability.
    When this feature is not enabled, shader modules must: not declare the
    `SPV_KHR_shader_draw_parameters` extension or the code:DrawParameters
    capability.
// end::VK_KHR_shader_draw_parameters-features[]

:refpage: VkPhysicalDeviceShaderDrawParametersFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderDrawParametersFeatures.adoc[]
--
endif::VK_VERSION_1_1[]

ifdef::VK_NV_mesh_shader[]
[open,refpage='VkPhysicalDeviceMeshShaderFeaturesNV',desc='Structure describing mesh shading features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMeshShaderFeaturesNV structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMeshShaderFeaturesNV.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
ifdef::VK_EXT_mesh_shader[]
  * pname:taskShader specifies whether task shaders are supported.
endif::VK_EXT_mesh_shader[]
ifndef::VK_EXT_mesh_shader[]
  * [[{vuprefix}features-taskShader]] pname:taskShader specifies whether
    task shaders are supported.
endif::VK_EXT_mesh_shader[]
    If this feature is not enabled, the ename:VK_SHADER_STAGE_TASK_BIT_NV
    and ename:VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV enum values must: not be
    used.
ifdef::VK_EXT_mesh_shader[]
  * pname:meshShader specifies whether mesh shaders are supported.
endif::VK_EXT_mesh_shader[]
ifndef::VK_EXT_mesh_shader[]
  * [[{vuprefix}features-meshShader]] pname:meshShader specifies whether
    mesh shaders are supported.
endif::VK_EXT_mesh_shader[]
    If this feature is not enabled, the ename:VK_SHADER_STAGE_MESH_BIT_NV
    and ename:VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV enum values must: not be
    used.

:refpage: VkPhysicalDeviceMeshShaderFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMeshShaderFeaturesNV.adoc[]
--
endif::VK_NV_mesh_shader[]

ifdef::VK_EXT_mesh_shader[]
[open,refpage='VkPhysicalDeviceMeshShaderFeaturesEXT',desc='Structure describing mesh shading features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMeshShaderFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMeshShaderFeaturesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-taskShader]] pname:taskShader specifies whether task shaders
    are supported.
    If this feature is not enabled, the ename:VK_SHADER_STAGE_TASK_BIT_EXT
    and ename:VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT enum values must: not be
    used.
  * [[features-meshShader]] pname:meshShader specifies whether mesh shaders
    are supported.
    If this feature is not enabled, the ename:VK_SHADER_STAGE_MESH_BIT_EXT
    and ename:VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT enum values must: not be
    used.
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[features-multiview-mesh]] pname:multiviewMeshShader specifies whether
    the implementation supports <<features-multiview, pname:multiview>>
    rendering within a render pass, with mesh shaders.
    If this feature is not enabled, then a pipeline compiled against a
    subpass with a non-zero view mask must: not include a mesh shader.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_KHR_fragment_shading_rate[]
  * [[features-primitiveFragmentShadingRate-mesh]]
    pname:primitiveFragmentShadingRateMeshShader indicates that the
    implementation supports the <<primsrast-fragment-shading-rate-primitive,
    primitive fragment shading rate>> in mesh shaders.
endif::VK_KHR_fragment_shading_rate[]
  * [[features-meshShaderQueries]] pname:meshShaderQueries indicates that
    the implementation supports creating query pools using the
    ename:VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT query type and
    statistic queries containing the
    ename:VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT and
    ename:VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT flags

:refpage: VkPhysicalDeviceMeshShaderFeaturesEXT
include::{chapters}/features.adoc[tag=features]

ifdef::VK_NV_mesh_shader[]
The corresponding features of the sname:VkPhysicalDeviceMeshShaderFeaturesNV
structure must: match those in sname:VkPhysicalDeviceMeshShaderFeaturesEXT.
endif::VK_NV_mesh_shader[]

.Valid Usage
****
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-VkPhysicalDeviceMeshShaderFeaturesEXT-multiviewMeshShader-07032]]
    If pname:multiviewMeshShader is enabled then
    sname:VkPhysicalDeviceMultiviewFeaturesKHR::pname:multiview must: also
    be enabled
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_KHR_fragment_shading_rate[]
  * [[VUID-VkPhysicalDeviceMeshShaderFeaturesEXT-primitiveFragmentShadingRateMeshShader-07033]]
    If pname:primitiveFragmentShadingRateMeshShader is enabled then
    sname:VkPhysicalDeviceFragmentShadingRateFeaturesKHR::pname:primitiveFragmentShadingRate
    must: also be enabled
endif::VK_KHR_fragment_shading_rate[]
****

include::{generated}/validity/structs/VkPhysicalDeviceMeshShaderFeaturesEXT.adoc[]
--
endif::VK_EXT_mesh_shader[]

ifdef::VK_NV_memory_decompression[]
[open,refpage='VkPhysicalDeviceMemoryDecompressionFeaturesNV',desc='Structure describing if memory decompression is supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMemoryDecompressionFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceMemoryDecompressionFeaturesNV.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-memoryDecompression]] pname:memoryDecompression indicates
    whether memory decompression is supported.

:refpage: VkPhysicalDeviceMemoryDecompressionFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMemoryDecompressionFeaturesNV.adoc[]
--
endif::VK_NV_memory_decompression[]

ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
[open,refpage='VkPhysicalDeviceDescriptorIndexingFeatures',desc='Structure describing descriptor indexing features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceDescriptorIndexingFeaturesEXT']
--
The sname:VkPhysicalDeviceDescriptorIndexingFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDescriptorIndexingFeatures.adoc[]

ifdef::VK_EXT_descriptor_indexing[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceDescriptorIndexingFeaturesEXT.adoc[]
endif::VK_EXT_descriptor_indexing[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_descriptor_indexing-features[]
  * [[{anchor-prefix}features-shaderInputAttachmentArrayDynamicIndexing]]
    pname:shaderInputAttachmentArrayDynamicIndexing indicates whether arrays
    of input attachments can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:InputAttachmentArrayDynamicIndexing capability.
  * [[{anchor-prefix}features-shaderUniformTexelBufferArrayDynamicIndexing]]
    pname:shaderUniformTexelBufferArrayDynamicIndexing indicates whether
    arrays of uniform texel buffers can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformTexelBufferArrayDynamicIndexing capability.
  * [[{anchor-prefix}features-shaderStorageTexelBufferArrayDynamicIndexing]]
    pname:shaderStorageTexelBufferArrayDynamicIndexing indicates whether
    arrays of storage texel buffers can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageTexelBufferArrayDynamicIndexing capability.
  * [[{anchor-prefix}features-shaderUniformBufferArrayNonUniformIndexing]]
    pname:shaderUniformBufferArrayNonUniformIndexing indicates whether
    arrays of uniform buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformBufferArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderSampledImageArrayNonUniformIndexing]]
    pname:shaderSampledImageArrayNonUniformIndexing indicates whether arrays
    of samplers or sampled images can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:SampledImageArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderStorageBufferArrayNonUniformIndexing]]
    pname:shaderStorageBufferArrayNonUniformIndexing indicates whether
    arrays of storage buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageBufferArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderStorageImageArrayNonUniformIndexing]]
    pname:shaderStorageImageArrayNonUniformIndexing indicates whether arrays
    of storage images can: be indexed by non-uniform integer expressions in
    shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageImageArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderInputAttachmentArrayNonUniformIndexing]]
    pname:shaderInputAttachmentArrayNonUniformIndexing indicates whether
    arrays of input attachments can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:InputAttachmentArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderUniformTexelBufferArrayNonUniformIndexing]]
    pname:shaderUniformTexelBufferArrayNonUniformIndexing indicates whether
    arrays of uniform texel buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformTexelBufferArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderStorageTexelBufferArrayNonUniformIndexing]]
    pname:shaderStorageTexelBufferArrayNonUniformIndexing indicates whether
    arrays of storage texel buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageTexelBufferArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-descriptorBindingUniformBufferUpdateAfterBind]]
    pname:descriptorBindingUniformBufferUpdateAfterBind indicates whether
    the implementation supports updating uniform buffer descriptors after a
    set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER.
  * [[{anchor-prefix}features-descriptorBindingSampledImageUpdateAfterBind]]
    pname:descriptorBindingSampledImageUpdateAfterBind indicates whether the
    implementation supports updating sampled image descriptors after a set
    is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE.
  * [[{anchor-prefix}features-descriptorBindingStorageImageUpdateAfterBind]]
    pname:descriptorBindingStorageImageUpdateAfterBind indicates whether the
    implementation supports updating storage image descriptors after a set
    is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.
  * [[{anchor-prefix}features-descriptorBindingStorageBufferUpdateAfterBind]]
    pname:descriptorBindingStorageBufferUpdateAfterBind indicates whether
    the implementation supports updating storage buffer descriptors after a
    set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER.
  * [[{anchor-prefix}features-descriptorBindingUniformTexelBufferUpdateAfterBind]]
    pname:descriptorBindingUniformTexelBufferUpdateAfterBind indicates
    whether the implementation supports updating uniform texel buffer
    descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.
  * [[{anchor-prefix}features-descriptorBindingStorageTexelBufferUpdateAfterBind]]
    pname:descriptorBindingStorageTexelBufferUpdateAfterBind indicates
    whether the implementation supports updating storage texel buffer
    descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.
  * [[{anchor-prefix}features-descriptorBindingUpdateUnusedWhilePending]]
    pname:descriptorBindingUpdateUnusedWhilePending indicates whether the
    implementation supports updating descriptors while the set is in use.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT must: not be
    used.
  * [[{anchor-prefix}features-descriptorBindingPartiallyBound]]
    pname:descriptorBindingPartiallyBound indicates whether the
    implementation supports statically using a descriptor set binding in
    which some descriptors are not valid.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT must: not be used.
  * [[{anchor-prefix}features-descriptorBindingVariableDescriptorCount]]
    pname:descriptorBindingVariableDescriptorCount indicates whether the
    implementation supports descriptor sets with a variable-sized last
    binding.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT must: not be
    used.
  * [[{anchor-prefix}features-runtimeDescriptorArray]]
    pname:runtimeDescriptorArray indicates whether the implementation
    supports the SPIR-V code:RuntimeDescriptorArray capability.
    If this feature is not enabled, descriptors must: not be declared in
    runtime arrays.
// end::VK_EXT_descriptor_indexing-features[]

:refpage: VkPhysicalDeviceDescriptorIndexingFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDescriptorIndexingFeatures.adoc[]
--
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]

ifdef::VK_NV_copy_memory_indirect[]
[open,refpage='VkPhysicalDeviceCopyMemoryIndirectFeaturesNV',desc='Structure describing indirect copy features supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCopyMemoryIndirectFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCopyMemoryIndirectFeaturesNV.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-indirectCopy]] pname:indirectCopy indicates whether
    <<indirect-copies, indirect copies>> are supported.

:refpage: VkPhysicalDeviceCopyMemoryIndirectFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCopyMemoryIndirectFeaturesNV.adoc[]
--
endif::VK_NV_copy_memory_indirect[]

ifdef::VK_KHR_vertex_attribute_divisor,VK_EXT_vertex_attribute_divisor[]
[open,refpage='VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR',desc='Structure describing if fetching of vertex attribute may be repeated for instanced rendering',type='structs',alias='VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT']
--
The sname:VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR.adoc[]

ifdef::VK_EXT_vertex_attribute_divisor[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.adoc[]
endif::VK_EXT_vertex_attribute_divisor[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-vertexAttributeInstanceRateDivisor]]
    pname:vertexAttributeInstanceRateDivisor specifies whether vertex
    attribute fetching may be repeated in the case of instanced rendering.
  * [[features-vertexAttributeInstanceRateZeroDivisor]]
    pname:vertexAttributeInstanceRateZeroDivisor specifies whether a zero
    value for slink:VkVertexInputBindingDivisorDescriptionEXT::pname:divisor
    is supported.

:refpage: VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR.adoc[]
--
endif::VK_KHR_vertex_attribute_divisor,VK_EXT_vertex_attribute_divisor[]

ifdef::VK_EXT_astc_decode_mode[]
[open,refpage='VkPhysicalDeviceASTCDecodeFeaturesEXT',desc='Structure describing ASTC decode mode features',type='structs']
--
The sname:VkPhysicalDeviceASTCDecodeFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceASTCDecodeFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-astc-decodeModeSharedExponent]]
    pname:decodeModeSharedExponent indicates whether the implementation
    supports decoding ASTC compressed formats to
    ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 internal precision.

:refpage: VkPhysicalDeviceASTCDecodeFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceASTCDecodeFeaturesEXT.adoc[]
--
endif::VK_EXT_astc_decode_mode[]

ifdef::VK_EXT_transform_feedback[]
[open,refpage='VkPhysicalDeviceTransformFeedbackFeaturesEXT',desc='Structure describing transform feedback features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceTransformFeedbackFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-transformFeedback]] pname:transformFeedback indicates whether
    the implementation supports transform feedback and shader modules can:
    declare the code:TransformFeedback capability.
  * [[features-geometryStreams]] pname:geometryStreams indicates whether the
    implementation supports the code:GeometryStreams SPIR-V capability.

:refpage: VkPhysicalDeviceTransformFeedbackFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceTransformFeedbackFeaturesEXT.adoc[]
--
endif::VK_EXT_transform_feedback[]

ifdef::VK_VERSION_1_2,VK_KHR_vulkan_memory_model[]
[open,refpage='VkPhysicalDeviceVulkanMemoryModelFeatures',desc='Structure describing features supported by the memory model',type='structs']
--
The sname:VkPhysicalDeviceVulkanMemoryModelFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVulkanMemoryModelFeatures.adoc[]

ifdef::VK_KHR_vulkan_memory_model[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.adoc[]
endif::VK_KHR_vulkan_memory_model[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_vulkan_memory_model-features[]
  * [[{anchor-prefix}features-vulkanMemoryModel]] pname:vulkanMemoryModel
    indicates whether shader modules can: declare the code:VulkanMemoryModel
    capability.
  * [[{anchor-prefix}features-vulkanMemoryModelDeviceScope]]
    pname:vulkanMemoryModelDeviceScope indicates whether the Vulkan Memory
    Model can use code:Device scope synchronization.
    This also indicates whether shader modules can: declare the
    code:VulkanMemoryModelDeviceScope capability.
  * [[{anchor-prefix}features-vulkanMemoryModelAvailabilityVisibilityChains]]
    pname:vulkanMemoryModelAvailabilityVisibilityChains indicates whether
    the Vulkan Memory Model can use <<memory-model-availability-visibility,
    availability and visibility chains>> with more than one element.
// end::VK_KHR_vulkan_memory_model-features[]

:refpage: VkPhysicalDeviceVulkanMemoryModelFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceVulkanMemoryModelFeatures.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_vulkan_memory_model[]

ifdef::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]
[open,refpage='VkPhysicalDeviceInlineUniformBlockFeatures',desc='Structure describing inline uniform block features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceInlineUniformBlockFeaturesEXT']
--
The sname:VkPhysicalDeviceInlineUniformBlockFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceInlineUniformBlockFeatures.adoc[]

ifdef::VK_EXT_inline_uniform_block[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceInlineUniformBlockFeaturesEXT.adoc[]
endif::VK_EXT_inline_uniform_block[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_EXT_inline_uniform_block-features[]
  * [[{anchor-prefix}features-inlineUniformBlock]] pname:inlineUniformBlock
    indicates whether the implementation supports inline uniform block
    descriptors.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK must: not be used.
  * [[{anchor-prefix}features-descriptorBindingInlineUniformBlockUpdateAfterBind]]
    pname:descriptorBindingInlineUniformBlockUpdateAfterBind
ifndef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    is ename:VK_FALSE and reserved for future use.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    indicates whether the implementation supports updating inline uniform
    block descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
// end::VK_EXT_inline_uniform_block-features[]

:refpage: VkPhysicalDeviceInlineUniformBlockFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceInlineUniformBlockFeatures.adoc[]
--
endif::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]

ifdef::VK_NV_representative_fragment_test[]
[open,refpage='VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV',desc='Structure describing the representative fragment test features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-representativeFragmentTest]] pname:representativeFragmentTest
    indicates whether the implementation supports the representative
    fragment test.
    See <<fragops-rep-frag-test, Representative Fragment Test>>.

:refpage: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.adoc[]
--
endif::VK_NV_representative_fragment_test[]

ifdef::VK_NV_scissor_exclusive[]
[open,refpage='VkPhysicalDeviceExclusiveScissorFeaturesNV',desc='Structure describing exclusive scissor features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceExclusiveScissorFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceExclusiveScissorFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-exclusiveScissor]] pname:exclusiveScissor indicates that the
    implementation supports the exclusive scissor test.

See <<fragops-exclusive-scissor,Exclusive Scissor Test>> for more
information.

:refpage: VkPhysicalDeviceExclusiveScissorFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExclusiveScissorFeaturesNV.adoc[]
--
endif::VK_NV_scissor_exclusive[]

ifdef::VK_NV_corner_sampled_image[]
[open,refpage='VkPhysicalDeviceCornerSampledImageFeaturesNV',desc='Structure describing corner sampled image features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCornerSampledImageFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCornerSampledImageFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-cornersampledimage]] pname:cornerSampledImage specifies
    whether images can be created with a
    slink:VkImageCreateInfo::pname:flags containing
    ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV.
    See <<resources-images-corner-sampled,Corner-Sampled Images>>.

:refpage: VkPhysicalDeviceCornerSampledImageFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCornerSampledImageFeaturesNV.adoc[]
--
endif::VK_NV_corner_sampled_image[]

ifdef::VK_NV_compute_shader_derivatives[]
[open,refpage='VkPhysicalDeviceComputeShaderDerivativesFeaturesNV',desc='Structure describing compute shader derivative features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceComputeShaderDerivativesFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-computeDerivativeGroupQuads]]
    pname:computeDerivativeGroupQuads indicates that the implementation
    supports the code:ComputeDerivativeGroupQuadsNV SPIR-V capability.
  * [[features-computeDerivativeGroupLinear]]
    pname:computeDerivativeGroupLinear indicates that the implementation
    supports the code:ComputeDerivativeGroupLinearNV SPIR-V capability.

See <<shaders-scope-quad, Quad shader scope>> for more information.

:refpage: VkPhysicalDeviceComputeShaderDerivativesFeaturesNVfeatures.
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.adoc[]
--
endif::VK_NV_compute_shader_derivatives[]

ifdef::VK_KHR_fragment_shader_barycentric[]
[open,refpage='VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR',desc='Structure describing barycentric support in fragment shaders that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.adoc[]

ifdef::VK_NV_fragment_shader_barycentric[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.adoc[]
endif::VK_NV_fragment_shader_barycentric[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-fragmentShaderBarycentric]] pname:fragmentShaderBarycentric
    indicates that the implementation supports the code:BaryCoordKHR and
    code:BaryCoordNoPerspKHR SPIR-V fragment shader built-ins and supports
    the code:PerVertexKHR SPIR-V decoration on fragment shader input
    variables.

See <<primsrast-barycentric,Barycentric Interpolation>> for more
information.

:refpage: VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.adoc[]
--
endif::VK_KHR_fragment_shader_barycentric[]

ifdef::VK_NV_shader_image_footprint[]
[open,refpage='VkPhysicalDeviceShaderImageFootprintFeaturesNV',desc='Structure describing shader image footprint features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderImageFootprintFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderImageFootprintFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-imageFootprint]] pname:imageFootprint specifies whether the
    implementation supports the code:ImageFootprintNV SPIR-V capability.

See <<textures-footprint,Texel Footprint Evaluation>> for more information.

:refpage: VkPhysicalDeviceShaderImageFootprintFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderImageFootprintFeaturesNV.adoc[]
--
endif::VK_NV_shader_image_footprint[]

ifdef::VK_NV_shading_rate_image[]
[open,refpage='VkPhysicalDeviceShadingRateImageFeaturesNV',desc='Structure describing shading rate image features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShadingRateImageFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShadingRateImageFeaturesNV.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shadingRateImage]] pname:shadingRateImage indicates that the
    implementation supports the use of a shading rate image to derive an
    effective shading rate for fragment processing.
    It also indicates that the implementation supports the
    code:ShadingRateNV SPIR-V execution mode.
  * [[features-shadingRateCoarseSampleOrder]]
    pname:shadingRateCoarseSampleOrder indicates that the implementation
    supports a user-configurable ordering of coverage samples in fragments
    larger than one pixel.

See <<primsrast-shading-rate-image, Shading Rate Image>> for more
information.

:refpage: VkPhysicalDeviceShadingRateImageFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShadingRateImageFeaturesNV.adoc[]
--
endif::VK_NV_shading_rate_image[]

ifdef::VK_EXT_fragment_density_map[]
[open,refpage='VkPhysicalDeviceFragmentDensityMapFeaturesEXT',desc='Structure describing fragment density map features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-fragmentDensityMap]] pname:fragmentDensityMap specifies
    whether the implementation supports render passes with a fragment
    density map attachment.
    If this feature is not enabled and the pname:pNext chain of
    slink:VkRenderPassCreateInfo includes a
    slink:VkRenderPassFragmentDensityMapCreateInfoEXT structure,
    pname:fragmentDensityMapAttachment must: be ename:VK_ATTACHMENT_UNUSED.
  * [[features-fragmentDensityMapDynamic]] pname:fragmentDensityMapDynamic
    specifies whether the implementation supports dynamic fragment density
    map image views.
    If this feature is not enabled,
    ename:VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT must:
    not be included in slink:VkImageViewCreateInfo::pname:flags.
  * [[features-fragmentDensityMapNonSubsampledImages]]
    pname:fragmentDensityMapNonSubsampledImages specifies whether the
    implementation supports regular non-subsampled image attachments with
    fragment density map render passes.
    If this feature is not enabled, render passes with a
    <<renderpass-fragmentdensitymapattachment,fragment density map
    attachment>> must: only have <<samplers-subsamplesampler,subsampled
    attachments>> bound.

:refpage: VkPhysicalDeviceFragmentDensityMapFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.adoc[]
--

ifdef::VK_EXT_fragment_density_map2[]
[open,refpage='VkPhysicalDeviceFragmentDensityMap2FeaturesEXT',desc='Structure describing additional fragment density map features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentDensityMap2FeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-fragmentDensityMapDeferred]] pname:fragmentDensityMapDeferred
    specifies whether the implementation supports deferred reads of fragment
    density map image views.
    If this feature is not enabled,
    ename:VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT must:
    not be included in sname:VkImageViewCreateInfo::pname:flags.

:refpage: VkPhysicalDeviceFragmentDensityMap2FeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.adoc[]
--
endif::VK_EXT_fragment_density_map2[]

ifdef::VK_QCOM_fragment_density_map_offset[]
[open,refpage='VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM',desc='Structure describing fragment density map offset features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-fragmentDensityMapOffsets]] pname:fragmentDensityMapOffsets
    specifies whether the implementation supports
    <<renderpass-fragmentdensitymapoffsets,fragment density map offsets>>

:refpage: VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM.adoc[]
--
endif::VK_QCOM_fragment_density_map_offset[]
endif::VK_EXT_fragment_density_map[]

ifdef::VK_HUAWEI_invocation_mask[]
[open,refpage='VkPhysicalDeviceInvocationMaskFeaturesHUAWEI',desc='Structure describing invocation mask features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceInvocationMaskFeaturesHUAWEI structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-invocationMask]] pname:invocationMask indicates that the
    implementation supports the use of an invocation mask image to optimize
    the ray dispatch.

:refpage: VkPhysicalDeviceInvocationMaskFeaturesHUAWEI
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.adoc[]
--
endif::VK_HUAWEI_invocation_mask[]

ifdef::VK_VERSION_1_2,VK_EXT_scalar_block_layout[]
[open,refpage='VkPhysicalDeviceScalarBlockLayoutFeatures',desc='Structure indicating support for scalar block layouts',type='structs',alias='VkPhysicalDeviceScalarBlockLayoutFeaturesEXT']
--
The sname:VkPhysicalDeviceScalarBlockLayoutFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceScalarBlockLayoutFeatures.adoc[]

ifdef::VK_EXT_scalar_block_layout[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.adoc[]
endif::VK_EXT_scalar_block_layout[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_scalar_block_layout-features[]
  * [[{anchor-prefix}features-scalarBlockLayout]] pname:scalarBlockLayout
    indicates that the implementation supports the layout of resource blocks
    in shaders using <<interfaces-alignment-requirements, scalar
    alignment>>.
// end::VK_EXT_scalar_block_layout-features[]

:refpage: VkPhysicalDeviceScalarBlockLayoutFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceScalarBlockLayoutFeatures.adoc[]
--
endif::VK_VERSION_1_2,VK_EXT_scalar_block_layout[]

ifdef::VK_VERSION_1_2,VK_KHR_uniform_buffer_standard_layout[]
[open,refpage='VkPhysicalDeviceUniformBufferStandardLayoutFeatures',desc='Structure indicating support for std430-like packing in uniform buffers',type='structs',alias='VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR']
--
The sname:VkPhysicalDeviceUniformBufferStandardLayoutFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceUniformBufferStandardLayoutFeatures.adoc[]

ifdef::VK_KHR_uniform_buffer_standard_layout[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.adoc[]
endif::VK_KHR_uniform_buffer_standard_layout[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_uniform_buffer_standard_layout-features[]
  * [[{anchor-prefix}features-uniformBufferStandardLayout]]
    pname:uniformBufferStandardLayout indicates that the implementation
    supports the same layouts for uniform buffers as for storage and other
    kinds of buffers.
    See <<interfaces-resources-standard-layout,Standard Buffer Layout>>.
// end::VK_KHR_uniform_buffer_standard_layout-features[]

:refpage: VkPhysicalDeviceUniformBufferStandardLayoutFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceUniformBufferStandardLayoutFeatures.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_uniform_buffer_standard_layout[]

ifdef::VK_EXT_depth_clip_enable[]
[open,refpage='VkPhysicalDeviceDepthClipEnableFeaturesEXT',desc='Structure indicating support for explicit enable of depth clip',type='structs']
--
The sname:VkPhysicalDeviceDepthClipEnableFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDepthClipEnableFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-depthClipEnable]] pname:depthClipEnable indicates that the
    implementation supports setting the depth clipping operation explicitly
    via the slink:VkPipelineRasterizationDepthClipStateCreateInfoEXT
    pipeline state.
    Otherwise depth clipping is only enabled when
    slink:VkPipelineRasterizationStateCreateInfo::pname:depthClampEnable is
    set to ename:VK_FALSE.

:refpage: VkPhysicalDeviceDepthClipEnableFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDepthClipEnableFeaturesEXT.adoc[]
--
endif::VK_EXT_depth_clip_enable[]

ifdef::VK_EXT_memory_priority[]
[open,refpage='VkPhysicalDeviceMemoryPriorityFeaturesEXT',desc='Structure describing memory priority features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMemoryPriorityFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMemoryPriorityFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-memoryPriority]] pname:memoryPriority indicates that the
    implementation supports memory priorities specified at memory allocation
    time via slink:VkMemoryPriorityAllocateInfoEXT.

:refpage: VkPhysicalDeviceMemoryPriorityFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMemoryPriorityFeaturesEXT.adoc[]
--
endif::VK_EXT_memory_priority[]

ifdef::VK_VERSION_1_2,VK_KHR_buffer_device_address[]
[open,refpage='VkPhysicalDeviceBufferDeviceAddressFeatures',desc='Structure describing buffer address features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceBufferDeviceAddressFeaturesKHR']
--
The sname:VkPhysicalDeviceBufferDeviceAddressFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceBufferDeviceAddressFeatures.adoc[]

ifdef::VK_KHR_buffer_device_address[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceBufferDeviceAddressFeaturesKHR.adoc[]
endif::VK_KHR_buffer_device_address[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_buffer_device_address-features[]
  * [[{anchor-prefix}features-bufferDeviceAddress]]
    pname:bufferDeviceAddress indicates that the implementation supports
    accessing buffer memory in shaders as storage buffers via an address
    queried from flink:vkGetBufferDeviceAddress.
  * [[{anchor-prefix}features-bufferDeviceAddressCaptureReplay]]
    pname:bufferDeviceAddressCaptureReplay indicates that the implementation
    supports saving and reusing buffer and device addresses, e.g. for trace
    capture and replay.
  * [[{anchor-prefix}features-bufferDeviceAddressMultiDevice]]
    pname:bufferDeviceAddressMultiDevice indicates that the implementation
    supports the pname:bufferDeviceAddress
ifndef::VK_KHR_ray_tracing_pipeline+VK_KHR_ray_query[feature]
ifdef::VK_KHR_ray_tracing_pipeline[]
ifndef::VK_KHR_ray_query[]
    and pname:rayTracingPipeline features
endif::VK_KHR_ray_query[]
ifdef::VK_KHR_ray_query[]
    , pname:rayTracingPipeline and pname:rayQuery features
endif::VK_KHR_ray_query[]
endif::VK_KHR_ray_tracing_pipeline[]
ifndef::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_KHR_ray_query[]
    and pname:rayQuery features
endif::VK_KHR_ray_query[]
endif::VK_KHR_ray_tracing_pipeline[]
    for logical devices created with multiple physical devices.
    If this feature is not supported, buffer
ifdef::VK_KHR_acceleration_structure[]
    and acceleration structure
endif::VK_KHR_acceleration_structure[]
    addresses must: not be queried on a logical device created with more
    than one physical device.
// end::VK_EXT_buffer_device_address-features[]

[NOTE]
.Note
====
pname:bufferDeviceAddressMultiDevice exists to allow certain legacy
platforms to be able to support pname:bufferDeviceAddress without needing to
support shared GPU virtual addresses for multi-device configurations.
====

See flink:vkGetBufferDeviceAddress for more information.

:refpage: VkPhysicalDeviceBufferDeviceAddressFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceBufferDeviceAddressFeatures.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_buffer_device_address[]

ifdef::VK_EXT_buffer_device_address[]
[open,refpage='VkPhysicalDeviceBufferDeviceAddressFeaturesEXT',desc='Structure describing buffer address features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceBufferAddressFeaturesEXT']
--
The sname:VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.adoc[]

include::{generated}/api/structs/VkPhysicalDeviceBufferAddressFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-bufferDeviceAddressEXT]] pname:bufferDeviceAddress indicates
    that the implementation supports accessing buffer memory in shaders as
    storage buffers via an address queried from
    flink:vkGetBufferDeviceAddressEXT.
  * [[features-bufferDeviceAddressCaptureReplayEXT]]
    pname:bufferDeviceAddressCaptureReplay indicates that the implementation
    supports saving and reusing buffer addresses, e.g. for trace capture and
    replay.
  * [[features-bufferDeviceAddressMultiDeviceEXT]]
    pname:bufferDeviceAddressMultiDevice indicates that the implementation
    supports the pname:bufferDeviceAddress feature for logical devices
    created with multiple physical devices.
    If this feature is not supported, buffer addresses must: not be queried
    on a logical device created with more than one physical device.

:refpage: VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
include::{chapters}/features.adoc[tag=features]

ifdef::VK_VERSION_1_2,VK_KHR_buffer_device_address[]
[NOTE]
.Note
====
The sname:VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure has the
same members as the sname:VkPhysicalDeviceBufferDeviceAddressFeatures
structure, but the functionality indicated by the members is expressed
differently.
The features indicated by the
sname:VkPhysicalDeviceBufferDeviceAddressFeatures structure requires
additional flags to be passed at memory allocation time, and the capture and
replay mechanism is built around opaque capture addresses for buffer and
memory objects.
====
endif::VK_VERSION_1_2,VK_KHR_buffer_device_address[]

include::{generated}/validity/structs/VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.adoc[]
--
endif::VK_EXT_buffer_device_address[]

ifdef::VK_NV_dedicated_allocation_image_aliasing[]
[open,refpage='VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV',desc='Structure describing dedicated allocation image aliasing features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-dedicatedAllocationImageAliasing]]
    pname:dedicatedAllocationImageAliasing indicates that the implementation
    supports aliasing of compatible image objects on a dedicated allocation.

:refpage: VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.adoc[]
--
endif::VK_NV_dedicated_allocation_image_aliasing[]

ifdef::VK_VERSION_1_2,VK_KHR_imageless_framebuffer[]
[open,refpage='VkPhysicalDeviceImagelessFramebufferFeatures',desc='Structure indicating support for imageless framebuffers',type='structs',alias='VkPhysicalDeviceImagelessFramebufferFeaturesKHR']
--
The sname:VkPhysicalDeviceImagelessFramebufferFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceImagelessFramebufferFeatures.adoc[]

ifdef::VK_KHR_imageless_framebuffer[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceImagelessFramebufferFeaturesKHR.adoc[]
endif::VK_KHR_imageless_framebuffer[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_imageless_framebuffer-features[]
  * [[{anchor-prefix}features-imagelessFramebuffer]]
    pname:imagelessFramebuffer indicates that the implementation supports
    specifying the image view for attachments at render pass begin time via
    slink:VkRenderPassAttachmentBeginInfo.
// end::VK_KHR_imageless_framebuffer-features[]

:refpage: VkPhysicalDeviceImagelessFramebufferFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceImagelessFramebufferFeatures.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_imageless_framebuffer[]

ifdef::VK_EXT_fragment_shader_interlock[]
[open,refpage='VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT',desc='Structure describing fragment shader interlock features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-fragmentShaderSampleInterlock]]
    pname:fragmentShaderSampleInterlock indicates that the implementation
    supports the code:FragmentShaderSampleInterlockEXT SPIR-V capability.
  * [[features-fragmentShaderPixelInterlock]]
    pname:fragmentShaderPixelInterlock indicates that the implementation
    supports the code:FragmentShaderPixelInterlockEXT SPIR-V capability.
  * [[features-fragmentShaderShadingRateInterlock]]
    pname:fragmentShaderShadingRateInterlock indicates that the
    implementation supports the code:FragmentShaderShadingRateInterlockEXT
    SPIR-V capability.

:refpage: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.adoc[]
--
endif::VK_EXT_fragment_shader_interlock[]

ifdef::VK_NV_cooperative_matrix[]
[open,refpage='VkPhysicalDeviceCooperativeMatrixFeaturesNV',desc='Structure describing cooperative matrix features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCooperativeMatrixFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCooperativeMatrixFeaturesNV.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-cooperativeMatrix-NV]] pname:cooperativeMatrix indicates that
    the implementation supports the code:CooperativeMatrixNV SPIR-V
    capability.
  * [[features-cooperativeMatrixRobustBufferAccess-NV]]
    pname:cooperativeMatrixRobustBufferAccess indicates that the
    implementation supports robust buffer access for SPIR-V
    code:OpCooperativeMatrixLoadNV and code:OpCooperativeMatrixStoreNV
    instructions.

:refpage: VkPhysicalDeviceCooperativeMatrixFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCooperativeMatrixFeaturesNV.adoc[]
--
endif::VK_NV_cooperative_matrix[]

ifdef::VK_KHR_cooperative_matrix[]
[open,refpage='VkPhysicalDeviceCooperativeMatrixFeaturesKHR',desc='Structure describing cooperative matrix features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCooperativeMatrixFeaturesKHR structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCooperativeMatrixFeaturesKHR.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-cooperativeMatrix]] pname:cooperativeMatrix indicates that
    the implementation supports the code:CooperativeMatrixKHR SPIR-V
    capability.
  * [[features-cooperativeMatrixRobustBufferAccess]]
    pname:cooperativeMatrixRobustBufferAccess indicates that the
    implementation supports robust buffer access for SPIR-V
    code:OpCooperativeMatrixLoadKHR and code:OpCooperativeMatrixStoreKHR
    instructions.

:refpage: VkPhysicalDeviceCooperativeMatrixFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCooperativeMatrixFeaturesKHR.adoc[]
--
endif::VK_KHR_cooperative_matrix[]

ifdef::VK_EXT_ycbcr_image_arrays[]
[open,refpage='VkPhysicalDeviceYcbcrImageArraysFeaturesEXT',desc='Structure describing extended {YCbCr} image creation features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-ycbcrImageArrays]] pname:ycbcrImageArrays indicates that the
    implementation supports creating images with a format that requires
    <<formats-requiring-sampler-ycbcr-conversion, {YCbCr} conversion>> and
    has multiple array layers.

:refpage: VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.adoc[]
--
endif::VK_EXT_ycbcr_image_arrays[]

ifdef::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]
[open,refpage='VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures',desc='Structure describing the extended types subgroups support feature for an implementation',type='structs',alias='VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR']
--
The sname:VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.adoc[]

ifdef::VK_KHR_shader_subgroup_extended_types[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR.adoc[]
endif::VK_KHR_shader_subgroup_extended_types[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_shader_subgroup_extended_types-features[]
  * [[{anchor-prefix}features-subgroup-extended-types]]
    pname:shaderSubgroupExtendedTypes is a boolean specifying whether
    subgroup operations can use 8-bit integer, 16-bit integer, 64-bit
    integer, 16-bit floating-point, and vectors of these types in
    <<shaders-group-operations,group operations>> with
    <<shaders-scope-subgroup, subgroup scope>>, if the implementation
    supports the types.
// end::VK_KHR_shader_subgroup_extended_types-features[]

:refpage: VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_2,VK_EXT_host_query_reset[]
[open,refpage='VkPhysicalDeviceHostQueryResetFeatures',desc='Structure describing whether queries can be reset from the host',type='structs',alias='VkPhysicalDeviceHostQueryResetFeaturesEXT']
--
The sname:VkPhysicalDeviceHostQueryResetFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceHostQueryResetFeatures.adoc[]

ifdef::VK_EXT_host_query_reset[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceHostQueryResetFeaturesEXT.adoc[]
endif::VK_EXT_host_query_reset[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_host_query_reset-features[]
  * [[{anchor-prefix}features-hostQueryReset]] pname:hostQueryReset
    indicates that the implementation supports resetting queries from the
    host with flink:vkResetQueryPool.
// end::VK_EXT_host_query_reset-features[]

:refpage: VkPhysicalDeviceHostQueryResetFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceHostQueryResetFeatures.adoc[]
--
endif::VK_VERSION_1_2,VK_EXT_host_query_reset[]

ifdef::VK_INTEL_shader_integer_functions2[]
[open,refpage='VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL',desc='Structure describing shader integer functions that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderIntegerFunctions2]] pname:shaderIntegerFunctions2
    indicates that the implementation supports the
    code:IntegerFunctions2INTEL SPIR-V capability.

:refpage: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELfeatures.
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.adoc[]
--
endif::VK_INTEL_shader_integer_functions2[]

ifdef::VK_NV_coverage_reduction_mode[]
[open,refpage='VkPhysicalDeviceCoverageReductionModeFeaturesNV',desc='Structure describing the coverage reduction mode features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCoverageReductionModeFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceCoverageReductionModeFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-coverageReductionMode]] pname:coverageReductionMode indicates
    whether the implementation supports coverage reduction modes.
    See <<fragops-coverage-reduction, Coverage Reduction>>.

:refpage: VkPhysicalDeviceCoverageReductionModeFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCoverageReductionModeFeaturesNV.adoc[]
--
endif::VK_NV_coverage_reduction_mode[]

ifdef::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]
[open,refpage='VkPhysicalDeviceTimelineSemaphoreFeatures',desc='Structure describing timeline semaphore features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceTimelineSemaphoreFeaturesKHR']
--
The sname:VkPhysicalDeviceTimelineSemaphoreFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceTimelineSemaphoreFeatures.adoc[]

ifdef::VK_KHR_timeline_semaphore[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceTimelineSemaphoreFeaturesKHR.adoc[]
endif::VK_KHR_timeline_semaphore[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_timeline_semaphore-features[]
  * [[{anchor-prefix}features-timelineSemaphore]] pname:timelineSemaphore
    indicates whether semaphores created with a elink:VkSemaphoreType of
    ename:VK_SEMAPHORE_TYPE_TIMELINE are supported.
// end::VK_KHR_timeline_semaphore-features[]

:refpage: VkPhysicalDeviceTimelineSemaphoreFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceTimelineSemaphoreFeatures.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]

ifdef::VK_NV_external_sci_sync[]
[open,refpage='VkPhysicalDeviceExternalSciSyncFeaturesNV',desc='Structure describing SciSync features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceExternalSciSyncFeaturesNV structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceExternalSciSyncFeaturesNV.adoc[]

The members of the sname:VkPhysicalDeviceExternalSciSyncFeaturesNV structure
describe the following features:

  * [[features-sciSyncFence]] pname:sciSyncFence indicates whether external
    fences created with a handle type of
    ename:VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV and
    ename:VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV are supported
    for import and/or export.
  * [[features-sciSyncSemaphore]] pname:sciSyncSemaphore indicates whether
    external semaphores created with a handle type of
    ename:VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV are
    supported for import and/or export.
  * [[features-sciSyncImport]] pname:sciSyncImport indicates whether
    stext:NvSciSyncObj import functionality is supported.
    If pname:sciSyncImport is set to ename:VK_TRUE, slink:VkFence and/or
    slink:VkSemaphore support importing stext:NvSciSyncObj from
    applications.
    In this case, the application is responsible for the resource management
    of the stext:NvSciSyncObj.
  * [[features-sciSyncExport]] pname:sciSyncExport indicates whether
    stext:NvSciSyncObj export functionality is supported.
    If pname:sciSyncExport is set to ename:VK_TRUE, slink:VkFence and/or
    slink:VkSemaphore support exporting stext:NvSciSyncObj created by the
    driver to applications.
    In this case, the driver is responsible for the resource management of
    the stext:NvSciSyncObj.

[[features-externalscisync-table]]
.Functionality supported for NvSciSync features
|=====
| Features           | pname:sciSyncImport | pname:sciSyncExport | Always supported^1^
| pname:sciSyncFence
  | flink:vkImportFenceSciSyncFenceNV, flink:vkImportFenceSciSyncObjNV
  | slink:VkExportFenceSciSyncInfoNV
  | flink:vkGetFenceSciSyncFenceNV, flink:vkGetFenceSciSyncObjNV, flink:vkGetPhysicalDeviceSciSyncAttributesNV (with ename:VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV)
| pname:sciSyncSemaphore
  | flink:vkImportSemaphoreSciSyncObjNV
  | slink:VkExportSemaphoreSciSyncInfoNV
  | flink:vkGetSemaphoreSciSyncObjNV, flink:vkGetPhysicalDeviceSciSyncAttributesNV (with ename:VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV)
|=====

1::
    Functionality in this column is always available.

The <<features-externalscisync-table, Functionality supported for NvSciSync
features>> table summarizes the functionality enabled by the
sname:VkPhysicalDeviceExternalSciSyncFeaturesNV structure.
There are two orthogonal pieces of functionality: fence and semaphore
support; import and export support.
Each entry in the body of the table summarizes the functionality that can:
be used when the given features are supported and enabled.
This summarizes Valid Usage statements that are added elsewhere in this
specification.

:refpage: VkPhysicalDeviceExternalSciSyncFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExternalSciSyncFeaturesNV.adoc[]
--
endif::VK_NV_external_sci_sync[]

ifdef::VK_NV_external_sci_sync2[]
[open,refpage='VkPhysicalDeviceExternalSciSync2FeaturesNV',desc='Structure describing SciSync features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceExternalSciSync2FeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceExternalSciSync2FeaturesNV.adoc[]

The members of the sname:VkPhysicalDeviceExternalSciSync2FeaturesNV
structure describe the following features:

  * [[features-sciSyncFence2]] pname:sciSyncFence indicates whether external
    fences created with a handle type of
    ename:VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV and
    ename:VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV are supported
    for import and/or export.
  * [[features-sciSyncSemaphore2]] pname:sciSyncSemaphore2 indicates whether
    semaphore SciSync pools are supported and semaphores can be created from
    stext:NvSciSyncObj via slink:VkSemaphoreSciSyncPoolNV objects.
    In this case, the application is responsible for the resource management
    of the stext:NvSciSyncObj.
  * [[features-sciSyncImport2]] pname:sciSyncImport indicates whether
    stext:NvSciSyncObj import functionality is supported.
    If pname:sciSyncImport is set to ename:VK_TRUE, slink:VkFence and/or
    slink:VkSemaphore support importing stext:NvSciSyncObj from
    applications.
    In this case, the application is responsible for the resource management
    of the stext:NvSciSyncObj.
  * [[features-sciSyncExport2]] pname:sciSyncExport indicates whether
    stext:NvSciSyncObj export functionality is supported.
    If pname:sciSyncExport is set to ename:VK_TRUE, slink:VkFence supports
    exporting stext:NvSciSyncObj created by the driver to applications.
    In this case, the driver is responsible for the resource management of
    the stext:NvSciSyncObj.

[[features-externalscisync2-table]]
.Functionality supported for NvSciSync features
|=====
| Features           | pname:sciSyncImport | pname:sciSyncExport | Always supported^1^
| pname:sciSyncFence
  | flink:vkImportFenceSciSyncFenceNV, flink:vkImportFenceSciSyncObjNV
  | slink:VkExportFenceSciSyncInfoNV
  | flink:vkGetFenceSciSyncFenceNV, flink:vkGetFenceSciSyncObjNV, flink:vkGetPhysicalDeviceSciSyncAttributesNV (with ename:VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV)
| pname:sciSyncSemaphore2
  | flink:vkCreateSemaphoreSciSyncPoolNV, slink:VkSemaphoreSciSyncCreateInfoNV
  | n/a
  | flink:vkGetPhysicalDeviceSciSyncAttributesNV (with ename:VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV)
|=====

1::
    Functionality in this column is always available.

The <<features-externalscisync2-table, Functionality supported for NvSciSync
features>> table summarizes the functionality enabled by the
sname:VkPhysicalDeviceExternalSciSync2FeaturesNV structure.
There are two orthogonal pieces of functionality: fence and semaphore
support; import and export support.
Each entry in the body of the table summarizes the functionality that can:
be used when the given features are supported and enabled.
This summarizes Valid Usage statements that are added elsewhere in this
specification.

:refpage: VkPhysicalDeviceExternalSciSync2FeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExternalSciSync2FeaturesNV.adoc[]
--
endif::VK_NV_external_sci_sync2[]

ifdef::VK_NV_external_memory_sci_buf[]
[open,refpage='VkPhysicalDeviceExternalMemorySciBufFeaturesNV',desc='Structure describing NvSciBuf features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceExternalMemorySciBufFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceExternalMemorySciBufFeaturesNV.adoc[]

include::{generated}/api/structs/VkPhysicalDeviceExternalSciBufFeaturesNV.adoc[]

The members of the sname:VkPhysicalDeviceExternalMemorySciBufFeaturesNV
structure describe the following features:

  * [[features-sciBufImport]] pname:sciBufImport indicates whether
    stext:NvSciBufObj import functionality is supported.
    If pname:sciBufImport is set to ename:VK_TRUE, slink:VkDeviceMemory
    supports importing stext:NvSciBufObj from applications.
    In this case, the application is responsible for the resource management
    of the stext:NvSciBufObj.
  * [[features-sciBufExport]] pname:sciBufExport indicates whether
    stext:NvSciBufObj export functionality is supported.
    If pname:sciBufExport is set to ename:VK_TRUE, slink:VkDeviceMemory
    supports exporting stext:NvSciBufObj created by the driver to
    applications.
    In this case, the driver is responsible for the resource management of
    the stext:NvSciBufObj.

[[features-externalscibuf-table]]
.Functionality supported for NvSciBuf features
|=====
| Features            | Functionality
| pname:sciBufImport  | slink:VkImportMemorySciBufInfoNV, flink:vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV
| pname:sciBufExport  | slink:VkExportMemorySciBufInfoNV
| Always supported^1^ | flink:vkGetPhysicalDeviceSciBufAttributesNV, flink:vkGetMemorySciBufNV,
|=====

1::
    Functionality in this row is always available.

The <<features-externalscibuf-table, Functionality supported for NvSciBuf
features>> table summarizes the functionality enabled by the
sname:VkPhysicalDeviceExternalMemorySciBufFeaturesNV structure.
Each entry in the body of the table summarizes the functionality that can:
be used when the given features are supported and enabled.
This summarizes Valid Usage statements that are added elsewhere in this
specification.

:refpage: VkPhysicalDeviceExternalMemorySciBufFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExternalMemorySciBufFeaturesNV.adoc[]
--
endif::VK_NV_external_memory_sci_buf[]

ifdef::VK_QNX_external_memory_screen_buffer[]
[open,refpage='VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX',desc='Structure describing QNX Screen Buffer features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX.adoc[]

The members of the
sname:VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX structure
describe the following features:

  * [[features-screenBufferImport]] pname:screenBufferImport indicates
    whether QNX Screen buffer import functionality is supported.
    If pname:screenBufferImport is set to ename:VK_TRUE,
    slink:VkDeviceMemory supports importing code:_screen_buffer from
    applications.
    In this case, the application is responsible for the resource management
    of the code:_screen_buffer.

[[features-externalscreenbuffer-table]]
.Functionality supported for QNX Screen Buffer features
|=====
| Features            | Functionality
| pname:screenBufferImport  | slink:VkImportScreenBufferInfoQNX
| Always supported^1^ | flink:vkGetScreenBufferPropertiesQNX, slink:VkScreenBufferPropertiesQNX, slink:VkScreenBufferFormatPropertiesQNX,
slink:VkExternalFormatQNX
|=====

1::
    Functionality in this row is always available.

The <<features-externalscreenbuffer-table, Functionality supported for QNX
Screen buffer features>> table summarizes the functionality enabled by the
sname:VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX structure.
Each entry in the body of the table summarizes the functionality that can:
be used when the given features are supported and enabled.
This summarizes Valid Usage statements that are added elsewhere in this
specification.

:refpage: VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX.adoc[]
--
endif::VK_QNX_external_memory_screen_buffer[]

ifdef::VK_KHR_index_type_uint8,VK_EXT_index_type_uint8[]
[open,refpage='VkPhysicalDeviceIndexTypeUint8FeaturesKHR',desc='Structure describing whether uint8 index type can be used',type='structs',alias='VkPhysicalDeviceIndexTypeUint8FeaturesEXT']
--
The sname:VkPhysicalDeviceIndexTypeUint8FeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceIndexTypeUint8FeaturesKHR.adoc[]

ifdef::VK_EXT_index_type_uint8[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceIndexTypeUint8FeaturesEXT.adoc[]
endif::VK_EXT_index_type_uint8[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-indexTypeUint8]] pname:indexTypeUint8 indicates that
    ename:VK_INDEX_TYPE_UINT8_KHR can be used with
ifdef::VK_KHR_maintenance5[flink:vkCmdBindIndexBuffer2KHR and]
    flink:vkCmdBindIndexBuffer.

:refpage: VkPhysicalDeviceIndexTypeUint8FeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceIndexTypeUint8FeaturesKHR.adoc[]
--
endif::VK_KHR_index_type_uint8,VK_EXT_index_type_uint8[]

ifdef::VK_EXT_primitive_topology_list_restart[]
[open,refpage='VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT',desc='Structure describing whether list type primitives can support primitive restart',type='structs']
--
The sname:VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT structure
is defined as:

include::{generated}/api/structs/VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-primitiveTopologyListRestart]]
    pname:primitiveTopologyListRestart indicates that list type primitives,
    ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY and
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY, can: use the
    primitive restart index value in index buffers.
  * [[features-primitiveTopologyPatchListRestart]]
    pname:primitiveTopologyPatchListRestart indicates that the
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST topology can: use the primitive
    restart index value in index buffers.

:refpage: VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.adoc[]
--
endif::VK_EXT_primitive_topology_list_restart[]

ifdef::VK_NV_shader_sm_builtins[]
[open,refpage='VkPhysicalDeviceShaderSMBuiltinsFeaturesNV',desc='Structure describing the shader SM Builtins features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderSMBuiltinsFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderSMBuiltins]] pname:shaderSMBuiltins indicates whether
    the implementation supports the SPIR-V code:ShaderSMBuiltinsNV
    capability.

:refpage: VkPhysicalDeviceShaderSMBuiltinsFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.adoc[]
--
endif::VK_NV_shader_sm_builtins[]

ifdef::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
[open,refpage='VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures',desc='Structure describing whether the implementation can do depth and stencil image barriers separately',type='structs',alias='VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR']
--
The sname:VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.adoc[]

ifdef::VK_KHR_separate_depth_stencil_layouts[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.adoc[]
endif::VK_KHR_separate_depth_stencil_layouts[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_separate_depth_stencil_layouts-features[]
  * [[{anchor-prefix}features-separateDepthStencilLayouts]]
    pname:separateDepthStencilLayouts indicates whether the implementation
    supports a sname:VkImageMemoryBarrier for a depth/stencil image with
    only one of ename:VK_IMAGE_ASPECT_DEPTH_BIT or
    ename:VK_IMAGE_ASPECT_STENCIL_BIT set, and whether
    ename:VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
    ename:VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
    ename:VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or
    ename:VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL can be used.
// end::VK_KHR_separate_depth_stencil_layouts-features[]

:refpage: VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]

ifdef::VK_KHR_pipeline_executable_properties[]
[open,refpage='VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR',desc='Structure describing whether pipeline executable properties are available',type='structs']
--
The sname:VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR structure
is defined as:

include::{generated}/api/structs/VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-pipelineExecutableInfo]] pname:pipelineExecutableInfo
    indicates that the implementation supports reporting properties and
    statistics about the pipeline executables associated with a compiled
    pipeline.

:refpage: VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.adoc[]
--
endif::VK_KHR_pipeline_executable_properties[]

ifdef::VK_VERSION_1_3,VK_EXT_shader_demote_to_helper_invocation[]
[open,refpage='VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures',desc='Structure describing the shader demote to helper invocations features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT']
--
The sname:VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.adoc[]

ifdef::VK_EXT_shader_demote_to_helper_invocation[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.adoc[]
endif::VK_EXT_shader_demote_to_helper_invocation[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_EXT_shader_demote_to_helper_invocation-features[]
  * [[{anchor-prefix}features-shaderDemoteToHelperInvocation]]
    pname:shaderDemoteToHelperInvocation indicates whether the
    implementation supports the SPIR-V code:DemoteToHelperInvocationEXT
    capability.
// end::VK_EXT_shader_demote_to_helper_invocation-features[]

:refpage: VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.adoc[]
--
endif::VK_VERSION_1_3,VK_EXT_shader_demote_to_helper_invocation[]

ifdef::VK_EXT_texel_buffer_alignment[]
[open,refpage='VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT',desc='Structure describing the texel buffer alignment features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-texelBufferAlignment]] pname:texelBufferAlignment indicates
    whether the implementation uses more specific alignment requirements
    advertised in slink:VkPhysicalDeviceTexelBufferAlignmentProperties
    rather than
    slink:VkPhysicalDeviceLimits::pname:minTexelBufferOffsetAlignment.

:refpage: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.adoc[]
--
endif::VK_EXT_texel_buffer_alignment[]

ifdef::VK_EXT_attachment_feedback_loop_dynamic_state[]
[open,refpage='VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT',desc='Structure describing if dynamic feedback loops can be used',type='structs']
--
The sname:VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT
structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-attachmentFeedbackLoopDynamicState]]
    pname:attachmentFeedbackLoopDynamicState specifies whether dynamic
    feedback loops are supported.

:refpage: VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT.adoc[]
--
endif::VK_EXT_attachment_feedback_loop_dynamic_state[]

ifdef::VK_EXT_legacy_vertex_attributes[]
[open,refpage='VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT',desc='Structure describing compatibility features for vertex attributes',type='structs']
--
The sname:VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-legacyVertexAttributes]] pname:legacyVertexAttributes
    specifies whether compatibility features for vertex attributes are
    supported when using dynamic vertex input state.

:refpage: VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT.adoc[]
--
endif::VK_EXT_legacy_vertex_attributes[]

ifdef::VK_VERSION_1_3,VK_EXT_texture_compression_astc_hdr[]
[open,refpage='VkPhysicalDeviceTextureCompressionASTCHDRFeatures',desc='Structure describing ASTC HDR features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT']
--
The sname:VkPhysicalDeviceTextureCompressionASTCHDRFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceTextureCompressionASTCHDRFeatures.adoc[]

ifdef::VK_EXT_texture_compression_astc_hdr[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.adoc[]
endif::VK_EXT_texture_compression_astc_hdr[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_EXT_texture_compression_astc_hdr-features[]
  * [[{anchor-prefix}features-textureCompressionASTC_HDR]]
    pname:textureCompressionASTC_HDR indicates whether all of the ASTC HDR
    compressed texture formats are supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK
  ** ename:VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK
  ** ename:VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK
  ** ename:VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK
  ** ename:VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK
  ** ename:VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK
  ** ename:VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK
  ** ename:VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK
  ** ename:VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK
  ** ename:VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK
  ** ename:VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK
  ** ename:VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK
  ** ename:VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK
  ** ename:VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.
// end::VK_EXT_texture_compression_astc_hdr-features[]

:refpage: VkPhysicalDeviceTextureCompressionASTCHDRFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceTextureCompressionASTCHDRFeatures.adoc[]
--
endif::VK_VERSION_1_3,VK_EXT_texture_compression_astc_hdr[]

ifdef::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
[open,refpage='VkPhysicalDeviceLineRasterizationFeaturesKHR',desc='Structure describing the line rasterization features that can be supported by an implementation',type='structs',alias='VK_EXT_line_rasterization']
--
The sname:VkPhysicalDeviceLineRasterizationFeaturesKHR structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceLineRasterizationFeaturesKHR.adoc[]

ifdef::VK_EXT_line_rasterization[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceLineRasterizationFeaturesEXT.adoc[]
endif::VK_EXT_line_rasterization[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-rectangularLines]] pname:rectangularLines indicates whether
    the implementation supports <<primsrast-lines,rectangular line
    rasterization>>.
  * [[features-bresenhamLines]] pname:bresenhamLines indicates whether the
    implementation supports <<primsrast-lines-bresenham,Bresenham-style line
    rasterization>>.
  * [[features-smoothLines]] pname:smoothLines indicates whether the
    implementation supports <<primsrast-lines-smooth,smooth line
    rasterization>>.
  * [[features-stippledRectangularLines]] pname:stippledRectangularLines
    indicates whether the implementation supports
    <<primsrast-lines-stipple,stippled line rasterization>> with
    ename:VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR lines.
  * [[features-stippledBresenhamLines]] pname:stippledBresenhamLines
    indicates whether the implementation supports
    <<primsrast-lines-stipple,stippled line rasterization>> with
    ename:VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR lines.
  * [[features-stippledSmoothLines]] pname:stippledSmoothLines indicates
    whether the implementation supports <<primsrast-lines-stipple,stippled
    line rasterization>> with
    ename:VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR lines.

:refpage: VkPhysicalDeviceLineRasterizationFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceLineRasterizationFeaturesKHR.adoc[]
--
endif::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]

ifdef::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
[open,refpage='VkPhysicalDeviceSubgroupSizeControlFeatures',desc='Structure describing the subgroup size control features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceSubgroupSizeControlFeaturesEXT']
--
The sname:VkPhysicalDeviceSubgroupSizeControlFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceSubgroupSizeControlFeatures.adoc[]

ifdef::VK_EXT_subgroup_size_control[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.adoc[]
endif::VK_EXT_subgroup_size_control[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_EXT_subgroup_size_control-features[]
  * [[{anchor-prefix}features-subgroupSizeControl]]
    pname:subgroupSizeControl indicates whether the implementation supports
    controlling shader subgroup sizes via the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT
    flag and the slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo
    structure.
  * [[{anchor-prefix}features-computeFullSubgroups]]
    pname:computeFullSubgroups indicates whether the implementation supports
    requiring full subgroups in compute
ifdef::VK_NV_mesh_shader[]
    , mesh, or task
endif::VK_NV_mesh_shader[]
    shaders via the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT flag.
// end::VK_EXT_subgroup_size_control-features[]

:refpage: VkPhysicalDeviceSubgroupSizeControlFeatures
include::{chapters}/features.adoc[tag=features]

ifndef::VKSC_VERSION_1_0[]
[NOTE]
.Note
====
The sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT structure was added
in version 2 of the `apiext:VK_EXT_subgroup_size_control` extension.
Version 1 implementations of this extension will not fill out the features
structure but applications may assume that both pname:subgroupSizeControl
and pname:computeFullSubgroups are supported if the extension is supported.
(See also the <<features-requirements, Feature Requirements>> section.)
Applications are advised to add a
sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT structure to the
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features
regardless of the version of the extension supported by the implementation.
If the implementation only supports version 1, it will safely ignore the
sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT structure.

Vulkan 1.3 implementations always support the features structure.
====
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/structs/VkPhysicalDeviceSubgroupSizeControlFeatures.adoc[]
--
endif::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]

ifdef::VK_AMD_device_coherent_memory[]
[open,refpage='VkPhysicalDeviceCoherentMemoryFeaturesAMD',desc='Structure describing whether device coherent memory can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCoherentMemoryFeaturesAMD structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceCoherentMemoryFeaturesAMD.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-deviceCoherentMemory]] pname:deviceCoherentMemory indicates
    that the implementation supports <<VkMemoryPropertyFlagBits,device
    coherent memory>>.

:refpage: VkPhysicalDeviceCoherentMemoryFeaturesAMD
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCoherentMemoryFeaturesAMD.adoc[]
--
endif::VK_AMD_device_coherent_memory[]

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='VkPhysicalDeviceAccelerationStructureFeaturesKHR',desc='Structure describing the acceleration structure features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceAccelerationStructureFeaturesKHR.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-accelerationStructure]] pname:accelerationStructure indicates
    whether the implementation supports the acceleration structure
    functionality.
    See <<acceleration-structure,Acceleration Structures>>.
  * [[features-accelerationStructureCaptureReplay]]
    pname:accelerationStructureCaptureReplay indicates whether the
    implementation supports saving and reusing acceleration structure device
    addresses, e.g. for trace capture and replay.
  * [[features-accelerationStructureIndirectBuild]]
    pname:accelerationStructureIndirectBuild indicates whether the
    implementation supports indirect acceleration structure build commands,
    e.g. flink:vkCmdBuildAccelerationStructuresIndirectKHR.
  * [[features-accelerationStructureHostCommands]]
    pname:accelerationStructureHostCommands indicates whether the
    implementation supports host side acceleration structure commands, e.g.
    flink:vkBuildAccelerationStructuresKHR,
    flink:vkCopyAccelerationStructureKHR,
    flink:vkCopyAccelerationStructureToMemoryKHR,
    flink:vkCopyMemoryToAccelerationStructureKHR,
    flink:vkWriteAccelerationStructuresPropertiesKHR.
  * [[features-descriptorBindingAccelerationStructureUpdateAfterBind]]
    pname:descriptorBindingAccelerationStructureUpdateAfterBind indicates
    whether the implementation supports updating acceleration structure
    descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR.

:refpage: VkPhysicalDeviceAccelerationStructureFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceAccelerationStructureFeaturesKHR.adoc[]
--
endif::VK_KHR_acceleration_structure[]

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='VkPhysicalDeviceRayTracingPipelineFeaturesKHR',desc='Structure describing the ray tracing features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRayTracingPipelineFeaturesKHR structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-rayTracingPipeline]] pname:rayTracingPipeline indicates
    whether the implementation supports the ray tracing pipeline
    functionality.
    See <<ray-tracing,Ray Tracing>>.
  * [[features-rayTracingPipelineShaderGroupHandleCaptureReplay]]
    pname:rayTracingPipelineShaderGroupHandleCaptureReplay indicates whether
    the implementation supports saving and reusing shader group handles,
    e.g. for trace capture and replay.
  * [[features-rayTracingPipelineShaderGroupHandleCaptureReplayMixed]]
    pname:rayTracingPipelineShaderGroupHandleCaptureReplayMixed indicates
    whether the implementation supports reuse of shader group handles being
    arbitrarily mixed with creation of non-reused shader group handles.
    If this is ename:VK_FALSE, all reused shader group handles must: be
    specified before any non-reused handles may: be created.
  * [[features-rayTracingPipelineTraceRaysIndirect]]
    pname:rayTracingPipelineTraceRaysIndirect indicates whether the
    implementation supports indirect ray tracing commands, e.g.
    flink:vkCmdTraceRaysIndirectKHR.
  * [[features-rayTraversalPrimitiveCulling]]
    pname:rayTraversalPrimitiveCulling indicates whether the implementation
    supports <<ray-traversal-culling-primitive, primitive culling during ray
    traversal>>.

:refpage: VkPhysicalDeviceRayTracingPipelineFeaturesKHR
include::{chapters}/features.adoc[tag=features]

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceRayTracingPipelineFeaturesKHR-rayTracingPipelineShaderGroupHandleCaptureReplayMixed-03575]]
    If pname:rayTracingPipelineShaderGroupHandleCaptureReplayMixed is
    ename:VK_TRUE, pname:rayTracingPipelineShaderGroupHandleCaptureReplay
    must: also be ename:VK_TRUE
****

include::{generated}/validity/structs/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.adoc[]
--
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_KHR_ray_query[]
[open,refpage='VkPhysicalDeviceRayQueryFeaturesKHR',desc='Structure describing the ray query features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRayQueryFeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceRayQueryFeaturesKHR.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-rayQuery]] pname:rayQuery indicates whether the
    implementation supports ray query (code:OpRayQueryProceedKHR)
    functionality.

:refpage: VkPhysicalDeviceRayQueryFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRayQueryFeaturesKHR.adoc[]
--
endif::VK_KHR_ray_query[]

ifdef::VK_KHR_ray_tracing_maintenance1[]
[open,refpage='VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR',desc='Structure describing the ray tracing maintenance features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-rayTracingMaintenance1]] pname:rayTracingMaintenance1
    indicates that the implementation supports the following:
  ** The code:CullMaskKHR SPIR-V builtin using the `SPV_KHR_ray_cull_mask`
     SPIR-V extension.
  ** Additional acceleration structure property queries:
     ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR
     and ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR.
  ** A new access flag ename:VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR.
  ** A new pipeline stage flag bit
     ename:VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR
  * [[features-rayTracingPipelineTraceRaysIndirect2]]
    pname:rayTracingPipelineTraceRaysIndirect2 indicates whether the
    implementation supports the extended indirect ray tracing command
    flink:vkCmdTraceRaysIndirect2KHR.

:refpage: VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.adoc[]
--
endif::VK_KHR_ray_tracing_maintenance1[]

ifdef::VK_KHR_video_maintenance1[]
[open,refpage='VkPhysicalDeviceVideoMaintenance1FeaturesKHR',desc='Structure describing the video maintenance features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceVideoMaintenance1FeaturesKHR structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceVideoMaintenance1FeaturesKHR.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-videoMaintenance1]] pname:videoMaintenance1 indicates that
    the implementation supports the following:
  ** The new buffer creation flag
     ename:VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR.
  ** The new image creation flag
     ename:VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR.
  ** The new video session creation flag
     ename:VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR.

:refpage: VkPhysicalDeviceVideoMaintenance1FeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceVideoMaintenance1FeaturesKHR.adoc[]
--
endif::VK_KHR_video_maintenance1[]

ifdef::VK_EXT_extended_dynamic_state[]
[open,refpage='VkPhysicalDeviceExtendedDynamicStateFeaturesEXT',desc='Structure describing what extended dynamic state can be used',type='structs']
--
The sname:VkPhysicalDeviceExtendedDynamicStateFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-extendedDynamicState]] pname:extendedDynamicState indicates
    that the implementation supports the following dynamic states:
  ** ename:VK_DYNAMIC_STATE_CULL_MODE
  ** ename:VK_DYNAMIC_STATE_FRONT_FACE
  ** ename:VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY
  ** ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT
  ** ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT
  ** ename:VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE
  ** ename:VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE
  ** ename:VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE
  ** ename:VK_DYNAMIC_STATE_DEPTH_COMPARE_OP
  ** ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE
  ** ename:VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE
  ** ename:VK_DYNAMIC_STATE_STENCIL_OP

:refpage: VkPhysicalDeviceExtendedDynamicStateFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.adoc[]
--
endif::VK_EXT_extended_dynamic_state[]

ifdef::VK_EXT_extended_dynamic_state2[]
[open,refpage='VkPhysicalDeviceExtendedDynamicState2FeaturesEXT',desc='Structure describing what extended dynamic state can be used',type='structs']
--
The sname:VkPhysicalDeviceExtendedDynamicState2FeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-extendedDynamicState2]] pname:extendedDynamicState2 indicates
    that the implementation supports the following dynamic states:
  ** ename:VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE
  ** ename:VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE
  ** ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE
  * [[features-extendedDynamicState2LogicOp]]
    pname:extendedDynamicState2LogicOp indicates that the implementation
    supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_LOGIC_OP_EXT
  * [[features-extendedDynamicState2PatchControlPoints]]
    pname:extendedDynamicState2PatchControlPoints indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT

:refpage: VkPhysicalDeviceExtendedDynamicState2FeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.adoc[]
--
endif::VK_EXT_extended_dynamic_state2[]

ifdef::VK_EXT_extended_dynamic_state3[]
[open,refpage='VkPhysicalDeviceExtendedDynamicState3FeaturesEXT',desc='Structure describing what extended dynamic state is supported by the implementation',type='structs']
--
The sname:VkPhysicalDeviceExtendedDynamicState3FeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-extendedDynamicState3TessellationDomainOrigin]]
    pname:extendedDynamicState3TessellationDomainOrigin indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT
  * [[features-extendedDynamicState3DepthClampEnable]]
    pname:extendedDynamicState3DepthClampEnable indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT
  * [[features-extendedDynamicState3PolygonMode]]
    pname:extendedDynamicState3PolygonMode indicates that the implementation
    supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_POLYGON_MODE_EXT
  * [[features-extendedDynamicState3RasterizationSamples]]
    pname:extendedDynamicState3RasterizationSamples indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT
  * [[features-extendedDynamicState3SampleMask]]
    pname:extendedDynamicState3SampleMask indicates that the implementation
    supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_SAMPLE_MASK_EXT
  * [[features-extendedDynamicState3AlphaToCoverageEnable]]
    pname:extendedDynamicState3AlphaToCoverageEnable indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT
  * [[features-extendedDynamicState3AlphaToOneEnable]]
    pname:extendedDynamicState3AlphaToOneEnable indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT
  * [[features-extendedDynamicState3LogicOpEnable]]
    pname:extendedDynamicState3LogicOpEnable indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT
  * [[features-extendedDynamicState3ColorBlendEnable]]
    pname:extendedDynamicState3ColorBlendEnable indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT
  * [[features-extendedDynamicState3ColorBlendEquation]]
    pname:extendedDynamicState3ColorBlendEquation indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT
  * [[features-extendedDynamicState3ColorWriteMask]]
    pname:extendedDynamicState3ColorWriteMask indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT
  * [[features-extendedDynamicState3RasterizationStream]]
    pname:extendedDynamicState3RasterizationStream indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT
  * [[features-extendedDynamicState3ConservativeRasterizationMode]]
    pname:extendedDynamicState3ConservativeRasterizationMode indicates that
    the implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT
  * [[features-extendedDynamicState3ExtraPrimitiveOverestimationSize]]
    pname:extendedDynamicState3ExtraPrimitiveOverestimationSize indicates
    that the implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT
  * [[features-extendedDynamicState3DepthClipEnable]]
    pname:extendedDynamicState3DepthClipEnable indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT
  * [[features-extendedDynamicState3SampleLocationsEnable]]
    pname:extendedDynamicState3SampleLocationsEnable indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT
  * [[features-extendedDynamicState3ColorBlendAdvanced]]
    pname:extendedDynamicState3ColorBlendAdvanced indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT
  * [[features-extendedDynamicState3ProvokingVertexMode]]
    pname:extendedDynamicState3ProvokingVertexMode indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT
  * [[features-extendedDynamicState3LineRasterizationMode]]
    pname:extendedDynamicState3LineRasterizationMode indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT
  * [[features-extendedDynamicState3LineStippleEnable]]
    pname:extendedDynamicState3LineStippleEnable indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT
  * [[features-extendedDynamicState3DepthClipNegativeOneToOne]]
    pname:extendedDynamicState3DepthClipNegativeOneToOne indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT
  * [[features-extendedDynamicState3ViewportWScalingEnable]]
    pname:extendedDynamicState3ViewportWScalingEnable indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV
  * [[features-extendedDynamicState3ViewportSwizzle]]
    pname:extendedDynamicState3ViewportSwizzle indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV
  * [[features-extendedDynamicState3CoverageToColorEnable]]
    pname:extendedDynamicState3CoverageToColorEnable indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV
  * [[features-extendedDynamicState3CoverageToColorLocation]]
    pname:extendedDynamicState3CoverageToColorLocation indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV
  * [[features-extendedDynamicState3CoverageModulationMode]]
    pname:extendedDynamicState3CoverageModulationMode indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV
  * [[features-extendedDynamicState3CoverageModulationTableEnable]]
    pname:extendedDynamicState3CoverageModulationTableEnable indicates that
    the implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV
  * [[features-extendedDynamicState3CoverageModulationTable]]
    pname:extendedDynamicState3CoverageModulationTable indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV
  * [[features-extendedDynamicState3CoverageReductionMode]]
    pname:extendedDynamicState3CoverageReductionMode indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV
  * [[features-extendedDynamicState3RepresentativeFragmentTestEnable]]
    pname:extendedDynamicState3RepresentativeFragmentTestEnable indicates
    that the implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV
  * [[features-extendedDynamicState3ShadingRateImageEnable]]
    pname:extendedDynamicState3ShadingRateImageEnable indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV

:refpage: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.adoc[]
--
endif::VK_EXT_extended_dynamic_state3[]

ifdef::VK_NV_device_generated_commands[]
[open,refpage='VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV',desc='Structure describing the device-generated commands features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-deviceGeneratedCommands]] pname:deviceGeneratedCommands
    indicates whether the implementation supports functionality to generate
    commands on the device.
    See <<device-generated-commands,Device-Generated Commands>>.

:refpage: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.adoc[]
--
endif::VK_NV_device_generated_commands[]

ifdef::VK_NV_device_generated_commands_compute[]
[open,refpage='VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV',desc='Structure describing the device-generated compute features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-deviceGeneratedCompute]] pname:deviceGeneratedCompute
    indicates whether the implementation supports functionality to generate
    dispatch commands and push constants for the compute pipeline on the
    device.
    See <<device-generated-commands,Device-Generated Commands>>.
  * [[features-deviceGeneratedComputePipelines]]
    pname:deviceGeneratedComputePipelines indicates whether the
    implementation supports functionality to generate commands to bind
    compute pipelines on the device.
    See <<device-generated-commands,Device-Generated Commands>>.
  * [[features-deviceGeneratedComputeCaptureReplay]]
    pname:deviceGeneratedComputeCaptureReplay indicates whether the
    implementation supports functionality to capture compute pipeline
    address and reuse later for replay in
    <<device-generated-commands,Device-Generated Commands>>.

:refpage: VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV.adoc[]
--
endif::VK_NV_device_generated_commands_compute[]

ifdef::VK_NV_device_diagnostics_config[]
[open,refpage='VkPhysicalDeviceDiagnosticsConfigFeaturesNV',desc='Structure describing the device-generated diagnostic configuration features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDiagnosticsConfigFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDiagnosticsConfigFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-diagnosticsConfig]] pname:diagnosticsConfig indicates whether
    the implementation supports the ability to configure diagnostic tools.

:refpage: VkPhysicalDeviceDiagnosticsConfigFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDiagnosticsConfigFeaturesNV.adoc[]
--
endif::VK_NV_device_diagnostics_config[]

ifdef::VK_EXT_device_memory_report[]
[open,refpage='VkPhysicalDeviceDeviceMemoryReportFeaturesEXT',desc='Structure describing whether device memory report callback can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDeviceMemoryReportFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-deviceMemoryReport]] pname:deviceMemoryReport indicates
    whether the implementation supports the ability to register device
    memory report callbacks.

:refpage: VkPhysicalDeviceDeviceMemoryReportFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.adoc[]
--
endif::VK_EXT_device_memory_report[]

ifdef::VK_EXT_global_priority_query,VK_KHR_global_priority[]
[open,refpage='VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR',desc='Structure describing whether global priority query can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR.adoc[]
ifdef::VK_EXT_global_priority_query[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT.adoc[]
endif::VK_EXT_global_priority_query[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-globalPriorityQuery]] pname:globalPriorityQuery indicates
    whether the implementation supports the ability to query global queue
    priorities.

:refpage: VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR.adoc[]
--
endif::VK_EXT_global_priority_query,VK_KHR_global_priority[]

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
[open,refpage='VkPhysicalDevicePipelineCreationCacheControlFeatures',desc='Structure describing whether pipeline cache control can be supported by an implementation',type='structs',alias='VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT']
--
The sname:VkPhysicalDevicePipelineCreationCacheControlFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDevicePipelineCreationCacheControlFeatures.adoc[]

ifdef::VK_EXT_pipeline_creation_cache_control[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.adoc[]
endif::VK_EXT_pipeline_creation_cache_control[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_EXT_pipeline_creation_cache_control-features[]
  * [[{anchor-prefix}features-pipelineCreationCacheControl]]
    pname:pipelineCreationCacheControl indicates that the implementation
    supports:
  ** The following can: be used in stext:Vk*PipelineCreateInfo::pname:flags:
  *** ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT
  *** ename:VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT
  ** The following can: be used in
     slink:VkPipelineCacheCreateInfo::pname:flags:
  *** ename:VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT
// end::VK_EXT_pipeline_creation_cache_control-features[]

:refpage: VkPhysicalDevicePipelineCreationCacheControlFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePipelineCreationCacheControlFeatures.adoc[]
--
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]

ifdef::VK_VERSION_1_3,VK_KHR_zero_initialize_workgroup_memory[]
[open,refpage='VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures',desc='Structure describing support for zero initialization of workgroup memory by an implementation',type='structs',alias='VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR']
--
The sname:VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.adoc[]

ifdef::VK_KHR_zero_initialize_workgroup_memory[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR.adoc[]
endif::VK_KHR_zero_initialize_workgroup_memory[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_KHR_zero_initialize_workgroup_memory-features[]
  * [[{anchor-prefix}features-shaderZeroInitializeWorkgroupMemory]]
    pname:shaderZeroInitializeWorkgroupMemory specifies whether the
    implementation supports initializing a variable in Workgroup storage
    class.
// end::VK_KHR_zero_initialize_workgroup_memory-features[]

:refpage: VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.adoc[]
--
endif::VK_VERSION_1_3,VK_KHR_zero_initialize_workgroup_memory[]

ifdef::VK_VERSION_1_3,VK_EXT_private_data[]
[open,refpage='VkPhysicalDevicePrivateDataFeatures',desc='Structure specifying physical device support',type='structs',alias='VkPhysicalDevicePrivateDataFeaturesEXT']
--
The sname:VkPhysicalDevicePrivateDataFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDevicePrivateDataFeatures.adoc[]

ifdef::VK_EXT_private_data[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDevicePrivateDataFeaturesEXT.adoc[]
endif::VK_EXT_private_data[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_EXT_private_data-features[]
  * [[{anchor-prefix}features-privateData]] pname:privateData indicates
    whether the implementation supports private data.
    See <<private-data, Private Data>>.
// end::VK_EXT_private_data-features[]

:refpage: VkPhysicalDevicePrivateDataFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePrivateDataFeatures.adoc[]
--
endif::VK_VERSION_1_3,VK_EXT_private_data[]

ifdef::VK_KHR_shader_subgroup_uniform_control_flow[]
[open,refpage='VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR',desc='Structure describing support for shader subgroup uniform control flow by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderSubgroupUniformControlFlow]]
    pname:shaderSubgroupUniformControlFlow specifies whether the
    implementation supports the shader execution mode
    code:SubgroupUniformControlFlowKHR

:refpage: VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.adoc[]
--
endif::VK_KHR_shader_subgroup_uniform_control_flow[]

ifdef::VK_EXT_robustness2[]
[open,refpage='VkPhysicalDeviceRobustness2FeaturesEXT',desc='Structure describing the out-of-bounds behavior for an implementation',type='structs']
--
The sname:VkPhysicalDeviceRobustness2FeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceRobustness2FeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-robustBufferAccess2]] pname:robustBufferAccess2 indicates
    whether buffer accesses are tightly bounds-checked against the range of
    the descriptor.
    Uniform buffers must: be bounds-checked to the range of the descriptor,
    where the range is rounded up to a multiple of
    <<limits-robustUniformBufferAccessSizeAlignment,
    pname:robustUniformBufferAccessSizeAlignment>>.
    Storage buffers must: be bounds-checked to the range of the descriptor,
    where the range is rounded up to a multiple of
    <<limits-robustStorageBufferAccessSizeAlignment,
    pname:robustStorageBufferAccessSizeAlignment>>.
    Out of bounds buffer loads will return zero values, and <<textures,
    image load, sample, and atomic operations>> from texel buffers will have
    [eq]#(0,0,1)# values <<textures-conversion-to-rgba,inserted for missing
    G, B, or A components>> based on the format.
  * [[features-robustImageAccess2]] pname:robustImageAccess2 indicates
    whether image accesses are tightly bounds-checked against the dimensions
    of the image view.
    Out of bounds <<textures, image load, sample, and atomic operations>>
    from images will return zero values, with [eq]#(0,0,1)# values
    <<textures-conversion-to-rgba,inserted for missing G, B, or A
    components>> based on the format.
  * [[{vuprefix}features-nullDescriptor]] pname:nullDescriptor indicates
    whether descriptors can: be written with a dlink:VK_NULL_HANDLE resource
    or view, which are considered valid to access and act as if the
    descriptor were bound to nothing.

:refpage: VkPhysicalDeviceRobustness2FeaturesEXT
include::{chapters}/features.adoc[tag=features]

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceRobustness2FeaturesEXT-robustBufferAccess2-04000]]
    If pname:robustBufferAccess2 is enabled then
    <<features-robustBufferAccess, pname:robustBufferAccess>> must: also be
    enabled
****

include::{generated}/validity/structs/VkPhysicalDeviceRobustness2FeaturesEXT.adoc[]
--
endif::VK_EXT_robustness2[]

ifndef::VK_EXT_robustness2[]
[[features-nullDescriptor]] nullDescriptor support requires the
`apiext:VK_EXT_robustness2` extension.
endif::VK_EXT_robustness2[]

ifdef::VK_VERSION_1_3,VK_EXT_image_robustness[]
[open,refpage='VkPhysicalDeviceImageRobustnessFeatures',desc='Structure describing the out-of-bounds behavior for an implementation',type='structs',alias='VkPhysicalDeviceImageRobustnessFeaturesEXT']
--
The sname:VkPhysicalDeviceImageRobustnessFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceImageRobustnessFeatures.adoc[]

ifdef::VK_EXT_image_robustness[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceImageRobustnessFeaturesEXT.adoc[]
endif::VK_EXT_image_robustness[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_EXT_image_robustness-features[]
  * [[{anchor-prefix}features-robustImageAccess]] pname:robustImageAccess
    indicates whether image accesses are tightly bounds-checked against the
    dimensions of the image view.
    <<textures-input-validation,Invalid texels>> resulting from out of
    bounds image loads will be replaced as described in
    <<textures-texel-replacement,Texel Replacement>>, with either
    [eq]#(0,0,1)# or [eq]#(0,0,0)# values inserted for missing G, B, or A
    components based on the format.
// end::VK_EXT_image_robustness-features[]

:refpage: VkPhysicalDeviceImageRobustnessFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceImageRobustnessFeatures.adoc[]
--
endif::VK_VERSION_1_3,VK_EXT_image_robustness[]

ifdef::VK_VERSION_1_3,VK_KHR_shader_terminate_invocation[]
[open,refpage='VkPhysicalDeviceShaderTerminateInvocationFeatures',desc='Structure describing support for the SPIR-V code:SPV_KHR_terminate_invocation extension',type='structs',alias='VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR']
--
The sname:VkPhysicalDeviceShaderTerminateInvocationFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderTerminateInvocationFeatures.adoc[]

ifdef::VK_KHR_shader_terminate_invocation[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.adoc[]
endif::VK_KHR_shader_terminate_invocation[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_KHR_shader_terminate_invocation-features[]
  * [[{anchor-prefix}features-shaderTerminateInvocation]]
    pname:shaderTerminateInvocation specifies whether the implementation
    supports SPIR-V modules that use the `SPV_KHR_terminate_invocation`
    extension.
// end::VK_KHR_shader_terminate_invocation-features[]

:refpage: VkPhysicalDeviceShaderTerminateInvocationFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderTerminateInvocationFeatures.adoc[]
--
endif::VK_VERSION_1_3,VK_KHR_shader_terminate_invocation[]

ifdef::VK_EXT_custom_border_color[]
[open,refpage='VkPhysicalDeviceCustomBorderColorFeaturesEXT',desc='Structure describing whether custom border colors can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCustomBorderColorFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCustomBorderColorFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-customBorderColors]] pname:customBorderColors indicates that
    the implementation supports providing a pname:borderColor value with one
    of the following values at sampler creation time:
  ** ename:VK_BORDER_COLOR_FLOAT_CUSTOM_EXT
  ** ename:VK_BORDER_COLOR_INT_CUSTOM_EXT
  * [[features-customBorderColorWithoutFormat]]
    pname:customBorderColorWithoutFormat indicates that explicit formats are
    not required for custom border colors and the value of the pname:format
    member of the slink:VkSamplerCustomBorderColorCreateInfoEXT structure
    may: be ename:VK_FORMAT_UNDEFINED.
    If this feature bit is not set, applications must: provide the
    elink:VkFormat of the image view(s) being sampled by this sampler in the
    pname:format member of the slink:VkSamplerCustomBorderColorCreateInfoEXT
    structure.

:refpage: VkPhysicalDeviceCustomBorderColorFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCustomBorderColorFeaturesEXT.adoc[]
--
endif::VK_EXT_custom_border_color[]

ifdef::VK_EXT_border_color_swizzle[]
[open,refpage='VkPhysicalDeviceBorderColorSwizzleFeaturesEXT',desc='Structure describing whether samplers with custom border colors require the component swizzle specified in order to have defined behavior',type='structs']
--
The sname:VkPhysicalDeviceBorderColorSwizzleFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceBorderColorSwizzleFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-borderColorSwizzle]] pname:borderColorSwizzle indicates that
    defined values are returned by sampled image operations when used with a
    sampler that uses a ename:VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
    ename:VK_BORDER_COLOR_INT_OPAQUE_BLACK,
    ename:VK_BORDER_COLOR_FLOAT_CUSTOM_EXT, or
    ename:VK_BORDER_COLOR_INT_CUSTOM_EXT pname:borderColor and an image view
    that uses a non-<<resources-image-views-identity-mappings,identity
    component mapping>>, when either pname:borderColorSwizzleFromImage is
    enabled or the slink:VkSamplerBorderColorComponentMappingCreateInfoEXT
    is specified.
  * [[features-borderColorSwizzleFromImage]]
    pname:borderColorSwizzleFromImage indicates that the implementation will
    return the correct border color values from sampled image operations
    under the conditions expressed above, without the application having to
    specify the border color component mapping when creating the sampler
    object.
    If this feature bit is not set, applications can: chain a
    slink:VkSamplerBorderColorComponentMappingCreateInfoEXT structure when
    creating samplers for use with image views that do not have an
    <<resources-image-views-identity-mappings,identity swizzle>> and, when
    those samplers are combined with image views using the same component
    mapping, sampled image operations that use opaque black or custom border
    colors will return the correct border color values.

:refpage: VkPhysicalDeviceBorderColorSwizzleFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceBorderColorSwizzleFeaturesEXT.adoc[]
--
endif::VK_EXT_border_color_swizzle[]

ifdef::VK_KHR_portability_subset[]
[open,refpage='VkPhysicalDevicePortabilitySubsetFeaturesKHR',desc='Structure describing the features that may not be supported by an implementation of the Vulkan 1.0 Portability Subset',type='structs']
--
The sname:VkPhysicalDevicePortabilitySubsetFeaturesKHR structure is defined
as:

include::{generated}/api/structs/VkPhysicalDevicePortabilitySubsetFeaturesKHR.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-constantAlphaColorBlendFactors]]
    pname:constantAlphaColorBlendFactors indicates whether this
    implementation supports constant _alpha_ <<framebuffer-blendfactors>>
    used as source or destination _color_ <<framebuffer-blending>>.
  * [[features-events]] pname:events indicates whether this implementation
    supports synchronization using <<synchronization-events>>.
  * [[features-imageViewFormatReinterpretation]]
    pname:imageViewFormatReinterpretation indicates whether this
    implementation supports a sname:VkImageView being created with a texel
    format containing a different number of components, or a different
    number of bits in each component, than the texel format of the
    underlying sname:VkImage.
  * [[features-imageViewFormatSwizzle]] pname:imageViewFormatSwizzle
    indicates whether this implementation supports remapping format
    components using slink:VkImageViewCreateInfo::pname:components.
  * [[features-imageView2DOn3DImage]] pname:imageView2DOn3DImage indicates
    whether this implementation supports a sname:VkImage being created with
    the ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT flag set, permitting a
    2D or 2D array image view to be created on a 3D sname:VkImage.
  * [[features-multisampleArrayImage]] pname:multisampleArrayImage indicates
    whether this implementation supports a sname:VkImage being created as a
    2D array with multiple samples per texel.
  * [[features-mutableComparisonSamplers]] pname:mutableComparisonSamplers
    indicates whether this implementation allows descriptors with comparison
    samplers to be <<descriptorsets-updates, updated>>.
  * [[features-pointPolygons]] pname:pointPolygons indicates whether this
    implementation supports <<primsrast>> using a _point_
    <<primsrast-polygonmode>>.
  * [[features-samplerMipLodBias]] pname:samplerMipLodBias indicates whether
    this implementation supports setting a <<samplers-mipLodBias, mipmap LOD
    bias value>> when <<samplers, creating a sampler>>.
  * [[features-separateStencilMaskRef]] pname:separateStencilMaskRef
    indicates whether this implementation supports separate front and back
    <<fragops-stencil>> reference values.
  * [[features-shaderSampleRateInterpolationFunctions]]
    pname:shaderSampleRateInterpolationFunctions indicates whether this
    implementation supports fragment shaders which use the
    <<spirvenv-capabilities-table-InterpolationFunction,
    code:InterpolationFunction>> capability and the extended instructions
    `InterpolateAtCentroid`, `InterpolateAtOffset`, and
    `InterpolateAtSample` from the `GLSL.std.450` extended instruction set.
    This member is only meaningful if the <<features-sampleRateShading,
    pname:sampleRateShading>> feature is supported.
  * [[features-tessellationIsolines]] pname:tessellationIsolines indicates
    whether this implementation supports
    <<tessellation-isoline-tessellation, isoline output>> from the
    <<tessellation>> stage of a graphics pipeline.
    This member is only meaningful if <<features-tessellationShader,
    pname:tessellationShader>> are supported.
  * [[features-tessellationPointMode]] pname:tessellationPointMode indicates
    whether this implementation supports <<tessellation-point-mode, point
    output>> from the <<tessellation>> stage of a graphics pipeline.
    This member is only meaningful if <<features-tessellationShader,
    pname:tessellationShader>> are supported.
  * [[features-triangleFans]] pname:triangleFans indicates whether this
    implementation supports <<drawing-triangle-fans>> primitive topology.
  * [[features-vertexAttributeAccessBeyondStride]]
    pname:vertexAttributeAccessBeyondStride indicates whether this
    implementation supports accessing a vertex input attribute beyond the
    stride of the corresponding vertex input binding.

:refpage: VkPhysicalDevicePortabilitySubsetFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePortabilitySubsetFeaturesKHR.adoc[]
--
endif::VK_KHR_portability_subset[]

ifdef::VKSC_VERSION_1_0[]
[open,refpage='VkPhysicalDeviceVulkanSC10Features',desc='Structure describing the features that may not be supported by an implementation of Vulkan SC',type='structs']
--
The sname:VkPhysicalDeviceVulkanSC10Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVulkanSC10Features.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderAtomicInstructions]] pname:shaderAtomicInstructions
    indicates whether this implementation supports shaders which use the
    SPIR-V code:OpAtomic* instructions.

:refpage: VkPhysicalDeviceVulkanSC10Features
include::{chapters}/features.adoc[tag=features]

ifdef::hidden[]
// tag::scaddition[]
  * slink:VkPhysicalDeviceVulkanSC10Features <<SCID-1>>
// end::scaddition[]
// tag::scdeviation[]
  * slink:VkPhysicalDeviceVulkanSC10Features::pname:shaderAtomicInstructions
    are made optional <<SCID-1>>.
// end::scdeviation[]
endif::hidden[]

include::{generated}/validity/structs/VkPhysicalDeviceVulkanSC10Features.adoc[]
--
endif::VKSC_VERSION_1_0[]

ifdef::VK_KHR_performance_query[]
include::{chapters}/VK_KHR_performance_query/features.adoc[]
endif::VK_KHR_performance_query[]

ifdef::VK_EXT_4444_formats[]
[open,refpage='VkPhysicalDevice4444FormatsFeaturesEXT',desc='Structure describing additional 4444 formats supported by an implementation',type='structs']
--
The sname:VkPhysicalDevice4444FormatsFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDevice4444FormatsFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-formatA4R4G4B4]] pname:formatA4R4G4B4 indicates that the
    implementation must: support using a elink:VkFormat of
    ename:VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT with at least the following
    elink:VkFormatFeatureFlagBits:
  ** ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
  ** ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT
  ** ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
  * [[features-formatA4B4G4R4]] pname:formatA4B4G4R4 indicates that the
    implementation must: support using a elink:VkFormat of
    ename:VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT with at least the following
    elink:VkFormatFeatureFlagBits:
  ** ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
  ** ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT
  ** ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT

:refpage: VkPhysicalDevice4444FormatsFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevice4444FormatsFeaturesEXT.adoc[]

ifdef::VK_VERSION_1_3[]
[NOTE]
.Note
====
Although the formats defined by the `apiext:VK_EXT_4444_formats` extension
were promoted to Vulkan 1.3 as optional formats, the
slink:VkPhysicalDevice4444FormatsFeaturesEXT structure was not promoted to
Vulkan 1.3.
====
endif::VK_VERSION_1_3[]
--
endif::VK_EXT_4444_formats[]

ifdef::VK_EXT_mutable_descriptor_type,VK_VALVE_mutable_descriptor_type[]
[open,refpage='VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT',desc='Structure describing whether the mutable descriptor type is supported',type='structs',alias='VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE']
--
The sname:VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT.adoc[]

ifdef::VK_VALVE_mutable_descriptor_type[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE.adoc[]
endif::VK_VALVE_mutable_descriptor_type[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-mutableDescriptorType]] pname:mutableDescriptorType indicates
    that the implementation must: support using the elink:VkDescriptorType
    of ename:VK_DESCRIPTOR_TYPE_MUTABLE_EXT with at least the following
    descriptor types, where any combination of the types must: be supported:
  ** ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE
  ** ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER

  * Additionally, pname:mutableDescriptorType indicates that:
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  ** Non-uniform descriptor indexing must: be supported if all descriptor
     types in a slink:VkMutableDescriptorTypeListEXT for
     ename:VK_DESCRIPTOR_TYPE_MUTABLE_EXT have the corresponding non-uniform
     indexing features enabled in
     slink:VkPhysicalDeviceDescriptorIndexingFeatures.
  ** ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT with
     pname:descriptorType of ename:VK_DESCRIPTOR_TYPE_MUTABLE_EXT relaxes
     the list of required descriptor types to the descriptor types which
     have the corresponding update-after-bind feature enabled in
     slink:VkPhysicalDeviceDescriptorIndexingFeatures.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  ** Dynamically uniform descriptor indexing must: be supported if all
     descriptor types in a slink:VkMutableDescriptorTypeListEXT for
     ename:VK_DESCRIPTOR_TYPE_MUTABLE_EXT have the corresponding dynamic
     indexing features enabled.
  ** ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT must: be
     supported.
  ** ename:VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT must: be supported.

:refpage: VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT.adoc[]
--
endif::VK_EXT_mutable_descriptor_type,VK_VALVE_mutable_descriptor_type[]

ifdef::VK_EXT_depth_clip_control[]
[open,refpage='VkPhysicalDeviceDepthClipControlFeaturesEXT',desc='Structure describing additional depth clip control supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDepthClipControlFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDepthClipControlFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-depthClipControl]] pname:depthClipControl indicates that the
    implementation supports setting
    slink:VkPipelineViewportDepthClipControlCreateInfoEXT::pname:negativeOneToOne
    to ename:VK_TRUE.

:refpage: VkPhysicalDeviceDepthClipControlFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDepthClipControlFeaturesEXT.adoc[]
--
endif::VK_EXT_depth_clip_control[]

ifdef::VK_KHR_workgroup_memory_explicit_layout[]
[open,refpage='VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR',desc='Structure describing the workgroup storage explicit layout features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-workgroupMemoryExplicitLayout]]
    pname:workgroupMemoryExplicitLayout indicates whether the implementation
    supports the SPIR-V code:WorkgroupMemoryExplicitLayoutKHR capability.
  * [[features-workgroupMemoryExplicitLayoutScalarBlockLayout]]
    pname:workgroupMemoryExplicitLayoutScalarBlockLayout indicates whether
    the implementation supports scalar alignment for laying out Workgroup
    Blocks.
  * [[features-workgroupMemoryExplicitLayout8BitAccess]]
    pname:workgroupMemoryExplicitLayout8BitAccess indicates whether objects
    in the code:Workgroup storage class with the code:Block decoration can:
    have 8-bit integer members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:WorkgroupMemoryExplicitLayout8BitAccessKHR capability.
  * [[features-workgroupMemoryExplicitLayout16BitAccess]]
    pname:workgroupMemoryExplicitLayout16BitAccess indicates whether objects
    in the code:Workgroup storage class with the code:Block decoration can:
    have 16-bit integer and 16-bit floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also indicates whether shader modules can: declare the
    code:WorkgroupMemoryExplicitLayout16BitAccessKHR capability.

:refpage: VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.adoc[]
--
endif::VK_KHR_workgroup_memory_explicit_layout[]

ifdef::VK_VERSION_1_3,VK_KHR_synchronization2[]
[open,refpage='VkPhysicalDeviceSynchronization2Features',desc='Structure describing whether the implementation supports v2 synchronization commands',type='structs',alias='VkPhysicalDeviceSynchronization2FeaturesKHR']
--
The sname:VkPhysicalDeviceSynchronization2Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceSynchronization2Features.adoc[]

ifdef::VK_KHR_synchronization2[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceSynchronization2FeaturesKHR.adoc[]
endif::VK_KHR_synchronization2[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_KHR_synchronization2-features[]
  * [[{anchor-prefix}features-synchronization2]] pname:synchronization2
    indicates whether the implementation supports the new set of
    synchronization commands introduced in `apiext:VK_KHR_synchronization2`.
// end::VK_KHR_synchronization2-features[]

:refpage: VkPhysicalDeviceSynchronization2Features
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceSynchronization2Features.adoc[]
--
endif::VK_VERSION_1_3,VK_KHR_synchronization2[]

ifdef::VK_EXT_vertex_input_dynamic_state[]
[open,refpage='VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT',desc='Structure describing whether the dynamic vertex input state can be used',type='structs']
--
The sname:VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-vertexInputDynamicState]] pname:vertexInputDynamicState
    indicates that the implementation supports the following dynamic states:
  ** ename:VK_DYNAMIC_STATE_VERTEX_INPUT_EXT

:refpage: VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.adoc[]
--
endif::VK_EXT_vertex_input_dynamic_state[]

ifdef::VK_EXT_primitives_generated_query[]
[open,refpage='VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT',desc='Structure describing support for primitives generated query',type='structs']
--
The sname:VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-primitivesGeneratedQuery]] pname:primitivesGeneratedQuery
    indicates whether the implementation supports the
    ename:VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query type.
  * [[features-primitivesGeneratedQueryWithRasterizerDiscard]]
    pname:primitivesGeneratedQueryWithRasterizerDiscard indicates whether
    the implementation supports this query when
    <<primsrast-discard,rasterization discard>> is enabled.
  * [[features-primitivesGeneratedQueryWithNonZeroStreams]]
    pname:primitivesGeneratedQueryWithNonZeroStreams indicates whether the
    implementation supports this query with a non-zero index in
    flink:vkCmdBeginQueryIndexedEXT.

:refpage: VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.adoc[]
--
endif::VK_EXT_primitives_generated_query[]

ifdef::VK_KHR_fragment_shading_rate[]
[open,refpage='VkPhysicalDeviceFragmentShadingRateFeaturesKHR',desc='Structure indicating support for variable rate fragment shading',type='structs']
--
The sname:VkPhysicalDeviceFragmentShadingRateFeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-pipelineFragmentShadingRate]]
    pname:pipelineFragmentShadingRate indicates that the implementation
    supports the <<primsrast-fragment-shading-rate-pipeline, pipeline
    fragment shading rate>>.
  * [[features-primitiveFragmentShadingRate]]
    pname:primitiveFragmentShadingRate indicates that the implementation
    supports the <<primsrast-fragment-shading-rate-primitive, primitive
    fragment shading rate>>.
  * [[features-attachmentFragmentShadingRate]]
    pname:attachmentFragmentShadingRate indicates that the implementation
    supports the <<primsrast-fragment-shading-rate-attachment, attachment
    fragment shading rate>>.

:refpage: VkPhysicalDeviceFragmentShadingRateFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.adoc[]
--
endif::VK_KHR_fragment_shading_rate[]

ifdef::VK_EXT_legacy_dithering[]
[open,refpage='VkPhysicalDeviceLegacyDitheringFeaturesEXT',desc='Structure describing support for legacy dithering',type='structs']
--
The sname:VkPhysicalDeviceLegacyDitheringFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceLegacyDitheringFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-legacyDithering]] pname:legacyDithering indicates whether the
    implementation supports <<interfaces-legacy-dithering, Legacy
    Dithering>>.

:refpage: VkPhysicalDeviceLegacyDitheringFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceLegacyDitheringFeaturesEXT.adoc[]
--
endif::VK_EXT_legacy_dithering[]

ifdef::VK_NV_fragment_shading_rate_enums[]
[open,refpage='VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV',desc='Structure indicating support for fragment shading rate enums',type='structs']
--
The sname:VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-fragmentShadingRateEnums]] pname:fragmentShadingRateEnums
    indicates that the implementation supports specifying fragment shading
    rates using the ename:VkFragmentShadingRateNV enumerated type.
  * [[features-supersampleFragmentShadingRates]]
    pname:supersampleFragmentShadingRates indicates that the implementation
    supports fragment shading rate enum values indicating more than one
    invocation per fragment.
  * [[features-noInvocationFragmentShadingRates]]
    pname:noInvocationFragmentShadingRates indicates that the implementation
    supports a fragment shading rate enum value indicating that no fragment
    shaders should be invoked when that shading rate is used.

:refpage: VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.adoc[]
--
endif::VK_NV_fragment_shading_rate_enums[]


ifdef::VK_NV_inherited_viewport_scissor[]
[open,refpage='VkPhysicalDeviceInheritedViewportScissorFeaturesNV',desc='Structure describing the viewport scissor inheritance behavior for an implementation',type='structs']
--
The sname:VkPhysicalDeviceInheritedViewportScissorFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceInheritedViewportScissorFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-inheritedViewportScissor2D]] pname:inheritedViewportScissor2D
    indicates whether secondary command buffers can inherit most of the
    dynamic state affected by
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
    ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT,
    ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT,
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
ifdef::VK_EXT_discard_rectangles[]
    ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT,
    ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT,
    ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT,
endif::VK_EXT_discard_rectangles[]
    ename:VK_DYNAMIC_STATE_VIEWPORT or ename:VK_DYNAMIC_STATE_SCISSOR, from
    a primary command buffer.

:refpage: VkPhysicalDeviceInheritedViewportScissorFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceInheritedViewportScissorFeaturesNV.adoc[]
--
endif::VK_NV_inherited_viewport_scissor[]

ifdef::VK_EXT_pipeline_protected_access[]
[open,refpage='VkPhysicalDevicePipelineProtectedAccessFeaturesEXT',desc='Structure describing support for specifying protected access on individual pipelines',type='structs']
--
The sname:VkPhysicalDevicePipelineProtectedAccessFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDevicePipelineProtectedAccessFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-pipelineProtectedAccess]] pname:pipelineProtectedAccess
    indicates whether the implementation supports specifying protected
    access on individual pipelines.

:refpage: VkPhysicalDevicePipelineProtectedAccessFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePipelineProtectedAccessFeaturesEXT.adoc[]
--
endif::VK_EXT_pipeline_protected_access[]

ifdef::VK_EXT_ycbcr_2plane_444_formats[]
[open,refpage='VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT',desc='Structure describing whether the implementation supports additional 2-plane 444 {YCbCr} formats',type='structs']
--
The sname:VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-ycbcr2plane444Formats]] pname:ycbcr2plane444Formats indicates
    that the implementation supports the following 2-plane 444 {YCbCr}
    formats:
  ** ename:VK_FORMAT_G8_B8R8_2PLANE_444_UNORM
  ** ename:VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16
  ** ename:VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16
  ** ename:VK_FORMAT_G16_B16R16_2PLANE_444_UNORM

:refpage: VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.adoc[]

ifdef::VK_VERSION_1_3[]
[NOTE]
.Note
====
Although the formats defined by the `apiext:VK_EXT_ycbcr_2plane_444_formats`
were promoted to Vulkan 1.3 as optional formats, the
slink:VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT structure was not
promoted to Vulkan 1.3.
====
endif::VK_VERSION_1_3[]
--
endif::VK_EXT_ycbcr_2plane_444_formats[]

ifdef::VK_EXT_color_write_enable[]
[open,refpage='VkPhysicalDeviceColorWriteEnableFeaturesEXT',desc='Structure describing whether writes to color attachments can be enabled and disabled dynamically',type='structs']
--
The sname:VkPhysicalDeviceColorWriteEnableFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceColorWriteEnableFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-colorWriteEnable]] pname:colorWriteEnable indicates that the
    implementation supports the dynamic state
    ename:VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT.

:refpage: VkPhysicalDeviceColorWriteEnableFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceColorWriteEnableFeaturesEXT.adoc[]
--
endif::VK_EXT_color_write_enable[]

ifdef::VK_EXT_pipeline_properties[]
[open,refpage='VkPhysicalDevicePipelinePropertiesFeaturesEXT',desc='Structure describing what pipeline properties are supported',type='structs']
--
The sname:VkPhysicalDevicePipelinePropertiesFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDevicePipelinePropertiesFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-pipelinePropertiesIdentifier]]
    pname:pipelinePropertiesIdentifier indicates that the implementation
    supports querying a unique pipeline identifier.

:refpage: VkPhysicalDevicePipelinePropertiesFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePipelinePropertiesFeaturesEXT.adoc[]
--
endif::VK_EXT_pipeline_properties[]

ifdef::VK_EXT_provoking_vertex[]
[open,refpage='VkPhysicalDeviceProvokingVertexFeaturesEXT',desc='Structure describing the provoking vertex features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceProvokingVertexFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceProvokingVertexFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-provokingVertexLast]] pname:provokingVertexLast indicates
    whether the implementation supports the
    ename:VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT
    <<VkProvokingVertexModeEXT,provoking vertex mode>> for flat shading.
  * [[features-transformFeedbackPreservesProvokingVertex]]
    pname:transformFeedbackPreservesProvokingVertex indicates that the order
    of vertices within each primitive written by transform feedback will
    preserve the provoking vertex.
    This does not apply to triangle fan primitives when
    <<limits-transformFeedbackPreservesTriangleFanProvokingVertex,
    pname:transformFeedbackPreservesTriangleFanProvokingVertex>> is
    ename:VK_FALSE.
    pname:transformFeedbackPreservesProvokingVertex must: be ename:VK_FALSE
    when the `apiext:VK_EXT_transform_feedback` extension is not supported.

:refpage: VkPhysicalDeviceProvokingVertexFeaturesEXT
include::{chapters}/features.adoc[tag=features]

ifdef::VK_EXT_transform_feedback[]
When sname:VkPhysicalDeviceProvokingVertexFeaturesEXT is in the pname:pNext
chain of slink:VkDeviceCreateInfo but the <<features-transformFeedback,
pname:transformFeedback>> feature is not enabled, the value of
pname:transformFeedbackPreservesProvokingVertex is ignored.
endif::VK_EXT_transform_feedback[]

include::{generated}/validity/structs/VkPhysicalDeviceProvokingVertexFeaturesEXT.adoc[]
--
endif::VK_EXT_provoking_vertex[]

ifdef::VK_EXT_descriptor_buffer[]
[open,refpage='VkPhysicalDeviceDescriptorBufferFeaturesEXT',desc='Structure describing the descriptor buffer features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDescriptorBufferFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDescriptorBufferFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-descriptorBuffer]] pname:descriptorBuffer indicates that the
    implementation supports putting shader-accessible descriptors directly
    in memory.
  * [[features-descriptorBufferCaptureReplay]]
    pname:descriptorBufferCaptureReplay indicates that the implementation
    supports capture and replay when using descriptor buffers.
    If this is ename:VK_TRUE, all resources created with
    ename:VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
    ename:VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
    ename:VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
    ename:VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, or
    ename:VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
    must: be created before resources of the same types without those flags.
  * [[features-descriptorBufferImageLayoutIgnored]]
    pname:descriptorBufferImageLayoutIgnored indicates that the
    implementation will ignore pname:imageLayout in
    sname:VkDescriptorImageInfo when calling flink:vkGetDescriptorEXT.
  * [[features-descriptorBufferPushDescriptors]]
    pname:descriptorBufferPushDescriptors indicates that the implementation
    supports using push descriptors with descriptor buffers.

:refpage: VkPhysicalDeviceDescriptorBufferFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDescriptorBufferFeaturesEXT.adoc[]
--
endif::VK_EXT_descriptor_buffer[]

ifdef::VK_EXT_pageable_device_local_memory[]
[open,refpage='VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT',desc='Structure describing whether the implementation supports pageable device-local memory',type='structs']
--
The sname:VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-pageableDeviceLocalMemory]] pname:pageableDeviceLocalMemory
    indicates that the implementation supports pageable device-local memory
    and may: transparently move device-local memory allocations to
    host-local memory to better share device-local memory with other
    applications.

:refpage: VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.adoc[]
--
endif::VK_EXT_pageable_device_local_memory[]

ifdef::VK_EXT_multi_draw[]
[open,refpage='VkPhysicalDeviceMultiDrawFeaturesEXT',desc='Structure describing whether the implementation supports multi draw functionality',type='structs']
--
The sname:VkPhysicalDeviceMultiDrawFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMultiDrawFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-multiDraw]] pname:multiDraw indicates that the implementation
    supports flink:vkCmdDrawMultiEXT and flink:vkCmdDrawMultiIndexedEXT.

:refpage: VkPhysicalDeviceMultiDrawFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMultiDrawFeaturesEXT.adoc[]
--
endif::VK_EXT_multi_draw[]

ifdef::VK_NV_ray_tracing_motion_blur[]
[open,refpage='VkPhysicalDeviceRayTracingMotionBlurFeaturesNV',desc='Structure describing the ray tracing motion blur features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRayTracingMotionBlurFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-rayTracingMotionBlur]] pname:rayTracingMotionBlur indicates
    whether the implementation supports the motion blur feature.
  * [[features-rayTracingMotionBlurPipelineTraceRaysIndirect]]
    pname:rayTracingMotionBlurPipelineTraceRaysIndirect indicates whether
    the implementation supports indirect ray tracing commands with the
    motion blur feature enabled.

:refpage: VkPhysicalDeviceRayTracingMotionBlurFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.adoc[]
--
endif::VK_NV_ray_tracing_motion_blur[]

ifdef::VK_EXT_opacity_micromap[]
[open,refpage='VkPhysicalDeviceOpacityMicromapFeaturesEXT',desc='Structure describing the ray tracing opacity micromap features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceOpacityMicromapFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceOpacityMicromapFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-micromap]] pname:micromap indicates whether the
    implementation supports the micromap array feature.
  * [[features-micromapCaptureReplay]] pname:micromapCaptureReplay indicates
    whether the implementation supports capture and replay of addresses for
    micromap arrays.
  * [[features-micromapHostCommands]] pname:micromapHostCommands indicates
    whether the implementation supports host side micromap array commands.

:refpage: VkPhysicalDeviceOpacityMicromapFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceOpacityMicromapFeaturesEXT.adoc[]
--
endif::VK_EXT_opacity_micromap[]

ifdef::VK_NV_displacement_micromap[]
[open,refpage='VkPhysicalDeviceDisplacementMicromapFeaturesNV',desc='Structure describing the ray tracing displacement micromap features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDisplacementMicromapFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceDisplacementMicromapFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-displacementMicromap]] pname:displacementMicromap indicates
    whether the implementation supports the displacement micromap feature.

:refpage: VkPhysicalDeviceDisplacementMicromapFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDisplacementMicromapFeaturesNV.adoc[]
--
endif::VK_NV_displacement_micromap[]

ifdef::VK_NV_ray_tracing_validation[]
[open,refpage='VkPhysicalDeviceRayTracingValidationFeaturesNV',desc='Structure describing the ray tracing validation features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRayTracingValidationFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceRayTracingValidationFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-rayTracingValidation]] pname:rayTracingValidation indicates
    whether the implementation supports the ray tracing validation feature.

:refpage: VkPhysicalDeviceRayTracingValidationFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRayTracingValidationFeaturesNV.adoc[]
--
endif::VK_NV_ray_tracing_validation[]

ifdef::VK_HUAWEI_subpass_shading[]
[open,refpage='VkPhysicalDeviceSubpassShadingFeaturesHUAWEI',desc='Structure describing whether subpass shading is enabled',type='structs']
--
The sname:VkPhysicalDeviceSubpassShadingFeaturesHUAWEI structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-subpassShading]] pname:subpassShading specifies whether
    subpass shading is supported.

:refpage: VkPhysicalDeviceSubpassShadingFeaturesHUAWEI
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.adoc[]
--
endif::VK_HUAWEI_subpass_shading[]

ifdef::VK_NV_external_memory_rdma[]
[open,refpage='VkPhysicalDeviceExternalMemoryRDMAFeaturesNV',desc='Structure describing the external memory RDMA features supported by the implementation',type='structs']
--
The sname:VkPhysicalDeviceExternalMemoryRDMAFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-externalMemoryRDMA]] pname:externalMemoryRDMA indicates
    whether the implementation has support for the
    ename:VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV memory property and the
    ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV external memory
    handle type.

:refpage: VkPhysicalDeviceExternalMemoryRDMAFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.adoc[]
--
endif::VK_NV_external_memory_rdma[]

ifdef::VK_KHR_present_id[]
[open,refpage='VkPhysicalDevicePresentIdFeaturesKHR',desc='Structure indicating support for present id',type='structs']
--
The sname:VkPhysicalDevicePresentIdFeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDevicePresentIdFeaturesKHR.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-presentId]] pname:presentId indicates that the implementation
    supports specifying present ID values in the sname:VkPresentIdKHR
    extension to the sname:VkPresentInfoKHR struct.

:refpage: VkPhysicalDevicePresentIdFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePresentIdFeaturesKHR.adoc[]
--
endif::VK_KHR_present_id[]

ifdef::VK_KHR_present_wait[]
[open,refpage='VkPhysicalDevicePresentWaitFeaturesKHR',desc='Structure indicating support for present wait',type='structs']
--
The sname:VkPhysicalDevicePresentWaitFeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDevicePresentWaitFeaturesKHR.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-presentWait]] pname:presentWait indicates that the
    implementation supports fname:vkWaitForPresentKHR.

:refpage: VkPhysicalDevicePresentWaitFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePresentWaitFeaturesKHR.adoc[]
--
endif::VK_KHR_present_wait[]

ifdef::VK_EXT_host_image_copy[]
[open,refpage='VkPhysicalDeviceHostImageCopyFeaturesEXT',desc='Structure indicating support for copies to or from images from host memory',type='structs']
--
The sname:VkPhysicalDeviceHostImageCopyFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceHostImageCopyFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-hostImageCopy]] pname:hostImageCopy indicates that the
    implementation supports copying from host memory to images using the
    flink:vkCopyMemoryToImageEXT command, copying from images to host memory
    using the flink:vkCopyImageToMemoryEXT command, and copying between
    images using the flink:vkCopyImageToImageEXT command.

:refpage: VkPhysicalDeviceHostImageCopyFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceHostImageCopyFeaturesEXT.adoc[]
--
endif::VK_EXT_host_image_copy[]

ifdef::VK_NV_present_barrier[]
[open,refpage='VkPhysicalDevicePresentBarrierFeaturesNV',desc='Structure indicating support for VK_NV_present_barrier extension',type='structs']
--
The sname:VkPhysicalDevicePresentBarrierFeaturesNV structure is defined as:

include::{generated}/api/structs/VkPhysicalDevicePresentBarrierFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-presentBarrier]] pname:presentBarrier indicates that the
    implementation supports the present barrier feature.

:refpage: VkPhysicalDevicePresentBarrierFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePresentBarrierFeaturesNV.adoc[]
--
endif::VK_NV_present_barrier[]

ifdef::VK_VERSION_1_3,VK_KHR_shader_integer_dot_product[]
[open,refpage='VkPhysicalDeviceShaderIntegerDotProductFeatures',desc='Structure describing integer dot product features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR']
--
The sname:VkPhysicalDeviceShaderIntegerDotProductFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderIntegerDotProductFeatures.adoc[]

ifdef::VK_KHR_shader_integer_dot_product[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR.adoc[]
endif::VK_KHR_shader_integer_dot_product[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_KHR_shader_integer_dot_product-features[]
  * [[{anchor-prefix}features-shaderIntegerDotProduct]]
    pname:shaderIntegerDotProduct specifies whether shader modules can:
    declare the code:DotProductInputAllKHR, code:DotProductInput4x8BitKHR,
    code:DotProductInput4x8BitPackedKHR and code:DotProductKHR capabilities.
// end::VK_KHR_shader_integer_dot_product-features[]

:refpage: VkPhysicalDeviceShaderIntegerDotProductFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderIntegerDotProductFeatures.adoc[]
--
endif::VK_VERSION_1_3,VK_KHR_shader_integer_dot_product[]

ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
[open,refpage='VkPhysicalDeviceMaintenance4Features',desc='Structure describing whether the implementation supports maintenance4 functionality',type='structs',alias='VkPhysicalDeviceMaintenance4FeaturesKHR']
--
The sname:VkPhysicalDeviceMaintenance4Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMaintenance4Features.adoc[]

ifdef::VK_KHR_maintenance4[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceMaintenance4FeaturesKHR.adoc[]
endif::VK_KHR_maintenance4[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_KHR_maintenance4-features[]
  * [[{anchor-prefix}features-maintenance4]] pname:maintenance4 indicates
    that the implementation supports the following:
  ** The application may: destroy a slink:VkPipelineLayout object
     immediately after using it to create another object.
  ** code:LocalSizeId can: be used as an alternative to code:LocalSize to
     specify the local workgroup size with specialization constants.
  ** Images created with identical creation parameters will always have the
     same alignment requirements.
  ** The size memory requirement of a buffer or image is never greater than
     that of another buffer or image created with a greater or equal size.
  ** Push constants do not have to be initialized before they are
     dynamically accessed.
  ** The interface matching rules allow a larger output vector to match with
     a smaller input vector, with additional values being discarded.
// end::VK_KHR_maintenance4-features[]

:refpage: VkPhysicalDeviceMaintenance4Features
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMaintenance4Features.adoc[]
--
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]

ifdef::VK_KHR_maintenance5[]
[open,refpage='VkPhysicalDeviceMaintenance5FeaturesKHR',desc='Structure describing whether the implementation supports maintenance5 functionality',type='structs',alias='VkPhysicalDeviceMaintenance5FeaturesKHR']
--
The sname:VkPhysicalDeviceMaintenance5FeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMaintenance5FeaturesKHR.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-maintenance5]] pname:maintenance5 indicates that the
    implementation supports the following:
  ** The ability to expose support for the optional format
     ename:VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR.
  ** The ability to expose support for the optional format
     ename:VK_FORMAT_A8_UNORM_KHR.
  ** A property to indicate that multisample coverage operations are
     performed after sample counting in EarlyFragmentTests mode.
  ** Creating a sname:VkBufferView with a subset of the associated
     sname:VkBuffer usage using slink:VkBufferUsageFlags2CreateInfoKHR.
  ** A new function flink:vkCmdBindIndexBuffer2KHR, allowing a range of
     memory to be bound as an index buffer.
  ** flink:vkGetDeviceProcAddr will return `NULL` for function pointers of
     core functions for versions higher than the version requested by the
     application.
  ** flink:vkCmdBindVertexBuffers2 supports using ename:VK_WHOLE_SIZE in the
     pname:pSizes parameter.
  ** If code:PointSize is not written, a default value of `1.0` is used for
     the size of points.
  ** slink:VkShaderModuleCreateInfo can: be added as a chained structure to
     pipeline creation via slink:VkPipelineShaderStageCreateInfo, rather
     than having to create a shader module.
  ** A function flink:vkGetRenderingAreaGranularityKHR to query the optimal
     render area for a dynamic rendering instance.
  ** A property to indicate that depth/stencil texturing operations with
     ename:VK_COMPONENT_SWIZZLE_ONE have defined behavior.
  ** flink:vkGetDeviceImageSubresourceLayoutKHR allows an application to
     perform a flink:vkGetImageSubresourceLayout query without having to
     create an image.
  ** ename:VK_REMAINING_ARRAY_LAYERS as the pname:layerCount member of
     slink:VkImageSubresourceLayers.
  ** A property to indicate whether code:PointSize controls the final
     rasterization of polygons if <<primsrast-polygonmode, polygon mode>> is
     ename:VK_POLYGON_MODE_POINT.
  ** Two properties to indicate the non-strict line rasterization algorithm
     used.
  ** Two new flags words elink:VkPipelineCreateFlagBits2KHR and
     elink:VkBufferUsageFlagBits2KHR.
  ** Physical-device-level functions can: now be called with any value in
     the valid range for a type beyond the defined enumerants, such that
     applications can avoid checking individual features, extensions, or
     versions before querying supported properties of a particular
     enumerant.
  ** Copies between images of any type are allowed, with 1D images treated
     as 2D images with a height of `1`.

:refpage: VkPhysicalDeviceMaintenance5FeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMaintenance5FeaturesKHR.adoc[]
--
endif::VK_KHR_maintenance5[]

ifdef::VK_KHR_maintenance6[]
[open,refpage='VkPhysicalDeviceMaintenance6FeaturesKHR',desc='Structure describing whether the implementation supports maintenance6 functionality',type='structs',alias='VkPhysicalDeviceMaintenance6FeaturesKHR']
--
The sname:VkPhysicalDeviceMaintenance6FeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMaintenance6FeaturesKHR.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-maintenance6]] pname:maintenance6 indicates that the
    implementation supports the following:
  ** dlink:VK_NULL_HANDLE can: be used when binding an index buffer
  ** slink:VkBindMemoryStatusKHR can: be included in the pname:pNext chain
     of the slink:VkBindBufferMemoryInfo and slink:VkBindImageMemoryInfo
     structures, enabling applications to retrieve elink:VkResult values for
     individual memory binding operations.
  ** slink:VkPhysicalDeviceMaintenance6PropertiesKHR::pname:blockTexelViewCompatibleMultipleLayers
     property to indicate that the implementation supports creating image
     views with ename:VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT where
     the pname:layerCount member of pname:subresourceRange is greater than
     `1`.
  ** slink:VkPhysicalDeviceMaintenance6PropertiesKHR::pname:maxCombinedImageSamplerDescriptorCount
     property which indicates the maximum descriptor size required for any
     <<formats-requiring-sampler-ycbcr-conversion, format that requires a
     sampler {YCbCr} conversion>> supported by the implementation.
  ** A
     slink:VkPhysicalDeviceMaintenance6PropertiesKHR::pname:fragmentShadingRateClampCombinerInputs
     property which indicates whether the implementation clamps the inputs
     to fragment shading rate combiner operations.

:refpage: VkPhysicalDeviceMaintenance6FeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMaintenance6FeaturesKHR.adoc[]
--
endif::VK_KHR_maintenance6[]

ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
[open,refpage='VkPhysicalDeviceDynamicRenderingFeatures',desc='Structure indicating support for dynamic render pass instances',type='structs',alias='VkPhysicalDeviceDynamicRenderingFeaturesKHR']
--
The sname:VkPhysicalDeviceDynamicRenderingFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceDynamicRenderingFeatures.adoc[]

ifdef::VK_KHR_dynamic_rendering[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceDynamicRenderingFeaturesKHR.adoc[]
endif::VK_KHR_dynamic_rendering[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_KHR_dynamic_rendering-features[]
  * [[{anchor-prefix}features-dynamicRendering]] pname:dynamicRendering
    specifies that the implementation supports dynamic render pass instances
    using the flink:vkCmdBeginRendering command.
// end::VK_KHR_dynamic_rendering-features[]

:refpage: VkPhysicalDeviceDynamicRenderingFeatures
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDynamicRenderingFeatures.adoc[]
--
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]

ifdef::VK_EXT_rgba10x6_formats[]
[open,refpage='VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT',desc='Structure describing whether rendering to VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 formats can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-formatRgba10x6WithoutYCbCrSampler]]
    pname:formatRgba10x6WithoutYCbCrSampler indicates that
    ename:VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 can: be used with a
    sname:VkImageView with pname:subresourceRange.aspectMask equal to
    ename:VK_IMAGE_ASPECT_COLOR_BIT without a <<samplers-YCbCr-conversion,
    sampler {YCbCr} conversion>> enabled.

:refpage: VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT.adoc[]
--
endif::VK_EXT_rgba10x6_formats[]

ifdef::VK_EXT_pipeline_robustness[]
[open,refpage='VkPhysicalDevicePipelineRobustnessFeaturesEXT',desc='Structure describing whether an implementation supports robustness requests on a per-pipeline stage granularity',type='structs']
--
The sname:VkPhysicalDevicePipelineRobustnessFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDevicePipelineRobustnessFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-pipelineRobustness]] pname:pipelineRobustness indicates that
    robustness can: be requested on a per-pipeline-stage granularity.

[NOTE]
.Note
====
Enabling <<features-pipelineRobustness, pname:pipelineRobustness>> may, on
some platforms, incur a minor performance cost when
<<features-robustBufferAccess, pname:robustBufferAccess>> is disabled, even
for pipelines which do not make use of any robustness features.
If robustness is not needed, <<features-pipelineRobustness,
pname:pipelineRobustness>> should not be enabled by an application.
====

:refpage: VkPhysicalDevicePipelineRobustnessFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePipelineRobustnessFeaturesEXT.adoc[]
--
endif::VK_EXT_pipeline_robustness[]

ifdef::VK_EXT_image_view_min_lod[]
[open,refpage='VkPhysicalDeviceImageViewMinLodFeaturesEXT',desc='Structure describing whether clamping the min LOD of a image view is supported by the implementation',type='structs']
--
The sname:VkPhysicalDeviceImageViewMinLodFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceImageViewMinLodFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-minLod]] pname:minLod indicates whether the implementation
    supports clamping the minimum LOD value during
    <<textures-image-level-selection,Image Level(s) Selection>>,
    <<textures-gather,Texel Gathering>> and
    <<textures-integer-coordinate-operations,Integer Texel Coordinate
    Operations>> with a given slink:VkImageView by
    slink:VkImageViewMinLodCreateInfoEXT::pname:minLod.

:refpage: VkPhysicalDeviceImageViewMinLodFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceImageViewMinLodFeaturesEXT.adoc[]
--
endif::VK_EXT_image_view_min_lod[]

ifdef::VK_EXT_rasterization_order_attachment_access[]
[open,refpage='VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT',desc='Structure describing whether rasterization order attachment access can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT
structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.adoc[]

ifdef::VK_ARM_rasterization_order_attachment_access[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM.adoc[]
endif::VK_ARM_rasterization_order_attachment_access[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-rasterizationOrderColorAttachmentAccess]]
    pname:rasterizationOrderColorAttachmentAccess indicates that
    rasterization order access to color and input attachments is supported
    by the implementation.
  * [[features-rasterizationOrderDepthAttachmentAccess]]
    pname:rasterizationOrderDepthAttachmentAccess indicates that
    rasterization order access to the depth aspect of depth/stencil and
    input attachments is supported by the implementation.
  * [[features-rasterizationOrderStencilAttachmentAccess]]
    pname:rasterizationOrderStencilAttachmentAccess indicates that
    rasterization order access to the stencil aspect of depth/stencil and
    input attachments is supported by the implementation.

:refpage: VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.adoc[]
--
endif::VK_EXT_rasterization_order_attachment_access[]

ifdef::VK_EXT_subpass_merge_feedback[]
[open,refpage='VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT',desc='Structure describing whether subpass merging feedback can be supported by the implementation',type='structs']
--
The sname:VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-subpassMergeFeedback]] pname:subpassMergeFeedback indicates
    whether the implementation supports feedback of subpass merging.

:refpage: VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT.adoc[]
--
endif::VK_EXT_subpass_merge_feedback[]

ifdef::VK_NV_linear_color_attachment[]
[open,refpage='VkPhysicalDeviceLinearColorAttachmentFeaturesNV',desc='Structure describing whether <<glossary-linear-color-attachment, Linear Color Attachment>> rendering is supported by the implementation',type='structs']
--
The sname:VkPhysicalDeviceLinearColorAttachmentFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceLinearColorAttachmentFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-linearColorAttachment]] pname:linearColorAttachment indicates
    whether the implementation supports renderable
    <<glossary-linear-color-attachment, Linear Color Attachment>>

:refpage: VkPhysicalDeviceLinearColorAttachmentFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceLinearColorAttachmentFeaturesNV.adoc[]
--
endif::VK_NV_linear_color_attachment[]
ifdef::VK_EXT_attachment_feedback_loop_layout[]

[open,refpage='VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT',desc='Structure indicating support for a render feedback loop image layout',type='structs']
--
The sname:VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-attachmentFeedbackLoopLayout]]
    pname:attachmentFeedbackLoopLayout indicates whether the implementation
    supports using
    ename:VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT image layout
    for images created with
    ename:VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT.

include::{generated}/validity/structs/VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT.adoc[]
--

endif::VK_EXT_attachment_feedback_loop_layout[]

ifdef::VK_EXT_nested_command_buffer[]
[open,refpage='VkPhysicalDeviceNestedCommandBufferFeaturesEXT',desc='Structure describing whether nested command buffers are supported by the implementation',type='structs']
--
The sname:VkPhysicalDeviceNestedCommandBufferFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceNestedCommandBufferFeaturesEXT.adoc[]

This structure describes the following features:

  * [[features-nestedCommandBuffer]] pname:nestedCommandBuffer indicates the
    implementation supports nested command buffers, which allows <<glossary,
    Secondary Command Buffers>> to execute other <<glossary, Secondary
    Command Buffers>>.
  * [[features-nestedCommandBufferRendering]]
    pname:nestedCommandBufferRendering indicates that it is valid to call
    flink:vkCmdExecuteCommands inside a <<glossary, Secondary Command
    Buffer>> recorded with
    ename:VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT.
  * [[features-nestedCommandBufferSimultaneousUse]]
    pname:nestedCommandBufferSimultaneousUse indicates that the
    implementation supports nested command buffers with command buffers that
    are recorded with ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT.

:refpage: VkPhysicalDeviceNestedCommandBufferFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceNestedCommandBufferFeaturesEXT.adoc[]
--
endif::VK_EXT_nested_command_buffer[]

ifdef::VK_EXT_graphics_pipeline_library[]
[open,refpage='VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT',desc='Structure describing support for graphics pipeline libraries',type='structs']
--
The sname:VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-graphicsPipelineLibrary]] pname:graphicsPipelineLibrary
    indicates that the implementation supports <<pipelines-library, graphics
    pipeline libraries>>.

:refpage: VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT.adoc[]
--
endif::VK_EXT_graphics_pipeline_library[]

ifdef::VK_EXT_multisampled_render_to_single_sampled[]
[open,refpage='VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT',desc='Structure describing whether multisampled rendering to single-sampled attachments is supported',type='structs']
--
The sname:VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT
structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-multisampledRenderToSingleSampled]]
    pname:multisampledRenderToSingleSampled indicates that the
    implementation supports multisampled rendering to single-sampled render
    pass attachments.

:refpage: VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT.adoc[]
--
endif::VK_EXT_multisampled_render_to_single_sampled[]

ifdef::VK_EXT_image_2d_view_of_3d[]
[open,refpage='VkPhysicalDeviceImage2DViewOf3DFeaturesEXT',desc='Structure describing whether single-slice 2D views of 3D images can be used in image descriptors',type='structs']
--
The sname:VkPhysicalDeviceImage2DViewOf3DFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceImage2DViewOf3DFeaturesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-image2DViewOf3D]] pname:image2DViewOf3D indicates that the
    implementation supports using a 2D view of a 3D image in a descriptor of
    type ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE if the image is created
    using ename:VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT.
  * [[features-sampler2DViewOf3D]] pname:sampler2DViewOf3D indicates that
    the implementation supports using a 2D view of a 3D image in a
    descriptor of type ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER if the image is created
    using ename:VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT.

:refpage: VkPhysicalDeviceImage2DViewOf3DFeaturesEXT
include::{chapters}/features.adoc[tag=features]


include::{generated}/validity/structs/VkPhysicalDeviceImage2DViewOf3DFeaturesEXT.adoc[]
--
endif::VK_EXT_image_2d_view_of_3d[]

ifdef::VK_EXT_image_sliced_view_of_3d[]

[open,refpage='VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT',desc='Structure describing whether slice-based views of 3D images can be used in storage image descriptors',type='structs']
--
The sname:VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT.adoc[]

The members of the sname:VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT
structure describe the following features:

  * [[features-imageSlicedViewOf3D]] pname:imageSlicedViewOf3D indicates
    that the implementation supports using a sliced view of a 3D image in a
    descriptor of type ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE by using a
    slink:VkImageViewSlicedCreateInfoEXT structure when creating the view.

:refpage: VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT
include::{chapters}/features.adoc[tag=features]


include::{generated}/validity/structs/VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT.adoc[]
--

endif::VK_EXT_image_sliced_view_of_3d[]

ifdef::VK_EXT_image_compression_control[]
[open,refpage='VkPhysicalDeviceImageCompressionControlFeaturesEXT',desc='Structure describing whether image compression controls can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceImageCompressionControlFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceImageCompressionControlFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-imageCompressionControl]] pname:imageCompressionControl
    indicates that the implementation supports providing controls for image
    compression at image creation time.

:refpage: VkPhysicalDeviceImageCompressionControlFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceImageCompressionControlFeaturesEXT.adoc[]
--

ifdef::VK_EXT_image_compression_control_swapchain[]
[open,refpage='VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT',desc='Structure describing whether per-swapchain image compression controls can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-imageCompressionControlSwapchain]]
    pname:imageCompressionControlSwapchain indicates that the implementation
    supports controlling image controls per swapchain and querying image
    compression properties per surface.

:refpage: VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT.adoc[]
--
endif::VK_EXT_image_compression_control_swapchain[]

endif::VK_EXT_image_compression_control[]

ifdef::VK_KHR_ray_tracing_position_fetch[]
[open,refpage='VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR',desc='Structure describing support for fetching vertex positions of hit triangles',type='structs']
--
The sname:VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-rayTracingPositionFetch]] pname:rayTracingPositionFetch
    indicates that the implementation supports fetching the object space
    vertex positions of a hit triangle.

:refpage: VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR.adoc[]
--
endif::VK_KHR_ray_tracing_position_fetch[]


ifdef::VK_KHR_shader_float_controls2[]
[open,refpage='VkPhysicalDeviceShaderFloatControls2FeaturesKHR',desc='Structure describing shader float controls 2 features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderFloatControls2FeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderFloatControls2FeaturesKHR.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

  * [[features-shaderFloatControls2]] pname:shaderFloatControls2 specifies
    whether shader modules can: declare the code:FloatControls2 capability.

:refpage: VkPhysicalDeviceShaderFloatControls2FeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderFloatControls2FeaturesKHR.adoc[]
--
endif::VK_KHR_shader_float_controls2[]


ifdef::VK_AMD_shader_early_and_late_fragment_tests[]
[open,refpage='VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD',desc='Structure describing whether early and late fragment tests can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD
structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderEarlyAndLateFragmentTests]]
    pname:shaderEarlyAndLateFragmentTests indicates whether the
    implementation supports the code:EarlyAndLateFragmentTestsAMD
    {ExecutionMode}.

:refpage: VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD.adoc[]
--
endif::VK_AMD_shader_early_and_late_fragment_tests[]

ifdef::VK_EXT_non_seamless_cube_map[]
[open,refpage='VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT',desc='Structure describing features to disable seamless cube maps',type='structs']
--
The sname:VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-nonSeamlessCubeMap]] pname:nonSeamlessCubeMap indicates that
    the implementation supports
    ename:VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT.

:refpage: VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT.adoc[]
--
endif::VK_EXT_non_seamless_cube_map[]

ifdef::VK_EXT_shader_module_identifier[]
[open,refpage='VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT',desc='Structure describing whether querying and providing an identifier of a shader module is supported by the implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderModuleIdentifier]] pname:shaderModuleIdentifier
    indicates whether the implementation supports querying an identifier of
    a slink:VkShaderModule or slink:VkShaderModuleCreateInfo structure, and
    creating pipelines from identifiers only.

:refpage: VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT.adoc[]
--
endif::VK_EXT_shader_module_identifier[]

ifdef::VK_QCOM_tile_properties[]
[open,refpage='VkPhysicalDeviceTilePropertiesFeaturesQCOM',desc='Structure describing tile properties features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceTilePropertiesFeaturesQCOM structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceTilePropertiesFeaturesQCOM.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-tileProperties]] pname:tileProperties indicates that the
    implementation supports queries for returning tile properties.

:refpage: VkPhysicalDeviceTilePropertiesFeaturesQCOM
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceTilePropertiesFeaturesQCOM.adoc[]
--
endif::VK_QCOM_tile_properties[]

ifdef::VK_QCOM_image_processing[]
[open,refpage='VkPhysicalDeviceImageProcessingFeaturesQCOM',desc='Structure describing image processing features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceImageProcessingFeaturesQCOM structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceImageProcessingFeaturesQCOM.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-textureSampleWeighted]] pname:textureSampleWeighted indicates
    that the implementation supports shader modules that declare the
    pname:TextureSampleWeightedQCOM capability.
  * [[features-textureBoxFilter]] pname:textureBoxFilter indicates that the
    implementation supports shader modules that declare the
    pname:TextureBoxFilterQCOM capability.
  * [[features-textureBlockMatch]] pname:textureBlockMatch indicates that
    the implementation supports shader modules that declare the
    pname:TextureBlockMatchQCOM capability.

:refpage: VkPhysicalDeviceImageProcessingFeaturesQCOM
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceImageProcessingFeaturesQCOM.adoc[]
--
endif::VK_QCOM_image_processing[]

ifdef::VK_QCOM_image_processing2[]
[open,refpage='VkPhysicalDeviceImageProcessing2FeaturesQCOM',desc='Structure describing image processing features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceImageProcessing2FeaturesQCOM structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceImageProcessing2FeaturesQCOM.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-textureBlockMatch2]] pname:textureBlockMatch2 indicates that
    the implementation supports shader modules that declare the
    code:TextureBlockMatch2QCOM capability.

:refpage: VkPhysicalDeviceImageProcessing2FeaturesQCOM
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceImageProcessing2FeaturesQCOM.adoc[]
--
endif::VK_QCOM_image_processing2[]



ifdef::VK_EXT_depth_clamp_zero_one[]
[open,refpage='VkPhysicalDeviceDepthClampZeroOneFeaturesEXT',desc='Structure describing feature to control zero to one depth clamping',type='structs']
--
The sname:VkPhysicalDeviceDepthClampZeroOneFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDepthClampZeroOneFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

  * [[features-depthClampZeroOne]] pname:depthClampZeroOne indicates that
    the implementation supports clamping the depth to a range of `0` to `1`.

:refpage: VkPhysicalDeviceDepthClampZeroOneFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDepthClampZeroOneFeaturesEXT.adoc[]
--
endif::VK_EXT_depth_clamp_zero_one[]
ifdef::VK_EXT_shader_tile_image[]
[open,refpage='VkPhysicalDeviceShaderTileImageFeaturesEXT',desc='Structure describing tile image features supported by the implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderTileImageFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderTileImageFeaturesEXT.adoc[]

The members of the sname:VkPhysicalDeviceShaderTileImageFeaturesEXT
structure describe the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderTileImageColorReadAccess]]
    pname:shaderTileImageColorReadAccess indicates that the implementation
    supports the code:TileImageColorReadAccessEXT SPIR-V capability.
  * [[features-shaderTileImageDepthReadAccess]]
    pname:shaderTileImageDepthReadAccess indicates that the implementation
    supports the code:TileImageDepthReadAccessEXT SPIR-V capability.
  * [[features-shaderTileImageStencilReadAccess]]
    pname:shaderTileImageStencilReadAccess indicates that the implementation
    supports the code:TileImageStencilReadAccessEXT SPIR-V capability.

:refpage: VkPhysicalDeviceShaderTileImageFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderTileImageFeaturesEXT.adoc[]
--
endif::VK_EXT_shader_tile_image[]


ifdef::VK_EXT_depth_bias_control[]

[open,refpage='VkPhysicalDeviceDepthBiasControlFeaturesEXT',desc='Structure indicating support for depth bias scaling and representation control',type='structs']
--
The sname:VkPhysicalDeviceDepthBiasControlFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDepthBiasControlFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-depthBiasControl]] pname:depthBiasControl indicates whether
    the implementation supports the fname:vkCmdSetDepthBias2EXT command and
    the sname:VkDepthBiasRepresentationInfoEXT structure.
  * [[features-leastRepresentableValueForceUnormRepresentation]]
    pname:leastRepresentableValueForceUnormRepresentation indicates whether
    the implementation supports using the
    ename:VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT
    depth bias representation.
  * [[features-floatRepresentation]] pname:floatRepresentation indicates
    whether the implementation supports using the
    ename:VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT depth bias representation.
  * [[features-depthBiasExact]] pname:depthBiasExact indicates whether the
    implementation supports forcing depth bias to not be scaled to ensure a
    minimum resolvable difference using
    sname:VkDepthBiasRepresentationInfoEXT::pname:depthBiasExact.

include::{generated}/validity/structs/VkPhysicalDeviceDepthBiasControlFeaturesEXT.adoc[]
--

endif::VK_EXT_depth_bias_control[]

ifdef::VK_EXT_device_address_binding_report[]
[open,refpage='VkPhysicalDeviceAddressBindingReportFeaturesEXT',desc='Structure describing the virtual allocation reporting feature supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceAddressBindingReportFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceAddressBindingReportFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-reportAddressBinding]] pname:reportAddressBinding indicates
    whether this implementation supports reporting the binding of GPU
    virtual address ranges to Vulkan objects.

:refpage: VkPhysicalDeviceAddressBindingReportFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceAddressBindingReportFeaturesEXT.adoc[]
--
endif::VK_EXT_device_address_binding_report[]

ifdef::VK_NV_optical_flow[]
[open,refpage='VkPhysicalDeviceOpticalFlowFeaturesNV',desc='Structure describing the optical flow features supported by the implementation',type='structs']
--
The sname:VkPhysicalDeviceOpticalFlowFeaturesNV structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceOpticalFlowFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-opticalFlow]] pname:opticalFlow indicates whether the
    implementation supports optical flow.

:refpage: VkPhysicalDeviceOpticalFlowFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceOpticalFlowFeaturesNV.adoc[]
--
endif::VK_NV_optical_flow[]

ifdef::VK_EXT_device_fault[]
[open,refpage='VkPhysicalDeviceFaultFeaturesEXT',desc='Structure indicating support for device fault reporting',type='structs']
--
The sname:VkPhysicalDeviceFaultFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceFaultFeaturesEXT.adoc[]

The members of the sname:VkPhysicalDeviceFaultFeaturesEXT structure describe
the following features:

  * [[features-deviceFault]] pname:deviceFault indicates that the
    implementation supports the reporting of device fault information.
  * [[features-deviceFaultVendorBinary]] pname:deviceFaultVendorBinary
    indicates that the implementation supports the generation of
    vendor-specific binary crash dumps.
    These may provide additional information when imported into
    vendor-specific external tools.

:refpage: VkPhysicalDeviceFaultFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFaultFeaturesEXT.adoc[]
--
endif::VK_EXT_device_fault[]

ifdef::VK_EXT_pipeline_library_group_handles[]
[open,refpage='VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT',desc='Structure describing whether querying shader group handles from a pipeline library is supported by the implementation',type='structs']
--
The sname:VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT structure
is defined as:

include::{generated}/api/structs/VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT.adoc[]

This structure describes the following features:

  * [[features-pipelineLibraryGroupHandles]]
    pname:pipelineLibraryGroupHandles indicates whether the implementation
    supports querying group handles directly from a ray tracing pipeline
    library, and guarantees bitwise identical group handles for such
    libraries when linked into other pipelines.

:refpage: VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT.adoc[]
--
endif::VK_EXT_pipeline_library_group_handles[]

ifdef::VK_EXT_shader_object[]
[open,refpage='VkPhysicalDeviceShaderObjectFeaturesEXT',desc='Structure describing whether shader objects can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderObjectFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderObjectFeaturesEXT.adoc[]

This structure describes the following feature:

  * [[features-shaderObject]] pname:shaderObject indicates whether the
    implementation supports <<shaders-objects, shader objects>>.

:refpage: VkPhysicalDeviceShaderObjectFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderObjectFeaturesEXT.adoc[]
--
endif::VK_EXT_shader_object[]

ifdef::VK_ARM_shader_core_builtins[]
[open,refpage='VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM',desc='Structure describing the shader core builtins features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderCoreBuiltins]] pname:shaderCoreBuiltins indicates
    whether the implementation supports the SPIR-V code:CoreBuiltinsARM
    capability.

:refpage: VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM.adoc[]
--
endif::VK_ARM_shader_core_builtins[]

ifdef::VK_EXT_frame_boundary[]
[open,refpage='VkPhysicalDeviceFrameBoundaryFeaturesEXT',desc='Structure describing the frame boundary features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFrameBoundaryFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceFrameBoundaryFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-frameBoundary]] pname:frameBoundary indicates whether the
    implementation supports frame boundary information.

:refpage: VkPhysicalDeviceFrameBoundaryFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFrameBoundaryFeaturesEXT.adoc[]
--
endif::VK_EXT_frame_boundary[]

ifdef::VK_EXT_swapchain_maintenance1[]
[open,refpage='VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT',desc='Structure describing whether implementation supports swapchain maintenance1 functionality',type='structs']
--
The sname:VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-swapchainMaintenance1]] pname:swapchainMaintenance1 indicates
    that the implementation supports the following:
  ** slink:VkSwapchainPresentFenceInfoEXT, specifying a fence that is
     signaled when the resources associated with a present operation can: be
     safely destroyed.
  ** slink:VkSwapchainPresentModesCreateInfoEXT and
     slink:VkSwapchainPresentModeInfoEXT, allowing the swapchain to switch
     present modes without a need for recreation.
  ** slink:VkSwapchainPresentScalingCreateInfoEXT, specifying the scaling
     behavior of the swapchain in presence of window resizing.
  ** The ename:VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT flag,
     allowing the implementation to defer the allocation of swapchain image
     memory until first acquisition.
  ** flink:vkReleaseSwapchainImagesEXT, allowing acquired swapchain images
     to be released without presenting them.

:refpage: VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT.adoc[]
--
endif::VK_EXT_swapchain_maintenance1[]

ifdef::VK_EXT_dynamic_rendering_unused_attachments[]
[open,refpage='VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT',desc='Structure describing the dynamic rendering unused attachment features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-dynamicRenderingUnusedAttachments]]
    pname:dynamicRenderingUnusedAttachments indicates that the
    implementation supports binding graphics pipelines within a render pass
    instance where any pipeline
    slink:VkPipelineRenderingCreateInfo::pname:pColorAttachmentFormats
    element with a format other than ename:VK_FORMAT_UNDEFINED is allowed
    with a corresponding slink:VkRenderingInfo::pname:pColorAttachments
    element with an pname:imageView equal to dlink:VK_NULL_HANDLE, or any
    pipeline
    slink:VkPipelineRenderingCreateInfo::pname:pColorAttachmentFormats
    element with a ename:VK_FORMAT_UNDEFINED format is allowed with a
    corresponding slink:VkRenderingInfo::pname:pColorAttachments element
    with a non-dlink:VK_NULL_HANDLE pname:imageView.
    Also a slink:VkPipelineRenderingCreateInfo::pname:depthAttachmentFormat
    other than ename:VK_FORMAT_UNDEFINED is allowed with a
    dlink:VK_NULL_HANDLE slink:VkRenderingInfo::pname:pDepthAttachment, or a
    slink:VkPipelineRenderingCreateInfo::pname:depthAttachmentFormat of
    ename:VK_FORMAT_UNDEFINED is allowed with a non-dlink:VK_NULL_HANDLE
    slink:VkRenderingInfo::pname:pDepthAttachment.
    Also a
    slink:VkPipelineRenderingCreateInfo::pname:stencilAttachmentFormat other
    than ename:VK_FORMAT_UNDEFINED is allowed with a dlink:VK_NULL_HANDLE
    slink:VkRenderingInfo::pname:pStencilAttachment, or a
    slink:VkPipelineRenderingCreateInfo::pname:stencilAttachmentFormat of
    ename:VK_FORMAT_UNDEFINED is allowed with a non-dlink:VK_NULL_HANDLE
    slink:VkRenderingInfo::pname:pStencilAttachment.
    Any writes to a slink:VkRenderingInfo::pname:pColorAttachments,
    slink:VkRenderingInfo::pname:pDepthAttachment, or
    slink:VkRenderingInfo::pname:pStencilAttachment with
    dlink:VK_NULL_HANDLE are discarded.

:refpage: VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT.adoc[]

--
endif::VK_EXT_dynamic_rendering_unused_attachments[]

ifdef::VK_NV_ray_tracing_invocation_reorder[]
[open,refpage='VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV',desc='Structure describing feature to control ray tracing invocation reordering',type='structs']
--
The sname:VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-rayTracingInvocationReorder]]
    pname:rayTracingInvocationReorder indicates that the implementation
    supports `SPV_NV_shader_invocation_reorder`.

:refpage: VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV.adoc[]

--
endif::VK_NV_ray_tracing_invocation_reorder[]

ifdef::VK_NV_extended_sparse_address_space[]
[open,refpage='VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV',desc='Structure describing feature to use extended sparse address space',type='structs']
--
The sname:VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-extendedSparseAddressSpace]] pname:extendedSparseAddressSpace
    indicates that the implementation supports allowing certain usages of
    sparse memory resources to exceed
    sname:VkPhysicalDeviceLimits::pname:sparseAddressSpaceSize.
    See slink:VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV.

:refpage: VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV.adoc[]

--
endif::VK_NV_extended_sparse_address_space[]

ifdef::VK_QCOM_multiview_per_view_viewports[]
[open,refpage='VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM',desc='Structure describing multiview per view viewports features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM.adoc[]

This structure describes the following features:

  * [[features-multiview-per-view-viewports]]
    pname:multiviewPerViewViewports indicates that the implementation
    supports multiview per-view viewports.

:refpage: VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM.adoc[]
--
endif::VK_QCOM_multiview_per_view_viewports[]

ifdef::VK_QCOM_multiview_per_view_render_areas[]
[open,refpage='VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM',desc='Structure describing multiview per view render areas features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM.adoc[]

This structure describes the following features:

  * [[features-multiview-per-view-render-areas]]
    pname:multiviewPerViewRenderAreas indicates that the implementation
    supports multiview per-view render areas.

:refpage: VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM.adoc[]
--
endif::VK_QCOM_multiview_per_view_render_areas[]

ifdef::VK_HUAWEI_cluster_culling_shader[]

[open,refpage='VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI',desc='Structure describing whether cluster culling shader is enabled',type='structs']
--
The sname:VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-clustercullingShader]] pname:clustercullingShader specifies
    whether cluster culling shader is supported.
  * [[features-multiviewClusterCullingShader]]
    pname:multiviewClusterCullingShader specifies whether multiview is
    supported.

:refpage: VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI.adoc[]
--
endif::VK_HUAWEI_cluster_culling_shader[]

ifdef::VK_HUAWEI_cluster_culling_shader[]

[open,refpage='VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI',desc='Structure describing whether cluster culling shader support VRS',type='structs']
--
To query whether a Cluster Culling Shader supports the per-cluster shading
rate feature, include a
sname:VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI structure in the
pname:pNext chain of the
sname:VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI structure.
This structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-clusterShadingRate]] pname:clusterShadingRate specifies
    whether per-cluster shading rates is supported.

include::{generated}/validity/structs/VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI.adoc[]
--

endif::VK_HUAWEI_cluster_culling_shader[]


ifdef::VK_AMDX_shader_enqueue[]
[open,refpage='VkPhysicalDeviceShaderEnqueueFeaturesAMDX',desc='Structure describing whether shader enqueue within execution graphs are supported by the implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderEnqueueFeaturesAMDX structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderEnqueueFeaturesAMDX.adoc[]

This structure describes the following feature:

  * [[features-shaderEnqueue]] pname:shaderEnqueue indicates whether the
    implementation supports <<executiongraphs,execution graphs>>.

:refpage: VkPhysicalDeviceShaderEnqueueFeaturesAMDX
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderEnqueueFeaturesAMDX.adoc[]
--
endif::VK_AMDX_shader_enqueue[]

ifdef::VK_QCOM_filter_cubic_clamp[]
[open,refpage='VkPhysicalDeviceCubicClampFeaturesQCOM',desc='Structure describing cubic clamp features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCubicClampFeaturesQCOM structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceCubicClampFeaturesQCOM.adoc[]

This structure describes the following features:

  * [[features-filter-cubic-range-clamp]] pname:cubicRangeClamp indicates
    that the implementation supports cubic filtering in combination with a
    <<textures-texel-range-clamp,texel range clamp>>.

:refpage: VkPhysicalDeviceCubicClampFeaturesQCOM
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCubicClampFeaturesQCOM.adoc[]
--
endif::VK_QCOM_filter_cubic_clamp[]

ifdef::VK_QCOM_ycbcr_degamma[]
[open,refpage='VkPhysicalDeviceYcbcrDegammaFeaturesQCOM',desc='Structure describing {YCbCr} degamma features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceYcbcrDegammaFeaturesQCOM structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceYcbcrDegammaFeaturesQCOM.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-ycbcr-degamma]] pname:ycbcrDegamma indicates whether the
    implementation supports <<textures-ycbcr-degamma,{YCbCr} degamma>>.

:refpage: VkPhysicalDeviceYcbcrDegammaFeaturesQCOM
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceYcbcrDegammaFeaturesQCOM.adoc[]
--
endif::VK_QCOM_ycbcr_degamma[]

ifdef::VK_QCOM_filter_cubic_weights[]
[open,refpage='VkPhysicalDeviceCubicWeightsFeaturesQCOM',desc='Structure describing cubic weight selection features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCubicWeightsFeaturesQCOM structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceCubicWeightsFeaturesQCOM.adoc[]

This structure describes the following feature:

  * [[features-filter-cubic-weight-selection]] pname:selectableCubicWeights
    indicates that the implementation supports the selection of filter cubic
    weights.

:refpage: VkPhysicalDeviceCubicWeightsFeaturesQCOM
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCubicWeightsFeaturesQCOM.adoc[]
--
endif::VK_QCOM_filter_cubic_weights[]

ifdef::VK_NV_descriptor_pool_overallocation[]
[open,refpage='VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV',desc='Structure describing feature to allow descriptor pool overallocation',type='structs']
--
The sname:VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-descriptorPoolOverallocation]]
    pname:descriptorPoolOverallocation indicates that the implementation
    allows the application to opt into descriptor pool overallocation by
    creating the descriptor pool with
    ename:VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV and/or
    ename:VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV flags.

:refpage: VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV.adoc[]
--
endif::VK_NV_descriptor_pool_overallocation[]

ifdef::VK_NV_per_stage_descriptor_set[]
[open,refpage='VkPhysicalDevicePerStageDescriptorSetFeaturesNV',desc='Structure describing feature to allow descriptor set layout bindings to be per-stage',type='structs']
--
The sname:VkPhysicalDevicePerStageDescriptorSetFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDevicePerStageDescriptorSetFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-perStageDescriptorSet]] pname:perStageDescriptorSet indicates
    that the implementation allows the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV descriptor set
    layout creation flag to be used so the bindings are specified per-stage
    rather than across all stages.
  * [[features-dynamicPipelineLayout]] pname:dynamicPipelineLayout indicates
    the implementation allows the pname:layout member of
    slink:VkBindDescriptorSetsInfoKHR, slink:VkPushConstantsInfoKHR,
    slink:VkPushDescriptorSetInfoKHR,
    slink:VkPushDescriptorSetWithTemplateInfoKHR,
    slink:VkSetDescriptorBufferOffsetsInfoEXT and
    slink:VkBindDescriptorBufferEmbeddedSamplersInfoEXT to be
    dlink:VK_NULL_HANDLE and slink:VkPipelineLayoutCreateInfo can: be
    chained off those structures' pname:pNext instead.

:refpage: VkPhysicalDevicePerStageDescriptorSetFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePerStageDescriptorSetFeaturesNV.adoc[]

--
endif::VK_NV_per_stage_descriptor_set[]

ifdef::VK_NV_cuda_kernel_launch[]
[open,refpage='VkPhysicalDeviceCudaKernelLaunchFeaturesNV',desc='Structure describing whether cuda kernel launch is supported by the implementation',type='structs']
--
The sname:VkPhysicalDeviceCudaKernelLaunchFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCudaKernelLaunchFeaturesNV.adoc[]

This structure describes the following features:

  * [[features-cudaKernelLaunchFeatures]] pname:cudaKernelLaunchFeatures is
    non-zero if cuda kernel launch is supported.

:refpage: VkPhysicalDeviceCudaKernelLaunchFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCudaKernelLaunchFeaturesNV.adoc[]
--
endif::VK_NV_cuda_kernel_launch[]

ifdef::VK_KHR_shader_maximal_reconvergence[]
[open,refpage='VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR',desc='Structure describing support for shader maximal reconvergence by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderMaximalReconvergence]] pname:shaderMaximalReconvergence
    specifies whether the implementation supports the shader execution mode
    code:MaximallyReconvergesKHR

:refpage: VkPhysicalDevicePrivateDataFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR.adoc[]
--
endif::VK_KHR_shader_maximal_reconvergence[]

ifdef::VK_ANDROID_external_format_resolve[]

[open,refpage='VkPhysicalDeviceExternalFormatResolveFeaturesANDROID',desc='Structure describing whether external format resolves are supported',type='structs']
--
The sname:VkPhysicalDeviceExternalFormatResolveFeaturesANDROID structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceExternalFormatResolveFeaturesANDROID.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-externalFormatResolve]] pname:externalFormatResolve specifies
    whether external format resolves are supported.

:refpage: VkPhysicalDeviceExternalFormatResolveFeaturesANDROID
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExternalFormatResolveFeaturesANDROID.adoc[]
--

endif::VK_ANDROID_external_format_resolve[]

ifdef::VK_ARM_scheduling_controls[]
[open,refpage='VkPhysicalDeviceSchedulingControlsFeaturesARM',desc='Structure describing scheduling controls features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceSchedulingControlsFeaturesARM structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceSchedulingControlsFeaturesARM.adoc[]

This structure describes the following features:

  * [[features-schedulingControls]] pname:schedulingControls indicates that
    the implementation supports scheduling controls.

:refpage: VkPhysicalDeviceSchedulingControlsFeaturesARM
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceSchedulingControlsFeaturesARM.adoc[]
--
endif::VK_ARM_scheduling_controls[]

ifdef::VK_IMG_relaxed_line_rasterization[]
[open,refpage='VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG',desc='Structure describing relaxed line rasterization features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-relaxedLineRasterization]] pname:relaxedLineRasterization
    indicates that the implementation supports relaxed line rasterization
    control.

:refpage: VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG.adoc[]
--
endif::VK_IMG_relaxed_line_rasterization[]

ifdef::VK_ARM_render_pass_striped[]
[open,refpage='VkPhysicalDeviceRenderPassStripedFeaturesARM',desc='Structure describing whether striped rendering can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRenderPassStripedFeaturesARM structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceRenderPassStripedFeaturesARM.adoc[]

The members of the sname:VkPhysicalDeviceRenderPassStripedFeaturesARM
structure describe the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-renderPassStriped]] pname:renderPassStriped indicates that
    striped rendering is supported by the implementation.

:refpage: VkPhysicalDeviceRenderPassStripedFeaturesARM
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRenderPassStripedFeaturesARM.adoc[]
--
endif::VK_ARM_render_pass_striped[]

ifdef::VK_KHR_shader_subgroup_rotate[]
[open,refpage='VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR',desc='Structure describing whether subgroup rotation is enabled',type='structs']
--
The sname:VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderSubgroupRotate]] pname:shaderSubgroupRotate specifies
    whether shader modules can: declare the code:GroupNonUniformRotateKHR
    capability.
  * [[features-shaderSubgroupRotateClustered]]
    pname:shaderSubgroupRotateClustered specifies whether shader modules
    can: use the code:ClusterSize operand to
    code:OpGroupNonUniformRotateKHR.

:refpage: VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR.adoc[]
--
endif::VK_KHR_shader_subgroup_rotate[]

ifdef::VK_KHR_shader_expect_assume[]
[open,refpage='VkPhysicalDeviceShaderExpectAssumeFeaturesKHR',desc='Structure describing shader expect assume features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderExpectAssumeFeaturesKHR structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderExpectAssumeFeaturesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderExpectAssume]] pname:shaderExpectAssume specifies
    whether shader modules can: declare the code:ExpectAssumeKHR capability.

:refpage: VkPhysicalDeviceShaderExpectAssumeFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderExpectAssumeFeaturesKHR.adoc[]
--
endif::VK_KHR_shader_expect_assume[]


ifdef::VK_KHR_dynamic_rendering_local_read[]
[open,refpage='VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR',desc='Structure indicating support for local reads in dynamic render pass instances',type='structs']
--
The sname:VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-dynamicRenderingLocalRead]] pname:dynamicRenderingLocalRead
    specifies that the implementation supports local reads inside dynamic
    render pass instances using the flink:vkCmdBeginRendering command.

:refpage: VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR.adoc[]
--
endif::VK_KHR_dynamic_rendering_local_read[]


ifdef::VK_KHR_shader_quad_control[]
[open,refpage='VkPhysicalDeviceShaderQuadControlFeaturesKHR',desc='Structure describing whether quad scopes are supported by the implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderQuadControlFeaturesKHR structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderQuadControlFeaturesKHR.adoc[]

This structure describes the following features:

  * [[features-shaderQuadControl]] pname:shaderQuadControl indicates whether
    the implementation supports shaders with the code:QuadControlKHR
    capability.

:refpage: VkPhysicalDeviceShaderQuadControlFeaturesKHR
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderQuadControlFeaturesKHR.adoc[]
--
endif::VK_KHR_shader_quad_control[]

ifdef::VK_EXT_map_memory_placed[]
[open,refpage='VkPhysicalDeviceMapMemoryPlacedFeaturesEXT',desc='Structure describing placed memory map features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMapMemoryPlacedFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceMapMemoryPlacedFeaturesEXT.adoc[]

This structure describes the following features:

  * [[features-memoryMapPlaced]] pname:memoryMapPlaced indicates that the
    implementation supports placing memory maps at client-specified virtual
    addresses.
  * [[features-memoryMapRangePlaced]] pname:memoryMapRangePlaced indicates
    that the implementation supports placing memory maps of a subrange of a
    memory object at client-specified virtual addresses.
  * [[features-memoryUnmapReserve]] pname:memoryUnmapReserve indicates that
    the implementation supports leaving the memory range reserved when
    unmapping a memory object.

:refpage: VkPhysicalDeviceMapMemoryPlacedFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMapMemoryPlacedFeaturesEXT.adoc[]
--
endif::VK_EXT_map_memory_placed[]


ifdef::VK_NV_shader_atomic_float16_vector[]
[open,refpage='VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV',desc='Structure describing features supported by VK_NV_shader_atomic_float16_vector',type='structs']
--
The slink:VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// tag::VK_NV_shader_atomic_float16_vector-features[]
  * [[features-shaderFloat16VectorAtomics]] pname:shaderFloat16VectorAtomics
    indicates whether shaders can: perform 16-bit floating-point, 2- and
    4-component vector atomic operations.
// end::VK_NV_shader_atomic_float16_vector-features[]

:refpage: VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV.adoc[]
--
endif::VK_NV_shader_atomic_float16_vector[]

ifdef::VK_NV_raw_access_chains[]
[open,refpage='VkPhysicalDeviceRawAccessChainsFeaturesNV', desc='Structure describing shader raw access chains features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRawAccessChainsFeaturesNV structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceRawAccessChainsFeaturesNV.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderRawAccessChains]] pname:shaderRawAccessChains specifies
    whether shader modules can: declare the code:RawAccessChainsNV
    capability.

:refpage: VkPhysicalDeviceRawAccessChainsFeaturesNV
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRawAccessChainsFeaturesNV.adoc[]
--
endif::VK_NV_raw_access_chains[]

ifdef::VK_MESA_image_alignment_control[]
[open,refpage='VkPhysicalDeviceImageAlignmentControlFeaturesMESA', desc='Structure describing features supported by VK_MESA_image_alignment_control',type='structs']
--
The sname:VkPhysicalDeviceImageAlignmentControlFeaturesMESA structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceImageAlignmentControlFeaturesMESA.adoc[]

This structure describes the following feature:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-imageAlignmentControl]] pname:imageAlignmentControl specifies
    that slink:VkImageAlignmentControlCreateInfoMESA can: be chained in
    slink:VkImageCreateInfo

:refpage: VkPhysicalDeviceImageAlignmentControlFeaturesMESA
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceImageAlignmentControlFeaturesMESA.adoc[]
--
endif::VK_MESA_image_alignment_control[]

ifdef::VK_EXT_shader_replicated_composites[]
[open,refpage='VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT',desc='Structure describing whether support for replicated composites in SPIR-V is enabled',type='structs']
--
The sname:VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderReplicatedComposites]] pname:shaderReplicatedComposites
    specifies whether shader modules can: declare the
    code:ReplicatedCompositesEXT capability.

:refpage: VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT.adoc[]
--
endif::VK_EXT_shader_replicated_composites[]

[[features-requirements]]
== Feature Requirements

All Vulkan graphics implementations must: support the following features:

ifdef::VK_KHR_portability_subset[]
  * <<features-robustBufferAccess, pname:robustBufferAccess>>, unless the
    `apiext:VK_KHR_portability_subset` extension is enabled.
endif::VK_KHR_portability_subset[]
ifndef::VK_KHR_portability_subset[]
  * <<features-robustBufferAccess, pname:robustBufferAccess>>
endif::VK_KHR_portability_subset[]
ifdef::VK_VERSION_1_1[]
  * <<features-multiview, pname:multiview>>, if Vulkan 1.1 is supported.
ifdef::VKSC_VERSION_1_0[]
    Vulkan SC 1.0 does not require pname:multiview to be supported
    <<SCID-8>>.
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkPhysicalDeviceVulkan11Features::pname:multiview is made optional
    <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]
ifdef::VK_KHR_shader_draw_parameters[]
  * <<features-shaderDrawParameters, pname:shaderDrawParameters>>, if the
    `apiext:VK_KHR_shader_draw_parameters` extension is supported.
endif::VK_KHR_shader_draw_parameters[]
endif::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_2,VK_KHR_uniform_buffer_standard_layout[]
  * <<features-uniformBufferStandardLayout,
    pname:uniformBufferStandardLayout>>, if Vulkan 1.2 or the
    `apiext:VK_KHR_uniform_buffer_standard_layout` extension is supported.
endif::VK_VERSION_1_2,VK_KHR_uniform_buffer_standard_layout[]
ifdef::VK_KHR_variable_pointers[]
  * <<features-variablePointersStorageBuffer,
    pname:variablePointersStorageBuffer>>, if the
    `apiext:VK_KHR_variable_pointers` extension is supported.
endif::VK_KHR_variable_pointers[]
ifdef::VK_KHR_8bit_storage[]
  * <<features-storageBuffer8BitAccess, pname:storageBuffer8BitAccess>>, if
    the `apiext:VK_KHR_8bit_storage` extension is supported.
endif::VK_KHR_8bit_storage[]
ifdef::VK_VERSION_1_2,VK_KHR_8bit_storage[]
  * <<features-storageBuffer8BitAccess, pname:storageBuffer8BitAccess>>, if
    <<features-uniformAndStorageBuffer8BitAccess,
    pname:uniformAndStorageBuffer8BitAccess>> is enabled.
endif::VK_VERSION_1_2,VK_KHR_8bit_storage[]
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  * If
ifdef::VK_VERSION_1_2[the <<features-descriptorIndexing, pname:descriptorIndexing>> feature is supported, or if]
    the `apiext:VK_EXT_descriptor_indexing` extension is supported:
  ** <<features-shaderSampledImageArrayDynamicIndexing,
     pname:shaderSampledImageArrayDynamicIndexing>>
  ** <<features-shaderStorageBufferArrayDynamicIndexing,
     pname:shaderStorageBufferArrayDynamicIndexing>>
  ** <<features-shaderUniformTexelBufferArrayDynamicIndexing,
     pname:shaderUniformTexelBufferArrayDynamicIndexing>>
  ** <<features-shaderStorageTexelBufferArrayDynamicIndexing,
     pname:shaderStorageTexelBufferArrayDynamicIndexing>>
  ** <<features-shaderSampledImageArrayNonUniformIndexing,
     pname:shaderSampledImageArrayNonUniformIndexing>>
  ** <<features-shaderStorageBufferArrayNonUniformIndexing,
     pname:shaderStorageBufferArrayNonUniformIndexing>>
  ** <<features-shaderUniformTexelBufferArrayNonUniformIndexing,
     pname:shaderUniformTexelBufferArrayNonUniformIndexing>>
  ** <<features-descriptorBindingSampledImageUpdateAfterBind,
     pname:descriptorBindingSampledImageUpdateAfterBind>>
  ** <<features-descriptorBindingStorageImageUpdateAfterBind,
     pname:descriptorBindingStorageImageUpdateAfterBind>>
  ** <<features-descriptorBindingStorageBufferUpdateAfterBind,
     pname:descriptorBindingStorageBufferUpdateAfterBind>> (see also
     <<limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-descriptorBindingUniformTexelBufferUpdateAfterBind,
     pname:descriptorBindingUniformTexelBufferUpdateAfterBind>> (see also
     <<limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-descriptorBindingStorageTexelBufferUpdateAfterBind,
     pname:descriptorBindingStorageTexelBufferUpdateAfterBind>> (see also
     <<limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-descriptorBindingUpdateUnusedWhilePending,
     pname:descriptorBindingUpdateUnusedWhilePending>>
  ** <<features-descriptorBindingPartiallyBound,
     pname:descriptorBindingPartiallyBound>>
  ** <<features-runtimeDescriptorArray, pname:runtimeDescriptorArray>>
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
ifdef::VK_VERSION_1_3[]
  * If Vulkan 1.3 is supported:
  ** <<features-vulkanMemoryModel, pname:vulkanMemoryModel>>
  ** <<features-vulkanMemoryModelDeviceScope,
     pname:vulkanMemoryModelDeviceScope>>
endif::VK_VERSION_1_3[]
ifdef::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]
  * <<features-inlineUniformBlock, pname:inlineUniformBlock>>, if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_EXT_inline_uniform_block` extension is supported.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  * <<features-descriptorBindingInlineUniformBlockUpdateAfterBind,
    pname:descriptorBindingInlineUniformBlockUpdateAfterBind>>, if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_EXT_inline_uniform_block` extension is supported; and if
ifdef::VK_VERSION_1_2[the <<features-descriptorIndexing, pname:descriptorIndexing>> feature is supported, or]
    the `apiext:VK_EXT_descriptor_indexing` extension is supported.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
endif::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]
ifdef::VK_EXT_scalar_block_layout[]
  * <<features-scalarBlockLayout, pname:scalarBlockLayout>>, if the
    `apiext:VK_EXT_scalar_block_layout` extension is supported.
endif::VK_EXT_scalar_block_layout[]
ifdef::VK_VERSION_1_2[]
  * <<features-subgroupBroadcastDynamicId,
    pname:subgroupBroadcastDynamicId>>, if Vulkan 1.2 is supported.
endif::VK_VERSION_1_2[]
ifdef::VK_VERSION_1_2+VK_KHR_sampler_mirror_clamp_to_edge[]
  * <<features-samplerMirrorClampToEdge, pname:samplerMirrorClampToEdge>>,
    if the `apiext:VK_KHR_sampler_mirror_clamp_to_edge` extension is
    supported.
endif::VK_VERSION_1_2+VK_KHR_sampler_mirror_clamp_to_edge[]
ifdef::VK_VERSION_1_2+VK_KHR_draw_indirect_count[]
  * <<features-drawIndirectCount, pname:drawIndirectCount>>, if the
    `apiext:VK_KHR_draw_indirect_count` extension is supported.
endif::VK_VERSION_1_2+VK_KHR_draw_indirect_count[]
ifdef::VK_VERSION_1_2+VK_EXT_sampler_filter_minmax[]
  * <<features-samplerFilterMinmax, pname:samplerFilterMinmax>>, if the
    `apiext:VK_EXT_sampler_filter_minmax` extension is supported.
endif::VK_VERSION_1_2+VK_EXT_sampler_filter_minmax[]
ifdef::VK_VERSION_1_2+VK_EXT_shader_viewport_index_layer[]
  * <<features-shaderOutputViewportIndex, pname:shaderOutputViewportIndex>>,
    if the `apiext:VK_EXT_shader_viewport_index_layer` extension is
    supported.
  * <<features-shaderOutputLayer, pname:shaderOutputLayer>>, if the
    `apiext:VK_EXT_shader_viewport_index_layer` extension is supported.
endif::VK_VERSION_1_2+VK_EXT_shader_viewport_index_layer[]
ifdef::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
  * <<features-subgroupSizeControl, pname:subgroupSizeControl>>, if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_EXT_subgroup_size_control` extension is supported.
  * <<features-computeFullSubgroups, pname:computeFullSubgroups>>, if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_EXT_subgroup_size_control` extension is supported.
endif::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
ifdef::VK_EXT_device_memory_report[]
  * <<features-deviceMemoryReport, pname:deviceMemoryReport>>, if the
    `apiext:VK_EXT_device_memory_report` extension is supported.
endif::VK_EXT_device_memory_report[]
ifdef::VK_EXT_global_priority_query[]
  * <<features-globalPriorityQuery, pname:globalPriorityQuery>>, if the
    `apiext:VK_EXT_global_priority_query` extension is supported.
endif::VK_EXT_global_priority_query[]
ifdef::VK_KHR_global_priority[]
  * <<features-globalPriorityQuery, pname:globalPriorityQuery>>, if the
    `apiext:VK_KHR_global_priority` extension is supported.
endif::VK_KHR_global_priority[]
ifdef::VK_VERSION_1_2,VK_KHR_imageless_framebuffer[]
  * <<features-imagelessFramebuffer, pname:imagelessFramebuffer>>, if Vulkan
    1.2 or the `apiext:VK_KHR_imageless_framebuffer` extension is supported.
endif::VK_VERSION_1_2,VK_KHR_imageless_framebuffer[]
ifdef::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
  * <<features-separateDepthStencilLayouts,
    pname:separateDepthStencilLayouts>>, if Vulkan 1.2 or the
    `apiext:VK_KHR_separate_depth_stencil_layouts` extension is supported.
endif::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
ifdef::VK_VERSION_1_2,VK_EXT_host_query_reset[]
  * <<features-hostQueryReset, pname:hostQueryReset>>, if Vulkan 1.2 or the
    `apiext:VK_EXT_host_query_reset` extension is supported.
endif::VK_VERSION_1_2,VK_EXT_host_query_reset[]
ifdef::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]
  * <<features-timelineSemaphore, pname:timelineSemaphore>>, if Vulkan 1.2
    or the `apiext:VK_KHR_timeline_semaphore` extension is supported.
ifdef::VKSC_VERSION_1_0[]
    Vulkan SC 1.0 does not require pname:timelineSemaphore to be supported
    <<SCID-8>>.
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkPhysicalDeviceVulkan12Features::pname:timelineSemaphore is made
    optional <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]
endif::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]
ifdef::VK_KHR_acceleration_structure[]
  * If the `apiext:VK_KHR_acceleration_structure` extension is supported:
  ** <<features-accelerationStructure, pname:accelerationStructure>>
  ** All the features required by
ifdef::VK_VERSION_1_2[the <<features-descriptorIndexing, pname:descriptorIndexing>> feature if Vulkan 1.2 is supported, or]
     the `apiext:VK_EXT_descriptor_indexing` extension.
  ** <<features-descriptorBindingAccelerationStructureUpdateAfterBind,
     pname:descriptorBindingAccelerationStructureUpdateAfterBind>>
  ** <<features-bufferDeviceAddress, pname:bufferDeviceAddress>> from
ifdef::VK_VERSION_1_2[Vulkan 1.2 or]
     the `apiext:VK_KHR_buffer_device_address` extension.
endif::VK_KHR_acceleration_structure[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * If the `apiext:VK_KHR_ray_tracing_pipeline` extension is supported:
  ** <<features-rayTracingPipeline, pname:rayTracingPipeline>>
  ** <<features-rayTracingPipelineTraceRaysIndirect,
     pname:rayTracingPipelineTraceRaysIndirect>>
  ** <<features-rayTraversalPrimitiveCulling,
     pname:rayTraversalPrimitiveCulling>>, if <<features-rayQuery,
     pname:rayQuery>> is supported
  ** the `apiext:VK_KHR_pipeline_library` extension must: be supported.
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_KHR_ray_query[]
  * <<features-rayQuery, pname:rayQuery>>, if the `apiext:VK_KHR_ray_query`
    extension is supported.
endif::VK_KHR_ray_query[]
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * <<features-pipelineCreationCacheControl,
    pname:pipelineCreationCacheControl>>, if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_EXT_pipeline_creation_cache_control` extension is
    supported.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifdef::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]
  * <<features-subgroup-extended-types, pname:shaderSubgroupExtendedTypes>>,
    if Vulkan 1.2 or the `apiext:VK_KHR_shader_subgroup_extended_types`
    extension is supported.
endif::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]
ifdef::VK_KHR_sampler_ycbcr_conversion[]
  * <<features-samplerYcbcrConversion, pname:samplerYcbcrConversion>>, if
    the `apiext:VK_KHR_sampler_ycbcr_conversion` extension is supported.
endif::VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_KHR_pipeline_executable_properties[]
  * <<features-pipelineExecutableInfo, pname:pipelineExecutableInfo>>, if
    the `apiext:VK_KHR_pipeline_executable_properties` extension is
    supported.
endif::VK_KHR_pipeline_executable_properties[]
ifdef::VK_VERSION_1_3,VK_EXT_texture_compression_astc_hdr[]
  * <<features-textureCompressionASTC_HDR,
    pname:textureCompressionASTC_HDR>>, if the
    `apiext:VK_EXT_texture_compression_astc_hdr` extension is supported.
endif::VK_VERSION_1_3,VK_EXT_texture_compression_astc_hdr[]
ifdef::VK_EXT_depth_clip_enable[]
  * <<features-depthClipEnable, pname:depthClipEnable>>, if the
    `apiext:VK_EXT_depth_clip_enable` extension is supported.
endif::VK_EXT_depth_clip_enable[]
ifdef::VK_EXT_memory_priority[]
  * <<features-memoryPriority, pname:memoryPriority>>, if the
    `apiext:VK_EXT_memory_priority` extension is supported.
endif::VK_EXT_memory_priority[]
ifdef::VK_EXT_ycbcr_image_arrays[]
  * <<features-ycbcrImageArrays, pname:ycbcrImageArrays>>, if the
    `apiext:VK_EXT_ycbcr_image_arrays` extension is supported.
endif::VK_EXT_ycbcr_image_arrays[]
ifdef::VK_EXT_index_type_uint8,VK_KHR_index_type_uint8[]
  * <<features-indexTypeUint8, pname:indexTypeUint8>>, if the
ifdef::VK_KHR_index_type_uint8[]
    `apiext:VK_KHR_index_type_uint8`
endif::VK_KHR_index_type_uint8[]
ifdef::VK_EXT_index_type_uint8+VK_KHR_index_type_uint8[]
    or
endif::VK_EXT_index_type_uint8+VK_KHR_index_type_uint8[]
ifdef::VK_EXT_index_type_uint8[]
    `apiext:VK_EXT_index_type_uint8`
endif::VK_EXT_index_type_uint8[]
    extension is supported.
endif::VK_EXT_index_type_uint8,VK_KHR_index_type_uint8[]
ifdef::VK_KHR_index_type_uint8[]
  * <<features-indexTypeUint8, pname:indexTypeUint8>>, if the
    `apiext:VK_KHR_index_type_uint8` extension is supported.
endif::VK_KHR_index_type_uint8[]
ifdef::VK_EXT_primitive_topology_list_restart[]
  * <<features-primitiveTopologyListRestart,
    pname:primitiveTopologyListRestart>>, if the
    `apiext:VK_EXT_primitive_topology_list_restart` extension is supported.
endif::VK_EXT_primitive_topology_list_restart[]
ifdef::VK_VERSION_1_3,VK_EXT_shader_demote_to_helper_invocation[]
  * <<features-shaderDemoteToHelperInvocation,
    pname:shaderDemoteToHelperInvocation>>, if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_EXT_shader_demote_to_helper_invocation` extension is
    supported.
endif::VK_VERSION_1_3,VK_EXT_shader_demote_to_helper_invocation[]
ifdef::VK_VERSION_1_3,VK_EXT_texel_buffer_alignment[]
  * <<features-texelBufferAlignment, pname:texelBufferAlignment>>, if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_EXT_texel_buffer_alignment` extension is supported.
endif::VK_VERSION_1_3,VK_EXT_texel_buffer_alignment[]
ifdef::VK_KHR_vulkan_memory_model,VKSC_VERSION_1_0[]
  * <<features-vulkanMemoryModel, pname:vulkanMemoryModel>>,
ifdef::VKSC_VERSION_1_0[]
    if Vulkan SC 1.0 <<SCID-5>> or
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkPhysicalDeviceVulkan12Features::pname:vulkanMemoryModel must: be
    reported as ename:VK_TRUE <<SCID-1>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]
    if the `apiext:VK_KHR_vulkan_memory_model` extension is supported.
endif::VK_KHR_vulkan_memory_model,VKSC_VERSION_1_0[]
ifdef::VK_VERSION_1_3,VK_KHR_buffer_device_address[]
  * <<features-bufferDeviceAddress, pname:bufferDeviceAddress>>, if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_KHR_buffer_device_address` extension is supported.
endif::VK_VERSION_1_3,VK_KHR_buffer_device_address[]
ifdef::VK_KHR_performance_query[]
  * <<VkPhysicalDevicePerformanceQueryFeaturesKHR,
    pname:performanceCounterQueryPools>>, if the
    `apiext:VK_KHR_performance_query` extension is supported.
endif::VK_KHR_performance_query[]
ifdef::VK_EXT_transform_feedback[]
  * <<features-transformFeedback, pname:transformFeedback>>, if the
    `apiext:VK_EXT_transform_feedback` extension is supported.
endif::VK_EXT_transform_feedback[]
ifdef::VK_EXT_conditional_rendering[]
  * <<features-conditionalRendering, pname:conditionalRendering>>, if the
    `apiext:VK_EXT_conditional_rendering` extension is supported.
endif::VK_EXT_conditional_rendering[]
ifdef::VK_KHR_vertex_attribute_divisor,VK_EXT_vertex_attribute_divisor[]
  * <<features-vertexAttributeInstanceRateDivisor,
    pname:vertexAttributeInstanceRateDivisor>>, if
ifdef::VK_EXT_vertex_attribute_divisor[]
    the `apiext:VK_EXT_vertex_attribute_divisor` extension or
endif::VK_EXT_vertex_attribute_divisor[]
    the `apiext:VK_KHR_vertex_attribute_divisor` extension is supported.
endif::VK_KHR_vertex_attribute_divisor,VK_EXT_vertex_attribute_divisor[]
ifdef::VK_EXT_fragment_density_map[]
  * <<features-fragmentDensityMap, pname:fragmentDensityMap>>, if the
    `apiext:VK_EXT_fragment_density_map` extension is supported.
endif::VK_EXT_fragment_density_map[]
ifdef::VK_KHR_shader_clock[]
  * <<features-shaderSubgroupClock, pname:shaderSubgroupClock>>, if the
    `apiext:VK_KHR_shader_clock` extension is supported.
endif::VK_KHR_shader_clock[]
ifdef::VK_KHR_shader_atomic_int64[]
  * <<features-shaderBufferInt64Atomics, pname:shaderBufferInt64Atomics>>,
    if the `apiext:VK_KHR_shader_atomic_int64` extension is supported.
endif::VK_KHR_shader_atomic_int64[]
ifdef::VK_VERSION_1_2,VK_KHR_shader_atomic_int64[]
  * <<features-shaderInt64, pname:shaderInt64>>, if the
    <<features-shaderSharedInt64Atomics, pname:shaderSharedInt64Atomics>> or
    <<features-shaderBufferInt64Atomics, pname:shaderBufferInt64Atomics>>
    features are supported.
endif::VK_VERSION_1_2,VK_KHR_shader_atomic_int64[]
ifdef::VK_KHR_shader_float16_int8[]
  * <<features-shaderFloat16, pname:shaderFloat16>> or
    <<features-shaderInt8, pname:shaderInt8>>, if the
    `apiext:VK_KHR_shader_float16_int8` extension is supported.
endif::VK_KHR_shader_float16_int8[]
ifdef::VK_EXT_fragment_shader_interlock[]
  * <<features-fragmentShaderSampleInterlock,
    pname:fragmentShaderSampleInterlock>> or
    <<features-fragmentShaderPixelInterlock,
    pname:fragmentShaderPixelInterlock>> or
    <<features-fragmentShaderShadingRateInterlock,
    pname:fragmentShaderShadingRateInterlock>>, if the
    `apiext:VK_EXT_fragment_shader_interlock` extension is supported.
endif::VK_EXT_fragment_shader_interlock[]
ifdef::VK_KHR_line_rasterization[]
  * <<features-rectangularLines, pname:rectangularLines>> or
    <<features-bresenhamLines, pname:bresenhamLines>> or
    <<features-smoothLines, pname:smoothLines>> or
    <<features-stippledRectangularLines, pname:stippledRectangularLines>> or
    <<features-stippledBresenhamLines, pname:stippledBresenhamLines>> or
    <<features-stippledSmoothLines, pname:stippledSmoothLines>>, if the
    `apiext:VK_KHR_line_rasterization` extension is supported.
endif::VK_KHR_line_rasterization[]
ifdef::VK_EXT_line_rasterization[]
  * <<features-rectangularLines, pname:rectangularLines>> or
    <<features-bresenhamLines, pname:bresenhamLines>> or
    <<features-smoothLines, pname:smoothLines>> or
    <<features-stippledRectangularLines, pname:stippledRectangularLines>> or
    <<features-stippledBresenhamLines, pname:stippledBresenhamLines>> or
    <<features-stippledSmoothLines, pname:stippledSmoothLines>>, if the
    `apiext:VK_EXT_line_rasterization` extension is supported.
endif::VK_EXT_line_rasterization[]
ifdef::VK_KHR_16bit_storage[]
  * <<features-storageBuffer16BitAccess, pname:storageBuffer16BitAccess>>,
    if the `apiext:VK_KHR_16bit_storage` extension is supported.
endif::VK_KHR_16bit_storage[]
ifdef::VK_VERSION_1_1,VK_KHR_16bit_storage[]
  * <<features-storageBuffer16BitAccess, pname:storageBuffer16BitAccess>>,
    if <<features-uniformAndStorageBuffer16BitAccess,
    pname:uniformAndStorageBuffer16BitAccess>> is enabled.
endif::VK_VERSION_1_1,VK_KHR_16bit_storage[]
ifdef::VK_VERSION_1_3,VK_EXT_image_robustness[]
  * <<features-robustImageAccess, pname:robustImageAccess>>, if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_EXT_image_robustness` extension is supported.
endif::VK_VERSION_1_3,VK_EXT_image_robustness[]
ifdef::VK_EXT_4444_formats[]
  * <<features-formatA4R4G4B4, pname:formatA4R4G4B4>>, if the
    `apiext:VK_EXT_4444_formats` extension is supported.
endif::VK_EXT_4444_formats[]
ifdef::VK_EXT_mutable_descriptor_type,VK_VALVE_mutable_descriptor_type[]
  * <<features-mutableDescriptorType, pname:mutableDescriptorType>>, if the
    `apiext:VK_EXT_mutable_descriptor_type` or
    `apiext:VK_VALVE_mutable_descriptor_type` extension is supported.
endif::VK_EXT_mutable_descriptor_type,VK_VALVE_mutable_descriptor_type[]
ifdef::VK_EXT_shader_image_atomic_int64[]
  * <<features-shaderInt64, pname:shaderInt64>> and
    <<features-shaderImageInt64Atomics, pname:shaderImageInt64Atomics>>, if
    the `apiext:VK_EXT_shader_image_atomic_int64` extension is supported.
  * <<features-shaderImageInt64Atomics, pname:shaderImageInt64Atomics>>, if
    the <<features-sparseImageInt64Atomics, pname:sparseImageInt64Atomics>>
    feature is supported.
endif::VK_EXT_shader_image_atomic_int64[]
ifdef::VK_EXT_shader_atomic_float[]
  * <<features-shaderImageFloat32Atomics, pname:shaderImageFloat32Atomics>>,
    if the <<features-sparseImageFloat32Atomics,
    pname:sparseImageFloat32Atomics>> feature is supported.
  * <<features-shaderImageFloat32AtomicAdd,
    pname:shaderImageFloat32AtomicAdd>>, if the
    <<features-sparseImageFloat32AtomicAdd,
    pname:sparseImageFloat32AtomicAdd>> feature is supported.
endif::VK_EXT_shader_atomic_float[]
ifdef::VK_EXT_primitives_generated_query[]
  * <<features-primitivesGeneratedQuery, pname:primitivesGeneratedQuery>>,
    if the `apiext:VK_EXT_primitives_generated_query` extension is
    supported.
endif::VK_EXT_primitives_generated_query[]
ifdef::VK_KHR_fragment_shading_rate[]
  * <<features-pipelineFragmentShadingRate,
    pname:pipelineFragmentShadingRate>>, if the
    `apiext:VK_KHR_fragment_shading_rate` extension is supported.
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_EXT_pipeline_protected_access[]
  * <<features-pipelineProtectedAccess, pname:pipelineProtectedAccess>>, if
    the `apiext:VK_EXT_pipeline_protected_access` extension is supported.
endif::VK_EXT_pipeline_protected_access[]
ifdef::VK_EXT_legacy_dithering[]
  * <<features-legacyDithering, pname:legacyDithering>>, if the
    `apiext:VK_EXT_legacy_dithering` extension is supported.
endif::VK_EXT_legacy_dithering[]
ifdef::VK_VERSION_1_3,VK_KHR_shader_terminate_invocation[]
  * <<features-shaderTerminateInvocation, pname:shaderTerminateInvocation>>
    if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_KHR_shader_terminate_invocation` extension is supported.
endif::VK_VERSION_1_3,VK_KHR_shader_terminate_invocation[]
ifdef::VK_VERSION_1_3,VK_KHR_zero_initialize_workgroup_memory[]
  * <<features-shaderZeroInitializeWorkgroupMemory,
    pname:shaderZeroInitializeWorkgroupMemory>>, if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_KHR_zero_initialize_workgroup_memory` extension is
    supported.
endif::VK_VERSION_1_3,VK_KHR_zero_initialize_workgroup_memory[]
ifdef::VK_KHR_workgroup_memory_explicit_layout[]
  * <<features-workgroupMemoryExplicitLayout,
    pname:workgroupMemoryExplicitLayout>>, if the
    `apiext:VK_KHR_workgroup_memory_explicit_layout` extension is supported.
endif::VK_KHR_workgroup_memory_explicit_layout[]
ifdef::VK_EXT_vertex_input_dynamic_state[]
  * <<features-vertexInputDynamicState, pname:vertexInputDynamicState>>, if
    the `apiext:VK_EXT_vertex_input_dynamic_state` extension is supported.
endif::VK_EXT_vertex_input_dynamic_state[]
ifdef::VK_VERSION_1_3,VK_KHR_synchronization2[]
  * <<features-synchronization2, pname:synchronization2>> if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_KHR_synchronization2` extension is supported.
endif::VK_VERSION_1_3,VK_KHR_synchronization2[]
ifdef::VK_EXT_provoking_vertex[]
  * <<features-provokingVertexLast, pname:provokingVertexLast>>, if the
    `apiext:VK_EXT_provoking_vertex` extension is supported.
endif::VK_EXT_provoking_vertex[]
ifdef::VK_EXT_descriptor_buffer[]
  * <<features-descriptorBuffer, pname:descriptorBuffer>>, if the
    `<<VK_EXT_descriptor_buffer>>` extension is supported.
endif::VK_EXT_descriptor_buffer[]
ifdef::VK_KHR_shader_subgroup_uniform_control_flow[]
  * <<features-shaderSubgroupUniformControlFlow,
    pname:shaderSubgroupUniformControlFlow>>, if the
    `apiext:VK_KHR_shader_subgroup_uniform_control_flow` extension is
    supported.
endif::VK_KHR_shader_subgroup_uniform_control_flow[]
ifdef::VK_EXT_border_color_swizzle[]
  * <<features-borderColorSwizzle, pname:borderColorSwizzle>> if the
    `apiext:VK_EXT_border_color_swizzle` extension is supported.
endif::VK_EXT_border_color_swizzle[]
ifdef::VK_EXT_multi_draw[]
  * <<features-multiDraw, pname:multiDraw>>, if the
    `apiext:VK_EXT_multi_draw` extension is supported.
endif::VK_EXT_multi_draw[]
ifdef::VK_EXT_shader_atomic_float2[]
  * <<features-shaderImageFloat32AtomicMinMax,
    pname:shaderImageFloat32AtomicMinMax>>, if the
    <<features-sparseImageFloat32AtomicMinMax,
    pname:sparseImageFloat32AtomicMinMax>> feature is supported.
endif::VK_EXT_shader_atomic_float2[]
ifdef::VK_KHR_present_id[]
  * <<features-presentId, pname:presentId>>, if the
    `apiext:VK_KHR_present_id` extension is supported.
endif::VK_KHR_present_id[]
ifdef::VK_KHR_present_wait[]
  * <<features-presentWait, pname:presentWait>>, if the
    `apiext:VK_KHR_present_wait` extension is supported.
endif::VK_KHR_present_wait[]
ifdef::VK_EXT_host_image_copy[]
  * <<features-hostImageCopy, pname:hostImageCopy>>, if the
    `<<VK_EXT_host_image_copy>>` extension is supported.
endif::VK_EXT_host_image_copy[]
ifdef::VK_VERSION_1_3,VK_KHR_shader_integer_dot_product[]
  * <<features-shaderIntegerDotProduct, pname:shaderIntegerDotProduct>> if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_KHR_shader_integer_dot_product` extension is supported.
endif::VK_VERSION_1_3,VK_KHR_shader_integer_dot_product[]
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
  * <<features-maintenance4, pname:maintenance4>>, if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_KHR_maintenance4` extension is supported.
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]
ifdef::VK_KHR_maintenance5[]
  * <<features-maintenance5, pname:maintenance5>>, if the
    `apiext:VK_KHR_maintenance5` extension is supported.
endif::VK_KHR_maintenance5[]
ifdef::VK_KHR_maintenance6[]
  * <<features-maintenance6, pname:maintenance6>>, if the
    `apiext:VK_KHR_maintenance6` extension is supported.
endif::VK_KHR_maintenance6[]
ifdef::VK_EXT_image_2d_view_of_3d[]
  * <<features-image2DViewOf3D, pname:image2DViewOf3D>>, if the
    `apiext:VK_EXT_image_2d_view_of_3d` extension is supported.
endif::VK_EXT_image_2d_view_of_3d[]
ifdef::VK_EXT_image_sliced_view_of_3d[]
  * <<features-imageSlicedViewOf3D, pname:imageSlicedViewOf3D>>, if the
    `apiext:VK_EXT_image_sliced_view_of_3d` extension is supported.
endif::VK_EXT_image_sliced_view_of_3d[]
ifdef::VK_VERSION_1_3,VK_EXT_private_data[]
  * <<features-privateData, pname:privateData>>, if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_EXT_private_data` extension is supported.
endif::VK_VERSION_1_3,VK_EXT_private_data[]
ifdef::VK_EXT_extended_dynamic_state[]
  * <<features-extendedDynamicState, pname:extendedDynamicState>>, if the
    `apiext:VK_EXT_extended_dynamic_state` extension is supported.
endif::VK_EXT_extended_dynamic_state[]
ifdef::VK_EXT_extended_dynamic_state2[]
  * <<features-extendedDynamicState2, pname:extendedDynamicState2>>, if the
    `apiext:VK_EXT_extended_dynamic_state2` extension is supported.
endif::VK_EXT_extended_dynamic_state2[]
ifdef::VK_EXT_depth_clip_control[]
  * <<features-depthClipControl, pname:depthClipControl>>, if the
    `apiext:VK_EXT_depth_clip_control` extension is supported.
endif::VK_EXT_depth_clip_control[]
ifdef::VK_EXT_image_view_min_lod[]
  * <<features-minLod, pname:minLod>>, if the
    `apiext:VK_EXT_image_view_min_lod` extension is supported.
endif::VK_EXT_image_view_min_lod[]
ifdef::VK_NV_external_sci_sync[]
  * At least one of <<features-sciSyncFence, pname:sciSyncFence>> and
    <<features-sciSyncSemaphore, pname:sciSyncSemaphore>>, and at least one
    of <<features-sciSyncImport, pname:sciSyncImport>> and
    <<features-sciSyncExport, pname:sciSyncExport>>, if the
    `apiext:VK_NV_external_sci_sync` extension is supported.
endif::VK_NV_external_sci_sync[]
ifdef::VK_NV_external_sci_sync2[]
  * At least one of <<features-sciSyncFence2, pname:sciSyncFence>> and
    <<features-sciSyncSemaphore2, pname:sciSyncSemaphore2>>, and at least
    one of <<features-sciSyncImport2, pname:sciSyncImport>> and
    <<features-sciSyncExport2, pname:sciSyncExport>>, if the
    `apiext:VK_NV_external_sci_sync2` extension is supported.
endif::VK_NV_external_sci_sync2[]
ifdef::VK_NV_external_memory_sci_buf[]
  * At least one of <<features-sciBufImport, pname:sciBufImport>> and
    <<features-sciBufExport, pname:sciBufExport>>, if the
    `apiext:VK_NV_external_memory_sci_buf` extension is supported.
endif::VK_NV_external_memory_sci_buf[]
ifdef::VK_NV_linear_color_attachment[]
  * <<features-linearColorAttachment, pname:linearColorAttachment>>, if the
    `apiext:VK_NV_linear_color_attachment` extension is supported.
endif::VK_NV_linear_color_attachment[]
ifdef::VK_NV_present_barrier[]
  * <<features-presentBarrier, pname:presentBarrier>>, if the
    `apiext:VK_NV_present_barrier` extension is supported.
endif::VK_NV_present_barrier[]
ifdef::VK_EXT_graphics_pipeline_library[]
  * <<features-graphicsPipelineLibrary, pname:graphicsPipelineLibrary>>, if
    the `apiext:VK_EXT_graphics_pipeline_library` extension is supported.
endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * <<features-dynamicRendering, pname:dynamicRendering>>, if
ifdef::VK_VERSION_1_3[Vulkan 1.3 or]
    the `apiext:VK_KHR_dynamic_rendering` extension is supported.
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_EXT_nested_command_buffer[]
  * <<features-nestedCommandBuffer, pname:nestedCommandBuffer>>, if the
    `apiext:VK_EXT_nested_command_buffer` extension is supported.
endif::VK_EXT_nested_command_buffer[]
ifdef::VK_EXT_mesh_shader[]
  * <<features-taskShader, pname:taskShader>> and <<features-meshShader,
    pname:meshShader>>, if the `apiext:VK_EXT_mesh_shader` extension is
    supported.
endif::VK_EXT_mesh_shader[]
ifdef::VK_EXT_mesh_shader+VK_KHR_fragment_shading_rate[]
  * <<features-primitiveFragmentShadingRate,
    pname:primitiveFragmentShadingRate>> if
    <<features-primitiveFragmentShadingRate-mesh,
    pname:primitiveFragmentShadingRateMeshShader>> feature is supported.
endif::VK_EXT_mesh_shader+VK_KHR_fragment_shading_rate[]
ifdef::VK_EXT_subpass_merge_feedback[]
  * <<features-subpassMergeFeedback, pname:subpassMergeFeedback>>, if the
    `apiext:VK_EXT_subpass_merge_feedback` extension is supported.
endif::VK_EXT_subpass_merge_feedback[]
ifdef::VK_KHR_ray_tracing_maintenance1[]
  * <<features-rayTracingMaintenance1, pname:rayTracingMaintenance1>>, if
    the `apiext:VK_KHR_ray_tracing_maintenance1` extension is supported.
endif::VK_KHR_ray_tracing_maintenance1[]
ifdef::VK_KHR_video_maintenance1[]
  * <<features-videoMaintenance1, pname:videoMaintenance1>>, if the
    `apiext:VK_KHR_video_maintenance1` extension is supported.
endif::VK_KHR_video_maintenance1[]
ifdef::VK_EXT_color_write_enable[]
  * <<features-colorWriteEnable, pname:colorWriteEnable>>, if the
    `apiext:VK_EXT_color_write_enable` extension is supported.
endif::VK_EXT_color_write_enable[]
ifdef::VK_EXT_multisampled_render_to_single_sampled[]
  * <<features-multisampledRenderToSingleSampled,
    pname:multisampledRenderToSingleSampled>>, if the
    `apiext:VK_EXT_multisampled_render_to_single_sampled` extension is
    supported.
endif::VK_EXT_multisampled_render_to_single_sampled[]
ifdef::VK_EXT_image_compression_control[]
  * <<features-imageCompressionControl, pname:imageCompressionControl>>, if
    the `apiext:VK_EXT_image_compression_control` extension is supported.
ifdef::VK_EXT_image_compression_control_swapchain[]
  * <<features-imageCompressionControlSwapchain,
    pname:imageCompressionControlSwapchain>>, if the
    `apiext:VK_EXT_image_compression_control_swapchain` extension is
    supported.
endif::VK_EXT_image_compression_control_swapchain[]
endif::VK_EXT_image_compression_control[]
ifdef::VK_AMD_shader_early_and_late_fragment_tests[]
  * <<features-shaderEarlyAndLateFragmentTests,
    pname:shaderEarlyAndLateFragmentTests>>, if the
    `apiext:VK_AMD_shader_early_and_late_fragment_tests` extension is
    supported.
endif::VK_AMD_shader_early_and_late_fragment_tests[]
ifdef::VK_EXT_non_seamless_cube_map[]
  * <<features-nonSeamlessCubeMap, pname:nonSeamlessCubeMap>>, if the
    `apiext:VK_EXT_non_seamless_cube_map` extension is supported.
endif::VK_EXT_non_seamless_cube_map[]
ifdef::VK_EXT_shader_module_identifier[]
  * <<features-shaderModuleIdentifier, pname:shaderModuleIdentifier>>, if
    `apiext:VK_EXT_shader_module_identifier` extension is supported.
endif::VK_EXT_shader_module_identifier[]
ifdef::VK_EXT_pipeline_robustness[]
  * <<features-pipelineRobustness, pname:pipelineRobustness>>, if the
    `apiext:VK_EXT_pipeline_robustness` extension is supported.
endif::VK_EXT_pipeline_robustness[]
ifdef::VK_QCOM_image_processing[]
  * <<features-textureSampleWeighted, pname:textureSampleWeighted>>,
    <<features-textureBlockMatch, pname:TextureBlockMatch>>, and
    <<features-textureBoxFilter, pname:TextureBoxFilter>> if
    `apiext:VK_QCOM_image_processing` extension is supported.
endif::VK_QCOM_image_processing[]
ifdef::VK_QCOM_image_processing2[]
  * <<features-textureBlockMatch2, pname:TextureBlockMatch2>> if
    `apiext:VK_QCOM_image_processing2` extension is supported.
endif::VK_QCOM_image_processing2[]
ifdef::VK_QCOM_tile_properties[]
  * <<features-tileProperties, pname:tileProperties>> if
    `apiext:VK_QCOM_tile_properties` extension is supported.
endif::VK_QCOM_tile_properties[]
ifdef::VK_EXT_attachment_feedback_loop_layout[]
  * <<features-attachmentFeedbackLoopLayout,
    pname:attachmentFeedbackLoopLayout>>, if the
    `apiext:VK_EXT_attachment_feedback_loop_layout` extension is supported.
endif::VK_EXT_attachment_feedback_loop_layout[]
ifdef::VK_EXT_depth_clamp_zero_one[]
  * <<features-depthClampZeroOne, pname:depthClampZeroOne>>, if the
    `apiext:VK_EXT_depth_clamp_zero_one` extension is supported.
endif::VK_EXT_depth_clamp_zero_one[]
ifdef::VK_EXT_device_fault[]
  * <<features-deviceFault, pname:deviceFault>>, if the
    `apiext:VK_EXT_device_fault` extension is supported.
endif::VK_EXT_device_fault[]
ifdef::VK_EXT_device_address_binding_report[]
  * <<features-reportAddressBinding, pname:reportAddressBinding>>, if the
    `apiext:VK_EXT_device_address_binding_report` extension is supported.
endif::VK_EXT_device_address_binding_report[]
ifdef::VK_EXT_opacity_micromap[]
  * <<features-micromap, pname:micromap>>, if the
    `apiext:VK_EXT_opacity_micromap` extension is supported.
endif::VK_EXT_opacity_micromap[]
ifdef::VK_EXT_frame_boundary[]
  * <<features-frameBoundary, pname:frameBoundary>>, if the
    `apiext:VK_EXT_frame_boundary` extension is supported.
endif::VK_EXT_frame_boundary[]
ifdef::VK_NV_displacement_micromap[]
  * <<features-displacementMicromap, pname:displacementMicromap>>, if the
    `apiext:VK_NV_displacement_micromap` extension is supported.
endif::VK_NV_displacement_micromap[]
ifdef::VK_EXT_pipeline_library_group_handles[]
  * <<features-pipelineLibraryGroupHandles,
    pname:pipelineLibraryGroupHandles>>, if the
    `apiext:VK_EXT_pipeline_library_group_handles` extension is supported.
endif::VK_EXT_pipeline_library_group_handles[]
ifdef::VK_EXT_swapchain_maintenance1[]
  * <<features-swapchainMaintenance1, pname:swapchainMaintenance1>>, if the
    `apiext:VK_EXT_swapchain_maintenance1` extension is supported.
endif::VK_EXT_swapchain_maintenance1[]
ifdef::VK_EXT_extended_dynamic_state3[]
  * <<features-tessellationShader, pname:tessellationShader>>, if the
    <<features-extendedDynamicState3TessellationDomainOrigin,
    pname:extendedDynamicState3TessellationDomainOrigin>> feature is
    supported.
  * <<features-depthClamp, pname:depthClamp>>, if the
    <<features-extendedDynamicState3DepthClampEnable,
    pname:extendedDynamicState3DepthClampEnable>> feature is supported.
  * <<features-fillModeNonSolid, pname:fillModeNonSolid>>, if the
    <<features-extendedDynamicState3PolygonMode,
    pname:extendedDynamicState3PolygonMode>> feature is supported.
  * <<features-alphaToOne, pname:alphaToOne>>, if the
    <<features-extendedDynamicState3AlphaToOneEnable,
    pname:extendedDynamicState3AlphaToOneEnable>> feature is supported.
  * <<features-logicOp, pname:logicOp>>, if the
    <<features-extendedDynamicState3LogicOpEnable,
    pname:extendedDynamicState3LogicOpEnable>> feature is supported.
ifdef::VK_EXT_transform_feedback[]
  * <<features-geometryStreams, pname:geometryStreams>>, if the
    <<features-extendedDynamicState3RasterizationStream,
    pname:extendedDynamicState3RasterizationStream>> feature is supported.
endif::VK_EXT_transform_feedback[]
ifdef::VK_EXT_conservative_rasterization[]
  * `apiext:VK_EXT_conservative_rasterization` extension, if the
    <<features-extendedDynamicState3ConservativeRasterizationMode,
    pname:extendedDynamicState3ConservativeRasterizationMode>> feature is
    supported.
  * `apiext:VK_EXT_conservative_rasterization` extension, if the
    <<features-extendedDynamicState3ExtraPrimitiveOverestimationSize,
    pname:extendedDynamicState3ExtraPrimitiveOverestimationSize>> feature is
    supported.
endif::VK_EXT_conservative_rasterization[]
ifdef::VK_EXT_sample_locations[]
  * `apiext:VK_EXT_sample_locations` extension, if the
    <<features-extendedDynamicState3SampleLocationsEnable,
    pname:extendedDynamicState3SampleLocationsEnable>> feature is supported.
endif::VK_EXT_sample_locations[]
ifdef::VK_EXT_blend_operation_advanced[]
  * `apiext:VK_EXT_blend_operation_advanced` extension, if the
    <<features-extendedDynamicState3ColorBlendAdvanced,
    pname:extendedDynamicState3ColorBlendAdvanced>> feature is supported.
endif::VK_EXT_blend_operation_advanced[]
ifdef::VK_EXT_provoking_vertex[]
  * <<features-provokingVertexLast, pname:provokingVertexLast>>, if the
    <<features-extendedDynamicState3ProvokingVertexMode,
    pname:extendedDynamicState3ProvokingVertexMode>> feature is supported.
endif::VK_EXT_provoking_vertex[]
ifdef::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
  * `apiext:VK_KHR_line_rasterization` or `apiext:VK_EXT_line_rasterization`
    extension, if the <<features-extendedDynamicState3LineRasterizationMode,
    pname:extendedDynamicState3LineRasterizationMode>> feature is supported.
  * `apiext:VK_KHR_line_rasterization` or `apiext:VK_EXT_line_rasterization`
    extension, if the <<features-extendedDynamicState3LineStippleEnable,
    pname:extendedDynamicState3LineStippleEnable>> feature is supported.
endif::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
ifdef::VK_EXT_depth_clip_control[]
  * <<features-depthClipControl, pname:depthClipControl>>, if the
    <<features-extendedDynamicState3DepthClipNegativeOneToOne,
    pname:extendedDynamicState3DepthClipNegativeOneToOne>> feature is
    supported.
endif::VK_EXT_depth_clip_control[]
ifdef::VK_NV_clip_space_w_scaling[]
  * `apiext:VK_NV_clip_space_w_scaling` extension, if the
    <<features-extendedDynamicState3ViewportWScalingEnable,
    pname:extendedDynamicState3ViewportWScalingEnable>> feature is
    supported.
endif::VK_NV_clip_space_w_scaling[]
ifdef::VK_NV_viewport_swizzle[]
  * `apiext:VK_NV_viewport_swizzle` extension, if the
    <<features-extendedDynamicState3ViewportSwizzle,
    pname:extendedDynamicState3ViewportSwizzle>> feature is supported.
endif::VK_NV_viewport_swizzle[]
ifdef::VK_NV_fragment_coverage_to_color[]
  * `apiext:VK_NV_fragment_coverage_to_color` extension, if the
    <<features-extendedDynamicState3CoverageToColorEnable,
    pname:extendedDynamicState3CoverageToColorEnable>> feature is supported.
  * `apiext:VK_NV_fragment_coverage_to_color` extension, if the
    <<features-extendedDynamicState3CoverageToColorLocation,
    pname:extendedDynamicState3CoverageToColorLocation>> feature is
    supported.
endif::VK_NV_fragment_coverage_to_color[]
ifdef::VK_NV_framebuffer_mixed_samples[]
  * `apiext:VK_NV_framebuffer_mixed_samples` extension, if the
    <<features-extendedDynamicState3CoverageModulationMode,
    pname:extendedDynamicState3CoverageModulationMode>> feature is
    supported.
  * `apiext:VK_NV_framebuffer_mixed_samples` extension, if the
    <<features-extendedDynamicState3CoverageModulationTableEnable,
    pname:extendedDynamicState3CoverageModulationTableEnable>> feature is
    supported.
  * `apiext:VK_NV_framebuffer_mixed_samples` extension, if the
    <<features-extendedDynamicState3CoverageModulationTable,
    pname:extendedDynamicState3CoverageModulationTable>> feature is
    supported.
endif::VK_NV_framebuffer_mixed_samples[]
ifdef::VK_NV_coverage_reduction_mode[]
  * <<features-coverageReductionMode, pname:coverageReductionMode>>, if the
    <<features-extendedDynamicState3CoverageReductionMode,
    pname:extendedDynamicState3CoverageReductionMode>> feature is supported.
endif::VK_NV_coverage_reduction_mode[]
ifdef::VK_NV_representative_fragment_test[]
  * <<features-representativeFragmentTest,
    pname:representativeFragmentTest>>, if the
    <<features-extendedDynamicState3RepresentativeFragmentTestEnable,
    pname:extendedDynamicState3RepresentativeFragmentTestEnable>> feature is
    supported.
endif::VK_NV_representative_fragment_test[]
ifdef::VK_NV_shading_rate_image[]
  * <<features-shadingRateImage, pname:shadingRateImage>>, if the
    <<features-extendedDynamicState3ShadingRateImageEnable,
    pname:extendedDynamicState3ShadingRateImageEnable>> feature is
    supported.
endif::VK_NV_shading_rate_image[]
endif::VK_EXT_extended_dynamic_state3[]
ifdef::VK_QCOM_multiview_per_view_viewports[]
  * <<features-multiview-per-view-viewports,
    pname:multiviewPerViewViewports>>, if the
    `apiext:VK_QCOM_multiview_per_view_viewports` extension is supported.
endif::VK_QCOM_multiview_per_view_viewports[]
ifdef::VK_EXT_attachment_feedback_loop_dynamic_state[]
  * <<features-attachmentFeedbackLoopDynamicState,
    pname:attachmentFeedbackLoopDynamicState>>, if the
    `apiext:VK_EXT_attachment_feedback_loop_dynamic_state` extension is
    supported.
endif::VK_EXT_attachment_feedback_loop_dynamic_state[]
ifdef::VK_EXT_legacy_vertex_attributes[]
  * <<features-legacyVertexAttributes, pname:legacyVertexAttributes>>, if
    the `apiext:VK_EXT_legacy_vertex_attributes` extension is supported.
endif::VK_EXT_legacy_vertex_attributes[]
ifdef::VK_KHR_ray_tracing_position_fetch[]
  * <<features-rayTracingPositionFetch, pname:rayTracingPositionFetch>>, if
    the `apiext:VK_KHR_ray_tracing_position_fetch` extension is supported.
endif::VK_KHR_ray_tracing_position_fetch[]
ifdef::VK_EXT_shader_object[]
  * <<features-shaderObject, pname:shaderObject>>, if the
    `apiext:VK_EXT_shader_object` extension is supported.
endif::VK_EXT_shader_object[]
ifdef::VK_EXT_shader_tile_image[]
  * <<features-shaderTileImageColorReadAccess,
    pname:shaderTileImageColorReadAccess>>, if the
    `apiext:VK_EXT_shader_tile_image` extension is supported.
endif::VK_EXT_shader_tile_image[]
ifdef::VK_EXT_depth_bias_control[]
  * <<features-depthBiasControl, pname:depthBiasControl>>, if the
    `apiext:VK_EXT_depth_bias_control` extension is supported.
endif::VK_EXT_depth_bias_control[]
ifdef::VK_NV_device_generated_commands_compute[]
  * <<features-deviceGeneratedCompute, pname:deviceGeneratedCompute>>, if
    the `apiext:VK_NV_device_generated_commands_compute` extension is
    supported.
endif::VK_NV_device_generated_commands_compute[]
ifdef::VK_AMDX_shader_enqueue[]
  * <<features-shaderEnqueue, pname:shaderEnqueue>> if the
    `apiext:VK_AMDX_shader_enqueue` extension is supported.
endif::VK_AMDX_shader_enqueue[]
ifdef::VK_KHR_cooperative_matrix[]
  * <<features-cooperativeMatrix, pname:cooperativeMatrix>> if the
    `apiext:VK_KHR_cooperative_matrix` extension is supported.
endif::VK_KHR_cooperative_matrix[]
ifdef::VK_QCOM_ycbcr_degamma[]
  * <<features-ycbcr-degamma,pname:ycbcrDegamma>>, if the
    `apiext:VK_QCOM_ycbcr_degamma` extension is supported.
endif::VK_QCOM_ycbcr_degamma[]
ifdef::VK_NV_descriptor_pool_overallocation[]
  * <<features-descriptorPoolOverallocation,pname:descriptorPoolOverallocation>>,
    if the `apiext:VK_NV_descriptor_pool_overallocation` extension is
    supported.
endif::VK_NV_descriptor_pool_overallocation[]
ifdef::VK_ANDROID_external_format_resolve[]
  * <<features-externalFormatResolve, pname:externalFormatResolve>>, if the
    `apiext:VK_ANDROID_external_format_resolve` extension is supported.
endif::VK_ANDROID_external_format_resolve[]
ifdef::VK_NV_extended_sparse_address_space[]
  * <<features-extendedSparseAddressSpace,
    pname:extendedSparseAddressSpace>>, if the
    `apiext:VK_NV_extended_sparse_address_space` extension is supported.
endif::VK_NV_extended_sparse_address_space[]
ifdef::VK_ARM_scheduling_controls[]
  * <<features-schedulingControls,pname:schedulingControls>>, if the
    `apiext:VK_ARM_scheduling_controls` extension is supported.
endif::VK_ARM_scheduling_controls[]
ifdef::VK_IMG_relaxed_line_rasterization[]
  * <<features-relaxedLineRasterization,pname:relaxedLineRasterization>>, if
    the `apiext:VK_IMG_relaxed_line_rasterization` extension is supported.
endif::VK_IMG_relaxed_line_rasterization[]
ifdef::VK_ARM_render_pass_striped[]
  * <<features-renderPassStriped,pname:renderPassStriped>>, if the
    `apiext:VK_ARM_render_pass_striped` extension is supported.
endif::VK_ARM_render_pass_striped[]
ifdef::VK_NV_per_stage_descriptor_set[]
  * <<features-perStageDescriptorSet,pname:perStageDescriptorSet>>, if the
    `apiext:VK_NV_per_stage_descriptor_set` extension is supported.
endif::VK_NV_per_stage_descriptor_set[]
ifdef::VK_KHR_shader_maximal_reconvergence[]
  * <<features-shaderMaximalReconvergence,
    pname:shaderMaximalReconvergence>>, if the
    `apiext:VK_KHR_shader_maximal_reconvergence` extension is supported.
endif::VK_KHR_shader_maximal_reconvergence[]
ifdef::VK_KHR_shader_subgroup_rotate[]
  * <<features-shaderSubgroupRotate, pname:shaderSubgroupRotate>>, if the
    `<<VK_KHR_shader_subgroup_rotate>>` extension is supported.
endif::VK_KHR_shader_subgroup_rotate[]
ifdef::VK_KHR_shader_expect_assume[]
  * <<features-shaderExpectAssume, pname:shaderExpectAssume>>, if the
    `apiext:VK_KHR_shader_expect_assume` extension is supported.
endif::VK_KHR_shader_expect_assume[]
ifdef::VK_KHR_shader_float_controls2[]
  * <<features-shaderFloatControls2, pname:shaderFloatControls2>>, if the
    `apiext:VK_KHR_shader_float_controls2` extension is supported.
endif::VK_KHR_shader_float_controls2[]
ifdef::VK_KHR_dynamic_rendering_local_read[]
  * <<features-dynamicRenderingLocalRead, pname:dynamicRenderingLocalRead>>,
    if the `apiext:VK_KHR_dynamic_rendering_local_read` extension is
    supported.
endif::VK_KHR_dynamic_rendering_local_read[]
ifdef::VK_KHR_shader_quad_control[]
  * <<features-shaderQuadControl, pname:shaderQuadControl>>, if the
    `apiext:VK_KHR_shader_quad_control` extension is supported.
endif::VK_KHR_shader_quad_control[]
ifdef::VK_NV_shader_atomic_float16_vector[]
  * <<features-shaderFloat16VectorAtomics,
    pname:shaderFloat16VectorAtomics>>, if the
    `apiext:VK_NV_shader_atomic_float16_vector` extension is supported.
endif::VK_NV_shader_atomic_float16_vector[]
ifdef::VK_EXT_map_memory_placed[]
  * <<features-memoryMapPlaced, pname:memoryMapPlaced>> if the
    `apiext:VK_EXT_map_memory_placed` extension is supported.
endif::VK_EXT_map_memory_placed[]
ifdef::VK_NV_raw_access_chains[]
  * <<features-shaderRawAccessChains, pname:shaderRawAccessChains>>, if the
    `apiext:VK_NV_raw_access_chains` extension is supported.
endif::VK_NV_raw_access_chains[]
ifdef::VK_EXT_custom_border_color[]
  * <<features-customBorderColors, pname:customBorderColors>>, if the
    `apiext:VK_EXT_custom_border_color` extension is supported.
endif::VK_EXT_custom_border_color[]
ifdef::VK_MESA_image_alignment_control[]
  * <<features-imageAlignmentControl, pname:imageAlignmentControl>>, if the
    `apiext:VK_MESA_image_alignment_control` extension is supported.
endif::VK_MESA_image_alignment_control[]
ifdef::VK_EXT_shader_replicated_composites[]
  * <<features-shaderReplicatedComposites,
    pname:shaderReplicatedComposites>>, if the
    `apiext:VK_EXT_shader_replicated_composites` extension is supported.
endif::VK_EXT_shader_replicated_composites[]

All other features defined in the Specification are optional:.


ifdef::VK_VERSION_1_3[]
[[profile-features]]
== Profile Features


[[profile-features-roadmap-2022]]
=== Roadmap 2022

Implementations that claim support for the <<roadmap-2022, Roadmap 2022>>
profile must: support the following features:

  * <<features-fullDrawIndexUint32, pname:fullDrawIndexUint32>>
  * <<features-imageCubeArray, pname:imageCubeArray>>
  * <<features-independentBlend, pname:independentBlend>>
  * <<features-sampleRateShading, pname:sampleRateShading>>
  * <<features-drawIndirectFirstInstance, pname:drawIndirectFirstInstance>>
  * <<features-depthClamp, pname:depthClamp>>
  * <<features-depthBiasClamp, pname:depthBiasClamp>>
  * <<features-samplerAnisotropy, pname:samplerAnisotropy>>
  * <<features-occlusionQueryPrecise, pname:occlusionQueryPrecise>>
  * <<features-fragmentStoresAndAtomics, pname:fragmentStoresAndAtomics>>
  * <<features-shaderStorageImageExtendedFormats,
    pname:shaderStorageImageExtendedFormats>>
  * <<features-shaderUniformBufferArrayDynamicIndexing,
    pname:shaderUniformBufferArrayDynamicIndexing>>
  * <<features-shaderSampledImageArrayDynamicIndexing,
    pname:shaderSampledImageArrayDynamicIndexing>>
  * <<features-shaderStorageBufferArrayDynamicIndexing,
    pname:shaderStorageBufferArrayDynamicIndexing>>
  * <<features-shaderStorageImageArrayDynamicIndexing,
    pname:shaderStorageImageArrayDynamicIndexing>>
  * <<features-samplerYcbcrConversion, pname:samplerYcbcrConversion>>
  * <<features-samplerMirrorClampToEdge, pname:samplerMirrorClampToEdge>>
  * <<features-descriptorIndexing, pname:descriptorIndexing>>
  * <<features-shaderUniformTexelBufferArrayDynamicIndexing,
    pname:shaderUniformTexelBufferArrayDynamicIndexing>>
  * <<features-shaderStorageTexelBufferArrayDynamicIndexing,
    pname:shaderStorageTexelBufferArrayDynamicIndexing>>
  * <<features-shaderUniformBufferArrayNonUniformIndexing,
    pname:shaderUniformBufferArrayNonUniformIndexing>>
  * <<features-shaderSampledImageArrayNonUniformIndexing,
    pname:shaderSampledImageArrayNonUniformIndexing>>
  * <<features-shaderStorageBufferArrayNonUniformIndexing,
    pname:shaderStorageBufferArrayNonUniformIndexing>>
  * <<features-shaderStorageImageArrayNonUniformIndexing,
    pname:shaderStorageImageArrayNonUniformIndexing>>
  * <<features-shaderUniformTexelBufferArrayNonUniformIndexing,
    pname:shaderUniformTexelBufferArrayNonUniformIndexing>>
  * <<features-shaderStorageTexelBufferArrayNonUniformIndexing,
    pname:shaderStorageTexelBufferArrayNonUniformIndexing>>
  * <<features-descriptorBindingSampledImageUpdateAfterBind,
    pname:descriptorBindingSampledImageUpdateAfterBind>>
  * <<features-descriptorBindingStorageImageUpdateAfterBind,
    pname:descriptorBindingStorageImageUpdateAfterBind>>
  * <<features-descriptorBindingStorageBufferUpdateAfterBind,
    pname:descriptorBindingStorageBufferUpdateAfterBind>>
  * <<features-descriptorBindingUniformTexelBufferUpdateAfterBind,
    pname:descriptorBindingUniformTexelBufferUpdateAfterBind>>
  * <<features-descriptorBindingStorageTexelBufferUpdateAfterBind,
    pname:descriptorBindingStorageTexelBufferUpdateAfterBind>>
  * <<features-descriptorBindingUpdateUnusedWhilePending,
    pname:descriptorBindingUpdateUnusedWhilePending>>
  * <<features-descriptorBindingPartiallyBound,
    pname:descriptorBindingPartiallyBound>>
  * <<features-descriptorBindingVariableDescriptorCount,
    pname:descriptorBindingVariableDescriptorCount>>
  * <<features-runtimeDescriptorArray, pname:runtimeDescriptorArray>>
  * <<features-scalarBlockLayout, pname:scalarBlockLayout>>


[[profile-features-roadmap-2024]]
=== Roadmap 2024

Implementations that claim support for the <<roadmap-2024, Roadmap 2024>>
profile must: support the following features:

  * <<features-multiDrawIndirect, pname:multiDrawIndirect>>
  * <<features-shaderImageGatherExtended, pname:shaderImageGatherExtended>>
  * <<features-shaderDrawParameters, pname:shaderDrawParameters>>
  * <<features-shaderInt8, pname:shaderInt8>>
  * <<features-shaderInt16, pname:shaderInt16>>
  * <<features-shaderFloat16, pname:shaderFloat16>>
  * <<features-storageBuffer16BitAccess, pname:storageBuffer16BitAccess>>
  * <<features-storageBuffer8BitAccess, pname:storageBuffer8BitAccess>>
endif::VK_VERSION_1_3[]
