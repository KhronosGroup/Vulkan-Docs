// Copyright 2015-2024 The Khronos Group Inc.
//
// SPDX-License-Identifier: CC-BY-4.0

// This text fragment is used many times in the Devices and Queues, and
// Limits chapters for different behavior, property, and limit queries.
ifdef::hidden[]
// tag::limits_desc[]
If the sname:{refpage} structure is included in the pname:pNext chain of the
slink:VkPhysicalDeviceProperties2 structure passed to
flink:vkGetPhysicalDeviceProperties2, it is filled in with each
corresponding implementation-dependent property.
// end::limits_desc[]
endif::hidden[]


[[limits]]
= Limits

_Limits_ are implementation-dependent minimums, maximums, and other device
characteristics that an application may: need to be aware of.

ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
[NOTE]
.Note
====
Limits are reported via the basic slink:VkPhysicalDeviceLimits structure as
well as the extensible structure sname:VkPhysicalDeviceProperties2, which
was added in `apiext:VK_KHR_get_physical_device_properties2` and included in
Vulkan 1.1.
When limits are added in future Vulkan versions or extensions, each
extension should: introduce one new limit structure, if needed.
This structure can: be added to the pname:pNext chain of the
sname:VkPhysicalDeviceProperties2 structure.
====
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

[open,refpage='VkPhysicalDeviceLimits',desc='Structure reporting implementation-dependent physical device limits',type='structs']
--
The sname:VkPhysicalDeviceLimits structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceLimits.adoc[]

The sname:VkPhysicalDeviceLimits are properties of the physical device.
These are available in the pname:limits member of the
slink:VkPhysicalDeviceProperties structure which is returned from
flink:vkGetPhysicalDeviceProperties.

  * [[limits-maxImageDimension1D]] pname:maxImageDimension1D is the largest
    dimension (pname:width) that is guaranteed to be supported for all
    images created with an pname:imageType of ename:VK_IMAGE_TYPE_1D.
    Some combinations of image parameters (format, usage, etc.) may: allow
    support for larger dimensions, which can: be queried using
    flink:vkGetPhysicalDeviceImageFormatProperties.
  * [[limits-maxImageDimension2D]] pname:maxImageDimension2D is the largest
    dimension (pname:width or pname:height) that is guaranteed to be
    supported for all images created with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and without
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.
    Some combinations of image parameters (format, usage, etc.) may: allow
    support for larger dimensions, which can: be queried using
    flink:vkGetPhysicalDeviceImageFormatProperties.
  * [[limits-maxImageDimension3D]] pname:maxImageDimension3D is the largest
    dimension (pname:width, pname:height, or pname:depth) that is guaranteed
    to be supported for all images created with an pname:imageType of
    ename:VK_IMAGE_TYPE_3D.
    Some combinations of image parameters (format, usage, etc.) may: allow
    support for larger dimensions, which can: be queried using
    flink:vkGetPhysicalDeviceImageFormatProperties.
  * [[limits-maxImageDimensionCube]] pname:maxImageDimensionCube is the
    largest dimension (pname:width or pname:height) that is guaranteed to be
    supported for all images created with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and with
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.
    Some combinations of image parameters (format, usage, etc.) may: allow
    support for larger dimensions, which can: be queried using
    flink:vkGetPhysicalDeviceImageFormatProperties.
  * [[limits-maxImageArrayLayers]] pname:maxImageArrayLayers is the maximum
    number of layers (pname:arrayLayers) for an image.
  * [[limits-maxTexelBufferElements]] pname:maxTexelBufferElements is the
    maximum number of addressable texels for a buffer view created on a
    buffer which was created with the
    ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or
    ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the pname:usage
    member of the slink:VkBufferCreateInfo structure.
  * [[limits-maxUniformBufferRange]] pname:maxUniformBufferRange is the
    maximum value that can: be specified in the pname:range member of a
    slink:VkDescriptorBufferInfo structure passed to
    flink:vkUpdateDescriptorSets for descriptors of type
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.
  * [[limits-maxStorageBufferRange]] pname:maxStorageBufferRange is the
    maximum value that can: be specified in the pname:range member of a
    slink:VkDescriptorBufferInfo structure passed to
    flink:vkUpdateDescriptorSets for descriptors of type
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.
  * [[limits-maxPushConstantsSize]] pname:maxPushConstantsSize is the
    maximum size, in bytes, of the pool of push constant memory.
    For each of the push constant ranges indicated by the
    pname:pPushConstantRanges member of the slink:VkPipelineLayoutCreateInfo
    structure, [eq]#(pname:offset {plus} pname:size)# must: be less than or
    equal to this limit.
  * [[limits-maxMemoryAllocationCount]] pname:maxMemoryAllocationCount is
    the maximum number of device memory allocations, as created by
    flink:vkAllocateMemory, which can: simultaneously exist.
  * [[limits-maxSamplerAllocationCount]] pname:maxSamplerAllocationCount is
    the maximum number of sampler objects, as created by
    flink:vkCreateSampler, which can: simultaneously exist on a device.
  * [[limits-bufferImageGranularity]] pname:bufferImageGranularity is the
    granularity, in bytes, at which buffer or linear image resources, and
    optimal image resources can: be bound to adjacent offsets in the same
    sname:VkDeviceMemory object without aliasing.
    See <<resources-bufferimagegranularity,Buffer-Image Granularity>> for
    more details.
  * [[limits-sparseAddressSpaceSize]] pname:sparseAddressSpaceSize is the
    total amount of address space available, in bytes, for sparse memory
    resources.
    This is an upper bound on the sum of the sizes of all sparse resources,
    regardless of whether any memory is bound to them.
ifdef::VK_NV_extended_sparse_address_space[]
    If the <<features-extendedSparseAddressSpace,
    pname:extendedSparseAddressSpace>> feature is enabled, then the
    difference between <<limits-extendedSparseAddressSpaceSize,
    pname:extendedSparseAddressSpaceSize>> and pname:sparseAddressSpaceSize
    can also be used, by sname:VkImage created with the pname:usage member
    of slink:VkImageCreateInfo only containing bits in
    <<limits-extendedSparseImageUsageFlags,
    pname:extendedSparseImageUsageFlags>> and sname:VkBuffer created with
    the pname:usage member of slink:VkBufferCreateInfo only containing bits
    in <<limits-extendedSparseBufferUsageFlags,
    pname:extendedSparseBufferUsageFlags>>.
endif::VK_NV_extended_sparse_address_space[]
  * [[limits-maxBoundDescriptorSets]] pname:maxBoundDescriptorSets is the
    maximum number of descriptor sets that can: be simultaneously used by a
    pipeline.
    All code:DescriptorSet decorations in shader modules must: have a value
    less than pname:maxBoundDescriptorSets.
    See <<descriptorsets-sets>>.
  * [[limits-maxPerStageDescriptorSamplers]]
    pname:maxPerStageDescriptorSamplers is the maximum number of samplers
    that can: be accessible to a single shader stage in a pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this
    limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    A descriptor is accessible to a shader stage when the pname:stageFlags
    member of the sname:VkDescriptorSetLayoutBinding structure has the bit
    for that shader stage set.
    See <<descriptorsets-sampler>> and
    <<descriptorsets-combinedimagesampler>>.
  * [[limits-maxPerStageDescriptorUniformBuffers]]
    pname:maxPerStageDescriptorUniformBuffers is the maximum number of
    uniform buffers that can: be accessible to a single shader stage in a
    pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
    limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    A descriptor is accessible to a shader stage when the pname:stageFlags
    member of the sname:VkDescriptorSetLayoutBinding structure has the bit
    for that shader stage set.
    See <<descriptorsets-uniformbuffer>> and
    <<descriptorsets-uniformbufferdynamic>>.
  * [[limits-maxPerStageDescriptorStorageBuffers]]
    pname:maxPerStageDescriptorStorageBuffers is the maximum number of
    storage buffers that can: be accessible to a single shader stage in a
    pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
    limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    A descriptor is accessible to a pipeline shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set.
    See <<descriptorsets-storagebuffer>> and
    <<descriptorsets-storagebufferdynamic>>.
  * [[limits-maxPerStageDescriptorSampledImages]]
    pname:maxPerStageDescriptorSampledImages is the maximum number of
    sampled images that can: be accessible to a single shader stage in a
    pipeline layout.
    Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    A descriptor is accessible to a pipeline shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set.
    See <<descriptorsets-combinedimagesampler>>,
    <<descriptorsets-sampledimage>>, and
    <<descriptorsets-uniformtexelbuffer>>.
  * [[limits-maxPerStageDescriptorStorageImages]]
    pname:maxPerStageDescriptorStorageImages is the maximum number of
    storage images that can: be accessible to a single shader stage in a
    pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    A descriptor is accessible to a pipeline shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set.
    See <<descriptorsets-storageimage>>, and
    <<descriptorsets-storagetexelbuffer>>.
  * [[limits-maxPerStageDescriptorInputAttachments]]
    pname:maxPerStageDescriptorInputAttachments is the maximum number of
    input attachments that can: be accessible to a single shader stage in a
    pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT
    count against this limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    A descriptor is accessible to a pipeline shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set.
    These are only supported for the fragment stage.
    See <<descriptorsets-inputattachment>>.
  * [[limits-maxPerStageResources]] pname:maxPerStageResources is the
    maximum number of resources that can: be accessible to a single shader
    stage in a pipeline layout.
    Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, or
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    For the fragment shader stage the framebuffer color attachments also
    count against this limit.
  * [[limits-maxDescriptorSetSamplers]] pname:maxDescriptorSetSamplers is
    the maximum number of samplers that can: be included in a pipeline
    layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this
    limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    See <<descriptorsets-sampler>> and
    <<descriptorsets-combinedimagesampler>>.
  * [[limits-maxDescriptorSetUniformBuffers]]
    pname:maxDescriptorSetUniformBuffers is the maximum number of uniform
    buffers that can: be included in a pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
    limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    See <<descriptorsets-uniformbuffer>> and
    <<descriptorsets-uniformbufferdynamic>>.
  * [[limits-maxDescriptorSetUniformBuffersDynamic]]
    pname:maxDescriptorSetUniformBuffersDynamic is the maximum number of
    dynamic uniform buffers that can: be included in a pipeline layout.
    Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
    limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    See <<descriptorsets-uniformbufferdynamic>>.
  * [[limits-maxDescriptorSetStorageBuffers]]
    pname:maxDescriptorSetStorageBuffers is the maximum number of storage
    buffers that can: be included in a pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
    limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    See <<descriptorsets-storagebuffer>> and
    <<descriptorsets-storagebufferdynamic>>.
  * [[limits-maxDescriptorSetStorageBuffersDynamic]]
    pname:maxDescriptorSetStorageBuffersDynamic is the maximum number of
    dynamic storage buffers that can: be included in a pipeline layout.
    Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
    limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    See <<descriptorsets-storagebufferdynamic>>.
  * [[limits-maxDescriptorSetSampledImages]]
    pname:maxDescriptorSetSampledImages is the maximum number of sampled
    images that can: be included in a pipeline layout.
    Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    See <<descriptorsets-combinedimagesampler>>,
    <<descriptorsets-sampledimage>>, and
    <<descriptorsets-uniformtexelbuffer>>.
  * [[limits-maxDescriptorSetStorageImages]]
    pname:maxDescriptorSetStorageImages is the maximum number of storage
    images that can: be included in a pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    See <<descriptorsets-storageimage>>, and
    <<descriptorsets-storagetexelbuffer>>.
  * [[limits-maxDescriptorSetInputAttachments]]
    pname:maxDescriptorSetInputAttachments is the maximum number of input
    attachments that can: be included in a pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT
    count against this limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    See <<descriptorsets-inputattachment>>.
  * [[limits-maxVertexInputAttributes]] pname:maxVertexInputAttributes is
    the maximum number of vertex input attributes that can: be specified for
    a graphics pipeline.
    These are described in the array of
    sname:VkVertexInputAttributeDescription structures that are provided at
    graphics pipeline creation time via the
    pname:pVertexAttributeDescriptions member of the
    slink:VkPipelineVertexInputStateCreateInfo structure.
    See <<fxvertex-attrib>> and <<fxvertex-input>>.
  * [[limits-maxVertexInputBindings]] pname:maxVertexInputBindings is the
    maximum number of vertex buffers that can: be specified for providing
    vertex attributes to a graphics pipeline.
    These are described in the array of
    sname:VkVertexInputBindingDescription structures that are provided at
    graphics pipeline creation time via the pname:pVertexBindingDescriptions
    member of the slink:VkPipelineVertexInputStateCreateInfo structure.
    The pname:binding member of sname:VkVertexInputBindingDescription must:
    be less than this limit.
    See <<fxvertex-input>>.
  * [[limits-maxVertexInputAttributeOffset]]
    pname:maxVertexInputAttributeOffset is the maximum vertex input
    attribute offset that can: be added to the vertex input binding stride.
    The pname:offset member of the sname:VkVertexInputAttributeDescription
    structure must: be less than or equal to this limit.
    See <<fxvertex-input>>.
  * [[limits-maxVertexInputBindingStride]] pname:maxVertexInputBindingStride
    is the maximum vertex input binding stride that can: be specified in a
    vertex input binding.
    The pname:stride member of the sname:VkVertexInputBindingDescription
    structure must: be less than or equal to this limit.
    See <<fxvertex-input>>.
  * [[limits-maxVertexOutputComponents]] pname:maxVertexOutputComponents is
    the maximum number of components of output variables which can: be
    output by a vertex shader.
    See <<shaders-vertex>>.
  * [[limits-maxTessellationGenerationLevel]]
    pname:maxTessellationGenerationLevel is the maximum tessellation
    generation level supported by the fixed-function tessellation primitive
    generator.
    See <<tessellation>>.
  * [[limits-maxTessellationPatchSize]] pname:maxTessellationPatchSize is
    the maximum patch size, in vertices, of patches that can: be processed
    by the tessellation control shader and tessellation primitive generator.
    The pname:patchControlPoints member of the
    slink:VkPipelineTessellationStateCreateInfo structure specified at
    pipeline creation time and the value provided in the code:OutputVertices
    execution mode of shader modules must: be less than or equal to this
    limit.
    See <<tessellation>>.
  * [[limits-maxTessellationControlPerVertexInputComponents]]
    pname:maxTessellationControlPerVertexInputComponents is the maximum
    number of components of input variables which can: be provided as
    per-vertex inputs to the tessellation control shader stage.
  * [[limits-maxTessellationControlPerVertexOutputComponents]]
    pname:maxTessellationControlPerVertexOutputComponents is the maximum
    number of components of per-vertex output variables which can: be output
    from the tessellation control shader stage.
  * [[limits-maxTessellationControlPerPatchOutputComponents]]
    pname:maxTessellationControlPerPatchOutputComponents is the maximum
    number of components of per-patch output variables which can: be output
    from the tessellation control shader stage.
  * [[limits-maxTessellationControlTotalOutputComponents]]
    pname:maxTessellationControlTotalOutputComponents is the maximum total
    number of components of per-vertex and per-patch output variables which
    can: be output from the tessellation control shader stage.
  * [[limits-maxTessellationEvaluationInputComponents]]
    pname:maxTessellationEvaluationInputComponents is the maximum number of
    components of input variables which can: be provided as per-vertex
    inputs to the tessellation evaluation shader stage.
  * [[limits-maxTessellationEvaluationOutputComponents]]
    pname:maxTessellationEvaluationOutputComponents is the maximum number of
    components of per-vertex output variables which can: be output from the
    tessellation evaluation shader stage.
  * [[limits-maxGeometryShaderInvocations]]
    pname:maxGeometryShaderInvocations is the maximum invocation count
    supported for instanced geometry shaders.
    The value provided in the code:Invocations execution mode of shader
    modules must: be less than or equal to this limit.
    See <<geometry>>.
  * [[limits-maxGeometryInputComponents]] pname:maxGeometryInputComponents
    is the maximum number of components of input variables which can: be
    provided as inputs to the geometry shader stage.
  * [[limits-maxGeometryOutputComponents]] pname:maxGeometryOutputComponents
    is the maximum number of components of output variables which can: be
    output from the geometry shader stage.
  * [[limits-maxGeometryOutputVertices]] pname:maxGeometryOutputVertices is
    the maximum number of vertices which can: be emitted by any geometry
    shader.
  * [[limits-maxGeometryTotalOutputComponents]]
    pname:maxGeometryTotalOutputComponents is the maximum total number of
    components of output variables, across all emitted vertices, which can:
    be output from the geometry shader stage.
  * [[limits-maxFragmentInputComponents]] pname:maxFragmentInputComponents
    is the maximum number of components of input variables which can: be
    provided as inputs to the fragment shader stage.
  * [[limits-maxFragmentOutputAttachments]]
    pname:maxFragmentOutputAttachments is the maximum number of output
    attachments which can: be written to by the fragment shader stage.
  * [[limits-maxFragmentDualSrcAttachments]]
    pname:maxFragmentDualSrcAttachments is the maximum number of output
    attachments which can: be written to by the fragment shader stage when
    blending is enabled and one of the dual source blend modes is in use.
    See <<framebuffer-dsb>> and <<features-dualSrcBlend,
    pname:dualSrcBlend>>.
  * [[limits-maxFragmentCombinedOutputResources]]
    pname:maxFragmentCombinedOutputResources is the total number of storage
    buffers, storage images, and output code:Location decorated color
    attachments (described in <<interfaces-fragmentoutput, Fragment Output
    Interface>>) which can: be used in the fragment shader stage.
  * [[limits-maxComputeSharedMemorySize]] pname:maxComputeSharedMemorySize
    is the maximum total storage size, in bytes, available for variables
    declared with the code:Workgroup storage class in shader modules (or
    with the code:shared storage qualifier in GLSL) in the compute shader
    stage.
  * [[limits-maxComputeWorkGroupCount]] pname:maxComputeWorkGroupCount[3] is
    the maximum number of local workgroups that can: be dispatched by a
    single dispatching command.
    These three values represent the maximum number of local workgroups for
    the X, Y, and Z dimensions, respectively.
    The workgroup count parameters to the dispatching commands must: be less
    than or equal to the corresponding limit.
    See <<dispatch>>.
  * [[limits-maxComputeWorkGroupInvocations]]
    pname:maxComputeWorkGroupInvocations is the maximum total number of
    compute shader invocations in a single local workgroup.
    The product of the X, Y, and Z sizes, as specified by the code:LocalSize
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[or code:LocalSizeId]
    execution mode in shader modules or by the object decorated by the
    code:WorkgroupSize decoration, must: be less than or equal to this
    limit.
  * [[limits-maxComputeWorkGroupSize]] pname:maxComputeWorkGroupSize[3] is
    the maximum size of a local compute workgroup, per dimension.
    These three values represent the maximum local workgroup size in the X,
    Y, and Z dimensions, respectively.
    The pname:x, pname:y, and pname:z sizes, as specified by the
    code:LocalSize
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[or code:LocalSizeId]
    execution mode or by the object decorated by the code:WorkgroupSize
    decoration in shader modules, must: be less than or equal to the
    corresponding limit.
  * [[limits-subPixelPrecisionBits]] pname:subPixelPrecisionBits is the
    number of bits of subpixel precision in framebuffer coordinates
    [eq]#x~f~# and [eq]#y~f~#.
    See <<primsrast>>.
  * [[limits-subTexelPrecisionBits]] pname:subTexelPrecisionBits is the
    number of bits of precision in the division along an axis of an image
    used for minification and magnification filters.
    [eq]#2^pname:subTexelPrecisionBits^# is the actual number of divisions
    along each axis of the image represented.
    Sub-texel values calculated during image sampling will snap to these
    locations when generating the filtered results.
  * [[limits-mipmapPrecisionBits]] pname:mipmapPrecisionBits is the number
    of bits of division that the LOD calculation for mipmap fetching get
    snapped to when determining the contribution from each mip level to the
    mip filtered results.
    [eq]#2^pname:mipmapPrecisionBits^# is the actual number of divisions.
  * [[limits-maxDrawIndexedIndexValue]] pname:maxDrawIndexedIndexValue is
    the maximum index value that can: be used for indexed draw calls when
    using 32-bit indices.
    This excludes the primitive restart index value of 0xFFFFFFFF.
    See <<features-fullDrawIndexUint32, pname:fullDrawIndexUint32>>.
  * [[limits-maxDrawIndirectCount]] pname:maxDrawIndirectCount is the
    maximum draw count that is supported for indirect drawing calls.
    See <<features-multiDrawIndirect, pname:multiDrawIndirect>>.
  * [[limits-maxSamplerLodBias]] pname:maxSamplerLodBias is the maximum
    absolute sampler LOD bias.
    The sum of the pname:mipLodBias member of the slink:VkSamplerCreateInfo
    structure and the code:Bias operand of image sampling operations in
    shader modules (or 0 if no code:Bias operand is provided to an image
    sampling operation) are clamped to the range
    [eq]#[-pname:maxSamplerLodBias,+pname:maxSamplerLodBias]#.
    See <<samplers-mipLodBias>>.
  * [[limits-maxSamplerAnisotropy]] pname:maxSamplerAnisotropy is the
    maximum degree of sampler anisotropy.
    The maximum degree of anisotropic filtering used for an image sampling
    operation is the minimum of the pname:maxAnisotropy member of the
    slink:VkSamplerCreateInfo structure and this limit.
    See <<samplers-maxAnisotropy>>.
  * [[limits-maxViewports]] pname:maxViewports is the maximum number of
    active viewports.
    The pname:viewportCount member of the
    slink:VkPipelineViewportStateCreateInfo structure that is provided at
    pipeline creation must: be less than or equal to this limit.
  * [[limits-maxViewportDimensions]] pname:maxViewportDimensions[2] are the
    maximum viewport dimensions in the X (width) and Y (height) dimensions,
    respectively.
    The maximum viewport dimensions must: be greater than or equal to the
    largest image which can: be created and used as a framebuffer
    attachment.
    See <<vertexpostproc-viewport,Controlling the Viewport>>.
  * [[limits-viewportboundsrange]] pname:viewportBoundsRange[2] is the
    [eq]#[minimum, maximum]# range that the corners of a viewport must: be
    contained in.
    This range must: be at least [eq]#[-2 {times} pname:size, 2 {times}
    pname:size - 1]#, where [eq]#pname:size =
    max(pname:maxViewportDimensions[0], pname:maxViewportDimensions[1])#.
    See <<vertexpostproc-viewport,Controlling the Viewport>>.
+
[NOTE]
.Note
====
The intent of the pname:viewportBoundsRange limit is to allow a maximum
sized viewport to be arbitrarily shifted relative to the output target as
long as at least some portion intersects.
This would give a bounds limit of [eq]#[-pname:size {plus} 1, 2 {times}
pname:size - 1]# which would allow all possible non-empty-set intersections
of the output target and the viewport.
Since these numbers are typically powers of two, picking the signed number
range using the smallest possible number of bits ends up with the specified
range.
====
  * [[limits-viewportSubPixelBits]] pname:viewportSubPixelBits is the number
    of bits of subpixel precision for viewport bounds.
    The subpixel precision that floating-point viewport bounds are
    interpreted at is given by this limit.
  * [[limits-minMemoryMapAlignment]] pname:minMemoryMapAlignment is the
    minimum required: alignment, in bytes, of host visible memory
    allocations within the host address space.
    When mapping a memory allocation with flink:vkMapMemory, subtracting
    pname:offset bytes from the returned pointer will always produce an
    integer multiple of this limit.
    See <<memory-device-hostaccess>>.
    The value must: be a power of two.
  * [[limits-minTexelBufferOffsetAlignment]]
    pname:minTexelBufferOffsetAlignment is the minimum required: alignment,
    in bytes, for the pname:offset member of the
    slink:VkBufferViewCreateInfo structure for texel buffers.
    The value must: be a power of two.
ifdef::VK_VERSION_1_3,VK_EXT_texel_buffer_alignment[]
    If <<features-texelBufferAlignment, pname:texelBufferAlignment>> is
    enabled, this limit is equivalent to the maximum of the
    <<limits-uniformTexelBufferOffsetAlignmentBytes,
    pname:uniformTexelBufferOffsetAlignmentBytes>> and
    <<limits-storageTexelBufferOffsetAlignmentBytes,
    pname:storageTexelBufferOffsetAlignmentBytes>> members of
    slink:VkPhysicalDeviceTexelBufferAlignmentProperties, but smaller
    alignment is optionally: allowed by
    <<limits-storageTexelBufferOffsetSingleTexelAlignment,
    pname:storageTexelBufferOffsetSingleTexelAlignment>> and
    <<limits-uniformTexelBufferOffsetSingleTexelAlignment,
    pname:uniformTexelBufferOffsetSingleTexelAlignment>>.
    If <<features-texelBufferAlignment, pname:texelBufferAlignment>> is not
    enabled,
endif::VK_VERSION_1_3,VK_EXT_texel_buffer_alignment[]
    slink:VkBufferViewCreateInfo::pname:offset must: be a multiple of this
    value.
  * [[limits-minUniformBufferOffsetAlignment]]
    pname:minUniformBufferOffsetAlignment is the minimum required:
    alignment, in bytes, for the pname:offset member of the
    sname:VkDescriptorBufferInfo structure for uniform buffers.
    When a descriptor of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC is updated, the
    pname:offset must: be an integer multiple of this limit.
    Similarly, dynamic offsets for uniform buffers must: be multiples of
    this limit.
    The value must: be a power of two.
  * [[limits-minStorageBufferOffsetAlignment]]
    pname:minStorageBufferOffsetAlignment is the minimum required:
    alignment, in bytes, for the pname:offset member of the
    sname:VkDescriptorBufferInfo structure for storage buffers.
    When a descriptor of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC is updated, the
    pname:offset must: be an integer multiple of this limit.
    Similarly, dynamic offsets for storage buffers must: be multiples of
    this limit.
    The value must: be a power of two.
  * [[limits-minTexelOffset]] pname:minTexelOffset is the minimum offset
    value for the code:ConstOffset image operand of any of the
    code:OpImageSample* or code:OpImageFetch* image instructions.
  * [[limits-maxTexelOffset]] pname:maxTexelOffset is the maximum offset
    value for the code:ConstOffset image operand of any of the
    code:OpImageSample* or code:OpImageFetch* image instructions.
  * [[limits-minTexelGatherOffset]] pname:minTexelGatherOffset is the
    minimum offset value for the code:Offset, code:ConstOffset, or
    code:ConstOffsets image operands of any of the code:OpImage*Gather image
    instructions.
  * [[limits-maxTexelGatherOffset]] pname:maxTexelGatherOffset is the
    maximum offset value for the code:Offset, code:ConstOffset, or
    code:ConstOffsets image operands of any of the code:OpImage*Gather image
    instructions.
  * [[limits-minInterpolationOffset]] pname:minInterpolationOffset is the
    base minimum (inclusive) negative offset value for the code:Offset
    operand of the code:InterpolateAtOffset extended instruction.
  * [[limits-maxInterpolationOffset]] pname:maxInterpolationOffset is the
    base maximum (inclusive) positive offset value for the code:Offset
    operand of the code:InterpolateAtOffset extended instruction.
  * [[limits-subPixelInterpolationOffsetBits]]
    pname:subPixelInterpolationOffsetBits is the number of fractional bits
    that the code:x and code:y offsets to the code:InterpolateAtOffset
    extended instruction may: be rounded to as fixed-point values.
  * [[limits-maxFramebufferWidth]] pname:maxFramebufferWidth is the maximum
    width for a framebuffer.
    The pname:width member of the slink:VkFramebufferCreateInfo structure
    must: be less than or equal to this limit.
  * [[limits-maxFramebufferHeight]] pname:maxFramebufferHeight is the
    maximum height for a framebuffer.
    The pname:height member of the slink:VkFramebufferCreateInfo structure
    must: be less than or equal to this limit.
  * [[limits-maxFramebufferLayers]] pname:maxFramebufferLayers is the
    maximum layer count for a layered framebuffer.
    The pname:layers member of the slink:VkFramebufferCreateInfo structure
    must: be less than or equal to this limit.
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkPhysicalDeviceLimits::pname:maxFramebufferLayers may: be 1 if
    neither pname:geometryShader or pname:shaderOutputLayer are supported
    <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]
  * [[limits-framebufferColorSampleCounts]]
    pname:framebufferColorSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the color sample counts that are
    supported for all framebuffer color attachments with floating- or
    fixed-point formats.
ifndef::VK_VERSION_1_2[]
    There is no limit specifying the color sample counts that are supported
    for all color attachments with integer formats.
endif::VK_VERSION_1_2[]
ifdef::VK_VERSION_1_2[]
    For color attachments with integer formats, see
    <<limits-framebufferIntegerColorSampleCounts,
    pname:framebufferIntegerColorSampleCounts>>.
endif::VK_VERSION_1_2[]
  * [[limits-framebufferDepthSampleCounts]]
    pname:framebufferDepthSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the supported depth sample counts
    for all framebuffer depth/stencil attachments, when the format includes
    a depth component.
  * [[limits-framebufferStencilSampleCounts]]
    pname:framebufferStencilSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the supported stencil sample
    counts for all framebuffer depth/stencil attachments, when the format
    includes a stencil component.
  * [[limits-framebufferNoAttachmentsSampleCounts]]
    pname:framebufferNoAttachmentsSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the supported sample counts for a
    <<renderpass-noattachments, subpass which uses no attachments>>.
  * [[limits-maxColorAttachments]] pname:maxColorAttachments is the maximum
    number of color attachments that can: be used by a subpass in a render
    pass.
    The pname:colorAttachmentCount member of the sname:VkSubpassDescription
ifdef::VK_VERSION_1_2,VK_KHR_create_renderpass2[]
    or sname:VkSubpassDescription2
endif::VK_VERSION_1_2,VK_KHR_create_renderpass2[]
    structure must: be less than or equal to this limit.
  * [[limits-sampledImageColorSampleCounts]]
    pname:sampledImageColorSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the sample counts supported for
    all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage
    containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a non-integer color
    format.
  * [[limits-sampledImageIntegerSampleCounts]]
    pname:sampledImageIntegerSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the sample counts supported for
    all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage
    containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and an integer color
    format.
  * [[limits-sampledImageDepthSampleCounts]]
    pname:sampledImageDepthSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the sample counts supported for
    all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage
    containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a depth format.
  * [[limits-sampledImageStencilSampleCounts]]
    pname:sampledImageStencilSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the sample counts supported for
    all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage
    containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a stencil format.
  * [[limits-storageImageSampleCounts]] pname:storageImageSampleCounts is a
    bitmask^1^ of elink:VkSampleCountFlagBits indicating the sample counts
    supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL,
    and pname:usage containing ename:VK_IMAGE_USAGE_STORAGE_BIT.
  * [[limits-maxSampleMaskWords]] pname:maxSampleMaskWords is the maximum
    number of array elements of a variable decorated with the
    code:SampleMask built-in decoration.
  * [[limits-timestampComputeAndGraphics]] pname:timestampComputeAndGraphics
    specifies support for timestamps on all graphics and compute queues.
    If this limit is set to ename:VK_TRUE, all queues that advertise the
    ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT in the
    sname:VkQueueFamilyProperties::pname:queueFlags support
    sname:VkQueueFamilyProperties::pname:timestampValidBits of at least 36.
    See <<queries-timestamps, Timestamp Queries>>.
  * [[limits-timestampPeriod]] pname:timestampPeriod is the number of
    nanoseconds required: for a timestamp query to be incremented by 1.
    See <<queries-timestamps, Timestamp Queries>>.
  * [[limits-maxClipDistances]] pname:maxClipDistances is the maximum number
    of clip distances that can: be used in a single shader stage.
    The size of any array declared with the code:ClipDistance built-in
    decoration in a shader module must: be less than or equal to this limit.
  * [[limits-maxCullDistances]] pname:maxCullDistances is the maximum number
    of cull distances that can: be used in a single shader stage.
    The size of any array declared with the code:CullDistance built-in
    decoration in a shader module must: be less than or equal to this limit.
  * [[limits-maxCombinedClipAndCullDistances]]
    pname:maxCombinedClipAndCullDistances is the maximum combined number of
    clip and cull distances that can: be used in a single shader stage.
    The sum of the sizes of all arrays declared with the code:ClipDistance
    and code:CullDistance built-in decoration used by a single shader stage
    in a shader module must: be less than or equal to this limit.
  * [[limits-discreteQueuePriorities]] pname:discreteQueuePriorities is the
    number of discrete priorities that can: be assigned to a queue based on
    the value of each member of
    slink:VkDeviceQueueCreateInfo::pname:pQueuePriorities.
    This must: be at least 2, and levels must: be spread evenly over the
    range, with at least one level at 1.0, and another at 0.0.
    See <<devsandqueues-priority>>.
  * [[limits-pointSizeRange]] pname:pointSizeRange[2] is the range
    [eq]#[pname:minimum,pname:maximum]# of supported sizes for points.
    Values written to variables decorated with the code:PointSize built-in
    decoration are clamped to this range.
  * [[limits-lineWidthRange]] pname:lineWidthRange[2] is the range
    [eq]#[pname:minimum,pname:maximum]# of supported widths for lines.
    Values specified by the pname:lineWidth member of the
    slink:VkPipelineRasterizationStateCreateInfo or the pname:lineWidth
    parameter to fname:vkCmdSetLineWidth are clamped to this range.
  * [[limits-pointSizeGranularity]] pname:pointSizeGranularity is the
    granularity of supported point sizes.
    Not all point sizes in the range defined by pname:pointSizeRange are
    supported.
    This limit specifies the granularity (or increment) between successive
    supported point sizes.
  * [[limits-lineWidthGranularity]] pname:lineWidthGranularity is the
    granularity of supported line widths.
    Not all line widths in the range defined by pname:lineWidthRange are
    supported.
    This limit specifies the granularity (or increment) between successive
    supported line widths.
  * [[limits-strictLines]] pname:strictLines specifies whether lines are
    rasterized according to the preferred method of rasterization.
    If set to ename:VK_FALSE, lines may: be rasterized under a relaxed set
    of rules.
    If set to ename:VK_TRUE, lines are rasterized as per the strict
    definition.
    See <<primsrast-lines-basic,Basic Line Segment Rasterization>>.
  * [[limits-standardSampleLocations]] pname:standardSampleLocations
    specifies whether rasterization uses the standard sample locations as
    documented in <<primsrast-multisampling,Multisampling>>.
    If set to ename:VK_TRUE, the implementation uses the documented sample
    locations.
    If set to ename:VK_FALSE, the implementation may: use different sample
    locations.
  * [[limits-optimalBufferCopyOffsetAlignment]]
    pname:optimalBufferCopyOffsetAlignment is the optimal buffer offset
    alignment in bytes for
ifndef::VK_VERSION_1_3,VK_KHR_copy_commands2[]
    flink:vkCmdCopyBufferToImage and flink:vkCmdCopyImageToBuffer.
endif::VK_VERSION_1_3,VK_KHR_copy_commands2[]
ifdef::VK_VERSION_1_3,VK_KHR_copy_commands2[]
    flink:vkCmdCopyBufferToImage2, flink:vkCmdCopyBufferToImage,
    flink:vkCmdCopyImageToBuffer2, and flink:vkCmdCopyImageToBuffer.
endif::VK_VERSION_1_3,VK_KHR_copy_commands2[]
ifdef::VK_EXT_host_image_copy[]
    This value is also the optimal host memory offset alignment in bytes for
    flink:vkCopyMemoryToImageEXT and flink:vkCopyImageToMemoryEXT.
endif::VK_EXT_host_image_copy[]
    The per texel alignment requirements are enforced, but applications
    should: use the optimal alignment for optimal performance and power use.
    The value must: be a power of two.
  * [[limits-optimalBufferCopyRowPitchAlignment]]
    pname:optimalBufferCopyRowPitchAlignment is the optimal buffer row pitch
    alignment in bytes for
ifndef::VK_VERSION_1_3,VK_KHR_copy_commands2[]
    flink:vkCmdCopyBufferToImage and flink:vkCmdCopyImageToBuffer.
endif::VK_VERSION_1_3,VK_KHR_copy_commands2[]
ifdef::VK_VERSION_1_3,VK_KHR_copy_commands2[]
    flink:vkCmdCopyBufferToImage2, flink:vkCmdCopyBufferToImage,
    flink:vkCmdCopyImageToBuffer2, and flink:vkCmdCopyImageToBuffer.
endif::VK_VERSION_1_3,VK_KHR_copy_commands2[]
ifdef::VK_EXT_host_image_copy[]
    This value is also the optimal host memory row pitch alignment in bytes
    for flink:vkCopyMemoryToImageEXT and flink:vkCopyImageToMemoryEXT.
endif::VK_EXT_host_image_copy[]
    Row pitch is the number of bytes between texels with the same X
    coordinate in adjacent rows (Y coordinates differ by one).
    The per texel alignment requirements are enforced, but applications
    should: use the optimal alignment for optimal performance and power use.
    The value must: be a power of two.
  * [[limits-nonCoherentAtomSize]] pname:nonCoherentAtomSize is the size and
    alignment in bytes that bounds concurrent access to
    <<memory-device-hostaccess, host-mapped device memory>>.
    The value must: be a power of two.

1::
    For all bitmasks of elink:VkSampleCountFlagBits, the sample count limits
    defined above represent the minimum supported sample counts for each
    image type.
    Individual images may: support additional sample counts, which are
    queried using flink:vkGetPhysicalDeviceImageFormatProperties as
    described in <<features-supported-sample-counts, Supported Sample
    Counts>>.

include::{generated}/validity/structs/VkPhysicalDeviceLimits.adoc[]
--


[open,refpage='VkSampleCountFlagBits',desc='Bitmask specifying sample counts supported for an image used for storage operations',type='enums']
--
Bits which may: be set in the sample count limits returned by
slink:VkPhysicalDeviceLimits, as well as in other queries and structures
representing image sample counts, are:

include::{generated}/api/enums/VkSampleCountFlagBits.adoc[]

  * ename:VK_SAMPLE_COUNT_1_BIT specifies an image with one sample per
    pixel.
  * ename:VK_SAMPLE_COUNT_2_BIT specifies an image with 2 samples per pixel.
  * ename:VK_SAMPLE_COUNT_4_BIT specifies an image with 4 samples per pixel.
  * ename:VK_SAMPLE_COUNT_8_BIT specifies an image with 8 samples per pixel.
  * ename:VK_SAMPLE_COUNT_16_BIT specifies an image with 16 samples per
    pixel.
  * ename:VK_SAMPLE_COUNT_32_BIT specifies an image with 32 samples per
    pixel.
  * ename:VK_SAMPLE_COUNT_64_BIT specifies an image with 64 samples per
    pixel.
--

[open,refpage='VkSampleCountFlags',desc='Bitmask of VkSampleCountFlagBits',type='flags']
--
include::{generated}/api/flags/VkSampleCountFlags.adoc[]

tname:VkSampleCountFlags is a bitmask type for setting a mask of zero or
more elink:VkSampleCountFlagBits.
--

ifdef::VK_KHR_push_descriptor[]
[open,refpage='VkPhysicalDevicePushDescriptorPropertiesKHR',desc='Structure describing push descriptor limits that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDevicePushDescriptorPropertiesKHR structure is defined
as:

include::{generated}/api/structs/VkPhysicalDevicePushDescriptorPropertiesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-maxPushDescriptors]] pname:maxPushDescriptors is the maximum
    number of descriptors that can: be used in a descriptor set layout
    created with
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set.

:refpage: VkPhysicalDevicePushDescriptorPropertiesKHR
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDevicePushDescriptorPropertiesKHR.adoc[]
--
endif::VK_KHR_push_descriptor[]

ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
[open,refpage='VkPhysicalDeviceMultiviewProperties',desc='Structure describing multiview limits that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMultiviewProperties structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMultiviewProperties.adoc[]

ifdef::VK_KHR_multiview[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceMultiviewPropertiesKHR.adoc[]
endif::VK_KHR_multiview[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_multiview-properties[]
  * [[{anchor-prefix}limits-maxMultiviewViewCount]]
    pname:maxMultiviewViewCount is one greater than the maximum view index
    that can: be used in a subpass.
  * [[{anchor-prefix}limits-maxMultiviewInstanceIndex]]
    pname:maxMultiviewInstanceIndex is the maximum valid value of instance
    index allowed to be generated by a drawing command recorded within a
    subpass of a multiview render pass instance.
// end::VK_KHR_multiview-properties[]

:refpage: VkPhysicalDeviceMultiviewProperties
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceMultiviewProperties.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_multiview[]

ifdef::VK_VERSION_1_2,VK_KHR_shader_float_controls[]
[open,refpage='VkPhysicalDeviceFloatControlsProperties',desc='Structure describing properties supported by VK_KHR_shader_float_controls',type='structs',alias='VkPhysicalDeviceFloatControlsPropertiesKHR']
--
The sname:VkPhysicalDeviceFloatControlsProperties structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceFloatControlsProperties.adoc[]

ifdef::VK_KHR_shader_float_controls[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceFloatControlsPropertiesKHR.adoc[]
endif::VK_KHR_shader_float_controls[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_shader_float_controls-properties[]
  * [[{anchor-prefix}features-denormBehaviorIndependence]]
    pname:denormBehaviorIndependence is a
    elink:VkShaderFloatControlsIndependence value indicating whether, and
    how, denorm behavior can be set independently for different bit widths.
  * [[{anchor-prefix}features-roundingModeIndependence]]
    pname:roundingModeIndependence is a
    elink:VkShaderFloatControlsIndependence value indicating whether, and
    how, rounding modes can be set independently for different bit widths.
  * [[{anchor-prefix}limits-shaderSignedZeroInfNanPreserveFloat16]]
    pname:shaderSignedZeroInfNanPreserveFloat16 is a boolean value
    indicating whether sign of a zero, [eq]##Nan##s and
    latexmath:[\pm\infty] can: be preserved in 16-bit floating-point
    computations.
    It also indicates whether the code:SignedZeroInfNanPreserve execution
    mode can: be used for 16-bit floating-point types.
  * [[{anchor-prefix}limits-shaderSignedZeroInfNanPreserveFloat32]]
    pname:shaderSignedZeroInfNanPreserveFloat32 is a boolean value
    indicating whether sign of a zero, [eq]##Nan##s and
    latexmath:[\pm\infty] can: be preserved in 32-bit floating-point
    computations.
    It also indicates whether the code:SignedZeroInfNanPreserve execution
    mode can: be used for 32-bit floating-point types.
  * [[{anchor-prefix}limits-shaderSignedZeroInfNanPreserveFloat64]]
    pname:shaderSignedZeroInfNanPreserveFloat64 is a boolean value
    indicating whether sign of a zero, [eq]##Nan##s and
    latexmath:[\pm\infty] can: be preserved in 64-bit floating-point
    computations.
    It also indicates whether the code:SignedZeroInfNanPreserve execution
    mode can: be used for 64-bit floating-point types.
  * [[{anchor-prefix}limits-shaderDenormPreserveFloat16]]
    pname:shaderDenormPreserveFloat16 is a boolean value indicating whether
    denormals can: be preserved in 16-bit floating-point computations.
    It also indicates whether the code:DenormPreserve execution mode can: be
    used for 16-bit floating-point types.
  * [[{anchor-prefix}limits-shaderDenormPreserveFloat32]]
    pname:shaderDenormPreserveFloat32 is a boolean value indicating whether
    denormals can: be preserved in 32-bit floating-point computations.
    It also indicates whether the code:DenormPreserve execution mode can: be
    used for 32-bit floating-point types.
  * [[{anchor-prefix}limits-shaderDenormPreserveFloat64]]
    pname:shaderDenormPreserveFloat64 is a boolean value indicating whether
    denormals can: be preserved in 64-bit floating-point computations.
    It also indicates whether the code:DenormPreserve execution mode can: be
    used for 64-bit floating-point types.
  * [[{anchor-prefix}limits-shaderDenormFlushToZeroFloat16]]
    pname:shaderDenormFlushToZeroFloat16 is a boolean value indicating
    whether denormals can: be flushed to zero in 16-bit floating-point
    computations.
    It also indicates whether the code:DenormFlushToZero execution mode can:
    be used for 16-bit floating-point types.
  * [[{anchor-prefix}limits-shaderDenormFlushToZeroFloat32]]
    pname:shaderDenormFlushToZeroFloat32 is a boolean value indicating
    whether denormals can: be flushed to zero in 32-bit floating-point
    computations.
    It also indicates whether the code:DenormFlushToZero execution mode can:
    be used for 32-bit floating-point types.
  * [[{anchor-prefix}limits-shaderDenormFlushToZeroFloat64]]
    pname:shaderDenormFlushToZeroFloat64 is a boolean value indicating
    whether denormals can: be flushed to zero in 64-bit floating-point
    computations.
    It also indicates whether the code:DenormFlushToZero execution mode can:
    be used for 64-bit floating-point types.
  * [[{anchor-prefix}limits-shaderRoundingModeRTEFloat16]]
    pname:shaderRoundingModeRTEFloat16 is a boolean value indicating whether
    an implementation supports the round-to-nearest-even rounding mode for
    16-bit floating-point arithmetic and conversion instructions.
    It also indicates whether the code:RoundingModeRTE execution mode can:
    be used for 16-bit floating-point types.
  * [[{anchor-prefix}limits-shaderRoundingModeRTEFloat32]]
    pname:shaderRoundingModeRTEFloat32 is a boolean value indicating whether
    an implementation supports the round-to-nearest-even rounding mode for
    32-bit floating-point arithmetic and conversion instructions.
    It also indicates whether the code:RoundingModeRTE execution mode can:
    be used for 32-bit floating-point types.
  * [[{anchor-prefix}limits-shaderRoundingModeRTEFloat64]]
    pname:shaderRoundingModeRTEFloat64 is a boolean value indicating whether
    an implementation supports the round-to-nearest-even rounding mode for
    64-bit floating-point arithmetic and conversion instructions.
    It also indicates whether the code:RoundingModeRTE execution mode can:
    be used for 64-bit floating-point types.
  * [[{anchor-prefix}limits-shaderRoundingModeRTZFloat16]]
    pname:shaderRoundingModeRTZFloat16 is a boolean value indicating whether
    an implementation supports the round-towards-zero rounding mode for
    16-bit floating-point arithmetic and conversion instructions.
    It also indicates whether the code:RoundingModeRTZ execution mode can:
    be used for 16-bit floating-point types.
  * [[{anchor-prefix}limits-shaderRoundingModeRTZFloat32]]
    pname:shaderRoundingModeRTZFloat32 is a boolean value indicating whether
    an implementation supports the round-towards-zero rounding mode for
    32-bit floating-point arithmetic and conversion instructions.
    It also indicates whether the code:RoundingModeRTZ execution mode can:
    be used for 32-bit floating-point types.
  * [[{anchor-prefix}limits-shaderRoundingModeRTZFloat64]]
    pname:shaderRoundingModeRTZFloat64 is a boolean value indicating whether
    an implementation supports the round-towards-zero rounding mode for
    64-bit floating-point arithmetic and conversion instructions.
    It also indicates whether the code:RoundingModeRTZ execution mode can:
    be used for 64-bit floating-point types.
// end::VK_KHR_shader_float_controls-properties[]

ifdef::editing-notes[]
[NOTE]
.editing-note
====
Implementations may not be able to control behavior of denorms for
floating-point atomics.
This needs to be taken into account when such atomics will be added to
Vulkan.
====
endif::editing-notes[]

:refpage: VkPhysicalDeviceFloatControlsProperties
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceFloatControlsProperties.adoc[]
--

[open,refpage='VkShaderFloatControlsIndependence',desc='Bitmask specifying whether, and how, shader float controls can be set separately',type='enums',alias='VkShaderFloatControlsIndependenceKHR']
--
Values which may: be returned in the pname:denormBehaviorIndependence and
pname:roundingModeIndependence fields of
sname:VkPhysicalDeviceFloatControlsProperties are:

include::{generated}/api/enums/VkShaderFloatControlsIndependence.adoc[]

ifdef::VK_KHR_shader_float_controls[]
or the equivalent

include::{generated}/api/enums/VkShaderFloatControlsIndependenceKHR.adoc[]
endif::VK_KHR_shader_float_controls[]

  * ename:VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY specifies that
    shader float controls for 32-bit floating point can: be set
    independently; other bit widths must: be set identically to each other.
  * ename:VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL specifies that shader
    float controls for all bit widths can: be set independently.
  * ename:VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE specifies that shader
    float controls for all bit widths must: be set identically.
--
endif::VK_VERSION_1_2,VK_KHR_shader_float_controls[]

ifdef::VK_EXT_discard_rectangles[]
[open,refpage='VkPhysicalDeviceDiscardRectanglePropertiesEXT',desc='Structure describing discard rectangle limits that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDiscardRectanglePropertiesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDiscardRectanglePropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-maxDiscardRectangles]] pname:maxDiscardRectangles is the
    maximum number of active discard rectangles that can: be specified.

:refpage: VkPhysicalDeviceDiscardRectanglePropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceDiscardRectanglePropertiesEXT.adoc[]
--
endif::VK_EXT_discard_rectangles[]

ifdef::VK_EXT_sample_locations[]
[open,refpage='VkPhysicalDeviceSampleLocationsPropertiesEXT',desc='Structure describing sample location limits that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceSampleLocationsPropertiesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceSampleLocationsPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-sampleLocationSampleCounts]] pname:sampleLocationSampleCounts
    is a bitmask of elink:VkSampleCountFlagBits indicating the sample counts
    supporting custom sample locations.
  * [[limits-maxSampleLocationGridSize]] pname:maxSampleLocationGridSize is
    the maximum size of the pixel grid in which sample locations can: vary
    that is supported for all sample counts in
    pname:sampleLocationSampleCounts.
  * [[limits-sampleLocationCoordinateRange]]
    pname:sampleLocationCoordinateRange[2] is the range of supported sample
    location coordinates.
  * [[limits-sampleLocationSubPixelBits]] pname:sampleLocationSubPixelBits
    is the number of bits of subpixel precision for sample locations.
  * [[limits-variableSampleLocations]] pname:variableSampleLocations
    specifies whether the sample locations used by all pipelines that will
    be bound to a command buffer during a subpass must: match.
    If set to ename:VK_TRUE, the implementation supports variable sample
    locations in a subpass.
    If set to ename:VK_FALSE, then the sample locations must: stay constant
    in each subpass.

:refpage: VkPhysicalDeviceSampleLocationsPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceSampleLocationsPropertiesEXT.adoc[]
--
endif::VK_EXT_sample_locations[]

ifdef::VK_EXT_legacy_vertex_attributes[]
[open,refpage='VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT',desc='Structure describing properties for legacy vertex attributes',type='structs']
--
The sname:VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT.adoc[]

This structure describes the following features:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-nativeUnalignedPerformance]] pname:nativeUnalignedPerformance
    specifies whether unaligned vertex fetches do not incur significant
    performance penalties as compared to aligned fetches.

:refpage: VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT
include::{chapters}/features.adoc[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT.adoc[]
--
endif::VK_EXT_legacy_vertex_attributes[]

ifdef::VK_EXT_external_memory_host[]
[open,refpage='VkPhysicalDeviceExternalMemoryHostPropertiesEXT',desc='Structure describing external memory host pointer limits that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceExternalMemoryHostPropertiesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceExternalMemoryHostPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-minImportedHostPointerAlignment]]
    pname:minImportedHostPointerAlignment is the minimum required:
    alignment, in bytes, for the base address and size of host pointers that
    can: be imported to a Vulkan memory object.
    The value must: be a power of two.

:refpage: VkPhysicalDeviceExternalMemoryHostPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceExternalMemoryHostPropertiesEXT.adoc[]
--
endif::VK_EXT_external_memory_host[]

ifdef::VK_NVX_multiview_per_view_attributes[]
[open,refpage='VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX',desc='Structure describing multiview limits that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-perViewPositionAllComponents]]
    pname:perViewPositionAllComponents is ename:VK_TRUE if the
    implementation supports per-view position values that differ in
    components other than the X component.

:refpage: VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.adoc[]
--
endif::VK_NVX_multiview_per_view_attributes[]

ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
[open,refpage='VkPhysicalDevicePointClippingProperties',desc='Structure describing the point clipping behavior supported by an implementation',type='structs']
--
The sname:VkPhysicalDevicePointClippingProperties structure is defined as:

include::{generated}/api/structs/VkPhysicalDevicePointClippingProperties.adoc[]

ifdef::VK_KHR_maintenance2[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDevicePointClippingPropertiesKHR.adoc[]
endif::VK_KHR_maintenance2[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_maintenance2-properties[]
  * [[{anchor-prefix}limits-pointClipping]] pname:pointClippingBehavior is a
    elink:VkPointClippingBehavior value specifying the point clipping
    behavior supported by the implementation.
// end::VK_KHR_maintenance2-properties[]

:refpage: VkPhysicalDevicePointClippingProperties
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDevicePointClippingProperties.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]

ifdef::VK_VERSION_1_1[]
[open,refpage='VkPhysicalDeviceSubgroupProperties',desc='Structure describing subgroup support for an implementation',type='structs']
--
The sname:VkPhysicalDeviceSubgroupProperties structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceSubgroupProperties.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_subgroup-properties[]
  * [[{anchor-prefix}limits-subgroup-size]] pname:subgroupSize is the
    default number of invocations in each subgroup.
    pname:subgroupSize is at least 1 if any of the physical device's queues
    support ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT.
    pname:subgroupSize is a power-of-two.
  * [[limits-subgroup-supportedStages]] pname:supportedStages is a bitfield
    of elink:VkShaderStageFlagBits describing the shader stages that
    <<shaders-group-operations, group operations>> with
    <<shaders-scope-subgroup, subgroup scope>> are supported in.
    pname:supportedStages will have the ename:VK_SHADER_STAGE_COMPUTE_BIT
    bit set if any of the physical device's queues support
    ename:VK_QUEUE_COMPUTE_BIT.
  * [[limits-subgroupSupportedOperations]] pname:supportedOperations is a
    bitmask of elink:VkSubgroupFeatureFlagBits specifying the sets of
    <<shaders-group-operations, group operations>> with
    <<shaders-scope-subgroup, subgroup scope>> supported on this device.
    pname:supportedOperations will have the
    ename:VK_SUBGROUP_FEATURE_BASIC_BIT bit set if any of the physical
    device's queues support ename:VK_QUEUE_GRAPHICS_BIT or
    ename:VK_QUEUE_COMPUTE_BIT.
  * [[limits-subgroup-quadOperationsInAllStages]]
    pname:quadOperationsInAllStages is a boolean specifying whether
    <<shaders-quad-operations,quad group operations>> are available in all
    stages, or are restricted to fragment and compute stages.
// end::VK_KHR_subgroup-properties[]

:refpage: VkPhysicalDeviceSubgroupProperties
include::{chapters}/limits.adoc[tag=limits_desc]

If pname:supportedOperations includes <<features-subgroup-quad,
ename:VK_SUBGROUP_FEATURE_QUAD_BIT>>,
ifdef::VK_KHR_shader_subgroup_uniform_control_flow[]
or <<features-shaderSubgroupUniformControlFlow,
pname:shaderSubgroupUniformControlFlow>> is enabled,
endif::VK_KHR_shader_subgroup_uniform_control_flow[]
pname:subgroupSize must: be greater than or equal to 4.

ifdef::VK_KHR_shader_quad_control[]
If the <<features-shaderQuadControl, pname:shaderQuadControl>> feature is
supported, pname:supportedOperations must: include <<features-subgroup-quad,
ename:VK_SUBGROUP_FEATURE_QUAD_BIT>>.
endif::VK_KHR_shader_quad_control[]

ifdef::VK_KHR_shader_subgroup_rotate[]
If apiext:VK_KHR_shader_subgroup_rotate is supported, and the implementation
advertises support with a slink:VkExtensionProperties::pname:specVersion
greater than or equal to 2, and <<features-shaderSubgroupRotate,
pname:shaderSubgroupRotate>> is supported,
ename:VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR must: be returned in
pname:subgroupSupportedOperations.
If apiext:VK_KHR_shader_subgroup_rotate is supported, and the implementation
advertises support with a slink:VkExtensionProperties::pname:specVersion
greater than or equal to 2, and <<features-shaderSubgroupRotateClustered,
pname:shaderSubgroupRotateClustered>> is supported,
ename:VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR must: be returned in
pname:subgroupSupportedOperations.

[NOTE]
.Note
====
ename:VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR and
ename:VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR were added in version 2
of the apiext:VK_KHR_shader_subgroup_rotate extension, after the initial
release, so there are implementations that do not advertise these bits.
Applications should use the <<features-shaderSubgroupRotate,
pname:shaderSubgroupRotate>> and <<features-shaderSubgroupRotateClustered,
pname:shaderSubgroupRotateClustered>> features to determine and enable
support.
These bits are advertised here for consistency and for future dependencies.
====
endif::VK_KHR_shader_subgroup_rotate[]

include::{generated}/validity/structs/VkPhysicalDeviceSubgroupProperties.adoc[]
--

[open,refpage='VkSubgroupFeatureFlagBits',desc='Bitmask describing what group operations are supported with subgroup scope',type='enums']
--
Bits which can: be set in
slink:VkPhysicalDeviceSubgroupProperties::pname:supportedOperations
ifdef::VK_VERSION_1_2[]
and
slink:VkPhysicalDeviceVulkan11Properties::pname:subgroupSupportedOperations
endif::VK_VERSION_1_2[]
to specify supported <<shaders-group-operations, group operations>> with
<<shaders-scope-subgroup, subgroup scope>> are:

include::{generated}/api/enums/VkSubgroupFeatureFlagBits.adoc[]

  * [[features-subgroup-basic]] ename:VK_SUBGROUP_FEATURE_BASIC_BIT
    specifies the device will accept SPIR-V shader modules containing the
    code:GroupNonUniform capability.
  * [[features-subgroup-vote]] ename:VK_SUBGROUP_FEATURE_VOTE_BIT specifies
    the device will accept SPIR-V shader modules containing the
    code:GroupNonUniformVote capability.
  * [[features-subgroup-arithmetic]]
    ename:VK_SUBGROUP_FEATURE_ARITHMETIC_BIT specifies the device will
    accept SPIR-V shader modules containing the
    code:GroupNonUniformArithmetic capability.
  * [[features-subgroup-ballot]] ename:VK_SUBGROUP_FEATURE_BALLOT_BIT
    specifies the device will accept SPIR-V shader modules containing the
    code:GroupNonUniformBallot capability.
  * [[features-subgroup-shuffle]] ename:VK_SUBGROUP_FEATURE_SHUFFLE_BIT
    specifies the device will accept SPIR-V shader modules containing the
    code:GroupNonUniformShuffle capability.
  * [[features-subgroup-shuffle-relative]]
    ename:VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT specifies the device will
    accept SPIR-V shader modules containing the
    code:GroupNonUniformShuffleRelative capability.
  * [[features-subgroup-clustered]] ename:VK_SUBGROUP_FEATURE_CLUSTERED_BIT
    specifies the device will accept SPIR-V shader modules containing the
    code:GroupNonUniformClustered capability.
  * [[features-subgroup-quad]] ename:VK_SUBGROUP_FEATURE_QUAD_BIT specifies
    the device will accept SPIR-V shader modules containing the
    code:GroupNonUniformQuad capability.
ifdef::VK_NV_shader_subgroup_partitioned[]
  * [[features-subgroup-partitioned]]
    ename:VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV specifies the device will
    accept SPIR-V shader modules containing the
    code:GroupNonUniformPartitionedNV capability.
endif::VK_NV_shader_subgroup_partitioned[]
ifdef::VK_KHR_shader_subgroup_rotate[]
  * [[features-subgroup-rotate]] ename:VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR
    specifies the device will accept SPIR-V shader modules containing the
    code:GroupNonUniformRotateKHR capability.
  * [[features-subgroup-rotate-clustered]]
    ename:VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR specifies the device
    will accept SPIR-V shader modules that use the code:ClusterSize operand
    to code:OpGroupNonUniformRotateKHR.
endif::VK_KHR_shader_subgroup_rotate[]
--

[open,refpage='VkSubgroupFeatureFlags',desc='Bitmask of VkSubgroupFeatureFlagBits',type='flags']
--
include::{generated}/api/flags/VkSubgroupFeatureFlags.adoc[]

tname:VkSubgroupFeatureFlags is a bitmask type for setting a mask of zero or
more elink:VkSubgroupFeatureFlagBits.
--

ifdef::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
[open,refpage='VkPhysicalDeviceSubgroupSizeControlProperties',desc='Structure describing the control subgroup size properties of an implementation',type='structs',alias='VkPhysicalDeviceSubgroupSizeControlPropertiesEXT']
--
The sname:VkPhysicalDeviceSubgroupSizeControlProperties structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceSubgroupSizeControlProperties.adoc[]

ifdef::VK_EXT_subgroup_size_control[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceSubgroupSizeControlPropertiesEXT.adoc[]
endif::VK_EXT_subgroup_size_control[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_EXT_subgroup_size_control-properties[]
  * [[{anchor-prefix}limits-minSubgroupSize]] pname:minSubgroupSize is the
    minimum subgroup size supported by this device.
    pname:minSubgroupSize is at least one if any of the physical device's
    queues support ename:VK_QUEUE_GRAPHICS_BIT or
    ename:VK_QUEUE_COMPUTE_BIT.
    pname:minSubgroupSize is a power-of-two.
    pname:minSubgroupSize is less than or equal to pname:maxSubgroupSize.
    pname:minSubgroupSize is less than or equal to <<limits-subgroup-size,
    pname:subgroupSize>>.
  * [[{anchor-prefix}limits-maxSubgroupSize]] pname:maxSubgroupSize is the
    maximum subgroup size supported by this device.
    pname:maxSubgroupSize is at least one if any of the physical device's
    queues support ename:VK_QUEUE_GRAPHICS_BIT or
    ename:VK_QUEUE_COMPUTE_BIT.
    pname:maxSubgroupSize is a power-of-two.
    pname:maxSubgroupSize is greater than or equal to pname:minSubgroupSize.
    pname:maxSubgroupSize is greater than or equal to
    <<limits-subgroup-size, pname:subgroupSize>>.
  * [[{anchor-prefix}limits-maxComputeWorkgroupSubgroups]]
    pname:maxComputeWorkgroupSubgroups is the maximum number of subgroups
    supported by the implementation within a workgroup.
  * [[{anchor-prefix}limits-requiredSubgroupSizeStages]]
    pname:requiredSubgroupSizeStages is a bitfield of what shader stages
    support having a required subgroup size specified.
// end::VK_EXT_subgroup_size_control-properties[]

:refpage: VkPhysicalDeviceSubgroupSizeControlProperties
include::{chapters}/limits.adoc[tag=limits_desc]

If slink:VkPhysicalDeviceSubgroupProperties::pname:supportedOperations
includes <<features-subgroup-quad, ename:VK_SUBGROUP_FEATURE_QUAD_BIT>>,
pname:minSubgroupSize must: be greater than or equal to 4.

include::{generated}/validity/structs/VkPhysicalDeviceSubgroupSizeControlProperties.adoc[]
--
endif::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
endif::VK_VERSION_1_1[]

ifdef::VK_EXT_blend_operation_advanced[]
[open,refpage='VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT',desc='Structure describing advanced blending limits that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-advancedBlendMaxColorAttachments]]
    pname:advancedBlendMaxColorAttachments is one greater than the highest
    color attachment index that can: be used in a subpass, for a pipeline
    that uses an <<framebuffer-blend-advanced,advanced blend operation>>.
  * [[limits-advancedBlendIndependentBlend]]
    pname:advancedBlendIndependentBlend specifies whether advanced blend
    operations can: vary per-attachment.
  * [[limits-advancedBlendNonPremultipliedSrcColor]]
    pname:advancedBlendNonPremultipliedSrcColor specifies whether the source
    color can: be treated as non-premultiplied.
    If this is ename:VK_FALSE, then
    slink:VkPipelineColorBlendAdvancedStateCreateInfoEXT::pname:srcPremultiplied
    must: be ename:VK_TRUE.
  * [[limits-advancedBlendNonPremultipliedDstColor]]
    pname:advancedBlendNonPremultipliedDstColor specifies whether the
    destination color can: be treated as non-premultiplied.
    If this is ename:VK_FALSE, then
    slink:VkPipelineColorBlendAdvancedStateCreateInfoEXT::pname:dstPremultiplied
    must: be ename:VK_TRUE.
  * [[limits-advancedBlendCorrelatedOverlap]]
    pname:advancedBlendCorrelatedOverlap specifies whether the overlap mode
    can: be treated as correlated.
    If this is ename:VK_FALSE, then
    slink:VkPipelineColorBlendAdvancedStateCreateInfoEXT::pname:blendOverlap
    must: be ename:VK_BLEND_OVERLAP_UNCORRELATED_EXT.
  * [[limits-advancedBlendAllOperations]] pname:advancedBlendAllOperations
    specifies whether all advanced blend operation enums are supported.
    See the valid usage of slink:VkPipelineColorBlendAttachmentState.

:refpage: VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.adoc[]
--
endif::VK_EXT_blend_operation_advanced[]

ifdef::VK_EXT_vertex_attribute_divisor[]
[open,refpage='VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT',desc='Structure describing max value of vertex attribute divisor that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_KHR_vertex_attribute_divisor[:anchor-prefix: extension-]
ifndef::VK_KHR_vertex_attribute_divisor[:anchor-prefix:]
// tag::VK_KHR_vertex_attribute_divisor-properties[]
  * [[{anchor-prefix}limits-maxVertexAttribDivisor]]
    pname:maxVertexAttribDivisor is the maximum value of the number of
    instances that will repeat the value of vertex attribute data when
    instanced rendering is enabled.

:refpage: VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.adoc[]
--
endif::VK_EXT_vertex_attribute_divisor[]

ifdef::VK_KHR_vertex_attribute_divisor[]
[open,refpage='VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR',desc='Structure describing max value of vertex attribute divisor that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-maxVertexAttribDivisor]] pname:maxVertexAttribDivisor is the
    maximum value of the number of instances that will repeat the value of
    vertex attribute data when instanced rendering is enabled.
  * [[limits-supportsNonZeroFirstInstance]]
    pname:supportsNonZeroFirstInstance specifies whether a non-zero value
    for the pname:firstInstance parameter of <<drawing, drawing commands>>
    is supported when
    slink:VkVertexInputBindingDivisorDescriptionKHR::pname:divisor is not
    `1`.

:refpage: VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR.adoc[]
--
endif::VK_KHR_vertex_attribute_divisor[]

ifdef::VK_VERSION_1_2,VK_EXT_sampler_filter_minmax[]
[open,refpage='VkPhysicalDeviceSamplerFilterMinmaxProperties',desc='Structure describing sampler filter minmax limits that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT']
--
The sname:VkPhysicalDeviceSamplerFilterMinmaxProperties structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceSamplerFilterMinmaxProperties.adoc[]

ifdef::VK_EXT_sampler_filter_minmax[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.adoc[]
endif::VK_EXT_sampler_filter_minmax[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_sampler_filter_minmax-properties[]
  * [[{anchor-prefix}limits-filterMinmaxSingleComponentFormats]]
    pname:filterMinmaxSingleComponentFormats is a boolean value indicating
    whether a minimum set of required formats support min/max filtering.
  * [[{anchor-prefix}limits-filterMinmaxImageComponentMapping]]
    pname:filterMinmaxImageComponentMapping is a boolean value indicating
    whether the implementation supports non-identity component mapping of
    the image when doing min/max filtering.
// end::VK_EXT_sampler_filter_minmax-properties[]

:refpage: VkPhysicalDeviceSamplerFilterMinmaxProperties
include::{chapters}/limits.adoc[tag=limits_desc]

[[limits-filterMinmaxSingleComponentFormats-minimum-requirements]]
If pname:filterMinmaxSingleComponentFormats is ename:VK_TRUE, the following
formats must: support the
ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT feature with
ename:VK_IMAGE_TILING_OPTIMAL, if they support
ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT:

  * ename:VK_FORMAT_R8_UNORM
  * ename:VK_FORMAT_R8_SNORM
  * ename:VK_FORMAT_R16_UNORM
  * ename:VK_FORMAT_R16_SNORM
  * ename:VK_FORMAT_R16_SFLOAT
  * ename:VK_FORMAT_R32_SFLOAT
  * ename:VK_FORMAT_D16_UNORM
  * ename:VK_FORMAT_X8_D24_UNORM_PACK32
  * ename:VK_FORMAT_D32_SFLOAT
  * ename:VK_FORMAT_D16_UNORM_S8_UINT
  * ename:VK_FORMAT_D24_UNORM_S8_UINT
  * ename:VK_FORMAT_D32_SFLOAT_S8_UINT

If the format is a depth/stencil format, this bit only specifies that the
depth aspect (not the stencil aspect) of an image of this format supports
min/max filtering, and that min/max filtering of the depth aspect is
supported when depth compare is disabled in the sampler.

If pname:filterMinmaxImageComponentMapping is ename:VK_FALSE the component
mapping of the image view used with min/max filtering must: have been
created with the pname:r component set to the
<<resources-image-views-identity-mappings,identity swizzle>>.
Only the pname:r component of the sampled image value is defined and the
other component values are undefined:.
If pname:filterMinmaxImageComponentMapping is ename:VK_TRUE this restriction
does not apply and image component mapping works as normal.

include::{generated}/validity/structs/VkPhysicalDeviceSamplerFilterMinmaxProperties.adoc[]
--
endif::VK_VERSION_1_2,VK_EXT_sampler_filter_minmax[]

ifdef::VK_VERSION_1_1[]
[open,refpage='VkPhysicalDeviceProtectedMemoryProperties',desc='Structure describing protected memory properties that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceProtectedMemoryProperties structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceProtectedMemoryProperties.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_protected_memory-properties[]
  * [[{anchor-prefix}limits-protectedNoFault]] pname:protectedNoFault
    specifies how an implementation behaves when an application attempts to
    write to unprotected memory in a protected queue operation, read from
    protected memory in an unprotected queue operation, or perform a query
    in a protected queue operation.
    If this limit is ename:VK_TRUE, such writes will be discarded or have
    undefined: values written, reads and queries will return undefined:
    values.
    If this limit is ename:VK_FALSE, applications must: not perform these
    operations.
    See <<memory-protected-access-rules>> for more information.
// end::VK_KHR_protected_memory-properties[]

:refpage: VkPhysicalDeviceProtectedMemoryProperties
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceProtectedMemoryProperties.adoc[]
--
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1,VK_KHR_maintenance3[]
[open,refpage='VkPhysicalDeviceMaintenance3Properties',desc='Structure describing descriptor set properties',type='structs']
--
The sname:VkPhysicalDeviceMaintenance3Properties structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMaintenance3Properties.adoc[]

ifdef::VK_KHR_maintenance3[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceMaintenance3PropertiesKHR.adoc[]
endif::VK_KHR_maintenance3[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_maintenance3-properties[]
  * [[{anchor-prefix}limits-maxPerSetDescriptors]]
    pname:maxPerSetDescriptors is a maximum number of descriptors (summed
    over all descriptor types) in a single descriptor set that is guaranteed
    to satisfy any implementation-dependent constraints on the size of a
    descriptor set itself.
    Applications can: query whether a descriptor set that goes beyond this
    limit is supported using flink:vkGetDescriptorSetLayoutSupport.
  * [[{anchor-prefix}limits-maxMemoryAllocationSize]]
    pname:maxMemoryAllocationSize is the maximum size of a memory allocation
    that can: be created, even if there is more space available in the heap.
// end::VK_KHR_maintenance3-properties[]

:refpage: VkPhysicalDeviceMaintenance3Properties
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceMaintenance3Properties.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_maintenance3[]

ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
[open,refpage='VkPhysicalDeviceMaintenance4Properties',desc='Structure describing various implementation-defined properties introduced with VK_KHR_maintenance4',type='structs',alias='VkPhysicalDeviceMaintenance4PropertiesKHR']
--
The sname:VkPhysicalDeviceMaintenance4Properties structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMaintenance4Properties.adoc[]

ifdef::VK_KHR_maintenance4[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceMaintenance4PropertiesKHR.adoc[]
endif::VK_KHR_maintenance4[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_KHR_maintenance4-properties[]
  * [[{anchor-prefix}limits-maxBufferSize]] pname:maxBufferSize is the
    maximum size sname:VkBuffer that can: be created.
// end::VK_KHR_maintenance4-properties[]

:refpage: VkPhysicalDeviceMaintenance4Properties
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceMaintenance4Properties.adoc[]
--
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]

ifdef::VK_KHR_maintenance5[]
[open,refpage='VkPhysicalDeviceMaintenance5PropertiesKHR',desc='Structure describing various implementation-defined properties introduced with VK_KHR_maintenance5',type='structs',alias='VkPhysicalDeviceMaintenance5PropertiesKHR']
--
The sname:VkPhysicalDeviceMaintenance5PropertiesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMaintenance5PropertiesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:earlyFragmentMultisampleCoverageAfterSampleCounting is a boolean
    value indicating whether the <<fragops-shader,fragment shading>> and
    <<fragops-covg, multisample coverage>> operations are performed after
    <<fragops-samplecount, sample counting>> for <<fragops-shader, fragment
    shaders>> with code:EarlyFragmentTests execution mode.
  * pname:earlyFragmentSampleMaskTestBeforeSampleCounting is a boolean value
    indicating whether the <<fragops-samplemask,sample mask test>> operation
    is performed before <<fragops-samplecount, sample counting>> for
    <<fragops-shader, fragment shaders>> using the code:EarlyFragmentTests
    execution mode.
  * pname:depthStencilSwizzleOneSupport is a boolean indicating that
    depth/stencil texturing operations with ename:VK_COMPONENT_SWIZZLE_ONE
    have defined behavior.
  * pname:polygonModePointSize is a boolean value indicating whether the
    point size of the final rasterization of polygons with
    ename:VK_POLYGON_MODE_POINT is controlled by code:PointSize.
  * pname:nonStrictSinglePixelWideLinesUseParallelogram is a boolean value
    indicating whether non-strict lines with a width of 1.0 are rasterized
    as parallelograms or using Bresenham's algorithm.
  * pname:nonStrictWideLinesUseParallelogram is a boolean value indicating
    whether non-strict lines with a width greater than 1.0 are rasterized as
    parallelograms or using Bresenham's algorithm.

:refpage: VkPhysicalDeviceMaintenance5PropertiesKHR
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceMaintenance5PropertiesKHR.adoc[]
--
endif::VK_KHR_maintenance5[]

ifdef::VK_KHR_maintenance6[]
[open,refpage='VkPhysicalDeviceMaintenance6PropertiesKHR',desc='Structure describing various implementation-defined properties introduced with VK_KHR_maintenance6',type='structs',alias='VkPhysicalDeviceMaintenance6PropertiesKHR']
--
The sname:VkPhysicalDeviceMaintenance6PropertiesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMaintenance6PropertiesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:blockTexelViewCompatibleMultipleLayers is a boolean value
     indicating that an implementation supports creating image views with
     ename:VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT where the
     pname:layerCount member of pname:subresourceRange is greater than `1`.
  * pname:maxCombinedImageSamplerDescriptorCount is the maximum number of
    combined image sampler descriptors that the implementation uses to
    access any of the <<formats-requiring-sampler-ycbcr-conversion, formats
    that require a sampler {YCbCr} conversion>> supported by the
    implementation.
  * pname:fragmentShadingRateClampCombinerInputs is a boolean value
    indicating that an implementation clamps the inputs to
    <<primsrast-fragment-shading-rate-combining, combiner operations>>.

:refpage: VkPhysicalDeviceMaintenance6PropertiesKHR
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceMaintenance6PropertiesKHR.adoc[]
--
endif::VK_KHR_maintenance6[]

ifdef::VK_NV_mesh_shader[]
[open,refpage='VkPhysicalDeviceMeshShaderPropertiesNV',desc='Structure describing mesh shading properties',type='structs']
--
The sname:VkPhysicalDeviceMeshShaderPropertiesNV structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMeshShaderPropertiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:maxDrawMeshTasksCount is the maximum number of local workgroups
    that can: be launched by a single draw mesh tasks command.
    See <<drawing-mesh-shading>>.
  * pname:maxTaskWorkGroupInvocations is the maximum total number of task
    shader invocations in a single local workgroup.
    The product of the X, Y, and Z sizes, as specified by the code:LocalSize
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[or code:LocalSizeId]
    execution mode in shader modules or by the object decorated by the
    code:WorkgroupSize decoration, must: be less than or equal to this
    limit.
  * pname:maxTaskWorkGroupSize[3] is the maximum size of a local task
    workgroup.
    These three values represent the maximum local workgroup size in the X,
    Y, and Z dimensions, respectively.
    The pname:x, pname:y, and pname:z sizes, as specified by the
    code:LocalSize
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[or code:LocalSizeId]
    execution mode or by the object decorated by the code:WorkgroupSize
    decoration in shader modules, must: be less than or equal to the
    corresponding limit.
  * pname:maxTaskTotalMemorySize is the maximum number of bytes that the
    task shader can use in total for shared and output memory combined.
  * pname:maxTaskOutputCount is the maximum number of output tasks a single
    task shader workgroup can emit.
  * pname:maxMeshWorkGroupInvocations is the maximum total number of mesh
    shader invocations in a single local workgroup.
    The product of the X, Y, and Z sizes, as specified by the code:LocalSize
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[or code:LocalSizeId]
    execution mode in shader modules or by the object decorated by the
    code:WorkgroupSize decoration, must: be less than or equal to this
    limit.
  * pname:maxMeshWorkGroupSize[3] is the maximum size of a local mesh
    workgroup.
    These three values represent the maximum local workgroup size in the X,
    Y, and Z dimensions, respectively.
    The pname:x, pname:y, and pname:z sizes, as specified by the
    code:LocalSize
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[or code:LocalSizeId]
    execution mode or by the object decorated by the code:WorkgroupSize
    decoration in shader modules, must: be less than or equal to the
    corresponding limit.
  * pname:maxMeshTotalMemorySize is the maximum number of bytes that the
    mesh shader can use in total for shared and output memory combined.
  * pname:maxMeshOutputVertices is the maximum number of vertices a mesh
    shader output can store.
  * pname:maxMeshOutputPrimitives is the maximum number of primitives a mesh
    shader output can store.
  * pname:maxMeshMultiviewViewCount is the maximum number of multiview views
    a mesh shader can use.
  * pname:meshOutputPerVertexGranularity is the granularity with which mesh
    vertex outputs are allocated.
    The value can be used to compute the memory size used by the mesh
    shader, which must be less than or equal to
    pname:maxMeshTotalMemorySize.
  * pname:meshOutputPerPrimitiveGranularity is the granularity with which
    mesh outputs qualified as per-primitive are allocated.
    The value can be used to compute the memory size used by the mesh
    shader, which must be less than or equal to
    pname:maxMeshTotalMemorySize.

:refpage: VkPhysicalDeviceMeshShaderPropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceMeshShaderPropertiesNV.adoc[]
--
endif::VK_NV_mesh_shader[]

ifdef::VK_EXT_mesh_shader[]

[open,refpage='VkPhysicalDeviceMeshShaderPropertiesEXT',desc='Structure describing mesh shading properties',type='structs']
--
The sname:VkPhysicalDeviceMeshShaderPropertiesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMeshShaderPropertiesEXT.adoc[]

The members of the sname:VkPhysicalDeviceMeshShaderPropertiesEXT structure
describe the following implementation-dependent limits:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-maxTaskWorkGroupTotalCount]] pname:maxTaskWorkGroupTotalCount
    is the maximum number of total local workgroups that can: be launched by
    a single mesh tasks drawing command.
    See <<drawing-mesh-shading>>.
  * [[limits-maxTaskWorkGroupCount]] pname:maxTaskWorkGroupCount[3] is the
    maximum number of local workgroups that can: be launched by a single
    mesh tasks drawing command.
    These three values represent the maximum number of local workgroups for
    the X, Y, and Z dimensions, respectively.
    The workgroup count parameters to the drawing commands must: be less
    than or equal to the corresponding limit.
    The product of these dimensions must: be less than or equal to
    pname:maxTaskWorkGroupTotalCount.
  * [[limits-maxTaskWorkGroupInvocations]] pname:maxTaskWorkGroupInvocations
    is the maximum total number of task shader invocations in a single local
    workgroup.
    The product of the X, Y, and Z sizes, as specified by the code:LocalSize
ifdef::VK_KHR_maintenance4[or code:LocalSizeId]
    execution mode in shader modules or by the object decorated by the
    code:WorkgroupSize decoration, must: be less than or equal to this
    limit.
  * [[limits-maxTaskWorkGroupSize]] pname:maxTaskWorkGroupSize[3] is the
    maximum size of a local task workgroup, per dimension.
    These three values represent the maximum local workgroup size in the X,
    Y, and Z dimensions, respectively.
    The pname:x, pname:y, and pname:z sizes, as specified by the
    code:LocalSize
ifdef::VK_KHR_maintenance4[or code:LocalSizeId]
    execution mode or by the object decorated by the code:WorkgroupSize
    decoration in shader modules, must: be less than or equal to the
    corresponding limit.
  * [[limits-maxTaskPayloadSize]] pname:maxTaskPayloadSize is the maximum
    total storage size, in bytes, available for variables declared with the
    code:TaskPayloadWorkgroupEXT storage class in shader modules in the task
    shader stage.
  * [[limits-maxTaskSharedMemorySize]] pname:maxTaskSharedMemorySize is the
    maximum total storage size, in bytes, available for variables declared
    with the code:Workgroup storage class in shader modules in the task
    shader stage.
  * [[limits-maxTaskPayloadAndSharedMemorySize]]
    pname:maxTaskPayloadAndSharedMemorySize is the maximum total storage
    size, in bytes, available for variables that are declared with the
    code:TaskPayloadWorkgroupEXT or code:Workgroup storage class, in shader
    modules in the task shader stage.
  * [[limits-maxMeshWorkGroupTotalCount]] pname:maxMeshWorkGroupTotalCount
    is the maximum number of local output tasks a single task shader
    workgroup can emit.
  * [[limits-maxMeshWorkGroupCount]] pname:maxMeshWorkGroupCount[3] is the
    maximum number of local output tasks a single task shader workgroup can
    emit, per dimension.
    These three values represent the maximum number of local output tasks
    for the X, Y, and Z dimensions, respectively.
    The workgroup count parameters to the code:OpEmitMeshTasksEXT must: be
    less than or equal to the corresponding limit.
    The product of these dimensions must: be less than or equal to
    pname:maxMeshWorkGroupTotalCount.
  * [[limits-maxMeshWorkGroupInvocations]] pname:maxMeshWorkGroupInvocations
    is the maximum total number of mesh shader invocations in a single local
    workgroup.
    The product of the X, Y, and Z sizes, as specified by the code:LocalSize
ifdef::VK_KHR_maintenance4[or code:LocalSizeId]
    execution mode in shader modules or by the object decorated by the
    code:WorkgroupSize decoration, must: be less than or equal to this
    limit.
  * [[limits-maxMeshWorkGroupSize]] pname:maxMeshWorkGroupSize[3] is the
    maximum size of a local mesh workgroup, per dimension.
    These three values represent the maximum local workgroup size in the X,
    Y, and Z dimensions, respectively.
    The pname:x, pname:y, and pname:z sizes, as specified by the
    code:LocalSize
ifdef::VK_KHR_maintenance4[or code:LocalSizeId]
    execution mode or by the object decorated by the code:WorkgroupSize
    decoration in shader modules, must: be less than or equal to the
    corresponding limit.
  * [[limits-maxMeshSharedMemorySize]] pname:maxMeshSharedMemorySize is the
    maximum total storage size, in bytes, available for variables declared
    with the code:Workgroup storage class in shader modules in the mesh
    shader stage.
  * [[limits-maxMeshPayloadAndSharedMemorySize]]
    pname:maxMeshPayloadAndSharedMemorySize is the maximum total storage
    size, in bytes, available for variables that are declared with the
    code:TaskPayloadWorkgroupEXT or code:Workgroup storage class in shader
    modules in the mesh shader stage.
  * [[limits-maxMeshOutputMemorySize]] pname:maxMeshOutputMemorySize is the
    maximum total storage size, in bytes, available for output variables in
    shader modules in the mesh shader stage, according to the formula in
    <<mesh-output, Mesh Shader Output>>.
  * [[limits-maxMeshPayloadAndOutputMemorySize]]
    pname:maxMeshPayloadAndOutputMemorySize is the maximum total storage
    size, in bytes, available for variables that are declared with the
    code:TaskPayloadWorkgroupEXT storage class, or output variables in
    shader modules in the mesh shader stage, according to the formula in
    <<mesh-output, Mesh Shader Output>>.
  * [[limits-maxMeshOutputComponents]] pname:maxMeshOutputComponents is the
    maximum number of components of output variables which can: be output
    from the mesh shader stage.
  * [[limits-maxMeshOutputVertices]] pname:maxMeshOutputVertices is the
    maximum number of vertices which can: be emitted by a single mesh shader
    workgroup.
  * [[limits-maxMeshOutputPrimitives]] pname:maxMeshOutputPrimitives is the
    maximum number of primitives which can: be emitted by a single mesh
    shader workgroup.
  * [[limits-maxMeshOutputLayers]] pname:maxMeshOutputLayers is one greater
    than the maximum layer index that can: be output from the mesh shader
    stage.
  * [[limits-maxMeshMultiviewViewCount]] pname:maxMeshMultiviewViewCount is
    one greater than the maximum view index that can: be used by any mesh
    shader.
  * [[limits-meshOutputPerVertexGranularity]]
    pname:meshOutputPerVertexGranularity is the granularity of vertex
    allocation.
    The number of output vertices allocated for the mesh shader stage is
    padded to a multiple of this number.
    The value can be used to calculate the required storage size for output
    variables in shader modules in the mesh shader stage, which must: be
    less than or equal to pname:maxMeshOutputMemorySize.
  * [[limits-meshOutputPerPrimitiveGranularity]]
    pname:meshOutputPerPrimitiveGranularity is the granularity of primitive
    allocation.
    The number of output primitives allocated for the mesh shader stage is
    padded to a multiple of this number.
    The value can be used to calculate the required storage size for output
    variables in shader modules in the mesh shader stage, which must: be
    less than or equal to pname:maxMeshOutputMemorySize.
  * [[limits-maxPreferredTaskWorkGroupInvocations]]
    pname:maxPreferredTaskWorkGroupInvocations is the maximum number of task
    shader invocations in a single workgroup that is preferred by the
    implementation for optimal performance.
    The value is guaranteed to be a multiple of a supported subgroup size
    for the task shader stage.
  * [[limits-maxPreferredMeshWorkGroupInvocations]]
    pname:maxPreferredMeshWorkGroupInvocations is the maximum number of mesh
    shader invocations in a single workgroup that is preferred by the
    implementation for optimal performance.
    The value is guaranteed to be a multiple of a supported subgroup size
    for the mesh shader stage.
  * [[limits-prefersLocalInvocationVertexOutput]]
    pname:prefersLocalInvocationVertexOutput specifies whether writes to the
    vertex output array in a mesh shader yield best performance when the
    array index matches code:LocalInvocationIndex.
  * [[limits-prefersLocalInvocationPrimitiveOutput]]
    pname:prefersLocalInvocationPrimitiveOutput specifies whether writes to
    the primitive output array in a mesh shader yield best performance when
    the array index matches code:LocalInvocationIndex.
  * [[limits-prefersCompactVertexOutput]] pname:prefersCompactVertexOutput
    specifies whether output vertices should be compacted after custom
    culling in the mesh shader for best performance, otherwise keeping the
    vertices at their original location may be better.
  * [[limits-prefersCompactPrimitiveOutput]]
    pname:prefersCompactPrimitiveOutput specifies whether output primitives
    should be compacted after custom culling in the mesh shader for best
    performance, otherwise the use of code:CullPrimitiveEXT may be better.

If the sname:VkPhysicalDeviceMeshShaderPropertiesEXT structure is included
in the pname:pNext chain of slink:VkPhysicalDeviceProperties2, it is filled
with the implementation-dependent limits.

include::{generated}/validity/structs/VkPhysicalDeviceMeshShaderPropertiesEXT.adoc[]
--

endif::VK_EXT_mesh_shader[]

ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
[open,refpage='VkPhysicalDeviceDescriptorIndexingProperties',desc='Structure describing descriptor indexing properties that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceDescriptorIndexingPropertiesEXT']
--
The sname:VkPhysicalDeviceDescriptorIndexingProperties structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDescriptorIndexingProperties.adoc[]

ifdef::VK_EXT_descriptor_indexing[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceDescriptorIndexingPropertiesEXT.adoc[]
endif::VK_EXT_descriptor_indexing[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_descriptor_indexing-properties[]
  * [[{anchor-prefix}limits-maxUpdateAfterBindDescriptorsInAllPools]]
    pname:maxUpdateAfterBindDescriptorsInAllPools is the maximum number of
    descriptors (summed over all descriptor types) that can: be created
    across all pools that are created with the
    ename:VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT bit set.
    Pool creation may: fail when this limit is exceeded, or when the space
    this limit represents is unable to satisfy a pool creation due to
    fragmentation.
  * [[{anchor-prefix}limits-shaderUniformBufferArrayNonUniformIndexingNative]]
    pname:shaderUniformBufferArrayNonUniformIndexingNative is a boolean
    value indicating whether uniform buffer descriptors natively support
    nonuniform indexing.
    If this is ename:VK_FALSE, then a single dynamic instance of an
    instruction that nonuniformly indexes an array of uniform buffers may:
    execute multiple times in order to access all the descriptors.
  * [[{anchor-prefix}limits-shaderSampledImageArrayNonUniformIndexingNative]]
    pname:shaderSampledImageArrayNonUniformIndexingNative is a boolean value
    indicating whether sampler and image descriptors natively support
    nonuniform indexing.
    If this is ename:VK_FALSE, then a single dynamic instance of an
    instruction that nonuniformly indexes an array of samplers or images
    may: execute multiple times in order to access all the descriptors.
  * [[{anchor-prefix}limits-shaderStorageBufferArrayNonUniformIndexingNative]]
    pname:shaderStorageBufferArrayNonUniformIndexingNative is a boolean
    value indicating whether storage buffer descriptors natively support
    nonuniform indexing.
    If this is ename:VK_FALSE, then a single dynamic instance of an
    instruction that nonuniformly indexes an array of storage buffers may:
    execute multiple times in order to access all the descriptors.
  * [[{anchor-prefix}limits-shaderStorageImageArrayNonUniformIndexingNative]]
    pname:shaderStorageImageArrayNonUniformIndexingNative is a boolean value
    indicating whether storage image descriptors natively support nonuniform
    indexing.
    If this is ename:VK_FALSE, then a single dynamic instance of an
    instruction that nonuniformly indexes an array of storage images may:
    execute multiple times in order to access all the descriptors.
  * [[{anchor-prefix}limits-shaderInputAttachmentArrayNonUniformIndexingNative]]
    pname:shaderInputAttachmentArrayNonUniformIndexingNative is a boolean
    value indicating whether input attachment descriptors natively support
    nonuniform indexing.
    If this is ename:VK_FALSE, then a single dynamic instance of an
    instruction that nonuniformly indexes an array of input attachments may:
    execute multiple times in order to access all the descriptors.
  * [[{anchor-prefix}limits-robustBufferAccessUpdateAfterBind]]
    pname:robustBufferAccessUpdateAfterBind is a boolean value indicating
    whether <<features-robustBufferAccess, pname:robustBufferAccess>> can:
    be enabled on a device simultaneously with
    pname:descriptorBindingUniformBufferUpdateAfterBind,
    pname:descriptorBindingStorageBufferUpdateAfterBind,
    pname:descriptorBindingUniformTexelBufferUpdateAfterBind, and/or
    pname:descriptorBindingStorageTexelBufferUpdateAfterBind.
    If this is ename:VK_FALSE, then either pname:robustBufferAccess must: be
    disabled or all of these update-after-bind features must: be disabled.
  * [[{anchor-prefix}limits-quadDivergentImplicitLod]]
    pname:quadDivergentImplicitLod is a boolean value indicating whether
    implicit LOD calculations for image operations have well-defined results
    when the image and/or sampler objects used for the instruction are not
    uniform within a quad.
    See <<textures-derivative-image-operations,Derivative Image
    Operations>>.
  * [[{anchor-prefix}limits-maxPerStageDescriptorUpdateAfterBindSamplers]]
    pname:maxPerStageDescriptorUpdateAfterBindSamplers is similar to
    pname:maxPerStageDescriptorSamplers but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[{anchor-prefix}limits-maxPerStageDescriptorUpdateAfterBindUniformBuffers]]
    pname:maxPerStageDescriptorUpdateAfterBindUniformBuffers is similar to
    pname:maxPerStageDescriptorUniformBuffers but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[{anchor-prefix}limits-maxPerStageDescriptorUpdateAfterBindStorageBuffers]]
    pname:maxPerStageDescriptorUpdateAfterBindStorageBuffers is similar to
    pname:maxPerStageDescriptorStorageBuffers but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[{anchor-prefix}limits-maxPerStageDescriptorUpdateAfterBindSampledImages]]
    pname:maxPerStageDescriptorUpdateAfterBindSampledImages is similar to
    pname:maxPerStageDescriptorSampledImages but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[{anchor-prefix}limits-maxPerStageDescriptorUpdateAfterBindStorageImages]]
    pname:maxPerStageDescriptorUpdateAfterBindStorageImages is similar to
    pname:maxPerStageDescriptorStorageImages but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[{anchor-prefix}limits-maxPerStageDescriptorUpdateAfterBindInputAttachments]]
    pname:maxPerStageDescriptorUpdateAfterBindInputAttachments is similar to
    pname:maxPerStageDescriptorInputAttachments but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[{anchor-prefix}limits-maxPerStageUpdateAfterBindResources]]
    pname:maxPerStageUpdateAfterBindResources is similar to
    pname:maxPerStageResources but counts descriptors from descriptor sets
    created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[{anchor-prefix}limits-maxDescriptorSetUpdateAfterBindSamplers]]
    pname:maxDescriptorSetUpdateAfterBindSamplers is similar to
    pname:maxDescriptorSetSamplers but counts descriptors from descriptor
    sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[{anchor-prefix}limits-maxDescriptorSetUpdateAfterBindUniformBuffers]]
    pname:maxDescriptorSetUpdateAfterBindUniformBuffers is similar to
    pname:maxDescriptorSetUniformBuffers but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[{anchor-prefix}limits-maxDescriptorSetUpdateAfterBindUniformBuffersDynamic]]
    pname:maxDescriptorSetUpdateAfterBindUniformBuffersDynamic is similar to
    pname:maxDescriptorSetUniformBuffersDynamic but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
    While an application can: allocate dynamic uniform buffer descriptors
    from a pool created with the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
    bindings for these descriptors must: not be present in any descriptor
    set layout that includes bindings created with
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT.
  * [[{anchor-prefix}limits-maxDescriptorSetUpdateAfterBindStorageBuffers]]
    pname:maxDescriptorSetUpdateAfterBindStorageBuffers is similar to
    pname:maxDescriptorSetStorageBuffers but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[{anchor-prefix}limits-maxDescriptorSetUpdateAfterBindStorageBuffersDynamic]]
    pname:maxDescriptorSetUpdateAfterBindStorageBuffersDynamic is similar to
    pname:maxDescriptorSetStorageBuffersDynamic but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
    While an application can: allocate dynamic storage buffer descriptors
    from a pool created with the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
    bindings for these descriptors must: not be present in any descriptor
    set layout that includes bindings created with
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT.
  * [[{anchor-prefix}limits-maxDescriptorSetUpdateAfterBindSampledImages]]
    pname:maxDescriptorSetUpdateAfterBindSampledImages is similar to
    pname:maxDescriptorSetSampledImages but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[{anchor-prefix}limits-maxDescriptorSetUpdateAfterBindStorageImages]]
    pname:maxDescriptorSetUpdateAfterBindStorageImages is similar to
    pname:maxDescriptorSetStorageImages but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[{anchor-prefix}limits-maxDescriptorSetUpdateAfterBindInputAttachments]]
    pname:maxDescriptorSetUpdateAfterBindInputAttachments is similar to
    pname:maxDescriptorSetInputAttachments but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
// end::VK_EXT_descriptor_indexing-properties[]

:refpage: VkPhysicalDeviceDescriptorIndexingProperties
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceDescriptorIndexingProperties.adoc[]
--
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]

ifdef::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]
[open,refpage='VkPhysicalDeviceInlineUniformBlockProperties',desc='Structure describing inline uniform block properties that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceInlineUniformBlockPropertiesEXT']
--
The sname:VkPhysicalDeviceInlineUniformBlockProperties structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceInlineUniformBlockProperties.adoc[]

ifdef::VK_EXT_inline_uniform_block[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceInlineUniformBlockPropertiesEXT.adoc[]
endif::VK_EXT_inline_uniform_block[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_EXT_inline_uniform_block-properties[]
  * [[{anchor-prefix}limits-maxInlineUniformBlockSize]]
    pname:maxInlineUniformBlockSize is the maximum size in bytes of an
    <<descriptorsets-inlineuniformblock, inline uniform block>> binding.
  * [[{anchor-prefix}limits-maxPerStageDescriptorInlineUniformBlocks]]
    pname:maxPerStageDescriptorInlineUniformBlocks is the maximum number of
    inline uniform block bindings that can: be accessible to a single shader
    stage in a pipeline layout.
    Descriptor bindings with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK count against this limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptor bindings in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  * [[{anchor-prefix}limits-maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks]]
    pname:maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks
ifndef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    equals pname:maxPerStageDescriptorInlineUniformBlocks and is reserved
    for future use.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    is similar to pname:maxPerStageDescriptorInlineUniformBlocks but counts
    descriptor bindings from descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  * [[{anchor-prefix}limits-maxDescriptorSetInlineUniformBlocks]]
    pname:maxDescriptorSetInlineUniformBlocks is the maximum number of
    inline uniform block bindings that can: be included in descriptor
    bindings in a pipeline layout across all pipeline shader stages and
    descriptor set numbers.
    Descriptor bindings with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK count against this limit.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    Only descriptor bindings in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  * [[{anchor-prefix}limits-maxDescriptorSetUpdateAfterBindInlineUniformBlocks]]
    pname:maxDescriptorSetUpdateAfterBindInlineUniformBlocks
ifndef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    equals pname:maxDescriptorSetInlineUniformBlocks and is reserved for
    future use.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    is similar to pname:maxDescriptorSetInlineUniformBlocks but counts
    descriptor bindings from descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
// end::VK_EXT_inline_uniform_block-properties[]

:refpage: VkPhysicalDeviceInlineUniformBlockProperties
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceInlineUniformBlockProperties.adoc[]
--
endif::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]

ifdef::VK_EXT_conservative_rasterization[]
[open,refpage='VkPhysicalDeviceConservativeRasterizationPropertiesEXT',desc='Structure describing conservative raster properties that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceConservativeRasterizationPropertiesEXT structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceConservativeRasterizationPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-primitiveOverestimationSize]] pname:primitiveOverestimationSize
    is the size in pixels the generating primitive is increased at each of
    its edges during conservative rasterization overestimation mode.
    Even with a size of 0.0, conservative rasterization overestimation rules
    still apply and if any part of the pixel rectangle is covered by the
    generating primitive, fragments are generated for the entire pixel.
    However implementations may: make the pixel coverage area even more
    conservative by increasing the size of the generating primitive.
  * [[limits-maxExtraPrimitiveOverestimationSize]]
    pname:maxExtraPrimitiveOverestimationSize is the maximum size in pixels
    of extra overestimation the implementation supports in the pipeline
    state.
    A value of 0.0 means the implementation does not support any additional
    overestimation of the generating primitive during conservative
    rasterization.
    A value above 0.0 allows the application to further increase the size of
    the generating primitive during conservative rasterization
    overestimation.
  * [[limits-extraPrimitiveOverestimationSizeGranularity]]
    pname:extraPrimitiveOverestimationSizeGranularity is the granularity of
    extra overestimation that can be specified in the pipeline state between
    0.0 and pname:maxExtraPrimitiveOverestimationSize inclusive.
    A value of 0.0 means the implementation can use the smallest
    representable non-zero value in the screen space pixel fixed-point grid.
  * [[limits-primitiveUnderestimation]] pname:primitiveUnderestimation is
    ename:VK_TRUE if the implementation supports the
    ename:VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT conservative
    rasterization mode in addition to
    ename:VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT.
    Otherwise the implementation only supports
    ename:VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT.
  * [[limits-conservativePointAndLineRasterization]]
    pname:conservativePointAndLineRasterization is ename:VK_TRUE if the
    implementation supports conservative rasterization of point and line
    primitives as well as triangle primitives.
    Otherwise the implementation only supports triangle primitives.
  * [[limits-degenerateTrianglesRasterized]]
    pname:degenerateTrianglesRasterized is ename:VK_FALSE if the
    implementation culls primitives generated from triangles that become
    zero area after they are quantized to the fixed-point rasterization
    pixel grid.
    pname:degenerateTrianglesRasterized is ename:VK_TRUE if these primitives
    are not culled and the provoking vertex attributes and depth value are
    used for the fragments.
    The primitive area calculation is done on the primitive generated from
    the clipped triangle if applicable.
    Zero area primitives are backfacing and the application can: enable
    backface culling if desired.
  * [[limits-degenerateLinesRasterized]] pname:degenerateLinesRasterized is
    ename:VK_FALSE if the implementation culls lines that become zero length
    after they are quantized to the fixed-point rasterization pixel grid.
    pname:degenerateLinesRasterized is ename:VK_TRUE if zero length lines
    are not culled and the provoking vertex attributes and depth value are
    used for the fragments.
  * [[limits-fullyCoveredFragmentShaderInputVariable]]
    pname:fullyCoveredFragmentShaderInputVariable is ename:VK_TRUE if the
    implementation supports the SPIR-V builtin fragment shader input
    variable code:FullyCoveredEXT specifying that conservative rasterization
    is enabled and the fragment area is fully covered by the generating
    primitive.
  * [[limits-conservativeRasterizationPostDepthCoverage]]
ifdef::VK_EXT_post_depth_coverage[]
    pname:conservativeRasterizationPostDepthCoverage is ename:VK_TRUE if the
    implementation supports conservative rasterization with the
    code:PostDepthCoverage execution mode enabled.
    Otherwise the code:PostDepthCoverage execution mode must: not be used
    when conservative rasterization is enabled.
endif::VK_EXT_post_depth_coverage[]
ifndef::VK_EXT_post_depth_coverage[]
    pname:conservativeRasterizationPostDepthCoverage must: be
    ename:VK_FALSE.
endif::VK_EXT_post_depth_coverage[]

:refpage: VkPhysicalDeviceConservativeRasterizationPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceConservativeRasterizationPropertiesEXT.adoc[]
--
endif::VK_EXT_conservative_rasterization[]

ifdef::VK_EXT_fragment_density_map[]
[open,refpage='VkPhysicalDeviceFragmentDensityMapPropertiesEXT',desc='Structure describing fragment density map properties that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentDensityMapPropertiesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentDensityMapPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-minFragmentDensityTexelSize]] pname:minFragmentDensityTexelSize
    is the minimum <<glossary-fragment-density-texel-size,fragment density
    texel size>>.
  * [[limits-maxFragmentDensityTexelSize]] pname:maxFragmentDensityTexelSize
    is the maximum fragment density texel size.
  * [[limits-fragmentDensityInvocations]] pname:fragmentDensityInvocations
    specifies whether the implementation may: invoke additional fragment
    shader invocations for each covered sample.

:refpage: VkPhysicalDeviceFragmentDensityMapPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentDensityMapPropertiesEXT.adoc[]
--

ifdef::VK_EXT_fragment_density_map2[]
[open,refpage='VkPhysicalDeviceFragmentDensityMap2PropertiesEXT',desc='Structure describing additional fragment density map properties that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentDensityMap2PropertiesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-subsampledLoads]] pname:subsampledLoads specifies if performing
    image data read with load operations on subsampled attachments will be
    resampled to the fragment density of the render pass
  * [[limits-subsampledCoarseReconstructionEarlyAccess]]
    pname:subsampledCoarseReconstructionEarlyAccess specifies if performing
    image data read with samplers created with pname:flags containing
    ename:VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT in
    fragment shader will trigger additional reads during
    ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT
  * [[limits-maxSubsampledArrayLayers]] pname:maxSubsampledArrayLayers is
    the maximum number of slink:VkImageView array layers for usages
    supporting subsampled samplers
  * [[limits-maxDescriptorSetSubsampledSamplers]]
    pname:maxDescriptorSetSubsampledSamplers is the maximum number of
    subsampled samplers that can: be included in a slink:VkPipelineLayout

:refpage: VkPhysicalDeviceFragmentDensityMap2PropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.adoc[]
--
endif::VK_EXT_fragment_density_map2[]

ifdef::VK_QCOM_fragment_density_map_offset[]
[open,refpage='VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM',desc='Structure describing fragment density map offset properties that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-fragmentdensityoffsetgranularity]]
    pname:fragmentDensityOffsetGranularity is the granularity for
    <<renderpass-fragmentdensitymapoffsets,fragment density offsets>>.

:refpage: VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM.adoc[]
--
endif::VK_QCOM_fragment_density_map_offset[]
endif::VK_EXT_fragment_density_map[]

ifdef::VK_AMD_shader_core_properties[]
[open,refpage='VkPhysicalDeviceShaderCorePropertiesAMD',desc='Structure describing shader core properties that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderCorePropertiesAMD structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderCorePropertiesAMD.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-shaderEngineCount]] pname:shaderEngineCount is an unsigned
    integer value indicating the number of shader engines found inside the
    shader core of the physical device.
  * [[limits-shaderArraysPerEngineCount]] pname:shaderArraysPerEngineCount
    is an unsigned integer value indicating the number of shader arrays
    inside a shader engine.
    Each shader array has its own scan converter, set of compute units, and
    a render back end (color and depth attachments).
    Shader arrays within a shader engine share shader processor input (wave
    launcher) and shader export (export buffer) units.
    Currently, a shader engine can have one or two shader arrays.
  * [[limits-computeUnitsPerShaderArray]] pname:computeUnitsPerShaderArray
    is an unsigned integer value indicating the physical number of compute
    units within a shader array.
    The active number of compute units in a shader array may: be lower.
    A compute unit houses a set of SIMDs along with a sequencer module and a
    local data store.
  * [[limits-simdPerComputeUnit]] pname:simdPerComputeUnit is an unsigned
    integer value indicating the number of SIMDs inside a compute unit.
    Each SIMD processes a single instruction at a time.
  * [[limits-wavefrontSize]] pname:wavefrontSize is an unsigned integer
    value indicating the maximum size of a subgroup.
  * [[limits-sgprsPerSimd]] pname:sgprsPerSimd is an unsigned integer value
    indicating the number of physical Scalar General-Purpose Registers
    (SGPRs) per SIMD.
  * [[limits-minSgprAllocation]] pname:minSgprAllocation is an unsigned
    integer value indicating the minimum number of SGPRs allocated for a
    wave.
  * [[limits-maxSgprAllocation]] pname:maxSgprAllocation is an unsigned
    integer value indicating the maximum number of SGPRs allocated for a
    wave.
  * [[limits-sgprAllocationGranularity]] pname:sgprAllocationGranularity is
    an unsigned integer value indicating the granularity of SGPR allocation
    for a wave.
  * [[limits-vgprsPerSimd]] pname:vgprsPerSimd is an unsigned integer value
    indicating the number of physical Vector General-Purpose Registers
    (VGPRs) per SIMD.
  * [[limits-minVgprAllocation]] pname:minVgprAllocation is an unsigned
    integer value indicating the minimum number of VGPRs allocated for a
    wave.
  * [[limits-maxVgprAllocation]] pname:maxVgprAllocation is an unsigned
    integer value indicating the maximum number of VGPRs allocated for a
    wave.
  * [[limits-vgprAllocationGranularity]] pname:vgprAllocationGranularity is
    an unsigned integer value indicating the granularity of VGPR allocation
    for a wave.

:refpage: VkPhysicalDeviceShaderCorePropertiesAMD
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceShaderCorePropertiesAMD.adoc[]
--
endif::VK_AMD_shader_core_properties[]

ifdef::VK_AMD_shader_core_properties2[]
[open,refpage='VkPhysicalDeviceShaderCoreProperties2AMD',desc='Structure describing shader core properties that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderCoreProperties2AMD structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderCoreProperties2AMD.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderCoreFeatures]] pname:shaderCoreFeatures is a bitmask of
    elink:VkShaderCorePropertiesFlagBitsAMD indicating the set of features
    supported by the shader core.
  * [[limits-activeComputeUnitCount]] pname:activeComputeUnitCount is an
    unsigned integer value indicating the number of compute units that have
    been enabled.

:refpage: VkPhysicalDeviceShaderCoreProperties2AMD
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceShaderCoreProperties2AMD.adoc[]
--

[open,refpage='VkShaderCorePropertiesFlagBitsAMD',desc='Bitmask specifying shader core properties',type='enums',xrefs='VkPhysicalDeviceShaderCoreProperties2AMD VkShaderCorePropertiesFlagsAMD']
--
Bits for this type may: be defined by future extensions, or new versions of
the `apiext:VK_AMD_shader_core_properties2` extension.
Possible values of the pname:flags member of
tlink:VkShaderCorePropertiesFlagsAMD are:

include::{generated}/api/enums/VkShaderCorePropertiesFlagBitsAMD.adoc[]
--

[open,refpage='VkShaderCorePropertiesFlagsAMD',desc='Bitmask of VkShaderCorePropertiesFlagBitsAMD',type='flags',xrefs='VkPhysicalDeviceShaderCoreProperties2AMD VkShaderCorePropertiesFlagBitsAMD']
--
include::{generated}/api/flags/VkShaderCorePropertiesFlagsAMD.adoc[]

tname:VkShaderCorePropertiesFlagsAMD is a bitmask type for providing zero or
more elink:VkShaderCorePropertiesFlagBitsAMD.
--
endif::VK_AMD_shader_core_properties2[]

ifdef::VK_VERSION_1_2,VK_KHR_depth_stencil_resolve[]
[open,refpage='VkPhysicalDeviceDepthStencilResolveProperties',desc='Structure describing depth/stencil resolve properties that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceDepthStencilResolvePropertiesKHR']
--
The sname:VkPhysicalDeviceDepthStencilResolveProperties structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDepthStencilResolveProperties.adoc[]

ifdef::VK_KHR_depth_stencil_resolve[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceDepthStencilResolvePropertiesKHR.adoc[]
endif::VK_KHR_depth_stencil_resolve[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_depth_stencil_resolve-properties[]
  * [[{anchor-prefix}features-depthResolveModes]]
    pname:supportedDepthResolveModes is a bitmask of
    elink:VkResolveModeFlagBits indicating the set of supported depth
    resolve modes.
ifdef::VKSC_VERSION_1_0[]
    A value of ename:VK_RESOLVE_MODE_NONE indicates that depth resolve
    operations are disallowed <<SCID-8>>.
    If any bits are set then
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkPhysicalDeviceVulkan12Properties::pname:supportedDepthResolveModes
    may: be only ename:VK_RESOLVE_MODE_NONE <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]
    ename:VK_RESOLVE_MODE_SAMPLE_ZERO_BIT must: be included in the set but
    implementations may: support additional modes.
  * [[{anchor-prefix}features-stencilResolveModes]]
    pname:supportedStencilResolveModes is a bitmask of
    elink:VkResolveModeFlagBits indicating the set of supported stencil
    resolve modes.
ifdef::VKSC_VERSION_1_0[]
    A value of ename:VK_RESOLVE_MODE_NONE indicates that stencil resolve
    operations are disallowed <<SCID-8>>.
    If any bits are set then
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkPhysicalDeviceVulkan12Properties::pname:supportedStencilResolveModes
    may: be only ename:VK_RESOLVE_MODE_NONE <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]
    ename:VK_RESOLVE_MODE_SAMPLE_ZERO_BIT must: be included in the set but
    implementations may: support additional modes.
    ename:VK_RESOLVE_MODE_AVERAGE_BIT must: not be included in the set.
  * [[{anchor-prefix}features-independentResolveNone]]
    pname:independentResolveNone is ename:VK_TRUE if the implementation
    supports setting the depth and stencil resolve modes to different values
    when one of those modes is ename:VK_RESOLVE_MODE_NONE.
    Otherwise the implementation only supports setting both modes to the
    same value.
  * [[{anchor-prefix}features-independentResolve]] pname:independentResolve
    is ename:VK_TRUE if the implementation supports all combinations of the
    supported depth and stencil resolve modes, including setting either
    depth or stencil resolve mode to ename:VK_RESOLVE_MODE_NONE.
    An implementation that supports pname:independentResolve must: also
    support pname:independentResolveNone.
// end::VK_KHR_depth_stencil_resolve-properties[]

:refpage: VkPhysicalDeviceDepthStencilResolveProperties
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceDepthStencilResolveProperties.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_depth_stencil_resolve[]

ifdef::VK_KHR_performance_query[]
include::{chapters}/VK_KHR_performance_query/props.adoc[]
endif::VK_KHR_performance_query[]

ifdef::VK_NV_shading_rate_image[]
[open,refpage='VkPhysicalDeviceShadingRateImagePropertiesNV',desc='Structure describing shading rate image limits that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShadingRateImagePropertiesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShadingRateImagePropertiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-shadingRateTexelSize]] pname:shadingRateTexelSize indicates the
    width and height of the portion of the framebuffer corresponding to each
    texel in the shading rate image.
  * [[limits-shadingRatePaletteSize]] pname:shadingRatePaletteSize indicates
    the maximum number of palette entries supported for the shading rate
    image.
  * [[limits-shadingRateMaxCoarseSamples]] pname:shadingRateMaxCoarseSamples
    specifies the maximum number of coverage samples supported in a single
    fragment.
    If the product of the fragment size derived from the base shading rate
    and the number of coverage samples per pixel exceeds this limit, the
    final shading rate will be adjusted so that its product does not exceed
    the limit.

:refpage: VkPhysicalDeviceShadingRateImagePropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

These properties are related to the <<primsrast-shading-rate-image, shading
rate image>> feature.

include::{generated}/validity/structs/VkPhysicalDeviceShadingRateImagePropertiesNV.adoc[]
--
endif::VK_NV_shading_rate_image[]

ifdef::VK_NV_memory_decompression[]
[open,refpage='VkPhysicalDeviceMemoryDecompressionPropertiesNV',desc='Structure describing supported memory decompression methods by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMemoryDecompressionPropertiesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceMemoryDecompressionPropertiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:decompressionMethods is a bitmask of
    elink:VkMemoryDecompressionMethodFlagBitsNV specifying memory
    decompression methods supported by the implementation.
  * pname:maxDecompressionIndirectCount specifies the maximum supported
    count value in the pname:countBuffer of
    flink:vkCmdDecompressMemoryIndirectCountNV

:refpage: VkPhysicalDeviceMemoryDecompressionPropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceMemoryDecompressionPropertiesNV.adoc[]
--
endif::VK_NV_memory_decompression[]

ifdef::VK_EXT_transform_feedback[]
[open,refpage='VkPhysicalDeviceTransformFeedbackPropertiesEXT',desc='Structure describing transform feedback properties that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceTransformFeedbackPropertiesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceTransformFeedbackPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-maxTransformFeedbackStreams]] pname:maxTransformFeedbackStreams
    is the maximum number of vertex streams that can be output from geometry
    shaders declared with the code:GeometryStreams capability.
    If the implementation does not support
    sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT::pname:geometryStreams
    then pname:maxTransformFeedbackStreams must: be set to `1`.
  * [[limits-maxTransformFeedbackBuffers]] pname:maxTransformFeedbackBuffers
    is the maximum number of transform feedback buffers that can be bound
    for capturing shader outputs from the last
    <<pipelines-graphics-subsets-pre-rasterization,pre-rasterization shader
    stage>>.
  * [[limits-maxTransformFeedbackBufferSize]]
    pname:maxTransformFeedbackBufferSize is the maximum size that can be
    specified when binding a buffer for transform feedback in
    flink:vkCmdBindTransformFeedbackBuffersEXT.
  * [[limits-maxTransformFeedbackStreamDataSize]]
    pname:maxTransformFeedbackStreamDataSize is the maximum amount of data
    in bytes for each vertex that captured to one or more transform feedback
    buffers associated with a specific vertex stream.
  * [[limits-maxTransformFeedbackBufferDataSize]]
    pname:maxTransformFeedbackBufferDataSize is the maximum amount of data
    in bytes for each vertex that can be captured to a specific transform
    feedback buffer.
  * [[limits-maxTransformFeedbackBufferDataStride]]
    pname:maxTransformFeedbackBufferDataStride is the maximum stride between
    each capture of vertex data to the buffer.
  * [[limits-transformFeedbackQueries]] pname:transformFeedbackQueries is
    ename:VK_TRUE if the implementation supports the
    ename:VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT query type.
    pname:transformFeedbackQueries is ename:VK_FALSE if queries of this type
    cannot: be created.
  * [[limits-transformFeedbackStreamsLinesTriangles]]
    pname:transformFeedbackStreamsLinesTriangles is ename:VK_TRUE if the
    implementation supports the geometry shader code:OpExecutionMode of
    code:OutputLineStrip and code:OutputTriangleStrip in addition to
    code:OutputPoints when more than one vertex stream is output.
    If pname:transformFeedbackStreamsLinesTriangles is ename:VK_FALSE the
    implementation only supports an code:OpExecutionMode of
    code:OutputPoints when more than one vertex stream is output from the
    geometry shader.
  * [[limits-transformFeedbackRasterizationStreamSelect]]
    pname:transformFeedbackRasterizationStreamSelect is ename:VK_TRUE if the
    implementation supports the code:GeometryStreams SPIR-V capability and
    the application can use
    slink:VkPipelineRasterizationStateStreamCreateInfoEXT to modify which
    vertex stream output is used for rasterization.
    Otherwise vertex stream `0` must: always be used for rasterization.
  * [[limits-transformFeedbackDraw]] pname:transformFeedbackDraw is
    ename:VK_TRUE if the implementation supports the
    flink:vkCmdDrawIndirectByteCountEXT function otherwise the function
    must: not be called.

:refpage: VkPhysicalDeviceTransformFeedbackPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceTransformFeedbackPropertiesEXT.adoc[]
--
endif::VK_EXT_transform_feedback[]

ifdef::VK_NV_copy_memory_indirect[]
[open,refpage='VkPhysicalDeviceCopyMemoryIndirectPropertiesNV',desc='Structure describing supported queues for indirect copy',type='structs']
--
The sname:VkPhysicalDeviceCopyMemoryIndirectPropertiesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceCopyMemoryIndirectPropertiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:supportedQueues is a bitmask of elink:VkQueueFlagBits indicating
    the queues on which <<indirect-copies, indirect copy commands>> are
    supported.

If the <<features-indirectCopy, pname:indirectCopy>> feature is supported,
pname:supportedQueues must: return at least one supported queue.

:refpage: VkPhysicalDeviceCopyMemoryIndirectPropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceCopyMemoryIndirectPropertiesNV.adoc[]
--
endif::VK_NV_copy_memory_indirect[]

ifdef::VK_NV_ray_tracing[]
[open,refpage='VkPhysicalDeviceRayTracingPropertiesNV',desc='Properties of the physical device for ray tracing',type='structs']
--
The sname:VkPhysicalDeviceRayTracingPropertiesNV structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceRayTracingPropertiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:shaderGroupHandleSize is the size in bytes of the shader header.
  * [[limits-maxRecursionDepth]] pname:maxRecursionDepth is the maximum
    number of levels of recursion allowed in a trace command.
  * pname:maxShaderGroupStride is the maximum stride in bytes allowed
    between shader groups in the shader binding table.
  * pname:shaderGroupBaseAlignment is the required: alignment in bytes for
    the base of the shader binding table.
  * pname:maxGeometryCount is the maximum number of geometries in the bottom
    level acceleration structure.
  * pname:maxInstanceCount is the maximum number of instances in the top
    level acceleration structure.
  * pname:maxTriangleCount is the maximum number of triangles in all
    geometries in the bottom level acceleration structure.
  * pname:maxDescriptorSetAccelerationStructures is the maximum number of
    acceleration structure descriptors that are allowed in a descriptor set.

Due to the fact that the geometry, instance, and triangle counts are
specified at acceleration structure creation as 32-bit values,
pname:maxGeometryCount, pname:maxInstanceCount, and pname:maxTriangleCount
must: not exceed [eq]#2^32^-1#.

:refpage: VkPhysicalDeviceRayTracingPropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

ifdef::VK_KHR_ray_tracing_pipeline[]
Limits specified by this structure must: match those specified with the same
name in slink:VkPhysicalDeviceAccelerationStructurePropertiesKHR and
slink:VkPhysicalDeviceRayTracingPipelinePropertiesKHR.
endif::VK_KHR_ray_tracing_pipeline[]

include::{generated}/validity/structs/VkPhysicalDeviceRayTracingPropertiesNV.adoc[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='VkPhysicalDeviceAccelerationStructurePropertiesKHR',desc='Properties of the physical device for acceleration structure',type='structs']
--
The sname:VkPhysicalDeviceAccelerationStructurePropertiesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceAccelerationStructurePropertiesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-maxGeometryCount]] pname:maxGeometryCount is the maximum number
    of geometries in the bottom level acceleration structure.
  * [[limits-maxInstanceCount]] pname:maxInstanceCount is the maximum number
    of instances in the top level acceleration structure.
  * [[limits-maxPrimitiveCount]] pname:maxPrimitiveCount is the maximum
    number of triangles or AABBs in all geometries in the bottom level
    acceleration structure.
  * [[limits-maxPerStageDescriptorAccelerationStructures]]
    pname:maxPerStageDescriptorAccelerationStructures is the maximum number
    of acceleration structure bindings that can: be accessible to a single
    shader stage in a pipeline layout.
    Descriptor bindings with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR count against this
    limit.
    Only descriptor bindings in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
  * [[limits-maxPerStageDescriptorUpdateAfterBindAccelerationStructures]]
    pname:maxPerStageDescriptorUpdateAfterBindAccelerationStructures is
    similar to pname:maxPerStageDescriptorAccelerationStructures but counts
    descriptor bindings from descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[limits-maxDescriptorSetAccelerationStructures]]
    pname:maxDescriptorSetAccelerationStructures is the maximum number of
    acceleration structure descriptors that can: be included in descriptor
    bindings in a pipeline layout across all pipeline shader stages and
    descriptor set numbers.
    Descriptor bindings with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR count against this
    limit.
    Only descriptor bindings in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set
    count against this limit.
  * [[limits-maxDescriptorSetUpdateAfterBindAccelerationStructures]]
    pname:maxDescriptorSetUpdateAfterBindAccelerationStructures is similar
    to pname:maxDescriptorSetAccelerationStructures but counts descriptor
    bindings from descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit
    set.
  * [[limits-minAccelerationStructureScratchOffsetAlignment]]
    pname:minAccelerationStructureScratchOffsetAlignment is the minimum
    required: alignment, in bytes, for scratch data passed in to an
    acceleration structure build command.
    The value must: be a power of two.

Due to the fact that the geometry, instance, and primitive counts are
specified at acceleration structure creation as 32-bit values,
<<limits-maxGeometryCount, pname:maxGeometryCount>>,
<<limits-maxInstanceCount, pname:maxInstanceCount>>, and
<<limits-maxPrimitiveCount, pname:maxPrimitiveCount>> must: not exceed
[eq]#2^32^-1#.

:refpage: VkPhysicalDeviceAccelerationStructurePropertiesKHR
include::{chapters}/limits.adoc[tag=limits_desc]

ifdef::VK_NV_ray_tracing[]
Limits specified by this structure must: match those specified with the same
name in slink:VkPhysicalDeviceRayTracingPropertiesNV.
endif::VK_NV_ray_tracing[]

include::{generated}/validity/structs/VkPhysicalDeviceAccelerationStructurePropertiesKHR.adoc[]
--
endif::VK_KHR_acceleration_structure[]

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='VkPhysicalDeviceRayTracingPipelinePropertiesKHR',desc='Properties of the physical device for ray tracing',type='structs']
--
The sname:VkPhysicalDeviceRayTracingPipelinePropertiesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceRayTracingPipelinePropertiesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:shaderGroupHandleSize is the size in bytes of the shader header.
  * [[limits-maxRayRecursionDepth]] pname:maxRayRecursionDepth is the
    maximum number of levels of ray recursion allowed in a trace command.
  * pname:maxShaderGroupStride is the maximum stride in bytes allowed
    between shader groups in the shader binding table.
  * pname:shaderGroupBaseAlignment is the required: alignment in bytes for
    the base of the shader binding table.
  * pname:shaderGroupHandleCaptureReplaySize is the number of bytes for the
    information required to do capture and replay for shader group handles.
  * pname:maxRayDispatchInvocationCount is the maximum number of ray
    generation shader invocations which may: be produced by a single
    flink:vkCmdTraceRaysIndirectKHR or flink:vkCmdTraceRaysKHR command.
  * pname:shaderGroupHandleAlignment is the required: alignment in bytes for
    each entry in a shader binding table.
    The value must: be a power of two.
  * pname:maxRayHitAttributeSize is the maximum size in bytes for a ray
    attribute structure

:refpage: VkPhysicalDeviceRayTracingPipelinePropertiesKHR
include::{chapters}/limits.adoc[tag=limits_desc]

ifdef::VK_NV_ray_tracing[]
Limits specified by this structure must: match those specified with the same
name in slink:VkPhysicalDeviceRayTracingPropertiesNV.
endif::VK_NV_ray_tracing[]

include::{generated}/validity/structs/VkPhysicalDeviceRayTracingPipelinePropertiesKHR.adoc[]
--
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_NV_cooperative_matrix[]
[open,refpage='VkPhysicalDeviceCooperativeMatrixPropertiesNV',desc='Structure describing cooperative matrix properties supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCooperativeMatrixPropertiesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCooperativeMatrixPropertiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-cooperativeMatrixSupportedStages-NV]]
    pname:cooperativeMatrixSupportedStages is a bitfield of
    elink:VkShaderStageFlagBits describing the shader stages that
    cooperative matrix instructions are supported in.
    pname:cooperativeMatrixSupportedStages will have the
    ename:VK_SHADER_STAGE_COMPUTE_BIT bit set if any of the physical
    device's queues support ename:VK_QUEUE_COMPUTE_BIT.

:refpage: VkPhysicalDeviceCooperativeMatrixPropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceCooperativeMatrixPropertiesNV.adoc[]
--
endif::VK_NV_cooperative_matrix[]

ifdef::VK_KHR_cooperative_matrix[]
[open,refpage='VkPhysicalDeviceCooperativeMatrixPropertiesKHR',desc='Structure describing cooperative matrix properties supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCooperativeMatrixPropertiesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceCooperativeMatrixPropertiesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-cooperativeMatrixSupportedStages]]
    pname:cooperativeMatrixSupportedStages is a bitfield of
    elink:VkShaderStageFlagBits describing the shader stages that
    cooperative matrix instructions are supported in.
    pname:cooperativeMatrixSupportedStages will have the
    ename:VK_SHADER_STAGE_COMPUTE_BIT bit set if any of the physical
    device's queues support ename:VK_QUEUE_COMPUTE_BIT.

pname:cooperativeMatrixSupportedStages must: not have any bits other than
ename:VK_SHADER_STAGE_COMPUTE_BIT set.

:refpage: VkPhysicalDeviceCooperativeMatrixPropertiesKHR
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceCooperativeMatrixPropertiesKHR.adoc[]
--
endif::VK_KHR_cooperative_matrix[]

ifdef::VK_NV_shader_sm_builtins[]
[open,refpage='VkPhysicalDeviceShaderSMBuiltinsPropertiesNV',desc='Structure describing shader SM Builtins properties supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderSMBuiltinsPropertiesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-shaderSMCount]] pname:shaderSMCount is the number of SMs on the
    device.
  * [[limits-shaderWarpsPerSM]] pname:shaderWarpsPerSM is the maximum number
    of simultaneously executing warps on an SM.

:refpage: VkPhysicalDeviceShaderSMBuiltinsPropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.adoc[]
--
endif::VK_NV_shader_sm_builtins[]

ifdef::VK_VERSION_1_3,VK_EXT_texel_buffer_alignment[]
[open,refpage='VkPhysicalDeviceTexelBufferAlignmentProperties',desc='Structure describing the texel buffer alignment requirements supported by an implementation',type='structs',alias='VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT']
--
The sname:VkPhysicalDeviceTexelBufferAlignmentProperties structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceTexelBufferAlignmentProperties.adoc[]

ifdef::VK_EXT_texel_buffer_alignment[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.adoc[]
endif::VK_EXT_texel_buffer_alignment[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_3[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_3[:anchor-prefix:]
// tag::VK_EXT_texel_buffer_alignment-properties[]
  * [[{anchor-prefix}limits-storageTexelBufferOffsetAlignmentBytes]]
    pname:storageTexelBufferOffsetAlignmentBytes is a byte alignment that is
    sufficient for a storage texel buffer of any format.
    The value must: be a power of two.
  * [[{anchor-prefix}limits-storageTexelBufferOffsetSingleTexelAlignment]]
    pname:storageTexelBufferOffsetSingleTexelAlignment indicates whether
    single texel alignment is sufficient for a storage texel buffer of any
    format.
  * [[{anchor-prefix}limits-uniformTexelBufferOffsetAlignmentBytes]]
    pname:uniformTexelBufferOffsetAlignmentBytes is a byte alignment that is
    sufficient for a uniform texel buffer of any format.
    The value must: be a power of two.
  * [[{anchor-prefix}limits-uniformTexelBufferOffsetSingleTexelAlignment]]
    pname:uniformTexelBufferOffsetSingleTexelAlignment indicates whether
    single texel alignment is sufficient for a uniform texel buffer of any
    format.
// end::VK_EXT_texel_buffer_alignment-properties[]

:refpage: VkPhysicalDeviceTexelBufferAlignmentProperties
include::{chapters}/limits.adoc[tag=limits_desc]

If the single texel alignment property is ename:VK_FALSE, then the buffer
view's offset must: be aligned to the corresponding byte alignment value.
If the single texel alignment property is ename:VK_TRUE, then the buffer
view's offset must: be aligned to the lesser of the corresponding byte
alignment value or the size of a single texel, based on
slink:VkBufferViewCreateInfo::pname:format.
If the size of a single texel is a multiple of three bytes, then the size of
a single component of the format is used instead.

These limits must: not advertise a larger alignment than the
<<limits-required, required>> maximum minimum value of
slink:VkPhysicalDeviceLimits::pname:minTexelBufferOffsetAlignment, for any
format that supports use as a texel buffer.

include::{generated}/validity/structs/VkPhysicalDeviceTexelBufferAlignmentProperties.adoc[]
--
endif::VK_VERSION_1_3,VK_EXT_texel_buffer_alignment[]

ifdef::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]
[open,refpage='VkPhysicalDeviceTimelineSemaphoreProperties',desc='Structure describing timeline semaphore properties that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceTimelineSemaphorePropertiesKHR']
--
The sname:VkPhysicalDeviceTimelineSemaphoreProperties structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceTimelineSemaphoreProperties.adoc[]

ifdef::VK_KHR_timeline_semaphore[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceTimelineSemaphorePropertiesKHR.adoc[]
endif::VK_KHR_timeline_semaphore[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_timeline_semaphore-properties[]
  * [[{anchor-prefix}limits-maxTimelineSemaphoreValueDifference]]
    pname:maxTimelineSemaphoreValueDifference indicates the maximum
    difference allowed by the implementation between the current value of a
    timeline semaphore and any pending signal or wait operations.
// end::VK_KHR_timeline_semaphore-properties[]

:refpage: VkPhysicalDeviceTimelineSemaphoreProperties
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceTimelineSemaphoreProperties.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]

ifdef::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
[open,refpage='VkPhysicalDeviceLineRasterizationPropertiesKHR',desc='Structure describing line rasterization properties supported by an implementation',type='structs',alias='VkPhysicalDeviceLineRasterizationPropertiesEXT']
--
The sname:VkPhysicalDeviceLineRasterizationPropertiesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceLineRasterizationPropertiesKHR.adoc[]

ifdef::VK_EXT_line_rasterization[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceLineRasterizationPropertiesEXT.adoc[]
endif::VK_EXT_line_rasterization[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-lineSubPixelPrecisionBits]] pname:lineSubPixelPrecisionBits is
    the number of bits of subpixel precision in framebuffer coordinates
    [eq]#x~f~# and [eq]#y~f~# when rasterizing <<primsrast-lines,line
    segments>>.

:refpage: VkPhysicalDeviceLineRasterizationPropertiesKHR
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceLineRasterizationPropertiesKHR.adoc[]
--
endif::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]

ifdef::VK_EXT_robustness2[]
[open,refpage='VkPhysicalDeviceRobustness2PropertiesEXT',desc='Structure describing robust buffer access properties supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRobustness2PropertiesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceRobustness2PropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-robustStorageBufferAccessSizeAlignment]]
    pname:robustStorageBufferAccessSizeAlignment is the number of bytes that
    the range of a storage buffer descriptor is rounded up to when used for
    bounds-checking when the <<features-robustBufferAccess2,
    pname:robustBufferAccess2>> feature is enabled.
    This value must: be either 1 or 4.
  * [[limits-robustUniformBufferAccessSizeAlignment]]
    pname:robustUniformBufferAccessSizeAlignment is the number of bytes that
    the range of a uniform buffer descriptor is rounded up to when used for
    bounds-checking when the <<features-robustBufferAccess2,
    pname:robustBufferAccess2>> feature is enabled.
    This value must: be a power of two in the range [1, 256].

:refpage: VkPhysicalDeviceRobustness2PropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceRobustness2PropertiesEXT.adoc[]
--
endif::VK_EXT_robustness2[]

ifdef::VK_NV_device_generated_commands[]
[open,refpage='VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV',desc='Structure describing push descriptor limits that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:maxGraphicsShaderGroupCount is the maximum number of shader groups
    in slink:VkGraphicsPipelineShaderGroupsCreateInfoNV.
  * pname:maxIndirectSequenceCount is the maximum number of sequences in
    slink:VkGeneratedCommandsInfoNV and in
    slink:VkGeneratedCommandsMemoryRequirementsInfoNV.
  * pname:maxIndirectCommandsTokenCount is the maximum number of tokens in
    slink:VkIndirectCommandsLayoutCreateInfoNV.
  * pname:maxIndirectCommandsStreamCount is the maximum number of streams in
    slink:VkIndirectCommandsLayoutCreateInfoNV.
  * pname:maxIndirectCommandsTokenOffset is the maximum offset in
    slink:VkIndirectCommandsLayoutTokenNV.
  * pname:maxIndirectCommandsStreamStride is the maximum stream stride in
    slink:VkIndirectCommandsLayoutCreateInfoNV.
  * pname:minSequencesCountBufferOffsetAlignment is the minimum alignment
    for memory addresses which can: be used in
    slink:VkGeneratedCommandsInfoNV.
  * pname:minSequencesIndexBufferOffsetAlignment is the minimum alignment
    for memory addresses which can: be used in
    slink:VkGeneratedCommandsInfoNV.
  * pname:minIndirectCommandsBufferOffsetAlignment is the minimum alignment
    for memory addresses used in slink:VkIndirectCommandsStreamNV, and as
    preprocess buffer in slink:VkGeneratedCommandsInfoNV.

:refpage: VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.adoc[]
--

endif::VK_NV_device_generated_commands[]

ifdef::VK_KHR_portability_subset[]
[open,refpage='VkPhysicalDevicePortabilitySubsetPropertiesKHR',desc='Structure describing additional properties supported by a portable implementation',type='structs']
--
The sname:VkPhysicalDevicePortabilitySubsetPropertiesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDevicePortabilitySubsetPropertiesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-minVertexInputBindingStrideAlignment]]
    pname:minVertexInputBindingStrideAlignment indicates the minimum
    alignment for vertex input strides.
    slink:VkVertexInputBindingDescription::pname:stride must: be a multiple
    of, and at least as large as, this value.
    The value must: be a power of two.

:refpage: VkPhysicalDevicePortabilitySubsetPropertiesKHR
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDevicePortabilitySubsetPropertiesKHR.adoc[]
--
endif::VK_KHR_portability_subset[]


ifdef::VK_KHR_fragment_shading_rate[]
[open,refpage='VkPhysicalDeviceFragmentShadingRatePropertiesKHR',desc='Structure describing variable fragment shading rate limits that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentShadingRatePropertiesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentShadingRatePropertiesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-minFragmentShadingRateAttachmentTexelSize]]
    pname:minFragmentShadingRateAttachmentTexelSize indicates minimum
    supported width and height of the portion of the framebuffer
    corresponding to each texel in a fragment shading rate attachment.
    Each value must: be less than or equal to the values in
    pname:maxFragmentShadingRateAttachmentTexelSize.
    Each value must: be a power-of-two.
    It must: be [eq]#(0,0)# if the <<features-attachmentFragmentShadingRate,
    pname:attachmentFragmentShadingRate>> feature is not supported.
  * [[limits-maxFragmentShadingRateAttachmentTexelSize]]
    pname:maxFragmentShadingRateAttachmentTexelSize indicates maximum
    supported width and height of the portion of the framebuffer
    corresponding to each texel in a fragment shading rate attachment.
    Each value must: be greater than or equal to the values in
    pname:minFragmentShadingRateAttachmentTexelSize.
    Each value must: be a power-of-two.
    It must: be [eq]#(0,0)# if the <<features-attachmentFragmentShadingRate,
    pname:attachmentFragmentShadingRate>> feature is not supported.
  * [[limits-maxFragmentShadingRateAttachmentTexelSizeAspectRatio]]
    pname:maxFragmentShadingRateAttachmentTexelSizeAspectRatio indicates the
    maximum ratio between the width and height of the portion of the
    framebuffer corresponding to each texel in a fragment shading rate
    attachment.
    pname:maxFragmentShadingRateAttachmentTexelSizeAspectRatio must: be a
    power-of-two value, and must: be less than or equal to
    [eq]#max(pname:maxFragmentShadingRateAttachmentTexelSize.width /
    pname:minFragmentShadingRateAttachmentTexelSize.height,
    pname:maxFragmentShadingRateAttachmentTexelSize.height /
    pname:minFragmentShadingRateAttachmentTexelSize.width)#.
    It must: be 0 if the <<features-attachmentFragmentShadingRate,
    pname:attachmentFragmentShadingRate>> feature is not supported.
  * [[limits-primitiveFragmentShadingRateWithMultipleViewports]]
    pname:primitiveFragmentShadingRateWithMultipleViewports specifies
    whether the <<primsrast-fragment-shading-rate-primitive,primitive
    fragment shading rate>> can: be used when multiple viewports are used.
    If this value is ename:VK_FALSE, only a single viewport must: be used,
    and applications must: not write to the
ifdef::VK_NV_viewport_array2[]
    code:ViewportMaskNV or
endif::VK_NV_viewport_array2[]
    code:ViewportIndex built-in when setting code:PrimitiveShadingRateKHR.
    It must: be ename:VK_FALSE if
ifdef::VK_VERSION_1_2[]
    the <<features-shaderOutputViewportIndex,
    pname:shaderOutputViewportIndex>> feature,
endif::VK_VERSION_1_2[]
ifdef::VK_EXT_shader_viewport_index_layer[]
    the `apiext:VK_EXT_shader_viewport_index_layer` extension,
endif::VK_EXT_shader_viewport_index_layer[]
ifdef::VK_VERSION_1_2,VK_EXT_shader_viewport_index_layer[or]
    the <<features-geometryShader, pname:geometryShader>> feature is not
    supported, or if the <<features-primitiveFragmentShadingRate,
    pname:primitiveFragmentShadingRate>> feature is not supported.
  * [[limits-layeredShadingRateAttachments]]
    pname:layeredShadingRateAttachments specifies whether a shading rate
    attachment image view can: be created with multiple layers.
    If this value is ename:VK_FALSE, when creating an image view with a
    pname:usage that includes
    ename:VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
    pname:layerCount must: be `1`.
    It must: be ename:VK_FALSE if
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
    the <<features-multiview, pname:multiview>> feature,
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_2[]
    the <<features-shaderOutputViewportIndex,
    pname:shaderOutputViewportIndex>> feature,
endif::VK_VERSION_1_2[]
ifdef::VK_EXT_shader_viewport_index_layer[]
    the `apiext:VK_EXT_shader_viewport_index_layer` extension,
endif::VK_EXT_shader_viewport_index_layer[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview,VK_VERSION_1_2,VK_EXT_shader_viewport_index_layer[or]
    the <<features-geometryShader, pname:geometryShader>> feature is not
    supported, or if the <<features-attachmentFragmentShadingRate,
    pname:attachmentFragmentShadingRate>> feature is not supported.
  * [[limits-fragmentShadingRateNonTrivialCombinerOps]]
    pname:fragmentShadingRateNonTrivialCombinerOps specifies whether
    elink:VkFragmentShadingRateCombinerOpKHR enums other than
    ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or
    ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR can: be used.
    It must: be ename:VK_FALSE unless either the
    <<features-primitiveFragmentShadingRate,
    pname:primitiveFragmentShadingRate>> or
    <<features-attachmentFragmentShadingRate,
    pname:attachmentFragmentShadingRate>> feature is supported.
  * [[limits-maxFragmentSize]] pname:maxFragmentSize indicates the maximum
    supported width and height of a fragment.
    Its pname:width and pname:height members must: both be power-of-two
    values.
    This limit is purely informational, and is not validated.
  * [[limits-maxFragmentSizeAspectRatio]] pname:maxFragmentSizeAspectRatio
    indicates the maximum ratio between the width and height of a fragment.
    pname:maxFragmentSizeAspectRatio must: be a power-of-two value, and
    must: be less than or equal to the maximum of the pname:width and
    pname:height members of pname:maxFragmentSize.
    This limit is purely informational, and is not validated.
  * [[limits-maxFragmentShadingRateCoverageSamples]]
    pname:maxFragmentShadingRateCoverageSamples specifies the maximum number
    of coverage samples supported in a single fragment.
    pname:maxFragmentShadingRateCoverageSamples must: be less than or equal
    to the product of the pname:width and pname:height members of
    pname:maxFragmentSize, and the sample count reported by
    pname:maxFragmentShadingRateRasterizationSamples.
    pname:maxFragmentShadingRateCoverageSamples must: be less than or equal
    to [eq]#pname:maxSampleMaskWords {times} 32# if
    pname:fragmentShadingRateWithShaderSampleMask is supported.
    This limit is purely informational, and is not validated.
  * [[limits-maxFragmentShadingRateRasterizationSamples]]
    pname:maxFragmentShadingRateRasterizationSamples is a
    elink:VkSampleCountFlagBits value specifying the maximum sample rate
    supported when a fragment covers multiple pixels.
    This limit is purely informational, and is not validated.
  * [[limits-fragmentShadingRateWithShaderDepthStencilWrites]]
    pname:fragmentShadingRateWithShaderDepthStencilWrites specifies whether
    the implementation supports writing code:FragDepth
ifdef::VK_EXT_shader_stencil_export[]
    or code:FragStencilRefEXT
endif::VK_EXT_shader_stencil_export[]
    from a fragment shader for multi-pixel fragments.
    If this value is ename:VK_FALSE, writing to those built-ins will clamp
    the fragment shading rate to [eq]#(1,1)#.
  * [[limits-fragmentShadingRateWithSampleMask]]
    pname:fragmentShadingRateWithSampleMask specifies whether the
    implementation supports setting valid bits of
    slink:VkPipelineMultisampleStateCreateInfo::pname:pSampleMask to `0` for
    multi-pixel fragments.
    If this value is ename:VK_FALSE, zeroing valid bits in the sample mask
    will clamp the fragment shading rate to [eq]#(1,1)#.
  * [[limits-fragmentShadingRateWithShaderSampleMask]]
    pname:fragmentShadingRateWithShaderSampleMask specifies whether the
    implementation supports reading or writing code:SampleMask for
    multi-pixel fragments.
    If this value is ename:VK_FALSE, using that built-in will clamp the
    fragment shading rate to [eq]#(1,1)#.
  * [[limits-fragmentShadingRateWithConservativeRasterization]]
    pname:fragmentShadingRateWithConservativeRasterization
ifndef::VK_EXT_conservative_rasterization[]
    is reserved for future use.
endif::VK_EXT_conservative_rasterization[]
ifdef::VK_EXT_conservative_rasterization[]
    specifies whether <<primsrast-conservativeraster, conservative
    rasterization>> is supported for multi-pixel fragments.
    It must: be ename:VK_FALSE if `apiext:VK_EXT_conservative_rasterization`
    is not supported.
    If this value is ename:VK_FALSE, using <<primsrast-conservativeraster,
    conservative rasterization>> will clamp the fragment shading rate to
    [eq]#(1,1)#.
endif::VK_EXT_conservative_rasterization[]
  * [[limits-fragmentShadingRateWithFragmentShaderInterlock]]
    pname:fragmentShadingRateWithFragmentShaderInterlock
ifndef::VK_EXT_fragment_shader_interlock[]
    is reserved for future use.
endif::VK_EXT_fragment_shader_interlock[]
ifdef::VK_EXT_fragment_shader_interlock[]
    specifies whether <<fragops-shader-interlock, fragment shader
    interlock>> is supported for multi-pixel fragments.
    It must: be ename:VK_FALSE if `apiext:VK_EXT_fragment_shader_interlock`
    is not supported.
    If this value is ename:VK_FALSE, using <<fragops-shader-interlock,
    fragment shader interlock>> will clamp the fragment shading rate to
    [eq]#(1,1)#.
endif::VK_EXT_fragment_shader_interlock[]
  * [[limits-fragmentShadingRateWithCustomSampleLocations]]
    pname:fragmentShadingRateWithCustomSampleLocations
ifndef::VK_EXT_sample_locations[]
    is reserved for future use.
endif::VK_EXT_sample_locations[]
ifdef::VK_EXT_sample_locations[]
    specifies whether <<primsrast-samplelocations, custom sample locations>>
    are supported for multi-pixel fragments.
    It must: be ename:VK_FALSE if `apiext:VK_EXT_sample_locations` is not
    supported.
    If this value is ename:VK_FALSE, using <<primsrast-samplelocations,
    custom sample locations>> will clamp the fragment shading rate to
    [eq]#(1,1)#.
endif::VK_EXT_sample_locations[]
  * [[limits-fragmentShadingRateStrictMultiplyCombiner]]
    pname:fragmentShadingRateStrictMultiplyCombiner specifies whether
    ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR accurately performs a
    multiplication or not.
    Implementations where this value is ename:VK_FALSE will instead combine
    rates with an addition.
    If pname:fragmentShadingRateNonTrivialCombinerOps is ename:VK_FALSE,
    implementations must: report this as ename:VK_FALSE.
    If pname:fragmentShadingRateNonTrivialCombinerOps is ename:VK_TRUE,
    implementations should: report this as ename:VK_TRUE.

[NOTE]
.Note
====
Multiplication of the combiner rates using the fragment width/height in
linear space is equivalent to an addition of those values in log2 space.
Some implementations inadvertently implemented an addition in linear space
due to unclear requirements originating outside of this specification.
This resulted in <<limits-fragmentShadingRateStrictMultiplyCombiner,
pname:fragmentShadingRateStrictMultiplyCombiner>> being added.
Fortunately, this only affects situations where a rate of 1 in either
dimension is combined with another rate of 1.
All other combinations result in the exact same result as if multiplication
was performed in linear space due to the clamping logic, and the fact that
both the sum and product of 2 and 2 are equal.
In many cases, this limit will not affect the correct operation of
applications.
====

:refpage: VkPhysicalDeviceFragmentShadingRatePropertiesKHR
include::{chapters}/limits.adoc[tag=limits_desc]

These properties are related to <<primsrast-fragment-shading-rate, fragment
shading rates>>.

include::{generated}/validity/structs/VkPhysicalDeviceFragmentShadingRatePropertiesKHR.adoc[]
--
endif::VK_KHR_fragment_shading_rate[]

ifdef::VK_NV_fragment_shading_rate_enums[]
[open,refpage='VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV',desc='Structure describing fragment shading rate limits that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-maxFragmentShadingRateInvocationCount]]
    pname:maxFragmentShadingRateInvocationCount is a
    elink:VkSampleCountFlagBits value indicating the maximum number of
    fragment shader invocations per fragment supported in pipeline,
    primitive, and attachment fragment shading rates.

:refpage: VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

These properties are related to <<primsrast-fragment-shading-rate, fragment
shading rates>>.

include::{generated}/validity/structs/VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.adoc[]
--
endif::VK_NV_fragment_shading_rate_enums[]

ifdef::VK_EXT_custom_border_color[]
[open,refpage='VkPhysicalDeviceCustomBorderColorPropertiesEXT',desc='Structure describing whether custom border colors can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCustomBorderColorPropertiesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceCustomBorderColorPropertiesEXT.adoc[]

  * [[limits-maxCustomBorderColorSamplers]]
    pname:maxCustomBorderColorSamplers indicates the maximum number of
    samplers with custom border colors which can: simultaneously exist on a
    device.

:refpage: VkPhysicalDeviceCustomBorderColorPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceCustomBorderColorPropertiesEXT.adoc[]
--
endif::VK_EXT_custom_border_color[]

ifdef::VK_EXT_provoking_vertex[]
[open,refpage='VkPhysicalDeviceProvokingVertexPropertiesEXT',desc='Structure describing provoking vertex properties supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceProvokingVertexPropertiesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceProvokingVertexPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-provokingVertexModePerPipeline]]
    pname:provokingVertexModePerPipeline indicates whether the
    implementation supports graphics pipelines with different provoking
    vertex modes within the same render pass instance.
  * [[limits-transformFeedbackPreservesTriangleFanProvokingVertex]]
    pname:transformFeedbackPreservesTriangleFanProvokingVertex indicates
    whether the implementation can preserve the provoking vertex order when
    writing triangle fan vertices to transform feedback.

:refpage: VkPhysicalDeviceProvokingVertexPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceProvokingVertexPropertiesEXT.adoc[]
--
endif::VK_EXT_provoking_vertex[]

ifdef::VK_EXT_descriptor_buffer[]
[open,refpage='VkPhysicalDeviceDescriptorBufferPropertiesEXT',desc='Structure describing descriptor buffer properties supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDescriptorBufferPropertiesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDescriptorBufferPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-combinedImageSamplerDescriptorSingleArray]]
    pname:combinedImageSamplerDescriptorSingleArray indicates that the
    implementation does not require an array of
    `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` descriptors to be written
    into a descriptor buffer as an array of image descriptors, immediately
    followed by an array of sampler descriptors.
  * [[limits-bufferlessPushDescriptors]] pname:bufferlessPushDescriptors
    indicates that the implementation does not require a buffer created with
    `VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT` to be bound
    when using push descriptors.
  * [[limits-allowSamplerImageViewPostSubmitCreation]]
    pname:allowSamplerImageViewPostSubmitCreation indicates that the
    implementation does not restrict when the slink:VkSampler or
    slink:VkImageView objects used to retrieve descriptor data can: be
    created in relation to command buffer submission.
    If this value is ename:VK_FALSE, then the application must: create any
    slink:VkSampler or slink:VkImageView objects whose descriptor data is
    accessed during the execution of a command buffer, before the
    flink:vkQueueSubmit
ifdef::VK_VERSION_1_3,VK_KHR_synchronization2[]
    , or flink:vkQueueSubmit2,
endif::VK_VERSION_1_3,VK_KHR_synchronization2[]
    call that submits that command buffer.
  * [[limits-descriptorBufferOffsetAlignment]]
    pname:descriptorBufferOffsetAlignment indicates the required: alignment
    in bytes when setting offsets into the descriptor buffer.
  * [[limits-maxDescriptorBufferBindings]] pname:maxDescriptorBufferBindings
    indicates the maximum sum total number of descriptor buffers and
    embedded immutable sampler sets that can: be bound.
  * [[limits-maxResourceDescriptorBufferBindings]]
    pname:maxResourceDescriptorBufferBindings indicates the maximum number
    of resource descriptor buffers that can: be bound.
  * [[limits-maxSamplerDescriptorBufferBindings]]
    pname:maxSamplerDescriptorBufferBindings indicates the maximum number of
    sampler descriptor buffers that can: be bound.
  * [[limits-maxEmbeddedImmutableSamplerBindings]]
    pname:maxEmbeddedImmutableSamplerBindings indicates the maximum number
    of embedded immutable sampler sets that can: be bound.
  * [[limits-maxEmbeddedImmutableSamplers]]
    pname:maxEmbeddedImmutableSamplers indicates the maximum number of
    unique immutable samplers in descriptor set layouts created with
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT,
    and pipeline layouts created from them, which can: simultaneously exist
    on a device.
  * [[limits-bufferCaptureReplayDescriptorDataSize]]
    pname:bufferCaptureReplayDescriptorDataSize indicates the maximum size
    in bytes of the opaque data used for capture and replay with buffers.
  * [[limits-imageCaptureReplayDescriptorDataSize]]
    pname:imageCaptureReplayDescriptorDataSize indicates the maximum size in
    bytes of the opaque data used for capture and replay with images.
  * [[limits-imageViewCaptureReplayDescriptorDataSize]]
    pname:imageViewCaptureReplayDescriptorDataSize indicates the maximum
    size in bytes of the opaque data used for capture and replay with image
    views.
  * [[limits-samplerCaptureReplayDescriptorDataSize]]
    pname:samplerCaptureReplayDescriptorDataSize indicates the maximum size
    in bytes of the opaque data used for capture and replay with samplers.
  * [[limits-accelerationStructureCaptureReplayDescriptorDataSize]]
    pname:accelerationStructureCaptureReplayDescriptorDataSize indicates the
    maximum size in bytes of the opaque data used for capture and replay
    with acceleration structures.
  * [[limits-samplerDescriptorSize]] pname:samplerDescriptorSize indicates
    the size in bytes of a ename:VK_DESCRIPTOR_TYPE_SAMPLER descriptor.
  * [[limits-combinedImageSamplerDescriptorSize]]
    pname:combinedImageSamplerDescriptorSize indicates the size in bytes of
    a ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER descriptor.
  * [[limits-sampledImageDescriptorSize]] pname:sampledImageDescriptorSize
    indicates the size in bytes of a ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
    descriptor.
  * [[limits-storageImageDescriptorSize]] pname:storageImageDescriptorSize
    indicates the size in bytes of a ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE
    descriptor.
  * [[limits-uniformTexelBufferDescriptorSize]]
    pname:uniformTexelBufferDescriptorSize indicates the size in bytes of a
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER descriptor if the
    <<features-robustBufferAccess, pname:robustBufferAccess>> feature is not
    enabled.
  * [[limits-robustUniformTexelBufferDescriptorSize]]
    pname:robustUniformTexelBufferDescriptorSize indicates the size in bytes
    of a ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER descriptor if the
    <<features-robustBufferAccess, pname:robustBufferAccess>> feature is
    enabled.
  * [[limits-storageTexelBufferDescriptorSize]]
    pname:storageTexelBufferDescriptorSize indicates the size in bytes of a
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor if the
    <<features-robustBufferAccess, pname:robustBufferAccess>> feature is not
    enabled.
  * [[limits-robustStorageTexelBufferDescriptorSize]]
    pname:robustStorageTexelBufferDescriptorSize indicates the size in bytes
    of a ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor if the
    <<features-robustBufferAccess, pname:robustBufferAccess>> feature is
    enabled.
  * [[limits-uniformBufferDescriptorSize]] pname:uniformBufferDescriptorSize
    indicates the size in bytes of a ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
    descriptor.
  * [[limits-robustUniformBufferDescriptorSize]]
    pname:robustUniformBufferDescriptorSize indicates the size in bytes of a
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER descriptor if the
    <<features-robustBufferAccess, pname:robustBufferAccess>> feature is
    enabled.
  * [[limits-storageBufferDescriptorSize]] pname:storageBufferDescriptorSize
    indicates the size in bytes of a ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER
    descriptor.
  * [[limits-robustStorageBufferDescriptorSize]]
    pname:robustStorageBufferDescriptorSize indicates the size in bytes of a
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER descriptor if the
    <<features-robustBufferAccess, pname:robustBufferAccess>> feature is
    enabled.
  * [[limits-inputAttachmentDescriptorSize]]
    pname:inputAttachmentDescriptorSize indicates the size in bytes of a
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT descriptor.
  * [[limits-accelerationStructureDescriptorSize]]
    pname:accelerationStructureDescriptorSize indicates the size in bytes of
    a ename:VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR or
    ename:VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV descriptor.
  * [[limits-maxSamplerDescriptorBufferRange]]
    pname:maxSamplerDescriptorBufferRange indicates the maximum range in
    bytes from the address of a sampler descriptor buffer binding that is
    accessible to a shader.
  * [[limits-maxResourceDescriptorBufferRange]]
    pname:maxResourceDescriptorBufferRange indicates the maximum range in
    bytes from the address of a resource descriptor buffer binding that is
    accessible to a shader.
  * [[limits-samplerDescriptorBufferAddressSpaceSize]]
    pname:samplerDescriptorBufferAddressSpaceSize indicates the total size
    in bytes of the address space available for descriptor buffers created
    with ename:VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT.
  * [[limits-resourceDescriptorBufferAddressSpaceSize]]
    pname:resourceDescriptorBufferAddressSpaceSize indicates the total size
    in bytes of the address space available for descriptor buffers created
    with ename:VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT.
  * [[limits-descriptorBufferAddressSpaceSize]]
    pname:descriptorBufferAddressSpaceSize indicates the total size in bytes
    of the address space available for descriptor buffers created with both
    ename:VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT and
    ename:VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT.

ifdef::VK_VALVE_mutable_descriptor_type[]
A descriptor binding with type ename:VK_DESCRIPTOR_TYPE_MUTABLE_VALVE has a
descriptor size which is implied by the descriptor types included in the
slink:VkMutableDescriptorTypeCreateInfoVALVE::pname:pDescriptorTypes list.
The descriptor size is equal to the maximum size of any descriptor type
included in the pname:pDescriptorTypes list.
endif::VK_VALVE_mutable_descriptor_type[]

ifdef::VK_EXT_pipeline_robustness[]
As there is no way to request robust and non-robust descriptors separately,
or specify robust/non-robust descriptors in the set layout, if
<<features-robustBufferAccess, pname:robustBufferAccess>> is enabled then
robust descriptors are always used.
endif::VK_EXT_pipeline_robustness[]

:refpage: VkPhysicalDeviceDescriptorBufferPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceDescriptorBufferPropertiesEXT.adoc[]
--

ifdef::VK_EXT_fragment_density_map[]
[open,refpage='VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT',desc='Structure describing descriptor buffer density map properties supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-combinedImageSamplerDensityMapDescriptorSize]]
    pname:combinedImageSamplerDensityMapDescriptorSize indicates the size in
    bytes of a ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER descriptor
    when creating the descriptor with
    ename:VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT set.

:refpage: VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT.adoc[]
--
endif::VK_EXT_fragment_density_map[]

endif::VK_EXT_descriptor_buffer[]

ifdef::VK_EXT_host_image_copy[]
[open,refpage='VkPhysicalDeviceHostImageCopyPropertiesEXT',desc='Structure enumerating image layouts supported by an implementation for host memory copies',type='structs']
--
The sname:VkPhysicalDeviceHostImageCopyPropertiesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceHostImageCopyPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:copySrcLayoutCount is an integer related to the number of image
    layouts for host copies from images available or queried, as described
    below.
  * pname:pCopySrcLayouts is a pointer to an array of elink:VkImageLayout in
    which supported image layouts for use with host copy operations from
    images are returned.
  * pname:copyDstLayoutCount is an integer related to the number of image
    layouts for host copies to images available or queried, as described
    below.
  * pname:pCopyDstLayouts is a pointer to an array of elink:VkImageLayout in
    which supported image layouts for use with host copy operations to
    images are returned.
  * pname:optimalTilingLayoutUUID is an array of ename:VK_UUID_SIZE
    code:uint8_t values representing a universally unique identifier for the
    implementation's swizzling layout of images created with
    ename:VK_IMAGE_TILING_OPTIMAL.
  * pname:identicalMemoryTypeRequirements indicates that specifying the
    ename:VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT flag in
    slink:VkImageCreateInfo::pname:usage does not affect the memory type
    requirements of the image.

:refpage: VkPhysicalDeviceHostImageCopyPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

If pname:pCopyDstLayouts is `NULL`, then the number of image layouts that
are supported in slink:VkCopyMemoryToImageInfoEXT::pname:dstImageLayout and
slink:VkCopyImageToImageInfoEXT::pname:dstImageLayout is returned in
pname:copyDstLayoutCount.
Otherwise, pname:copyDstLayoutCount must: be set by the user to the number
of elements in the pname:pCopyDstLayouts array, and on return the variable
is overwritten with the number of values actually written to
pname:pCopyDstLayouts.
If the value of pname:copyDstLayoutCount is less than the number of image
layouts that are supported, at most pname:copyDstLayoutCount values will be
written to pname:pCopyDstLayouts.
The implementation must: include the ename:VK_IMAGE_LAYOUT_GENERAL image
layout in pname:pCopyDstLayouts.

If pname:pCopySrcLayouts is `NULL`, then the number of image layouts that
are supported in slink:VkCopyImageToMemoryInfoEXT::pname:srcImageLayout and
slink:VkCopyImageToImageInfoEXT::pname:srcImageLayout is returned in
pname:copySrcLayoutCount.
Otherwise, pname:copySrcLayoutCount must: be set by the user to the number
of elements in the pname:pCopySrcLayouts array, and on return the variable
is overwritten with the number of values actually written to
pname:pCopySrcLayouts.
If the value of pname:copySrcLayoutCount is less than the number of image
layouts that are supported, at most pname:copySrcLayoutCount values will be
written to pname:pCopySrcLayouts.
The implementation must: include the ename:VK_IMAGE_LAYOUT_GENERAL image
layout in pname:pCopySrcLayouts.

The pname:optimalTilingLayoutUUID value can be used to ensure compatible
data layouts when using the ename:VK_HOST_IMAGE_COPY_MEMCPY_EXT flag in
flink:vkCopyMemoryToImageEXT and flink:vkCopyImageToMemoryEXT.

include::{generated}/validity/structs/VkPhysicalDeviceHostImageCopyPropertiesEXT.adoc[]
--
endif::VK_EXT_host_image_copy[]

ifdef::VK_HUAWEI_subpass_shading[]
[open,refpage='VkPhysicalDeviceSubpassShadingPropertiesHUAWEI',desc='Structure describing subpass shading properties supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceSubpassShadingPropertiesHUAWEI structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceSubpassShadingPropertiesHUAWEI.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-maxSubpassShadingWorkgroupSizeAspectRatio]]
    pname:maxSubpassShadingWorkgroupSizeAspectRatio indicates the maximum
    ratio between the width and height of the portion of the subpass shading
    shader workgroup size.
    pname:maxSubpassShadingWorkgroupSizeAspectRatio must: be a power-of-two
    value, and must: be less than or equal to max(code:WorkgroupSize.x /
    code:WorkgroupSize.y, code:WorkgroupSize.y / code:WorkgroupSize.x).

:refpage: VkPhysicalDeviceSubpassShadingPropertiesHUAWEI
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceSubpassShadingPropertiesHUAWEI.adoc[]
--
endif::VK_HUAWEI_subpass_shading[]

ifdef::VK_EXT_multi_draw[]

[open,refpage='VkPhysicalDeviceMultiDrawPropertiesEXT',desc='Structure describing multidraw limits of an implementation',type='structs']
--
The sname:VkPhysicalDeviceMultiDrawPropertiesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMultiDrawPropertiesEXT.adoc[]

The members of the sname:VkPhysicalDeviceMultiDrawPropertiesEXT structure
describe the following features:

  * [[limits-maxMultiDrawCount]] pname:maxMultiDrawCount indicates the
    maximum number of draw calls which can: be batched into a single
    multidraw.

:refpage: VkPhysicalDeviceMultiDrawPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceMultiDrawPropertiesEXT.adoc[]
--

endif::VK_EXT_multi_draw[]

ifdef::VK_EXT_nested_command_buffer[]

[open,refpage='VkPhysicalDeviceNestedCommandBufferPropertiesEXT',desc='Structure describing the nested command buffer limits of an implementation',type='structs']
--
The sname:VkPhysicalDeviceNestedCommandBufferPropertiesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceNestedCommandBufferPropertiesEXT.adoc[]

The members of the sname:VkPhysicalDeviceNestedCommandBufferPropertiesEXT
structure describe the following features:

  * [[limits-maxCommandBufferNestingLevel]]
    pname:maxCommandBufferNestingLevel indicates the maximum nesting level
    of calls to flink:vkCmdExecuteCommands from <<glossary, Secondary
    Command Buffers>>.
    A pname:maxCommandBufferNestingLevel of code:UINT32_MAX means there is
    no limit to the nesting level.

:refpage: VkPhysicalDeviceNestedCommandBufferPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceNestedCommandBufferPropertiesEXT.adoc[]
--

endif::VK_EXT_nested_command_buffer[]

ifdef::VK_EXT_graphics_pipeline_library[]
[open,refpage='VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT',desc='Structure describing additional properties of graphics pipeline libraries',type='structs']
--
The sname:VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT.adoc[]

  * [[limits-graphicsPipelineLibraryFastLinking]]
    pname:graphicsPipelineLibraryFastLinking indicates whether fast linking
    of graphics pipelines is supported.
    If it is ename:VK_TRUE, creating a graphics pipeline entirely from
    pipeline libraries without
    ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT is comparable in
    cost to recording a command in a command buffer.
  * [[limits-graphicsPipelineLibraryIndependentInterpolationDecoration]]
    pname:graphicsPipelineLibraryIndependentInterpolationDecoration
    indicates whether code:NoPerspective and code:Flat interpolation
    decorations in the last vertex processing stage and the fragment shader
    are required to match when using graphics pipeline libraries.
    If it is ename:VK_TRUE, the interpolation decorations do not need to
    match.
    If it is ename:VK_FALSE, these decorations must: either be present in
    both stages or neither stage in order for a given interface variable to
    match.

:refpage: VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT.adoc[]
--

endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_KHR_fragment_shader_barycentric[]

[open,refpage='VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR',desc='Structure describing fragment shader barycentric limits of an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR.adoc[]

  * [[limits-triStripVertexOrderIndependentOfProvokingVertex]] When the
    <<vertexpostproc-flatshading,provoking vertex mode>> is
    ename:VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT, and the primitive order
    is odd in a triangle strip, the ordering of vertices is defined in
    <<primsrast-barycentric-order-table-last-vertex, last vertex table>>.
    pname:triStripVertexOrderIndependentOfProvokingVertex equal to
    ename:VK_TRUE indicates that the implementation ignores this and uses
    the vertex order defined by
    ename:VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT instead.

:refpage: VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR.adoc[]
--

endif::VK_KHR_fragment_shader_barycentric[]

ifdef::VK_EXT_shader_module_identifier[]
[open,refpage='VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT',desc='Structure describing shader module identifier properties of an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT.adoc[]

The members of the sname:VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT
structure describe the following:

  * [[limits-shaderModuleIdentifierAlgorithmUUID]]
    pname:shaderModuleIdentifierAlgorithmUUID is an array of
    ename:VK_UUID_SIZE code:uint8_t values which uniquely represents the
    algorithm used to compute an identifier in
    flink:vkGetShaderModuleIdentifierEXT and
    flink:vkGetShaderModuleCreateInfoIdentifierEXT.
    Implementations should: not change this value in different driver
    versions if the algorithm used to compute an identifier is the same.

[NOTE]
.Note
====
The algorithm UUID may be the same in different ICDs if the algorithms are
guaranteed to produce the same results.
This may happen in driver stacks which support different kinds of hardware
with shared code.

Khronos' conformance testing can not guarantee that
pname:shaderModuleIdentifierAlgorithmUUID values are actually unique, so
implementors should make their own best efforts to ensure that their UUID is
unlikely to conflict with other implementations which may use a different
algorithm.
In particular, hard-coded values which easily conflict, such as all-`0`
bits, should: never be used.
Hard-coded values are acceptable if best effort is ensured that the value
will not accidentally conflict.
====

:refpage: VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT.adoc[]
--

endif::VK_EXT_shader_module_identifier[]

ifdef::VK_EXT_pipeline_robustness[]
[open,refpage='VkPhysicalDevicePipelineRobustnessPropertiesEXT',desc='Structure describing the default robustness behavior of a physical device',type='structs']
--
The sname:VkPhysicalDevicePipelineRobustnessPropertiesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDevicePipelineRobustnessPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:defaultRobustnessStorageBuffers describes the behavior of out of
    bounds accesses made to storage buffers when no robustness features are
    enabled
  * pname:defaultRobustnessUniformBuffers describes the behavior of out of
    bounds accesses made to uniform buffers when no robustness features are
    enabled
  * pname:defaultRobustnessVertexInputs describes the behavior of out of
    bounds accesses made to vertex input attributes when no robustness
    features are enabled
  * pname:defaultRobustnessImages describes the behavior of out of bounds
    accesses made to images when no robustness features are enabled

Some implementations of Vulkan may be able to guarantee that certain types
of accesses are always performed with robustness even when the Vulkan API's
robustness features are not explicitly enabled.

Even when an implementation reports that accesses to a given resource type
are robust by default, it remains invalid to make an out of bounds access
without requesting the appropriate robustness feature.

:refpage: VkPhysicalDevicePipelineRobustnessPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDevicePipelineRobustnessPropertiesEXT.adoc[]
--
endif::VK_EXT_pipeline_robustness[]

ifdef::VK_EXT_extended_dynamic_state3[]

[open,refpage='VkPhysicalDeviceExtendedDynamicState3PropertiesEXT',desc='Structure describing capabilities of extended dynamic state',type='structs']
--
The sname:VkPhysicalDeviceExtendedDynamicState3PropertiesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceExtendedDynamicState3PropertiesEXT.adoc[]

  * [[limits-dynamicPrimitiveTopologyUnrestricted]]
    pname:dynamicPrimitiveTopologyUnrestricted indicates that the
    implementation allows fname:vkCmdSetPrimitiveTopology to use a different
    <<drawing-primitive-topology-class, primitive topology class>> to the
    one specified in the active graphics pipeline.

:refpage: VkPhysicalDeviceExtendedDynamicState3PropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceExtendedDynamicState3PropertiesEXT.adoc[]
--

endif::VK_EXT_extended_dynamic_state3[]

ifdef::VK_NV_optical_flow[]
[open,refpage='VkPhysicalDeviceOpticalFlowPropertiesNV',desc='Structure describing properties supported by VK_NV_optical_flow',type='structs']
--
The sname:VkPhysicalDeviceOpticalFlowPropertiesNV structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceOpticalFlowPropertiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-supportedOutputGridSizes]] pname:supportedOutputGridSizes are
    the supported tlink:VkOpticalFlowGridSizeFlagsNV which can be specified
    in sname:VkOpticalFlowSessionCreateInfoNV::pname:outputGridSize.
  * [[limits-supportedHintGridSizes]] pname:supportedHintGridSizes are the
    supported tlink:VkOpticalFlowGridSizeFlagsNV which can be specified in
    sname:VkOpticalFlowSessionCreateInfoNV::pname:hintGridSize.
  * [[limits-hintSupported]] pname:hintSupported is a boolean describing
    whether using hint flow vector map is supported in an optical flow
    session.
  * [[limits-costSupported]] pname:costSupported is a boolean describing
    whether cost map generation is supported in an optical flow session.
  * [[limits-bidirectionalFlowSupported]] pname:bidirectionalFlowSupported
    is a boolean describing whether bi-directional flow generation is
    supported in an optical flow session.
  * [[limits-globalFlowSupported]] pname:globalFlowSupported is a boolean
    describing whether global flow vector map generation is supported in an
    optical flow session.
  * [[limits-minWidth]] pname:minWidth is the minimum width in pixels for
    images used in an optical flow session.
  * [[limits-minHeight]] pname:minHeight is the minimum height in pixels for
    images used in an optical flow session.
  * [[limits-maxWidth]] pname:maxWidth is the maximum width in pixels for
    images used in an optical flow session.
  * [[limits-maxHeight]] pname:maxHeight is the maximum height in pixels for
    images used in an optical flow session.
  * [[limits-maxNumRegionsOfInterest]] pname:maxNumRegionsOfInterest is the
    maximum number of regions of interest which can be used in an optical
    flow session.
    If this pname:maxNumRegionsOfInterest is 0, regions of interest are not
    supported in an optical flow session.

:refpage: VkPhysicalDeviceOpticalFlowPropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceOpticalFlowPropertiesNV.adoc[]
--
endif::VK_NV_optical_flow[]

ifdef::VK_EXT_opacity_micromap[]
[open,refpage='VkPhysicalDeviceOpacityMicromapPropertiesEXT',desc='Structure describing the opacity micromap properties of a physical device',type='structs']
--
The sname:VkPhysicalDeviceOpacityMicromapPropertiesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceOpacityMicromapPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:maxOpacity2StateSubdivisionLevel is the maximum allowed
    pname:subdivisionLevel when pname:format is
    ename:VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT
  * pname:maxOpacity4StateSubdivisionLevel is the maximum allowed
    pname:subdivisionLevel when pname:format is
    ename:VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT

:refpage: VkPhysicalDeviceOpacityMicromapPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceOpacityMicromapPropertiesEXT.adoc[]
--
endif::VK_EXT_opacity_micromap[]

ifdef::VK_NV_displacement_micromap[]
[open,refpage='VkPhysicalDeviceDisplacementMicromapPropertiesNV',desc='Structure describing the displacement micromap properties of a physical device',type='structs']
--
The sname:VkPhysicalDeviceDisplacementMicromapPropertiesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceDisplacementMicromapPropertiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:maxDisplacementMicromapSubdivisionLevel is the maximum allowed
    pname:subdivisionLevel for displacement micromaps.

:refpage: VkPhysicalDeviceDisplacementMicromapPropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceDisplacementMicromapPropertiesNV.adoc[]
--
endif::VK_NV_displacement_micromap[]

ifdef::VK_ARM_shader_core_builtins[]
[open,refpage='VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM',desc='Structure describing shader core builtins properties supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-shaderCoreMask]] pname:shaderCoreMask is a bitfield where each
    bit set represents the presence of a shader core whose ID is the bit
    position.
    The highest ID for any shader core on the device is the position of the
    most significant bit set.
  * [[limits-shaderCoreCount]] pname:shaderCoreCount is the number of shader
    cores on the device.
  * [[limits-shaderWarpsPerCore]] pname:shaderWarpsPerCore is the maximum
    number of simultaneously executing warps on a shader core.

:refpage: VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM.adoc[]
--
endif::VK_ARM_shader_core_builtins[]

ifdef::VK_NV_ray_tracing_invocation_reorder[]
[open,refpage='VkRayTracingInvocationReorderModeNV',desc='Enum providing a hint on how the application may: reorder',type='enums']
--
Values which may: be returned in the
pname:rayTracingInvocationReorderReorderingHint field of
sname:VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV are:

include::{generated}/api/enums/VkRayTracingInvocationReorderModeNV.adoc[]

  * ename:VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV indicates that the
    implementation is likely to not reorder at reorder calls.
  * ename:VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV indicates that
    the implementation is likely to reorder at reorder calls.
--

[open,refpage='VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV',desc='Structure describing shader module identifier properties of an implementation',type='structs']
--
The sname:VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV.adoc[]

  * pname:rayTracingInvocationReorderReorderingHint is a hint indicating if
    the implementation will actually reorder at the reorder calls.

[NOTE]
.Note
====
Because the extension changes how hits are managed there is a compatibility
reason to expose the extension even when an implementation does not have
sorting active.
====

:refpage: VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV.adoc[]
--
endif::VK_NV_ray_tracing_invocation_reorder[]

ifdef::VK_HUAWEI_cluster_culling_shader[]
[open,refpage='VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI',desc='Structure describing cluster culling shader properties supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:maxWorkGroupCount[3] is the maximum number of local workgroups
    that can be launched by a single command.
    These three value represent the maximum local workgroup count in the X,
    Y and Z dimensions, respectively.
    In the current implementation, the values of Y and Z are both implicitly
    set as one.
    groupCountX of DrawCluster command must be less than or equal to
    maxWorkGroupCount[0].
  * pname:maxWorkGroupSize[3] is the maximum size of a local workgroup.
    These three value represent the maximum local workgroup size in the X, Y
    and Z dimensions, respectively.
    The x, y and z sizes, as specified by the code:LocalSize
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[or code:LocalSizeId]
    execution mode or by the object decorated by the WorkgroupSize
    decoration in shader modules, must be less than or equal to the
    corresponding limit.
    In the current implementation, the maximum workgroup size of the X
    dimension is 32, the others are 1.
  * pname:maxOutputClusterCount is the maximum number of output cluster a
    single cluster culling shader workgroup can emit.
  * pname:indirectBufferOffsetAlignment indicates the alignment for cluster
    drawing command buffer stride.
    flink:vkCmdDrawClusterIndirectHUAWEI::pname:offset must be a multiple of
    this value.

:refpage: VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI.adoc[]
--
endif::VK_HUAWEI_cluster_culling_shader[]

ifdef::VK_ARM_shader_core_properties[]
[open,refpage='VkPhysicalDeviceShaderCorePropertiesARM',desc='Structure describing shader core properties that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderCorePropertiesARM structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderCorePropertiesARM.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pixelRate is an unsigned integer value indicating the maximum
    number of pixels output per clock per shader core.
  * pname:texelRate is an unsigned integer value indicating the maximum
    number of texels per clock per shader core.
  * pname:fmaRate is an unsigned integer value indicating the maximum number
    of single-precision fused multiply-add operations per clock per shader
    core.

If a throughput rate cannot be determined on the physical device, the value
`0` will be returned for that rate.

:refpage: VkPhysicalDeviceShaderCorePropertiesARM
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceShaderCorePropertiesARM.adoc[]
--
endif::VK_ARM_shader_core_properties[]

ifdef::VK_EXT_shader_object[]
[open,refpage='VkPhysicalDeviceShaderObjectPropertiesEXT',desc='Structure describing shader object properties supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderObjectPropertiesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderObjectPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-shaderBinaryUUID]] pname:shaderBinaryUUID is an array of
    ename:VK_UUID_SIZE code:uint8_t values representing a universally unique
    identifier for one or more implementations whose shader binaries are
    guaranteed to be compatible with each other.
  * [[limits-shaderBinaryVersion]] pname:shaderBinaryVersion is an unsigned
    integer incremented to represent backwards compatible differences
    between implementations with the same pname:shaderBinaryUUID.

The purpose and usage of the values of this structure are described in
greater detail in <<shaders-objects-binary-compatibility, Binary Shader
Compatibility>>.

:refpage: VkPhysicalDeviceShaderObjectPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceShaderObjectPropertiesEXT.adoc[]
--
endif::VK_EXT_shader_object[]


ifdef::VK_AMDX_shader_enqueue[]
[open,refpage='VkPhysicalDeviceShaderEnqueuePropertiesAMDX',desc='Structure describing shader enqueue limits of an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderEnqueuePropertiesAMDX structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderEnqueuePropertiesAMDX.adoc[]

The members of the sname:VkPhysicalDeviceShaderEnqueuePropertiesAMDX
structure describe the following limits:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-maxExecutionGraphDepth]] pname:maxExecutionGraphDepth defines
    the maximum node chain depth in the graph.
    The dispatched node is at depth 1 and the node enqueued by it is at
    depth 2, and so on.
    If a node enqueues itself, each recursive enqueue increases the depth by
    1 as well.
  * [[limits-maxExecutionGraphShaderOutputNodes]]
    pname:maxExecutionGraphShaderOutputNodes specifies the maximum number of
    unique nodes that can be dispatched from a single shader, and must be at
    least 256.
  * [[limits-maxExecutionGraphShaderPayloadSize]]
    pname:maxExecutionGraphShaderPayloadSize specifies the maximum total
    size of payload declarations in a shader.
    For any payload declarations that share resources, indicated by
    code:NodeSharesPayloadLimitsWithAMDX decorations, the maximum size of
    each set of shared payload declarations is taken.
    The sum of each shared set's maximum size and the size of each unshared
    payload is counted against this limit.
  * [[limits-maxExecutionGraphShaderPayloadCount]]
    pname:maxExecutionGraphShaderPayloadCount specifies the maximum number
    of output payloads that can be initialized in a single workgroup.
  * [[limits-executionGraphDispatchAddressAlignment]]
    pname:executionGraphDispatchAddressAlignment specifies the alignment of
    non-scratch basetype:VkDeviceAddress arguments consumed by graph
    dispatch commands.

:refpage: VkPhysicalDeviceShaderEnqueuePropertiesAMDX
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceShaderEnqueuePropertiesAMDX.adoc[]
--
endif::VK_AMDX_shader_enqueue[]

ifdef::VK_NV_extended_sparse_address_space[]
[open,refpage='VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV',desc='Structure describing sparse address space limits of an implementation',type='structs']
--
The sname:VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-extendedSparseAddressSpaceSize]]
    pname:extendedSparseAddressSpaceSize is the total amount of address
    space available, in bytes, for sparse memory resources of all usages if
    the <<features-extendedSparseAddressSpace,
    pname:extendedSparseAddressSpace>> feature is enabled.
    This must: be greater than or equal to
    sname:VkPhysicalDeviceLimits::pname:sparseAddressSpaceSize, and the
    difference in space must: only be used with usages allowed below.
    This is an upper bound on the sum of the sizes of all sparse resources,
    regardless of whether any memory is bound to them.
  * [[limits-extendedSparseImageUsageFlags]]
    pname:extendedSparseImageUsageFlags is a bitmask of
    elink:VkImageUsageFlagBits of usages which may: allow an implementation
    to use the full pname:extendedSparseAddressSpaceSize space.
  * [[limits-extendedSparseBufferUsageFlags]]
    pname:extendedSparseBufferUsageFlags is a bitmask of
    elink:VkBufferUsageFlagBits of usages which may: allow an implementation
    to use the full pname:extendedSparseAddressSpaceSize space.

:refpage: VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV.adoc[]
--
endif::VK_NV_extended_sparse_address_space[]

ifdef::VK_NV_cuda_kernel_launch[]
[open,refpage='VkPhysicalDeviceCudaKernelLaunchPropertiesNV',desc='Structure describing the compute capability version available',type='structs']
--
The sname:VkPhysicalDeviceCudaKernelLaunchPropertiesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCudaKernelLaunchPropertiesNV.adoc[]

The members of the sname:VkPhysicalDeviceCudaKernelLaunchPropertiesNV
structure describe the following features:

  * [[limits-computeCapabilityMinor]] pname:computeCapabilityMinor indicates
    the minor version number of the compute code.
  * [[limits-computeCapabilityMajor]] pname:computeCapabilityMajor indicates
    the major version number of the compute code.

:refpage: VkPhysicalDeviceCudaKernelLaunchPropertiesNV
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceCudaKernelLaunchPropertiesNV.adoc[]
--
endif::VK_NV_cuda_kernel_launch[]

ifdef::VK_ANDROID_external_format_resolve[]
[open,refpage='VkPhysicalDeviceExternalFormatResolvePropertiesANDROID',desc='Structure describing external format resolve supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceExternalFormatResolvePropertiesANDROID structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceExternalFormatResolvePropertiesANDROID.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-nullColorAttachmentWithExternalFormatResolve]]
    pname:nullColorAttachmentWithExternalFormatResolve indicates that there
    must: be no color attachment image when performing external format
    resolves if it is ename:VK_TRUE.
  * [[limits-externalFormatResolveChromaOffsetX]]
    pname:externalFormatResolveChromaOffsetX indicates the
    elink:VkChromaLocation that an implementation uses in the X axis for
    accesses to an external format image as a resolve attachment.
    This must: be consistent between external format resolves and load
    operations from external format resolve attachments to color attachments
    when pname:nullColorAttachmentWithExternalFormatResolve is
    ename:VK_TRUE.
  * [[limits-externalFormatResolveChromaOffsetY]]
    pname:externalFormatResolveChromaOffsetY indicates the
    elink:VkChromaLocation that an implementation uses in the Y axis for
    accesses to an external format image as a resolve attachment.
    This must: be consistent between external format resolves and load
    operations from external format resolve attachments to color attachments
    when pname:nullColorAttachmentWithExternalFormatResolve is
    ename:VK_TRUE.

:refpage: VkPhysicalDeviceExternalFormatResolvePropertiesANDROID
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceExternalFormatResolvePropertiesANDROID.adoc[]
--
endif::VK_ANDROID_external_format_resolve[]

ifdef::VK_ARM_render_pass_striped[]

[open,refpage='VkPhysicalDeviceRenderPassStripedPropertiesARM',desc='Structure describing striped rendering limits of an implementation',type='structs']
--
The sname:VkPhysicalDeviceRenderPassStripedPropertiesARM structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceRenderPassStripedPropertiesARM.adoc[]

The members of the sname:VkPhysicalDeviceRenderPassStripedPropertiesARM
structure describe the following limits:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[limits-renderPassStripeGranularity]] pname:renderPassStripeGranularity
    indicates the minimum supported granularity of striped render pass
    regions.
  * [[limits-maxRenderPassStripes]] pname:maxRenderPassStripes indicates the
    maximum number of stripes supported in striped rendering.

:refpage: VkPhysicalDeviceRenderPassStripedPropertiesARM
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceRenderPassStripedPropertiesARM.adoc[]
--

endif::VK_ARM_render_pass_striped[]

ifdef::VK_EXT_map_memory_placed[]
[open,refpage='VkPhysicalDeviceMapMemoryPlacedPropertiesEXT',desc='Structure describing the alignment requirements of placed memory maps for a physical device',type='structs']
--
The sname:VkPhysicalDeviceMapMemoryPlacedPropertiesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceMapMemoryPlacedPropertiesEXT.adoc[]

The members of the sname:VkPhysicalDeviceMapMemoryPlacedPropertiesEXT
structure describe the following:

  * [[limits-minPlacedMemoryMapAlignment]] pname:minPlacedMemoryMapAlignment
    is the minimum alignment required for memory object offsets and virtual
    address ranges when using placed memory mapping.

:refpage: VkPhysicalDeviceMapMemoryPlacedPropertiesEXT
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceMapMemoryPlacedPropertiesEXT.adoc[]
--
endif::VK_EXT_map_memory_placed[]

ifdef::VK_MESA_image_alignment_control[]
[open,refpage='VkPhysicalDeviceImageAlignmentControlPropertiesMESA',desc='Structure describing supported image alignments for a physical device',type='structs']
--
The sname:VkPhysicalDeviceImageAlignmentControlPropertiesMESA structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceImageAlignmentControlPropertiesMESA.adoc[]

The members of the sname:VkPhysicalDeviceImageAlignmentControlPropertiesMESA
structure describe the following:

  * [[limits-supportedImageAlignmentMask]] pname:supportedImageAlignmentMask
    is a bitwise-or of all potentially supported image alignments for a
    given physical device when using ename:VK_IMAGE_TILING_OPTIMAL.
    If a given alignment is supported, the application can: request an image
    to have that alignment.
    A given set of image creation parameters may: support a subset of these
    alignments.
    To determine if a particular alignment is supported for a given set of
    image creation parameters, check
    slink:VkMemoryRequirements::pname:alignment after chaining in
    slink:VkImageAlignmentControlCreateInfoMESA.

:refpage: VkPhysicalDeviceImageAlignmentControlPropertiesMESA
include::{chapters}/limits.adoc[tag=limits_desc]

include::{generated}/validity/structs/VkPhysicalDeviceImageAlignmentControlPropertiesMESA.adoc[]
--

endif::VK_MESA_image_alignment_control[]


[[limits-minmax]]
== Limit Requirements

The following table specifies the required: minimum/maximum for all Vulkan
graphics implementations.
Where a limit corresponds to a fine-grained device feature which is
optional:, the feature name is listed with two required: limits, one when
the feature is supported and one when it is not supported.
If an implementation supports a feature, the limits reported are the same
whether or not the feature is enabled.

[[limits-types]]
.Required Limit Types
[width="100%",cols="<20%,<50%,<30%",options="header"]
|====
| Type                     | Limit                                      | Feature
| code:uint32_t            | pname:maxImageDimension1D                  | -
| code:uint32_t            | pname:maxImageDimension2D                  | -
| code:uint32_t            | pname:maxImageDimension3D                  | -
| code:uint32_t            | pname:maxImageDimensionCube                | -
| code:uint32_t            | pname:maxImageArrayLayers                  | -
| code:uint32_t            | pname:maxTexelBufferElements               | -
| code:uint32_t            | pname:maxUniformBufferRange                | -
| code:uint32_t            | pname:maxStorageBufferRange                | -
| code:uint32_t            | pname:maxPushConstantsSize                 | -
| code:uint32_t            | pname:maxMemoryAllocationCount             | -
| code:uint32_t            | pname:maxSamplerAllocationCount            | -
| basetype:VkDeviceSize    | pname:bufferImageGranularity               | -
| basetype:VkDeviceSize    | pname:sparseAddressSpaceSize               | pname:sparseBinding
| code:uint32_t            | pname:maxBoundDescriptorSets               | -
| code:uint32_t            | pname:maxPerStageDescriptorSamplers        | -
| code:uint32_t            | pname:maxPerStageDescriptorUniformBuffers  | -
| code:uint32_t            | pname:maxPerStageDescriptorStorageBuffers  | -
| code:uint32_t            | pname:maxPerStageDescriptorSampledImages   | -
| code:uint32_t            | pname:maxPerStageDescriptorStorageImages   | -
| code:uint32_t            | pname:maxPerStageDescriptorInputAttachments| -
| code:uint32_t            | pname:maxPerStageResources                 | -
| code:uint32_t            | pname:maxDescriptorSetSamplers             | -
| code:uint32_t            | pname:maxDescriptorSetUniformBuffers       | -
| code:uint32_t            | pname:maxDescriptorSetUniformBuffersDynamic| -
| code:uint32_t            | pname:maxDescriptorSetStorageBuffers       | -
| code:uint32_t            | pname:maxDescriptorSetStorageBuffersDynamic| -
| code:uint32_t            | pname:maxDescriptorSetSampledImages        | -
| code:uint32_t            | pname:maxDescriptorSetStorageImages        | -
| code:uint32_t            | pname:maxDescriptorSetInputAttachments     | -
| code:uint32_t            | pname:maxVertexInputAttributes             | -
| code:uint32_t            | pname:maxVertexInputBindings               | -
| code:uint32_t            | pname:maxVertexInputAttributeOffset        | -
| code:uint32_t            | pname:maxVertexInputBindingStride          | -
| code:uint32_t            | pname:maxVertexOutputComponents            | -
| code:uint32_t            | pname:maxTessellationGenerationLevel       | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationPatchSize             | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationControlPerVertexInputComponents  | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationControlPerVertexOutputComponents | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationControlPerPatchOutputComponents  | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationControlTotalOutputComponents     | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationEvaluationInputComponents        | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationEvaluationOutputComponents       | pname:tessellationShader
| code:uint32_t            | pname:maxGeometryShaderInvocations         | pname:geometryShader
| code:uint32_t            | pname:maxGeometryInputComponents           | pname:geometryShader
| code:uint32_t            | pname:maxGeometryOutputComponents          | pname:geometryShader
| code:uint32_t            | pname:maxGeometryOutputVertices            | pname:geometryShader
| code:uint32_t            | pname:maxGeometryTotalOutputComponents     | pname:geometryShader
| code:uint32_t            | pname:maxFragmentInputComponents           | -
| code:uint32_t            | pname:maxFragmentOutputAttachments         | -
| code:uint32_t            | pname:maxFragmentDualSrcAttachments        | pname:dualSrcBlend
| code:uint32_t            | pname:maxFragmentCombinedOutputResources   | -
| code:uint32_t            | pname:maxComputeSharedMemorySize           | -
| 3 {times} code:uint32_t  | pname:maxComputeWorkGroupCount             | -
| code:uint32_t            | pname:maxComputeWorkGroupInvocations       | -
| 3 {times} code:uint32_t  | pname:maxComputeWorkGroupSize              | -
| code:uint32_t            | pname:subPixelPrecisionBits                | -
| code:uint32_t            | pname:subTexelPrecisionBits                | -
| code:uint32_t            | pname:mipmapPrecisionBits                  | -
| code:uint32_t            | pname:maxDrawIndexedIndexValue             | pname:fullDrawIndexUint32
| code:uint32_t            | pname:maxDrawIndirectCount                 | pname:multiDrawIndirect
| code:float               | pname:maxSamplerLodBias                    | -
| code:float               | pname:maxSamplerAnisotropy                 | pname:samplerAnisotropy
| code:uint32_t            | pname:maxViewports                         | pname:multiViewport
| 2 {times} code:uint32_t  | pname:maxViewportDimensions                | -
| 2 {times} code:float     | pname:viewportBoundsRange                  | -
| code:uint32_t            | pname:viewportSubPixelBits                 | -
| code:size_t              | pname:minMemoryMapAlignment                | -
| basetype:VkDeviceSize    | pname:minTexelBufferOffsetAlignment        | -
| basetype:VkDeviceSize    | pname:minUniformBufferOffsetAlignment      | -
| basetype:VkDeviceSize    | pname:minStorageBufferOffsetAlignment      | -
| code:int32_t             | pname:minTexelOffset                       | -
| code:uint32_t            | pname:maxTexelOffset                       | -
| code:int32_t             | pname:minTexelGatherOffset                 | pname:shaderImageGatherExtended
| code:uint32_t            | pname:maxTexelGatherOffset                 | pname:shaderImageGatherExtended
| code:float               | pname:minInterpolationOffset               | pname:sampleRateShading
| code:float               | pname:maxInterpolationOffset               | pname:sampleRateShading
| code:uint32_t            | pname:subPixelInterpolationOffsetBits      | pname:sampleRateShading
| code:uint32_t            | pname:maxFramebufferWidth                  | -
| code:uint32_t            | pname:maxFramebufferHeight                 | -
| code:uint32_t            | pname:maxFramebufferLayers                 |
ifdef::VKSC_VERSION_1_0[pname:geometryShader, pname:shaderOutputLayer]
ifndef::VKSC_VERSION_1_0[-]
| tlink:VkSampleCountFlags | pname:framebufferColorSampleCounts         | -
ifdef::VK_VERSION_1_2[]
| tlink:VkSampleCountFlags | pname:framebufferIntegerColorSampleCounts  | -
endif::VK_VERSION_1_2[]
| tlink:VkSampleCountFlags | pname:framebufferDepthSampleCounts         | -
| tlink:VkSampleCountFlags | pname:framebufferStencilSampleCounts       | -
| tlink:VkSampleCountFlags | pname:framebufferNoAttachmentsSampleCounts | -
| code:uint32_t            | pname:maxColorAttachments                  | -
| tlink:VkSampleCountFlags | pname:sampledImageColorSampleCounts        | -
| tlink:VkSampleCountFlags | pname:sampledImageIntegerSampleCounts      | -
| tlink:VkSampleCountFlags | pname:sampledImageDepthSampleCounts        | -
| tlink:VkSampleCountFlags | pname:sampledImageStencilSampleCounts      | -
| tlink:VkSampleCountFlags | pname:storageImageSampleCounts             | pname:shaderStorageImageMultisample
| code:uint32_t            | pname:maxSampleMaskWords                   | -
| basetype:VkBool32        | pname:timestampComputeAndGraphics          | -
| code:float               | pname:timestampPeriod                      | -
| code:uint32_t            | pname:maxClipDistances                     | pname:shaderClipDistance
| code:uint32_t            | pname:maxCullDistances                     | pname:shaderCullDistance
| code:uint32_t            | pname:maxCombinedClipAndCullDistances      | pname:shaderCullDistance
| code:uint32_t            | pname:discreteQueuePriorities              | -
| 2 {times} code:float     | pname:pointSizeRange                       | pname:largePoints
| 2 {times} code:float     | pname:lineWidthRange                       | pname:wideLines
| code:float               | pname:pointSizeGranularity                 | pname:largePoints
| code:float               | pname:lineWidthGranularity                 | pname:wideLines
| basetype:VkBool32        | pname:strictLines                          | -
| basetype:VkBool32        | pname:standardSampleLocations              | -
| basetype:VkDeviceSize    | pname:optimalBufferCopyOffsetAlignment     | -
| basetype:VkDeviceSize    | pname:optimalBufferCopyRowPitchAlignment   | -
| basetype:VkDeviceSize    | pname:nonCoherentAtomSize                  | -
ifdef::VK_EXT_discard_rectangles[]
| code:uint32_t            | pname:maxDiscardRectangles                 | `apiext:VK_EXT_discard_rectangles`
endif::VK_EXT_discard_rectangles[]
ifdef::VK_VERSION_1_2,VK_EXT_sampler_filter_minmax[]
| basetype:VkBool32        | pname:filterMinmaxSingleComponentFormats   |
ifdef::VK_VERSION_1_2[`<<features-samplerFilterMinmax, pname:samplerFilterMinmax>>` ]
ifdef::VK_EXT_sampler_filter_minmax[`apiext:VK_EXT_sampler_filter_minmax`]
| basetype:VkBool32        | pname:filterMinmaxImageComponentMapping    |
ifdef::VK_VERSION_1_2[`<<features-samplerFilterMinmax, pname:samplerFilterMinmax>>` ]
ifdef::VK_EXT_sampler_filter_minmax[`apiext:VK_EXT_sampler_filter_minmax`]
endif::VK_VERSION_1_2,VK_EXT_sampler_filter_minmax[]
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
| basetype:VkDeviceSize    | pname:maxBufferSize                        | `<<features-maintenance4, pname:maintenance4>>`
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]
ifdef::VK_EXT_conservative_rasterization[]
| code:float           | pname:primitiveOverestimationSize                 | `apiext:VK_EXT_conservative_rasterization`
| basetype:VkBool32        | pname:maxExtraPrimitiveOverestimationSize         | `apiext:VK_EXT_conservative_rasterization`
| code:float           | pname:extraPrimitiveOverestimationSizeGranularity | `apiext:VK_EXT_conservative_rasterization`
| basetype:VkBool32        | pname:degenerateTriangleRasterized                | `apiext:VK_EXT_conservative_rasterization`
| code:float           | pname:degenerateLinesRasterized                   | `apiext:VK_EXT_conservative_rasterization`
| basetype:VkBool32        | pname:fullyCoveredFragmentShaderInputVariable     | `apiext:VK_EXT_conservative_rasterization`
| basetype:VkBool32        | pname:conservativeRasterizationPostDepthCoverage  | `apiext:VK_EXT_conservative_rasterization`
endif::VK_EXT_conservative_rasterization[]
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
| code:uint32_t     | pname:maxUpdateAfterBindDescriptorsInAllPools             | `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| basetype:VkBool32 | pname:shaderUniformBufferArrayNonUniformIndexingNative    | -
| basetype:VkBool32 | pname:shaderSampledImageArrayNonUniformIndexingNative     | -
| basetype:VkBool32 | pname:shaderStorageBufferArrayNonUniformIndexingNative    | -
| basetype:VkBool32 | pname:shaderStorageImageArrayNonUniformIndexingNative     | -
| basetype:VkBool32 | pname:shaderInputAttachmentArrayNonUniformIndexingNative  | -
| code:uint32_t     | pname:maxPerStageDescriptorUpdateAfterBindSamplers        | `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxPerStageDescriptorUpdateAfterBindUniformBuffers  | `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxPerStageDescriptorUpdateAfterBindStorageBuffers  | `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxPerStageDescriptorUpdateAfterBindSampledImages   | `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxPerStageDescriptorUpdateAfterBindStorageImages   | `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxPerStageDescriptorUpdateAfterBindInputAttachments| `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxPerStageUpdateAfterBindResources                 | `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxDescriptorSetUpdateAfterBindSamplers             | `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxDescriptorSetUpdateAfterBindUniformBuffers       | `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxDescriptorSetUpdateAfterBindUniformBuffersDynamic| `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxDescriptorSetUpdateAfterBindStorageBuffers       | `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxDescriptorSetUpdateAfterBindStorageBuffersDynamic| `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxDescriptorSetUpdateAfterBindSampledImages        | `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxDescriptorSetUpdateAfterBindStorageImages        | `<<features-descriptorIndexing, pname:descriptorIndexing>>`
| code:uint32_t     | pname:maxDescriptorSetUpdateAfterBindInputAttachments     | `<<features-descriptorIndexing, pname:descriptorIndexing>>`
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
ifdef::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]
| code:uint32_t     | pname:maxInlineUniformBlockSize                               |`<<features-inlineUniformBlock, pname:inlineUniformBlock>>`
| code:uint32_t     | pname:maxPerStageDescriptorInlineUniformBlocks                |`<<features-inlineUniformBlock, pname:inlineUniformBlock>>`
| code:uint32_t     | pname:maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks |`<<features-inlineUniformBlock, pname:inlineUniformBlock>>`
| code:uint32_t     | pname:maxDescriptorSetInlineUniformBlocks                     |`<<features-inlineUniformBlock, pname:inlineUniformBlock>>`
| code:uint32_t     | pname:maxDescriptorSetUpdateAfterBindInlineUniformBlocks      |`<<features-inlineUniformBlock, pname:inlineUniformBlock>>`
endif::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]
ifdef::VK_VERSION_1_3[]
| code:uint32_t     | pname:maxInlineUniformTotalSize                               |`<<features-inlineUniformBlock, pname:inlineUniformBlock>>`
endif::VK_VERSION_1_3[]
ifdef::VK_EXT_vertex_attribute_divisor,VK_KHR_vertex_attribute_divisor[]
| code:uint32_t            | pname:maxVertexAttribDivisor               |
ifdef::VK_KHR_vertex_attribute_divisor[`apiext:VK_KHR_vertex_attribute_divisor`]
ifndef::VK_KHR_vertex_attribute_divisor[`apiext:VK_EXT_vertex_attribute_divisor`]
endif::VK_EXT_vertex_attribute_divisor,VK_KHR_vertex_attribute_divisor[]
ifdef::VK_NV_mesh_shader[]
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxDrawMeshTasksCount               | `apiext:VK_NV_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxTaskWorkGroupInvocations         | `apiext:VK_NV_mesh_shader`
| 3 {times} code:uint32_t  | slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxTaskWorkGroupSize                | `apiext:VK_NV_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxTaskTotalMemorySize              | `apiext:VK_NV_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxTaskOutputCount                  | `apiext:VK_NV_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshWorkGroupInvocations         | `apiext:VK_NV_mesh_shader`
| 3 {times} code:uint32_t  | slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshWorkGroupSize                | `apiext:VK_NV_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshTotalMemorySize              | `apiext:VK_NV_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshOutputVertices               | `apiext:VK_NV_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshOutputPrimitives             | `apiext:VK_NV_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshMultiviewViewCount           | `apiext:VK_NV_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:meshOutputPerVertexGranularity      | `apiext:VK_NV_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:meshOutputPerPrimitiveGranularity   | `apiext:VK_NV_mesh_shader`
endif::VK_NV_mesh_shader[]
ifdef::VK_EXT_mesh_shader[]
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskWorkGroupTotalCount                 | `apiext:VK_EXT_mesh_shader`
| 3 {times} code:uint32_t  | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskWorkGroupCount                      | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskWorkGroupInvocations                | `apiext:VK_EXT_mesh_shader`
| 3 {times} code:uint32_t  | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskWorkGroupSize                       | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskPayloadSize                         | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskSharedMemorySize                    | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskPayloadAndSharedMemorySize          | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupTotalCount                 | `apiext:VK_EXT_mesh_shader`
| 3 {times} code:uint32_t  | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupCount                      | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupInvocations                | `apiext:VK_EXT_mesh_shader`
| 3 {times} code:uint32_t  | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupSize                       | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshSharedMemorySize                    | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshPayloadAndSharedMemorySize          | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshOutputMemorySize                    | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshPayloadAndOutputMemorySize          | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshOutputComponents                    | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshOutputVertices                      | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshOutputPrimitives                    | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshOutputLayers                        | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshMultiviewViewCount                  | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:meshOutputPerVertexGranularity             | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:meshOutputPerPrimitiveGranularity          | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxPreferredTaskWorkGroupInvocations       | `apiext:VK_EXT_mesh_shader`
| code:uint32_t            | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxPreferredMeshWorkGroupInvocations       | `apiext:VK_EXT_mesh_shader`
| basetype:VkBool32        | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:prefersLocalInvocationVertexOutput         | `apiext:VK_EXT_mesh_shader`
| basetype:VkBool32        | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:prefersLocalInvocationPrimitiveOutput      | `apiext:VK_EXT_mesh_shader`
| basetype:VkBool32        | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:prefersCompactVertexOutput                 | `apiext:VK_EXT_mesh_shader`
| basetype:VkBool32        | slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:prefersCompactPrimitiveOutput              | `apiext:VK_EXT_mesh_shader`
endif::VK_EXT_mesh_shader[]
ifdef::VK_EXT_transform_feedback[]
| code:uint32_t            | pname:maxTransformFeedbackStreams                 | `apiext:VK_EXT_transform_feedback`
| code:uint32_t            | pname:maxTransformFeedbackBuffers                 | `apiext:VK_EXT_transform_feedback`
| basetype:VkDeviceSize    | pname:maxTransformFeedbackBufferSize              | `apiext:VK_EXT_transform_feedback`
| code:uint32_t            | pname:maxTransformFeedbackStreamDataSize          | `apiext:VK_EXT_transform_feedback`
| code:uint32_t            | pname:maxTransformFeedbackBufferDataSize          | `apiext:VK_EXT_transform_feedback`
| code:uint32_t            | pname:maxTransformFeedbackBufferDataStride        | `apiext:VK_EXT_transform_feedback`
| basetype:VkBool32        | pname:transformFeedbackQueries                    | `apiext:VK_EXT_transform_feedback`
| basetype:VkBool32        | pname:transformFeedbackStreamsLinesTriangles      | `apiext:VK_EXT_transform_feedback`
| basetype:VkBool32        | pname:transformFeedbackRasterizationStreamSelect  | `apiext:VK_EXT_transform_feedback`
| basetype:VkBool32        | pname:transformFeedbackDraw                       | `apiext:VK_EXT_transform_feedback`
endif::VK_EXT_transform_feedback[]
ifdef::VK_EXT_fragment_density_map[]
| slink:VkExtent2D         | pname:minFragmentDensityTexelSize         | `<<features-fragmentDensityMap, pname:fragmentDensityMap>>`
| slink:VkExtent2D         | pname:maxFragmentDensityTexelSize         | `<<features-fragmentDensityMap, pname:fragmentDensityMap>>`
| basetype:VkBool32        | pname:fragmentDensityInvocations          | `<<features-fragmentDensityMap, pname:fragmentDensityMap>>`
ifdef::VK_EXT_fragment_density_map2[]
| basetype:VkBool32        | pname:subsampledLoads                           | `apiext:VK_EXT_fragment_density_map2`
| basetype:VkBool32        | pname:subsampledCoarseReconstructionEarlyAccess | `apiext:VK_EXT_fragment_density_map2`
| code:uint32_t            | pname:maxSubsampledArrayLayers                  | `apiext:VK_EXT_fragment_density_map2`
| code:uint32_t            | pname:maxDescriptorSetSubsampledSamplers        | `apiext:VK_EXT_fragment_density_map2`
endif::VK_EXT_fragment_density_map2[]
ifdef::VK_QCOM_fragment_density_map_offset[]
| slink:VkExtent2D         | pname:fragmentDensityOffsetGranularity    | `<<features-fragmentDensityMapOffsets, pname:fragmentDensityMapOffset>>`
endif::VK_QCOM_fragment_density_map_offset[]
endif::VK_EXT_fragment_density_map[]
ifdef::VK_NV_ray_tracing,VK_KHR_acceleration_structure[]
| code:uint32_t            | pname:maxGeometryCount                         | `apiext:VK_NV_ray_tracing`, `apiext:VK_KHR_acceleration_structure`
| code:uint32_t            | pname:maxInstanceCount                         | `apiext:VK_NV_ray_tracing`, `apiext:VK_KHR_acceleration_structure`
endif::VK_NV_ray_tracing,VK_KHR_acceleration_structure[]
ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
| code:uint32_t            | pname:shaderGroupHandleSize                    | `apiext:VK_NV_ray_tracing`, `apiext:VK_KHR_ray_tracing_pipeline`
| code:uint32_t            | pname:maxShaderGroupStride                     | `apiext:VK_NV_ray_tracing`, `apiext:VK_KHR_ray_tracing_pipeline`
| code:uint32_t            | pname:shaderGroupBaseAlignment                 | `apiext:VK_NV_ray_tracing`, `apiext:VK_KHR_ray_tracing_pipeline`
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_ray_tracing[]
| code:uint32_t            | pname:maxRecursionDepth                        | `apiext:VK_NV_ray_tracing`
| code:uint32_t            | pname:maxTriangleCount                         | `apiext:VK_NV_ray_tracing`
endif::VK_NV_ray_tracing[]
ifdef::VK_KHR_acceleration_structure[]
| code:uint32_t            | pname:maxPerStageDescriptorAccelerationStructures
                                                                            | `apiext:VK_KHR_acceleration_structure`
| code:uint32_t            | pname:maxPerStageDescriptorUpdateAfterBindAccelerationStructures
                                                                            | `apiext:VK_KHR_acceleration_structure`
endif::VK_KHR_acceleration_structure[]
ifdef::VK_NV_ray_tracing,VK_KHR_acceleration_structure[]
| code:uint32_t            | pname:maxDescriptorSetAccelerationStructures   | `apiext:VK_NV_ray_tracing`, `apiext:VK_KHR_acceleration_structure`
endif::VK_NV_ray_tracing,VK_KHR_acceleration_structure[]
ifdef::VK_KHR_acceleration_structure[]
| code:uint32_t            | pname:maxDescriptorSetUpdateAfterBindAccelerationStructures
                                                                            | `apiext:VK_KHR_acceleration_structure`
| code:uint32_t            | pname:minAccelerationStructureScratchOffsetAlignment
                                                                            | `apiext:VK_KHR_acceleration_structure`
endif::VK_KHR_acceleration_structure[]
ifdef::VK_KHR_ray_tracing_pipeline[]
| code:uint32_t            | pname:maxRayRecursionDepth                     | `apiext:VK_KHR_ray_tracing_pipeline`
| code:uint32_t            | pname:shaderGroupHandleCaptureReplaySize       | `apiext:VK_KHR_ray_tracing_pipeline`
| code:uint32_t            | pname:maxRayDispatchInvocationCount            | `apiext:VK_KHR_ray_tracing_pipeline`
| code:uint32_t            | pname:shaderGroupHandleAlignment               | `apiext:VK_KHR_ray_tracing_pipeline`
| code:uint32_t            | pname:maxRayHitAttributeSize                   | `apiext:VK_KHR_ray_tracing_pipeline`
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]
| code:uint64_t            | pname:maxTimelineSemaphoreValueDifference      | `<<features-timelineSemaphore, pname:timelineSemaphore>>`
endif::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]
ifdef::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
| code:uint32_t            | pname:lineSubPixelPrecisionBits                | `apiext:VK_KHR_line_rasterization`, `apiext:VK_EXT_line_rasterization`
endif::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
ifdef::VK_EXT_custom_border_color[]
| code:uint32_t            | pname:maxCustomBorderColorSamplers             | `apiext:VK_EXT_custom_border_color`
endif::VK_EXT_custom_border_color[]
ifdef::VK_EXT_robustness2[]
| basetype:VkDeviceSize    | pname:robustStorageBufferAccessSizeAlignment   | `apiext:VK_EXT_robustness2`
| basetype:VkDeviceSize    | pname:robustUniformBufferAccessSizeAlignment   | `apiext:VK_EXT_robustness2`
endif::VK_EXT_robustness2[]
ifdef::VK_KHR_fragment_shading_rate[]
| 2 {times} code:uint32_t       | pname:minFragmentShadingRateAttachmentTexelSize           | `<<features-attachmentFragmentShadingRate, pname:attachmentFragmentShadingRate>>`
| 2 {times} code:uint32_t       | pname:maxFragmentShadingRateAttachmentTexelSize           | `<<features-attachmentFragmentShadingRate, pname:attachmentFragmentShadingRate>>`
| code:uint32_t                 | pname:maxFragmentShadingRateAttachmentTexelSizeAspectRatio | `<<features-attachmentFragmentShadingRate, pname:attachmentFragmentShadingRate>>`
| basetype:VkBool32             | pname:primitiveFragmentShadingRateWithMultipleViewports   | `<<features-primitiveFragmentShadingRate, pname:primitiveFragmentShadingRate>>`
| basetype:VkBool32             | pname:layeredShadingRateAttachments                       | `<<features-attachmentFragmentShadingRate, pname:attachmentFragmentShadingRate>>`
| basetype:VkBool32             | pname:fragmentShadingRateNonTrivialCombinerOps            | `<<features-pipelineFragmentShadingRate, pname:pipelineFragmentShadingRate>>`
| 2 {times} code:uint32_t       | pname:maxFragmentSize                                     | `<<features-pipelineFragmentShadingRate, pname:pipelineFragmentShadingRate>>`
| code:uint32_t                 | pname:maxFragmentSizeAspectRatio                          | `<<features-pipelineFragmentShadingRate, pname:pipelineFragmentShadingRate>>`
| code:uint32_t                 | pname:maxFragmentShadingRateCoverageSamples               | `<<features-pipelineFragmentShadingRate, pname:pipelineFragmentShadingRate>>`
| elink:VkSampleCountFlagBits   | pname:maxFragmentShadingRateRasterizationSamples          | `<<features-pipelineFragmentShadingRate, pname:pipelineFragmentShadingRate>>`
| basetype:VkBool32             | pname:fragmentShadingRateWithShaderDepthStencilWrites     | `<<features-pipelineFragmentShadingRate, pname:pipelineFragmentShadingRate>>`
| basetype:VkBool32             | pname:fragmentShadingRateWithSampleMask                   | `<<features-pipelineFragmentShadingRate, pname:pipelineFragmentShadingRate>>`
| basetype:VkBool32             | pname:fragmentShadingRateWithShaderSampleMask             | `<<features-pipelineFragmentShadingRate, pname:pipelineFragmentShadingRate>>`
| basetype:VkBool32             | pname:fragmentShadingRateWithConservativeRasterization    | `<<features-pipelineFragmentShadingRate, pname:pipelineFragmentShadingRate>>`
| basetype:VkBool32             | pname:fragmentShadingRateWithFragmentShaderInterlock      | `<<features-pipelineFragmentShadingRate, pname:pipelineFragmentShadingRate>>`
| basetype:VkBool32             | pname:fragmentShadingRateWithCustomSampleLocations        | `<<features-pipelineFragmentShadingRate, pname:pipelineFragmentShadingRate>>`
| basetype:VkBool32             | pname:fragmentShadingRateStrictMultiplyCombiner           | `<<features-pipelineFragmentShadingRate, pname:pipelineFragmentShadingRate>>`
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_NV_fragment_shading_rate_enums[]
| elink:VkSampleCountFlagBits   | pname:maxFragmentShadingRateInvocationCount               | `<<features-supersampleFragmentShadingRates, pname:supersampleFragmentShadingRates>>`
endif::VK_NV_fragment_shading_rate_enums[]
ifdef::VK_EXT_descriptor_buffer[]
| basetype:VkBool32       | pname:combinedImageSamplerDescriptorSingleArray          | `<<VK_EXT_descriptor_buffer>>`
| basetype:VkBool32       | pname:bufferlessPushDescriptors            | `<<VK_EXT_descriptor_buffer>>`
| basetype:VkBool32       | pname:allowSamplerImageViewPostSubmitCreation     | `<<VK_EXT_descriptor_buffer>>`
| basetype:VkDeviceSize   | pname:descriptorBufferOffsetAlignment             | `<<VK_EXT_descriptor_buffer>>`
| code:uint32_t           | pname:maxDescriptorBufferBindings                 | `<<VK_EXT_descriptor_buffer>>`
| code:uint32_t           | pname:maxResourceDescriptorBufferBindings         | `<<VK_EXT_descriptor_buffer>>`
| code:uint32_t           | pname:maxSamplerDescriptorBufferBindings          | `<<VK_EXT_descriptor_buffer>>`
| code:uint32_t           | pname:maxEmbeddedImmutableSamplerBindings         | `<<VK_EXT_descriptor_buffer>>`
| code:uint32_t           | pname:maxEmbeddedImmutableSamplers                | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:bufferCaptureReplayDescriptorDataSize       | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:imageCaptureReplayDescriptorDataSize        | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:imageViewCaptureReplayDescriptorDataSize    | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:samplerCaptureReplayDescriptorDataSize      | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:accelerationStructureCaptureReplayDescriptorDataSize      | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:samplerDescriptorSize                       | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:combinedImageSamplerDescriptorSize          | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:sampledImageDescriptorSize                  | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:storageImageDescriptorSize                  | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:uniformTexelBufferDescriptorSize            | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:robustUniformTexelBufferDescriptorSize      | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:storageTexelBufferDescriptorSize            | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:robustStorageTexelBufferDescriptorSize      | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:uniformBufferDescriptorSize                 | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:robustUniformBufferDescriptorSize           | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:storageBufferDescriptorSize                 | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:robustStorageBufferDescriptorSize           | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:inputAttachmentDescriptorSize               | `<<VK_EXT_descriptor_buffer>>`
| code:size_t             | pname:accelerationStructureDescriptorSize         | `<<VK_EXT_descriptor_buffer>>`
| basetype:VkDeviceSize   | pname:maxSamplerDescriptorBufferRange             | `<<VK_EXT_descriptor_buffer>>`
| basetype:VkDeviceSize   | pname:maxResourceDescriptorBufferRange            | `<<VK_EXT_descriptor_buffer>>`
| basetype:VkDeviceSize   | pname:samplerDescriptorBufferAddressSpaceSize     | `<<VK_EXT_descriptor_buffer>>`
| basetype:VkDeviceSize   | pname:resourceDescriptorBufferAddressSpaceSize    | `<<VK_EXT_descriptor_buffer>>`
| basetype:VkDeviceSize   | pname:descriptorBufferAddressSpaceSize            | `<<VK_EXT_descriptor_buffer>>`
ifdef::VK_EXT_fragment_density_map[]
| code:size_t             | pname:combinedImageSamplerDensityMapDescriptorSize          | `<<VK_EXT_descriptor_buffer>>`
endif::VK_EXT_fragment_density_map[]
endif::VK_EXT_descriptor_buffer[]
ifdef::VK_HUAWEI_subpass_shading[]
| code:uint32_t                 | pname:maxSubpassShadingWorkgroupSizeAspectRatio | `<<features-subpassShading, pname:subpassShading>>`
endif::VK_HUAWEI_subpass_shading[]
ifdef::VKSC_VERSION_1_0[]
| basetype:VkBool32        | pname:deviceNoDynamicHostAllocations                   | -
| basetype:VkBool32        | pname:deviceDestroyFreesMemory                         | -
| basetype:VkBool32        | pname:commandPoolMultipleCommandBuffersRecording       | -
| basetype:VkBool32        | pname:commandPoolResetCommandBuffer                    | -
| basetype:VkBool32        | pname:commandBufferSimultaneousUse                     | -
| basetype:VkBool32        | pname:secondaryCommandBufferNullOrImagelessFramebuffer | -
| basetype:VkBool32        | pname:recycleDescriptorSetMemory                       | -
| basetype:VkBool32        | pname:recyclePipelineMemory                            | -
| code:uint32_t            | pname:maxRenderPassSubpasses                           | -
| code:uint32_t            | pname:maxRenderPassDependencies                        | -
| code:uint32_t            | pname:maxSubpassInputAttachments                       | -
| code:uint32_t            | pname:maxSubpassPreserveAttachments                    | -
| code:uint32_t            | pname:maxFramebufferAttachments                        | -
| code:uint32_t            | pname:maxDescriptorSetLayoutBindings                   | -
| code:uint32_t            | pname:maxQueryFaultCount                               | -
| code:uint32_t            | pname:maxCallbackFaultCount                            | -
| code:uint32_t            | pname:maxCommandPoolCommandBuffers                     | -
| basetype:VkDeviceSize    | pname:maxCommandBufferSize                             | -
endif::VKSC_VERSION_1_0[]
ifdef::VK_EXT_graphics_pipeline_library[]
| basetype:VkBool32             | pname:graphicsPipelineLibraryFastLinking                  | `<<features-graphicsPipelineLibrary, pname:graphicsPipelineLibrary>>`
| basetype:VkBool32             | pname:graphicsPipelineLibraryIndependentInterpolationDecoration | `<<features-graphicsPipelineLibrary, pname:graphicsPipelineLibrary>>`
endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_KHR_fragment_shader_barycentric[]
| basetype:VkBool32             | pname:triStripVertexOrderIndependentOfProvokingVertex     | -
endif::VK_KHR_fragment_shader_barycentric[]
ifdef::VK_QCOM_image_processing[]
| code:uint32_t                 | pname:maxWeightFilterPhases    | `<<features-textureSampleWeighted, pname:textureSampleWeighted>>`
| 2 {times} code:uint32_t       | pname:maxWeightFilterDimension | `<<features-textureSampleWeighted, pname:textureSampleWeighted>>`
| 2 {times} code:uint32_t       | pname:maxBlockMatchRegion      | `<<features-textureBlockMatch, pname:textureBlockMatch>>`
| 2 {times} code:uint32_t       | pname:maxBoxFilterBlockSize    | `<<features-textureBoxFilter, pname:textureBoxFilter>>`
endif::VK_QCOM_image_processing[]
ifdef::VK_EXT_extended_dynamic_state3[]
| basetype:VkBool32             | pname:dynamicPrimitiveTopologyUnrestricted                | `apiext:VK_EXT_extended_dynamic_state3`
endif::VK_EXT_extended_dynamic_state3[]
ifdef::VK_EXT_opacity_micromap[]
| code:uint32_t                 | pname:maxOpacity2StateSubdivisionLevel                    | `apiext:VK_EXT_opacity_micromap`
| code:uint32_t                 | pname:maxOpacity4StateSubdivisionLevel                    | `apiext:VK_EXT_opacity_micromap`
endif::VK_EXT_opacity_micromap[]
ifdef::VK_NV_memory_decompression[]
| code:uint64_t                 | pname:maxDecompressionIndirectCount                       | `apiext:VK_NV_memory_decompression`
endif::VK_NV_memory_decompression[]
ifdef::VK_HUAWEI_cluster_culling_shader[]
|  3 {times} code:uint32_t                 |
pname:maxWorkGroupCount | `apiext:VK_HUAWEI_cluster_culling_shader`
|  3 {times} code:uint32_t                 |
pname:maxWorkGroupSize | `apiext:VK_HUAWEI_cluster_culling_shader`
| code:uint32_t                 |
pname:maxOutputClusterCount | `apiext:VK_HUAWEI_cluster_culling_shader`
| basetype:VkDeviceSize                 |
pname:indirectBufferOffsetAlignment | `apiext:VK_HUAWEI_cluster_culling_shader`
endif::VK_HUAWEI_cluster_culling_shader[]
ifdef::VK_AMDX_shader_enqueue[]
| code:uint32_t                 | pname:maxExecutionGraphDepth                              | `<<features-shaderEnqueue,pname:shaderEnqueue>>`
| code:uint32_t                 | pname:maxExecutionGraphShaderOutputNodes                  | `<<features-shaderEnqueue,pname:shaderEnqueue>>`
| code:uint32_t                 | pname:maxExecutionGraphShaderPayloadSize                  | `<<features-shaderEnqueue,pname:shaderEnqueue>>`
| code:uint32_t                 | pname:maxExecutionGraphShaderPayloadCount                 | `<<features-shaderEnqueue,pname:shaderEnqueue>>`
| code:uint32_t                 | pname:executionGraphDispatchAddressAlignment              | `<<features-shaderEnqueue,pname:shaderEnqueue>>`
endif::VK_AMDX_shader_enqueue[]
ifdef::VK_NV_extended_sparse_address_space[]
| basetype:VkDeviceSize         | pname:extendedSparseAddressSpaceSize                      | pname:sparseBinding, `<<features-extendedSparseAddressSpace, pname:extendedSparseAddressSpace>>`
endif::VK_NV_extended_sparse_address_space[]
ifdef::VK_MESA_image_alignment_control[]
| code:uint32_t                 | pname:supportedImageAlignmentMask | `<<features-imageAlignmentControl,pname:imageAlignmentControl>>`
endif::VK_MESA_image_alignment_control[]
|====

[[limits-required]]
.Required Limits
[width="100%",cols="<35,<9,<14,<11",options="header"]
|====
| Limit | Unsupported Limit | Supported Limit | Limit Type^1^
| pname:maxImageDimension1D                  | - | 4096    | min
| pname:maxImageDimension2D                  | - | 4096    | min
| pname:maxImageDimension3D                  | - | 256     | min
| pname:maxImageDimensionCube                | - | 4096    | min
| pname:maxImageArrayLayers                  | - | 256     | min
| pname:maxTexelBufferElements               | - | 65536   | min
| pname:maxUniformBufferRange                | - | 16384   | min
| pname:maxStorageBufferRange                | - | 2^27^   | min
| pname:maxPushConstantsSize                 | - | 128     | min
| pname:maxMemoryAllocationCount             | - | 4096    | min
| pname:maxSamplerAllocationCount            | - | 4000    | min
| pname:bufferImageGranularity               | - | 131072  | max
| pname:sparseAddressSpaceSize               | 0 | 2^31^   | min
| pname:maxBoundDescriptorSets               | - | 4       | min
| pname:maxPerStageDescriptorSamplers        | - | 16      | min
| pname:maxPerStageDescriptorUniformBuffers  | - | 12      | min
| pname:maxPerStageDescriptorStorageBuffers  | - | 4       | min
| pname:maxPerStageDescriptorSampledImages   | - | 16      | min
| pname:maxPerStageDescriptorStorageImages   | - | 4       | min
| pname:maxPerStageDescriptorInputAttachments| - | 4       | min
| pname:maxPerStageResources                 | - | 128 ^2^ | min
| pname:maxDescriptorSetSamplers             | - | 96 ^8^  | min, _n_ {times} PerStage
| pname:maxDescriptorSetUniformBuffers       | - | 72 ^8^  | min, _n_ {times} PerStage
| pname:maxDescriptorSetUniformBuffersDynamic| - | 8       | min
| pname:maxDescriptorSetStorageBuffers       | - | 24 ^8^  | min, _n_ {times} PerStage
| pname:maxDescriptorSetStorageBuffersDynamic| - | 4       | min
| pname:maxDescriptorSetSampledImages        | - | 96 ^8^  | min, _n_ {times} PerStage
| pname:maxDescriptorSetStorageImages        | - | 24 ^8^  | min, _n_ {times} PerStage
| pname:maxDescriptorSetInputAttachments     | - | 4       | min
| pname:maxVertexInputAttributes             | - | 16      | min
ifndef::VK_KHR_portability_subset[]
| pname:maxVertexInputBindings               | - | 16      | min
endif::VK_KHR_portability_subset[]
ifdef::VK_KHR_portability_subset[]
| pname:maxVertexInputBindings               | - | 16 ^10^ | min
endif::VK_KHR_portability_subset[]
| pname:maxVertexInputAttributeOffset        | - | 2047    | min
| pname:maxVertexInputBindingStride          | - | 2048    | min
| pname:maxVertexOutputComponents            | - | 64      | min
| pname:maxTessellationGenerationLevel       | 0 | 64      | min
| pname:maxTessellationPatchSize             | 0 | 32      | min
| pname:maxTessellationControlPerVertexInputComponents  | 0 |64 | min
| pname:maxTessellationControlPerVertexOutputComponents | 0 |64 | min
| pname:maxTessellationControlPerPatchOutputComponents  | 0 |120 | min
| pname:maxTessellationControlTotalOutputComponents     | 0 |2048 | min
| pname:maxTessellationEvaluationInputComponents        | 0 |64 | min
| pname:maxTessellationEvaluationOutputComponents       | 0 |64 | min
| pname:maxGeometryShaderInvocations         | 0 | 32      | min
| pname:maxGeometryInputComponents           | 0 | 64      | min
| pname:maxGeometryOutputComponents          | 0 | 64      | min
| pname:maxGeometryOutputVertices            | 0 | 256     | min
| pname:maxGeometryTotalOutputComponents     | 0 | 1024    | min
| pname:maxFragmentInputComponents           | - | 64      | min
| pname:maxFragmentOutputAttachments         | - | 4       | min
| pname:maxFragmentDualSrcAttachments        | 0 | 1       | min
| pname:maxFragmentCombinedOutputResources   | - | 4       | min
| pname:maxComputeSharedMemorySize           | - | 16384   | min
| pname:maxComputeWorkGroupCount             | - | (65535,65535,65535) | min
| pname:maxComputeWorkGroupInvocations       | - | 128     | min
| pname:maxComputeWorkGroupSize              | - | (128,128,64) | min
| pname:subPixelPrecisionBits                | - | 4       | min
| pname:subTexelPrecisionBits                | - | 4       | min
| pname:mipmapPrecisionBits                  | - | 4       | min
| pname:maxDrawIndexedIndexValue             | 2^24^-1 | 2^32^-1 | min
| pname:maxDrawIndirectCount                 | 1 | 2^16^-1 | min
| pname:maxSamplerLodBias                    | - | 2       | min
| pname:maxSamplerAnisotropy                 | 1 | 16      | min
| pname:maxViewports                         | 1 | 16      | min
| pname:maxViewportDimensions                | - | (4096,4096) ^3^  | min
| pname:viewportBoundsRange                  | - | (-8192,8191) ^4^ | (max,min)
| pname:viewportSubPixelBits                 | - | 0   | min
| pname:minMemoryMapAlignment                | - | 64  | min
| pname:minTexelBufferOffsetAlignment        | - | 256 | max
| pname:minUniformBufferOffsetAlignment      | - | 256 | max
| pname:minStorageBufferOffsetAlignment      | - | 256 | max
| pname:minTexelOffset                       | - | -8  | max
| pname:maxTexelOffset                       | - | 7   | min
| pname:minTexelGatherOffset                 | 0 | -8  | max
| pname:maxTexelGatherOffset                 | 0 | 7   | min
| pname:minInterpolationOffset               |0.0| -0.5 ^5^ | max
| pname:maxInterpolationOffset               |0.0| 0.5 - (1 ULP) ^5^ | min
| pname:subPixelInterpolationOffsetBits      | 0 | 4 ^5^ | min
| pname:maxFramebufferWidth                  | - | 4096  | min
| pname:maxFramebufferHeight                 | - | 4096  | min
| pname:maxFramebufferLayers                 |
ifdef::VKSC_VERSION_1_0[1]
ifndef::VKSC_VERSION_1_0[-]
| 256   | min
| pname:framebufferColorSampleCounts         | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
ifdef::VK_VERSION_1_2[]
| pname:framebufferIntegerColorSampleCounts  | - | (ename:VK_SAMPLE_COUNT_1_BIT)                                | min
endif::VK_VERSION_1_2[]
| pname:framebufferDepthSampleCounts         | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:framebufferStencilSampleCounts       | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:framebufferNoAttachmentsSampleCounts | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:maxColorAttachments                  | - | 4     | min
| pname:sampledImageColorSampleCounts        | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:sampledImageIntegerSampleCounts      | - | ename:VK_SAMPLE_COUNT_1_BIT                                  | min
| pname:sampledImageDepthSampleCounts        | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:sampledImageStencilSampleCounts      | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:storageImageSampleCounts             | ename:VK_SAMPLE_COUNT_1_BIT | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:maxSampleMaskWords                   | - | 1     | min
| pname:timestampComputeAndGraphics          | - | -     |implementation-dependent
| pname:timestampPeriod                      | - | -     |duration
| pname:maxClipDistances                     | 0 | 8     | min
| pname:maxCullDistances                     | 0 | 8     | min
| pname:maxCombinedClipAndCullDistances      | 0 | 8     | min
| pname:discreteQueuePriorities              | - | 2     | min
| pname:pointSizeRange                       | (1.0,1.0) | (1.0,64.0 - ULP)^6^| (max,min)
| pname:lineWidthRange                       | (1.0,1.0) | (1.0,8.0 - ULP)^7^ | (max,min)
| pname:pointSizeGranularity                 |  0.0 | 1.0 ^6^ | max, fixed point increment
| pname:lineWidthGranularity                 |  0.0 | 1.0 ^7^ | max, fixed point increment
| pname:strictLines                          | - | -   | implementation-dependent
| pname:standardSampleLocations              | - | -   | implementation-dependent
| pname:optimalBufferCopyOffsetAlignment     | - | -   | recommendation
| pname:optimalBufferCopyRowPitchAlignment   | - | -   | recommendation
| pname:nonCoherentAtomSize                  | - | 256 | max
ifdef::VK_KHR_push_descriptor[]
| pname:maxPushDescriptors                   | - | 32  | min
endif::VK_KHR_push_descriptor[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
| pname:maxMultiviewViewCount                | - |  6  | min
| pname:maxMultiviewInstanceIndex            | - |  2^27^-1  | min
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_EXT_discard_rectangles[]
| pname:maxDiscardRectangles                 | 0 | 4   | min
endif::VK_EXT_discard_rectangles[]
ifdef::VK_EXT_sample_locations[]
| pname:sampleLocationSampleCounts           | - | ename:VK_SAMPLE_COUNT_4_BIT | min
| pname:maxSampleLocationGridSize            | - | (1,1) | min
| pname:sampleLocationCoordinateRange        | - | (0.0, 0.9375) | (max,min)
| pname:sampleLocationSubPixelBits           | - | 4   | min
| pname:variableSampleLocations              | - |false| implementation-dependent
endif::VK_EXT_sample_locations[]
ifdef::VK_EXT_legacy_vertex_attributes[]
| pname:nativeUnalignedPerformance              | - |false| implementation-dependent
endif::VK_EXT_legacy_vertex_attributes[]
ifdef::VK_EXT_external_memory_host[]
| pname:minImportedHostPointerAlignment      | - | 65536 | max
endif::VK_EXT_external_memory_host[]
ifdef::VK_NVX_multiview_per_view_attributes[]
| pname:perViewPositionAllComponents         | - | -   | implementation-dependent
endif::VK_NVX_multiview_per_view_attributes[]
ifdef::VK_VERSION_1_2,VK_EXT_sampler_filter_minmax[]
| pname:filterMinmaxSingleComponentFormats   | - | -   | implementation-dependent
| pname:filterMinmaxImageComponentMapping    | - | -   | implementation-dependent
endif::VK_VERSION_1_2,VK_EXT_sampler_filter_minmax[]
ifdef::VK_EXT_blend_operation_advanced[]
| pname:advancedBlendMaxColorAttachments        | - | 1   | min
| pname:advancedBlendIndependentBlend           | - |false| implementation-dependent
| pname:advancedBlendNonPremultipliedSrcColor   | - |false| implementation-dependent
| pname:advancedBlendNonPremultipliedDstColor   | - |false| implementation-dependent
| pname:advancedBlendCorrelatedOverlap          | - |false| implementation-dependent
| pname:advancedBlendAllOperations              | - |false| implementation-dependent
endif::VK_EXT_blend_operation_advanced[]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance3[]
| pname:maxPerSetDescriptors                                | - |1024 | min
| pname:maxMemoryAllocationSize                             | - | 2^30^ | min
endif::VK_VERSION_1_1,VK_KHR_maintenance3[]
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
| pname:maxBufferSize                                       | - | 2^30^ | min
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]
ifdef::VK_EXT_conservative_rasterization[]
| pname:primitiveOverestimationSize                 | - |0.0   | min
| pname:maxExtraPrimitiveOverestimationSize         | - |0.0   | min
| pname:extraPrimitiveOverestimationSizeGranularity | - |0.0   | min
| pname:primitiveUnderestimation                    | - |false | implementation-dependent
| pname:conservativePointAndLineRasterization       | - |false | implementation-dependent
| pname:degenerateTrianglesRasterized               | - |false | implementation-dependent
| pname:degenerateLinesRasterized                   | - |false | implementation-dependent
| pname:fullyCoveredFragmentShaderInputVariable     | - |false | implementation-dependent
| pname:conservativeRasterizationPostDepthCoverage  | - |false | implementation-dependent
endif::VK_EXT_conservative_rasterization[]
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
| pname:maxUpdateAfterBindDescriptorsInAllPools             | 0 |500000| min
| pname:shaderUniformBufferArrayNonUniformIndexingNative    | - |false| implementation-dependent
| pname:shaderSampledImageArrayNonUniformIndexingNative     | - |false| implementation-dependent
| pname:shaderStorageBufferArrayNonUniformIndexingNative    | - |false| implementation-dependent
| pname:shaderStorageImageArrayNonUniformIndexingNative     | - |false| implementation-dependent
| pname:shaderInputAttachmentArrayNonUniformIndexingNative  | - |false| implementation-dependent
| pname:maxPerStageDescriptorUpdateAfterBindSamplers        | 0^9^ |500000 ^9^ | min
| pname:maxPerStageDescriptorUpdateAfterBindUniformBuffers  | 0^9^ |12 ^9^ | min
| pname:maxPerStageDescriptorUpdateAfterBindStorageBuffers  | 0^9^ |500000 ^9^ | min
| pname:maxPerStageDescriptorUpdateAfterBindSampledImages   | 0^9^ |500000 ^9^ | min
| pname:maxPerStageDescriptorUpdateAfterBindStorageImages   | 0^9^ |500000 ^9^ | min
| pname:maxPerStageDescriptorUpdateAfterBindInputAttachments| 0^9^ |4 ^9^ | min
| pname:maxPerStageUpdateAfterBindResources                 | 0^9^ |500000 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindSamplers             | 0^9^ |500000 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindUniformBuffers       | 0^9^ |72 ^8^ ^9^ | min, _n_ {times} PerStage
| pname:maxDescriptorSetUpdateAfterBindUniformBuffersDynamic| 0^9^ |8 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindStorageBuffers       | 0^9^ |500000 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindStorageBuffersDynamic| 0^9^ |4 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindSampledImages        | 0^9^ |500000 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindStorageImages        | 0^9^ |500000 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindInputAttachments     | 0^9^ |4 ^9^ | min
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
ifdef::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]
| pname:maxInlineUniformBlockSize                               | - | 256   | min
| pname:maxPerStageDescriptorInlineUniformBlocks                | - | 4     | min
| pname:maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks | - | 4     | min
| pname:maxDescriptorSetInlineUniformBlocks                     | - | 4     | min
| pname:maxDescriptorSetUpdateAfterBindInlineUniformBlocks      | - | 4     | min
endif::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]
ifdef::VK_VERSION_1_3[]
| pname:maxInlineUniformTotalSize                               | - | 256   | min
endif::VK_VERSION_1_3[]
ifdef::VK_EXT_vertex_attribute_divisor,VK_KHR_vertex_attribute_divisor[]
| pname:maxVertexAttribDivisor               | - | 2^16^-1   | min
endif::VK_EXT_vertex_attribute_divisor,VK_KHR_vertex_attribute_divisor[]
ifdef::VK_NV_mesh_shader[]
| slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxDrawMeshTasksCount                | - | 2^16^-1   | min
| slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxTaskWorkGroupInvocations          | - | 32        | min
| slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxTaskWorkGroupSize                 | - | (32,1,1)  | min
| slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxTaskTotalMemorySize               | - | 16384     | min
| slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxTaskOutputCount                   | - | 2^16^-1   | min
| slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshWorkGroupInvocations          | - | 32        | min
| slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshWorkGroupSize                 | - | (32,1,1)  | min
| slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshTotalMemorySize               | - | 16384     | min
| slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshOutputVertices                | - | 256       | min
| slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshOutputPrimitives              | - | 256       | min
| slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshMultiviewViewCount            | - | 1         | min
| slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:meshOutputPerVertexGranularity       | - | -         | implementation-dependent
| slink:VkPhysicalDeviceMeshShaderPropertiesNV::pname:meshOutputPerPrimitiveGranularity    | - | -         | implementation-dependent
endif::VK_NV_mesh_shader[]
ifdef::VK_EXT_mesh_shader[]
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskWorkGroupTotalCount                 | - | 2^22      | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskWorkGroupCount                      | - | (65535,65535,65535) | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskWorkGroupInvocations                | - | 128       | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskWorkGroupSize                       | - | (128,128,128) | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskPayloadSize                         | - | 16384     | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskSharedMemorySize                    | - | 32768     | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxTaskPayloadAndSharedMemorySize          | - | 32768     | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupTotalCount                 | - | 2^22      | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupCount                      | - | (65535,65535,65535) | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupInvocations                | - | 128       | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshWorkGroupSize                       | - | (128,128,128) | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshSharedMemorySize                    | - | 28672     | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshPayloadAndSharedMemorySize          | - | 28672     | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshOutputMemorySize                    | - | 32768     | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshPayloadAndOutputMemorySize          | - | 48128     | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshOutputComponents                    | - | 128       | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshOutputVertices                      | - | 256       | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshOutputPrimitives                    | - | 256       | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshOutputLayers                        | - | 8         | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxMeshMultiviewViewCount                  | - | 1         | min
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:meshOutputPerVertexGranularity             | 0 | 32        | max
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:meshOutputPerPrimitiveGranularity          | 0 | 32        | max
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxPreferredTaskWorkGroupInvocations       | - | -         | implementation-dependent
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:maxPreferredMeshWorkGroupInvocations       | - | -         | implementation-dependent
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:prefersLocalInvocationVertexOutput         | - | -         | implementation-dependent
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:prefersLocalInvocationPrimitiveOutput      | - | -         | implementation-dependent
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:prefersCompactVertexOutput                 | - | -         | implementation-dependent
| slink:VkPhysicalDeviceMeshShaderPropertiesEXT::pname:prefersCompactPrimitiveOutput              | - | -         | implementation-dependent
endif::VK_EXT_mesh_shader[]
ifdef::VK_EXT_transform_feedback[]
| pname:maxTransformFeedbackStreams                         | - | 1         | min
| pname:maxTransformFeedbackBuffers                         | - | 1         | min
| pname:maxTransformFeedbackBufferSize                      | - | 2^27^     | min
| pname:maxTransformFeedbackStreamDataSize                  | - | 512       | min
| pname:maxTransformFeedbackBufferDataSize                  | - | 512       | min
| pname:maxTransformFeedbackBufferDataStride                | - | 512       | min
| pname:transformFeedbackQueries                            | - | false     | implementation-dependent
| pname:transformFeedbackStreamsLinesTriangles              | - | false     | implementation-dependent
| pname:transformFeedbackRasterizationStreamSelect          | - | false     | implementation-dependent
| pname:transformFeedbackDraw                               | - | false     | implementation-dependent
endif::VK_EXT_transform_feedback[]
ifdef::VK_EXT_fragment_density_map[]
| pname:minFragmentDensityTexelSize          | - | (1,1)       | min
| pname:maxFragmentDensityTexelSize          | - | (1,1)       | min
| pname:fragmentDensityInvocations           | - |  -          | implementation-dependent
ifdef::VK_EXT_fragment_density_map2[]
| pname:subsampledLoads                           | true  | false | implementation-dependent
| pname:subsampledCoarseReconstructionEarlyAccess | false | false | implementation-dependent
| pname:maxSubsampledArrayLayers                  | 2     | 2     | min
| pname:maxDescriptorSetSubsampledSamplers        | 1     | 1     | min
endif::VK_EXT_fragment_density_map2[]
ifdef::VK_QCOM_fragment_density_map_offset[]
| pname:fragmentDensityOffsetGranularity     | - | (1024,1024) | max
endif::VK_QCOM_fragment_density_map_offset[]
endif::VK_EXT_fragment_density_map[]
ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_ray_tracing[]
| slink:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupHandleSize | - | 16      | min
| slink:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxRecursionDepth     | - | 31      | min
endif::VK_NV_ray_tracing[]
ifdef::VK_KHR_ray_tracing_pipeline[]
| slink:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:shaderGroupHandleSize | - | 32      | exact
| slink:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:maxRayRecursionDepth  | - | 1       | min
endif::VK_KHR_ray_tracing_pipeline[]
| pname:maxShaderGroupStride                     | - | 4096    | min
| pname:shaderGroupBaseAlignment                 | - | 64      | max
| pname:maxGeometryCount                         | - | 2^24^-1 | min
| pname:maxInstanceCount                         | - | 2^24^-1 | min
ifdef::VK_NV_ray_tracing[]
| pname:maxTriangleCount                         | - | 2^29^-1 | min
endif::VK_NV_ray_tracing[]
ifdef::VK_KHR_acceleration_structure[]
| pname:maxPrimitiveCount                        | - | 2^29^-1 | min
| pname:maxPerStageDescriptorAccelerationStructures                 | - | 16         | min
| pname:maxPerStageDescriptorUpdateAfterBindAccelerationStructures  | - | 500000 ^9^ | min
endif::VK_KHR_acceleration_structure[]
| pname:maxDescriptorSetAccelerationStructures                      | - | 16         | min
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
ifdef::VK_KHR_acceleration_structure[]
| pname:maxDescriptorSetUpdateAfterBindAccelerationStructures       | - | 500000 ^9^ | min
| pname:minAccelerationStructureScratchOffsetAlignment              | - | 256        | max
endif::VK_KHR_acceleration_structure[]
ifdef::VK_KHR_ray_tracing_pipeline[]
| pname:shaderGroupHandleCaptureReplaySize              | - | 64  | max
| pname:maxRayDispatchInvocationCount                   | - | 2^30^ | min
| pname:shaderGroupHandleAlignment                      | - | 32  | max
| pname:maxRayHitAttributeSize                          | - | 32  | min
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]
| pname:maxTimelineSemaphoreValueDifference      | - | 2^31^-1 | min
endif::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]
ifdef::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
| pname:lineSubPixelPrecisionBits                | - | 4    | min
endif::VK_KHR_line_rasterization,VK_EXT_line_rasterization[]
ifdef::VK_NV_device_generated_commands[]
| pname:maxGraphicsShaderGroupCount               | - | 2^12^   | min
| pname:maxIndirectSequenceCount                  | - | 2^20^   | min
| pname:maxIndirectCommandsTokenCount             | - | 16     | min
| pname:maxIndirectCommandsStreamCount            | - | 16     | min
| pname:maxIndirectCommandsTokenOffset            | - | 2047   | min
| pname:maxIndirectCommandsStreamStride           | - | 2048   | min
| pname:minSequencesCountBufferOffsetAlignment    | - | 256    | max
| pname:minSequencesIndexBufferOffsetAlignment    | - | 256    | max
| pname:minIndirectCommandsBufferOffsetAlignment  | - | 256    | max
endif::VK_NV_device_generated_commands[]
ifdef::VK_EXT_custom_border_color[]
| pname:maxCustomBorderColorSamplers              | - | 32    | min
endif::VK_EXT_custom_border_color[]
ifdef::VK_EXT_robustness2[]
| pname:robustStorageBufferAccessSizeAlignment   | - | 4    | max
| pname:robustUniformBufferAccessSizeAlignment   | - | 256  | max
endif::VK_EXT_robustness2[]
ifdef::VK_KHR_fragment_shading_rate[]
| pname:minFragmentShadingRateAttachmentTexelSize           | (0,0) | (32,32) | max
| pname:maxFragmentShadingRateAttachmentTexelSize           | (0,0) | (8,8)   | min
| pname:maxFragmentShadingRateAttachmentTexelSizeAspectRatio |  0   |   1     | min
| pname:primitiveFragmentShadingRateWithMultipleViewports   | false | false   | implementation-dependent
| pname:layeredShadingRateAttachments                       | false | false   | implementation-dependent
| pname:fragmentShadingRateNonTrivialCombinerOps            |   -   | false   | implementation-dependent
| pname:maxFragmentSize                                     |   -   | (2,2)   | min
| pname:maxFragmentSizeAspectRatio                          |   -   | 2       | min
| pname:maxFragmentShadingRateCoverageSamples               |   -   | 16      | min
| pname:maxFragmentShadingRateRasterizationSamples          |   -   | ename:VK_SAMPLE_COUNT_4_BIT      | min
| pname:fragmentShadingRateWithShaderDepthStencilWrites     |   -   | false   | implementation-dependent
| pname:fragmentShadingRateWithSampleMask                   |   -   | false   | implementation-dependent
| pname:fragmentShadingRateWithShaderSampleMask             |   -   | false   | implementation-dependent
| pname:fragmentShadingRateWithConservativeRasterization    |   -   | false   | implementation-dependent
| pname:fragmentShadingRateWithFragmentShaderInterlock      |   -   | false   | implementation-dependent
| pname:fragmentShadingRateWithCustomSampleLocations        |   -   | false   | implementation-dependent
| pname:fragmentShadingRateStrictMultiplyCombiner           |   -   | false   | implementation-dependent
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_NV_fragment_shading_rate_enums[]
| pname:maxFragmentShadingRateInvocationCount               | - | ename:VK_SAMPLE_COUNT_4_BIT | min
endif::VK_NV_fragment_shading_rate_enums[]
ifdef::VK_EXT_descriptor_buffer[]
| pname:combinedImageSamplerDescriptorSingleArray          | - | false | implementation-dependent
| pname:bufferlessPushDescriptors            | - | false | implementation-dependent
| pname:allowSamplerImageViewPostSubmitCreation     | - | false | implementation-dependent
| pname:descriptorBufferOffsetAlignment             | - | 256 | max
| pname:maxDescriptorBufferBindings                 | - | 3 | min
| pname:maxResourceDescriptorBufferBindings         | - | 1 | min
| pname:maxSamplerDescriptorBufferBindings          | - | 1 | min
| pname:maxEmbeddedImmutableSamplerBindings         | - | 1 | min
| pname:maxEmbeddedImmutableSamplers                | - | 2032 | min
| pname:bufferCaptureReplayDescriptorDataSize       | - | 64 | max
| pname:imageCaptureReplayDescriptorDataSize        | - | 64 | max
| pname:imageViewCaptureReplayDescriptorDataSize    | - | 64 | max
| pname:samplerCaptureReplayDescriptorDataSize      | - | 64 | max
| pname:accelerationStructureCaptureReplayDescriptorDataSize | - | 64 | max
| pname:samplerDescriptorSize                       | - | 256 | max
| pname:combinedImageSamplerDescriptorSize          | - | 256 | max
| pname:sampledImageDescriptorSize                  | - | 256 | max
| pname:storageImageDescriptorSize                  | - | 256 | max
| pname:uniformTexelBufferDescriptorSize            | - | 256 | max
| pname:robustUniformTexelBufferDescriptorSize      | - | 256 | max
| pname:storageTexelBufferDescriptorSize            | - | 256 | max
| pname:robustStorageTexelBufferDescriptorSize      | - | 256 | max
| pname:uniformBufferDescriptorSize                 | - | 256 | max
| pname:robustUniformBufferDescriptorSize           | - | 256 | max
| pname:storageBufferDescriptorSize                 | - | 256 | max
| pname:robustStorageBufferDescriptorSize           | - | 256 | max
| pname:inputAttachmentDescriptorSize               | - | 256 | max
| pname:accelerationStructureDescriptorSize         | - | 256 | max
| pname:maxSamplerDescriptorBufferRange             | - | [eq]#2^11^ {times} pname:samplerDescriptorSize# | min
| pname:maxResourceDescriptorBufferRange            | - | [eq]#(2^20^ - 2^15^) {times} ptext:maxResourceDescriptorSize# ^12^ | min
| pname:samplerDescriptorBufferAddressSpaceSize     | - | 2^27^ | min
| pname:resourceDescriptorBufferAddressSpaceSize    | - | 2^27^ | min
| pname:descriptorBufferAddressSpaceSize            | - | 2^27^ | min
ifdef::VK_EXT_fragment_density_map[]
| pname:combinedImageSamplerDensityMapDescriptorSize          | - | 256 | max
endif::VK_EXT_fragment_density_map[]
endif::VK_EXT_descriptor_buffer[]
ifdef::VK_HUAWEI_subpass_shading[]
| pname:maxSubpassShadingWorkgroupSizeAspectRatio |  0   |   1     | min
endif::VK_HUAWEI_subpass_shading[]
ifdef::VK_EXT_multi_draw[]
| pname:maxMultiDrawCount               | - | 1024 | min
endif::VK_EXT_multi_draw[]
ifdef::VK_EXT_nested_command_buffer[]
| pname:maxCommandBufferNestingLevel                        | - | 1 | min
endif::VK_EXT_nested_command_buffer[]
ifdef::VKSC_VERSION_1_0[]
| pname:deviceNoDynamicHostAllocations                      | - | -      | implementation-dependent
| pname:deviceDestroyFreesMemory                            | - | -      | implementation-dependent
| pname:commandPoolMultipleCommandBuffersRecording          | - | -      | implementation-dependent
| pname:commandPoolResetCommandBuffer                       | - | -      | implementation-dependent
| pname:commandBufferSimultaneousUse                        | - | -      | implementation-dependent
| pname:secondaryCommandBufferNullOrImagelessFramebuffer    | - | -      | implementation-dependent
| pname:recycleDescriptorSetMemory                          | - | -      | implementation-dependent
| pname:recyclePipelineMemory                               | - | -      | implementation-dependent
| pname:maxRenderPassSubpasses                              | - | 1      | min
| pname:maxRenderPassDependencies                           | - | 18     | min
| pname:maxSubpassInputAttachments                          | - | 0      | min
| pname:maxSubpassPreserveAttachments                       | - | 0      | min
| pname:maxFramebufferAttachments                           | - | 9 ^11^ | min
| pname:maxDescriptorSetLayoutBindings                      | - | 64     | min
| pname:maxQueryFaultCount                                  | - | 16     | min
| pname:maxCallbackFaultCount                               | - | 1      | min
| pname:maxCommandPoolCommandBuffers                        | - | 256    | min
| pname:maxCommandBufferSize                                | - | 2^20^  | min
endif::VKSC_VERSION_1_0[]
ifdef::VK_EXT_graphics_pipeline_library[]
| pname:graphicsPipelineLibraryFastLinking                  | - | false | implementation-dependent
| pname:graphicsPipelineLibraryIndependentInterpolationDecoration | - | false | implementation-dependent
endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_KHR_fragment_shader_barycentric[]
| pname:triStripVertexOrderIndependentOfProvokingVertex     |   -   | false   | implementation-dependent
endif::VK_KHR_fragment_shader_barycentric[]
ifdef::VK_QCOM_image_processing[]
| pname:maxWeightFilterPhases           | - | 1024    | min
| pname:maxWeightFilterDimension        | - | (64,64) | min
| pname:maxBlockMatchRegion             | - | (64,64) | min
| pname:maxBoxFilterBlockSize           | - | (64,64) | min
endif::VK_QCOM_image_processing[]
ifdef::VK_EXT_extended_dynamic_state3[]
| pname:dynamicPrimitiveTopologyUnrestricted   | - | -   | implementation-dependent
endif::VK_EXT_extended_dynamic_state3[]
ifdef::VK_EXT_opacity_micromap[]
| pname:maxOpacity2StateSubdivisionLevel | - | 3      | min
| pname:maxOpacity4StateSubdivisionLevel | - | 3      | min
endif::VK_EXT_opacity_micromap[]
ifdef::VK_NV_memory_decompression[]
| pname:maxDecompressionIndirectCount    | 1 | 2^16^-1 | min
endif::VK_NV_memory_decompression[]
ifdef::VK_HUAWEI_cluster_culling_shader[]
| pname:maxWorkGroupCount | - | (65536,1,1) | min
| pname:maxWorkGroupSize  | - | (32,1,1) | min
| pname:maxOutputClusterCount | - | 1024 | min
| pname:indirectBufferOffsetAlignment | - | - | implementation-dependent
endif::VK_HUAWEI_cluster_culling_shader[]
ifdef::VK_AMDX_shader_enqueue[]
| pname:maxExecutionGraphDepth                              |   -   | 32      | min
| pname:maxExecutionGraphShaderOutputNodes                  |   -   | 256     | min
| pname:maxExecutionGraphShaderPayloadSize                  |   -   | 32768   | min
| pname:maxExecutionGraphShaderPayloadCount                 |   -   | 256     | min
| pname:executionGraphDispatchAddressAlignment              |   -   | 4       | max
endif::VK_AMDX_shader_enqueue[]
ifdef::VK_NV_extended_sparse_address_space[]
| pname:extendedSparseAddressSpaceSize                      |   0   | pname:sparseAddressSpaceSize | min
endif::VK_NV_extended_sparse_address_space[]
ifdef::VK_ARM_render_pass_striped[]
| pname:renderPassStripeGranularity               | - | (64,64) | max
| pname:maxRenderPassStripes                      | - | 32 | min
endif::VK_ARM_render_pass_striped[]
ifdef::VK_EXT_map_memory_placed[]
| pname:minPlacedMemoryMapAlignment     | - | 65536 | max
endif::VK_EXT_map_memory_placed[]
ifdef::VK_MESA_image_alignment_control[]
| pname:supportedImageAlignmentMask | - | 1 | min
endif::VK_MESA_image_alignment_control[]
|====

1::
    The *Limit Type* column specifies the limit is either the minimum limit
    all implementations must: support, the maximum limit all implementations
    must: support, or the exact value all implementations must: support.
    For bitmasks a minimum limit is the least bits all implementations must:
    set, but they may: have additional bits set beyond this minimum.

2::
    The pname:maxPerStageResources must: be at least the smallest of the
    following:
+
  * the sum of the pname:maxPerStageDescriptorUniformBuffers,
    pname:maxPerStageDescriptorStorageBuffers,
    pname:maxPerStageDescriptorSampledImages,
    pname:maxPerStageDescriptorStorageImages,
    pname:maxPerStageDescriptorInputAttachments, pname:maxColorAttachments
    limits, or
  * 128.
+
It may: not be possible to reach this limit in every stage.

3::
    See <<limits-maxViewportDimensions, pname:maxViewportDimensions>> for
    the required: relationship to other limits.

4::
    See <<limits-viewportboundsrange, pname:viewportBoundsRange>> for the
    required: relationship to other limits.

5::
    The values pname:minInterpolationOffset and pname:maxInterpolationOffset
    describe the closed interval of supported interpolation offsets:
    [pname:minInterpolationOffset, pname:maxInterpolationOffset].
    The ULP is determined by pname:subPixelInterpolationOffsetBits.
    If pname:subPixelInterpolationOffsetBits is 4, this provides increments
    of (1/2^4^) = 0.0625, and thus the range of supported interpolation
    offsets would be [eq]#[-0.5, 0.4375]#.

6::
    The point size ULP is determined by pname:pointSizeGranularity.
    If the pname:pointSizeGranularity is 0.125, the range of supported point
    sizes must: be at least [1.0, 63.875].

7::
    The line width ULP is determined by pname:lineWidthGranularity.
    If the pname:lineWidthGranularity is 0.0625, the range of supported line
    widths must: be at least [1.0, 7.9375].

8::
    The minimum ptext:maxDescriptorSet* limit is _n_ times the corresponding
    _specification_ minimum ptext:maxPerStageDescriptor* limit, where _n_ is
    the number of shader stages supported by the slink:VkPhysicalDevice.
    If all shader stages are supported, _n_ = 6 (vertex, tessellation
    control, tessellation evaluation, geometry, fragment, compute).

ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
9::
    The ptext:UpdateAfterBind descriptor limits must: each be greater than
    or equal to the corresponding ptext:non-UpdateAfterBind limit.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]

ifdef::VK_KHR_portability_subset[]
10::
     If the `apiext:VK_KHR_portability_subset` extension is enabled, the
     required minimum value of pname:maxVertexInputBindings is code:8.
endif::VK_KHR_portability_subset[]

ifdef::VKSC_VERSION_1_0[]
11:: ptext:maxFramebufferAttachments must: be greater than or equal to two
     times pname:maxColorAttachments (for color and resolve attachments)
     plus one (for the depth/stencil attachment), or else must: be equal to
     2^32^-1.
endif::VKSC_VERSION_1_0[]

ifdef::VK_EXT_descriptor_buffer[]
12::
     ptext:maxResourceDescriptorSize is defined as the maximum value of
     pname:storageImageDescriptorSize, pname:sampledImageDescriptorSize,
     pname:robustUniformTexelBufferDescriptorSize,
     pname:robustStorageTexelBufferDescriptorSize,
     pname:robustUniformBufferDescriptorSize,
     pname:robustStorageBufferDescriptorSize,
     pname:inputAttachmentDescriptorSize, and
     pname:accelerationStructureDescriptorSize.
endif::VK_EXT_descriptor_buffer[]


ifdef::VK_EXT_sample_locations[]
[[limits-multisample]]
== Additional Multisampling Capabilities

[open,refpage='vkGetPhysicalDeviceMultisamplePropertiesEXT',desc='Report sample count specific multisampling capabilities of a physical device',type='protos']
--
To query additional multisampling capabilities which may: be supported for a
specific sample count, beyond the minimum capabilities described for
<<limits, Limits>> above, call:

include::{generated}/api/protos/vkGetPhysicalDeviceMultisamplePropertiesEXT.adoc[]

  * pname:physicalDevice is the physical device from which to query the
    additional multisampling capabilities.
  * pname:samples is a elink:VkSampleCountFlagBits value specifying the
    sample count to query capabilities for.
  * pname:pMultisampleProperties is a pointer to a
    slink:VkMultisamplePropertiesEXT structure in which information about
    additional multisampling capabilities specific to the sample count is
    returned.

include::{generated}/validity/protos/vkGetPhysicalDeviceMultisamplePropertiesEXT.adoc[]
--

[open,refpage='VkMultisamplePropertiesEXT',desc='Structure returning information about sample count specific additional multisampling capabilities',type='structs']
--
The sname:VkMultisamplePropertiesEXT structure is defined as

include::{generated}/api/structs/VkMultisamplePropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:maxSampleLocationGridSize is the maximum size of the pixel grid in
    which sample locations can: vary.

include::{generated}/validity/structs/VkMultisamplePropertiesEXT.adoc[]
--

If the sample count for which additional multisampling capabilities are
requested using fname:vkGetPhysicalDeviceMultisamplePropertiesEXT is set in
<<limits-sampleLocationSampleCounts, pname:sampleLocationSampleCounts>> the
pname:width and pname:height members of
sname:VkMultisamplePropertiesEXT::pname:maxSampleLocationGridSize must: be
greater than or equal to the corresponding members of
<<limits-maxSampleLocationGridSize, pname:maxSampleLocationGridSize>>,
respectively, otherwise both members must: be `0`.

endif::VK_EXT_sample_locations[]

// If you are adding a new features structure, it must be placed at the end
// of the previous section (immediately before <<limits-multisample>>).


ifdef::VK_VERSION_1_3[]
[[profile-limits]]
== Profile Limits


[[profile-limits-roadmap-2022]]
=== Roadmap 2022

Implementations that claim support for the <<roadmap-2022, Roadmap 2022>>
profile must: satisfy the following additional limit requirements:

[width="100%",cols="<35,<14,<11",options="header"]
|====
| Limit                                    | Supported Limit  | Limit Type^1^
| pname:maxImageDimension1D                   | 8192          | min
| pname:maxImageDimension2D                   | 8192          | min
| pname:maxImageDimensionCube                 | 8192          | min
| pname:maxImageArrayLayers                   | 2048          | min
| pname:maxUniformBufferRange                 | 65536         | min
| pname:bufferImageGranularity                | 4096          | max
| pname:maxPerStageDescriptorSamplers         | 64            | min
| pname:maxPerStageDescriptorUniformBuffers   | 15            | min
| pname:maxPerStageDescriptorStorageBuffers   | 30            | min
| pname:maxPerStageDescriptorSampledImages    | 200           | min
| pname:maxPerStageDescriptorStorageImages    | 16            | min
| pname:maxPerStageResources                  | 200           | min
| pname:maxDescriptorSetSamplers              | 576           | min
| pname:maxDescriptorSetUniformBuffers        | 90            | min
| pname:maxDescriptorSetStorageBuffers        | 96            | min
| pname:maxDescriptorSetSampledImages         | 1800          | min
| pname:maxDescriptorSetStorageImages         | 144           | min
| pname:maxFragmentCombinedOutputResources    | 16            | min
| pname:maxComputeWorkGroupInvocations        | 256           | min
| pname:maxComputeWorkGroupSize               | (256,256,64)  | min
| pname:subTexelPrecisionBits                 | 8             | min
| pname:mipmapPrecisionBits                   | 6             | min
| pname:maxSamplerLodBias                     | 14            | min
| pname:pointSizeGranularity                  | 0.125         | max
| pname:lineWidthGranularity                  | 0.5           | max
| pname:standardSampleLocations               | ename:VK_TRUE | Boolean
| pname:maxColorAttachments                   | 7             | min
| pname:subgroupSize                          | 4             | min
| pname:subgroupSupportedStages               | ename:VK_SHADER_STAGE_COMPUTE_BIT +
                                                ename:VK_SHADER_STAGE_FRAGMENT_BIT
                                                              | bitfield
| pname:subgroupSupportedOperations           | ename:VK_SUBGROUP_FEATURE_BASIC_BIT +
                                                ename:VK_SUBGROUP_FEATURE_VOTE_BIT +
                                                ename:VK_SUBGROUP_FEATURE_ARITHMETIC_BIT +
                                                ename:VK_SUBGROUP_FEATURE_BALLOT_BIT +
                                                ename:VK_SUBGROUP_FEATURE_SHUFFLE_BIT +
                                                ename:VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT +
                                                ename:VK_SUBGROUP_FEATURE_QUAD_BIT
                                                              | bitfield
| pname:shaderSignedZeroInfNanPreserveFloat16 | ename:VK_TRUE | Boolean
| pname:shaderSignedZeroInfNanPreserveFloat32 | ename:VK_TRUE | Boolean
| pname:maxSubgroupSize                       | 4             | min
| pname:maxPerStageDescriptorUpdateAfterBindInputAttachments | 7    | min
|====


[[profile-limits-roadmap-2024]]
=== Roadmap 2024

Implementations that claim support for the <<roadmap-2024, Roadmap 2024>>
profile must: satisfy the following additional limit requirements:

[width="100%",cols="<35,<14,<11",options="header"]
|====
| Limit                                                         | Supported Limit  | Limit Type^1^
| pname:shaderRoundingModeRTEFloat16                            | ename:VK_TRUE | Boolean
| pname:shaderRoundingModeRTEFloat32                            | ename:VK_TRUE | Boolean
| pname:timestampComputeAndGraphics                             | ename:VK_TRUE | Boolean
| pname:maxColorAttachments                                     | 8             | min
| pname:maxBoundDescriptorSets                                  | 7             | min
|====
endif::VK_VERSION_1_3[]
