// Copyright 2014-2026 The Khronos Group Inc.
// Copyright (c) 2018-2020 NVIDIA Corporation
// SPDX-License-Identifier: CC-BY-4.0

[[debugging]]
= Debugging

To aid developers in tracking down errors in the application's use of
Vulkan, particularly in combination with an external debugger or profiler,
_debugging extensions_ may be available.

[open,refpage='VkObjectType',desc='Specify an enumeration to track object handle types',type='enums']
--
The elink:VkObjectType enumeration defines values, each of which corresponds
to a specific Vulkan handle type.
These values can: be used to associate debug information with a particular
type of object through one or more extensions.

include::{generated}/api/enums/VkObjectType.adoc[]

[[debugging-object-types]]
.`VkObjectType` and Vulkan Handle Relationship
[width="80%",cols="<35,<23",options="header"]
|====
| elink:VkObjectType                         | Vulkan Handle Type
| ename:VK_OBJECT_TYPE_UNKNOWN               | Unknown/Undefined Handle
| ename:VK_OBJECT_TYPE_INSTANCE              | slink:VkInstance
| ename:VK_OBJECT_TYPE_PHYSICAL_DEVICE       | slink:VkPhysicalDevice
| ename:VK_OBJECT_TYPE_DEVICE                | slink:VkDevice
| ename:VK_OBJECT_TYPE_QUEUE                 | slink:VkQueue
| ename:VK_OBJECT_TYPE_SEMAPHORE             | slink:VkSemaphore
| ename:VK_OBJECT_TYPE_COMMAND_BUFFER        | slink:VkCommandBuffer
| ename:VK_OBJECT_TYPE_FENCE                 | slink:VkFence
| ename:VK_OBJECT_TYPE_DEVICE_MEMORY         | slink:VkDeviceMemory
| ename:VK_OBJECT_TYPE_BUFFER                | slink:VkBuffer
| ename:VK_OBJECT_TYPE_IMAGE                 | slink:VkImage
| ename:VK_OBJECT_TYPE_EVENT                 | slink:VkEvent
| ename:VK_OBJECT_TYPE_QUERY_POOL            | slink:VkQueryPool
| ename:VK_OBJECT_TYPE_BUFFER_VIEW           | slink:VkBufferView
| ename:VK_OBJECT_TYPE_IMAGE_VIEW            | slink:VkImageView
ifndef::VKSC_VERSION_1_0[]
| ename:VK_OBJECT_TYPE_SHADER_MODULE         | slink:VkShaderModule
endif::VKSC_VERSION_1_0[]
| ename:VK_OBJECT_TYPE_PIPELINE_CACHE        | slink:VkPipelineCache
| ename:VK_OBJECT_TYPE_PIPELINE_LAYOUT       | slink:VkPipelineLayout
| ename:VK_OBJECT_TYPE_RENDER_PASS           | slink:VkRenderPass
| ename:VK_OBJECT_TYPE_PIPELINE              | slink:VkPipeline
| ename:VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT | slink:VkDescriptorSetLayout
| ename:VK_OBJECT_TYPE_SAMPLER               | slink:VkSampler
| ename:VK_OBJECT_TYPE_DESCRIPTOR_POOL       | slink:VkDescriptorPool
| ename:VK_OBJECT_TYPE_DESCRIPTOR_SET        | slink:VkDescriptorSet
| ename:VK_OBJECT_TYPE_FRAMEBUFFER           | slink:VkFramebuffer
| ename:VK_OBJECT_TYPE_COMMAND_POOL          | slink:VkCommandPool
ifdef::VK_COMPUTE_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
| ename:VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION | slink:VkSamplerYcbcrConversion
endif::VK_COMPUTE_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_COMPUTE_VERSION_1_1,VK_KHR_descriptor_update_template[]
ifndef::VKSC_VERSION_1_0[]
| ename:VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE | slink:VkDescriptorUpdateTemplate
endif::VKSC_VERSION_1_0[]
endif::VK_COMPUTE_VERSION_1_1,VK_KHR_descriptor_update_template[]
ifdef::VK_BASE_VERSION_1_3,VK_EXT_private_data[]
| ename:VK_OBJECT_TYPE_PRIVATE_DATA_SLOT | slink:VkPrivateDataSlot
endif::VK_BASE_VERSION_1_3,VK_EXT_private_data[]
ifdef::VK_KHR_surface[]
| ename:VK_OBJECT_TYPE_SURFACE_KHR           | slink:VkSurfaceKHR
endif::VK_KHR_surface[]
ifdef::VK_KHR_swapchain[]
| ename:VK_OBJECT_TYPE_SWAPCHAIN_KHR         | slink:VkSwapchainKHR
endif::VK_KHR_swapchain[]
ifdef::VK_KHR_display[]
| ename:VK_OBJECT_TYPE_DISPLAY_KHR           | slink:VkDisplayKHR
| ename:VK_OBJECT_TYPE_DISPLAY_MODE_KHR      | slink:VkDisplayModeKHR
endif::VK_KHR_display[]
ifdef::VK_EXT_debug_report[]
| ename:VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT | slink:VkDebugReportCallbackEXT
endif::VK_EXT_debug_report[]
ifdef::VK_KHR_video_queue[]
| ename:VK_OBJECT_TYPE_VIDEO_SESSION_KHR | slink:VkVideoSessionKHR
| ename:VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR | slink:VkVideoSessionParametersKHR
endif::VK_KHR_video_queue[]
ifdef::VK_EXT_debug_utils[]
| ename:VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT | slink:VkDebugUtilsMessengerEXT
endif::VK_EXT_debug_utils[]
ifdef::VK_KHR_acceleration_structure[]
| ename:VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR | slink:VkAccelerationStructureKHR
endif::VK_KHR_acceleration_structure[]
ifdef::VK_EXT_validation_cache[]
| ename:VK_OBJECT_TYPE_VALIDATION_CACHE_EXT | slink:VkValidationCacheEXT
endif::VK_EXT_validation_cache[]
ifdef::VK_NV_ray_tracing[]
| ename:VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV | slink:VkAccelerationStructureNV
endif::VK_NV_ray_tracing[]
ifdef::VK_INTEL_performance_query[]
| ename:VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL | slink:VkPerformanceConfigurationINTEL
endif::VK_INTEL_performance_query[]
ifdef::VK_KHR_deferred_host_operations[]
| ename:VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR | slink:VkDeferredOperationKHR
endif::VK_KHR_deferred_host_operations[]
ifdef::VK_NV_device_generated_commands[]
| ename:VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV | slink:VkIndirectCommandsLayoutNV
endif::VK_NV_device_generated_commands[]
ifdef::VK_EXT_device_generated_commands[]
| ename:VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT | slink:VkIndirectCommandsLayoutEXT
| ename:VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT | slink:VkIndirectExecutionSetEXT
endif::VK_EXT_device_generated_commands[]
ifdef::VK_FUCHSIA_buffer_collection[]
| ename:VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA | slink:VkBufferCollectionFUCHSIA
endif::VK_FUCHSIA_buffer_collection[]
ifdef::VK_EXT_opacity_micromap[]
| ename:VK_OBJECT_TYPE_MICROMAP_EXT | slink:VkMicromapEXT
endif::VK_EXT_opacity_micromap[]
ifdef::VK_NV_optical_flow[]
| ename:VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV | slink:VkOpticalFlowSessionNV
endif::VK_NV_optical_flow[]
ifdef::VK_EXT_shader_object[]
| ename:VK_OBJECT_TYPE_SHADER_EXT | slink:VkShaderEXT
endif::VK_EXT_shader_object[]
ifdef::VK_ARM_tensors[]
| ename:VK_OBJECT_TYPE_TENSOR_ARM | slink:VkTensorARM
| ename:VK_OBJECT_TYPE_TENSOR_VIEW_ARM | slink:VkTensorViewARM
endif::VK_ARM_tensors[]
ifdef::VK_ARM_data_graph[]
| ename:VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM | slink:VkDataGraphPipelineSessionARM
endif::VK_ARM_data_graph[]
|====
--

If this Specification was generated with any such extensions included, they
will be described in the remainder of this chapter.


ifdef::VK_EXT_debug_utils[]
[[debugging-debug-utils]]
== Debug Utilities

Vulkan provides flexible debugging utilities for debugging an application.

The <<debugging-object-debug-annotation,Object Debug Annotation>> section
describes how to associate either a name or binary data with a specific
Vulkan object.

The <<debugging-queue-labels,Queue Labels>> section describes how to
annotate and group the work submitted to a queue.

The <<debugging-command-buffer-labels,Command Buffer Labels>> section
describes how to associate logical elements of the scene with commands in a
slink:VkCommandBuffer.

The <<debugging-debug-messengers,Debug Messengers>> section describes how to
create debug messenger objects associated with an application supplied
callback to capture debug messages from a variety of Vulkan components.


[[debugging-object-debug-annotation]]
=== Object Debug Annotation

It can be useful for an application to provide its own content relative to a
specific Vulkan object.

The following commands allow application developers to associate
application-defined information with Vulkan objects.
These commands are device-level commands but they may: reference
instance-level objects (such as slink:VkInstance) and physical device-level
objects (such as slink:VkPhysicalDevice) with a few restrictions:

  * The data for the corresponding object may: still be available after the
    slink:VkDevice used in the corresponding API call to set it is
    destroyed, but access to this data is not guaranteed and should be
    avoided.
  * Subsequent calls to change the data of the same object across multiple
    sname:VkDevice objects, may: result in the data being changed to the
    most recent version for all sname:VkDevice objects and not just the
    sname:VkDevice used in the most recent API call.


[[debugging-object-naming]]
==== Object Naming

[open,refpage='vkSetDebugUtilsObjectNameEXT',desc='Give an application-defined name to an object',type='protos']
--
An object can be given an application-defined name by calling:

include::{generated}/api/protos/vkSetDebugUtilsObjectNameEXT.adoc[]

  * pname:device is the device that is associated with the named object
    passed in via pname:objectHandle.
  * pname:pNameInfo is a pointer to a slink:VkDebugUtilsObjectNameInfoEXT
    structure specifying parameters of the name to set on the object.

.Valid Usage
****
  * [[VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-02587]]
    pname:pNameInfo->objectType must: not be ename:VK_OBJECT_TYPE_UNKNOWN
  * [[VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-02588]]
    pname:pNameInfo->objectHandle must: not be dlink:VK_NULL_HANDLE
  * [[VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-07872]]
    If pname:pNameInfo->objectHandle is the valid handle of an
    instance-level object, the slink:VkDevice identified by pname:device
    must: be a descendent of the same slink:VkInstance as the object
    identified by pname:pNameInfo->objectHandle
  * [[VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-07873]]
    If pname:pNameInfo->objectHandle is the valid handle of a
    physical-device-level object, the slink:VkDevice identified by
    pname:device must: be a descendant of the same slink:VkPhysicalDevice as
    the object identified by pname:pNameInfo->objectHandle
  * [[VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-07874]]
    If pname:pNameInfo->objectHandle is the valid handle of a device-level
    object, that object must: be a descendent of the slink:VkDevice
    identified by pname:device
****

include::{generated}/validity/protos/vkSetDebugUtilsObjectNameEXT.adoc[]
--

[open,refpage='VkDebugUtilsObjectNameInfoEXT',desc='Specify parameters of a name to give to an object',type='structs']
--
The sname:VkDebugUtilsObjectNameInfoEXT structure is defined as:

include::{generated}/api/structs/VkDebugUtilsObjectNameInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:objectType is a elink:VkObjectType specifying the type of the
    object to be named.
  * pname:objectHandle is the object to be named.
  * pname:pObjectName is either `NULL` or a null-terminated UTF-8 string
    specifying the name to apply to pname:objectHandle.

Applications may: change the name associated with an object simply by
calling fname:vkSetDebugUtilsObjectNameEXT again with a new string.
If pname:pObjectName is either `NULL` or an empty string, then any
previously set name is removed.

ifdef::VK_EXT_graphics_pipeline_library[]
The <<features-graphicsPipelineLibrary, pname:graphicsPipelineLibrary>>
feature allows the specification of pipelines without the creation of
slink:VkShaderModule objects beforehand.
In order to continue to allow naming these shaders independently,
sname:VkDebugUtilsObjectNameInfoEXT can: be included in the pname:pNext
chain of slink:VkPipelineShaderStageCreateInfo, which associates a static
name with that particular shader.
endif::VK_EXT_graphics_pipeline_library[]

ifdef::VK_EXT_descriptor_heap[]
This structure can: be included in the pname:pNext chain of
slink:VkResourceDescriptorInfoEXT or slink:VkSamplerCreateInfo to label a
descriptor or embedded sampler.
This structure may: be ignored when included in the pname:pNext chain of
slink:VkSamplerCreateInfo when creating a sampler object.
The label must: remain valid while the descriptor is valid; it may: be
discarded if it becomes invalid.
endif::VK_EXT_descriptor_heap[]

.Valid Usage
****
  * [[VUID-VkDebugUtilsObjectNameInfoEXT-objectType-02589]]
    If pname:objectType is ename:VK_OBJECT_TYPE_UNKNOWN, pname:objectHandle
    must: not be dlink:VK_NULL_HANDLE
  * [[VUID-VkDebugUtilsObjectNameInfoEXT-objectType-02590]]
    If pname:objectType is not ename:VK_OBJECT_TYPE_UNKNOWN,
    pname:objectHandle must: be dlink:VK_NULL_HANDLE or a valid Vulkan
    handle of the type associated with pname:objectType as defined in the
    <<debugging-object-types, `VkObjectType` and Vulkan Handle
    Relationship>> table
****

include::{generated}/validity/structs/VkDebugUtilsObjectNameInfoEXT.adoc[]
--


[[debugging-object-data-association]]
==== Object Data Association

In addition to setting a name for an object, debugging and validation layers
may: have uses for additional binary data on a per-object basis that have no
other place in the Vulkan API.

For example, a sname:VkShaderModule could have additional debugging data
attached to it to aid in offline shader tracing.

Additional data can be attached to an object by calling
fname:vkSetDebugUtilsObjectTagEXT as defined below.

[open,refpage='vkSetDebugUtilsObjectTagEXT',desc='Attach arbitrary data to an object',type='protos']
--
include::{generated}/api/protos/vkSetDebugUtilsObjectTagEXT.adoc[]

  * pname:device is the device that created the object.
  * pname:pTagInfo is a pointer to a slink:VkDebugUtilsObjectTagInfoEXT
    structure specifying parameters of the tag to attach to the object.

.Valid Usage
****
  * [[VUID-vkSetDebugUtilsObjectTagEXT-pNameInfo-07875]]
    If pname:pNameInfo->objectHandle is the valid handle of an
    instance-level object, the slink:VkDevice identified by pname:device
    must: be a descendent of the same slink:VkInstance as the object
    identified by pname:pNameInfo->objectHandle
  * [[VUID-vkSetDebugUtilsObjectTagEXT-pNameInfo-07876]]
    If pname:pNameInfo->objectHandle is the valid handle of a
    physical-device-level object, the slink:VkDevice identified by
    pname:device must: be a descendant of the same slink:VkPhysicalDevice as
    the object identified by pname:pNameInfo->objectHandle
  * [[VUID-vkSetDebugUtilsObjectTagEXT-pNameInfo-07877]]
    If pname:pNameInfo->objectHandle is the valid handle of a device-level
    object, that object must: be a descendent of the slink:VkDevice
    identified by pname:device
****

include::{generated}/validity/protos/vkSetDebugUtilsObjectTagEXT.adoc[]
--

[open,refpage='VkDebugUtilsObjectTagInfoEXT',desc='Specify parameters of a tag to attach to an object',type='structs']
--
The sname:VkDebugUtilsObjectTagInfoEXT structure is defined as:

include::{generated}/api/structs/VkDebugUtilsObjectTagInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:objectType is a elink:VkObjectType specifying the type of the
    object to be named.
  * pname:objectHandle is the object to be tagged.
  * pname:tagName is a numerical identifier of the tag.
  * pname:tagSize is the number of bytes of data to attach to the object.
  * pname:pTag is a pointer to an array of pname:tagSize bytes containing
    the data to be associated with the object.

The pname:tagName parameter gives a name or identifier to the type of data
being tagged.
This can be used by debugging layers to easily filter for only data that can
be used by that implementation.

.Valid Usage
****
  * [[VUID-VkDebugUtilsObjectTagInfoEXT-objectType-01908]]
    pname:objectType must: not be ename:VK_OBJECT_TYPE_UNKNOWN
  * [[VUID-VkDebugUtilsObjectTagInfoEXT-objectHandle-01910]]
    pname:objectHandle must: be a valid Vulkan handle of the type associated
    with pname:objectType as defined in the <<debugging-object-types,
    `VkObjectType` and Vulkan Handle Relationship>> table
****

include::{generated}/validity/structs/VkDebugUtilsObjectTagInfoEXT.adoc[]
--


[[debugging-queue-labels]]
=== Queue Labels

All Vulkan work is submitted using queues.
It is possible for an application to use multiple queues, each containing
multiple command buffers, when performing work.
It can be useful to identify which queue, or even where in a queue,
something has occurred.

To begin identifying a region using a debug label inside a queue, you may
use the flink:vkQueueBeginDebugUtilsLabelEXT command.

Then, when the region of interest has passed, you may end the label region
using flink:vkQueueEndDebugUtilsLabelEXT.

Additionally, a single debug label may be inserted at any time using
flink:vkQueueInsertDebugUtilsLabelEXT.

[open,refpage='vkQueueBeginDebugUtilsLabelEXT',desc='Open a queue debug label region',type='protos']
--
A queue debug label region is opened by calling:

include::{generated}/api/protos/vkQueueBeginDebugUtilsLabelEXT.adoc[]

  * pname:queue is the queue in which to start a debug label region.
  * pname:pLabelInfo is a pointer to a slink:VkDebugUtilsLabelEXT structure
    specifying parameters of the label region to open.

include::{generated}/validity/protos/vkQueueBeginDebugUtilsLabelEXT.adoc[]
--

[open,refpage='VkDebugUtilsLabelEXT',desc='Specify parameters of a label region',type='structs']
--
The sname:VkDebugUtilsLabelEXT structure is defined as:

include::{generated}/api/structs/VkDebugUtilsLabelEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pLabelName is a pointer to a null-terminated UTF-8 string
    containing the name of the label.
  * pname:color is an optional RGBA color value that can be associated with
    the label.
    A particular implementation may: choose to ignore this color value.
    The values contain RGBA values in order, in the range 0.0 to 1.0.
    If all elements in pname:color are 0.0, then it is ignored.

include::{generated}/validity/structs/VkDebugUtilsLabelEXT.adoc[]
--

[open,refpage='vkQueueEndDebugUtilsLabelEXT',desc='Close a queue debug label region',type='protos']
--
A queue debug label region is closed by calling:

include::{generated}/api/protos/vkQueueEndDebugUtilsLabelEXT.adoc[]

  * pname:queue is the queue in which a debug label region should be closed.

The calls to flink:vkQueueBeginDebugUtilsLabelEXT and
flink:vkQueueEndDebugUtilsLabelEXT must: be matched and balanced.

.Valid Usage
****
  * [[VUID-vkQueueEndDebugUtilsLabelEXT-None-01911]]
    There must: be an outstanding fname:vkQueueBeginDebugUtilsLabelEXT
    command prior to the fname:vkQueueEndDebugUtilsLabelEXT on the queue
****

include::{generated}/validity/protos/vkQueueEndDebugUtilsLabelEXT.adoc[]
--

[open,refpage='vkQueueInsertDebugUtilsLabelEXT',desc='Insert a label into a queue',type='protos']
--
A single label can be inserted into a queue by calling:

include::{generated}/api/protos/vkQueueInsertDebugUtilsLabelEXT.adoc[]

  * pname:queue is the queue into which a debug label will be inserted.
  * pname:pLabelInfo is a pointer to a slink:VkDebugUtilsLabelEXT structure
    specifying parameters of the label to insert.

include::{generated}/validity/protos/vkQueueInsertDebugUtilsLabelEXT.adoc[]
--


[[debugging-command-buffer-labels]]
=== Command Buffer Labels

Typical Vulkan applications will submit many command buffers in each frame,
with each command buffer containing a large number of individual commands.
Being able to logically annotate regions of command buffers that belong
together as well as hierarchically subdivide the frame is important to a
developer's ability to navigate the commands viewed holistically.

To identify the beginning of a debug label region in a command buffer,
flink:vkCmdBeginDebugUtilsLabelEXT can: be used as defined below.

To indicate the end of a debug label region in a command buffer,
flink:vkCmdEndDebugUtilsLabelEXT can: be used.

To insert a single command buffer debug label inside of a command buffer,
flink:vkCmdInsertDebugUtilsLabelEXT can: be used as defined below.

[open,refpage='vkCmdBeginDebugUtilsLabelEXT',desc='Open a command buffer debug label region',type='protos']
--
A command buffer debug label region can be opened by calling:

include::{generated}/api/protos/vkCmdBeginDebugUtilsLabelEXT.adoc[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:pLabelInfo is a pointer to a slink:VkDebugUtilsLabelEXT structure
    specifying parameters of the label region to open.

include::{generated}/validity/protos/vkCmdBeginDebugUtilsLabelEXT.adoc[]
--

[open,refpage='vkCmdEndDebugUtilsLabelEXT',desc='Close a command buffer label region',type='protos']
--
A command buffer label region can be closed by calling:

include::{generated}/api/protos/vkCmdEndDebugUtilsLabelEXT.adoc[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.

An application may: open a debug label region in one command buffer and
close it in another, or otherwise split debug label regions across multiple
command buffers or multiple queue submissions.
When viewed from the linear series of submissions to a single queue, the
calls to flink:vkCmdBeginDebugUtilsLabelEXT and
flink:vkCmdEndDebugUtilsLabelEXT must: be matched and balanced.

There can: be problems reporting command buffer debug labels during the
recording process because command buffers may: be recorded out of sequence
with the resulting execution order.
Since the recording order may: be different, a solitary command buffer may:
have an inconsistent view of the debug label regions by itself.
Therefore, if an issue occurs during the recording of a command buffer, and
the environment requires returning debug labels, the implementation may:
return only those labels it is aware of.
This is true even if the implementation is aware of only the debug labels
within the command buffer being actively recorded.


.Valid Usage
****
  * [[VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-01912]]
    There must: be an outstanding fname:vkCmdBeginDebugUtilsLabelEXT command
    prior to the fname:vkCmdEndDebugUtilsLabelEXT on the queue that
    pname:commandBuffer is submitted to
  * [[VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-01913]]
    If pname:commandBuffer is a secondary command buffer, there must: be an
    outstanding fname:vkCmdBeginDebugUtilsLabelEXT command recorded to
    pname:commandBuffer that has not previously been ended by a call to
    fname:vkCmdEndDebugUtilsLabelEXT
****

include::{generated}/validity/protos/vkCmdEndDebugUtilsLabelEXT.adoc[]
--

[open,refpage='vkCmdInsertDebugUtilsLabelEXT',desc='Insert a label into a command buffer',type='protos']
--
A single debug label can be inserted into a command buffer by calling:

include::{generated}/api/protos/vkCmdInsertDebugUtilsLabelEXT.adoc[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:pLabelInfo is a pointer to a slink:VkDebugUtilsLabelEXT structure
    specifying parameters of the label to insert.

include::{generated}/validity/protos/vkCmdInsertDebugUtilsLabelEXT.adoc[]
--


[[debugging-debug-messengers]]
=== Debug Messengers

Vulkan allows an application to register multiple callbacks with any Vulkan
component wishing to report debug information.
Some callbacks may log the information to a file, others may cause a debug
break point or other application-defined behavior.
A primary producer of callback messages are the validation layers.
An application can: register callbacks even when no validation layers are
enabled, but they will only be called for the Vulkan loader and, if
implemented, other layer and driver events.

[open,refpage='VkDebugUtilsMessengerEXT',desc='Opaque handle to a debug messenger object',type='handles']
--
A sname:VkDebugUtilsMessengerEXT is a messenger object which handles passing
along debug messages to a provided debug callback.

include::{generated}/api/handles/VkDebugUtilsMessengerEXT.adoc[]

The debug messenger will provide detailed feedback on the application's use
of Vulkan when events of interest occur.
When an event of interest does occur, the debug messenger will submit a
debug message to the debug callback that was provided during its creation.
Additionally, the debug messenger is responsible with filtering out debug
messages that the callback is not interested in and will only provide
desired debug messages.
--

[open,refpage='vkCreateDebugUtilsMessengerEXT',desc='Create a debug messenger object',type='protos']
--
A debug messenger triggers a debug callback with a debug message when an
event of interest occurs.
To create a debug messenger which will trigger a debug callback, call:

include::{generated}/api/protos/vkCreateDebugUtilsMessengerEXT.adoc[]

  * pname:instance is the instance the messenger will be used with.
  * pname:pCreateInfo is a pointer to a
    slink:VkDebugUtilsMessengerCreateInfoEXT structure containing the
    callback pointer, as well as defining conditions under which this
    messenger will trigger the callback.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pMessenger is a pointer to a slink:VkDebugUtilsMessengerEXT handle
    in which the created object is returned.

include::{generated}/validity/protos/vkCreateDebugUtilsMessengerEXT.adoc[]

The application must: ensure that flink:vkCreateDebugUtilsMessengerEXT is
not executed in parallel with any Vulkan command that is also called with
pname:instance or child of pname:instance as the dispatchable argument.
--

[open,refpage='VkDebugUtilsMessengerCreateInfoEXT',desc='Structure specifying parameters of a newly created debug messenger',type='structs']
--
The definition of sname:VkDebugUtilsMessengerCreateInfoEXT is:

include::{generated}/api/structs/VkDebugUtilsMessengerCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is `0` and is reserved for future use.
  * pname:messageSeverity is a bitmask of
    elink:VkDebugUtilsMessageSeverityFlagBitsEXT specifying which severity
    of event(s) will cause this callback to be called.
  * pname:messageType is a bitmask of
    elink:VkDebugUtilsMessageTypeFlagBitsEXT specifying which type of
    event(s) will cause this callback to be called.
  * pname:pfnUserCallback is the application callback function to call.
  * pname:pUserData is NULL or an application-defined user data pointer to
    be passed to the callback.

For each sname:VkDebugUtilsMessengerEXT that is created the
sname:VkDebugUtilsMessengerCreateInfoEXT::pname:messageSeverity and
sname:VkDebugUtilsMessengerCreateInfoEXT::pname:messageType determine when
that sname:VkDebugUtilsMessengerCreateInfoEXT::pname:pfnUserCallback is
called.
The process to determine if the user's pname:pfnUserCallback is triggered
when an event occurs is as follows:

  . The implementation will perform a bitwise AND of the event's
    elink:VkDebugUtilsMessageSeverityFlagBitsEXT with the
    pname:messageSeverity provided during creation of the
    slink:VkDebugUtilsMessengerEXT object.
  .. If the value is 0, the message is skipped.
  . The implementation will perform bitwise AND of the event's
    elink:VkDebugUtilsMessageTypeFlagBitsEXT with the pname:messageType
    provided during the creation of the slink:VkDebugUtilsMessengerEXT
    object.
  .. If the value is 0, the message is skipped.
  . The callback will trigger a debug message for the current event

The callback will come directly from the component that detected the event,
unless some other layer intercepts the calls for its own purposes (filter
them in a different way, log to a system error log, etc.).

An application can: receive multiple callbacks if multiple
sname:VkDebugUtilsMessengerEXT objects are created.
A callback will always be executed in the same thread as the originating
Vulkan call.

A callback can: be called from multiple threads simultaneously (if the
application is making Vulkan calls from multiple threads).

include::{generated}/validity/structs/VkDebugUtilsMessengerCreateInfoEXT.adoc[]
--

[open,refpage='VkDebugUtilsMessengerCreateFlagsEXT',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkDebugUtilsMessengerCreateFlagsEXT.adoc[]

tname:VkDebugUtilsMessengerCreateFlagsEXT is a bitmask type for setting a
mask, but is currently reserved for future use.
--

[open,refpage='VkDebugUtilsMessageSeverityFlagBitsEXT',desc='Bitmask specifying which severities of events cause a debug messenger callback',type='enums']
--
Bits which can: be set in
slink:VkDebugUtilsMessengerCreateInfoEXT::pname:messageSeverity, specifying
event severities which cause a debug messenger to call the callback, are:

include::{generated}/api/enums/VkDebugUtilsMessageSeverityFlagBitsEXT.adoc[]

  * ename:VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT specifies the most
    verbose output indicating all diagnostic messages from the Vulkan
    loader, layers, and drivers should be captured.
  * ename:VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT specifies an
    informational message such as resource details that may be handy when
    debugging an application.
  * ename:VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT specifies use of
    Vulkan that may: expose an application bug.
    Such cases may not be immediately harmful, such as a fragment shader
    outputting to a location with no attachment.
    Other cases may: point to behavior that is almost certainly bad when
    unintended such as using an image whose memory has not been filled.
    In general if you see a warning but you know that the behavior is
    intended/desired, then simply ignore the warning.
  * ename:VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT specifies that the
    application has violated a valid usage condition of the specification.

[NOTE]
====
The values of elink:VkDebugUtilsMessageSeverityFlagBitsEXT are sorted based
on severity.
The higher the flag value, the more severe the message.
This allows for simple boolean operation comparisons when looking at
elink:VkDebugUtilsMessageSeverityFlagBitsEXT values.

For example:

[source,c++]
----
    if (messageSeverity >= VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) {
        // Do something for warnings and errors
    }
----

In addition, space has been left between the enums to allow for later
addition of new severities in between the existing values.
====
--

[open,refpage='VkDebugUtilsMessageSeverityFlagsEXT',desc='Bitmask of VkDebugUtilsMessageSeverityFlagBitsEXT',type='flags']
--
include::{generated}/api/flags/VkDebugUtilsMessageSeverityFlagsEXT.adoc[]

tname:VkDebugUtilsMessageSeverityFlagsEXT is a bitmask type for setting a
mask of zero or more elink:VkDebugUtilsMessageSeverityFlagBitsEXT.
--

[open,refpage='VkDebugUtilsMessageTypeFlagBitsEXT',desc='Bitmask specifying which types of events cause a debug messenger callback',type='enums']
--
Bits which can: be set in
slink:VkDebugUtilsMessengerCreateInfoEXT::pname:messageType, specifying
event types which cause a debug messenger to call the callback, are:

include::{generated}/api/enums/VkDebugUtilsMessageTypeFlagBitsEXT.adoc[]

  * ename:VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT specifies that some
    general event has occurred.
    This is typically a non-specification, non-performance event.
  * ename:VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT specifies that
    something has occurred during validation against the Vulkan
    specification that may indicate invalid behavior.
  * ename:VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT specifies a
    potentially non-optimal use of Vulkan, e.g. using
    flink:vkCmdClearColorImage when setting
    slink:VkAttachmentDescription::pname:loadOp to
    ename:VK_ATTACHMENT_LOAD_OP_CLEAR would have worked.
ifdef::VK_EXT_device_address_binding_report[]
  * ename:VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT
    specifies that the implementation has modified the set of GPU-visible
    virtual addresses associated with a Vulkan object.
endif::VK_EXT_device_address_binding_report[]
--

[open,refpage='VkDebugUtilsMessageTypeFlagsEXT',desc='Bitmask of VkDebugUtilsMessageTypeFlagBitsEXT',type='flags']
--
include::{generated}/api/flags/VkDebugUtilsMessageTypeFlagsEXT.adoc[]

tname:VkDebugUtilsMessageTypeFlagsEXT is a bitmask type for setting a mask
of zero or more elink:VkDebugUtilsMessageTypeFlagBitsEXT.
--

[open,refpage='PFN_vkDebugUtilsMessengerCallbackEXT',desc='Application-defined debug messenger callback function',type='funcpointers']
--
The prototype for the
slink:VkDebugUtilsMessengerCreateInfoEXT::pname:pfnUserCallback function
implemented by the application is:

include::{generated}/api/funcpointers/PFN_vkDebugUtilsMessengerCallbackEXT.adoc[]

  * pname:messageSeverity specifies the
    elink:VkDebugUtilsMessageSeverityFlagBitsEXT that triggered this
    callback.
  * pname:messageTypes is a bitmask of
    elink:VkDebugUtilsMessageTypeFlagBitsEXT specifying which type of
    event(s) triggered this callback.
  * pname:pCallbackData contains all the callback related data in the
    slink:VkDebugUtilsMessengerCallbackDataEXT structure.
  * pname:pUserData is the application-defined user data pointer, equal to
    the value of slink:VkDebugUtilsMessengerCreateInfoEXT::pname:pUserData
    specified when the slink:VkDebugUtilsMessengerEXT object was created.

The callback returns a basetype:VkBool32, which is interpreted in a
layer-specified manner.
The application should: always return ename:VK_FALSE.
The ename:VK_TRUE value is reserved for use in layer development.

.Valid Usage
****
  * [[VUID-PFN_vkDebugUtilsMessengerCallbackEXT-None-04769]]
    The callback must: not make calls to any Vulkan commands
****
--

[open,refpage='VkDebugUtilsMessengerCallbackDataEXT',desc='Structure specifying parameters returned to the callback',type='structs']
--
The definition of sname:VkDebugUtilsMessengerCallbackDataEXT is:

include::{generated}/api/structs/VkDebugUtilsMessengerCallbackDataEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is `0` and is reserved for future use.
  * pname:pMessageIdName is `NULL` or a null-terminated UTF-8 string that
    identifies the particular message ID that is associated with the
    provided message.
    If the message corresponds to a validation layer message, then this
    string will be the VUID.
  * pname:messageIdNumber is the ID number of the triggering message.
    If the message corresponds to a validation layer message, then this
    number is an internal hash of the VUID.
  * pname:pMessage is
ifdef::VK_EXT_device_address_binding_report[]
    `NULL` if pname:messageTypes is equal to
    ename:VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT, or
endif::VK_EXT_device_address_binding_report[]
    a null-terminated UTF-8 string detailing the trigger conditions.
    If the message corresponds to a validation layer message, then this will
    contain the main message with the specification text and link.
  * pname:queueLabelCount is a count of items contained in the
    pname:pQueueLabels array.
  * pname:pQueueLabels is `NULL` or a pointer to an array of
    slink:VkDebugUtilsLabelEXT active in the current sname:VkQueue at the
    time the callback was triggered.
    Refer to <<debugging-queue-labels,Queue Labels>> for more information.
  * pname:cmdBufLabelCount is a count of items contained in the
    pname:pCmdBufLabels array.
  * pname:pCmdBufLabels is `NULL` or a pointer to an array of
    slink:VkDebugUtilsLabelEXT active in the current sname:VkCommandBuffer
    at the time the callback was triggered.
    Refer to <<debugging-command-buffer-labels, Command Buffer Labels>> for
    more information.
  * pname:objectCount is a count of items contained in the pname:pObjects
    array.
  * pname:pObjects is a pointer to an array of
    slink:VkDebugUtilsObjectNameInfoEXT objects related to the detected
    issue.
    The array is roughly in order or importance, but the 0th element is
    always guaranteed to be the most important object for this message.

[NOTE]
====
This structure should only be considered valid during the lifetime of the
triggered callback.
====

Since adding queue and command buffer labels behaves like pushing and
popping onto a stack, the order of both pname:pQueueLabels and
pname:pCmdBufLabels is based on the order the labels were defined.
The result is that the first label in either pname:pQueueLabels or
pname:pCmdBufLabels will be the first defined (and therefore the oldest)
while the last label in each list will be the most recent.

[NOTE]
====
pname:pQueueLabels will only be non-`NULL` if one of the objects in
pname:pObjects can be related directly to a defined sname:VkQueue which has
had one or more labels associated with it.

Likewise, pname:pCmdBufLabels will only be non-`NULL` if one of the objects
in pname:pObjects can be related directly to a defined sname:VkCommandBuffer
which has had one or more labels associated with it.
Additionally, while command buffer labels allow for beginning and ending
across different command buffers, the debug messaging framework cannot:
guarantee that labels in pname:pCmdBufLables will contain those defined
outside of the associated command buffer.
This is partially due to the fact that the association of one command buffer
with another may not have been defined at the time the debug message is
triggered.
====

include::{generated}/validity/structs/VkDebugUtilsMessengerCallbackDataEXT.adoc[]
--

[open,refpage='VkDebugUtilsMessengerCallbackDataFlagsEXT',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkDebugUtilsMessengerCallbackDataFlagsEXT.adoc[]

tname:VkDebugUtilsMessengerCallbackDataFlagsEXT is a bitmask type for
setting a mask, but is currently reserved for future use.
--

ifdef::VK_EXT_device_address_binding_report[]
[open,refpage='VkDeviceAddressBindingCallbackDataEXT',desc='Structure specifying parameters returned to the callback',type='structs']
--
The definition of sname:VkDeviceAddressBindingCallbackDataEXT is:

include::{generated}/api/structs/VkDeviceAddressBindingCallbackDataEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkDeviceAddressBindingFlagBitsEXT
    specifying additional information about the binding event that caused
    the callback to be called.
  * pname:baseAddress is a GPU-accessible virtual address identifying the
    start of a region of the virtual address space associated with a Vulkan
    object, as identified by the pname:pObjects member of
    slink:VkDebugUtilsMessengerCallbackDataEXT.
  * pname:size is the size in bytes of a region of GPU-accessible virtual
    address space.
  * pname:bindingType is a elink:VkDeviceAddressBindingTypeEXT specifying
    the type of binding event that caused the callback to be called.

If the <<features-reportAddressBinding, pname:reportAddressBinding>> feature
is enabled and the implementation binds or unbinds a region of virtual
address space associated with a Vulkan object, the implementation must:
submit a debug message with the following properties:

  * pname:messageSeverity equal to
    ename:VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT
  * pname:messageTypes equal to
    ename:VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT
  * sname:VkDebugUtilsMessengerCallbackDataEXT::pname:pObjects must:
    identify the associated Vulkan object
  * sname:VkDeviceAddressBindingCallbackDataEXT must: be included in the
    pname:pNext chain of sname:VkDebugUtilsMessengerCallbackDataEXT

These debug messages must: be emitted both for GPU virtual address space
regions that are explicitly bound to a Vulkan object via the
sname:vkBind*Memory/sname:vkBind*Memory2 functions, and for those that are
implicitly generated via memory allocation or importing external memory.

An implementation may: report binding events associated with a Vulkan object
via sname:VkDebugUtilsMessengerEXT prior to the object becoming visible to
an application via other Vulkan commands.
For example, object creation functions may: report binding events that occur
during an objects creation.
In such cases, sname:VkDeviceAddressBindingCallbackDataEXT::pname:flags
must: include ename:VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT.

Object handles reported in this manner are not
<<fundamentals-validusage-handles, valid object handles>>, and must: not be
used as an input parameter to any Vulkan command.

Any valid object handle returned by an object creation function must: match
the handle specified via any previously reported binding events associated
with the object's creation.

include::{generated}/validity/structs/VkDeviceAddressBindingCallbackDataEXT.adoc[]
--

[open,refpage='VkDeviceAddressBindingFlagBitsEXT',desc='Bitmask specifying the additional information about a binding event',type='enums']
--
Bits which can: be set in
slink:VkDeviceAddressBindingCallbackDataEXT::pname:flags specifying
additional information about a binding event are:

include::{generated}/api/enums/VkDeviceAddressBindingFlagBitsEXT.adoc[]

  * ename:VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT specifies that
    slink:VkDeviceAddressBindingCallbackDataEXT describes a Vulkan object
    that has not been made visible to the application via a Vulkan command.
--

[open,refpage='VkDeviceAddressBindingFlagsEXT',desc='Bitmask of VkDeviceAddressBindingFlagBitsEXT',type='flags']
--
include::{generated}/api/flags/VkDeviceAddressBindingFlagsEXT.adoc[]

tlink:VkDeviceAddressBindingFlagsEXT is a bitmask type for setting a mask of
zero or more elink:VkDeviceAddressBindingFlagBitsEXT.
--

[open,refpage='VkDeviceAddressBindingTypeEXT',desc='Enum describing a change in device address bindings',type='enums']
--
The ename:VkDeviceAddressBindingTypeEXT enum is defined as:

include::{generated}/api/enums/VkDeviceAddressBindingTypeEXT.adoc[]

  * ename:VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT specifies that a new
    GPU-accessible virtual address range has been bound.
  * ename:VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT specifies that a
    GPU-accessible virtual address range has been unbound.

--
endif::VK_EXT_device_address_binding_report[]

[open,refpage='vkSubmitDebugUtilsMessageEXT',desc='Inject a message into a debug stream',type='protos']
--
To intentionally submit a debug message, call:

include::{generated}/api/protos/vkSubmitDebugUtilsMessageEXT.adoc[]

  * pname:instance is the debug stream's slink:VkInstance.
  * pname:messageSeverity is a elink:VkDebugUtilsMessageSeverityFlagBitsEXT
    value specifying the severity of this event/message.
  * pname:messageTypes is a bitmask of
    elink:VkDebugUtilsMessageTypeFlagBitsEXT specifying which type of
    event(s) to identify with this message.
  * pname:pCallbackData contains all the callback related data in the
    slink:VkDebugUtilsMessengerCallbackDataEXT structure.

The call will propagate through the layers and generate callback(s) as
indicated by the message's flags.
The parameters are passed on to the callback in addition to the
pname:pUserData value that was defined at the time the messenger was
registered.

.Valid Usage
****
  * [[VUID-vkSubmitDebugUtilsMessageEXT-objectType-02591]]
    The pname:objectType member of each element of
    pname:pCallbackData->pObjects must: not be ename:VK_OBJECT_TYPE_UNKNOWN
****

include::{generated}/validity/protos/vkSubmitDebugUtilsMessageEXT.adoc[]
--

[open,refpage='vkDestroyDebugUtilsMessengerEXT',desc='Destroy a debug messenger object',type='protos']
--
To destroy a sname:VkDebugUtilsMessengerEXT object, call:

include::{generated}/api/protos/vkDestroyDebugUtilsMessengerEXT.adoc[]

  * pname:instance is the instance where the callback was created.
  * pname:messenger is the slink:VkDebugUtilsMessengerEXT object to destroy.
    pname:messenger is an externally synchronized object and must: not be
    used on more than one thread at a time.
    This means that fname:vkDestroyDebugUtilsMessengerEXT must: not be
    called when a callback is active.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

ifndef::VKSC_VERSION_1_0[]
.Valid Usage
****
  * [[VUID-vkDestroyDebugUtilsMessengerEXT-messenger-01915]]
    If sname:VkAllocationCallbacks were provided when pname:messenger was
    created, a compatible set of callbacks must: be provided here
  * [[VUID-vkDestroyDebugUtilsMessengerEXT-messenger-01916]]
    If no sname:VkAllocationCallbacks were provided when pname:messenger was
    created, pname:pAllocator must: be `NULL`
****
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/protos/vkDestroyDebugUtilsMessengerEXT.adoc[]

The application must: ensure that flink:vkDestroyDebugUtilsMessengerEXT is
not executed in parallel with any Vulkan command that is also called with
pname:instance or child of pname:instance as the dispatchable argument.
--

endif::VK_EXT_debug_utils[]


ifdef::VK_EXT_debug_marker[]
[[debugging-debug-markers]]
== Debug Markers

Debug markers provide a flexible way for debugging and validation layers to
receive annotation and debug information.

The <<debugging-object-annotation,Object Annotation>> section describes how
to associate a name or binary data with a Vulkan object.

The <<debugging-command-buffer-markers,Command Buffer Markers>> section
describes how to associate logical elements of the scene with commands in
the command buffer.


[[debugging-object-annotation]]
=== Object Annotation

The commands in this section allow application developers to associate
application-defined information with Vulkan objects at will.

[open,refpage='vkDebugMarkerSetObjectNameEXT',desc='Give an application-defined name to an object',type='protos']
--
An object can be given an application-defined name by calling:

include::{generated}/api/protos/vkDebugMarkerSetObjectNameEXT.adoc[]

  * pname:device is the device that created the object.
  * pname:pNameInfo is a pointer to a slink:VkDebugMarkerObjectNameInfoEXT
    structure specifying the parameters of the name to set on the object.

include::{generated}/validity/protos/vkDebugMarkerSetObjectNameEXT.adoc[]
--

[open,refpage='VkDebugMarkerObjectNameInfoEXT',desc='Specify parameters of a name to give to an object',type='structs']
--
The sname:VkDebugMarkerObjectNameInfoEXT structure is defined as:

include::{generated}/api/structs/VkDebugMarkerObjectNameInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:objectType is a elink:VkDebugReportObjectTypeEXT specifying the
    type of the object to be named.
  * pname:object is the object to be named.
  * pname:pObjectName is a null-terminated UTF-8 string specifying the name
    to apply to pname:object.

Applications may: change the name associated with an object simply by
calling fname:vkDebugMarkerSetObjectNameEXT again with a new string.
To remove a previously set name, pname:pObjectName should: be an empty
string.

.Valid Usage
****
  * [[VUID-VkDebugMarkerObjectNameInfoEXT-objectType-01490]]
    pname:objectType must: not be
    ename:VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT
  * [[VUID-VkDebugMarkerObjectNameInfoEXT-object-01491]]
    pname:object must: not be dlink:VK_NULL_HANDLE
  * [[VUID-VkDebugMarkerObjectNameInfoEXT-object-01492]]
    pname:object must: be a Vulkan object of the type associated with
    pname:objectType as defined in <<debug-report-object-types>>
****

include::{generated}/validity/structs/VkDebugMarkerObjectNameInfoEXT.adoc[]
--

[open,refpage='vkDebugMarkerSetObjectTagEXT',desc='Attach arbitrary data to an object',type='protos']
--
In addition to setting a name for an object, debugging and validation layers
may have uses for additional binary data on a per-object basis that has no
other place in the Vulkan API.
For example, a sname:VkShaderModule could have additional debugging data
attached to it to aid in offline shader tracing.
To attach data to an object, call:

include::{generated}/api/protos/vkDebugMarkerSetObjectTagEXT.adoc[]

  * pname:device is the device that created the object.
  * pname:pTagInfo is a pointer to a slink:VkDebugMarkerObjectTagInfoEXT
    structure specifying the parameters of the tag to attach to the object.

include::{generated}/validity/protos/vkDebugMarkerSetObjectTagEXT.adoc[]
--

[open,refpage='VkDebugMarkerObjectTagInfoEXT',desc='Specify parameters of a tag to attach to an object',type='structs']
--
The sname:VkDebugMarkerObjectTagInfoEXT structure is defined as:

include::{generated}/api/structs/VkDebugMarkerObjectTagInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:objectType is a elink:VkDebugReportObjectTypeEXT specifying the
    type of the object to be named.
  * pname:object is the object to be tagged.
  * pname:tagName is a numerical identifier of the tag.
  * pname:tagSize is the number of bytes of data to attach to the object.
  * pname:pTag is a pointer to an array of pname:tagSize bytes containing
    the data to be associated with the object.

The pname:tagName parameter gives a name or identifier to the type of data
being tagged.
This can be used by debugging layers to easily filter for only data that can
be used by that implementation.

.Valid Usage
****
  * [[VUID-VkDebugMarkerObjectTagInfoEXT-objectType-01493]]
    pname:objectType must: not be
    ename:VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT
  * [[VUID-VkDebugMarkerObjectTagInfoEXT-object-01494]]
    pname:object must: not be dlink:VK_NULL_HANDLE
  * [[VUID-VkDebugMarkerObjectTagInfoEXT-object-01495]]
    pname:object must: be a Vulkan object of the type associated with
    pname:objectType as defined in <<debug-report-object-types>>
****

include::{generated}/validity/structs/VkDebugMarkerObjectTagInfoEXT.adoc[]
--


[[debugging-command-buffer-markers]]
=== Command Buffer Markers

Typical Vulkan applications will submit many command buffers in each frame,
with each command buffer containing a large number of individual commands.
Being able to logically annotate regions of command buffers that belong
together as well as hierarchically subdivide the frame is important to a
developer's ability to navigate the commands viewed holistically.

The marker commands fname:vkCmdDebugMarkerBeginEXT and
fname:vkCmdDebugMarkerEndEXT define regions of a series of commands that are
grouped together, and they can be nested to create a hierarchy.
The fname:vkCmdDebugMarkerInsertEXT command allows insertion of a single
label within a command buffer.

[open,refpage='vkCmdDebugMarkerBeginEXT',desc='Open a command buffer marker region',type='protos']
--
A marker region can be opened by calling:

include::{generated}/api/protos/vkCmdDebugMarkerBeginEXT.adoc[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:pMarkerInfo is a pointer to a slink:VkDebugMarkerMarkerInfoEXT
    structure specifying the parameters of the marker region to open.

.Valid Usage
****
ifdef::VK_QCOM_tile_shading[]
  * [[VUID-vkCmdDebugMarkerBeginEXT-None-10614]]
    This command must: not be recorded when
    <<renderpass-per-tile-execution-model,per-tile execution model>> is
    enabled
endif::VK_QCOM_tile_shading[]
****

include::{generated}/validity/protos/vkCmdDebugMarkerBeginEXT.adoc[]
--

[open,refpage='VkDebugMarkerMarkerInfoEXT',desc='Specify parameters of a command buffer marker region',type='structs']
--
The sname:VkDebugMarkerMarkerInfoEXT structure is defined as:

include::{generated}/api/structs/VkDebugMarkerMarkerInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pMarkerName is a pointer to a null-terminated UTF-8 string
    containing the name of the marker.
  * pname:color is an optional: RGBA color value that can be associated with
    the marker.
    A particular implementation may: choose to ignore this color value.
    The values contain RGBA values in order, in the range 0.0 to 1.0.
    If all elements in pname:color are 0.0, then it is ignored.

include::{generated}/validity/structs/VkDebugMarkerMarkerInfoEXT.adoc[]
--

[open,refpage='vkCmdDebugMarkerEndEXT',desc='Close a command buffer marker region',type='protos']
--
A marker region can be closed by calling:

include::{generated}/api/protos/vkCmdDebugMarkerEndEXT.adoc[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.

An application may: open a marker region in one command buffer and close it
in another, or otherwise split marker regions across multiple command
buffers or multiple queue submissions.
When viewed from the linear series of submissions to a single queue, the
calls to fname:vkCmdDebugMarkerBeginEXT and fname:vkCmdDebugMarkerEndEXT
must: be matched and balanced.

.Valid Usage
****
  * [[VUID-vkCmdDebugMarkerEndEXT-commandBuffer-01239]]
    There must: be an outstanding flink:vkCmdDebugMarkerBeginEXT command
    prior to the fname:vkCmdDebugMarkerEndEXT on the queue that
    pname:commandBuffer is submitted to
  * [[VUID-vkCmdDebugMarkerEndEXT-commandBuffer-01240]]
    If pname:commandBuffer is a secondary command buffer, there must: be an
    outstanding flink:vkCmdDebugMarkerBeginEXT command recorded to
    pname:commandBuffer that has not previously been ended by a call to
    flink:vkCmdDebugMarkerEndEXT
ifdef::VK_QCOM_tile_shading[]
  * [[VUID-vkCmdDebugMarkerEndEXT-None-10615]]
    This command must: not be recorded when
    <<renderpass-per-tile-execution-model,per-tile execution model>> is
    enabled
endif::VK_QCOM_tile_shading[]
****

include::{generated}/validity/protos/vkCmdDebugMarkerEndEXT.adoc[]
--

[open,refpage='vkCmdDebugMarkerInsertEXT',desc='Insert a marker label into a command buffer',type='protos']
--
A single marker label can be inserted into a command buffer by calling:

include::{generated}/api/protos/vkCmdDebugMarkerInsertEXT.adoc[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:pMarkerInfo is a pointer to a slink:VkDebugMarkerMarkerInfoEXT
    structure specifying the parameters of the marker to insert.

include::{generated}/validity/protos/vkCmdDebugMarkerInsertEXT.adoc[]
--
endif::VK_EXT_debug_marker[]


ifdef::VK_EXT_debug_report[]
[[debugging-debug-report-callbacks]]
== Debug Report Callbacks

[open,refpage='VkDebugReportCallbackEXT',desc='Opaque handle to a debug report callback object',type='handles']
--
Debug report callbacks are represented by sname:VkDebugReportCallbackEXT
handles:

include::{generated}/api/handles/VkDebugReportCallbackEXT.adoc[]
--

[open,refpage='vkCreateDebugReportCallbackEXT',desc='Create a debug report callback object',type='protos']
--
Debug report callbacks give more detailed feedback on the application's use
of Vulkan when events of interest occur.

To register a debug report callback, an application uses
flink:vkCreateDebugReportCallbackEXT.

include::{generated}/api/protos/vkCreateDebugReportCallbackEXT.adoc[]

  * pname:instance is the instance the callback will be logged on.
  * pname:pCreateInfo is a pointer to a
    slink:VkDebugReportCallbackCreateInfoEXT structure defining the
    conditions under which this callback will be called.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pCallback is a pointer to a slink:VkDebugReportCallbackEXT handle
    in which the created object is returned.

include::{generated}/validity/protos/vkCreateDebugReportCallbackEXT.adoc[]
--

[open,refpage='VkDebugReportCallbackCreateInfoEXT',desc='Structure specifying parameters of a newly created debug report callback',type='structs']
--
The definition of slink:VkDebugReportCallbackCreateInfoEXT is:

include::{generated}/api/structs/VkDebugReportCallbackCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkDebugReportFlagBitsEXT specifying
    which event(s) will cause this callback to be called.
  * pname:pfnCallback is the application callback function to call.
  * pname:pUserData is NULL or an application-defined user data pointer to
    be passed to the callback.

For each sname:VkDebugReportCallbackEXT that is created the
sname:VkDebugReportCallbackCreateInfoEXT::pname:flags determine when that
sname:VkDebugReportCallbackCreateInfoEXT::pname:pfnCallback is called.
When an event happens, the implementation will do a bitwise AND of the
event's elink:VkDebugReportFlagBitsEXT flags to each
sname:VkDebugReportCallbackEXT object's flags.
For each non-zero result the corresponding callback will be called.
The callback will come directly from the component that detected the event,
unless some other layer intercepts the calls for its own purposes (filter
them in a different way, log to a system error log, etc.).

An application may: receive multiple callbacks if multiple
sname:VkDebugReportCallbackEXT objects were created.
A callback will always be executed in the same thread as the originating
Vulkan call.

A callback may be called from multiple threads simultaneously (if the
application is making Vulkan calls from multiple threads).

include::{generated}/validity/structs/VkDebugReportCallbackCreateInfoEXT.adoc[]
--

[open,refpage='VkDebugReportFlagBitsEXT',desc='Bitmask specifying events which cause a debug report callback',type='enums']
--
Bits which can: be set in
slink:VkDebugReportCallbackCreateInfoEXT::pname:flags, specifying events
which cause a debug report, are:

include::{generated}/api/enums/VkDebugReportFlagBitsEXT.adoc[]

  * ename:VK_DEBUG_REPORT_ERROR_BIT_EXT specifies that the application has
    violated a valid usage condition of the specification.
  * ename:VK_DEBUG_REPORT_WARNING_BIT_EXT specifies use of Vulkan that may:
    expose an application bug.
    Such cases may not be immediately harmful, such as a fragment shader
    outputting to a location with no attachment.
    Other cases may: point to behavior that is almost certainly bad when
    unintended such as using an image whose memory has not been filled.
    In general if you see a warning but you know that the behavior is
    intended/desired, then simply ignore the warning.
  * ename:VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT specifies a
    potentially non-optimal use of Vulkan, e.g. using
    flink:vkCmdClearColorImage when setting
    slink:VkAttachmentDescription::pname:loadOp to
    ename:VK_ATTACHMENT_LOAD_OP_CLEAR would have worked.
  * ename:VK_DEBUG_REPORT_INFORMATION_BIT_EXT specifies an informational
    message such as resource details that may be handy when debugging an
    application.
  * ename:VK_DEBUG_REPORT_DEBUG_BIT_EXT specifies diagnostic information
    from the implementation and layers.
--

[open,refpage='VkDebugReportFlagsEXT',desc='Bitmask of VkDebugReportFlagBitsEXT',type='flags']
--
include::{generated}/api/flags/VkDebugReportFlagsEXT.adoc[]

tname:VkDebugReportFlagsEXT is a bitmask type for setting a mask of zero or
more elink:VkDebugReportFlagBitsEXT.
--

[open,refpage='PFN_vkDebugReportCallbackEXT',desc='Application-defined debug report callback function',type='funcpointers']
--
The prototype for the
slink:VkDebugReportCallbackCreateInfoEXT::pname:pfnCallback function
implemented by the application is:

include::{generated}/api/funcpointers/PFN_vkDebugReportCallbackEXT.adoc[]

  * pname:flags specifies the elink:VkDebugReportFlagBitsEXT that triggered
    this callback.
  * pname:objectType is a elink:VkDebugReportObjectTypeEXT value specifying
    the type of object being used or created at the time the event was
    triggered.
  * pname:object is the object where the issue was detected.
    If pname:objectType is ename:VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
    pname:object is undefined:.
  * pname:location is a component (layer, driver, loader) defined value
    specifying the _location_ of the trigger.
    This is an optional: value.
  * pname:messageCode is a layer-defined value indicating what test
    triggered this callback.
  * pname:pLayerPrefix is a null-terminated UTF-8 string that is an
    abbreviation of the name of the component making the callback.
    pname:pLayerPrefix is only valid for the duration of the callback.
  * pname:pMessage is a null-terminated UTF-8 string detailing the trigger
    conditions.
    pname:pMessage is only valid for the duration of the callback.
  * pname:pUserData is the application-defined user data pointer, equal to
    the value of slink:VkDebugReportCallbackCreateInfoEXT::pname:pUserData
    specified when the slink:VkDebugReportCallbackEXT object was created.

The callback must: not call fname:vkDestroyDebugReportCallbackEXT.

The callback returns a basetype:VkBool32, which is interpreted in a
layer-specified manner.
The application should: always return ename:VK_FALSE.
The ename:VK_TRUE value is reserved for use in layer development.

pname:object must: be a Vulkan object or dlink:VK_NULL_HANDLE.
If pname:objectType is not ename:VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT and
pname:object is not dlink:VK_NULL_HANDLE, pname:object must: be a Vulkan
object of the corresponding type associated with pname:objectType as defined
in <<debug-report-object-types>>.
--

[open,refpage='VkDebugReportObjectTypeEXT',desc='Specify the type of an object handle',type='enums']
--
Possible values passed to the pname:objectType parameter of the callback
function specified by
slink:VkDebugReportCallbackCreateInfoEXT::pname:pfnCallback, specifying the
type of object handle being reported, are:

include::{generated}/api/enums/VkDebugReportObjectTypeEXT.adoc[]

[[debug-report-object-types]]
.`VkDebugReportObjectTypeEXT` and Vulkan Handle Relationship
[width="80%",cols="<35,<23",options="header"]
|====
| elink:VkDebugReportObjectTypeEXT                            | Vulkan Handle Type
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT               | Unknown/Undefined Handle
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT              | slink:VkInstance
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT       | slink:VkPhysicalDevice
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT                | slink:VkDevice
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT                 | slink:VkQueue
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT             | slink:VkSemaphore
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT        | slink:VkCommandBuffer
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT                 | slink:VkFence
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT         | slink:VkDeviceMemory
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT                | slink:VkBuffer
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT                 | slink:VkImage
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT                 | slink:VkEvent
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT            | slink:VkQueryPool
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT           | slink:VkBufferView
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT            | slink:VkImageView
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT         | slink:VkShaderModule
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT        | slink:VkPipelineCache
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT       | slink:VkPipelineLayout
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT           | slink:VkRenderPass
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT              | slink:VkPipeline
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT | slink:VkDescriptorSetLayout
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT               | slink:VkSampler
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT       | slink:VkDescriptorPool
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT        | slink:VkDescriptorSet
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT           | slink:VkFramebuffer
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT          | slink:VkCommandPool
ifdef::VK_KHR_surface[]
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT           | slink:VkSurfaceKHR
endif::VK_KHR_surface[]
ifdef::VK_KHR_swapchain[]
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT         | slink:VkSwapchainKHR
endif::VK_KHR_swapchain[]
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT | slink:VkDebugReportCallbackEXT
ifdef::VK_KHR_display[]
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT           | slink:VkDisplayKHR
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT      | slink:VkDisplayModeKHR
endif::VK_KHR_display[]
ifndef::VK_COMPUTE_VERSION_1_1[]
ifdef::VK_KHR_descriptor_update_template[]
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT | slink:VkDescriptorUpdateTemplate
endif::VK_KHR_descriptor_update_template[]
endif::VK_COMPUTE_VERSION_1_1[]
ifdef::VK_COMPUTE_VERSION_1_1[]
| ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT | slink:VkDescriptorUpdateTemplate
endif::VK_COMPUTE_VERSION_1_1[]
|====

[NOTE]
====
The primary expected use of ename:VK_ERROR_VALIDATION_FAILED_EXT is for
validation layer testing to prevent invalid commands from reaching the ICD.
It is not expected that an application would see this error code during
normal use of the validation layers.
If an application returns ename:VK_TRUE in
slink:VkDebugUtilsMessengerCallbackDataEXT, the validation layers will
return this error code instead of passing the command down the dispatch
chain.
====
--

[open,refpage='vkDebugReportMessageEXT',desc='Inject a message into a debug stream',type='protos']
--
To inject its own messages into the debug stream, call:

include::{generated}/api/protos/vkDebugReportMessageEXT.adoc[]

  * pname:instance is the debug stream's slink:VkInstance.
  * pname:flags specifies the elink:VkDebugReportFlagBitsEXT classification
    of this event/message.
  * pname:objectType is a elink:VkDebugReportObjectTypeEXT specifying the
    type of object being used or created at the time the event was
    triggered.
  * pname:object is the object where the issue was detected.
    pname:object can: be dlink:VK_NULL_HANDLE if there is no object
    associated with the event.
  * pname:location is an application-defined value.
  * pname:messageCode is an application-defined value.
  * pname:pLayerPrefix is the abbreviation of the component making this
    event/message.
  * pname:pMessage is a null-terminated UTF-8 string detailing the trigger
    conditions.

The call will propagate through the layers and generate callback(s) as
indicated by the message's flags.
The parameters are passed on to the callback in addition to the
pname:pUserData value that was defined at the time the callback was
registered.

.Valid Usage
****
  * [[VUID-vkDebugReportMessageEXT-object-01241]]
    pname:object must: be a Vulkan object or dlink:VK_NULL_HANDLE
  * [[VUID-vkDebugReportMessageEXT-objectType-01498]]
    If pname:objectType is not ename:VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT
    and pname:object is not dlink:VK_NULL_HANDLE, pname:object must: be a
    Vulkan object of the corresponding type associated with pname:objectType
    as defined in <<debug-report-object-types>>
****

include::{generated}/validity/protos/vkDebugReportMessageEXT.adoc[]
--

[open,refpage='vkDestroyDebugReportCallbackEXT',desc='Destroy a debug report callback object',type='protos']
--
To destroy a sname:VkDebugReportCallbackEXT object, call:

include::{generated}/api/protos/vkDestroyDebugReportCallbackEXT.adoc[]

  * pname:instance is the instance where the callback was created.
  * pname:callback is the slink:VkDebugReportCallbackEXT object to destroy.
    pname:callback is an externally synchronized object and must: not be
    used on more than one thread at a time.
    This means that fname:vkDestroyDebugReportCallbackEXT must: not be
    called when a callback is active.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

ifndef::VKSC_VERSION_1_0[]
.Valid Usage
****
  * [[VUID-vkDestroyDebugReportCallbackEXT-instance-01242]]
    If sname:VkAllocationCallbacks were provided when pname:callback was
    created, a compatible set of callbacks must: be provided here
  * [[VUID-vkDestroyDebugReportCallbackEXT-instance-01243]]
    If no sname:VkAllocationCallbacks were provided when pname:callback was
    created, pname:pAllocator must: be `NULL`
****
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/protos/vkDestroyDebugReportCallbackEXT.adoc[]
--
endif::VK_EXT_debug_report[]


ifdef::VK_NV_device_diagnostic_checkpoints,VK_EXT_device_fault[]
== Device Loss Debugging
endif::VK_NV_device_diagnostic_checkpoints,VK_EXT_device_fault[]


ifdef::VK_NV_device_diagnostic_checkpoints[]
[[device-diagnostic-checkpoints]]
=== Device Diagnostic Checkpoints

Device execution progress can: be tracked for the purposes of debugging a
device loss by annotating the command stream with application-defined
diagnostic checkpoints.

[open,refpage='vkCmdSetCheckpointNV',desc='Insert diagnostic checkpoint in command stream',type='protos']
--
Device diagnostic checkpoints are inserted into the command stream by
calling flink:vkCmdSetCheckpointNV.

include::{generated}/api/protos/vkCmdSetCheckpointNV.adoc[]

  * pname:commandBuffer is the command buffer that will receive the marker
  * pname:pCheckpointMarker is an opaque application-provided value that
    will be associated with the checkpoint.

include::{generated}/validity/protos/vkCmdSetCheckpointNV.adoc[]
--

Note that pname:pCheckpointMarker is treated as an opaque value.
It does not need to be a valid pointer and will not be dereferenced by the
implementation.

ifdef::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
[open,refpage='vkGetQueueCheckpointData2NV',desc='Retrieve diagnostic checkpoint data',type='protos']
--
If the device encounters an error during execution, the implementation will
return a ename:VK_ERROR_DEVICE_LOST error to the application at some point
during host execution.
When this happens, the application can: call
flink:vkGetQueueCheckpointData2NV to retrieve information on the most recent
diagnostic checkpoints that were executed by the device.

include::{generated}/api/protos/vkGetQueueCheckpointData2NV.adoc[]

  * pname:queue is the slink:VkQueue object the caller would like to
    retrieve checkpoint data for
  * pname:pCheckpointDataCount is a pointer to an integer related to the
    number of checkpoint markers available or queried, as described below.
  * pname:pCheckpointData is either `NULL` or a pointer to an array of
    sname:VkCheckpointData2NV structures.

If pname:pCheckpointData is `NULL`, then the number of checkpoint markers
available is returned in pname:pCheckpointDataCount.
Otherwise, pname:pCheckpointDataCount must: point to a variable set by the
application to the number of elements in the pname:pCheckpointData array,
and on return the variable is overwritten with the number of structures
actually written to pname:pCheckpointData.

If pname:pCheckpointDataCount is less than the number of checkpoint markers
available, at most pname:pCheckpointDataCount structures will be written.

.Valid Usage
****
  * [[VUID-vkGetQueueCheckpointData2NV-queue-03892]]
    The device that pname:queue belongs to must: be in the lost state
****

include::{generated}/validity/protos/vkGetQueueCheckpointData2NV.adoc[]
--

[open,refpage='VkCheckpointData2NV',desc='Return structure for command buffer checkpoint data',type='structs']
--
The slink:VkCheckpointData2NV structure is defined as:

include::{generated}/api/structs/VkCheckpointData2NV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:stage indicates a single pipeline stage which the checkpoint
    marker data refers to.
  * pname:pCheckpointMarker contains the value of the last checkpoint marker
    executed in the stage that pname:stage refers to.

include::{generated}/validity/structs/VkCheckpointData2NV.adoc[]

The stages at which a checkpoint marker can: be executed are
implementation-defined and can: be queried by calling
flink:vkGetPhysicalDeviceQueueFamilyProperties2.
--
endif::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]

[open,refpage='vkGetQueueCheckpointDataNV',desc='Retrieve diagnostic checkpoint data',type='protos']
--
If the device encounters an error during execution, the implementation will
return a ename:VK_ERROR_DEVICE_LOST error to the application at a certain
point during host execution.
When this happens, the application can: call
flink:vkGetQueueCheckpointDataNV to retrieve information on the most recent
diagnostic checkpoints that were executed by the device.

include::{generated}/api/protos/vkGetQueueCheckpointDataNV.adoc[]

  * pname:queue is the slink:VkQueue object the caller would like to
    retrieve checkpoint data for
  * pname:pCheckpointDataCount is a pointer to an integer related to the
    number of checkpoint markers available or queried, as described below.
  * pname:pCheckpointData is either `NULL` or a pointer to an array of
    sname:VkCheckpointDataNV structures.

If pname:pCheckpointData is `NULL`, then the number of checkpoint markers
available is returned in pname:pCheckpointDataCount.

Otherwise, pname:pCheckpointDataCount must: point to a variable set by the
application to the number of elements in the pname:pCheckpointData array,
and on return the variable is overwritten with the number of structures
actually written to pname:pCheckpointData.

If pname:pCheckpointDataCount is less than the number of checkpoint markers
available, at most pname:pCheckpointDataCount structures will be written.

.Valid Usage
****
  * [[VUID-vkGetQueueCheckpointDataNV-queue-02025]]
    The device that pname:queue belongs to must: be in the lost state
****

include::{generated}/validity/protos/vkGetQueueCheckpointDataNV.adoc[]
--

[open,refpage='VkCheckpointDataNV',desc='Return structure for command buffer checkpoint data',type='structs']
--
The slink:VkCheckpointDataNV structure is defined as:

include::{generated}/api/structs/VkCheckpointDataNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:stage is a ename:VkPipelineStageFlagBits value specifying which
    pipeline stage the checkpoint marker data refers to.
  * pname:pCheckpointMarker contains the value of the last checkpoint marker
    executed in the stage that pname:stage refers to.

The stages at which a checkpoint marker can: be executed are
implementation-defined and can: be queried by calling
flink:vkGetPhysicalDeviceQueueFamilyProperties2.

include::{generated}/validity/structs/VkCheckpointDataNV.adoc[]
--
endif::VK_NV_device_diagnostic_checkpoints[]


ifdef::VKSC_VERSION_1_0[]
[[fault-handling]]
== Fault Handling

The fault handling mechanism provides a method for the implementation to
pass fault information to the application.
A fault indicates that an issue has occurred with the host or device that
could impact the implementation's ability to function correctly.
It consists of a slink:VkFaultData structure that is used to communicate
information about the fault between the implementation and the application,
with two methods to obtain the data.
The application can: obtain the fault data from the implementation using
flink:vkGetFaultData.
Alternatively, the implementation can: directly call a pre-registered fault
handler function (tlink:PFN_vkFaultCallbackFunction) in the application when
a fault occurs.

The sname:VkFaultData structure provides categories the implementation must:
set to provide basic information on a fault.
These allow the implementation to provide a coarse classification of a fault
to the application.
As the potential faults that could occur will vary between different
platforms, it is expected that an implementation would also provide
additional implementation-specific data on the fault, enabling the
application to take appropriate action.

The implementation must: also define whether a particular fault results in
the fault callback function being called, is communicated via
flink:vkGetFaultData, or both.
This will be decided by several factors including:

  * the severity of the fault,
  * the application's ability to handle the fault, and
  * how the application should handle the fault.

The implementation must: document the implementation-specific fault data,
how the faults are communicated, and expected responses from the application
for each of the faults that it can: report.


[[fault-data]]
=== Fault Data

[open,refpage='VkFaultData',desc='structure describing fault data',type='structs']
--
The information on a single fault is returned using the sname:VkFaultData
structure.
The sname:VkFaultData structure is defined as:

include::{generated}/api/structs/VkFaultData.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure that provides implementation-specific data on the fault.
  * pname:faultLevel is a elink:VkFaultLevel that provides the severity of
    the fault.
  * pname:faultType is a elink:VkFaultType that provides the type of the
    fault.

To retrieve implementation-specific fault data, pname:pNext can: point to
one or more implementation-defined fault structures or `NULL` to not
retrieve implementation-specific data.

.Valid Usage
****
  * [[VUID-VkFaultData-pNext-05019]]
    pname:pNext must: be `NULL` or a valid pointer to an
    implementation-specific structure
****

include::{generated}/validity/structs/VkFaultData.adoc[]

--

[open,refpage='VkFaultLevel',desc='The different fault severity levels that can be returned',type='enums']
--
Possible values of slink:VkFaultData::pname:faultLevel, specifying the fault
severity, are:

include::{generated}/api/enums/VkFaultLevel.adoc[]

  * ename:VK_FAULT_LEVEL_UNASSIGNED A fault level has not been assigned.
  * ename:VK_FAULT_LEVEL_CRITICAL A fault that cannot: be recovered by the
    application.
  * ename:VK_FAULT_LEVEL_RECOVERABLE A fault that can: be recovered by the
    application.
  * ename:VK_FAULT_LEVEL_WARNING A fault that indicates a non-optimal
    condition has occurred, but no recovery is necessary at this point.

--

[open,refpage='VkFaultType',desc='The different fault types that can be returned',type='enums']
--

Possible values of slink:VkFaultData::pname:faultType, specifying the fault
type, are:

include::{generated}/api/enums/VkFaultType.adoc[]

  * ename:VK_FAULT_TYPE_INVALID The fault data does not contain a valid
    fault.
  * ename:VK_FAULT_TYPE_UNASSIGNED A fault type has not been assigned.
  * ename:VK_FAULT_TYPE_IMPLEMENTATION Implementation-defined fault.
  * ename:VK_FAULT_TYPE_SYSTEM A fault occurred in the system components.
  * ename:VK_FAULT_TYPE_PHYSICAL_DEVICE A fault occurred with the physical
    device.
  * ename:VK_FAULT_TYPE_COMMAND_BUFFER_FULL Command buffer memory was
    exhausted before flink:vkEndCommandBuffer was called.
  * ename:VK_FAULT_TYPE_INVALID_API_USAGE Invalid usage of the API was
    detected by the implementation.
--


[[querrying-fault]]
=== Querying Fault Status

[open,refpage='vkGetFaultData',desc='Query fault information',type='protos']
--
:refpage: vkGetFaultData

To query the number of current faults and obtain the fault data, call
flink:vkGetFaultData.

include::{generated}/api/protos/vkGetFaultData.adoc[]

  * pname:device is the logical device to obtain faults from.
  * pname:faultQueryBehavior is a elink:VkFaultQueryBehavior that specifies
    the types of faults to obtain from the implementation, and how those
    faults should be handled.
  * pname:pUnrecordedFaults is a return boolean that specifies if the logged
    fault information is incomplete and does not contain entries for all
    faults that have been detected by the implementation and may: be
    reported via flink:vkGetFaultData.
  * pname:pFaultCount is a pointer to an integer that specifies the number
    of fault entries.
  * pname:pFaults is either `NULL` or a pointer to an array of
    pname:pFaultCount slink:VkFaultData structures to be updated with the
    recorded fault data.

Access to fault data is internally synchronized, meaning
flink:vkGetFaultData can: be called from multiple threads simultaneously.

The implementation must: not record more than <<limits-maxQueryFaultCount,
pname:maxQueryFaultCount>> faults to be reported by flink:vkGetFaultData.

pname:pUnrecordedFaults is ename:VK_TRUE if the implementation has detected
one or more faults since the last successful retrieval of fault data using
this command, but was unable to record fault information for all faults.
Otherwise, pname:pUnrecordedFaults is ename:VK_FALSE.

If pname:pFaults is `NULL`, then the number of faults with the specified
pname:faultQueryBehavior characteristics associated with pname:device is
returned in pname:pFaultCount, and pname:pUnrecordedFaults is set as
indicated above.
Otherwise, pname:pFaultCount must: point to a variable set by the
application to the number of elements in the pname:pFaults array, and on
return the variable is overwritten with the number of faults actually
written to pname:pFaults.
If pname:pFaultCount is less than the number of recorded pname:device faults
with the specified pname:faultQueryBehavior characteristics, at most
pname:pFaultCount faults will be written, and ename:VK_INCOMPLETE will be
returned instead of ename:VK_SUCCESS, to indicate that not all the available
faults were returned.

If ename:VK_SUCCESS is returned, the fault information stored by the
implementation for the faults that were returned will be handled as
specified by pname:faultQueryBehavior.
Otherwise, the stored fault information is not modified.

For each filled pname:pFaults entry, if pname:pNext is not `NULL`, the
implementation will fill in any implementation-specific structures
applicable to that fault that are included in the pname:pNext chain.

[NOTE]
====
In order to simplify the application logic, an application could have a
static allocation sized to <<limits-maxQueryFaultCount,
pname:maxQueryFaultCount>> which it passes in to each call of
flink:vkGetFaultData.
This allows an application to obtain all the faults available at this time
in a single call to flink:vkGetFaultData.
Furthermore, under this usage pattern, the command will never return
ename:VK_INCOMPLETE.
====

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkGetFaultData-pFaultCount-05020]]
    pname:pFaultCount must: be less than or equal to
    <<limits-maxQueryFaultCount,pname:maxQueryFaultCount>>
****

include::{generated}/validity/protos/vkGetFaultData.adoc[]
--


[open,refpage='VkFaultQueryBehavior',desc='Controls how the faults are retrieved by vkGetFaultData',type='enums']
--
Possible values that can: be set in elink:VkFaultQueryBehavior, specifying
which faults to return, are:

include::{generated}/api/enums/VkFaultQueryBehavior.adoc[]

  * ename:VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS All fault types
    and severities are reported and are cleared from the internal fault
    storage after retrieval.

--


[[fault-callback]]
=== Fault Callback

The slink:VkFaultCallbackInfo structure allows an application to register a
function at device creation that the implementation can call to report
faults when they occur.
A callback function is registered by attaching a valid
sname:VkFaultCallbackInfo structure to the pname:pNext chain of the
slink:VkDeviceCreateInfo structure.
The callback function is only called by the implementation during a call to
the API, using the same thread that is making the API call.
The sname:VkFaultCallbackInfo structure provides the function pointer to be
called by the implementation, and optionally, application memory to store
fault data.

[open,refpage='VkFaultCallbackInfo',desc='Fault call back information',type='structs']
--

The sname:VkFaultCallbackInfo structure is defined as:

include::{generated}/api/structs/VkFaultCallbackInfo.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or pointer to a structure extending this
    structure.
  * pname:faultCount is the number of reported faults in the array pointed
    to by pname:pFaults.
  * pname:pFaults is either `NULL` or a pointer to an array of
    pname:faultCount slink:VkFaultData structures.
  * pname:pfnFaultCallback is a function pointer to the fault handler
    function that will be called by the implementation when a fault occurs.

If provided, the implementation may: make use of the pname:pFaults array to
return fault data to the application when using the fault callback.

[NOTE]
====
Prior to Vulkan SC 1.0.11, the application was required to provide the
pname:pFaults array for fault callback data.
This proved to be unwieldy for both applications and implementations and it
was made optional as of version 1.0.11.
It is expected that most implementations will ignore this and use stack or
other preallocated memory for fault callback parameters.
====

If provided, the application memory referenced by pname:pFaults must: remain
accessible throughout the lifetime of the logical device that was created
with this structure.

[NOTE]
====
The memory pointed to by pname:pFaults will be updated by the implementation
and should not be used or accessed by the application outside of the fault
handling function pointed to by pname:pfnFaultCallback.
This restriction also applies to any implementation-specific structure
chained to an element of pname:pFaults by pname:pNext.

It is expected that implementations will maintain separate storage for fault
information and populate the array pointed to by pname:pFaults ahead of
calling the fault callback function.
====

.Valid Usage
****
  * [[VUID-VkFaultCallbackInfo-faultCount-05138]]
    pname:faultCount must: either be 0, or equal to
    <<limits-maxCallbackFaultCount,
    sname:VkPhysicalDeviceVulkanSC10Properties::pname:maxCallbackFaultCount>>
****

include::{generated}/validity/structs/VkFaultCallbackInfo.adoc[]
--

[open,refpage='PFN_vkFaultCallbackFunction',desc='Fault Callback Function',type='funcpointers']
--

The function pointer tlink:PFN_vkFaultCallbackFunction is defined as:

include::{generated}/api/funcpointers/PFN_vkFaultCallbackFunction.adoc[]

  * pname:unrecordedFaults is a boolean that specifies if the supplied fault
    information is incomplete and does not contain entries for all faults
    that have been detected by the implementation and may: be reported via
    tlink:PFN_vkFaultCallbackFunction since the last call to this callback.
  * pname:faultCount will contain the number of reported faults in the array
    pointed to by pname:pFaults.
  * pname:pFaults will point to an array of pname:faultCount
    slink:VkFaultData structures containing the fault information.

An implementation must: only make calls to pname:pfnFaultCallback during the
execution of an API command.
An implementation must: only make calls into the application-provided fault
callback from the same thread that called the API command.
The implementation should: not synchronize calls to the callback.
If synchronization is needed, the callback must: provide it.

The fault callback must: not call any Vulkan commands.

It is implementation-dependent whether faults reported by this callback are
also reported via flink:vkGetFaultData, but each unique fault will be
reported by at most one callback.
--

ifdef::hidden[]
// tag::scaddition[]
  * slink:VkFaultData <<SCID-6>>
  * slink:VkFaultCallbackInfo <<SCID-6>>
  * elink:VkFaultLevel <<SCID-6>>
  * elink:VkFaultType <<SCID-6>>
  * elink:VkFaultQueryBehavior <<SCID-6>>
  * tlink:PFN_vkFaultCallbackFunction <<SCID-6>>
  * flink:vkGetFaultData <<SCID-6>>
// end::scaddition[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]


ifdef::VK_EXT_device_fault[]
=== Device Fault Diagnosis

[open,refpage='vkGetDeviceFaultInfoEXT',desc='Reports diagnostic fault information on the specified logical device',type='protos']
--
To retrieve diagnostic information about faults that may: have caused device
loss, call:

include::{generated}/api/protos/vkGetDeviceFaultInfoEXT.adoc[]

  * pname:device is the logical device from which to query the diagnostic
    fault information.
  * pname:pFaultCounts is a pointer to a slink:VkDeviceFaultCountsEXT
    structure in which counts for structures describing additional fault
    information are returned.
  * pname:pFaultInfo is `NULL` or a pointer to a slink:VkDeviceFaultInfoEXT
    structure in which fault information is returned.

If pname:pFaultInfo is `NULL`, then the counts of corresponding additional
fault information structures available are returned in the
pname:addressInfoCount and pname:vendorInfoCount members of
pname:pFaultCounts.
Additionally, the size of any vendor-specific binary crash dump is returned
in the pname:vendorBinarySize member of pname:pFaultCounts.

If pname:pFaultInfo is not `NULL`, pname:pFaultCounts must: point to a
slink:VkDeviceFaultCountsEXT structure with each structure count or size
member (pname:addressInfoCount, pname:vendorInfoCount,
pname:vendorBinarySize) set by the application to the number of elements in
the corresponding output array member of pname:pFaultInfo
(pname:pAddressInfos and pname:pVendorInfos), or to the size of the output
buffer in bytes (pname:pVendorBinaryData).
On return, each structure count member is overwritten with the number of
structures actually written to the corresponding output array member of
pname:pFaultInfo.
Similarly, pname:vendorBinarySize is overwritten with the number of bytes
actually written to the pname:pVendorBinaryData member of pname:pFaultInfo.

If the <<features-deviceFaultVendorBinary, vendor-specific crash dumps>>
feature is not enabled, then implementations must: set
pname:pFaultCounts\->vendorBinarySize to zero and must: not modify
pname:pFaultInfo\->pVendorBinaryData.

If any pname:pFaultCounts structure count member is less than the number of
corresponding fault properties available, at most structure count
(pname:addressInfoCount, pname:vendorInfoCount) elements will be written to
the associated pname:pFaultInfo output array.
Similarly, if pname:vendorBinarySize is less than the size in bytes of the
available crash dump data, at most pname:vendorBinarySize elements will be
written to pname:pVendorBinaryData.

If pname:pFaultInfo is `NULL`, then subsequent calls to
flink:vkGetDeviceFaultInfoEXT for the same pname:device must: return
identical values in the pname:addressInfoCount, pname:vendorInfoCount and
pname:vendorBinarySize members of pname:pFaultCounts.

If pname:pFaultInfo is not `NULL`, then subsequent calls to
flink:vkGetDeviceFaultInfoEXT for the same pname:device must: return
identical values in the output members of pname:pFaultInfo
(pname:pAddressInfos, pname:pVendorInfos, pname:pVendorBinaryData), up to
the limits described by the structure count and buffer size members of
pname:pFaultCounts (pname:addressInfoCount, pname:vendorInfoCount,
pname:vendorBinarySize).
If the sizes of the output members of pname:pFaultInfo increase for a
subsequent call to flink:vkGetDeviceFaultInfoEXT, then supplementary
information may: be returned in the additional available space.

If any pname:pFaultCounts structure count member is smaller than the number
of corresponding fault properties available, or if
pname:pFaultCounts\->vendorBinarySize is smaller than the size in bytes of
the generated binary crash dump data, ename:VK_INCOMPLETE will be returned
instead of ename:VK_SUCCESS, to indicate that not all the available
properties were returned.

If pname:pFaultCounts\->vendorBinarySize is less than what is necessary to
store the <<vendor-binary-crash-dumps, binary crash dump header>>, nothing
will be written to pname:pFaultInfo\->pVendorBinaryData and zero will be
written to pname:pFaultCounts\->vendorBinarySize.

.Valid Usage
****
  * [[VUID-vkGetDeviceFaultInfoEXT-device-07336]]
    pname:device must: be in the _lost_ state
  * [[VUID-vkGetDeviceFaultInfoEXT-pFaultCounts-07337]]
    If the value referenced by pname:pFaultCounts->addressInfoCount is not
    `0`, and pname:pFaultInfo->pAddressInfos is not `NULL`,
    pname:pFaultInfo->pAddressInfos must: be a valid pointer to an array of
    pname:pFaultCounts->addressInfoCount slink:VkDeviceFaultAddressInfoEXT
    structures
  * [[VUID-vkGetDeviceFaultInfoEXT-pFaultCounts-07338]]
    If the value referenced by pname:pFaultCounts->vendorInfoCount is not
    `0`, and pname:pFaultInfo->pVendorInfos is not `NULL`,
    pname:pFaultInfo->pVendorInfos must: be a valid pointer to an array of
    pname:pFaultCounts->vendorInfoCount slink:VkDeviceFaultVendorInfoEXT
    structures
  * [[VUID-vkGetDeviceFaultInfoEXT-pFaultCounts-07339]]
    If the value referenced by pname:pFaultCounts->vendorBinarySize is not
    `0`, and pname:pFaultInfo->pVendorBinaryData is not `NULL`,
    pname:pFaultInfo->pVendorBinaryData must: be a valid pointer to an array
    of pname:pFaultCounts->vendorBinarySize bytes
****

include::{generated}/validity/protos/vkGetDeviceFaultInfoEXT.adoc[]
--

[open,refpage='VkDeviceFaultCountsEXT',desc='Structure specifying device fault information',type='structs']
--
The sname:VkDeviceFaultCountsEXT structure is defined as:

include::{generated}/api/structs/VkDeviceFaultCountsEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:addressInfoCount is the number of
    slink:VkDeviceFaultAddressInfoEXT structures describing either memory
    accesses which may: have caused a page fault, or the addresses of active
    instructions at the time of the fault.
  * pname:vendorInfoCount is the number of slink:VkDeviceFaultVendorInfoEXT
    structures describing vendor-specific fault information.
  * pname:vendorBinarySize is the size in bytes of a vendor-specific binary
    crash dump, which may provide additional information when imported into
    external tools.

include::{generated}/validity/structs/VkDeviceFaultCountsEXT.adoc[]
--

[open,refpage='VkDeviceFaultInfoEXT',desc='Structure specifying device fault information',type='structs']
--
The sname:VkDeviceFaultInfoEXT structure is defined as:

include::{generated}/api/structs/VkDeviceFaultInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:description is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a human readable
    description of the fault.
  * pname:pAddressInfos is `NULL` or a pointer to an array of
    slink:VkDeviceFaultAddressInfoEXT structures describing either memory
    accesses which may: have caused a page fault, or describing active
    instruction pointers at the time of the fault.
    If not `NULL`, each element of pname:pAddressInfos describes the a
    bounded region of GPU virtual address space containing either the GPU
    virtual address accessed, or the value of an active instruction pointer.
  * pname:pVendorInfos is `NULL` or a pointer to an array of
    slink:VkDeviceFaultVendorInfoEXT structures describing vendor-specific
    fault information.
  * pname:pVendorBinaryData is `NULL` or a pointer to pname:vendorBinarySize
    number of bytes of data, which will be populated with a vendor-specific
    binary crash dump, as described in <<vendor-binary-crash-dumps, Vendor
    Binary Crash Dumps>>.

An implementation should: populate as many members of
slink:VkDeviceFaultInfoEXT as possible, given the information available at
the time of the fault and the constraints of the implementation itself.

Due to hardware limitations, pname:pAddressInfos describes ranges of GPU
virtual address space, rather than precise addresses.
The precise memory address accessed or the precise value of the instruction
pointer must: lie within the region described.

ifdef::VK_EXT_device_address_binding_report[]
[NOTE]
====
Each element of pname:pAddressInfos describes either:

  * A memory access which may have triggered a page fault and may have
    contributed to device loss
  * The value of an active instruction pointer at the time a fault occurred.
    This value may be indicative of the active pipeline or shader at the
    time of device loss

Comparison of the GPU virtual addresses described by pname:pAddressInfos to
GPU virtual address ranges reported by the
`apiext:VK_EXT_device_address_binding_report` extension may allow
applications to correlate between these addresses and Vulkan objects.
Applications should be aware that these addresses may also correspond to
resources internal to an implementation, which will not be reported via the
`apiext:VK_EXT_device_address_binding_report` extension.
====
endif::VK_EXT_device_address_binding_report[]

include::{generated}/validity/structs/VkDeviceFaultInfoEXT.adoc[]
--

[open,refpage='VkDeviceFaultAddressInfoEXT',desc='Structure specifying GPU virtual address information',type='structs']
--
The sname:VkDeviceFaultAddressInfoEXT structure is defined as:

include::{generated}/api/structs/VkDeviceFaultAddressInfoEXT.adoc[]

  * pname:addressType is either the type of memory operation that triggered
    a page fault, or the type of association between an instruction pointer
    and a fault.
  * pname:reportedAddress is the GPU virtual address recorded by the device.
  * pname:addressPrecision is a power of two value that specifies how
    precisely the device can report the address.

The combination of pname:reportedAddress and pname:addressPrecision allow
the possible range of addresses to be calculated, such that:

[source,c++]
----
lower_address = (pInfo->reportedAddress & ~(pInfo->addressPrecision-1))
upper_address = (pInfo->reportedAddress |  (pInfo->addressPrecision-1))
----

[NOTE]
====
It is valid for the pname:reportedAddress to contain a more precise address
than indicated by pname:addressPrecision.
In this case, the value of pname:reportedAddress should be treated as an
additional hint as to the value of the address that triggered the page
fault, or to the value of an instruction pointer.
====

include::{generated}/validity/structs/VkDeviceFaultAddressInfoEXT.adoc[]
--

[open,refpage='VkDeviceFaultAddressTypeEXT',desc='Page fault access types',type='enums']
--
Possible values of slink:VkDeviceFaultAddressInfoEXT::pname:addressType are:

include::{generated}/api/enums/VkDeviceFaultAddressTypeEXT.adoc[]

  * ename:VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT specifies that
    slink:VkDeviceFaultAddressInfoEXT does not describe a page fault, or an
    instruction address.
  * ename:VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT specifies that
    slink:VkDeviceFaultAddressInfoEXT describes a page fault triggered by an
    invalid read operation.
  * ename:VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT specifies that
    slink:VkDeviceFaultAddressInfoEXT describes a page fault triggered by an
    invalid write operation.
  * ename:VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT describes a page
    fault triggered by an attempt to execute non-executable memory.
  * ename:VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT
    specifies an instruction pointer value at the time the fault occurred.
    This may or may not be related to a fault.
  * ename:VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT
    specifies an instruction pointer value associated with an invalid
    instruction fault.
  * ename:VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT
    specifies an instruction pointer value associated with a fault.

[NOTE]
====
The instruction pointer values recorded may not identify the specific
instruction(s) that triggered the fault.
The relationship between the instruction pointer reported and triggering
instruction will be vendor-specific.
====
--

[open,refpage='VkDeviceFaultVendorInfoEXT',desc='Structure specifying vendor-specific fault information',type='structs']
--
The sname:VkDeviceFaultVendorInfoEXT structure is defined as:

include::{generated}/api/structs/VkDeviceFaultVendorInfoEXT.adoc[]

  * pname:description is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a human readable
    description of the fault.
  * pname:vendorFaultCode is the vendor-specific fault code for this fault.
  * pname:vendorFaultData is the vendor-specific fault data associated with
    this fault.

include::{generated}/validity/structs/VkDeviceFaultVendorInfoEXT.adoc[]
--


[[vendor-binary-crash-dumps]]
==== Vendor Binary Crash Dumps

Applications can: store the vendor-specific binary crash dump data retrieved
by calling flink:vkGetDeviceFaultInfoEXT for later analysis using external
tools.

However, the format of this data may: depend on the vendor ID, device ID,
driver version, and other details of the device.
To enable external applications to identify the original device from which a
crash dump was generated, the initial bytes written to
sname:VkDeviceFaultInfoEXT::pname:pVendorBinaryData must: begin with a valid
crash dump header.

[open,refpage='VkDeviceFaultVendorBinaryHeaderVersionOneEXT',desc='Structure describing the layout of the vendor binary crash dump header',type='structs']
--
Version one of the crash dump header is defined as:

include::{generated}/api/structs/VkDeviceFaultVendorBinaryHeaderVersionOneEXT.adoc[]

  * pname:headerSize is the length in bytes of the crash dump header.
  * pname:headerVersion is a elink:VkDeviceFaultVendorBinaryHeaderVersionEXT
    enum value specifying the version of the header.
    A consumer of the crash dump should: use the header version to interpret
    the remainder of the header.
    pname:headerVersion must: be written as exactly 4 bytes.
  * pname:vendorID is the sname:VkPhysicalDeviceProperties::pname:vendorID
    of the implementation.
  * pname:deviceID is the sname:VkPhysicalDeviceProperties::pname:deviceID
    of the implementation.
  * pname:driverVersion is the
    sname:VkPhysicalDeviceProperties::pname:driverVersion of the
    implementation.
  * pname:pipelineCacheUUID is an array of ename:VK_UUID_SIZE code:uint8_t
    values matching the
    sname:VkPhysicalDeviceProperties::pname:pipelineCacheUUID property of
    the implementation.
  * pname:applicationNameOffset is zero, or an offset from the base address
    of the crash dump header to a null-terminated UTF-8 string containing
    the name of the application.
    If pname:applicationNameOffset is non-zero, this string must: match the
    application name specified via
    slink:VkApplicationInfo::pname:pApplicationName during instance
    creation.
  * pname:applicationVersion must: be zero or the value specified by
    slink:VkApplicationInfo::pname:applicationVersion during instance
    creation.
  * pname:engineNameOffset is zero, or an offset from the base address of
    the crash dump header to a null-terminated UTF-8 string containing the
    name of the engine (if any) used to create the application.
    If pname:engineNameOffset is non-zero, this string must: match the
    engine name specified via slink:VkApplicationInfo::pname:pEngineName
    during instance creation.
  * pname:engineVersion must: be zero or the value specified by
    slink:VkApplicationInfo::pname:engineVersion during instance creation.
  * pname:apiVersion must: be zero or the value specified by
    slink:VkApplicationInfo::pname:apiVersion during instance creation.

:binary_blob_size: 56
include::{chapters}/pipelines.adoc[tag=binary_blob_header]

.Valid Usage
****
  * [[VUID-VkDeviceFaultVendorBinaryHeaderVersionOneEXT-headerSize-07340]]
    pname:headerSize must: be 56
  * [[VUID-VkDeviceFaultVendorBinaryHeaderVersionOneEXT-headerVersion-07341]]
    pname:headerVersion must: be
    ename:VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT
****

include::{generated}/validity/structs/VkDeviceFaultVendorBinaryHeaderVersionOneEXT.adoc[]
--

[open,refpage='VkDeviceFaultVendorBinaryHeaderVersionEXT',desc='Encode vendor binary crash dump version',type='enums',xrefs='vkGetDeviceFaultInfoEXT']
--
Possible values of the pname:headerVersion value of the crash dump header
are:

include::{generated}/api/enums/VkDeviceFaultVendorBinaryHeaderVersionEXT.adoc[]

  * ename:VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT specifies
    version one of the binary crash dump header.
--
endif::VK_EXT_device_fault[]


ifdef::VK_BASE_VERSION_1_3,VK_EXT_tooling_info[]
[[debugging-tooling-info]]
== Active Tooling Information

[open,refpage='vkGetPhysicalDeviceToolProperties',desc='Reports properties of tools active on the specified physical device',type='protos']
--
Information about tools providing debugging, profiling, or similar services,
active for a given physical device, can be obtained by calling:

ifdef::VK_BASE_VERSION_1_3[]
include::{generated}/api/protos/vkGetPhysicalDeviceToolProperties.adoc[]
endif::VK_BASE_VERSION_1_3[]

ifdef::VK_EXT_tooling_info[]
include::{generated}/api/protos/vkGetPhysicalDeviceToolPropertiesEXT.adoc[]
endif::VK_EXT_tooling_info[]

  * pname:physicalDevice is the handle to the physical device to query for
    active tools.
  * pname:pToolCount is a pointer to an integer describing the number of
    tools active on pname:physicalDevice.
  * pname:pToolProperties is either `NULL` or a pointer to an array of
    slink:VkPhysicalDeviceToolProperties structures.

If pname:pToolProperties is `NULL`, then the number of tools currently
active on pname:physicalDevice is returned in pname:pToolCount.
Otherwise, pname:pToolCount must: point to a variable set by the application
to the number of elements in the pname:pToolProperties array, and on return
the variable is overwritten with the number of structures actually written
to pname:pToolProperties.
If pname:pToolCount is less than the number of currently active tools, at
most pname:pToolCount structures will be written.

The count and properties of active tools may: change in response to events
outside the scope of the specification.
An application should: assume these properties might change at any given
time.

include::{generated}/validity/protos/vkGetPhysicalDeviceToolProperties.adoc[]
--

[open,refpage='VkPhysicalDeviceToolProperties',desc='Structure providing information about an active tool',type='structs']
--
The slink:VkPhysicalDeviceToolProperties structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceToolProperties.adoc[]

ifdef::VK_EXT_tooling_info[]
include::{generated}/api/structs/VkPhysicalDeviceToolPropertiesEXT.adoc[]
endif::VK_EXT_tooling_info[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:name is a null-terminated UTF-8 string containing the name of the
    tool.
  * pname:version is a null-terminated UTF-8 string containing the version
    of the tool.
  * pname:purposes is a bitmask of elink:VkToolPurposeFlagBits which is
    populated with purposes supported by the tool.
  * pname:description is a null-terminated UTF-8 string containing a
    description of the tool.
  * pname:layer is a null-terminated UTF-8 string containing the name of the
    layer implementing the tool, if the tool is implemented in a layer -
    otherwise it may: be an empty string.

include::{generated}/validity/structs/VkPhysicalDeviceToolProperties.adoc[]
--

[open,refpage='VkToolPurposeFlagBits',desc='Bitmask specifying the purposes of an active tool',type='enums']
--
Bits which can: be set in
slink:VkPhysicalDeviceToolProperties::pname:purposes, specifying the
purposes of an active tool, are:

include::{generated}/api/enums/VkToolPurposeFlagBits.adoc[]

ifdef::VK_EXT_tooling_info[]
include::{generated}/api/enums/VkToolPurposeFlagBitsEXT.adoc[]
endif::VK_EXT_tooling_info[]

  * ename:VK_TOOL_PURPOSE_VALIDATION_BIT specifies that the tool provides
    validation of API usage.
  * ename:VK_TOOL_PURPOSE_PROFILING_BIT specifies that the tool provides
    profiling of API usage.
  * ename:VK_TOOL_PURPOSE_TRACING_BIT specifies that the tool is capturing
    data about the application's API usage, including anything from simple
    logging to capturing data for later replay.
  * ename:VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT specifies that the tool
    provides additional API features/extensions on top of the underlying
    implementation.
  * ename:VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT specifies that the tool
    modifies the API features/limits/extensions presented to the
    application.
ifdef::VK_EXT_debug_report,VK_EXT_debug_utils[]
  * ename:VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT specifies that the tool
    reports additional information to the application via callbacks
    specified by
ifdef::VK_EXT_debug_report[]
    flink:vkCreateDebugReportCallbackEXT
endif::VK_EXT_debug_report[]
ifdef::VK_EXT_debug_report+VK_EXT_debug_utils[]
    or
endif::VK_EXT_debug_report+VK_EXT_debug_utils[]
ifdef::VK_EXT_debug_utils[]
    flink:vkCreateDebugUtilsMessengerEXT
endif::VK_EXT_debug_utils[]
endif::VK_EXT_debug_report,VK_EXT_debug_utils[]
ifdef::VK_EXT_debug_marker,VK_EXT_debug_utils[]
  * ename:VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT specifies that the tool
    consumes
ifdef::VK_EXT_debug_marker[]
    <<debugging-debug-markers,debug markers>>
endif::VK_EXT_debug_marker[]
ifdef::VK_EXT_debug_marker+VK_EXT_debug_utils[]
    or
endif::VK_EXT_debug_marker+VK_EXT_debug_utils[]
ifdef::VK_EXT_debug_utils[]
    <<debugging-object-debug-annotation,object debug annotation>>,
    <<debugging-queue-labels, queue labels>>, or
    <<debugging-command-buffer-labels, command buffer labels>>
endif::VK_EXT_debug_utils[]
endif::VK_EXT_debug_marker,VK_EXT_debug_utils[]
--

[open,refpage='VkToolPurposeFlags',desc='Bitmask of VkToolPurposeFlagBits',type='flags']
--
include::{generated}/api/flags/VkToolPurposeFlags.adoc[]

ifdef::VK_EXT_tooling_info[]
include::{generated}/api/flags/VkToolPurposeFlagsEXT.adoc[]
endif::VK_EXT_tooling_info[]

tlink:VkToolPurposeFlags is a bitmask type for setting a mask of zero or
more elink:VkToolPurposeFlagBits.
--
endif::VK_BASE_VERSION_1_3,VK_EXT_tooling_info[]


ifdef::VK_EXT_frame_boundary[]
== Frame Boundary

[open,refpage='VkFrameBoundaryEXT',desc='Add frame boundary information to queue submissions',type='structs']
--
The sname:VkFrameBoundaryEXT structure is defined as:

include::{generated}/api/structs/VkFrameBoundaryEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkFrameBoundaryFlagBitsEXT that can
    flag the last submission of a frame identifier.
  * pname:frameID is the frame identifier.
  * pname:imageCount is the number of images that store frame results.
  * pname:pImages is a pointer to an array of VkImage objects with
    imageCount entries.
  * pname:bufferCount is the number of buffers the store the frame results.
  * pname:pBuffers is a pointer to an array of VkBuffer objects with
    bufferCount entries.
  * pname:tagName is a numerical identifier for tag data.
  * pname:tagSize is the number of bytes of tag data.
  * pname:pTag is a pointer to an array of pname:tagSize bytes containing
    tag data.

The application can: associate frame boundary information to a queue
submission call by adding a sname:VkFrameBoundaryEXT structure to the
pname:pNext chain of <<devsandqueues-submission,queue submission>>,
ifdef::VK_KHR_swapchain[slink:VkPresentInfoKHR,]
or slink:VkBindSparseInfo.

[NOTE]
====
The frame identifier is used to associate one or more queue submissions to a
frame.
It is meant to be unique within a frame lifetime, i.e. it is possible
(though not recommended) to reuse frame identifiers, as long as any two
frames that may have overlapping queue submissions (as in the example above)
use different frame identifiers.

Since the concept of frame is application-dependent, there is no way to
validate the use of frame identifier.
It is good practice to use a monotonically increasing counter as the frame
identifier and not reuse identifiers between frames.
====

The pname:pImages and pname:pBuffers arrays contain a list of images and
buffers which store the "`end result`" of the frame.
As the concept of frame is application-dependent, not all frames may:
produce their results in images or buffers, yet this is a sufficiently
common case to be handled by sname:VkFrameBoundaryEXT.
Note that no extra information, such as image layout is being provided,
since the images are meant to be used by tools which would already be
tracking this required information.
ifdef::VK_KHR_swapchain[]
Having the possibility of passing a list of end-result images makes
sname:VkFrameBoundaryEXT as expressive as flink:vkQueuePresentKHR, which is
often the default frame boundary delimiter.
endif::VK_KHR_swapchain[]

The application can: also associate arbitrary extra information via tag data
using pname:tagName, pname:tagSize and pname:pTag.
This extra information is typically tool-specific.

include::{generated}/validity/structs/VkFrameBoundaryEXT.adoc[]
--

[open,refpage='VkFrameBoundaryFlagBitsEXT',desc='Bitmask specifying whether a queue submission is the last one for a given frame',type='enums']
--
The bit which can: be set in slink:VkFrameBoundaryEXT::pname:flags is:

include::{generated}/api/enums/VkFrameBoundaryFlagBitsEXT.adoc[]

  * ename:VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT specifies that this queue
    submission is the last one for this frame, i.e. once this queue
    submission has terminated, then the work for this frame is completed.
--

ifdef::VK_BASE_VERSION_1_2,VK_KHR_timeline_semaphore[]
Note that in the presence of timeline semaphores, the last queue submission
might not be the last one to be submitted, as timeline semaphores allow for
wait-before-signal submissions.
In the context of frame boundary, the queue submission that should be done
flagged as the last one is the one that is meant to be executed last, even
if it may: not be the last one to be submitted.
endif::VK_BASE_VERSION_1_2,VK_KHR_timeline_semaphore[]

[open,refpage='VkFrameBoundaryFlagsEXT',desc='Bitmask of VkFrameBoundaryFlagBitsEXT',type='flags']
--
include::{generated}/api/flags/VkFrameBoundaryFlagsEXT.adoc[]

tlink:VkFrameBoundaryFlagsEXT is a bitmask type for setting a mask of zero
or more elink:VkFrameBoundaryFlagBitsEXT.
--

ifdef::VK_ARM_tensors[]
[open,refpage='VkFrameBoundaryTensorsARM',desc='Add tensor frame boundary information to queue submissions',type='structs']
--
The sname:VkFrameBoundaryTensorsARM structure is defined as:

include::{generated}/api/structs/VkFrameBoundaryTensorsARM.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:tensorCount is the number of tensors that store frame results.
  * pname:pTensors is a pointer to an array of slink:VkTensorARM objects
    with tensorCount entries.

include::{generated}/validity/structs/VkFrameBoundaryTensorsARM.adoc[]
--
endif::VK_ARM_tensors[]

endif::VK_EXT_frame_boundary[]
