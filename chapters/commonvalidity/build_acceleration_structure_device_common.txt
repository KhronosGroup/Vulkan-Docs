// Copyright 2019-2021 The Khronos Group Inc.
//
// SPDX-License-Identifier: CC-BY-4.0

// Common Valid Usage
// Common to acceleration structure build commands executed on the device
  * [[VUID-{refpage}-pInfos-03707]]
    For each element of pname:pInfos, the pname:buffer used to create its
    pname:dstAccelerationStructure member must: be bound to device memory
  * [[VUID-{refpage}-pInfos-03708]]
    For each element of pname:pInfos, if its pname:mode member is
    ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR the pname:buffer
    used to create its pname:srcAccelerationStructure member must: be bound
    to device memory
  * [[VUID-{refpage}-pInfos-03709]]
    For each element of pname:pInfos, the pname:buffer used to create each
    acceleration structure referenced by the pname:geometry.instances.data
    member of any element of pname:pGeometries or pname:ppGeometries with a
    pname:geometryType of ename:VK_GEOMETRY_TYPE_INSTANCES_KHR must: be
    bound to device memory
  * [[VUID-{refpage}-pInfos-03671]]
    If pname:pInfos[i].pname:mode is
    ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR, all addresses
    between pname:pInfos[i].pname:scratchData.deviceAddress and
    pname:pInfos[i].pname:scratchData.deviceAddress {plus} N - 1 must: be in
    the buffer device address range of the same buffer, where N is given by
    the pname:buildScratchSize member of the
    slink:VkAccelerationStructureBuildSizesInfoKHR structure returned from a
    call to flink:vkGetAccelerationStructureBuildSizesKHR with an identical
    slink:VkAccelerationStructureBuildGeometryInfoKHR structure and
    primitive count
  * [[VUID-{refpage}-pInfos-03672]]
    If pname:pInfos[i].pname:mode is
    ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, all addresses
    between pname:pInfos[i].pname:scratchData.deviceAddress and
    pname:pInfos[i].pname:scratchData.deviceAddress {plus} N - 1 must: be in
    the buffer device address range of the same buffer, where N is given by
    the pname:updateScratchSize member of the
    slink:VkAccelerationStructureBuildSizesInfoKHR structure returned from a
    call to flink:vkGetAccelerationStructureBuildSizesKHR with an identical
    slink:VkAccelerationStructureBuildGeometryInfoKHR structure and
    primitive count
  * [[VUID-{refpage}-geometry-03673]]
    The buffers from which the buffer device addresses for all of the
    pname:geometry.triangles.vertexData, pname:geometry.triangles.indexData,
    pname:geometry.triangles.transformData, pname:geometry.aabbs.data, and
    pname:geometry.instances.data members of all
    pname:pInfos[i].pname:pGeometries and pname:pInfos[i].pname:ppGeometries
    are queried must: have been created with the
    ename:VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR
    usage flag
  * [[VUID-{refpage}-pInfos-03674]]
    The buffer from which the buffer device address
    pname:pInfos[i].pname:scratchData.deviceAddress is queried must: have
    been created with ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT usage flag
  * [[VUID-{refpage}-pInfos-03802]]
    For each element of pname:pInfos, its pname:scratchData.deviceAddress
    member must: be a valid device address obtained from
    flink:vkGetBufferDeviceAddress
  * [[VUID-{refpage}-pInfos-03803]]
    For each element of pname:pInfos, if pname:scratchData.deviceAddress is
    the address of a non-sparse buffer then it must: be bound completely and
    contiguously to a single slink:VkDeviceMemory object
  * [[VUID-{refpage}-pInfos-03710]]
    For each element of pname:pInfos, its pname:scratchData.deviceAddress
    member must: be a multiple of
    slink:VkPhysicalDeviceAccelerationStructurePropertiesKHR::pname:minAccelerationStructureScratchOffsetAlignment
  * [[VUID-{refpage}-pInfos-03804]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR,
    pname:geometry.triangles.vertexData.deviceAddress must: be a valid
    device address obtained from flink:vkGetBufferDeviceAddress
  * [[VUID-{refpage}-pInfos-03805]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if
    pname:geometry.triangles.vertexData.deviceAddress is the address of a
    non-sparse buffer then it must: be bound completely and contiguously to
    a single slink:VkDeviceMemory object
  * [[VUID-{refpage}-pInfos-03711]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR,
    pname:geometry.triangles.vertexData.deviceAddress must: be aligned to
    the size in bytes of the smallest component of the format in
    pname:vertexFormat
  * [[VUID-{refpage}-pInfos-03806]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if
    pname:geometry.triangles.indexType is not ename:VK_INDEX_TYPE_NONE_KHR,
    pname:geometry.triangles.indexData.deviceAddress must: be a valid device
    address obtained from flink:vkGetBufferDeviceAddress
  * [[VUID-{refpage}-pInfos-03807]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if
    pname:geometry.triangles.indexType is not ename:VK_INDEX_TYPE_NONE_KHR,
    if pname:geometry.triangles.indexData.deviceAddress is the address of a
    non-sparse buffer then it must: be bound completely and contiguously to
    a single slink:VkDeviceMemory object
  * [[VUID-{refpage}-pInfos-03712]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, and with
    pname:geometry.triangles.indexType not equal to
    ename:VK_INDEX_TYPE_NONE_KHR,
    pname:geometry.triangles.indexData.deviceAddress must: be aligned to the
    size in bytes of the type in pname:indexType
  * [[VUID-{refpage}-pInfos-03808]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if
    pname:geometry.triangles.transformData.deviceAddress is not `0`, it
    must: be a valid device address obtained from
    flink:vkGetBufferDeviceAddress
  * [[VUID-{refpage}-pInfos-03809]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if
    pname:geometry.triangles.transformData.deviceAddress is the address of a
    non-sparse buffer then it must: be bound completely and contiguously to
    a single slink:VkDeviceMemory object
  * [[VUID-{refpage}-pInfos-03810]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if
    pname:geometry.triangles.transformData.deviceAddress is not `0`, it
    must: be aligned to `16` bytes
  * [[VUID-{refpage}-pInfos-03811]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_AABBS_KHR,
    pname:geometry.aabbs.data.deviceAddress must: be a valid device address
    obtained from flink:vkGetBufferDeviceAddress
  * [[VUID-{refpage}-pInfos-03812]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_AABBS_KHR, if
    pname:geometry.aabbs.data.deviceAddress is the address of a non-sparse
    buffer then it must: be bound completely and contiguously to a single
    slink:VkDeviceMemory object
  * [[VUID-{refpage}-pInfos-03714]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_AABBS_KHR,
    pname:geometry.aabbs.data.deviceAddress must: be aligned to `8` bytes
  * [[VUID-{refpage}-pInfos-03715]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_INSTANCES_KHR, if pname:geometry.arrayOfPointers
    is ename:VK_FALSE, pname:geometry.instances.data.deviceAddress must: be
    aligned to `16` bytes
  * [[VUID-{refpage}-pInfos-03716]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_INSTANCES_KHR, if pname:geometry.arrayOfPointers
    is ename:VK_TRUE, pname:geometry.instances.data.deviceAddress must: be
    aligned to `8` bytes
  * [[VUID-{refpage}-pInfos-03717]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_INSTANCES_KHR, if pname:geometry.arrayOfPointers
    is ename:VK_TRUE, each element of
    pname:geometry.instances.data.deviceAddress in device memory must: be
    aligned to `16` bytes
  * [[VUID-{refpage}-pInfos-03813]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_INSTANCES_KHR,
    pname:geometry.instances.data.deviceAddress must: be a valid device
    address obtained from flink:vkGetBufferDeviceAddress
  * [[VUID-{refpage}-pInfos-03814]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_INSTANCES_KHR, if
    pname:geometry.instances.data.deviceAddress is the address of a
    non-sparse buffer then it must: be bound completely and contiguously to
    a single slink:VkDeviceMemory object
  * [[VUID-{refpage}-pInfos-03815]]
    For any element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_INSTANCES_KHR, each
    slink:VkAccelerationStructureInstanceKHR::pname:accelerationStructureReference
    value in pname:geometry.instances.data.deviceAddress must: be a valid
    device address containing a value obtained from
    flink:vkGetAccelerationStructureDeviceAddressKHR
// Common Valid Usage
