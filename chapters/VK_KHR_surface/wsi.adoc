// Copyright 2014-2026 The Khronos Group Inc.
// Copyright (c) 2021 BlackBerry Limited.
// Copyright (c) 2018-2020 The Brenwill Workshop Ltd.
// Copyright (c) 2018-2020 Google LLC
// Copyright (c) 2025 Huawei Technologies Co. Ltd.
// Copyright (c) 2018-2020 Nintendo
// Copyright (c) 2018-2022 NVIDIA Corporation.
// SPDX-License-Identifier: CC-BY-4.0

[[wsi]]
= Window System Integration (WSI)

This chapter discusses the window system integration (WSI) between the
Vulkan API and the various forms of displaying the results of rendering to a
user.
Since the Vulkan API can: be used without displaying results, WSI is
provided through the use of optional Vulkan extensions.
This chapter provides an overview of WSI.
See the appendix for additional details of each WSI extension, including
which extensions must: be enabled in order to use each of the functions
described in this chapter.


== WSI Platform

A platform is an abstraction for a window system, OS, etc.
Some examples include MS Windows, Android, and Wayland.
The Vulkan API may: be integrated in a unique manner for each platform.

The Vulkan API does not define any type of platform object.
Platform-specific WSI extensions are defined, each containing
platform-specific functions for using WSI.
Use of these extensions is guarded by preprocessor symbols as defined in the
<<boilerplate-wsi-header,Window System-Specific Header Control>> appendix.

In order for an application to be compiled to use WSI with a given platform,
it must: either:

  * `#define` the appropriate preprocessor symbol prior to including the
    `{full_header}` header file, or
  * include `{core_header}` and any native platform headers, followed by the
    appropriate platform-specific header.

The preprocessor symbols and platform-specific headers are defined in the
<<boilerplate-wsi-header-table, Window System Extensions and Headers>>
table.

Each platform-specific extension is an instance extension.
The application must: enable instance extensions with fname:vkCreateInstance
before using them.


== WSI Surface

[open,refpage='VkSurfaceKHR',desc='Opaque handle to a surface object',type='handles']
--
Native platform surface or window objects are abstracted by surface objects,
which are represented by sname:VkSurfaceKHR handles:

include::{generated}/api/handles/VkSurfaceKHR.adoc[]

The `apiext:VK_KHR_surface` extension declares the sname:VkSurfaceKHR
object, and provides a function for destroying sname:VkSurfaceKHR objects.
Separate platform-specific extensions each provide a function for creating a
sname:VkSurfaceKHR object for the respective platform.
From the application's perspective this is an opaque handle, just like the
handles of other Vulkan objects.

ifdef::implementation-guide[]
[NOTE]
====
On certain platforms, the Vulkan loader and ICDs may: have conventions that
treat the handle as a pointer to a structure containing the
platform-specific information about the surface.
This will be described in the documentation for the loader-ICD interface,
and in the `vk_icd.h` header file of the LoaderAndTools source-code
repository.
This does not affect the loader-layer interface; layers may: wrap
sname:VkSurfaceKHR objects.
====
endif::implementation-guide[]
--


ifdef::VK_KHR_android_surface[]
[[platformCreateSurface_android]]
=== Android Platform

[open,refpage='vkCreateAndroidSurfaceKHR',desc='Create a slink:VkSurfaceKHR object for an Android native window',type='protos']
--
:refpage: vkCreateAndroidSurfaceKHR

To create a sname:VkSurfaceKHR object for an Android native window, call:

include::{generated}/api/protos/vkCreateAndroidSurfaceKHR.adoc[]

  * pname:instance is the instance to associate the surface with.
  * pname:pCreateInfo is a pointer to a slink:VkAndroidSurfaceCreateInfoKHR
    structure containing parameters affecting the creation of the surface
    object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

During the lifetime of a surface created using a particular
basetype:ANativeWindow handle any attempts to create another surface for the
same basetype:ANativeWindow and any attempts to connect to the same
basetype:ANativeWindow through other platform mechanisms will fail.

[NOTE]
====
In particular, only one sname:VkSurfaceKHR can: exist at a time for a given
window.
Similarly, a native window cannot: be used by both a sname:VkSurfaceKHR and
code:EGLSurface simultaneously.
====

If successful, fname:vkCreateAndroidSurfaceKHR increments the
basetype:ANativeWindow's reference count, and fname:vkDestroySurfaceKHR will
decrement it.

On Android, when a swapchain's pname:imageExtent does not match the
surface's pname:currentExtent, the presentable images will be scaled to the
surface's dimensions during presentation.
pname:minImageExtent is [eq]#(1,1)#, and pname:maxImageExtent is the maximum
image size supported by the consumer.
For the system compositor, pname:currentExtent is the window size (i.e. the
consumer's preferred size).

include::{generated}/validity/protos/vkCreateAndroidSurfaceKHR.adoc[]
--

[open,refpage='VkAndroidSurfaceCreateInfoKHR',desc='Structure specifying parameters of a newly created Android surface object',type='structs']
--
The sname:VkAndroidSurfaceCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkAndroidSurfaceCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:window is a pointer to the basetype:ANativeWindow to associate the
    surface with.

.Valid Usage
****
  * [[VUID-VkAndroidSurfaceCreateInfoKHR-window-01248]]
    pname:window must: point to a valid Android basetype:ANativeWindow
****

include::{generated}/validity/structs/VkAndroidSurfaceCreateInfoKHR.adoc[]
--

[open,refpage='ANativeWindow',desc='Android native window type',type='basetypes']
--
To remove an unnecessary compile time dependency, an incomplete type
definition of basetype:ANativeWindow is provided in the Vulkan headers:

include::{generated}/api/basetypes/ANativeWindow.adoc[]

The actual basetype:ANativeWindow type is defined in Android NDK headers.
--

[open,refpage='VkAndroidSurfaceCreateFlagsKHR',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkAndroidSurfaceCreateFlagsKHR.adoc[]

tname:VkAndroidSurfaceCreateFlagsKHR is a bitmask type for setting a mask,
but is currently reserved for future use.
--
endif::VK_KHR_android_surface[]


ifdef::VK_KHR_wayland_surface[]
[[platformCreateSurface_wayland]]
=== Wayland Platform

[open,refpage='vkCreateWaylandSurfaceKHR',desc='Create a slink:VkSurfaceKHR object for a Wayland window',type='protos']
--
:refpage: vkCreateWaylandSurfaceKHR

To create a sname:VkSurfaceKHR object for a Wayland surface, call:

include::{generated}/api/protos/vkCreateWaylandSurfaceKHR.adoc[]

  * pname:instance is the instance to associate the surface with.
  * pname:pCreateInfo is a pointer to a slink:VkWaylandSurfaceCreateInfoKHR
    structure containing parameters affecting the creation of the surface
    object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

include::{generated}/validity/protos/vkCreateWaylandSurfaceKHR.adoc[]
--

[open,refpage='VkWaylandSurfaceCreateInfoKHR',desc='Structure specifying parameters of a newly created Wayland surface object',type='structs']
--
The sname:VkWaylandSurfaceCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkWaylandSurfaceCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:display and pname:surface are pointers to the Wayland
    code:wl_display and code:wl_surface to associate the surface with.

.Valid Usage
****
  * [[VUID-VkWaylandSurfaceCreateInfoKHR-display-01304]]
    pname:display must: point to a valid Wayland code:wl_display
  * [[VUID-VkWaylandSurfaceCreateInfoKHR-surface-01305]]
    pname:surface must: point to a valid Wayland code:wl_surface
****

include::{generated}/validity/structs/VkWaylandSurfaceCreateInfoKHR.adoc[]
--

On Wayland, pname:currentExtent is the special value [eq]#(0xFFFFFFFF,
0xFFFFFFFF)#, indicating that the surface size will be determined by the
extent of a swapchain targeting the surface.
Whatever the application sets a swapchain's pname:imageExtent to will be the
size of the window, after the first image is presented.
pname:minImageExtent is [eq]#(1,1)#, and pname:maxImageExtent is the maximum
supported surface size.
Any calls to flink:vkGetPhysicalDeviceSurfacePresentModesKHR on a surface
created with fname:vkCreateWaylandSurfaceKHR are required: to return
ename:VK_PRESENT_MODE_MAILBOX_KHR as one of the valid present modes.

Some Vulkan functions may: send protocol over the specified code:wl_display
connection when using a swapchain or presentable images created from a
sname:VkSurfaceKHR referring to a code:wl_surface.
Applications must: therefore ensure that both the code:wl_display and the
code:wl_surface remain valid for the lifetime of any sname:VkSwapchainKHR
objects created from a particular code:wl_display and code:wl_surface.
Also, calling flink:vkQueuePresentKHR will result in Vulkan sending
code:wl_surface.commit requests to the underlying code:wl_surface of each
The code:wl_surface.attach, code:wl_surface.damage, and
code:wl_surface.commit requests must: be issued by the implementation during
the call to flink:vkQueuePresentKHR and must: not be issued by the
implementation outside of flink:vkQueuePresentKHR.
This ensures that any Wayland requests sent by the client after the call to
flink:vkQueuePresentKHR returns will be received by the compositor after the
code:wl_surface.commit.
Regardless of the mode of swapchain creation, a new code:wl_event_queue
must: be created for each successful flink:vkCreateWaylandSurfaceKHR call,
and every Wayland object created by the implementation must: be assigned to
this event queue.
If the platform provides Wayland 1.11 or greater, this must: be implemented
by the use of Wayland proxy object wrappers, to avoid race conditions.

If the application wishes to synchronize any window changes with a
particular frame, such requests must: be sent to the Wayland display server
prior to calling flink:vkQueuePresentKHR.

ifdef::VK_EXT_swapchain_colorspace[]
The implementation must: ensure that no code:wp_color_management_surface_v1
object exists for a surface, which has no swapchains, or only swapchains
with a pname:imageColorSpace of ename:VK_COLOR_SPACE_PASS_THROUGH_EXT
associated with it.
endif::VK_EXT_swapchain_colorspace[]

[open,refpage='VkWaylandSurfaceCreateFlagsKHR',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkWaylandSurfaceCreateFlagsKHR.adoc[]

tname:VkWaylandSurfaceCreateFlagsKHR is a bitmask type for setting a mask,
but is currently reserved for future use.
--
endif::VK_KHR_wayland_surface[]


ifdef::VK_KHR_win32_surface[]
[[platformCreateSurface_win32]]
=== Win32 Platform

[open,refpage='vkCreateWin32SurfaceKHR',desc='Create a VkSurfaceKHR object for a Win32 native window',type='protos']
--
:refpage: vkCreateWin32SurfaceKHR

To create a sname:VkSurfaceKHR object for a Win32 window, call:

include::{generated}/api/protos/vkCreateWin32SurfaceKHR.adoc[]

  * pname:instance is the instance to associate the surface with.
  * pname:pCreateInfo is a pointer to a slink:VkWin32SurfaceCreateInfoKHR
    structure containing parameters affecting the creation of the surface
    object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

include::{generated}/validity/protos/vkCreateWin32SurfaceKHR.adoc[]

Some Vulkan functions may: call the `SendMessage` system API when
interacting with a sname:VkSurfaceKHR through a sname:VkSwapchainKHR.
In a multithreaded environment, calling `SendMessage` from a thread that is
not the thread associated with pname:pCreateInfo->hwnd will block until the
application has processed the window message.
Thus, applications should: either call these Vulkan functions on the message
pump thread, or make sure their message pump is actively running.
Failing to do so may: result in deadlocks.

The functions subject to this requirement are:

  * flink:vkCreateSwapchainKHR
  * flink:vkDestroySwapchainKHR
  * flink:vkAcquireNextImageKHR and flink:vkAcquireNextImage2KHR
  * flink:vkQueuePresentKHR
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
  * flink:vkReleaseSwapchainImagesKHR
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
ifdef::VK_EXT_full_screen_exclusive[]
  * flink:vkAcquireFullScreenExclusiveModeEXT
  * flink:vkReleaseFullScreenExclusiveModeEXT
endif::VK_EXT_full_screen_exclusive[]
ifdef::VK_EXT_hdr_metadata[]
  * flink:vkSetHdrMetadataEXT
endif::VK_EXT_hdr_metadata[]
--

[open,refpage='VkWin32SurfaceCreateInfoKHR',desc='Structure specifying parameters of a newly created Win32 surface object',type='structs']
--
The sname:VkWin32SurfaceCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkWin32SurfaceCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:hinstance is the Win32 code:HINSTANCE for the window to associate
    the surface with.
  * pname:hwnd is the Win32 code:HWND for the window to associate the
    surface with.

.Valid Usage
****
  * [[VUID-VkWin32SurfaceCreateInfoKHR-hinstance-01307]]
    pname:hinstance must: be a valid Win32 code:HINSTANCE
  * [[VUID-VkWin32SurfaceCreateInfoKHR-hwnd-01308]]
    pname:hwnd must: be a valid Win32 code:HWND
****

include::{generated}/validity/structs/VkWin32SurfaceCreateInfoKHR.adoc[]
--

With Win32, pname:minImageExtent, pname:maxImageExtent, and
pname:currentExtent must: always equal the window size.

The pname:currentExtent of a Win32 surface must: have both pname:width and
pname:height greater than 0, or both of them 0.

[NOTE]
====
Due to above restrictions,
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
unless slink:VkSwapchainPresentScalingCreateInfoKHR is used to specify
handling of disparities between surface and swapchain dimensions,
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
it is only possible to create a new swapchain on this platform with
pname:imageExtent being equal to the current size of the window, as reported
in slink:VkSurfaceCapabilitiesKHR::pname:currentExtent.

The window size may: become [eq]#(0, 0)# on this platform (e.g. when the
window is minimized), and so a swapchain cannot: be created until the size
changes.
====

[open,refpage='VkWin32SurfaceCreateFlagsKHR',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkWin32SurfaceCreateFlagsKHR.adoc[]

tname:VkWin32SurfaceCreateFlagsKHR is a bitmask type for setting a mask, but
is currently reserved for future use.
--
endif::VK_KHR_win32_surface[]


ifdef::VK_KHR_xcb_surface[]
[[platformCreateSurface_xcb]]
=== XCB Platform

[open,refpage='vkCreateXcbSurfaceKHR',desc='Create a slink:VkSurfaceKHR object for a X11 window, using the XCB client-side library',type='protos']
--
:refpage: vkCreateXcbSurfaceKHR

To create a sname:VkSurfaceKHR object for an X11 window, using the XCB
client-side library, call:

include::{generated}/api/protos/vkCreateXcbSurfaceKHR.adoc[]

  * pname:instance is the instance to associate the surface with.
  * pname:pCreateInfo is a pointer to a slink:VkXcbSurfaceCreateInfoKHR
    structure containing parameters affecting the creation of the surface
    object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

include::{generated}/validity/protos/vkCreateXcbSurfaceKHR.adoc[]
--

[open,refpage='VkXcbSurfaceCreateInfoKHR',desc='Structure specifying parameters of a newly created Xcb surface object',type='structs']
--
The sname:VkXcbSurfaceCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkXcbSurfaceCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:connection is a pointer to an code:xcb_connection_t to the X
    server.
  * pname:window is the code:xcb_window_t for the X11 window to associate
    the surface with.

.Valid Usage
****
  * [[VUID-VkXcbSurfaceCreateInfoKHR-connection-01310]]
    pname:connection must: point to a valid X11 code:xcb_connection_t
  * [[VUID-VkXcbSurfaceCreateInfoKHR-window-01311]]
    pname:window must: be a valid X11 code:xcb_window_t
****

include::{generated}/validity/structs/VkXcbSurfaceCreateInfoKHR.adoc[]
--

With Xcb, pname:minImageExtent, pname:maxImageExtent, and
pname:currentExtent must: always equal the window size.

The pname:currentExtent of an Xcb surface must: have both pname:width and
pname:height greater than 0, or both of them 0.

[NOTE]
====
Due to above restrictions,
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
unless slink:VkSwapchainPresentScalingCreateInfoKHR is used to specify
handling of disparities between surface and swapchain dimensions,
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
it is only possible to create a new swapchain on this platform with
pname:imageExtent being equal to the current size of the window, as reported
in slink:VkSurfaceCapabilitiesKHR::pname:currentExtent.

The window size may: become [eq]#(0, 0)# on this platform (e.g. when the
window is minimized), and so a swapchain cannot: be created until the size
changes.
====

Some Vulkan functions may: send protocol over the specified xcb connection
when using a swapchain or presentable images created from a
slink:VkSurfaceKHR referring to an xcb window.
Applications must: therefore ensure the xcb connection is available to
Vulkan for the duration of any functions that manipulate such swapchains or
their presentable images, and any functions that build or queue command
buffers that operate on such presentable images.
Specifically, applications using Vulkan with xcb-based swapchains must:

  * Avoid holding a server grab on an xcb connection while waiting for
    Vulkan operations to complete using a swapchain derived from a different
    xcb connection referring to the same X server instance.
    Failing to do so may: result in deadlock.

[open,refpage='VkXcbSurfaceCreateFlagsKHR',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkXcbSurfaceCreateFlagsKHR.adoc[]

tname:VkXcbSurfaceCreateFlagsKHR is a bitmask type for setting a mask, but
is currently reserved for future use.
--
endif::VK_KHR_xcb_surface[]


ifdef::VK_KHR_xlib_surface[]
[[platformCreateSurface_xlib]]
=== Xlib Platform

[open,refpage='vkCreateXlibSurfaceKHR',desc='Create a slink:VkSurfaceKHR object for an X11 window, using the Xlib client-side library',type='protos']
--
:refpage: vkCreateXlibSurfaceKHR

To create a sname:VkSurfaceKHR object for an X11 window, using the Xlib
client-side library, call:

include::{generated}/api/protos/vkCreateXlibSurfaceKHR.adoc[]

  * pname:instance is the instance to associate the surface with.
  * pname:pCreateInfo is a pointer to a slink:VkXlibSurfaceCreateInfoKHR
    structure containing the parameters affecting the creation of the
    surface object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

include::{generated}/validity/protos/vkCreateXlibSurfaceKHR.adoc[]
--

[open,refpage='VkXlibSurfaceCreateInfoKHR',desc='Structure specifying parameters of a newly created Xlib surface object',type='structs']
--
The sname:VkXlibSurfaceCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkXlibSurfaceCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:dpy is a pointer to an Xlib code:Display connection to the X
    server.
  * pname:window is an Xlib code:Window to associate the surface with.

.Valid Usage
****
  * [[VUID-VkXlibSurfaceCreateInfoKHR-dpy-01313]]
    pname:dpy must: point to a valid Xlib code:Display
  * [[VUID-VkXlibSurfaceCreateInfoKHR-window-01314]]
    pname:window must: be a valid Xlib code:Window
****

include::{generated}/validity/structs/VkXlibSurfaceCreateInfoKHR.adoc[]
--

With Xlib, pname:minImageExtent, pname:maxImageExtent, and
pname:currentExtent must: always equal the window size.

The pname:currentExtent of an Xlib surface must: have both pname:width and
pname:height greater than 0, or both of them 0.

[NOTE]
====
Due to above restrictions,
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
unless slink:VkSwapchainPresentScalingCreateInfoKHR is used to specify
handling of disparities between surface and swapchain dimensions,
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
it is only possible to create a new swapchain on this platform with
pname:imageExtent being equal to the current size of the window, as reported
in slink:VkSurfaceCapabilitiesKHR::pname:currentExtent.

The window size may: become [eq]#(0, 0)# on this platform (e.g. when the
window is minimized), and so a swapchain cannot: be created until the size
changes.
====

Some Vulkan functions may: send protocol over the specified Xlib
code:Display connection when using a swapchain or presentable images created
from a slink:VkSurfaceKHR referring to an Xlib window.
Applications must: therefore ensure the display connection is available to
Vulkan for the duration of any functions that manipulate such swapchains or
their presentable images, and any functions that build or queue command
buffers that operate on such presentable images.
Specifically, applications using Vulkan with Xlib-based swapchains must:

  * Avoid holding a server grab on a display connection while waiting for
    Vulkan operations to complete using a swapchain derived from a different
    display connection referring to the same X server instance.
    Failing to do so may: result in deadlock.

Some implementations may require threads to implement some presentation
modes so applications must: call code:XInitThreads() before calling any
other Xlib functions.

[open,refpage='VkXlibSurfaceCreateFlagsKHR',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkXlibSurfaceCreateFlagsKHR.adoc[]

tname:VkXlibSurfaceCreateFlagsKHR is a bitmask type for setting a mask, but
is currently reserved for future use.
--
endif::VK_KHR_xlib_surface[]


ifdef::VK_EXT_directfb_surface[]
[[platformCreateSurface_directfb]]
=== DirectFB Platform

[open,refpage='vkCreateDirectFBSurfaceEXT',desc='Create a slink:VkSurfaceKHR object for a DirectFB surface',type='protos']
--
:refpage: vkCreateDirectFBSurfaceEXT

To create a sname:VkSurfaceKHR object for a DirectFB surface, call:

include::{generated}/api/protos/vkCreateDirectFBSurfaceEXT.adoc[]

  * pname:instance is the instance to associate the surface with.
  * pname:pCreateInfo is a pointer to a slink:VkDirectFBSurfaceCreateInfoEXT
    structure containing parameters affecting the creation of the surface
    object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

include::{generated}/validity/protos/vkCreateDirectFBSurfaceEXT.adoc[]
--

[open,refpage='VkDirectFBSurfaceCreateInfoEXT',desc='Structure specifying parameters of a newly created DirectFB surface object',type='structs']
--
The sname:VkDirectFBSurfaceCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkDirectFBSurfaceCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:dfb is a pointer to the code:IDirectFB main interface of DirectFB.
  * pname:surface is a pointer to a code:IDirectFBSurface surface interface.

.Valid Usage
****
  * [[VUID-VkDirectFBSurfaceCreateInfoEXT-dfb-04117]]
    pname:dfb must: point to a valid DirectFB code:IDirectFB
  * [[VUID-VkDirectFBSurfaceCreateInfoEXT-surface-04118]]
    pname:surface must: point to a valid DirectFB code:IDirectFBSurface
****

include::{generated}/validity/structs/VkDirectFBSurfaceCreateInfoEXT.adoc[]
--

With DirectFB, pname:minImageExtent, pname:maxImageExtent, and
pname:currentExtent must: always equal the surface size.

[open,refpage='VkDirectFBSurfaceCreateFlagsEXT',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkDirectFBSurfaceCreateFlagsEXT.adoc[]

tname:VkDirectFBSurfaceCreateFlagsEXT is a bitmask type for setting a mask,
but is currently reserved for future use.
--
endif::VK_EXT_directfb_surface[]


ifdef::VK_FUCHSIA_imagepipe_surface[]
[[platformCreateSurface_imagepipe]]
=== Fuchsia Platform

[open,refpage='vkCreateImagePipeSurfaceFUCHSIA',desc='Create a slink:VkSurfaceKHR object for a Fuchsia ImagePipe',type='protos']
--
:refpage: vkCreateImagePipeSurfaceFUCHSIA

To create a sname:VkSurfaceKHR object for a Fuchsia ImagePipe, call:

include::{generated}/api/protos/vkCreateImagePipeSurfaceFUCHSIA.adoc[]

  * pname:instance is the instance to associate with the surface.
  * pname:pCreateInfo is a pointer to a
    slink:VkImagePipeSurfaceCreateInfoFUCHSIA structure containing
    parameters affecting the creation of the surface object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

include::{generated}/validity/protos/vkCreateImagePipeSurfaceFUCHSIA.adoc[]
--

[open,refpage='VkImagePipeSurfaceCreateInfoFUCHSIA',desc='Structure specifying parameters of a newly created ImagePipe surface object',type='structs']
--
The sname:VkImagePipeSurfaceCreateInfoFUCHSIA structure is defined as:

include::{generated}/api/structs/VkImagePipeSurfaceCreateInfoFUCHSIA.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:imagePipeHandle is a code:zx_handle_t referring to the ImagePipe
    to associate with the surface.

.Valid Usage
****
  * [[VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-imagePipeHandle-04863]]
    pname:imagePipeHandle must: be a valid code:zx_handle_t
****

include::{generated}/validity/structs/VkImagePipeSurfaceCreateInfoFUCHSIA.adoc[]
--

On Fuchsia, the surface pname:currentExtent is the special value
[eq]#(0xFFFFFFFF, 0xFFFFFFFF)#, indicating that the surface size will be
determined by the extent of a swapchain targeting the surface.

[open,refpage='VkImagePipeSurfaceCreateFlagsFUCHSIA',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkImagePipeSurfaceCreateFlagsFUCHSIA.adoc[]

tname:VkImagePipeSurfaceCreateFlagsFUCHSIA is a bitmask type for setting a
mask, but is currently reserved for future use.
--
endif::VK_FUCHSIA_imagepipe_surface[]


ifdef::VK_GGP_stream_descriptor_surface[]
[[platformCreateSurface_streamdescriptor]]
=== Google Games Platform

[open,refpage='vkCreateStreamDescriptorSurfaceGGP',desc='Create a slink:VkSurfaceKHR object for a Google Games Platform stream',type='protos']
--
:refpage: vkCreateStreamDescriptorSurfaceGGP

To create a sname:VkSurfaceKHR object for a Google Games Platform stream
descriptor, call:

include::{generated}/api/protos/vkCreateStreamDescriptorSurfaceGGP.adoc[]

  * pname:instance is the instance to associate with the surface.
  * pname:pCreateInfo is a pointer to a
    sname:VkStreamDescriptorSurfaceCreateInfoGGP structure containing
    parameters that affect the creation of the surface object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

include::{generated}/validity/protos/vkCreateStreamDescriptorSurfaceGGP.adoc[]
--

[open,refpage='VkStreamDescriptorSurfaceCreateInfoGGP',desc='Structure specifying parameters of a newly created Google Games Platform stream surface object',type='structs']
--
The sname:VkStreamDescriptorSurfaceCreateInfoGGP structure is defined as:

include::{generated}/api/structs/VkStreamDescriptorSurfaceCreateInfoGGP.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:streamDescriptor is a code:GgpStreamDescriptor referring to the
    GGP stream descriptor to associate with the surface.

.Valid Usage
****
  * [[VUID-VkStreamDescriptorSurfaceCreateInfoGGP-streamDescriptor-02681]]
    pname:streamDescriptor must: be a valid code:GgpStreamDescriptor
****

include::{generated}/validity/structs/VkStreamDescriptorSurfaceCreateInfoGGP.adoc[]
--

On Google Games Platform, the surface extents are dynamic.
The pname:minImageExtent will never be greater than 1080p and the
pname:maxImageExtent will never be less than 1080p.
The pname:currentExtent will reflect the current optimal resolution.

ifdef::VK_KHR_swapchain[]
Applications are expected to choose an appropriate size for the swapchain's
pname:imageExtent, within the bounds of the surface.
Using the surface's pname:currentExtent will offer the best performance and
quality.
When a swapchain's pname:imageExtent does not match the surface's
pname:currentExtent, the presentable images are scaled to the surface's
dimensions during presentation if possible and ename:VK_SUBOPTIMAL_KHR is
returned, otherwise presentation fails with ename:VK_ERROR_OUT_OF_DATE_KHR.
endif::VK_KHR_swapchain[]

[open,refpage='VkStreamDescriptorSurfaceCreateFlagsGGP',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkStreamDescriptorSurfaceCreateFlagsGGP.adoc[]

tname:VkStreamDescriptorSurfaceCreateFlagsGGP is a bitmask type for setting
a mask, but is currently reserved for future use.
--
endif::VK_GGP_stream_descriptor_surface[]


ifdef::VK_MVK_ios_surface[]
[[platformCreateSurface_ios]]
=== iOS Platform

[open,refpage='vkCreateIOSSurfaceMVK',desc='Create a VkSurfaceKHR object for an iOS UIView',type='protos']
--
:refpage: vkCreateIOSSurfaceMVK

To create a sname:VkSurfaceKHR object for an iOS code:UIView or
basetype:CAMetalLayer, call:

include::{generated}/api/protos/vkCreateIOSSurfaceMVK.adoc[]

  * pname:instance is the instance with which to associate the surface.
  * pname:pCreateInfo is a pointer to a slink:VkIOSSurfaceCreateInfoMVK
    structure containing parameters affecting the creation of the surface
    object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

ifdef::VK_EXT_metal_surface[]
[NOTE]
====
The `vkCreateIOSSurfaceMVK` function is considered legacy and has been
superseded by flink:vkCreateMetalSurfaceEXT from the
`apiext:VK_EXT_metal_surface` extension.
====
endif::VK_EXT_metal_surface[]

include::{generated}/validity/protos/vkCreateIOSSurfaceMVK.adoc[]
--

[open,refpage='VkIOSSurfaceCreateInfoMVK',desc='Structure specifying parameters of a newly created iOS surface object',type='structs']
--
The slink:VkIOSSurfaceCreateInfoMVK structure is defined as:

include::{generated}/api/structs/VkIOSSurfaceCreateInfoMVK.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:pView is a reference to either a basetype:CAMetalLayer object or a
    code:UIView object.

.Valid Usage
****
  * [[VUID-VkIOSSurfaceCreateInfoMVK-pView-04143]]
    If pname:pView is a basetype:CAMetalLayer object, it must: be a valid
    basetype:CAMetalLayer
  * [[VUID-VkIOSSurfaceCreateInfoMVK-pView-01316]]
    If pname:pView is a code:UIView object, it must: be a valid code:UIView,
    must: be backed by a code:CALayer object of type basetype:CAMetalLayer,
    and flink:vkCreateIOSSurfaceMVK must: be called on the main thread
****

include::{generated}/validity/structs/VkIOSSurfaceCreateInfoMVK.adoc[]
--

[open,refpage='VkIOSSurfaceCreateFlagsMVK',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkIOSSurfaceCreateFlagsMVK.adoc[]

tname:VkIOSSurfaceCreateFlagsMVK is a bitmask type for setting a mask, but
is currently reserved for future use.
--
endif::VK_MVK_ios_surface[]


ifdef::VK_MVK_macos_surface[]
[[platformCreateSurface_macos]]
=== macOS Platform

[open,refpage='vkCreateMacOSSurfaceMVK',desc='Create a VkSurfaceKHR object for a macOS NSView',type='protos']
--
:refpage: vkCreateMacOSSurfaceMVK

To create a sname:VkSurfaceKHR object for a macOS code:NSView or
basetype:CAMetalLayer, call:

include::{generated}/api/protos/vkCreateMacOSSurfaceMVK.adoc[]

  * pname:instance is the instance with which to associate the surface.
  * pname:pCreateInfo is a pointer to a slink:VkMacOSSurfaceCreateInfoMVK
    structure containing parameters affecting the creation of the surface
    object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

ifdef::VK_EXT_metal_surface[]
[NOTE]
====
The `vkCreateMacOSSurfaceMVK` function is considered legacy and has been
superseded by flink:vkCreateMetalSurfaceEXT from the
`apiext:VK_EXT_metal_surface` extension.
====
endif::VK_EXT_metal_surface[]

include::{generated}/validity/protos/vkCreateMacOSSurfaceMVK.adoc[]
--

[open,refpage='VkMacOSSurfaceCreateInfoMVK',desc='Structure specifying parameters of a newly created macOS surface object',type='structs']
--
The slink:VkMacOSSurfaceCreateInfoMVK structure is defined as:

include::{generated}/api/structs/VkMacOSSurfaceCreateInfoMVK.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:pView is a reference to either a basetype:CAMetalLayer object or
    an code:NSView object.

.Valid Usage
****
  * [[VUID-VkMacOSSurfaceCreateInfoMVK-pView-04144]]
    If pname:pView is a basetype:CAMetalLayer object, it must: be a valid
    basetype:CAMetalLayer
  * [[VUID-VkMacOSSurfaceCreateInfoMVK-pView-01317]]
    If pname:pView is an code:NSView object, it must: be a valid
    code:NSView, must: be backed by a code:CALayer object of type
    basetype:CAMetalLayer, and flink:vkCreateMacOSSurfaceMVK must: be called
    on the main thread
****

include::{generated}/validity/structs/VkMacOSSurfaceCreateInfoMVK.adoc[]
--

[open,refpage='VkMacOSSurfaceCreateFlagsMVK',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkMacOSSurfaceCreateFlagsMVK.adoc[]

tname:VkMacOSSurfaceCreateFlagsMVK is a bitmask type for setting a mask, but
is currently reserved for future use.
--
endif::VK_MVK_macos_surface[]


ifdef::VK_NN_vi_surface[]
[[platformCreateSurface_vi]]
=== VI Platform

[open,refpage='vkCreateViSurfaceNN',desc='Create a slink:VkSurfaceKHR object for a VI layer',type='protos']
--
:refpage: vkCreateViSurfaceNN

To create a sname:VkSurfaceKHR object for an code:nn::code:vi::code:Layer,
query the layer's native handle using
code:nn::code:vi::code:GetNativeWindow, and then call:

include::{generated}/api/protos/vkCreateViSurfaceNN.adoc[]

  * pname:instance is the instance with which to associate the surface.
  * pname:pCreateInfo is a pointer to a slink:VkViSurfaceCreateInfoNN
    structure containing parameters affecting the creation of the surface
    object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

During the lifetime of a surface created using a particular
code:nn::code:vi::code:NativeWindowHandle, applications must: not attempt to
create another surface for the same code:nn::code:vi::code:Layer or attempt
to connect to the same code:nn::code:vi::code:Layer through other platform
mechanisms.

If the native window is created with a specified size, pname:currentExtent
will reflect that size.
In this case, applications should use the same size for the swapchain's
pname:imageExtent.
Otherwise, the pname:currentExtent will have the special value
[eq]#(0xFFFFFFFF, 0xFFFFFFFF)#, indicating that applications are expected to
choose an appropriate size for the swapchain's pname:imageExtent (e.g., by
matching the result of a call to
code:nn::code:vi::code:GetDisplayResolution).

include::{generated}/validity/protos/vkCreateViSurfaceNN.adoc[]
--

[open,refpage='VkViSurfaceCreateInfoNN',desc='Structure specifying parameters of a newly created VI surface object',type='structs']
--
The sname:VkViSurfaceCreateInfoNN structure is defined as:

include::{generated}/api/structs/VkViSurfaceCreateInfoNN.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:window is the code:nn::code:vi::code:NativeWindowHandle for the
    code:nn::code:vi::code:Layer with which to associate the surface.

.Valid Usage
****
  * [[VUID-VkViSurfaceCreateInfoNN-window-01318]]
    pname:window must: be a valid code:nn::code:vi::code:NativeWindowHandle
****

include::{generated}/validity/structs/VkViSurfaceCreateInfoNN.adoc[]
--

[open,refpage='VkViSurfaceCreateFlagsNN',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkViSurfaceCreateFlagsNN.adoc[]

tname:VkViSurfaceCreateFlagsNN is a bitmask type for setting a mask, but is
currently reserved for future use.
--
endif::VK_NN_vi_surface[]


ifdef::VK_EXT_metal_surface[]
[[platformCreateSurface_metal]]
=== Metal Platform

[open,refpage='vkCreateMetalSurfaceEXT',desc='Create a VkSurfaceKHR object for CAMetalLayer',type='protos']
--
:refpage: vkCreateMetalSurfaceEXT

To create a sname:VkSurfaceKHR object for a basetype:CAMetalLayer, call:

include::{generated}/api/protos/vkCreateMetalSurfaceEXT.adoc[]

  * pname:instance is the instance with which to associate the surface.
  * pname:pCreateInfo is a pointer to a slink:VkMetalSurfaceCreateInfoEXT
    structure specifying parameters affecting the creation of the surface
    object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

include::{generated}/validity/protos/vkCreateMetalSurfaceEXT.adoc[]
--

[open,refpage='VkMetalSurfaceCreateInfoEXT',desc='Structure specifying parameters of a newly created Metal surface object',type='structs']
--
The slink:VkMetalSurfaceCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkMetalSurfaceCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:pLayer is a reference to a basetype:CAMetalLayer object
    representing a renderable surface.

include::{generated}/validity/structs/VkMetalSurfaceCreateInfoEXT.adoc[]
--

[open,refpage='CAMetalLayer',desc='CoreAnimation native layer type for Metal',type='basetypes']
--
To remove an unnecessary compile time dependency, an incomplete type
definition of basetype:CAMetalLayer is provided in the Vulkan headers:

include::{generated}/api/basetypes/CAMetalLayer.adoc[]

The actual basetype:CAMetalLayer type is defined in the QuartzCore
framework.
--

[open,refpage='VkMetalSurfaceCreateFlagsEXT',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkMetalSurfaceCreateFlagsEXT.adoc[]

tname:VkMetalSurfaceCreateFlagsEXT is a bitmask type for setting a mask, but
is currently reserved for future use.
--
endif::VK_EXT_metal_surface[]


ifdef::VK_QNX_screen_surface[]
[[platformCreateSurface_screen]]
=== QNX Screen Platform

[open,refpage='vkCreateScreenSurfaceQNX',desc='Create a slink:VkSurfaceKHR object for a QNX Screen window',type='protos']
--
To create a sname:VkSurfaceKHR object for a QNX Screen surface, call:

include::{generated}/api/protos/vkCreateScreenSurfaceQNX.adoc[]

  * pname:instance is the instance to associate the surface with.
  * pname:pCreateInfo is a pointer to a slink:VkScreenSurfaceCreateInfoQNX
    structure containing parameters affecting the creation of the surface
    object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

include::{generated}/validity/protos/vkCreateScreenSurfaceQNX.adoc[]
--

[open,refpage='VkScreenSurfaceCreateInfoQNX',desc='Structure specifying parameters of a newly created QNX Screen surface object',type='structs']
--
The sname:VkScreenSurfaceCreateInfoQNX structure is defined as:

include::{generated}/api/structs/VkScreenSurfaceCreateInfoQNX.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:context and pname:window are QNX Screen code:context and
    code:window to associate the surface with.

.Valid Usage
****
  * [[VUID-VkScreenSurfaceCreateInfoQNX-context-04741]]
    pname:context must: point to a valid QNX Screen code:struct
    _screen_context
  * [[VUID-VkScreenSurfaceCreateInfoQNX-window-04742]]
    pname:window must: point to a valid QNX Screen code:struct
    _screen_window
****

include::{generated}/validity/structs/VkScreenSurfaceCreateInfoQNX.adoc[]
--

[open,refpage='VkScreenSurfaceCreateFlagsQNX',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkScreenSurfaceCreateFlagsQNX.adoc[]

tname:VkScreenSurfaceCreateFlagsQNX is a bitmask type for setting a mask,
but is currently reserved for future use.
--
endif::VK_QNX_screen_surface[]


ifdef::VK_OHOS_surface[]
[[platformCreateSurface_OHOS]]
=== Open Harmony OS Platform Surface Creation

ifdef::VK_OHOS_surface[]
[open,refpage='vkCreateSurfaceOHOS',desc='Create a slink:VkSurfaceKHR object for an Open Harmony OS native window',type='protos']
--
To create a sname:VkSurfaceKHR object on Open Harmony OS platform, call:

include::{generated}/api/protos/vkCreateSurfaceOHOS.adoc[]

  * pname:instance is the instance to associate the surface with.
  * pname:pCreateInfo is a pointer to a slink:VkSurfaceCreateInfoOHOS
    structure containing parameters affecting the creation of the surface
    object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

include::{generated}/validity/protos/vkCreateSurfaceOHOS.adoc[]
--

[open,refpage='VkSurfaceCreateInfoOHOS', desc='The parameters for surface creation on Open Harmony OS platform', type='structs']
--
The sname:VkSurfaceCreateInfoOHOS structure is defined as:

include::{generated}/api/structs/VkSurfaceCreateInfoOHOS.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:window: is a pointer to a basetype:OHNativeWindow to associate the
    surface with.

include::{generated}/validity/structs/VkSurfaceCreateInfoOHOS.adoc[]
--

[open,refpage='OHNativeWindow',desc='Native window on Open Harmony OS platform',type='basetypes']
--
:refpage: OHNativeWindow

The basetype:OHNativeWindow structure is defined as:

include::{generated}/api/basetypes/OHNativeWindow.adoc[]

It is the native window structure on Open Harmony OS platform.
It is exposed by the Open Harmony OS NDK.
--

[open,refpage='VkSurfaceCreateFlagsOHOS',desc='reserved flag for surface creation',type='flags']
--
include::{generated}/api/flags/VkSurfaceCreateFlagsOHOS.adoc[]

tname:VkSurfaceCreateFlagsOHOS is a bitmask type for setting a mask, but is
currently reserved for future use.
--

endif::VK_OHOS_surface[]
endif::VK_OHOS_surface[]

=== Platform-Independent Information

Once created, sname:VkSurfaceKHR objects can: be used in this and other
extensions, in particular the `apiext:VK_KHR_swapchain` extension.

Several WSI functions return ename:VK_ERROR_SURFACE_LOST_KHR if the surface
becomes no longer available.
After such an error, the surface (and any child swapchain, if one exists)
should: be destroyed, as there is no way to restore them to a not-lost
state.
Applications may: attempt to create a new sname:VkSurfaceKHR using the same
native platform window object, but whether such re-creation will succeed is
platform-dependent and may: depend on the reason the surface became
unavailable.
A lost surface does not otherwise cause devices to be
<<devsandqueues-lost-device,lost>>.

[open,refpage='vkDestroySurfaceKHR',desc='Destroy a VkSurfaceKHR object',type='protos']
--
To destroy a sname:VkSurfaceKHR object, call:

include::{generated}/api/protos/vkDestroySurfaceKHR.adoc[]

  * pname:instance is the instance used to create the surface.
  * pname:surface is the surface to destroy.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).

Destroying a sname:VkSurfaceKHR merely severs the connection between Vulkan
and the native surface, and does not imply destroying the native surface,
closing a window, or similar behavior.

.Valid Usage
****
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkDestroySurfaceKHR-surface-01266]]
    All sname:VkSwapchainKHR objects created for pname:surface must: have
    been destroyed prior to destroying pname:surface
  * [[VUID-vkDestroySurfaceKHR-surface-01267]]
    If sname:VkAllocationCallbacks were provided when pname:surface was
    created, a compatible set of callbacks must: be provided here
  * [[VUID-vkDestroySurfaceKHR-surface-01268]]
    If no sname:VkAllocationCallbacks were provided when pname:surface was
    created, pname:pAllocator must: be `NULL`
endif::VKSC_VERSION_1_0[]
****

include::{generated}/validity/protos/vkDestroySurfaceKHR.adoc[]
--


ifdef::VK_KHR_display[]
[[display]]
== Presenting Directly to Display Devices

In some environments applications can: also present Vulkan rendering
directly to display devices without using an intermediate windowing system.
This can: be useful for embedded applications, or implementing the
rendering/presentation backend of a windowing system using Vulkan.
The `apiext:VK_KHR_display` extension provides the functionality necessary
to enumerate display devices and create sname:VkSurfaceKHR objects that
target displays.


=== Display Enumeration

[open,refpage='VkDisplayKHR',desc='Opaque handle to a display object',type='handles']
--
Displays are represented by sname:VkDisplayKHR handles:

include::{generated}/api/handles/VkDisplayKHR.adoc[]
--

[open,refpage='vkGetPhysicalDeviceDisplayPropertiesKHR',desc='Query information about the available displays',type='protos']
--
:refpage: vkGetPhysicalDeviceDisplayPropertiesKHR

Various functions are provided for enumerating the available display devices
present on a Vulkan physical device.
To query information about the available displays, call:

include::{generated}/api/protos/vkGetPhysicalDeviceDisplayPropertiesKHR.adoc[]

  * pname:physicalDevice is a physical device.
  * pname:pPropertyCount is a pointer to an integer related to the number of
    display devices available or queried, as described below.
  * pname:pProperties is either `NULL` or a pointer to an array of
    slink:VkDisplayPropertiesKHR structures.

If pname:pProperties is `NULL`, then the number of display devices available
for pname:physicalDevice is returned in pname:pPropertyCount.
Otherwise, pname:pPropertyCount must: point to a variable set by the
application to the number of elements in the pname:pProperties array, and on
return the variable is overwritten with the number of structures actually
written to pname:pProperties.
If the value of pname:pPropertyCount is less than the number of display
devices for pname:physicalDevice, at most pname:pPropertyCount structures
will be written, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all the available properties were
returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkGetPhysicalDeviceDisplayPropertiesKHR.adoc[]
--

[open,refpage='VkDisplayPropertiesKHR',desc='Structure describing an available display device',type='structs']
--
The sname:VkDisplayPropertiesKHR structure is defined as:

include::{generated}/api/structs/VkDisplayPropertiesKHR.adoc[]

  * pname:display is a handle that is used to refer to the display described
    here.
    This handle will be valid for the lifetime of the Vulkan instance.
  * pname:displayName is `NULL` or a pointer to a null-terminated UTF-8
    string containing the name of the display.
    Generally, this will be the name provided by the display's EDID.
    If `NULL`, no suitable name is available.
    If not `NULL`, the string pointed to must: remain accessible and
    unmodified as long as pname:display is valid.
  * pname:physicalDimensions describes the physical width and height of the
    visible portion of the display, in millimeters.
  * pname:physicalResolution describes the physical, native, or preferred
    resolution of the display.

[NOTE]
====
For devices which have no natural value to return here, implementations
should: return the maximum resolution supported.
====

  * pname:supportedTransforms is a bitmask of
    elink:VkSurfaceTransformFlagBitsKHR describing which transforms are
    supported by this display.
  * pname:planeReorderPossible tells whether the planes on this display can:
    have their z order changed.
    If this is ename:VK_TRUE, the application can: re-arrange the planes on
    this display in any order relative to each other.
  * pname:persistentContent tells whether the display supports
    self-refresh/internal buffering.
    If this is true, the application can: submit persistent present
    operations on swapchains created against this display.

[NOTE]
====
Persistent presents may: have higher latency, and may: use less power when
the screen content is updated infrequently, or when only a portion of the
screen needs to be updated in most frames.
====

include::{generated}/validity/structs/VkDisplayPropertiesKHR.adoc[]
--

ifdef::VK_KHR_get_display_properties2[]
[open,refpage='vkGetPhysicalDeviceDisplayProperties2KHR',desc='Query information about the available displays',type='protos']
--
:refpage: vkGetPhysicalDeviceDisplayProperties2KHR

To query information about the available displays, call:

include::{generated}/api/protos/vkGetPhysicalDeviceDisplayProperties2KHR.adoc[]

  * pname:physicalDevice is a physical device.
  * pname:pPropertyCount is a pointer to an integer related to the number of
    display devices available or queried, as described below.
  * pname:pProperties is either `NULL` or a pointer to an array of
    sname:VkDisplayProperties2KHR structures.

fname:vkGetPhysicalDeviceDisplayProperties2KHR behaves similarly to
flink:vkGetPhysicalDeviceDisplayPropertiesKHR, with the ability to return
extended information via chained output structures.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkGetPhysicalDeviceDisplayProperties2KHR.adoc[]
--

[open,refpage='VkDisplayProperties2KHR',desc='Structure describing an available display device',type='structs']
--
The sname:VkDisplayProperties2KHR structure is defined as:

include::{generated}/api/structs/VkDisplayProperties2KHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:displayProperties is a slink:VkDisplayPropertiesKHR structure.

include::{generated}/validity/structs/VkDisplayProperties2KHR.adoc[]
--
endif::VK_KHR_get_display_properties2[]


ifdef::VK_EXT_direct_mode_display[]
==== Acquiring and Releasing Displays

On some platforms, access to displays is limited to a single process or
native driver instance.
On such platforms, some or all of the displays may not be available to
Vulkan if they are already in use by a native windowing system or other
application.

ifdef::VK_EXT_acquire_xlib_display[]
[open,refpage='vkAcquireXlibDisplayEXT',desc='Acquire access to a VkDisplayKHR using Xlib',type='protos']
--
To acquire permission to directly access a display in Vulkan from an X11
server, call:

include::{generated}/api/protos/vkAcquireXlibDisplayEXT.adoc[]

  * pname:physicalDevice The physical device the display is on.
  * pname:dpy A connection to the X11 server that currently owns
    pname:display.
  * pname:display The display the caller wishes to control in Vulkan.

All permissions necessary to control the display are granted to the Vulkan
instance associated with pname:physicalDevice until the display is released
or the X11 connection specified by pname:dpy is terminated.
Permission to access the display may: be temporarily revoked during periods
when the X11 server from which control was acquired itself loses access to
pname:display.
During such periods, operations which require access to the display must:
fail with an appropriate error code.
If the X11 server associated with pname:dpy does not own pname:display, or
if permission to access it has already been acquired by another entity, the
call must: return the error code ename:VK_ERROR_INITIALIZATION_FAILED.

[NOTE]
====
One example of when an X11 server loses access to a display is when it loses
ownership of its virtual terminal.
====

include::{generated}/validity/protos/vkAcquireXlibDisplayEXT.adoc[]
--

[open,refpage='vkGetRandROutputDisplayEXT',desc='Query the VkDisplayKHR corresponding to an X11 RandR Output',type='protos']
--
When acquiring displays from an X11 server, an application may also wish to
enumerate and identify them using a native handle rather than a
sname:VkDisplayKHR handle.
To determine the sname:VkDisplayKHR handle corresponding to an X11 RandR
Output, call:

include::{generated}/api/protos/vkGetRandROutputDisplayEXT.adoc[]

  * pname:physicalDevice The physical device to query the display handle on.
  * pname:dpy A connection to the X11 server from which pname:rrOutput was
    queried.
  * pname:rrOutput An X11 RandR output ID.
  * pname:pDisplay The corresponding slink:VkDisplayKHR handle will be
    returned here.

If there is no slink:VkDisplayKHR corresponding to pname:rrOutput on
pname:physicalDevice, dlink:VK_NULL_HANDLE must: be returned in
pname:pDisplay.

include::{generated}/validity/protos/vkGetRandROutputDisplayEXT.adoc[]
--
endif::VK_EXT_acquire_xlib_display[]

ifdef::VK_NV_acquire_winrt_display[]
[open,refpage='vkAcquireWinrtDisplayNV',desc='Acquire access to a VkDisplayKHR',type='protos']
--
:refpage: vkAcquireWinrtDisplayNV

To acquire permission to directly access a display in Vulkan on Windows 10,
call:

include::{generated}/api/protos/vkAcquireWinrtDisplayNV.adoc[]

  * pname:physicalDevice The physical device the display is on.
  * pname:display The display the caller wishes to control in Vulkan.

All permissions necessary to control the display are granted to the Vulkan
instance associated with pname:physicalDevice until the display is released
or the application is terminated.
Permission to access the display may: be revoked by events that cause
Windows 10 itself to lose access to pname:display.
If this has happened, operations which require access to the display must:
fail with an appropriate error code.
If permission to access pname:display has already been acquired by another
entity, the call must: return the error code
ename:VK_ERROR_INITIALIZATION_FAILED.

[NOTE]
====
The Vulkan instance acquires control of a
https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displaytarget["`winrt::Windows::Devices::Display::Core::DisplayTarget`"]
by performing an operation equivalent to
https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displaymanager.tryacquiretarget["`winrt::Windows::Devices::Display::Core::DisplayManager.TryAcquireTarget()`"]
on the "`DisplayTarget`".
====

[NOTE]
====
One example of when Windows 10 loses access to a display is when the display
is hot-unplugged.
====

[NOTE]
====
One example of when a display has already been acquired by another entity is
when the Windows desktop compositor (DWM) is in control of the display.
Beginning with Windows 10 version 2004 it is possible to cause DWM to
release a display by using the "`Advanced display settings`" sub-page of the
"`Display settings`" control panel.
flink:vkAcquireWinrtDisplayNV does not itself cause DWM to release a
display; this action must be performed outside of Vulkan.
====

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkAcquireWinrtDisplayNV.adoc[]
--

[open,refpage='vkGetWinrtDisplayNV',desc='Query the VkDisplayKHR corresponding to a WinRT DisplayTarget',type='protos']
--
:refpage: vkGetWinrtDisplayNV

When acquiring displays on Windows 10, an application may also wish to
enumerate and identify them using a native handle rather than a
sname:VkDisplayKHR handle.

To determine the sname:VkDisplayKHR handle corresponding to a
https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displaytarget["`winrt::Windows::Devices::Display::Core::DisplayTarget`"],
call:

include::{generated}/api/protos/vkGetWinrtDisplayNV.adoc[]

  * pname:physicalDevice The physical device on which to query the display
    handle.
  * pname:deviceRelativeId The value of the
    https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displaytarget.adapterrelativeid["`AdapterRelativeId`"]
    property of a
    https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displaytarget["`DisplayTarget`"]
    that is enumerated by a
    https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displayadapter["`DisplayAdapter`"]
    with an
    https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displayadapter.id["`Id`"]
    property matching the pname:deviceLUID property of a
    slink:VkPhysicalDeviceIDProperties for pname:physicalDevice.
  * pname:pDisplay The corresponding slink:VkDisplayKHR handle will be
    returned here.

If there is no slink:VkDisplayKHR corresponding to pname:deviceRelativeId on
pname:physicalDevice, dlink:VK_NULL_HANDLE must: be returned in
pname:pDisplay.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkGetWinrtDisplayNV.adoc[]
--
endif::VK_NV_acquire_winrt_display[]

ifdef::VK_EXT_acquire_drm_display[]
[open,refpage='vkAcquireDrmDisplayEXT',desc='Acquire access to a VkDisplayKHR using DRM',type='protos']
--
To acquire permission to directly a display in Vulkan from the Direct
Rendering Manager (DRM) interface, call:

include::{generated}/api/protos/vkAcquireDrmDisplayEXT.adoc[]

  * pname:physicalDevice The physical device the display is on.
  * pname:drmFd DRM primary file descriptor.
  * pname:display The display the caller wishes Vulkan to control.

All permissions necessary to control the display are granted to the Vulkan
instance associated with the provided pname:physicalDevice until the display
is either released or the connector is unplugged.
The provided pname:drmFd must: correspond to the one owned by the
pname:physicalDevice.
If not, the error code ename:VK_ERROR_UNKNOWN must: be returned.
The DRM FD must have DRM mast{wj}er permissions.
If any error is encountered during the acquisition of the display, the call
must: return the error code ename:VK_ERROR_INITIALIZATION_FAILED.

The provided DRM fd should not be closed before the display is released,
attempting to do it may result in undefined: behavior.

include::{generated}/validity/protos/vkAcquireDrmDisplayEXT.adoc[]
--

[open,refpage='vkGetDrmDisplayEXT',desc='Query the VkDisplayKHR corresponding to a DRM connector ID',type='protos']
--
Before acquiring a display from the DRM interface, the caller may want to
select a specific sname:VkDisplayKHR handle by identifying it using a
pname:connectorId.
To do so, call:

include::{generated}/api/protos/vkGetDrmDisplayEXT.adoc[]

  * pname:physicalDevice The physical device to query the display from.
  * pname:drmFd DRM primary file descriptor.
  * pname:connectorId Identifier of the specified DRM connector.
  * pname:display The corresponding slink:VkDisplayKHR handle will be
    returned here.

If there is no slink:VkDisplayKHR corresponding to the pname:connectorId on
the pname:physicalDevice, the returning pname:display must: be
dlink:VK_NULL_HANDLE.
The provided pname:drmFd must: correspond to the one owned by the
pname:physicalDevice.
If not, the error code ename:VK_ERROR_UNKNOWN must: be returned.
Mast{wj}er permissions are not required, because the file descriptor is just
used for information gathering purposes.
The given pname:connectorId must: be a resource owned by the provided
pname:drmFd.
If not, the error code ename:VK_ERROR_UNKNOWN must: be returned.
If any error is encountered during the identification of the display, the
call must: return the error code ename:VK_ERROR_INITIALIZATION_FAILED.

include::{generated}/validity/protos/vkGetDrmDisplayEXT.adoc[]
--
endif::VK_EXT_acquire_drm_display[]

[open,refpage='vkReleaseDisplayEXT',desc='Release access to an acquired VkDisplayKHR',type='protos']
--
To release a previously acquired display, call:

include::{generated}/api/protos/vkReleaseDisplayEXT.adoc[]

  * pname:physicalDevice The physical device the display is on.
  * pname:display The display to release control of.

include::{generated}/validity/protos/vkReleaseDisplayEXT.adoc[]
--
endif::VK_EXT_direct_mode_display[]


==== Display Planes

[open,refpage='vkGetPhysicalDeviceDisplayPlanePropertiesKHR',desc='Query the plane properties',type='protos']
--
:refpage: vkGetPhysicalDeviceDisplayPlanePropertiesKHR

Images are presented to individual planes on a display.
Devices must: support at least one plane on each display.
Planes can: be stacked and blended to composite multiple images on one
display.
Devices may: support only a fixed stacking order and fixed mapping between
planes and displays, or they may: allow arbitrary application-specified
stacking orders and mappings between planes and displays.
To query the properties of device display planes, call:

include::{generated}/api/protos/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.adoc[]

  * pname:physicalDevice is a physical device.
  * pname:pPropertyCount is a pointer to an integer related to the number of
    display planes available or queried, as described below.
  * pname:pProperties is either `NULL` or a pointer to an array of
    sname:VkDisplayPlanePropertiesKHR structures.

If pname:pProperties is `NULL`, then the number of display planes available
for pname:physicalDevice is returned in pname:pPropertyCount.
Otherwise, pname:pPropertyCount must: point to a variable set by the
application to the number of elements in the pname:pProperties array, and on
return the variable is overwritten with the number of structures actually
written to pname:pProperties.
If the value of pname:pPropertyCount is less than the number of display
planes for pname:physicalDevice, at most pname:pPropertyCount structures
will be written.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.adoc[]
--

[open,refpage='VkDisplayPlanePropertiesKHR',desc='Structure describing display plane properties',type='structs']
--
The sname:VkDisplayPlanePropertiesKHR structure is defined as:

include::{generated}/api/structs/VkDisplayPlanePropertiesKHR.adoc[]

  * pname:currentDisplay is the handle of the display the plane is currently
    associated with.
    If the plane is not currently attached to any displays, this will be
    dlink:VK_NULL_HANDLE.
  * pname:currentStackIndex is the current z-order of the plane.
    This will be between 0 and the value returned by
    fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR in
    pname:pPropertyCount.

include::{generated}/validity/structs/VkDisplayPlanePropertiesKHR.adoc[]
--

ifdef::VK_KHR_get_display_properties2[]
[open,refpage='vkGetPhysicalDeviceDisplayPlaneProperties2KHR',desc='Query information about the available display planes.',type='protos']
--
:refpage: vkGetPhysicalDeviceDisplayPlaneProperties2KHR

To query the properties of a device's display planes, call:

include::{generated}/api/protos/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.adoc[]

  * pname:physicalDevice is a physical device.
  * pname:pPropertyCount is a pointer to an integer related to the number of
    display planes available or queried, as described below.
  * pname:pProperties is either `NULL` or a pointer to an array of
    sname:VkDisplayPlaneProperties2KHR structures.

fname:vkGetPhysicalDeviceDisplayPlaneProperties2KHR behaves similarly to
flink:vkGetPhysicalDeviceDisplayPlanePropertiesKHR, with the ability to
return extended information via chained output structures.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.adoc[]
--

[open,refpage='VkDisplayPlaneProperties2KHR',desc='Structure describing an available display plane',type='structs']
--
The sname:VkDisplayPlaneProperties2KHR structure is defined as:

include::{generated}/api/structs/VkDisplayPlaneProperties2KHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:displayPlaneProperties is a slink:VkDisplayPlanePropertiesKHR
    structure.

include::{generated}/validity/structs/VkDisplayPlaneProperties2KHR.adoc[]
--
endif::VK_KHR_get_display_properties2[]

[open,refpage='vkGetDisplayPlaneSupportedDisplaysKHR',desc='Query the list of displays a plane supports',type='protos']
--
:refpage: vkGetDisplayPlaneSupportedDisplaysKHR

To determine which displays a plane is usable with, call

include::{generated}/api/protos/vkGetDisplayPlaneSupportedDisplaysKHR.adoc[]

  * pname:physicalDevice is a physical device.
  * pname:planeIndex is the plane which the application wishes to use, and
    must: be in the range [eq]#[0, physical device plane count - 1]#.
  * pname:pDisplayCount is a pointer to an integer related to the number of
    displays available or queried, as described below.
  * pname:pDisplays is either `NULL` or a pointer to an array of
    sname:VkDisplayKHR handles.

If pname:pDisplays is `NULL`, then the number of displays usable with the
specified pname:planeIndex for pname:physicalDevice is returned in
pname:pDisplayCount.
Otherwise, pname:pDisplayCount must: point to a variable set by the
application to the number of elements in the pname:pDisplays array, and on
return the variable is overwritten with the number of handles actually
written to pname:pDisplays.
If the value of pname:pDisplayCount is less than the number of usable
display-plane pairs for pname:physicalDevice, at most pname:pDisplayCount
handles will be written, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all the available pairs were
returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkGetDisplayPlaneSupportedDisplaysKHR-planeIndex-01249]]
    pname:planeIndex must: be less than the number of display planes
    supported by the device as determined by calling
    fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR
****

include::{generated}/validity/protos/vkGetDisplayPlaneSupportedDisplaysKHR.adoc[]
--

Additional properties of displays are queried using specialized query
functions.


==== Display Modes

[open,refpage='VkDisplayModeKHR',desc='Opaque handle to a display mode object',type='handles']
--
Display modes are represented by sname:VkDisplayModeKHR handles:

include::{generated}/api/handles/VkDisplayModeKHR.adoc[]
--

[open,refpage='vkGetDisplayModePropertiesKHR',desc='Query the set of mode properties supported by the display',type='protos']
--
:refpage: vkGetDisplayModePropertiesKHR

Each display has one or more supported modes associated with it by default.
These built-in modes are queried by calling:

include::{generated}/api/protos/vkGetDisplayModePropertiesKHR.adoc[]

  * pname:physicalDevice is the physical device associated with
    pname:display.
  * pname:display is the display to query.
  * pname:pPropertyCount is a pointer to an integer related to the number of
    display modes available or queried, as described below.
  * pname:pProperties is either `NULL` or a pointer to an array of
    sname:VkDisplayModePropertiesKHR structures.

If pname:pProperties is `NULL`, then the number of display modes available
on the specified pname:display for pname:physicalDevice is returned in
pname:pPropertyCount.
Otherwise, pname:pPropertyCount must: point to a variable set by the
application to the number of elements in the pname:pProperties array, and on
return the variable is overwritten with the number of structures actually
written to pname:pProperties.
If the value of pname:pPropertyCount is less than the number of display
modes for pname:physicalDevice, at most pname:pPropertyCount structures will
be written, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all the available display modes were
returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkGetDisplayModePropertiesKHR.adoc[]
--

[open,refpage='VkDisplayModePropertiesKHR',desc='Structure describing display mode properties',type='structs']
--
The sname:VkDisplayModePropertiesKHR structure is defined as:

include::{generated}/api/structs/VkDisplayModePropertiesKHR.adoc[]

  * pname:displayMode is a handle to the display mode described in this
    structure.
    This handle will be valid for the lifetime of the Vulkan instance.
  * pname:parameters is a slink:VkDisplayModeParametersKHR structure
    describing the display parameters associated with pname:displayMode.

include::{generated}/validity/structs/VkDisplayModePropertiesKHR.adoc[]
--

[open,refpage='VkDisplayModeCreateFlagsKHR',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkDisplayModeCreateFlagsKHR.adoc[]

tname:VkDisplayModeCreateFlagsKHR is a bitmask type for setting a mask, but
is currently reserved for future use.
--

ifdef::VK_KHR_get_display_properties2[]
[open,refpage='vkGetDisplayModeProperties2KHR',desc='Query information about the available display modes.',type='protos']
--
:refpage: vkGetDisplayModeProperties2KHR

To query the properties of a device's built-in display modes, call:

include::{generated}/api/protos/vkGetDisplayModeProperties2KHR.adoc[]

  * pname:physicalDevice is the physical device associated with
    pname:display.
  * pname:display is the display to query.
  * pname:pPropertyCount is a pointer to an integer related to the number of
    display modes available or queried, as described below.
  * pname:pProperties is either `NULL` or a pointer to an array of
    sname:VkDisplayModeProperties2KHR structures.

fname:vkGetDisplayModeProperties2KHR behaves similarly to
flink:vkGetDisplayModePropertiesKHR, with the ability to return extended
information via chained output structures.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkGetDisplayModeProperties2KHR.adoc[]
--

[open,refpage='VkDisplayModeProperties2KHR',desc='Structure describing an available display mode',type='structs']
--
The sname:VkDisplayModeProperties2KHR structure is defined as:

include::{generated}/api/structs/VkDisplayModeProperties2KHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:displayModeProperties is a slink:VkDisplayModePropertiesKHR
    structure.

include::{generated}/validity/structs/VkDisplayModeProperties2KHR.adoc[]
--
endif::VK_KHR_get_display_properties2[]

[open,refpage='VkDisplayModeParametersKHR',desc='Structure describing display parameters associated with a display mode',type='structs']
--
The sname:VkDisplayModeParametersKHR structure is defined as:

include::{generated}/api/structs/VkDisplayModeParametersKHR.adoc[]

  * pname:visibleRegion is the 2D extents of the visible region.
  * pname:refreshRate is a code:uint32_t that is the number of times the
    display is refreshed each second multiplied by 1000.

[NOTE]
====
For example, a 60Hz display mode would report a pname:refreshRate of 60,000.
====

.Valid Usage
****
  * [[VUID-VkDisplayModeParametersKHR-width-01990]]
    The pname:width member of pname:visibleRegion must: be greater than `0`
  * [[VUID-VkDisplayModeParametersKHR-height-01991]]
    The pname:height member of pname:visibleRegion must: be greater than `0`
  * [[VUID-VkDisplayModeParametersKHR-refreshRate-01992]]
    pname:refreshRate must: be greater than `0`
****

include::{generated}/validity/structs/VkDisplayModeParametersKHR.adoc[]
--

ifdef::VK_NV_display_stereo[]
[open,refpage='VkDisplayModeStereoPropertiesNV',desc='Structure describing the stereo properties of a display mode',type='structs']
--
The sname:VkDisplayModeStereoPropertiesNV structure is defined as:

include::{generated}/api/structs/VkDisplayModeStereoPropertiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:hdmi3DSupported indicates whether this display mode can be used
    for a display surface configured for
    ename:VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV.

include::{generated}/validity/structs/VkDisplayModeStereoPropertiesNV.adoc[]
--
endif::VK_NV_display_stereo[]

[open,refpage='vkCreateDisplayModeKHR',desc='Create a display mode',type='protos']
--
:refpage: vkCreateDisplayModeKHR

Additional modes may: also be created by calling:

include::{generated}/api/protos/vkCreateDisplayModeKHR.adoc[]

  * pname:physicalDevice is the physical device associated with
    pname:display.
  * pname:display is the display to create an additional mode for.
  * pname:pCreateInfo is a pointer to a slink:VkDisplayModeCreateInfoKHR
    structure describing the new mode to create.
  * pname:pAllocator is the allocator used for host memory allocated for the
    display mode object when there is no more specific allocator available
    (see <<memory-allocation,Memory Allocation>>).
  * pname:pMode is a pointer to a slink:VkDisplayModeKHR handle in which the
    mode created is returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkCreateDisplayModeKHR.adoc[]
--

[open,refpage='VkDisplayModeCreateInfoKHR',desc='Structure specifying parameters of a newly created display mode object',type='structs']
--
The sname:VkDisplayModeCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkDisplayModeCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use, and must: be zero.
  * pname:parameters is a slink:VkDisplayModeParametersKHR structure
    describing the display parameters to use in creating the new mode.
    If the parameters are not compatible with the specified display, the
    implementation must: return ename:VK_ERROR_INITIALIZATION_FAILED.

include::{generated}/validity/structs/VkDisplayModeCreateInfoKHR.adoc[]
--

[open,refpage='vkGetDisplayPlaneCapabilitiesKHR',desc='Query capabilities of a mode and plane combination',type='protos']
--
:refpage: vkGetDisplayPlaneCapabilitiesKHR

Applications that wish to present directly to a display must: select which
layer, or "`plane`" of the display they wish to target, and a mode to use
with the display.
Each display supports at least one plane.
The capabilities of a given mode and plane combination are determined by
calling:

include::{generated}/api/protos/vkGetDisplayPlaneCapabilitiesKHR.adoc[]

  * pname:physicalDevice is the physical device associated with the display
    specified by pname:mode
  * pname:mode is the display mode the application intends to program when
    using the specified plane.
    Note this parameter also implicitly specifies a display.
  * pname:planeIndex is the plane which the application intends to use with
    the display, and is less than the number of display planes supported by
    the device.
  * pname:pCapabilities is a pointer to a
    slink:VkDisplayPlaneCapabilitiesKHR structure in which the capabilities
    are returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkGetDisplayPlaneCapabilitiesKHR.adoc[]
--

[open,refpage='VkDisplayPlaneCapabilitiesKHR',desc='Structure describing capabilities of a mode and plane combination',type='structs']
--
The sname:VkDisplayPlaneCapabilitiesKHR structure is defined as:

include::{generated}/api/structs/VkDisplayPlaneCapabilitiesKHR.adoc[]

  * pname:supportedAlpha is a bitmask of
    elink:VkDisplayPlaneAlphaFlagBitsKHR describing the supported alpha
    blending modes.
  * pname:minSrcPosition is the minimum source rectangle offset supported by
    this plane using the specified mode.
  * pname:maxSrcPosition is the maximum source rectangle offset supported by
    this plane using the specified mode.
    The pname:x and pname:y components of pname:maxSrcPosition must: each be
    greater than or equal to the pname:x and pname:y components of
    pname:minSrcPosition, respectively.
  * pname:minSrcExtent is the minimum source rectangle size supported by
    this plane using the specified mode.
  * pname:maxSrcExtent is the maximum source rectangle size supported by
    this plane using the specified mode.
  * pname:minDstPosition, pname:maxDstPosition, pname:minDstExtent,
    pname:maxDstExtent all have similar semantics to their corresponding
    ptext:*Src* equivalents, but apply to the output region within the mode
    rather than the input region within the source image.
    Unlike the ptext:*Src* offsets, pname:minDstPosition and
    pname:maxDstPosition may: contain negative values.

The minimum and maximum position and extent fields describe the
implementation limits, if any, as they apply to the specified display mode
and plane.
Vendors may: support displaying a subset of a swapchain's presentable images
on the specified display plane.
This is expressed by returning pname:minSrcPosition, pname:maxSrcPosition,
pname:minSrcExtent, and pname:maxSrcExtent values that indicate a range of
possible positions and sizes which may: be used to specify the region within
the presentable images that source pixels will be read from when creating a
swapchain on the specified display mode and plane.

Vendors may: also support mapping the presentable images`' content to a
subset or superset of the visible region in the specified display mode.
This is expressed by returning pname:minDstPosition, pname:maxDstPosition,
pname:minDstExtent and pname:maxDstExtent values that indicate a range of
possible positions and sizes which may: be used to describe the region
within the display mode that the source pixels will be mapped to.

Other vendors may: support only a 1-1 mapping between pixels in the
presentable images and the display mode.
This may: be indicated by returning [eq]#(0,0)# for pname:minSrcPosition,
pname:maxSrcPosition, pname:minDstPosition, and pname:maxDstPosition, and
(display mode width, display mode height) for pname:minSrcExtent,
pname:maxSrcExtent, pname:minDstExtent, and pname:maxDstExtent.

The value pname:supportedAlpha must: contain at least one valid
elink:VkDisplayPlaneAlphaFlagBitsKHR bit.

These values indicate the limits of the implementation's individual fields.
Not all combinations of values within the offset and extent ranges returned
in sname:VkDisplayPlaneCapabilitiesKHR are guaranteed to be supported.
Presentation requests specifying unsupported combinations may: fail.

include::{generated}/validity/structs/VkDisplayPlaneCapabilitiesKHR.adoc[]
--

ifdef::VK_KHR_get_display_properties2[]
[open,refpage='vkGetDisplayPlaneCapabilities2KHR',desc='Query capabilities of a mode and plane combination',type='protos']
--
:refpage: vkGetDisplayPlaneCapabilities2KHR

To query the capabilities of a given mode and plane combination, call:

include::{generated}/api/protos/vkGetDisplayPlaneCapabilities2KHR.adoc[]

  * pname:physicalDevice is the physical device associated with
    pname:pDisplayPlaneInfo.
  * pname:pDisplayPlaneInfo is a pointer to a slink:VkDisplayPlaneInfo2KHR
    structure describing the plane and mode.
  * pname:pCapabilities is a pointer to a
    slink:VkDisplayPlaneCapabilities2KHR structure in which the capabilities
    are returned.

fname:vkGetDisplayPlaneCapabilities2KHR behaves similarly to
flink:vkGetDisplayPlaneCapabilitiesKHR, with the ability to specify extended
inputs via chained input structures, and to return extended information via
chained output structures.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkGetDisplayPlaneCapabilities2KHR.adoc[]
--

[open,refpage='VkDisplayPlaneInfo2KHR',desc='Structure defining the intended configuration of a display plane',type='structs']
--
The sname:VkDisplayPlaneInfo2KHR structure is defined as:

include::{generated}/api/structs/VkDisplayPlaneInfo2KHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:mode is the display mode the application intends to program when
    using the specified plane.

[NOTE]
====
This parameter also implicitly specifies a display.
====

  * pname:planeIndex is the plane which the application intends to use with
    the display.

The members of sname:VkDisplayPlaneInfo2KHR correspond to the arguments to
flink:vkGetDisplayPlaneCapabilitiesKHR, with pname:sType and pname:pNext
added for extensibility.

include::{generated}/validity/structs/VkDisplayPlaneInfo2KHR.adoc[]
--

[open,refpage='VkDisplayPlaneCapabilities2KHR',desc='Structure describing the capabilities of a mode and plane combination',type='structs']
--
The sname:VkDisplayPlaneCapabilities2KHR structure is defined as:

include::{generated}/api/structs/VkDisplayPlaneCapabilities2KHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:capabilities is a slink:VkDisplayPlaneCapabilitiesKHR structure.

include::{generated}/validity/structs/VkDisplayPlaneCapabilities2KHR.adoc[]
--
endif::VK_KHR_get_display_properties2[]


ifdef::VK_EXT_display_control[]
=== Display Control

[open,refpage='vkDisplayPowerControlEXT',desc='Set the power state of a display',type='protos']
--
:refpage: vkDisplayPowerControlEXT

To set the power state of a display, call:

include::{generated}/api/protos/vkDisplayPowerControlEXT.adoc[]

  * pname:device is a logical device associated with pname:display.
  * pname:display is the display whose power state is modified.
  * pname:pDisplayPowerInfo is a pointer to a slink:VkDisplayPowerInfoEXT
    structure specifying the new power state of pname:display.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkDisplayPowerControlEXT.adoc[]
--

[open,refpage='VkDisplayPowerInfoEXT',desc='Describe the power state of a display',type='structs']
--
The sname:VkDisplayPowerInfoEXT structure is defined as:

include::{generated}/api/structs/VkDisplayPowerInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:powerState is a elink:VkDisplayPowerStateEXT value specifying the
    new power state of the display.

include::{generated}/validity/structs/VkDisplayPowerInfoEXT.adoc[]
--

[open,refpage='VkDisplayPowerStateEXT',desc='Possible power states for a display',type='enums']
--
Possible values of slink:VkDisplayPowerInfoEXT::pname:powerState, specifying
the new power state of a display, are:

include::{generated}/api/enums/VkDisplayPowerStateEXT.adoc[]

  * ename:VK_DISPLAY_POWER_STATE_OFF_EXT specifies that the display is
    powered down.
  * ename:VK_DISPLAY_POWER_STATE_SUSPEND_EXT specifies that the display is
    put into a low power mode, from which it may: be able to transition back
    to ename:VK_DISPLAY_POWER_STATE_ON_EXT more quickly than if it were in
    ename:VK_DISPLAY_POWER_STATE_OFF_EXT.
    This state may: be the same as ename:VK_DISPLAY_POWER_STATE_OFF_EXT.
  * ename:VK_DISPLAY_POWER_STATE_ON_EXT specifies that the display is
    powered on.
--
endif::VK_EXT_display_control[]


[[wsi-display-surfaces]]
=== Display Surfaces

[open,refpage='vkCreateDisplayPlaneSurfaceKHR',desc='Create a slink:VkSurfaceKHR structure representing a display plane and mode',type='protos']
--
:refpage: vkCreateDisplayPlaneSurfaceKHR

A complete display configuration includes a mode, one or more display planes
and any parameters describing their behavior, and parameters describing some
aspects of the images associated with those planes.
Display surfaces describe the configuration of a single plane within a
complete display configuration.
To create a sname:VkSurfaceKHR object for a display plane, call:

include::{generated}/api/protos/vkCreateDisplayPlaneSurfaceKHR.adoc[]

  * pname:instance is the instance corresponding to the physical device the
    targeted display is on.
  * pname:pCreateInfo is a pointer to a slink:VkDisplaySurfaceCreateInfoKHR
    structure specifying which mode, plane, and other parameters to use, as
    described below.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface is returned.

include::{generated}/validity/protos/vkCreateDisplayPlaneSurfaceKHR.adoc[]
--

[open,refpage='VkDisplaySurfaceCreateInfoKHR',desc='Structure specifying parameters of a newly created display plane surface object',type='structs']
--
The sname:VkDisplaySurfaceCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkDisplaySurfaceCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use, and must: be zero.
  * pname:displayMode is a slink:VkDisplayModeKHR handle specifying the mode
    to use when displaying this surface.
  * pname:planeIndex is the plane on which this surface appears.
  * pname:planeStackIndex is the z-order of the plane.
  * pname:transform is a elink:VkSurfaceTransformFlagBitsKHR value
    specifying the transformation to apply to images as part of the scanout
    operation.
  * pname:globalAlpha is the global alpha value.
    This value is ignored if pname:alphaMode is not
    ename:VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR.
  * pname:alphaMode is a elink:VkDisplayPlaneAlphaFlagBitsKHR value
    specifying the type of alpha blending to use.
  * pname:imageExtent is the size of the presentable images to use with the
    surface.

[NOTE]
====
Creating a display surface must: not modify the state of the displays,
planes, or other resources it names.
For example, it must: not apply the specified mode to be set on the
associated display.
Application of display configuration occurs as a side effect of presenting
to a display surface.
====

.Valid Usage
****
  * [[VUID-VkDisplaySurfaceCreateInfoKHR-planeIndex-01252]]
    pname:planeIndex must: be less than the number of display planes
    supported by the device as determined by calling
    fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR
  * [[VUID-VkDisplaySurfaceCreateInfoKHR-planeReorderPossible-01253]]
    If the pname:planeReorderPossible member of the
    sname:VkDisplayPropertiesKHR structure returned by
    fname:vkGetPhysicalDeviceDisplayPropertiesKHR for the display
    corresponding to pname:displayMode is ename:VK_TRUE then
    pname:planeStackIndex must: be less than the number of display planes
    supported by the device as determined by calling
    fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR; otherwise
    pname:planeStackIndex must: equal the pname:currentStackIndex member of
    sname:VkDisplayPlanePropertiesKHR returned by
    fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR for the display plane
    corresponding to pname:displayMode
  * [[VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01254]]
    If pname:alphaMode is ename:VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR then
    pname:globalAlpha must: be between `0` and `1`, inclusive
  * [[VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01255]]
    pname:alphaMode must: be one of the bits present in the
    pname:supportedAlpha member of sname:VkDisplayPlaneCapabilitiesKHR for
    the display plane corresponding to pname:displayMode
  * [[VUID-VkDisplaySurfaceCreateInfoKHR-transform-06740]]
    pname:transform must: be one of the bits present in the
    pname:supportedTransforms member of sname:VkDisplayPropertiesKHR for the
    display corresponding to pname:displayMode
  * [[VUID-VkDisplaySurfaceCreateInfoKHR-width-01256]]
    The pname:width and pname:height members of pname:imageExtent must: be
    less than or equal to
    slink:VkPhysicalDeviceLimits::pname:maxImageDimension2D
ifdef::VK_NV_display_stereo[]
  * [[VUID-VkDisplaySurfaceCreateInfoKHR-pNext-10284]]
    If the pname:pNext chain includes a
    slink:VkDisplaySurfaceStereoCreateInfoNV structure whose
    pname:stereoType member is
    ename:VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV, then the
    pname:hdmi3DSupported member of the
    slink:VkDisplayModeStereoPropertiesNV structure in the pname:pNext chain
    of the sname:VkDisplayModeProperties2KHR structure returned by
    flink:vkGetDisplayModeProperties2KHR for the display mode corresponding
    to pname:displayMode must: be ename:VK_TRUE
endif::VK_NV_display_stereo[]
****

include::{generated}/validity/structs/VkDisplaySurfaceCreateInfoKHR.adoc[]
--

[open,refpage='VkDisplaySurfaceCreateFlagsKHR',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkDisplaySurfaceCreateFlagsKHR.adoc[]

tname:VkDisplaySurfaceCreateFlagsKHR is a bitmask type for setting a mask,
but is currently reserved for future use.
--

[open,refpage='VkDisplayPlaneAlphaFlagBitsKHR',desc='Alpha blending type',type='enums']
--
Bits which can: be set in
slink:VkDisplaySurfaceCreateInfoKHR::pname:alphaMode, specifying the type of
alpha blending to use on a display, are:

include::{generated}/api/enums/VkDisplayPlaneAlphaFlagBitsKHR.adoc[]

  * ename:VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR specifies that the source
    image will be treated as opaque.
  * ename:VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR specifies that a global
    alpha value must: be specified that will be applied to all pixels in the
    source image.
  * ename:VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR specifies that the alpha
    value will be determined by the alpha component of the source image's
    pixels.
    If the source format contains no alpha values, no blending will be
    applied.
    The source alpha values are not premultiplied into the source image's
    other color components.
  * ename:VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR is
    equivalent to ename:VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR, except the
    source alpha values are assumed to be premultiplied into the source
    image's other color components.
--

[open,refpage='VkDisplayPlaneAlphaFlagsKHR',desc='Bitmask of VkDisplayPlaneAlphaFlagBitsKHR',type='flags']
--
include::{generated}/api/flags/VkDisplayPlaneAlphaFlagsKHR.adoc[]

tname:VkDisplayPlaneAlphaFlagsKHR is a bitmask type for setting a mask of
zero or more elink:VkDisplayPlaneAlphaFlagBitsKHR.
--

ifdef::VK_NV_display_stereo[]
[open,refpage='VkDisplaySurfaceStereoCreateInfoNV',desc='Structure specifying stereo parameters of a newly created display plane surface object',type='structs']
--
The sname:VkDisplaySurfaceStereoCreateInfoNV structure is defined as:

include::{generated}/api/structs/VkDisplaySurfaceStereoCreateInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[wsi-displaySurfaceStereoType]] pname:stereoType is a
    elink:VkDisplaySurfaceStereoTypeNV value specifying the type of 3D
    stereo presentation the display will be configured for.

include::{generated}/validity/structs/VkDisplaySurfaceStereoCreateInfoNV.adoc[]
--

[open,refpage='VkDisplaySurfaceStereoTypeNV',desc='3D Stereo type',type='enums']
--
Possible values of
slink:VkDisplaySurfaceStereoCreateInfoNV::pname:stereoType, specifying the
type of 3D stereo presentation the display will be configured for, are:

include::{generated}/api/enums/VkDisplaySurfaceStereoTypeNV.adoc[]

  * ename:VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV specifies no configuration
    for stereo presentation.
    This is the default behavior if slink:VkDisplaySurfaceStereoCreateInfoNV
    is not provided.
  * ename:VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV specifies
    configuration for glasses that connect via a DIN connector on the back
    of the graphics card.
  * ename:VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV specifies configuration
    for HDMI 3D compatible display devices with their own stereo emitters.
    This is also known as HDMI Frame Packed Stereo, where the left and right
    eye images are stacked into a single frame with a doubled pixel clock
    and refresh rate.
  * ename:VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV specifies
    configuration for DisplayPort display devices with in-band stereo
    signaling and emitters.
--
endif::VK_NV_display_stereo[]
endif::VK_KHR_display[]


ifdef::VK_EXT_headless_surface[]
[[headless]]
=== Presenting to Headless Surfaces

Vulkan rendering can be presented to a headless surface, where the
presentation operation is a no-op producing no externally-visible result.

[NOTE]
====
Because there is no real presentation target, the headless presentation
engine may be extended to impose an arbitrary or customizable set of
restrictions and features.
This makes it a useful portable test target for applications targeting a
wide range of presentation engines where the actual target presentation
engines might be scarce, unavailable or otherwise undesirable or
inconvenient to use for general Vulkan application development.

The usual surface query mechanisms must be used to determine the actual
restrictions and features of the implementation.
====

[open,refpage='vkCreateHeadlessSurfaceEXT',desc='Create a headless slink:VkSurfaceKHR object',type='protos']
--
:refpage: vkCreateHeadlessSurfaceEXT

To create a headless sname:VkSurfaceKHR object, call:

include::{generated}/api/protos/vkCreateHeadlessSurfaceEXT.adoc[]

  * pname:instance is the instance to associate the surface with.
  * pname:pCreateInfo is a pointer to a slink:VkHeadlessSurfaceCreateInfoEXT
    structure containing parameters affecting the creation of the surface
    object.
  * pname:pAllocator is the allocator used for host memory allocated for the
    surface object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSurface is a pointer to a slink:VkSurfaceKHR handle in which the
    created surface object is returned.

include::{generated}/validity/protos/vkCreateHeadlessSurfaceEXT.adoc[]
--

[open,refpage='VkHeadlessSurfaceCreateInfoEXT',desc='Structure specifying parameters of a newly created headless surface object',type='structs']
--
The sname:VkHeadlessSurfaceCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkHeadlessSurfaceCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.

include::{generated}/validity/structs/VkHeadlessSurfaceCreateInfoEXT.adoc[]
--

For headless surfaces, pname:currentExtent is the reserved value
[eq]#(0xFFFFFFFF, 0xFFFFFFFF)#.
Whatever the application sets a swapchain's pname:imageExtent to will be the
size of the surface, after the first image is presented.

[open,refpage='VkHeadlessSurfaceCreateFlagsEXT',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkHeadlessSurfaceCreateFlagsEXT.adoc[]

tname:VkHeadlessSurfaceCreateFlagsEXT is a bitmask type for setting a mask,
but is currently reserved for future use.
--
endif::VK_EXT_headless_surface[]


== Querying for WSI Support

Not all physical devices will include WSI support.
Within a physical device, not all queue families will support presentation.
WSI support and compatibility can: be determined in a platform-neutral
manner (which determines support for presentation to a particular surface
object) and additionally may: be determined in platform-specific manners
(which determine support for presentation on the specified physical device
but do not guarantee support for presentation to a particular surface
object).

[open,refpage='vkGetPhysicalDeviceSurfaceSupportKHR',desc='Query if presentation is supported',type='protos']
--
:refpage: vkGetPhysicalDeviceSurfaceSupportKHR

To determine whether a queue family of a physical device supports
presentation to a given surface, call:

include::{generated}/api/protos/vkGetPhysicalDeviceSurfaceSupportKHR.adoc[]

  * pname:physicalDevice is the physical device.
  * pname:queueFamilyIndex is the queue family.
  * pname:surface is the surface.
  * pname:pSupported is a pointer to a basetype:VkBool32.
    ename:VK_TRUE indicates support, and ename:VK_FALSE indicates no
    support.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkGetPhysicalDeviceSurfaceSupportKHR-queueFamilyIndex-01269]]
    pname:queueFamilyIndex must: be less than
    pname:pQueueFamilyPropertyCount returned by
    fname:vkGetPhysicalDeviceQueueFamilyProperties for the given
    pname:physicalDevice
****

include::{generated}/validity/protos/vkGetPhysicalDeviceSurfaceSupportKHR.adoc[]
--


ifdef::VK_KHR_android_surface[]
[[platformQuerySupport_android]]
=== Android Platform

On Android, all physical devices and queue families must: be capable of
presentation with any native window.
As a result there is no Android-specific query for these capabilities.

endif::VK_KHR_android_surface[]


ifdef::VK_KHR_wayland_surface[]
[[platformQuerySupport_walyand]]
=== Wayland Platform

[open,refpage='vkGetPhysicalDeviceWaylandPresentationSupportKHR',desc='Query physical device for presentation to Wayland',type='protos']
--
To determine whether a queue family of a physical device supports
presentation to a Wayland compositor, call:

include::{generated}/api/protos/vkGetPhysicalDeviceWaylandPresentationSupportKHR.adoc[]

  * pname:physicalDevice is the physical device.
  * pname:queueFamilyIndex is the queue family index.
  * pname:display is a pointer to the code:wl_display associated with a
    Wayland compositor.

This platform-specific function can: be called prior to creating a surface.

.Valid Usage
****
  * [[VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-queueFamilyIndex-01306]]
    pname:queueFamilyIndex must: be less than
    pname:pQueueFamilyPropertyCount returned by
    fname:vkGetPhysicalDeviceQueueFamilyProperties for the given
    pname:physicalDevice
****

include::{generated}/validity/protos/vkGetPhysicalDeviceWaylandPresentationSupportKHR.adoc[]
--
endif::VK_KHR_wayland_surface[]


ifdef::VK_KHR_win32_surface[]
[[platformQuerySupport_win32]]
=== Win32 Platform

[open,refpage='vkGetPhysicalDeviceWin32PresentationSupportKHR',desc='Query queue family support for presentation on a Win32 display',type='protos']
--
To determine whether a queue family of a physical device supports
presentation to the Microsoft Windows desktop, call:

include::{generated}/api/protos/vkGetPhysicalDeviceWin32PresentationSupportKHR.adoc[]

  * pname:physicalDevice is the physical device.
  * pname:queueFamilyIndex is the queue family index.

This platform-specific function can: be called prior to creating a surface.

.Valid Usage
****
  * [[VUID-vkGetPhysicalDeviceWin32PresentationSupportKHR-queueFamilyIndex-01309]]
    pname:queueFamilyIndex must: be less than
    pname:pQueueFamilyPropertyCount returned by
    fname:vkGetPhysicalDeviceQueueFamilyProperties for the given
    pname:physicalDevice
****

include::{generated}/validity/protos/vkGetPhysicalDeviceWin32PresentationSupportKHR.adoc[]
--
endif::VK_KHR_win32_surface[]


ifdef::VK_KHR_xcb_surface[]
[[platformQuerySupport_xcb]]
=== XCB Platform

[open,refpage='vkGetPhysicalDeviceXcbPresentationSupportKHR',desc='Query physical device for presentation to X11 server using XCB',type='protos']
--
To determine whether a queue family of a physical device supports
presentation to an X11 server, using the XCB client-side library, call:

include::{generated}/api/protos/vkGetPhysicalDeviceXcbPresentationSupportKHR.adoc[]

  * pname:physicalDevice is the physical device.
  * pname:queueFamilyIndex is the queue family index.
  * pname:connection is a pointer to an code:xcb_connection_t to the X
    server.
  * pname:visual_id is an X11 visual (code:xcb_visualid_t).

This platform-specific function can: be called prior to creating a surface.

.Valid Usage
****
  * [[VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-queueFamilyIndex-01312]]
    pname:queueFamilyIndex must: be less than
    pname:pQueueFamilyPropertyCount returned by
    fname:vkGetPhysicalDeviceQueueFamilyProperties for the given
    pname:physicalDevice
****

include::{generated}/validity/protos/vkGetPhysicalDeviceXcbPresentationSupportKHR.adoc[]
--
endif::VK_KHR_xcb_surface[]


ifdef::VK_KHR_xlib_surface[]
[[platformQuerySupport_xlib]]
=== Xlib Platform

[open,refpage='vkGetPhysicalDeviceXlibPresentationSupportKHR',desc='Query physical device for presentation to X11 server using Xlib',type='protos']
--
To determine whether a queue family of a physical device supports
presentation to an X11 server, using the Xlib client-side library, call:

include::{generated}/api/protos/vkGetPhysicalDeviceXlibPresentationSupportKHR.adoc[]

  * pname:physicalDevice is the physical device.
  * pname:queueFamilyIndex is the queue family index.
  * pname:dpy is a pointer to an Xlib code:Display connection to the server.
  * pname:visualID is an X11 visual (code:VisualID).

This platform-specific function can: be called prior to creating a surface.

.Valid Usage
****
  * [[VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-queueFamilyIndex-01315]]
    pname:queueFamilyIndex must: be less than
    pname:pQueueFamilyPropertyCount returned by
    fname:vkGetPhysicalDeviceQueueFamilyProperties for the given
    pname:physicalDevice
****

include::{generated}/validity/protos/vkGetPhysicalDeviceXlibPresentationSupportKHR.adoc[]
--
endif::VK_KHR_xlib_surface[]


ifdef::VK_EXT_directfb_surface[]
[[platformQuerySupport_directfb]]
=== DirectFB Platform

[open,refpage='vkGetPhysicalDeviceDirectFBPresentationSupportEXT',desc='Query physical device for presentation with DirectFB',type='protos']
--
To determine whether a queue family of a physical device supports
presentation with DirectFB library, call:

include::{generated}/api/protos/vkGetPhysicalDeviceDirectFBPresentationSupportEXT.adoc[]

  * pname:physicalDevice is the physical device.
  * pname:queueFamilyIndex is the queue family index.
  * pname:dfb is a pointer to the code:IDirectFB main interface of DirectFB.

This platform-specific function can: be called prior to creating a surface.

.Valid Usage
****
  * [[VUID-vkGetPhysicalDeviceDirectFBPresentationSupportEXT-queueFamilyIndex-04119]]
    pname:queueFamilyIndex must: be less than
    pname:pQueueFamilyPropertyCount returned by
    fname:vkGetPhysicalDeviceQueueFamilyProperties for the given
    pname:physicalDevice
****

include::{generated}/validity/protos/vkGetPhysicalDeviceDirectFBPresentationSupportEXT.adoc[]
--
endif::VK_EXT_directfb_surface[]


ifdef::VK_EXT_metal_surface[]
[[platformQuerySupport_metal]]
=== Metal Platform

On Apple platforms with Metal support, all physical devices and queue
families must: be capable of presentation with any layer.
As a result there is no Apple-specific query for these capabilities.
endif::VK_EXT_metal_surface[]


ifdef::VK_FUCHSIA_imagepipe_surface[]
[[platformQuerySupport_fuchsia]]
=== Fuchsia Platform

On Fuchsia, all physical devices and queue families must: be capable of
presentation with any ImagePipe.
As a result there is no Fuchsia-specific query for these capabilities.

endif::VK_FUCHSIA_imagepipe_surface[]


ifdef::VK_GGP_stream_descriptor_surface[]
[[platformQuerySupport_streamdescriptor]]
=== Google Games Platform

On Google Games Platform, all physical devices and queue families with the
ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT capabilities must:
be capable of presentation with any Google Games Platform stream descriptor.
As a result, there is no query specific to Google Games Platform for these
capabilities.
endif::VK_GGP_stream_descriptor_surface[]


ifdef::VK_MVK_ios_surface[]
[[platformQuerySupport_ios]]
=== iOS Platform

On iOS, all physical devices and queue families must: be capable of
presentation with any layer.
As a result there is no iOS-specific query for these capabilities.
endif::VK_MVK_ios_surface[]


ifdef::VK_MVK_macos_surface[]
[[platformQuerySupport_macos]]
=== macOS Platform

On macOS, all physical devices and queue families must: be capable of
presentation with any layer.
As a result there is no macOS-specific query for these capabilities.
endif::VK_MVK_macos_surface[]


ifdef::VK_NN_vi_surface[]
[[platformQuerySupport_vi]]
=== VI Platform

On VI, all physical devices and queue families must: be capable of
presentation with any layer.
As a result there is no VI-specific query for these capabilities.

endif::VK_NN_vi_surface[]


ifdef::VK_QNX_screen_surface[]
[[platformQuerySupport_screen]]
=== QNX Screen Platform

[open,refpage='vkGetPhysicalDeviceScreenPresentationSupportQNX',desc='Query physical device for presentation to QNX Screen',type='protos']
--
To determine whether a queue family of a physical device supports
presentation to a QNX Screen compositor, call:

include::{generated}/api/protos/vkGetPhysicalDeviceScreenPresentationSupportQNX.adoc[]

  * pname:physicalDevice is the physical device.
  * pname:queueFamilyIndex is the queue family index.
  * pname:window is the QNX Screen code:window object.

This platform-specific function can: be called prior to creating a surface.

.Valid Usage
****
  * [[VUID-vkGetPhysicalDeviceScreenPresentationSupportQNX-queueFamilyIndex-04743]]
    pname:queueFamilyIndex must: be less than
    pname:pQueueFamilyPropertyCount returned by
    fname:vkGetPhysicalDeviceQueueFamilyProperties for the given
    pname:physicalDevice
****

include::{generated}/validity/protos/vkGetPhysicalDeviceScreenPresentationSupportQNX.adoc[]
--
endif::VK_QNX_screen_surface[]


ifdef::VK_OHOS_surface[]
[[platformQuerySupport_OHOS]]
=== Open Harmony OS Platform

On Open Harmony OS, all physical devices and queue families must: be capable
of presentation with any native window.
As a result there is no Open Harmony OS platform-specific query for these
capabilities.
endif::VK_OHOS_surface[]


== Surface Queries

The capabilities of a swapchain targeting a surface are the intersection of
the capabilities of the WSI platform, the native window or display, and the
physical device.
The resulting capabilities can: be obtained with the queries listed below in
this section.

[NOTE]
====
In addition to the surface capabilities as obtained by surface queries
below, swapchain images are also subject to ordinary image creation limits
as reported by flink:vkGetPhysicalDeviceImageFormatProperties.
As an application is instructed by the appropriate Valid Usage sections,
both the surface capabilities and the image creation limits have to be
satisfied whenever swapchain images are created.
====


=== Surface Capabilities

[open,refpage='vkGetPhysicalDeviceSurfaceCapabilitiesKHR',desc='Query surface capabilities',type='protos']
--
:refpage: vkGetPhysicalDeviceSurfaceCapabilitiesKHR

To query the basic capabilities of a surface, needed in order to create a
swapchain, call:

include::{generated}/api/protos/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.adoc[]

  * pname:physicalDevice is the physical device that will be associated with
    the swapchain to be created, as described for
    flink:vkCreateSwapchainKHR.
  * pname:surface is the surface that will be associated with the swapchain.
  * pname:pSurfaceCapabilities is a pointer to a
    slink:VkSurfaceCapabilitiesKHR structure in which the capabilities are
    returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
include::{chapters}/commonvalidity/surface_physical_device_common.adoc[]
****

include::{generated}/validity/protos/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.adoc[]
--

[open,refpage='VkSurfaceCapabilitiesKHR',desc='Structure describing capabilities of a surface',type='structs']
--
The sname:VkSurfaceCapabilitiesKHR structure is defined as:

include::{generated}/api/structs/VkSurfaceCapabilitiesKHR.adoc[]

// These members are defined identically in VkSurfaceCapabilities2EXT, an
// extendable structure version of this query, so they are just reused from
// here.

// tag::surface_capabilities_members[]
  * pname:minImageCount is the minimum number of images the specified device
    supports for a swapchain created for the surface, and will be at least
    one.
  * pname:maxImageCount is the maximum number of images the specified device
    supports for a swapchain created for the surface, and will be either 0,
    or greater than or equal to pname:minImageCount.
    A value of 0 means that there is no limit on the number of images,
    though there may: be limits related to the total amount of memory used
    by presentable images.
  * pname:currentExtent is the current width and height of the surface, or
    the special value [eq]#(0xFFFFFFFF, 0xFFFFFFFF)# indicating that the
    surface size will be determined by the extent of a swapchain targeting
    the surface.
  * pname:minImageExtent contains the smallest valid swapchain extent for
    the surface on the specified device.
    The pname:width and pname:height of the extent will each be less than or
    equal to the corresponding pname:width and pname:height of
    pname:currentExtent, unless pname:currentExtent has the special value
    described above.
  * pname:maxImageExtent contains the largest valid swapchain extent for the
    surface on the specified device.
    The pname:width and pname:height of the extent will each be greater than
    or equal to the corresponding pname:width and pname:height of
    pname:minImageExtent.
    The pname:width and pname:height of the extent will each be greater than
    or equal to the corresponding pname:width and pname:height of
    pname:currentExtent, unless pname:currentExtent has the special value
    described above.
  * pname:maxImageArrayLayers is the maximum number of layers presentable
    images can: have for a swapchain created for this device and surface,
    and will be at least one.
  * pname:supportedTransforms is a bitmask of
    elink:VkSurfaceTransformFlagBitsKHR indicating the presentation
    transforms supported for the surface on the specified device.
    At least one bit will be set.
  * pname:currentTransform is elink:VkSurfaceTransformFlagBitsKHR value
    indicating the surface's current transform relative to the presentation
    engine's natural orientation.
  * pname:supportedCompositeAlpha is a bitmask of
    elink:VkCompositeAlphaFlagBitsKHR, representing the alpha compositing
    modes supported by the presentation engine for the surface on the
    specified device, and at least one bit will be set.
    Opaque composition can: be achieved in any alpha compositing mode by
    either using an image format that has no alpha component, or by ensuring
    that all pixels in the presentable images have an alpha value of 1.0.
  * pname:supportedUsageFlags is a bitmask of elink:VkImageUsageFlagBits
    representing the ways the application can: use the presentable images of
    a swapchain created
ifdef::VK_KHR_shared_presentable_image[]
    with elink:VkPresentModeKHR set to
ifdef::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
    ename:VK_PRESENT_MODE_FIFO_LATEST_READY_KHR,
endif::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
    ename:VK_PRESENT_MODE_IMMEDIATE_KHR, ename:VK_PRESENT_MODE_MAILBOX_KHR,
    ename:VK_PRESENT_MODE_FIFO_KHR or ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR
endif::VK_KHR_shared_presentable_image[]
    for the surface on the specified device.
    ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT must: be included in the set.
    Implementations may: support additional usages.
// end::surface_capabilities_members[]

ifdef::VK_KHR_shared_presentable_image[]
[NOTE]
====
Supported usage flags of a presentable image when using
ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or
ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR presentation mode are
provided by
slink:VkSharedPresentSurfaceCapabilitiesKHR::pname:sharedPresentSupportedUsageFlags.
====
endif::VK_KHR_shared_presentable_image[]

[NOTE]
====
Formulas such as [eq]#min(N, pname:maxImageCount)# are not correct, since
pname:maxImageCount may: be zero.
====

include::{generated}/validity/structs/VkSurfaceCapabilitiesKHR.adoc[]
--

ifdef::VK_KHR_get_surface_capabilities2[]
[open,refpage='vkGetPhysicalDeviceSurfaceCapabilities2KHR',desc='Reports capabilities of a surface on a physical device',type='protos']
--
:refpage: vkGetPhysicalDeviceSurfaceCapabilities2KHR

To query the basic capabilities of a surface defined by the core or
extensions, call:

include::{generated}/api/protos/vkGetPhysicalDeviceSurfaceCapabilities2KHR.adoc[]

  * pname:physicalDevice is the physical device that will be associated with
    the swapchain to be created, as described for
    flink:vkCreateSwapchainKHR.
  * pname:pSurfaceInfo is a pointer to a
    slink:VkPhysicalDeviceSurfaceInfo2KHR structure describing the surface
    and other fixed parameters that would be consumed by
    flink:vkCreateSwapchainKHR.
  * pname:pSurfaceCapabilities is a pointer to a
    slink:VkSurfaceCapabilities2KHR structure in which the capabilities are
    returned.

fname:vkGetPhysicalDeviceSurfaceCapabilities2KHR behaves similarly to
flink:vkGetPhysicalDeviceSurfaceCapabilitiesKHR, with the ability to specify
extended inputs via chained input structures, and to return extended
information via chained output structures.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
include::{chapters}/commonvalidity/surface_info_physical_device_surfaceless_common.adoc[]
ifdef::VK_EXT_full_screen_exclusive+VK_KHR_win32_surface[]
  * [[VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-02671]]
    If a slink:VkSurfaceCapabilitiesFullScreenExclusiveEXT structure is
    included in the pname:pNext chain of pname:pSurfaceCapabilities, a
    slink:VkSurfaceFullScreenExclusiveWin32InfoEXT structure must: be
    included in the pname:pNext chain of pname:pSurfaceInfo
endif::VK_EXT_full_screen_exclusive+VK_KHR_win32_surface[]
ifdef::VK_KHR_surface_maintenance1,VK_EXT_surface_maintenance1[]
  * [[VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-07776]]
    If a slink:VkSurfacePresentModeCompatibilityKHR structure is included in
    the pname:pNext chain of pname:pSurfaceCapabilities, a
    slink:VkSurfacePresentModeKHR structure must: be included in the
    pname:pNext chain of pname:pSurfaceInfo
  * [[VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-07777]]
    If a slink:VkSurfacePresentScalingCapabilitiesKHR structure is included
    in the pname:pNext chain of pname:pSurfaceCapabilities, a
    slink:VkSurfacePresentModeKHR structure must: be included in the
    pname:pNext chain of pname:pSurfaceInfo
ifdef::VK_GOOGLE_surfaceless_query[]
  * [[VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-07778]]
    If a slink:VkSurfacePresentModeCompatibilityKHR structure is included in
    the pname:pNext chain of pname:pSurfaceCapabilities,
    pname:pSurfaceInfo->surface must: be a valid slink:VkSurfaceKHR handle
  * [[VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-07779]]
    If a slink:VkSurfacePresentScalingCapabilitiesKHR structure is included
    in the pname:pNext chain of pname:pSurfaceCapabilities,
    pname:pSurfaceInfo->surface must: be a valid slink:VkSurfaceKHR handle
endif::VK_GOOGLE_surfaceless_query[]
endif::VK_KHR_surface_maintenance1,VK_EXT_surface_maintenance1[]
****

include::{generated}/validity/protos/vkGetPhysicalDeviceSurfaceCapabilities2KHR.adoc[]
--

[open,refpage='VkPhysicalDeviceSurfaceInfo2KHR',desc='Structure specifying a surface and related swapchain creation parameters',type='structs']
--
The sname:VkPhysicalDeviceSurfaceInfo2KHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceSurfaceInfo2KHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:surface is the surface that will be associated with the swapchain.

The members of sname:VkPhysicalDeviceSurfaceInfo2KHR correspond to the
arguments to flink:vkGetPhysicalDeviceSurfaceCapabilitiesKHR, with
pname:sType and pname:pNext added for extensibility.

ifdef::VK_EXT_full_screen_exclusive[]
Additional capabilities of a surface may: be available to swapchains created
with different full-screen exclusive settings - particularly if exclusive
full-screen access is application controlled.
These additional capabilities can: be queried by adding a
slink:VkSurfaceFullScreenExclusiveInfoEXT structure to the pname:pNext chain
of this structure when used to query surface properties.
ifdef::VK_KHR_win32_surface[]
Additionally, for Win32 surfaces with application controlled exclusive
full-screen access, chaining a
slink:VkSurfaceFullScreenExclusiveWin32InfoEXT structure may: also report
additional surface capabilities.
endif::VK_KHR_win32_surface[]
These additional capabilities only apply to swapchains created with the same
parameters included in the pname:pNext chain of
slink:VkSwapchainCreateInfoKHR.
endif::VK_EXT_full_screen_exclusive[]

.Valid Usage
****
ifdef::VK_KHR_win32_surface+VK_EXT_full_screen_exclusive[]
  * [[VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-02672]]
    If the pname:pNext chain includes a
    slink:VkSurfaceFullScreenExclusiveInfoEXT structure with its
    pname:fullScreenExclusive member set to
    ename:VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, and
    pname:surface was created using flink:vkCreateWin32SurfaceKHR, a
    slink:VkSurfaceFullScreenExclusiveWin32InfoEXT structure must: be
    included in the pname:pNext chain
endif::VK_KHR_win32_surface+VK_EXT_full_screen_exclusive[]
  * [[VUID-VkPhysicalDeviceSurfaceInfo2KHR-surface-07919]]
    If surface is not VK_NULL_HANDLE,
ifdef::VK_GOOGLE_surfaceless_query[]
    and the `apiext:VK_GOOGLE_surfaceless_query` extension is not enabled,
endif::VK_GOOGLE_surfaceless_query[]
    pname:surface must: be a valid slink:VkSurfaceKHR handle
****

include::{generated}/validity/structs/VkPhysicalDeviceSurfaceInfo2KHR.adoc[]
--

ifdef::VK_EXT_full_screen_exclusive[]
[open,refpage='VkSurfaceFullScreenExclusiveInfoEXT',desc='Structure specifying the preferred full-screen transition behavior',type='structs']
--
If the pname:pNext chain of slink:VkSwapchainCreateInfoKHR includes a
sname:VkSurfaceFullScreenExclusiveInfoEXT structure, then that structure
specifies the application's preferred full-screen transition behavior.

The sname:VkSurfaceFullScreenExclusiveInfoEXT structure is defined as:

include::{generated}/api/structs/VkSurfaceFullScreenExclusiveInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:fullScreenExclusive is a elink:VkFullScreenExclusiveEXT value
    specifying the preferred full-screen transition behavior.

If this structure is not present, pname:fullScreenExclusive is considered to
be ename:VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT.

include::{generated}/validity/structs/VkSurfaceFullScreenExclusiveInfoEXT.adoc[]
--

[open,refpage='VkFullScreenExclusiveEXT',desc='Hint values an application can specify affecting full-screen transition behavior',type='enums']
--
Possible values of
sname:VkSurfaceFullScreenExclusiveInfoEXT::pname:fullScreenExclusive are:

include::{generated}/api/enums/VkFullScreenExclusiveEXT.adoc[]

  * ename:VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT specifies that the
    implementation should: determine the appropriate full-screen method by
    whatever means it deems appropriate.
  * ename:VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT specifies that the
    implementation may: use full-screen exclusive mechanisms when available.
    Such mechanisms may: result in better performance and/or the
    availability of different presentation capabilities, but may: require a
    more disruptive transition during swapchain initialization, first
    presentation and/or destruction.
  * ename:VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT specifies that the
    implementation should: avoid using full-screen mechanisms which rely on
    disruptive transitions.
  * ename:VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT specifies that
    the application will manage full-screen exclusive mode by using the
    flink:vkAcquireFullScreenExclusiveModeEXT and
    flink:vkReleaseFullScreenExclusiveModeEXT commands.
--

ifdef::VK_KHR_win32_surface[]
[open,refpage='VkSurfaceFullScreenExclusiveWin32InfoEXT',desc='Structure specifying additional creation parameters specific to Win32 fullscreen exclusive mode',type='structs']
--
The sname:VkSurfaceFullScreenExclusiveWin32InfoEXT structure is defined as:

include::{generated}/api/structs/VkSurfaceFullScreenExclusiveWin32InfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:hmonitor is the Win32 code:HMONITOR handle identifying the display
    to create the surface with.

[NOTE]
====
If pname:hmonitor is invalidated (e.g. the monitor is unplugged) during the
lifetime of a swapchain created with this structure, operations on that
swapchain will return ename:VK_ERROR_OUT_OF_DATE_KHR.
====

[NOTE]
====
It is the responsibility of the application to change the display settings
of the targeted Win32 display using the appropriate platform APIs.
Such changes may: alter the surface capabilities reported for the created
surface.
====

.Valid Usage
****
  * [[VUID-VkSurfaceFullScreenExclusiveWin32InfoEXT-hmonitor-02673]]
    pname:hmonitor must: be a valid code:HMONITOR
****

include::{generated}/validity/structs/VkSurfaceFullScreenExclusiveWin32InfoEXT.adoc[]
--
endif::VK_KHR_win32_surface[]
endif::VK_EXT_full_screen_exclusive[]

[open,refpage='VkSurfaceCapabilities2KHR',desc='Structure describing capabilities of a surface',type='structs']
--
The sname:VkSurfaceCapabilities2KHR structure is defined as:

include::{generated}/api/structs/VkSurfaceCapabilities2KHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:surfaceCapabilities is a slink:VkSurfaceCapabilitiesKHR structure
    describing the capabilities of the specified surface.

ifdef::VK_GOOGLE_surfaceless_query[]
If the `apiext:VK_GOOGLE_surfaceless_query` extension is enabled and
slink:VkPhysicalDeviceSurfaceInfo2KHR::pname:surface in the
flink:vkGetPhysicalDeviceSurfaceCapabilities2KHR call is
dlink:VK_NULL_HANDLE, the values returned in pname:minImageCount,
pname:maxImageCount, pname:currentExtent, and pname:currentTransform will
not reflect that of any surface and will instead be as such:

  * pname:minImageCount and pname:maxImageCount will be [eq]#0xFFFFFFFF#
  * pname:currentExtent will be [eq]#(0xFFFFFFFF, 0xFFFFFFFF)#
  * pname:currentTransform will be
    ename:VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR
endif::VK_GOOGLE_surfaceless_query[]

include::{generated}/validity/structs/VkSurfaceCapabilities2KHR.adoc[]
--

ifdef::VK_KHR_surface_protected_capabilities[]
[open,refpage='VkSurfaceProtectedCapabilitiesKHR',desc='Structure describing capability of a surface to be protected',type='structs']
--
An application queries if a protected slink:VkSurfaceKHR is displayable on a
specific windowing system using sname:VkSurfaceProtectedCapabilitiesKHR,
which can: be passed in pname:pNext parameter of
sname:VkSurfaceCapabilities2KHR.

The sname:VkSurfaceProtectedCapabilitiesKHR structure is defined as:

include::{generated}/api/structs/VkSurfaceProtectedCapabilitiesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:supportsProtected specifies whether a protected swapchain created
    from slink:VkPhysicalDeviceSurfaceInfo2KHR::pname:surface for a
    particular windowing system can: be displayed on screen or not.
    If pname:supportsProtected is ename:VK_TRUE, then creation of swapchains
    with the ename:VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR flag set must: be
    supported for pname:surface.

ifdef::VK_GOOGLE_surfaceless_query[]
If the `apiext:VK_GOOGLE_surfaceless_query` extension is enabled, the value
returned in pname:supportsProtected will be identical for every valid
surface created on this physical device, and so in the
flink:vkGetPhysicalDeviceSurfaceCapabilities2KHR call,
slink:VkPhysicalDeviceSurfaceInfo2KHR::pname:surface can: be
dlink:VK_NULL_HANDLE.
In that case, the contents of
slink:VkSurfaceCapabilities2KHR::pname:surfaceCapabilities as well as any
other structure chained to it will be undefined:.
endif::VK_GOOGLE_surfaceless_query[]

include::{generated}/validity/structs/VkSurfaceProtectedCapabilitiesKHR.adoc[]
--
endif::VK_KHR_surface_protected_capabilities[]

ifdef::VK_KHR_surface_maintenance1,VK_EXT_surface_maintenance1[]
[open,refpage='VkSurfacePresentScalingCapabilitiesKHR',desc='Structure describing the presentation scaling capabilities of the surface',type='structs']
--
The sname:VkSurfacePresentScalingCapabilitiesKHR structure is defined as:

include::{generated}/api/structs/VkSurfacePresentScalingCapabilitiesKHR.adoc[]

ifdef::VK_EXT_surface_maintenance1[]
include::{generated}/api/structs/VkSurfacePresentScalingCapabilitiesEXT.adoc[]
endif::VK_EXT_surface_maintenance1[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:supportedPresentScaling is a bitmask of
    elink:VkPresentScalingFlagBitsKHR representing the scaling methods
    supported by the surface, or `0` if application-defined scaling is not
    supported.
  * pname:supportedPresentGravityX is a bitmask of
    elink:VkPresentGravityFlagBitsKHR representing the X-axis pixel gravity
    supported by the surface, or `0` if Vulkan-defined pixel gravity is not
    supported for the X axis.
  * pname:supportedPresentGravityY is a bitmask of
    elink:VkPresentGravityFlagBitsKHR representing the Y-axis pixel gravity
    supported by the surface, or `0` if Vulkan-defined pixel gravity is not
    supported for the Y axis.
  * pname:minScaledImageExtent contains the smallest valid swapchain extent
    for the surface on the specified device when one of the scaling methods
    specified in pname:supportedPresentScaling is used, or the special value
    [eq]#(0xFFFFFFFF, 0xFFFFFFFF)# indicating that the surface size will be
    determined by the extent of a swapchain targeting the surface.
    The pname:width and pname:height of the extent will each be smaller than
    or equal to the corresponding pname:width and pname:height of
    slink:VkSurfaceCapabilitiesKHR::pname:minImageExtent.
  * pname:maxScaledImageExtent contains the largest valid swapchain extent
    for the surface on the specified device when one of the scaling methods
    specified in pname:supportedPresentScaling is used, or the special value
    described above for pname:minScaledImageExtent.
    The pname:width and pname:height of the extent will each be greater than
    or equal to the corresponding pname:width and pname:height of
    slink:VkSurfaceCapabilitiesKHR::pname:maxImageExtent.

To query the set of supported scaling modes for a given present mode, add a
slink:VkSurfacePresentModeKHR structure in the pname:pNext chain of
slink:VkPhysicalDeviceSurfaceInfo2KHR when calling
flink:vkGetPhysicalDeviceSurfaceCapabilities2KHR.
The implementation must: return the same values in
sname:VkSurfacePresentScalingCapabilitiesKHR for any of the compatible
present modes as obtained through
slink:VkSurfacePresentModeCompatibilityKHR.

ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
The application can: specify the scaling mode when creating a swapchain
through the use of slink:VkSwapchainPresentScalingCreateInfoKHR.
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]

include::{generated}/validity/structs/VkSurfacePresentScalingCapabilitiesKHR.adoc[]
--

[open,refpage='VkPresentScalingFlagBitsKHR',desc='Bitmask specifying presentation scaling methods',type='enums']
--
Bits which may: be set in
slink:VkSurfacePresentScalingCapabilitiesKHR::pname:supportedPresentScaling,
specifying scaling modes supported by the surface, are:

include::{generated}/api/enums/VkPresentScalingFlagBitsKHR.adoc[]

ifdef::VK_EXT_surface_maintenance1[]
include::{generated}/api/enums/VkPresentScalingFlagBitsEXT.adoc[]
endif::VK_EXT_surface_maintenance1[]

  * ename:VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR specifies that no scaling
    occurs, and pixels in the swapchain image are mapped to one and only one
    pixel in the surface.
    The mapping between pixels is defined by the chosen presentation
    gravity.
  * ename:VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR specifies that the
    swapchain image will be minified or magnified such that at least one of
    the resulting width or height is equal to the corresponding surface
    dimension, and the other resulting dimension is less than or equal to
    the corresponding surface dimension, with the aspect ratio of the
    resulting image being identical to that of the original swapchain image.
  * ename:VK_PRESENT_SCALING_STRETCH_BIT_KHR specifies that the swapchain
    image will be minified or magnified such that the resulting image
    dimensions are equal to those of the surface.
--

[open,refpage='VkPresentScalingFlagsKHR',desc='Bitmask of VkPresentScalingFlagBitsKHR',type='flags']
--
include::{generated}/api/flags/VkPresentScalingFlagsKHR.adoc[]

ifdef::VK_EXT_surface_maintenance1[]
include::{generated}/api/flags/VkPresentScalingFlagsEXT.adoc[]
endif::VK_EXT_surface_maintenance1[]

tname:VkPresentScalingFlagsKHR is a bitmask type for setting a mask of zero
or more elink:VkPresentScalingFlagBitsKHR.
--

[open,refpage='VkPresentGravityFlagBitsKHR',desc='Bitmask specifying presentation pixel gravity on either the x or y axis',type='enums']
--
Bits which may: be set in the
slink:VkSurfacePresentScalingCapabilitiesKHR::pname:supportedPresentGravityX
or pname:supportedPresentGravityY fields, specifying the gravity of
presented pixels supported by the surface, are:

include::{generated}/api/enums/VkPresentGravityFlagBitsKHR.adoc[]

ifdef::VK_EXT_surface_maintenance1[]
include::{generated}/api/enums/VkPresentGravityFlagBitsEXT.adoc[]
endif::VK_EXT_surface_maintenance1[]

  * ename:VK_PRESENT_GRAVITY_MIN_BIT_KHR means that the pixels will
    gravitate towards the top or left side of the surface.
  * ename:VK_PRESENT_GRAVITY_MAX_BIT_KHR means that the pixels will
    gravitate towards the bottom or right side of the surface.
  * ename:VK_PRESENT_GRAVITY_CENTERED_BIT_KHR means that the pixels will be
    centered in the surface.

If the value in slink:VkSurfaceCapabilitiesKHR::pname:currentTransform is
not ename:VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, it is
implementation-defined whether the gravity configuration applies to the
presented image before or after transformation.
--

[open,refpage='VkPresentGravityFlagsKHR',desc='Bitmask of VkPresentGravityFlagBitsKHR',type='flags']
--
include::{generated}/api/flags/VkPresentGravityFlagsKHR.adoc[]

ifdef::VK_EXT_surface_maintenance1[]
include::{generated}/api/flags/VkPresentGravityFlagsEXT.adoc[]
endif::VK_EXT_surface_maintenance1[]

tname:VkPresentGravityFlagsKHR is a bitmask type for setting a mask of zero
or more elink:VkPresentGravityFlagBitsKHR.
--

[open,refpage='VkSurfacePresentModeKHR',desc='Structure describing present mode of a surface',type='structs']
--
The sname:VkSurfacePresentModeKHR structure is defined as:

include::{generated}/api/structs/VkSurfacePresentModeKHR.adoc[]

ifdef::VK_EXT_surface_maintenance1[]
include::{generated}/api/structs/VkSurfacePresentModeEXT.adoc[]
endif::VK_EXT_surface_maintenance1[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentMode is the presentation mode the swapchain will use.

If the sname:VkSurfacePresentModeKHR structure is included in the
pname:pNext chain of slink:VkPhysicalDeviceSurfaceInfo2KHR, the values
returned in slink:VkSurfaceCapabilitiesKHR::pname:minImageCount,
slink:VkSurfaceCapabilitiesKHR::pname:maxImageCount,
slink:VkSurfacePresentScalingCapabilitiesKHR::pname:minScaledImageExtent,
and slink:VkSurfacePresentScalingCapabilitiesKHR::pname:maxScaledImageExtent
are valid only for the specified pname:presentMode.
ifdef::VK_KHR_shared_presentable_image[]
If pname:presentMode is ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or
ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, the per-present mode
image counts must: both be one.
endif::VK_KHR_shared_presentable_image[]
The per-present mode image counts may: be less-than or greater-than the
image counts returned when sname:VkSurfacePresentModeKHR is not provided.

[NOTE]
====
If slink:VkSwapchainPresentModesCreateInfoKHR is provided to swapchain
creation, the requirements for forward progress may be less strict.
For example, a FIFO swapchain might only require 2 images to guarantee
forward progress, but a MAILBOX one might require 4.
Without the per-present image counts, such an implementation would have to
return 4 in slink:VkSurfaceCapabilitiesKHR::pname:minImageCount, which
pessimizes FIFO.
Conversely, an implementation may return a low number for minImageCount, but
internally bump the image count when application queries
flink:vkGetSwapchainImagesKHR, which can surprise applications, and is not
discoverable until swapchain creation.
Using sname:VkSurfacePresentModeKHR and
slink:VkSwapchainPresentModesCreateInfoKHR together effectively removes this
problem.

slink:VkSwapchainPresentModesCreateInfoKHR is required for the specification
to be backwards compatible with applications that do not know about, or make
use of this feature.
====

.Valid Usage
****
  * [[VUID-VkSurfacePresentModeKHR-presentMode-07780]]
    pname:presentMode must: be a value reported by
    flink:vkGetPhysicalDeviceSurfacePresentModesKHR for the specified
    surface
****

include::{generated}/validity/structs/VkSurfacePresentModeKHR.adoc[]
--

[open,refpage='VkSurfacePresentModeCompatibilityKHR',desc='Structure describing the subset of compatible presentation modes for the purposes of switching without swapchain recreation',type='structs']
--
The sname:VkSurfacePresentModeCompatibilityKHR structure is defined as:

include::{generated}/api/structs/VkSurfacePresentModeCompatibilityKHR.adoc[]

ifdef::VK_EXT_surface_maintenance1[]
include::{generated}/api/structs/VkSurfacePresentModeCompatibilityEXT.adoc[]
endif::VK_EXT_surface_maintenance1[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentModeCount is an integer related to the number of present
    modes available or queried, as described below.
  * pname:pPresentModes is a pointer to an array of elink:VkPresentModeKHR
    in which present modes compatible with a given present mode are
    returned.

If pname:pPresentModes is `NULL`, then the number of present modes that are
compatible with the one specified in slink:VkSurfacePresentModeKHR is
returned in pname:presentModeCount.
Otherwise, pname:presentModeCount must: be set by the application to the
number of elements in the pname:pPresentModes array, and on return is
overwritten with the number of values actually written to
pname:pPresentModes.
If the value of pname:presentModeCount is less than the number of compatible
present modes that are supported, at most pname:presentModeCount values will
be written to pname:pPresentModes.
The implementation must: include the present mode passed to
slink:VkSurfacePresentModeKHR in pname:pPresentModes, unless
pname:presentModeCount is zero.

To query the set of present modes compatible with a given initial present
mode, add a slink:VkSurfacePresentModeKHR structure in the pname:pNext chain
of slink:VkPhysicalDeviceSurfaceInfo2KHR when calling
flink:vkGetPhysicalDeviceSurfaceCapabilities2KHR.

ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
The application can: create a swapchain whose present mode can: be modified
through the use of slink:VkSwapchainPresentModesCreateInfoKHR.
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]

include::{generated}/validity/structs/VkSurfacePresentModeCompatibilityKHR.adoc[]
--
endif::VK_KHR_surface_maintenance1,VK_EXT_surface_maintenance1[]

ifdef::VK_KHR_shared_presentable_image[]
[open,refpage='VkSharedPresentSurfaceCapabilitiesKHR',desc='Structure describing capabilities of a surface for shared presentation',type='structs']
--
The sname:VkSharedPresentSurfaceCapabilitiesKHR structure is defined as:

include::{generated}/api/structs/VkSharedPresentSurfaceCapabilitiesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:sharedPresentSupportedUsageFlags is a bitmask of
    elink:VkImageUsageFlagBits representing the ways the application can:
    use the shared presentable image from a swapchain created with
    elink:VkPresentModeKHR set to
    ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or
    ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR for the surface on
    the specified device.
    ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT must: be included in the set
    but implementations may: support additional usages.

include::{generated}/validity/structs/VkSharedPresentSurfaceCapabilitiesKHR.adoc[]
--
endif::VK_KHR_shared_presentable_image[]

ifdef::VK_AMD_display_native_hdr[]
[open,refpage='VkDisplayNativeHdrSurfaceCapabilitiesAMD',desc='Structure describing display native HDR specific capabilities of a surface',type='structs']
--
The sname:VkDisplayNativeHdrSurfaceCapabilitiesAMD structure is defined as:

include::{generated}/api/structs/VkDisplayNativeHdrSurfaceCapabilitiesAMD.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:localDimmingSupport specifies whether the surface supports local
    dimming.
    If this is ename:VK_TRUE, slink:VkSwapchainDisplayNativeHdrCreateInfoAMD
    can: be used to explicitly enable or disable local dimming for the
    surface.
    Local dimming may also be overridden by flink:vkSetLocalDimmingAMD
    during the lifetime of the swapchain.

include::{generated}/validity/structs/VkDisplayNativeHdrSurfaceCapabilitiesAMD.adoc[]
--
endif::VK_AMD_display_native_hdr[]

ifdef::VK_EXT_full_screen_exclusive[]
[open,refpage='VkSurfaceCapabilitiesFullScreenExclusiveEXT',desc='Structure describing full screen exclusive capabilities of a surface',type='structs']
--
The sname:VkSurfaceCapabilitiesFullScreenExclusiveEXT structure is defined
as:

include::{generated}/api/structs/VkSurfaceCapabilitiesFullScreenExclusiveEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:fullScreenExclusiveSupported is a boolean describing whether the
    surface is able to make use of exclusive full-screen access.

This structure can: be included in the pname:pNext chain of
slink:VkSurfaceCapabilities2KHR to determine support for exclusive
full-screen access.
If pname:fullScreenExclusiveSupported is ename:VK_FALSE, it indicates that
exclusive full-screen access is not obtainable for this surface.

Applications must: not attempt to create swapchains with
ename:VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT set if
pname:fullScreenExclusiveSupported is ename:VK_FALSE.

include::{generated}/validity/structs/VkSurfaceCapabilitiesFullScreenExclusiveEXT.adoc[]
--
endif::VK_EXT_full_screen_exclusive[]

ifdef::VK_NV_present_barrier[]
[open,refpage='VkSurfaceCapabilitiesPresentBarrierNV',desc='Structure describing present barrier capabilities of a surface',type='structs']
--
The sname:VkSurfaceCapabilitiesPresentBarrierNV structure is defined as:

include::{generated}/api/structs/VkSurfaceCapabilitiesPresentBarrierNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentBarrierSupported is a boolean describing whether the
    surface is able to make use of the present barrier feature.

This structure can: be included in the pname:pNext chain of
slink:VkSurfaceCapabilities2KHR to determine support for present barrier
access.
If pname:presentBarrierSupported is ename:VK_FALSE, it indicates that the
present barrier feature is not obtainable for this surface.

include::{generated}/validity/structs/VkSurfaceCapabilitiesPresentBarrierNV.adoc[]
--
endif::VK_NV_present_barrier[]

ifdef::VK_KHR_present_id2[]
[open,refpage='VkSurfaceCapabilitiesPresentId2KHR',desc='Structure describing presentation-ID capabilities of a surface',type='structs']
--
The sname:VkSurfaceCapabilitiesPresentId2KHR structure is defined as:

include::{generated}/api/structs/VkSurfaceCapabilitiesPresentId2KHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentId2Supported is a boolean describing whether the surface is
    able to support the present-ID extension

This structure can: be included in the pname:pNext chain of
slink:VkSurfaceCapabilities2KHR to determine support for present-wait.
If pname:presentId2Supported is ename:VK_FALSE, it indicates that attaching
an ID to presentation requests is not possible for this surface.

Applications must: not attempt to include slink:VkPresentId2KHR in the
pname:pNext chain of a slink:VkPresentInfoKHR if pname:presentId2Supported
is ename:VK_FALSE.

include::{generated}/validity/structs/VkSurfaceCapabilitiesPresentId2KHR.adoc[]
--
endif::VK_KHR_present_id2[]

ifdef::VK_KHR_present_wait2[]
[open,refpage='VkSurfaceCapabilitiesPresentWait2KHR',desc='Structure describing presentation-wait capabilities of a surface',type='structs']
--
The sname:VkSurfaceCapabilitiesPresentWait2KHR structure is defined as:

include::{generated}/api/structs/VkSurfaceCapabilitiesPresentWait2KHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentWait2Supported is a boolean describing whether the surface
    is able to support the present-wait extension

This structure can: be included in the pname:pNext chain of
slink:VkSurfaceCapabilities2KHR to determine support for present-wait.
If pname:presentWait2Supported is ename:VK_FALSE, it indicates that waiting
for presentation is not possible for this surface.

Applications must: not attempt to call flink:vkWaitForPresent2KHR on a
swapchain if pname:presentWait2Supported is ename:VK_FALSE.

include::{generated}/validity/structs/VkSurfaceCapabilitiesPresentWait2KHR.adoc[]
--
endif::VK_KHR_present_wait2[]

ifdef::VK_EXT_present_timing[]
[open,refpage='VkPresentTimingSurfaceCapabilitiesEXT',desc='Structure describing present timing capabilities of a surface',type='structs']
--
The sname:VkPresentTimingSurfaceCapabilitiesEXT structure is defined as:

include::{generated}/api/structs/VkPresentTimingSurfaceCapabilitiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentTimingSupported indicates whether querying presentation
    timestamps is supported for a swapchain created from
    slink:VkPhysicalDeviceSurfaceInfo2KHR::pname:surface.
  * pname:presentAtAbsoluteTimeSupported indicates whether a swapchain
    created from slink:VkPhysicalDeviceSurfaceInfo2KHR::pname:surface
    supports presenting images with absolute times.
  * pname:presentAtRelativeTimeSupported indicates whether a swapchain
    created from slink:VkPhysicalDeviceSurfaceInfo2KHR::pname:surface
    supports presenting images with relative times.
  * pname:presentStageQueries is a bitmask of
    elink:VkPresentStageFlagBitsEXT indicating which present stages a
    swapchain created from
    slink:VkPhysicalDeviceSurfaceInfo2KHR::pname:surface is able to provide
    timing information for.

include::{generated}/validity/structs/VkPresentTimingSurfaceCapabilitiesEXT.adoc[]
--
endif::VK_EXT_present_timing[]
endif::VK_KHR_get_surface_capabilities2[]

ifdef::VK_EXT_display_surface_counter[]
[open,refpage='vkGetPhysicalDeviceSurfaceCapabilities2EXT',desc='Query surface capabilities',type='protos']
--
:refpage: vkGetPhysicalDeviceSurfaceCapabilities2EXT

To query the basic capabilities of a surface, needed in order to create a
swapchain, call:

include::{generated}/api/protos/vkGetPhysicalDeviceSurfaceCapabilities2EXT.adoc[]

  * pname:physicalDevice is the physical device that will be associated with
    the swapchain to be created, as described for
    flink:vkCreateSwapchainKHR.
  * pname:surface is the surface that will be associated with the swapchain.
  * pname:pSurfaceCapabilities is a pointer to a
    slink:VkSurfaceCapabilities2EXT structure in which the capabilities are
    returned.

fname:vkGetPhysicalDeviceSurfaceCapabilities2EXT behaves similarly to
flink:vkGetPhysicalDeviceSurfaceCapabilitiesKHR, with the ability to return
extended information by adding extending structures to the pname:pNext chain
of its pname:pSurfaceCapabilities parameter.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
include::{chapters}/commonvalidity/surface_physical_device_common.adoc[]
****

include::{generated}/validity/protos/vkGetPhysicalDeviceSurfaceCapabilities2EXT.adoc[]
--

[open,refpage='VkSurfaceCapabilities2EXT',desc='Structure describing capabilities of a surface',type='structs']
--
The sname:VkSurfaceCapabilities2EXT structure is defined as:

include::{generated}/api/structs/VkSurfaceCapabilities2EXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
include::{chapters}/VK_KHR_surface/wsi.adoc[tag=surface_capabilities_members]
  * pname:supportedSurfaceCounters is a bitmask of
    elink:VkSurfaceCounterFlagBitsEXT indicating the supported surface
    counter types.

.Valid Usage
****
  * [[VUID-VkSurfaceCapabilities2EXT-supportedSurfaceCounters-01246]]
    pname:supportedSurfaceCounters must: not include
    ename:VK_SURFACE_COUNTER_VBLANK_BIT_EXT unless the surface queried is a
    <<wsi-display-surfaces,display surface>>
****

include::{generated}/validity/structs/VkSurfaceCapabilities2EXT.adoc[]
--

[open,refpage='VkSurfaceCounterFlagBitsEXT',desc='Surface-relative counter types',type='enums']
--
Bits which can: be set in
slink:VkSurfaceCapabilities2EXT::pname:supportedSurfaceCounters, indicating
supported surface counter types, are:

include::{generated}/api/enums/VkSurfaceCounterFlagBitsEXT.adoc[]

  * ename:VK_SURFACE_COUNTER_VBLANK_BIT_EXT specifies a counter incrementing
    once every time a vertical blanking period occurs on the display
    associated with the surface.
--

[open,refpage='VkSurfaceCounterFlagsEXT',desc='Bitmask of VkSurfaceCounterFlagBitsEXT',type='flags']
--
include::{generated}/api/flags/VkSurfaceCounterFlagsEXT.adoc[]

tname:VkSurfaceCounterFlagsEXT is a bitmask type for setting a mask of zero
or more elink:VkSurfaceCounterFlagBitsEXT.
--

endif::VK_EXT_display_surface_counter[]

[open,refpage='VkSurfaceTransformFlagBitsKHR',desc='Presentation transforms supported on a device',type='enums']
--
Bits which may: be set in
slink:VkSurfaceCapabilitiesKHR::pname:supportedTransforms indicating the
presentation transforms supported for the surface on the specified device,
and possible values of
slink:VkSurfaceCapabilitiesKHR::pname:currentTransform indicating the
surface's current transform relative to the presentation engine's natural
orientation, are:

include::{generated}/api/enums/VkSurfaceTransformFlagBitsKHR.adoc[]

  * ename:VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR specifies that image content
    is presented without being transformed.
  * ename:VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR specifies that image
    content is rotated 90 degrees clockwise.
  * ename:VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR specifies that image
    content is rotated 180 degrees clockwise.
  * ename:VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR specifies that image
    content is rotated 270 degrees clockwise.
  * ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR specifies that
    image content is mirrored horizontally.
  * ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR specifies
    that image content is mirrored horizontally, then rotated 90 degrees
    clockwise.
  * ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR
    specifies that image content is mirrored horizontally, then rotated 180
    degrees clockwise.
  * ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR
    specifies that image content is mirrored horizontally, then rotated 270
    degrees clockwise.
  * ename:VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR specifies that the
    presentation transform is not specified, and is instead determined by
    platform-specific considerations and mechanisms outside Vulkan.
--

[open,refpage='VkSurfaceTransformFlagsKHR',desc='Bitmask of VkSurfaceTransformFlagBitsKHR',type='flags']
--
include::{generated}/api/flags/VkSurfaceTransformFlagsKHR.adoc[]

tname:VkSurfaceTransformFlagsKHR is a bitmask type for setting a mask of
zero or more elink:VkSurfaceTransformFlagBitsKHR.
--

[open,refpage='VkCompositeAlphaFlagBitsKHR',desc='Alpha compositing modes supported on a device',type='enums']
--
The pname:supportedCompositeAlpha member is of type
elink:VkCompositeAlphaFlagBitsKHR, containing the following values:

include::{generated}/api/enums/VkCompositeAlphaFlagBitsKHR.adoc[]

These values are described as follows:

  * ename:VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR: The alpha component, if it
    exists, of the images is ignored in the compositing process.
    Instead, the image is treated as if it has a constant alpha of 1.0.
  * ename:VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR: The alpha component, if
    it exists, of the images is respected in the compositing process.
    The non-alpha components of the image are expected to already be
    multiplied by the alpha component by the application.
  * ename:VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: The alpha component,
    if it exists, of the images is respected in the compositing process.
    The non-alpha components of the image are not expected to already be
    multiplied by the alpha component by the application; instead, the
    compositor will multiply the non-alpha components of the image by the
    alpha component during compositing.
  * ename:VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR: The way in which the
    presentation engine treats the alpha component in the images is unknown
    to the Vulkan API.
    Instead, the application is responsible for setting the composite alpha
    blending mode using native window system commands.
    If the application does not set the blending mode using native window
    system commands, then a platform-specific default will be used.
--

[open,refpage='VkCompositeAlphaFlagsKHR',desc='Bitmask of VkCompositeAlphaFlagBitsKHR',type='flags']
--
include::{generated}/api/flags/VkCompositeAlphaFlagsKHR.adoc[]

tname:VkCompositeAlphaFlagsKHR is a bitmask type for setting a mask of zero
or more elink:VkCompositeAlphaFlagBitsKHR.
--


=== Surface Format Support

[open,refpage='vkGetPhysicalDeviceSurfaceFormatsKHR',desc='Query color formats supported by surface',type='protos']
--
:refpage: vkGetPhysicalDeviceSurfaceFormatsKHR

To query the supported swapchain format-color space pairs for a surface,
call:

include::{generated}/api/protos/vkGetPhysicalDeviceSurfaceFormatsKHR.adoc[]

  * pname:physicalDevice is the physical device that will be associated with
    the swapchain to be created, as described for
    flink:vkCreateSwapchainKHR.
  * pname:surface is the surface that will be associated with the swapchain.
  * pname:pSurfaceFormatCount is a pointer to an integer related to the
    number of format pairs available or queried, as described below.
  * pname:pSurfaceFormats is either `NULL` or a pointer to an array of
    sname:VkSurfaceFormatKHR structures.

If pname:pSurfaceFormats is `NULL`, then the number of format pairs
supported for the given pname:surface is returned in
pname:pSurfaceFormatCount.
Otherwise, pname:pSurfaceFormatCount must: point to a variable set by the
application to the number of elements in the pname:pSurfaceFormats array,
and on return the variable is overwritten with the number of structures
actually written to pname:pSurfaceFormats.
If the value of pname:pSurfaceFormatCount is less than the number of format
pairs supported, at most pname:pSurfaceFormatCount structures will be
written, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all the available format pairs were
returned.

The number of format pairs supported must: be greater than or equal to 1.
pname:pSurfaceFormats must: not contain an entry whose value for
pname:format is ename:VK_FORMAT_UNDEFINED.

If pname:pSurfaceFormats includes an entry whose value for pname:colorSpace
is ename:VK_COLOR_SPACE_SRGB_NONLINEAR_KHR and whose value for pname:format
is a UNORM (or SRGB) format and the corresponding SRGB (or UNORM) format is
a color renderable format for ename:VK_IMAGE_TILING_OPTIMAL, then
pname:pSurfaceFormats must: also contain an entry with the same value for
pname:colorSpace and pname:format equal to the corresponding SRGB (or UNORM)
format.

ifdef::VK_GOOGLE_surfaceless_query[]
If the `apiext:VK_GOOGLE_surfaceless_query` extension is enabled, the values
returned in pname:pSurfaceFormats will be identical for every valid surface
created on this physical device, and so pname:surface can: be
dlink:VK_NULL_HANDLE.
endif::VK_GOOGLE_surfaceless_query[]

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
include::{chapters}/commonvalidity/surface_physical_device_surfaceless_common.adoc[]
****

include::{generated}/validity/protos/vkGetPhysicalDeviceSurfaceFormatsKHR.adoc[]
--

[open,refpage='VkSurfaceFormatKHR',desc='Structure describing a supported swapchain format-color space pair',type='structs']
--
The sname:VkSurfaceFormatKHR structure is defined as:

include::{generated}/api/structs/VkSurfaceFormatKHR.adoc[]

  * pname:format is a elink:VkFormat that is compatible with the specified
    surface.
  * pname:colorSpace is a presentation elink:VkColorSpaceKHR that is
    compatible with the surface.

include::{generated}/validity/structs/VkSurfaceFormatKHR.adoc[]
--

ifdef::VK_KHR_get_surface_capabilities2[]
[open,refpage='vkGetPhysicalDeviceSurfaceFormats2KHR',desc='Query color formats supported by surface',type='protos']
--
:refpage: vkGetPhysicalDeviceSurfaceFormats2KHR

To query the supported swapchain format tuples for a surface, call:

include::{generated}/api/protos/vkGetPhysicalDeviceSurfaceFormats2KHR.adoc[]

  * pname:physicalDevice is the physical device that will be associated with
    the swapchain to be created, as described for
    flink:vkCreateSwapchainKHR.
  * pname:pSurfaceInfo is a pointer to a
    slink:VkPhysicalDeviceSurfaceInfo2KHR structure describing the surface
    and other fixed parameters that would be consumed by
    flink:vkCreateSwapchainKHR.
  * pname:pSurfaceFormatCount is a pointer to an integer related to the
    number of format tuples available or queried, as described below.
  * pname:pSurfaceFormats is either `NULL` or a pointer to an array of
    slink:VkSurfaceFormat2KHR structures.

flink:vkGetPhysicalDeviceSurfaceFormats2KHR behaves similarly to
flink:vkGetPhysicalDeviceSurfaceFormatsKHR, with the ability to be extended
via pname:pNext chains.

If pname:pSurfaceFormats is `NULL`, then the number of format tuples
supported for the given pname:surface is returned in
pname:pSurfaceFormatCount.
Otherwise, pname:pSurfaceFormatCount must: point to a variable set by the
application to the number of elements in the pname:pSurfaceFormats array,
and on return the variable is overwritten with the number of structures
actually written to pname:pSurfaceFormats.
If the value of pname:pSurfaceFormatCount is less than the number of format
tuples supported, at most pname:pSurfaceFormatCount structures will be
written, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all the available values were
returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
include::{chapters}/commonvalidity/surface_info_physical_device_surfaceless_common.adoc[]
****

include::{generated}/validity/protos/vkGetPhysicalDeviceSurfaceFormats2KHR.adoc[]
--

[open,refpage='VkSurfaceFormat2KHR',desc='Structure describing a supported swapchain format tuple',type='structs']
--
The sname:VkSurfaceFormat2KHR structure is defined as:

include::{generated}/api/structs/VkSurfaceFormat2KHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:surfaceFormat is a slink:VkSurfaceFormatKHR structure describing a
    format-color space pair that is compatible with the specified surface.

ifdef::VK_EXT_image_compression_control[]
ifdef::VK_EXT_image_compression_control_swapchain[]
If the <<features-imageCompressionControlSwapchain,
pname:imageCompressionControlSwapchain>> feature is supported and a
slink:VkImageCompressionPropertiesEXT structure is included in the
pname:pNext chain of this structure, then it will be filled with the
compression properties that are supported for the pname:surfaceFormat.
endif::VK_EXT_image_compression_control_swapchain[]
endif::VK_EXT_image_compression_control[]

ifdef::VK_EXT_image_compression_control[]
.Valid Usage
****
  * [[VUID-VkSurfaceFormat2KHR-pNext-06750]]
ifdef::VK_EXT_image_compression_control_swapchain[]
    If the `apiext:VK_EXT_image_compression_control_swapchain` extension is
    not supported, the
endif::VK_EXT_image_compression_control_swapchain[]
ifndef::VK_EXT_image_compression_control_swapchain[The]
    pname:pNext chain must: not include an
    slink:VkImageCompressionPropertiesEXT structure
****
endif::VK_EXT_image_compression_control[]

include::{generated}/validity/structs/VkSurfaceFormat2KHR.adoc[]
--

endif::VK_KHR_get_surface_capabilities2[]

While the pname:format of a presentable image refers to the encoding of each
pixel, the pname:colorSpace determines how the presentation engine
interprets the pixel values.
A color space in this document refers to a specific color space (defined by
the chromaticities of its primaries and a white point in CIE Lab), and
transfer functions indicating the mapping between the image data and the
colorimetry with respect to the given color space.

[open,refpage='VkColorSpaceKHR',desc='Supported color space of the presentation engine',type='enums']
--
Possible values of slink:VkSurfaceFormatKHR::pname:colorSpace, specifying
the color spaces that a presentation engine can accept, are:

include::{generated}/api/enums/VkColorSpaceKHR.adoc[]

  * ename:VK_COLOR_SPACE_SRGB_NONLINEAR_KHR specifies support for the images
    in sRGB color space, encoded according to the sRGB specification.
ifdef::VK_EXT_swapchain_colorspace[]
  * ename:VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT specifies support for the
    images in Display-P3 color space, encoded using a Display-P3 transfer
    function.
  * ename:VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT specifies support for the
    images in extended sRGB color space, encoded using a linear transfer
    function.
  * ename:VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT specifies support for
    the images in extended sRGB color space, encoded according to the scRGB
    specification.
  * ename:VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT specifies support for the
    images in Display-P3 color space, encoded using a linear transfer
    function.
  * ename:VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT specifies support for the
    images in DCI-P3 color space, encoded according to the DCI-P3
    specification.
    Note that values in such an image are interpreted as XYZ encoded color
    data by the presentation engine.
  * ename:VK_COLOR_SPACE_BT709_LINEAR_EXT specifies support for the images
    in BT709 color space, encoded using a linear transfer function.
  * ename:VK_COLOR_SPACE_BT709_NONLINEAR_EXT specifies support for the
    images in BT709 color space, encoded according to the BT709
    specification.
  * ename:VK_COLOR_SPACE_BT2020_LINEAR_EXT specifies support for the images
    in BT2020 color space, encoded using a linear transfer function.
  * ename:VK_COLOR_SPACE_HDR10_ST2084_EXT specifies support for the images
    in HDR10 (BT2020) color space, encoded according to SMPTE ST2084
    Perceptual Quantizer (PQ) specification.
  * ename:VK_COLOR_SPACE_HDR10_HLG_EXT specifies support for the images in
    HDR10 (BT2020) color space, encoded according to the Hybrid Log Gamma
    (HLG) specification.
  * ename:VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT specifies support for images in
    Adobe RGB color space, encoded using a linear transfer function.
  * ename:VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT specifies support for the
    images in Adobe RGB color space, encoded according to the Adobe RGB
    specification (approximately Gamma 2.2).
  * ename:VK_COLOR_SPACE_PASS_THROUGH_EXT specifies that color components
    are used "`as is`".
    This is intended to allow applications to supply data for color spaces
    not described here.
ifdef::VK_AMD_display_native_hdr[]
  * ename:VK_COLOR_SPACE_DISPLAY_NATIVE_AMD specifies support for the
    display's native color space.
    This matches the color space expectations of AMD's FreeSync2 standard,
    for displays supporting it.
endif::VK_AMD_display_native_hdr[]

ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scremoved[]
  * elink:VkColorSpaceKHR (legacy aliases)
  ** etext:VK_COLORSPACE_SRGB_NONLINEAR_KHR <<SCID-8>>
  ** etext:VK_COLOR_SPACE_DCI_P3_LINEAR_EXT <<SCID-8>>
  * elink:VkColorSpaceKHR (not well-defined)
  ** ename:VK_COLOR_SPACE_DOLBYVISION_EXT <<SCID-8>>
// end::scremoved[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

ifndef::VKSC_VERSION_1_0[]
[NOTE]
====
In the initial release of the `apiext:VK_KHR_surface` and
`apiext:VK_KHR_swapchain` extensions, the token
etext:VK_COLORSPACE_SRGB_NONLINEAR_KHR was used.
Starting in the 2016-05-13 updates to the extension branches, matching
release 1.0.13 of the core API specification,
ename:VK_COLOR_SPACE_SRGB_NONLINEAR_KHR is used instead for consistency with
Vulkan naming rules.
The older enum is still available for backwards compatibility.
====

[NOTE]
====
In older versions of this extension
ename:VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT was misnamed
etext:VK_COLOR_SPACE_DCI_P3_LINEAR_EXT.
This has been updated to indicate that it uses RGB color encoding, not XYZ.
The old name is legacy but is maintained for backwards compatibility.
====
endif::VKSC_VERSION_1_0[]

[NOTE]
====
In older versions of the `apiext:VK_EXT_swapchain_colorspace` extension,
ename:VK_COLOR_SPACE_DOLBYVISION_EXT was exposed.
The intent was to indicate the presentation engine shall decode an image
using the SMPTE ST 2084 Perceptual Quantizer (PQ) EOTF, and then apply a
proprietary OOTF to process the image.
However, Dolby Vision profile 8.4 describes an encoding using the Hybrid Log
Gamma (HLG) OETF, and there is no swapchain extension for signaling Dolby
Vision metadata to be used by a proprietary OOTF.
This enum is legacy but is maintained for backwards compatibility.
====

[NOTE]
====
For a traditional "`Linear`" or non-gamma transfer function color space use
ename:VK_COLOR_SPACE_PASS_THROUGH_EXT.
====

ifdef::VK_KHR_wayland_surface[]
[NOTE]
====
On Wayland, ename:VK_COLOR_SPACE_PASS_THROUGH_EXT can be used to disable
color management by the WSI on a surface, which makes it possible for the
application to create a code:wp_color_management_surface_v1 object without
triggering a code:surface_exists protocol error.

See flink:vkCreateWaylandSurfaceKHR
====
endif::VK_KHR_wayland_surface[]

The presentation engine interprets the pixel values of the R, G, and B
components as having been encoded using an appropriate transfer function.
Applications should: ensure that the appropriate transfer function has been
applied.
<<images-texel-encode, Texel encode>> requires that all implementations
implicitly apply the sRGB EOTF^-1^ on R, G, and B components when shaders
write to an sRGB pixel format image, which is useful for sRGB color spaces.
For sRGB color spaces with other pixel formats, or other non-linear color
spaces, applications can: apply the transfer function explicitly in a
shader.
The A channel is always interpreted as linearly encoded.

This extension defines enums for elink:VkColorSpaceKHR that correspond to
the following color spaces:

[[VK_EXT_swapchain_colorspace-table]]
.Color Spaces and Attributes
[options="header"]
|====
| Name           | Red Primary  | Green Primary | Blue Primary | White-point          | Transfer function
| DCI-P3         | 1.000, 0.000 | 0.000, 1.000  | 0.000, 0.000 | 0.3333, 0.3333       | DCI P3
| Display-P3     | 0.680, 0.320 | 0.265, 0.690  | 0.150, 0.060 | 0.3127, 0.3290 (D65) | Display-P3
| BT709          | 0.640, 0.330 | 0.300, 0.600  | 0.150, 0.060 | 0.3127, 0.3290 (D65) | BT709
| sRGB           | 0.640, 0.330 | 0.300, 0.600  | 0.150, 0.060 | 0.3127, 0.3290 (D65) | sRGB
| extended sRGB  | 0.640, 0.330 | 0.300, 0.600  | 0.150, 0.060 | 0.3127, 0.3290 (D65) | scRGB
| HDR10_ST2084   | 0.708, 0.292 | 0.170, 0.797  | 0.131, 0.046 | 0.3127, 0.3290 (D65) | ST2084 PQ
| HDR10_HLG      | 0.708, 0.292 | 0.170, 0.797  | 0.131, 0.046 | 0.3127, 0.3290 (D65) | HLG
| Adobe RGB      | 0.640, 0.330 | 0.210, 0.710  | 0.150, 0.060 | 0.3127, 0.3290 (D65) | Adobe RGB
|====

The transfer functions are described in the "`Transfer Functions`" chapter
of the <<data-format,Khronos Data Format Specification>>.

Except Display-P3 OETF, which is:

[latexmath]
++++
\begin{aligned}
E & =
  \begin{cases}
    1.055 \times L^{1 \over 2.4} - 0.055 & \text{for}\  0.0030186 \leq L \leq 1 \\
    12.92 \times L                       & \text{for}\  0 \leq L < 0.0030186
  \end{cases}
\end{aligned}
++++

where [eq]#L# is the linear value of a color component and [eq]#E# is the
encoded value (as stored in the image in memory).

[NOTE]
====
For most uses, the sRGB OETF is equivalent.
====
endif::VK_EXT_swapchain_colorspace[]
--


=== Surface Presentation Mode Support

[open,refpage='vkGetPhysicalDeviceSurfacePresentModesKHR',desc='Query supported presentation modes',type='protos']
--
:refpage: vkGetPhysicalDeviceSurfacePresentModesKHR

To query the supported presentation modes for a surface, call:

include::{generated}/api/protos/vkGetPhysicalDeviceSurfacePresentModesKHR.adoc[]

  * pname:physicalDevice is the physical device that will be associated with
    the swapchain to be created, as described for
    flink:vkCreateSwapchainKHR.
  * pname:surface is the surface that will be associated with the swapchain.
  * pname:pPresentModeCount is a pointer to an integer related to the number
    of presentation modes available or queried, as described below.
  * pname:pPresentModes is either `NULL` or a pointer to an array of
    elink:VkPresentModeKHR values, indicating the supported presentation
    modes.

If pname:pPresentModes is `NULL`, then the number of presentation modes
supported for the given pname:surface is returned in
pname:pPresentModeCount.
Otherwise, pname:pPresentModeCount must: point to a variable set by the
application to the number of elements in the pname:pPresentModes array, and
on return the variable is overwritten with the number of values actually
written to pname:pPresentModes.
If the value of pname:pPresentModeCount is less than the number of
presentation modes supported, at most pname:pPresentModeCount values will be
written, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all the available modes were
returned.

ifdef::VK_GOOGLE_surfaceless_query[]
If the `apiext:VK_GOOGLE_surfaceless_query` extension is enabled and
pname:surface is dlink:VK_NULL_HANDLE, the values returned in
pname:pPresentModes will only indicate support for
ifndef::VK_KHR_shared_presentable_image[]
ename:VK_PRESENT_MODE_FIFO_KHR.
endif::VK_KHR_shared_presentable_image[]
ifdef::VK_KHR_shared_presentable_image[]
ename:VK_PRESENT_MODE_FIFO_KHR,
ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR, and
ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR.
endif::VK_KHR_shared_presentable_image[]
To query support for any other present mode, a valid handle must: be
provided in pname:surface.
endif::VK_GOOGLE_surfaceless_query[]

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
include::{chapters}/commonvalidity/surface_physical_device_surfaceless_common.adoc[]
****

include::{generated}/validity/protos/vkGetPhysicalDeviceSurfacePresentModesKHR.adoc[]
--

ifdef::VK_EXT_full_screen_exclusive[]
[open,refpage='vkGetPhysicalDeviceSurfacePresentModes2EXT',desc='Query supported presentation modes',type='protos']
--
:refpage: vkGetPhysicalDeviceSurfacePresentModes2EXT

To query the supported presentation modes for a surface combined with select
other fixed swapchain creation parameters, call:

include::{generated}/api/protos/vkGetPhysicalDeviceSurfacePresentModes2EXT.adoc[]

  * pname:physicalDevice is the physical device that will be associated with
    the swapchain to be created, as described for
    flink:vkCreateSwapchainKHR.
  * pname:pSurfaceInfo is a pointer to a
    slink:VkPhysicalDeviceSurfaceInfo2KHR structure describing the surface
    and other fixed parameters that would be consumed by
    flink:vkCreateSwapchainKHR.
  * pname:pPresentModeCount is a pointer to an integer related to the number
    of presentation modes available or queried, as described below.
  * pname:pPresentModes is either `NULL` or a pointer to an array of
    elink:VkPresentModeKHR values, indicating the supported presentation
    modes.

fname:vkGetPhysicalDeviceSurfacePresentModes2EXT behaves similarly to
flink:vkGetPhysicalDeviceSurfacePresentModesKHR, with the ability to specify
extended inputs via chained input structures.

.Valid Usage
****
include::{chapters}/commonvalidity/surface_info_physical_device_surfaceless_common.adoc[]
****

include::{generated}/validity/protos/vkGetPhysicalDeviceSurfacePresentModes2EXT.adoc[]
--
endif::VK_EXT_full_screen_exclusive[]

[open,refpage='VkPresentModeKHR',desc='Presentation mode supported for a surface',type='enums']
--
Possible values of elements of the
flink:vkGetPhysicalDeviceSurfacePresentModesKHR::pname:pPresentModes array,
indicating the supported presentation modes for a surface, are:

include::{generated}/api/enums/VkPresentModeKHR.adoc[]

  * ename:VK_PRESENT_MODE_IMMEDIATE_KHR specifies that the presentation
    engine does not wait for a vertical blanking period to update the
    current image, meaning this mode may: result in visible tearing.
    No internal queuing of presentation requests is needed, as the requests
    are applied immediately.
  * ename:VK_PRESENT_MODE_MAILBOX_KHR specifies that the presentation engine
    waits for the next vertical blanking period to update the current image.
    Tearing cannot: be observed.
    An internal single-entry queue is used to hold pending presentation
    requests.
    If the queue is full when a new presentation request is received, the
    new request replaces the existing entry, and any images associated with
    the prior entry become available for reuse by the application.
    One request is removed from the queue and processed during each vertical
    blanking period in which the queue is non-empty.
  * ename:VK_PRESENT_MODE_FIFO_KHR specifies that the presentation engine
    waits for the next vertical blanking period to update the current image.
    Tearing cannot: be observed.
    An internal queue is used to hold pending presentation requests.
    New requests are appended to the end of the queue, and one request is
    removed from the beginning of the queue and processed during each
    vertical blanking period in which the queue is non-empty.
    This is the only value of pname:presentMode that is required: to be
    supported.
  * ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR specifies that the presentation
    engine generally waits for the next vertical blanking period to update
    the current image.
    If a vertical blanking period has already passed since the last update
    of the current image then the presentation engine does not wait for
    another vertical blanking period for the update, meaning this mode may:
    result in visible tearing in this case.
    This mode is useful for reducing visual stutter with an application that
    will mostly present a new image before the next vertical blanking
    period, but may occasionally be late, and present a new image just after
    the next vertical blanking period.
    An internal queue is used to hold pending presentation requests.
    New requests are appended to the end of the queue, and one request is
    removed from the beginning of the queue and processed during or after
    each vertical blanking period in which the queue is non-empty.
ifdef::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
  * ename:VK_PRESENT_MODE_FIFO_LATEST_READY_KHR specifies that the
    presentation engine waits for the next vertical blanking period to
    update the current image.
    Tearing cannot: be observed.
    An internal queue is used to hold pending presentation requests.
    New requests are appended to the end of the queue.
    At each vertical blanking period, the presentation engine dequeues all
    successive requests that are ready to be presented from the beginning of
    the queue.
ifdef::VK_EXT_present_timing,VK_GOOGLE_display_timing[]
    If using
ifdef::VK_GOOGLE_display_timing[]
    the `apiext:VK_GOOGLE_display_timing` extension
endif::VK_GOOGLE_display_timing[]
ifdef::VK_EXT_present_timing+VK_GOOGLE_display_timing[or]
ifdef::VK_EXT_present_timing[]
    the <<features-presentAtAbsoluteTime, pname:presentAtAbsoluteTime>>
    feature
endif::VK_EXT_present_timing[]
    to provide a target present time, the presentation engine checks the
    specified time for each image.
    If the target present time is less-than or equal-to the current time,
    the presentation engine dequeues the image and checks the next one.
endif::VK_EXT_present_timing,VK_GOOGLE_display_timing[]
    The image of the last dequeued request is presented.
    The other dequeued requests are dropped.
endif::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
ifdef::VK_KHR_shared_presentable_image[]
  * ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR specifies that the
    presentation engine and application have concurrent access to a single
    image, which is referred to as a _shared presentable image_.
    The presentation engine is only required to update the current image
    after a new presentation request is received.
    Therefore the application must: make a presentation request whenever an
    update is required.
    However, the presentation engine may: update the current image at any
    point, meaning this mode may: result in visible tearing.
  * ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR specifies that the
    presentation engine and application have concurrent access to a single
    image, which is referred to as a _shared presentable image_.
    The presentation engine periodically updates the current image on its
    regular refresh cycle.
    The application is only required to make one initial presentation
    request, after which the presentation engine must: update the current
    image without any need for further presentation requests.
    The application can: indicate the image contents have been updated by
    making a presentation request, but this does not guarantee the timing of
    when it will be updated.
    This mode may: result in visible tearing if rendering to the image is
    not timed correctly.

The supported elink:VkImageUsageFlagBits of the presentable images of a
swapchain created for a surface may: differ depending on the presentation
mode, and can be determined as per the table below:

.Presentable Image Usage Queries
[width="100%",cols="<50%,<50%",options="header"]
|====
| Presentation mode                                   | Image usage flags
| ename:VK_PRESENT_MODE_IMMEDIATE_KHR                 | slink:VkSurfaceCapabilitiesKHR::pname:supportedUsageFlags
| ename:VK_PRESENT_MODE_MAILBOX_KHR                   | slink:VkSurfaceCapabilitiesKHR::pname:supportedUsageFlags
| ename:VK_PRESENT_MODE_FIFO_KHR                      | slink:VkSurfaceCapabilitiesKHR::pname:supportedUsageFlags
| ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR              | slink:VkSurfaceCapabilitiesKHR::pname:supportedUsageFlags
ifdef::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
| ename:VK_PRESENT_MODE_FIFO_LATEST_READY_KHR         | slink:VkSurfaceCapabilitiesKHR::pname:supportedUsageFlags
endif::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
| ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR     | slink:VkSharedPresentSurfaceCapabilitiesKHR::pname:sharedPresentSupportedUsageFlags
| ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR | slink:VkSharedPresentSurfaceCapabilitiesKHR::pname:sharedPresentSupportedUsageFlags
|====
endif::VK_KHR_shared_presentable_image[]

[NOTE]
====
For reference, the mode indicated by ename:VK_PRESENT_MODE_FIFO_KHR is
equivalent to the behavior of {wgl|glX|egl}SwapBuffers with a swap interval
of 1, while the mode indicated by ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR is
equivalent to the behavior of {wgl|glX}SwapBuffers with a swap interval of
-1 (from the {WGL|GLX}_EXT_swap_control_tear extensions).
====
--


ifdef::VK_EXT_full_screen_exclusive[]
== Full Screen Exclusive Control

Swapchains created with pname:fullScreenExclusive set to
ename:VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT must: acquire and
release exclusive full-screen access explicitly, using the following
commands.

[open,refpage='vkAcquireFullScreenExclusiveModeEXT',desc='Acquire full-screen exclusive mode for a swapchain',type='protos']
--
To acquire exclusive full-screen access for a swapchain, call:

include::{generated}/api/protos/vkAcquireFullScreenExclusiveModeEXT.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to acquire exclusive full-screen access
    for.

.Valid Usage
****
  * [[VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02674]]
    pname:swapchain must: not be in the retired state
  * [[VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02675]]
    pname:swapchain must: be a swapchain created with a
    slink:VkSurfaceFullScreenExclusiveInfoEXT structure, with
    pname:fullScreenExclusive set to
    ename:VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT
  * [[VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02676]]
    pname:swapchain must: not currently have exclusive full-screen access
****

A return value of ename:VK_SUCCESS indicates that the pname:swapchain
successfully acquired exclusive full-screen access.
The swapchain will retain this exclusivity until either the application
releases exclusive full-screen access with
flink:vkReleaseFullScreenExclusiveModeEXT, destroys the swapchain, or if any
of the swapchain commands return
ename:VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT indicating that the mode
was lost because of platform-specific changes.

If the swapchain was unable to acquire exclusive full-screen access to the
display then ename:VK_ERROR_INITIALIZATION_FAILED is returned.
An application can: attempt to acquire exclusive full-screen access again
for the same swapchain even if this command fails, or if
ename:VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT has been returned by a
swapchain command.

include::{generated}/validity/protos/vkAcquireFullScreenExclusiveModeEXT.adoc[]
--

[open,refpage='vkReleaseFullScreenExclusiveModeEXT',desc='Release full-screen exclusive mode from a swapchain',type='protos']
--
To release exclusive full-screen access from a swapchain, call:

include::{generated}/api/protos/vkReleaseFullScreenExclusiveModeEXT.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to release exclusive full-screen access
    from.

[NOTE]
====
Applications will not be able to present to pname:swapchain after this call
until exclusive full-screen access is reacquired.
This is usually useful to handle when an application is minimized or
otherwise intends to stop presenting for a time.
====

.Valid Usage
****
  * [[VUID-vkReleaseFullScreenExclusiveModeEXT-swapchain-02677]]
    pname:swapchain must: not be in the retired state
  * [[VUID-vkReleaseFullScreenExclusiveModeEXT-swapchain-02678]]
    pname:swapchain must: be a swapchain created with a
    slink:VkSurfaceFullScreenExclusiveInfoEXT structure, with
    pname:fullScreenExclusive set to
    ename:VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT
****

include::{generated}/validity/protos/vkReleaseFullScreenExclusiveModeEXT.adoc[]
--
endif::VK_EXT_full_screen_exclusive[]


ifdef::VK_KHR_swapchain[]
ifdef::VK_BASE_VERSION_1_1,VK_KHR_device_group[]
== Device Group Queries

[open,refpage='vkGetDeviceGroupPresentCapabilitiesKHR',desc='Query present capabilities from other physical devices',type='protos']
--
:refpage: vkGetDeviceGroupPresentCapabilitiesKHR

A logical device that represents multiple physical devices may: support
presenting from images on more than one physical device, or combining images
from multiple physical devices.

To query these capabilities, call:

include::{generated}/api/protos/vkGetDeviceGroupPresentCapabilitiesKHR.adoc[]

  * pname:device is the logical device.
  * pname:pDeviceGroupPresentCapabilities is a pointer to a
    slink:VkDeviceGroupPresentCapabilitiesKHR structure in which the
    device's capabilities are returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkGetDeviceGroupPresentCapabilitiesKHR.adoc[]
--

[open,refpage='VkDeviceGroupPresentCapabilitiesKHR',desc='Present capabilities from other physical devices',type='structs']
--
The sname:VkDeviceGroupPresentCapabilitiesKHR structure is defined as:

include::{generated}/api/structs/VkDeviceGroupPresentCapabilitiesKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentMask is an array of ename:VK_MAX_DEVICE_GROUP_SIZE
    code:uint32_t masks, where the mask at element [eq]#i# is non-zero if
    physical device [eq]#i# has a presentation engine, and where bit [eq]#j#
    is set in element [eq]#i# if physical device [eq]#i# can: present
    swapchain images from physical device [eq]#j#.
    If element [eq]#i# is non-zero, then bit [eq]#i# must: be set.
  * pname:modes is a bitmask of elink:VkDeviceGroupPresentModeFlagBitsKHR
    indicating which device group presentation modes are supported.

pname:modes always has ename:VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR set.

The present mode flags are also used when presenting an image, in
slink:VkDeviceGroupPresentInfoKHR::pname:mode.

If a device group only includes a single physical device, then pname:modes
must: equal ename:VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR.

include::{generated}/validity/structs/VkDeviceGroupPresentCapabilitiesKHR.adoc[]
--


[open,refpage='VkDeviceGroupPresentModeFlagBitsKHR',desc='Bitmask specifying supported device group present modes',type='enums']
--
Bits which may: be set in
slink:VkDeviceGroupPresentCapabilitiesKHR::pname:modes, indicating which
device group presentation modes are supported, are:

include::{generated}/api/enums/VkDeviceGroupPresentModeFlagBitsKHR.adoc[]

  * ename:VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR specifies that any
    physical device with a presentation engine can: present its own
    swapchain images.
  * ename:VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR specifies that any
    physical device with a presentation engine can: present swapchain images
    from any physical device in its pname:presentMask.
  * ename:VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR specifies that any
    physical device with a presentation engine can: present the sum of
    swapchain images from any physical devices in its pname:presentMask.
  * ename:VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR specifies
    that multiple physical devices with a presentation engine can: each
    present their own swapchain images.
--

[open,refpage='VkDeviceGroupPresentModeFlagsKHR',desc='Bitmask of VkDeviceGroupPresentModeFlagBitsKHR',type='flags']
--
include::{generated}/api/flags/VkDeviceGroupPresentModeFlagsKHR.adoc[]

tname:VkDeviceGroupPresentModeFlagsKHR is a bitmask type for setting a mask
of zero or more elink:VkDeviceGroupPresentModeFlagBitsKHR.
--

[open,refpage='vkGetDeviceGroupSurfacePresentModesKHR',desc='Query present capabilities for a surface',type='protos']
--
:refpage: vkGetDeviceGroupSurfacePresentModesKHR

Some surfaces may: not be capable of using all the device group present
modes.

To query the supported device group present modes for a particular surface,
call:

include::{generated}/api/protos/vkGetDeviceGroupSurfacePresentModesKHR.adoc[]

  * pname:device is the logical device.
  * pname:surface is the surface.
  * pname:pModes is a pointer to a tlink:VkDeviceGroupPresentModeFlagsKHR in
    which the supported device group present modes for the surface are
    returned.

The modes returned by this command are not invariant, and may: change in
response to the surface being moved, resized, or occluded.
These modes must: be a subset of the modes returned by
flink:vkGetDeviceGroupPresentCapabilitiesKHR.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkGetDeviceGroupSurfacePresentModesKHR-surface-06212]]
    pname:surface must: be supported by all physical devices associated with
    pname:device, as reported by flink:vkGetPhysicalDeviceSurfaceSupportKHR
    or an equivalent platform-specific mechanism
****

include::{generated}/validity/protos/vkGetDeviceGroupSurfacePresentModesKHR.adoc[]
--

ifdef::VK_EXT_full_screen_exclusive[]
[open,refpage='vkGetDeviceGroupSurfacePresentModes2EXT',desc='Query device group present capabilities for a surface',type='protos']
--
To query the supported device group presentation modes for a surface
combined with select other fixed swapchain creation parameters, call:

include::{generated}/api/protos/vkGetDeviceGroupSurfacePresentModes2EXT.adoc[]

  * pname:device is the logical device.
  * pname:pSurfaceInfo is a pointer to a
    slink:VkPhysicalDeviceSurfaceInfo2KHR structure describing the surface
    and other fixed parameters that would be consumed by
    flink:vkCreateSwapchainKHR.
  * pname:pModes is a pointer to a tlink:VkDeviceGroupPresentModeFlagsKHR in
    which the supported device group present modes for the surface are
    returned.

fname:vkGetDeviceGroupSurfacePresentModes2EXT behaves similarly to
flink:vkGetDeviceGroupSurfacePresentModesKHR, with the ability to specify
extended inputs via chained input structures.

.Valid Usage
****
  * [[VUID-vkGetDeviceGroupSurfacePresentModes2EXT-pSurfaceInfo-06213]]
    pname:pSurfaceInfo->surface must: be supported by all physical devices
    associated with pname:device, as reported by
    flink:vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent
    platform-specific mechanism
****

include::{generated}/validity/protos/vkGetDeviceGroupSurfacePresentModes2EXT.adoc[]
--
endif::VK_EXT_full_screen_exclusive[]

[open,refpage='vkGetPhysicalDevicePresentRectanglesKHR',desc='Query present rectangles for a surface on a physical device',type='protos']
--
:refpage: vkGetPhysicalDevicePresentRectanglesKHR

When using ename:VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR,
the application may: need to know which regions of the surface are used when
presenting locally on each physical device.
Presentation of swapchain images to this surface need only have valid
contents in the regions returned by this command.

To query a set of rectangles used in presentation on the physical device,
call:

include::{generated}/api/protos/vkGetPhysicalDevicePresentRectanglesKHR.adoc[]

  * pname:physicalDevice is the physical device.
  * pname:surface is the surface.
  * pname:pRectCount is a pointer to an integer related to the number of
    rectangles available or queried, as described below.
  * pname:pRects is either `NULL` or a pointer to an array of slink:VkRect2D
    structures.

If pname:pRects is `NULL`, then the number of rectangles used when
presenting the given pname:surface is returned in pname:pRectCount.
Otherwise, pname:pRectCount must: point to a variable set by the application
to the number of elements in the pname:pRects array, and on return the
variable is overwritten with the number of structures actually written to
pname:pRects.
If the value of pname:pRectCount is less than the number of rectangles, at
most pname:pRectCount structures will be written, and ename:VK_INCOMPLETE
will be returned instead of ename:VK_SUCCESS, to indicate that not all the
available rectangles were returned.

The values returned by this command are not invariant, and may: change in
response to the surface being moved, resized, or occluded.

The rectangles returned by this command must: not overlap.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
include::{chapters}/commonvalidity/surface_physical_device_common.adoc[]
****

include::{generated}/validity/protos/vkGetPhysicalDevicePresentRectanglesKHR.adoc[]
--
endif::VK_BASE_VERSION_1_1,VK_KHR_device_group[]


ifdef::VK_EXT_present_timing,VK_GOOGLE_display_timing[]
== Present Timing Queries

Traditional game and real-time-animation applications frequently use
ename:VK_PRESENT_MODE_FIFO_KHR so that presentable images are updated during
the vertical blanking period of a given refresh cycle (RC) of the
presentation engine's display.
On fixed refresh rate displays, this avoids the visual anomaly known as
tearing.

However, synchronizing the presentation of images with the RC does not
prevent all forms of visual anomalies.
Stuttering occurs when the geometry for each presentable image is not
accurately positioned for when that image will be displayed.
The geometry may appear to move too little some RCs, and too much for
others.
Sometimes the animation appears to freeze, when the same image is used for
more RCs than other images.

In order to minimize stuttering, an application needs to: 1) render and
present images at a consistent rate that is, on fixed refresh rate displays,
a multiple of the presentation engine's refresh rate; 2) correctly position
its geometry for when the presentable image will be displayed to the user.
The
ifdef::VK_EXT_present_timing[]
`apiext:VK_EXT_present_timing`
endif::VK_EXT_present_timing[]
ifdef::VK_EXT_present_timing+VK_GOOGLE_display_timing[or]
ifdef::VK_GOOGLE_display_timing[]
`apiext:VK_GOOGLE_display_timing`
endif::VK_GOOGLE_display_timing[]
extension allows an application to satisfy these needs.

The presentation engine's display typically refreshes the pixels that are
displayed to the user on a periodic basis.
This period may: be fixed (Fixed Refresh Rate, FRR) or variable (Variable
Refresh Rate, VRR).

ifdef::VK_EXT_present_timing[]
[open,refpage='vkSetSwapchainPresentTimingQueueSizeEXT',desc='Allocate memory for the swapchain-internal timing results queue',type='protos']
--
In order to collect timing information about presentation, a swapchain needs
an internal queue to store asynchronously updated results until applications
collect them.

To allocate the swapchain's internal timing results queue, call:

include::{generated}/api/protos/vkSetSwapchainPresentTimingQueueSizeEXT.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to allocate a results queue for.
  * pname:size is the requested number of slots in the internal results
    queue.

If this function is called multiple times, the internal queue is reallocated
to fit the new pname:size.
If the new pname:size is less than the current number of outstanding
results, ename:VK_NOT_READY is returned and no allocation is performed.

.Valid Usage
****
  * [[VUID-vkSetSwapchainPresentTimingQueueSizeEXT-swapchain-12229]]
    pname:swapchain must: have been created with
    sname:VkSwapchainCreateInfoKHR::pname:flags containing
    ename:VK_SWAPCHAIN_CREATE_PRESENT_TIMING_BIT_EXT
****

include::{generated}/validity/protos/vkSetSwapchainPresentTimingQueueSizeEXT.adoc[]
--

[open,refpage='vkGetSwapchainTimingPropertiesEXT',desc='Obtain the display timing properties of the PE\'s display',type='protos']
--

The implementation maintains an internal monotonically increasing counter
which updates when the presentation engine's timing properties are modified.

To query the presentation engine's current timing properties for a given
swapchain, call:

include::{generated}/api/protos/vkGetSwapchainTimingPropertiesEXT.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to obtain timing properties for.
  * pname:pSwapchainTimingProperties is a pointer to an instance of the
    slink:VkSwapchainTimingPropertiesEXT structure.
  * pname:pSwapchainTimingPropertiesCounter is `NULL` or a pointer to a
    64-bit unsigned integer set by the implementation to the current value
    of the swapchain's internal timing properties counter.

If fname:vkGetSwapchainTimingPropertiesEXT returns ename:VK_NOT_READY, the
implementation was not able to determine the current refresh cycle duration.
Some platforms may: not provide timing properties until after at least one
image has been presented to the pname:swapchain.
If timing properties change for the pname:swapchain, these platforms may:
not provide updated results until after at least one additional image has
been presented to the pname:swapchain.

include::{generated}/validity/protos/vkGetSwapchainTimingPropertiesEXT.adoc[]
--

[open,refpage='VkSwapchainTimingPropertiesEXT',desc='Structure containing the RC duration of a display',type='structs']
--

The sname:VkSwapchainTimingPropertiesEXT structure is defined as:

include::{generated}/api/structs/VkSwapchainTimingPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:refreshDuration is zero or an indication of the duration of a
    refresh cycle.
  * pname:refreshInterval is zero or a duration in nanoseconds indicating
    the interval between refresh cycle durations.

If pname:refreshDuration is zero, the presentation engine is not able to
determine the duration of the refresh cycle.
Similarly, if pname:refreshInterval is zero, the presentation engine is not
able to determine whether it is operating in VRR mode.

Otherwise, if pname:refreshInterval is the same as pname:refreshDuration,
the presentation engine is operating in FRR mode.
In this case, pname:refreshDuration is the number of nanoseconds from the
start of one refresh cycle to the start of the next refresh cycle.

If pname:refreshInterval is code:UINT64_MAX, the presentation engine is
operating in VRR mode, and pname:refreshDuration is the minimum number of
nanoseconds from the start of one refresh cycle to the start of the next
refresh cycle.

If pname:refreshDuration and pname:refreshInterval are not zero,
pname:refreshInterval is a factor of pname:refreshDuration.

include::{generated}/validity/structs/VkSwapchainTimingPropertiesEXT.adoc[]
--

[NOTE]
====
The rate at which an application renders and presents new images is known as
the image present rate (IPR, a.k.a.
frame rate).
The inverse of IPR, or the duration between each image present, is the image
present duration (IPD).

In order to provide a smooth, stutter-free animation on non-VRR displays, an
application needs its IPD to be a multiple of pname:refreshInterval that is
at least equal to pname:refreshDuration.

For example, if a FRR display has a set 60Hz refresh rate, where
pname:refreshDuration is equal to pname:refreshInterval,
pname:refreshDuration will be a value in nanoseconds that is approximately
equal to 16.67ms.
In such a case, an application will want an IPD of 16.67ms (1X multiplier of
pname:refreshInterval), or 33.33ms (2X multiplier of pname:refreshInterval),
or 50.0ms (3X multiplier of pname:refreshInterval), etc.

In order to determine a target IPD for a display (i.e. a multiple of
pname:refreshInterval), an application needs to determine when its images
are actually displayed.

Consider an application that has an initial target IPD of 16.67ms (1X
multiplier of pname:refreshDuration).
It will therefore position the geometry of a new image 16.67ms later than
the previous image.

If this application is running on slower hardware, so that it actually takes
20ms to render each new image, the images will not be displayed to the user
every 16.67ms, nor every 20ms, which will create visual anomalies.
In this case, it is better for the application to adjust its target IPD to
33.33ms (i.e. a 2X multiplier of pname:refreshDuration), and tell the
presentation engine to not present images any sooner than every 33.33ms.
This will allow the geometry to be correctly positioned for each presentable
image.

On VRR displays, where pname:refreshInterval is code:UINT64_MAX,
applications should: target an IPD that is at least equal to
pname:refreshDuration.

Adjustments to an application's IPD may be needed because different views of
an application's geometry can take different amounts of time to render.
For example, looking at the sky may take less time to render than looking at
multiple, complex items in a room.

In general, it is good to not frequently change IPD, as that can cause
visual anomalies.

Adjustments to a larger IPD because of late images should happen quickly,
but adjustments to a smaller IPD should only happen if the periodic feedback
of slink:VkPastPresentationTimingEXT values indicates that the target IPD
can be durably achieved.
====

[open,refpage='vkGetSwapchainTimeDomainPropertiesEXT',desc='Obtain the time domains supported by the PE for the swapchain',type='protos']
--
The implementation maintains an internal monotonically increasing counter
which updates when the presentation engine's list of supported time domains
for a swapchain is modified.

To query the time domains supported by the presentation engine for a given
swapchain, call:

include::{generated}/api/protos/vkGetSwapchainTimeDomainPropertiesEXT.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to obtain time domain properties for.
  * pname:pSwapchainTimeDomainProperties is a pointer to an instance of the
    slink:VkSwapchainTimeDomainPropertiesEXT structure.
  * pname:pTimeDomainsCounter is `NULL` or a pointer to a 64-bit unsigned
    integer set by the implementation to the current value of the
    swapchain's internal time domain properties counter.

If upon return
slink:VkSwapchainTimeDomainPropertiesEXT::pname:timeDomainCount is smaller
than the number of time domains supported for the given pname:swapchain,
ename:VK_INCOMPLETE will be returned instead of ename:VK_SUCCESS to indicate
that not all the available values were returned.

include::{generated}/validity/protos/vkGetSwapchainTimeDomainPropertiesEXT.adoc[]
--

[open,refpage='VkSwapchainTimeDomainPropertiesEXT',desc='List of available time domains for a swapchain',type='structs']
--

The sname:VkSwapchainTimeDomainPropertiesEXT structure is defined as:

include::{generated}/api/structs/VkSwapchainTimeDomainPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:timeDomainCount is an integer related to the number of time
    domains available or queried, as described below.
  * pname:pTimeDomains is a pointer to an array of elink:VkTimeDomainKHR
    values representing time domains that are available for the swapchain.
  * pname:pTimeDomainIds is a pointer to an array of unique identifiers for
    each time domain.

When calling flink:vkGetSwapchainTimeDomainPropertiesEXT, if
pname:pTimeDomains is `NULL` and pname:pTimeDomainIds is `NULL`, then the
number of time domains supported for the given pname:swapchain is returned
in pname:timeDomainCount.
Otherwise, pname:timeDomainCount must: specify the number of elements in the
pname:pTimeDomains, pname:pTimeDomainIds, or both arrays, and on return is
overwritten with the number of values actually written to either array.

[NOTE]
====
Due to the dynamic nature of their underlying sname:VkSurfaceKHR properties,
swapchains may need to expose multiple swapchain-local opaque time domains
using the same elink:VkTimeDomainKHR value over time, for example when a
surface is moved from one display hardware to another.
Arbitrary identifiers, provided in pname:timeDomainIds, are used by the
implementation to differentiate opaque time domains of identical scopes.
====

include::{generated}/validity/structs/VkSwapchainTimeDomainPropertiesEXT.adoc[]
--

[open,refpage='vkGetPastPresentationTimingEXT',desc='Obtain timing of previously-presented images',type='protos']
--

Because of the asynchronous nature of the presentation engine, the timing
information for a given flink:vkQueuePresentKHR command may: only becomes
available some time after the presentation has occurred.
These time values should: be asynchronously queried, and are returned if
available.
All time values are in nanoseconds, according to the time-domain being used.

To asynchronously query the presentation engine for newly-available timing
information about one or more previous presents to a given swapchain, call:

include::{generated}/api/protos/vkGetPastPresentationTimingEXT.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:pPastPresentationTimingInfo is a pointer to an instance of the
    slink:VkPastPresentationTimingInfoEXT structure.
  * pname:pPastPresentationTimingProperties is a pointer to an instance of
    the slink:VkPastPresentationTimingPropertiesEXT structure.

If upon return the value of
sname:VkPastPresentationTimingPropertiesEXT::pname:presentationTimingCount
is less than the number of available timing records for the given
sname:VkPastPresentationTimingInfoEXT::pname:swapchain, ename:VK_INCOMPLETE
is returned instead of ename:VK_SUCCESS to indicate that not all the
available values were returned.

Upon return, zero or more slots of the pname:swapchain internal timing
results queue, equal to the number of entries written to
sname:VkPastPresentationTimingPropertiesEXT::pname:pPresentationTimings for
which pname:reportComplete is ename:VK_TRUE, are made available for future
fname:vkQueuePresentKHR calls.
Elements of pname:pPresentationTimings are arranged in ascending order of
present ids.

Timing information may: become available out of order with regards to their
associated flink:vkQueuePresentKHR order.
ename:VK_PAST_PRESENTATION_TIMING_ALLOW_OUT_OF_ORDER_RESULTS_BIT_EXT can: be
set in sname:VkPastPresentationTimingInfoEXT::pname:flags to allow
fname:vkGetPastPresentationTimingEXT to return results in that same order.
Otherwise, results are returned in the order of their associated
flink:vkQueuePresentKHR calls.

There is no requirement for any precise timing relationship between the
completion of a present stage and the availability of any associated timing
information.
However, results must: be made available in finite time.

As an exception to the normal rules for objects which are externally
synchronized, pname:swapchain may: be simultaneously used by other threads
in calls to functions other than flink:vkDestroySwapchainKHR and
flink:vkCreateSwapchainKHR with pname:swapchain used as an
pname:oldSwapchain.
Access to the swapchain timing information must: be atomic within the
implementation.

.Valid Usage
****
  * [[VUID-vkGetPastPresentationTimingEXT-flags-12230]]
    If ename:VK_PAST_PRESENTATION_TIMING_ALLOW_OUT_OF_ORDER_RESULTS_BIT_EXT
    is set in sname:VkPastPresentationTimingInfoEXT::pname:flags, the
    pname:presentStageCount value of each element of
    sname:VkPastPresentationTimingPropertiesEXT::pname:pPresentationTimings
    must: be at least the maximum number of present stages set in
    slink:VkPresentTimingInfoEXT::pname:presentStageQueries among all
    flink:vkQueuePresentKHR calls, with a non-zero
    pname:presentStageQueries, for which complete results have not been
    returned yet by a previous call
  * [[VUID-vkGetPastPresentationTimingEXT-flags-12231]]
    If ename:VK_PAST_PRESENTATION_TIMING_ALLOW_OUT_OF_ORDER_RESULTS_BIT_EXT
    is not set in sname:VkPastPresentationTimingInfoEXT::pname:flags, the
    pname:presentStageCount value of each element of
    sname:VkPastPresentationTimingPropertiesEXT::pname:pPresentationTimings
    must: be at least the number of present stages set in
    sname:VkPresentTimingInfoEXT::pname:presentStageQueries for the earliest
    call to fname:vkQueuePresentKHR, with a non-zero
    pname:presentStageQueries, that corresponds to that element's index and
    for which complete results have not been returned yet by a previous call
****

include::{generated}/validity/protos/vkGetPastPresentationTimingEXT.adoc[]
--

[open,refpage='VkPastPresentationTimingInfoEXT',desc='Structure specifying swapchain present timing query parameters',type='structs']
--

The sname:VkPastPresentationTimingInfoEXT structure is defined as:

include::{generated}/api/structs/VkPastPresentationTimingInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkPastPresentationTimingFlagBitsEXT
    specifying options for queries of past presentation timing information.
  * pname:swapchain is the swapchain to obtain presentation timing
    information for.

include::{generated}/validity/structs/VkPastPresentationTimingInfoEXT.adoc[]
--

[open,refpage='VkPastPresentationTimingFlagsEXT',desc='Bitmask of VkPastPresentationTimingFlagBitsEXT',type='flags']
--
include::{generated}/api/flags/VkPastPresentationTimingFlagsEXT.adoc[]

tname:VkPastPresentationTimingFlagsEXT is a bitmask type for setting a mask
of zero or more elink:VkPastPresentationTimingFlagBitsEXT.
--

[open,refpage='VkPastPresentationTimingFlagBitsEXT',desc='Bitmask specifying past presentation timing query flags',type='enums']
--
Bits which can: be set in
slink:VkPastPresentationTimingInfoEXT::pname:flags, specifying options for
queries of past presentation timing information, are:

include::{generated}/api/enums/VkPastPresentationTimingFlagBitsEXT.adoc[]

  * ename:VK_PAST_PRESENTATION_TIMING_ALLOW_PARTIAL_RESULTS_BIT_EXT
    specifies that flink:vkGetPastPresentationTimingEXT may: return partial
    results for presentation requests that have not completed all requested
    present stages.
  * ename:VK_PAST_PRESENTATION_TIMING_ALLOW_OUT_OF_ORDER_RESULTS_BIT_EXT
    specifies that flink:vkGetPastPresentationTimingEXT may: return results
    out of order with respect to the presentation order.
--

[open,refpage='VkPastPresentationTimingPropertiesEXT',desc='Structure containing details about a swapchain past presentation activity',type='structs']
--

The sname:VkPastPresentationTimingPropertiesEXT structure is defined as:

include::{generated}/api/structs/VkPastPresentationTimingPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:timingPropertiesCounter is a 64-bit unsigned integer set by the
    implementation to the current value of the swapchain's internal timing
    properties counter.
  * pname:timeDomainsCounter is a 64-bit unsigned integer set by the
    implementation to the current value of the swapchain's internal time
    domains list counter.
  * pname:presentationTimingCount is an integer related to the number of
    slink:VkPastPresentationTimingEXT structures available or queried, as
    described below.
  * pname:pPresentationTimings is `NULL` or a pointer to an array of
    slink:VkPastPresentationTimingEXT structures.

When calling flink:vkGetPastPresentationTimingEXT, if
pname:pPresentationTimings is `NULL`, then the number of available timing
records for the given pname:swapchain is returned in
pname:presentationTimingCount.
Otherwise, pname:presentationTimingCount must: specify the number of
elements in the pname:pPresentationTimings array, and on return is
overwritten with the number of structures actually written to
pname:pPresentationTimings.

if ename:VK_PAST_PRESENTATION_TIMING_ALLOW_PARTIAL_RESULTS_BIT_EXT is
specified in slink:VkPastPresentationTimingInfoEXT::pname:flags,
fname:vkGetPastPresentationTimingEXT may: return incomplete results,
containing only information for a subset of the requested present stages.
Further calls to fname:vkGetPastPresentationTimingEXT will keep providing
all available results for a previously incomplete entry until it is
complete.

The implementation must: return a slink:VkPastPresentationTimingEXT for
every flink:vkQueuePresentKHR referencing pname:swapchain where a non-zero
slink:VkPresentTimingInfoEXT::pname:presentStageQueries was specified and at
least one present stage has available results.

include::{generated}/validity/structs/VkPastPresentationTimingPropertiesEXT.adoc[]
--

[NOTE]
====
The presentation engine may: change the timing properties of the
pname:swapchain for a variety of reasons.

This may: occur, for example, if the window system changes its mode,
including the refresh rate of the display.
Another example is if an application's surface is being composited with
other windows of a window system, and then the surface's window becomes a
borderless, full-screen window.
While composited, the timing properties may: be FRR, and while full-screen,
the timing properties may: be VRR.

The available time domains for a swapchain may: change for similar or
identical reasons.
Therefore, it is possible that the same event will cause both the
swapchain's internal timing properties counter and time domains list counter
to update.
====

[open,refpage='VkPastPresentationTimingEXT',desc='Structure containing timing information about a previously-presented image',type='structs']
--

The sname:VkPastPresentationTimingEXT structure is defined as:

include::{generated}/api/structs/VkPastPresentationTimingEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentId is zero or a value that was given to a previous
    fname:vkQueuePresentKHR command via
    slink:VkPresentId2KHR::pname:pPresentIds.
  * pname:targetTime is the application-provided target absolute time or
    duration of the associated presentation request in
    slink:VkPresentTimingInfoEXT::pname:targetTime.
  * pname:presentStageCount is a count of items contained in
    pname:pPresentStages.
  * pname:pPresentStages a pointer to an array of
    slink:VkPresentStageTimeEXT providing timing information for the
    presentation request associated with pname:presentId.
  * pname:timeDomain is the time domain used by the presentation engine to
    report times in pname:pPresentStages.
  * pname:timeDomainId is the id associated with pname:timeDomain.
  * pname:reportComplete is ename:VK_TRUE if the presentation engine has
    reported all the requested results in pname:pPresentStages.

When calling flink:vkGetPastPresentationTimingEXT, the implementation sets
pname:presentStageCount to the number of present stages it has written
results for.
If ename:VK_PAST_PRESENTATION_TIMING_ALLOW_PARTIAL_RESULTS_BIT_EXT was
specified in slink:VkPastPresentationTimingInfoEXT::pname:flags, the
implementation may: return an incomplete report containing fewer present
stage results than were queried by the associated presentation request.
Otherwise, results for all the present stages queried by the presentation
request are written by the implementation.

Timing information for some present stages may: have a time value of 0,
indicating that results for that present stage are not available.

For systems with multiple entities operating within the presentation engine,
such as multiple displays, pname:pPresentStages will return timing results
for one entity which has been affected by the presentation.

pname:timeDomainId may: be different than the time domain that was specified
in sname:VkPresentTimingInfoEXT::pname:timeDomainId if the requirements for
using this time domain could not be met at the time the presentation engine
processed the presentation request.
In such a case, the presentation engine may: pick a time domain to fall back
to, if one is available, and report results in that domain.
Applications can: continue to use this fallback time domain in future
fname:vkQueuePresentKHR calls, or they can: call
flink:vkGetSwapchainTimeDomainPropertiesEXT to choose from the currently
supported time domains.

include::{generated}/validity/structs/VkPastPresentationTimingEXT.adoc[]
--

[open,refpage='VkPresentStageTimeEXT',desc='Associate a present stage with a timestamp',type='structs']
--
The sname:VkPresentStageTimeEXT structure is defined as:

include::{generated}/api/structs/VkPresentStageTimeEXT.adoc[]

  * pname:stage is a tlink:VkPresentStageFlagsEXT value specifying a present
    stage.
  * pname:time is a time in nanoseconds associated with the pname:stage.

include::{generated}/validity/structs/VkPresentStageTimeEXT.adoc[]
--
endif::VK_EXT_present_timing[]

ifdef::VK_GOOGLE_display_timing[]
[open,refpage='vkGetRefreshCycleDurationGOOGLE',desc='Obtain the RC duration of the PE\'s display',type='protos']
--
To query the duration of a refresh cycle (RC) for the presentation engine's
display, call:

include::{generated}/api/protos/vkGetRefreshCycleDurationGOOGLE.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to obtain the refresh duration for.
  * pname:pDisplayTimingProperties is a pointer to a
    sname:VkRefreshCycleDurationGOOGLE structure.

include::{generated}/validity/protos/vkGetRefreshCycleDurationGOOGLE.adoc[]
--

[open,refpage='VkRefreshCycleDurationGOOGLE',desc='Structure containing the RC duration of a display',type='structs']
--
The sname:VkRefreshCycleDurationGOOGLE structure is defined as:

include::{generated}/api/structs/VkRefreshCycleDurationGOOGLE.adoc[]

  * pname:refreshDuration is the number of nanoseconds from the start of one
    refresh cycle to the next.

include::{generated}/validity/structs/VkRefreshCycleDurationGOOGLE.adoc[]
--

[open,refpage='vkGetPastPresentationTimingGOOGLE',desc='Obtain timing of a previously-presented image',type='protos']
--
The implementation will maintain a limited amount of history of timing
information about previous presents.
Because of the asynchronous nature of the presentation engine, the timing
information for a given flink:vkQueuePresentKHR command will become
available some time later.
These time values can be asynchronously queried, and will be returned if
available.
All time values are in nanoseconds, relative to a monotonically-increasing
clock (e.g. `CLOCK_MONOTONIC` (see clock_gettime(2)) on Android and Linux).

To asynchronously query the presentation engine, for newly-available timing
information about one or more previous presents to a given swapchain, call:

include::{generated}/api/protos/vkGetPastPresentationTimingGOOGLE.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to obtain presentation timing
    information duration for.
  * pname:pPresentationTimingCount is a pointer to an integer related to the
    number of sname:VkPastPresentationTimingGOOGLE structures to query, as
    described below.
  * pname:pPresentationTimings is either `NULL` or a pointer to an array of
    sname:VkPastPresentationTimingGOOGLE structures.

If pname:pPresentationTimings is `NULL`, then the number of newly-available
timing records for the given pname:swapchain is returned in
pname:pPresentationTimingCount.
Otherwise, pname:pPresentationTimingCount must: point to a variable set by
the user to the number of elements in the pname:pPresentationTimings array,
and on return the variable is overwritten with the number of structures
actually written to pname:pPresentationTimings.
If the value of pname:pPresentationTimingCount is less than the number of
newly-available timing records, at most pname:pPresentationTimingCount
structures will be written, and ename:VK_INCOMPLETE will be returned instead
of ename:VK_SUCCESS, to indicate that not all the available timing records
were returned.

include::{generated}/validity/protos/vkGetPastPresentationTimingGOOGLE.adoc[]
--

[open,refpage='VkPastPresentationTimingGOOGLE',desc='Structure containing timing information about a previously-presented image',type='structs']
--
The sname:VkPastPresentationTimingGOOGLE structure is defined as:

include::{generated}/api/structs/VkPastPresentationTimingGOOGLE.adoc[]

  * pname:presentID is an application-provided value that was given to a
    previous fname:vkQueuePresentKHR command via
    slink:VkPresentTimeGOOGLE::pname:presentID (see below).
    It can: be used to uniquely identify a previous present with the
    flink:vkQueuePresentKHR command.
  * pname:desiredPresentTime is an application-provided value that was given
    to a previous flink:vkQueuePresentKHR command via
    slink:VkPresentTimeGOOGLE::pname:desiredPresentTime.
    If non-zero, it was used by the application to indicate that an image
    not be presented any sooner than pname:desiredPresentTime.
  * pname:actualPresentTime is the time when the image of the
    pname:swapchain was actually displayed.
  * pname:earliestPresentTime is the time when the image of the
    pname:swapchain could have been displayed.
    This may: differ from pname:actualPresentTime if the application
    requested that the image be presented no sooner than
    slink:VkPresentTimeGOOGLE::pname:desiredPresentTime.
  * pname:presentMargin is an indication of how early the
    fname:vkQueuePresentKHR command was processed compared to how soon it
    needed to be processed, and still be presented at
    pname:earliestPresentTime.

The results for a given pname:swapchain and pname:presentID are only
returned once from fname:vkGetPastPresentationTimingGOOGLE.

The application can: use the sname:VkPastPresentationTimingGOOGLE values to
occasionally adjust its timing.
For example, if pname:actualPresentTime is later than expected (e.g. one
pname:refreshDuration late), the application may increase its target IPD to
a higher multiple of pname:refreshDuration (e.g. decrease its frame rate
from 60Hz to 30Hz).
If pname:actualPresentTime and pname:earliestPresentTime are consistently
different, and if pname:presentMargin is consistently large enough, the
application may decrease its target IPD to a smaller multiple of
pname:refreshDuration (e.g. increase its frame rate from 30Hz to 60Hz).
If pname:actualPresentTime and pname:earliestPresentTime are same, and if
pname:presentMargin is consistently high, the application may delay the
start of its input-render-present loop in order to decrease the latency
between user input and the corresponding present (always leaving some margin
in case a new image takes longer to render than the previous image).
An application that desires its target IPD to always be the same as
pname:refreshDuration, can also adjust features until
pname:actualPresentTime is never late and pname:presentMargin is
satisfactory.
--

The full `apiext:VK_GOOGLE_display_timing` extension semantics are described
for swapchains created with ename:VK_PRESENT_MODE_FIFO_KHR.
For example, non-zero values of
sname:VkPresentTimeGOOGLE::pname:desiredPresentTime must: be honored, and
fname:vkGetPastPresentationTimingGOOGLE should: return a
sname:VkPastPresentationTimingGOOGLE structure with valid values for all
images presented with fname:vkQueuePresentKHR.
The semantics for other present modes are as follows:

  * ename:VK_PRESENT_MODE_IMMEDIATE_KHR.
    The presentation engine may: ignore non-zero values of
    sname:VkPresentTimeGOOGLE::pname:desiredPresentTime in favor of
    presenting immediately.
    The value of
    sname:VkPastPresentationTimingGOOGLE::pname:earliestPresentTime must: be
    the same as
    sname:VkPastPresentationTimingGOOGLE::pname:actualPresentTime, which
    should: be when the presentation engine displayed the image.
  * ename:VK_PRESENT_MODE_MAILBOX_KHR.
    The intention of using this present mode with this extension is to
    handle cases where an image is presented late, and the next image is
    presented soon enough to replace it at the next vertical blanking
    period.
    For images that are displayed to the user, the value of
    sname:VkPastPresentationTimingGOOGLE::pname:actualPresentTime must: be
    when the image was displayed.
    For images that are not displayed to the user,
    fname:vkGetPastPresentationTimingGOOGLE may: not return a
    sname:VkPastPresentationTimingGOOGLE structure, or it may: return a
    sname:VkPastPresentationTimingGOOGLE structure with the value of zero
    for both sname:VkPastPresentationTimingGOOGLE::pname:actualPresentTime
    and sname:VkPastPresentationTimingGOOGLE::pname:earliestPresentTime.
    It is possible that an application can: submit images with
    sname:VkPresentTimeGOOGLE::pname:desiredPresentTime values such that new
    images may: not be displayed.
    For example, if sname:VkPresentTimeGOOGLE::pname:desiredPresentTime is
    far enough in the future that an image is not presented before
    fname:vkQueuePresentKHR is called to present another image, the first
    image will not be displayed to the user.
    If the application continues to do that, the presentation engine may:
    not display new images.
  * ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR.
    For images that are presented in time to be displayed at the next
    vertical blanking period, the semantics are identical as for
    ename:VK_PRESENT_MODE_FIFO_KHR.
    For images that are presented late, and are displayed after the start of
    the vertical blanking period (i.e. with tearing), the values of
    sname:VkPastPresentationTimingGOOGLE may: be treated as if the image was
    displayed at the start of the vertical blanking period, or may: be
    treated the same as for ename:VK_PRESENT_MODE_IMMEDIATE_KHR.
endif::VK_GOOGLE_display_timing[]
endif::VK_EXT_present_timing,VK_GOOGLE_display_timing[]


ifdef::VK_KHR_present_wait[]
ifndef::VK_KHR_present_wait2[]
[[present-wait]]
== Present Wait

Applications wanting to control the pacing of the application by monitoring
when presentation processes have completed to limit the number of
outstanding images queued for presentation, need to have a method of being
signaled during the presentation process.

ifdef::VK_GOOGLE_display_timing,VK_KHR_present_timing[]
Using
ifdef::VK_KHR_present_timing[]
the `apiext:VK_KHR_present_timing` extension
ifdef::VK_GOOGLE_display_timing[or]
endif::VK_KHR_present_timing[]
ifdef::VK_GOOGLE_display_timing[]
the `apiext:VK_GOOGLE_display_timing` extension
endif::VK_GOOGLE_display_timing[]
applications can discover when images were presented, but only
asynchronously.
endif::VK_GOOGLE_display_timing,VK_KHR_present_timing[]

Providing a mechanism which allows applications to block, waiting for a
specific step of the presentation process to complete allows them to control
the amount of outstanding work (and hence the potential lag in responding to
user input or changes in the rendering environment).

The `apiext:VK_KHR_present_wait` extension allows applications to tell the
presentation engine at the flink:vkQueuePresentKHR call that it plans on
waiting for presentation by passing a slink:VkPresentIdKHR structure.
The pname:presentId passed in that structure may then be passed to a future
flink:vkWaitForPresentKHR call to cause the application to block until that
presentation is finished.

endif::VK_KHR_present_wait2[]
endif::VK_KHR_present_wait[]


ifdef::VK_KHR_present_wait2[]
[[present-wait2]]
== Present Wait

Applications wanting to control the pacing of the application by monitoring
when presentation processes have completed to limit the number of
outstanding images queued for presentation, need to have a method of being
signaled during the presentation process.

ifdef::VK_GOOGLE_display_timing[]
Using the `apiext:VK_GOOGLE_display_timing` extension, applications can
discover when images were presented, but only asynchronously.
endif::VK_GOOGLE_display_timing[]

Providing a mechanism which allows applications to block, waiting for a
specific step of the presentation process to complete allows them to control
the amount of outstanding work (and hence the potential lag in responding to
user input or changes in the rendering environment).

The `apiext:VK_KHR_present_wait2` extension allows applications to tell the
presentation engine at the flink:vkQueuePresentKHR call that it plans on
waiting for presentation by passing a slink:VkPresentId2KHR structure.
The pname:presentId passed in that structure may then be passed to a future
flink:vkWaitForPresent2KHR call to cause the application to block until that
presentation is finished.

This functionality was originally provided by the
`apiext:VK_KHR_present_wait` extension, which has been deprecated and
replaced by `apiext:VK_KHR_present_wait2`.

[open,refpage='VkPresentWait2InfoKHR',desc='Structure describing parameters of a presentation wait',type='structs']
--
The sname:VkPresentWait2InfoKHR structure is defined as:

include::{generated}/api/structs/VkPresentWait2InfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentId is the presentation presentId to wait for.
  * pname:timeout is the timeout period in units of nanoseconds.
    pname:timeout is adjusted to the closest value allowed by the
    implementation-dependent timeout accuracy, which may: be substantially
    longer than one nanosecond, and may: be longer than the requested
    period.

include::{generated}/validity/structs/VkPresentWait2InfoKHR.adoc[]
--
endif::VK_KHR_present_wait2[]


[[wsi-swapchain]]
== WSI Swapchain

[open,refpage='VkSwapchainKHR',desc='Opaque handle to a swapchain object',type='handles',xrefs='vkQueuePresentKHR']
--
A swapchain object (a.k.a.
swapchain) provides the ability to present rendering results to a surface.
Swapchain objects are represented by sname:VkSwapchainKHR handles:

include::{generated}/api/handles/VkSwapchainKHR.adoc[]

A swapchain is an abstraction for an array of presentable images that are
associated with a surface.
The presentable images are represented by sname:VkImage objects created by
the platform.
One image (which can: be an array image for multiview/stereoscopic-3D
surfaces) is displayed at a time, but multiple images can: be queued for
presentation.
An application renders to the image, and then queues the image for
presentation to the surface.

A native window cannot: be associated with more than one non-retired
swapchain at a time.
Further, swapchains cannot: be created for native windows that have a
non-Vulkan graphics API surface associated with them.

[NOTE]
====
The presentation engine is an abstraction for the platform's compositor or
display engine.

The presentation engine may: be synchronous or asynchronous with respect to
the application and/or logical device.

Some implementations may: use the device's graphics queue or dedicated
presentation hardware to perform presentation.
====

The presentable images of a swapchain are owned by the presentation engine.
An application can: acquire use of a presentable image from the presentation
engine.
Use of a presentable image must: occur only after the image is returned by
flink:vkAcquireNextImageKHR, and before it is released by
flink:vkQueuePresentKHR.
This includes transitioning the image layout and rendering commands.

An application can: acquire use of a presentable image with
flink:vkAcquireNextImageKHR.
After acquiring a presentable image and before modifying it, the application
must: use a synchronization primitive to ensure that the presentation engine
has finished reading from the image.
The application can: then transition the image's layout, queue rendering
commands to it, etc.
Finally, the application presents the image with flink:vkQueuePresentKHR,
which releases the acquisition of the image.
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
The application can: also release the acquisition of the image through
flink:vkReleaseSwapchainImagesKHR, if the image is not in use by the device,
and skip the present operation.
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]

The presentation engine controls the order in which presentable images are
acquired for use by the application.

[NOTE]
====
This allows the platform to handle situations which require out-of-order
return of images after presentation.
At the same time, it allows the application to generate command buffers
referencing all of the images in the swapchain at initialization time,
rather than in its main loop.
====

ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scremoved_swapchain[]
  * fname:vkDestroySwapchainKHR <<SCID-4>>
// end::scremoved_swapchain[]
endif::hidden[]

Swapchains cannot: be destroyed <<SCID-4>>.
If <<limits-deviceDestroyFreesMemory,
slink:VkPhysicalDeviceVulkanSC10Properties::pname:deviceDestroyFreesMemory>>
is ename:VK_TRUE, the memory for swapchain images is returned to the system
when the device is destroyed.
Otherwise, it may: not be returned to the system until the process is
terminated.

endif::VKSC_VERSION_1_0[]
--

How this all works is described below.

ifdef::VK_KHR_shared_presentable_image[]
If a swapchain is created with pname:presentMode set to either
ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or
ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, a single presentable
image can: be acquired, referred to as a shared presentable image.
A shared presentable image may: be concurrently accessed by the application
and the presentation engine, without transitioning the image's layout after
it is initially presented.

  * With ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR, the presentation
    engine is only required to update to the latest contents of a shared
    presentable image after a present.
    The application must: call fname:vkQueuePresentKHR to guarantee an
    update.
    However, the presentation engine may: update from it at any time.
  * With ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, the
    presentation engine will automatically present the latest contents of a
    shared presentable image during every refresh cycle.
    The application is only required to make one initial call to
    fname:vkQueuePresentKHR, after which the presentation engine will update
    from it without any need for further present calls.
    The application can: indicate the image contents have been updated by
    calling fname:vkQueuePresentKHR, but this does not guarantee the timing
    of when updates will occur.

The presentation engine may: access a shared presentable image at any time
after it is first presented.
To avoid tearing, an application should: coordinate access with the
presentation engine.
This requires presentation engine timing information through
platform-specific mechanisms and ensuring that color attachment writes are
made available during the portion of the presentation engine's refresh cycle
they are intended for.

[NOTE]
====
The `apiext:VK_KHR_shared_presentable_image` extension does not provide
functionality for determining the timing of the presentation engine's
refresh cycles.
====

[open,refpage='vkGetSwapchainStatusKHR',desc='Get a swapchain\'s status',type='protos']
--
:refpage: vkGetSwapchainStatusKHR

In order to query a swapchain's status when rendering to a shared
presentable image, call:
include::{generated}/api/protos/vkGetSwapchainStatusKHR.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to query.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkGetSwapchainStatusKHR.adoc[]
--

The possible return values for fname:vkGetSwapchainStatusKHR should: be
interpreted as follows:

  * ename:VK_SUCCESS specifies the presentation engine is presenting the
    contents of the shared presentable image, as per the swapchain's
    elink:VkPresentModeKHR.
  * ename:VK_SUBOPTIMAL_KHR the swapchain no longer matches the surface
    properties exactly, but the presentation engine is presenting the
    contents of the shared presentable image, as per the swapchain's
    elink:VkPresentModeKHR.
  * ename:VK_ERROR_OUT_OF_DATE_KHR the surface has changed in such a way
    that it is no longer compatible with the swapchain.
  * ename:VK_ERROR_SURFACE_LOST_KHR the surface is no longer available.

[NOTE]
====
The swapchain state may: be cached by implementations, so applications
should: regularly call fname:vkGetSwapchainStatusKHR when using a swapchain
with elink:VkPresentModeKHR equal to
ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR.
====


endif::VK_KHR_shared_presentable_image[]

[open,refpage='vkCreateSwapchainKHR',desc='Create a swapchain',type='protos']
--
:refpage: vkCreateSwapchainKHR
:objectnameplural: swapchains
:objectnamecamelcase: swapchain
:objectnamestruct: VkDeviceObjectReservationCreateInfo
:objectcount: 1

To create a swapchain, call:

include::{generated}/api/protos/vkCreateSwapchainKHR.adoc[]

  * pname:device is the device to create the swapchain for.
  * pname:pCreateInfo is a pointer to a slink:VkSwapchainCreateInfoKHR
    structure specifying the parameters of the created swapchain.
  * pname:pAllocator is the allocator used for host memory allocated for the
    swapchain object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).
  * pname:pSwapchain is a pointer to a slink:VkSwapchainKHR handle in which
    the created swapchain object will be returned.

As mentioned above, if fname:vkCreateSwapchainKHR succeeds, it will return a
handle to a swapchain containing an array of at least
pname:pCreateInfo->minImageCount presentable images.

While acquired by the application, presentable images can: be used in any
way that equivalent non-presentable images can: be used.
A presentable image is equivalent to a non-presentable image created with
the following slink:VkImageCreateInfo parameters:

[[swapchain-wsi-image-create-info]]
[options="header"]
|====
| sname:VkImageCreateInfo Field | Value
ifndef::VK_BASE_VERSION_1_1,VK_KHR_device_group,VK_KHR_swapchain_mutable_format[]
| pname:flags                   | 0
endif::VK_BASE_VERSION_1_1,VK_KHR_device_group,VK_KHR_swapchain_mutable_format[]
ifdef::VK_BASE_VERSION_1_1,VK_KHR_device_group,VK_KHR_swapchain_mutable_format[]
| pname:flags                   |
ifdef::VK_BASE_VERSION_1_1,VK_KHR_device_group[]
ename:VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT is set if
ename:VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR is set

endif::VK_BASE_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_BASE_VERSION_1_1[]
ename:VK_IMAGE_CREATE_PROTECTED_BIT is set if
ename:VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR is set

endif::VK_BASE_VERSION_1_1[]
ifdef::VK_KHR_swapchain_mutable_format[]
ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT and
ename:VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR are both set if
ename:VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR is set

endif::VK_KHR_swapchain_mutable_format[]
all other bits are unset
endif::VK_BASE_VERSION_1_1,VK_KHR_device_group,VK_KHR_swapchain_mutable_format[]
| pname:imageType               | ename:VK_IMAGE_TYPE_2D
| pname:format                  | pname:pCreateInfo->imageFormat
| pname:extent                  | {pname:pCreateInfo->imageExtent.width, pname:pCreateInfo->imageExtent.height, `1`}
| pname:mipLevels               | 1
| pname:arrayLayers             | pname:pCreateInfo->imageArrayLayers
| pname:samples                 | ename:VK_SAMPLE_COUNT_1_BIT
| pname:tiling                  | ename:VK_IMAGE_TILING_OPTIMAL
| pname:usage                   | pname:pCreateInfo->imageUsage
| pname:sharingMode             | pname:pCreateInfo->imageSharingMode
| pname:queueFamilyIndexCount   | pname:pCreateInfo->queueFamilyIndexCount
| pname:pQueueFamilyIndices     | pname:pCreateInfo->pQueueFamilyIndices
| pname:initialLayout           | ename:VK_IMAGE_LAYOUT_UNDEFINED
|====

The pname:pCreateInfo->surface must: not be destroyed until after the
swapchain is destroyed.

ifdef::VKSC_VERSION_1_0[If]
ifndef::VKSC_VERSION_1_0[If pname:oldSwapchain is dlink:VK_NULL_HANDLE, and]
the native window referred to by pname:pCreateInfo->surface is already
associated with a Vulkan swapchain, ename:VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
must: be returned.

ifndef::VKSC_VERSION_1_0[]
ifdef::VK_KHR_present_wait2[]
If pname:oldSwapchain is a valid swapchain and there are outstanding calls
to fname:vkWaitForPresent2KHR, then fname:vkCreateSwapchainKHR may: block
until those calls complete.
endif::VK_KHR_present_wait2[]
endif::VKSC_VERSION_1_0[]

If the native window referred to by pname:pCreateInfo->surface is already
associated with a non-Vulkan graphics API surface,
ename:VK_ERROR_NATIVE_WINDOW_IN_USE_KHR must: be returned.

The native window referred to by pname:pCreateInfo->surface must: not become
associated with a non-Vulkan graphics API surface before all associated
Vulkan swapchains have been destroyed.

fname:vkCreateSwapchainKHR will return ename:VK_ERROR_DEVICE_LOST if the
logical device was lost.
ifndef::VKSC_VERSION_1_0[]
The sname:VkSwapchainKHR is a child of the pname:device, and must: be
destroyed before the pname:device.
endif::VKSC_VERSION_1_0[]
However, sname:VkSurfaceKHR is not a child of any sname:VkDevice and is not
affected by the lost device.
After successfully recreating a sname:VkDevice, the same sname:VkSurfaceKHR
can: be used to create a new sname:VkSwapchainKHR, provided the previous one
was destroyed.

ifdef::VK_EXT_full_screen_exclusive[]
If the pname:oldSwapchain parameter of pname:pCreateInfo is a valid
swapchain, which has exclusive full-screen access, that access is released
from pname:pCreateInfo->oldSwapchain.
If the command succeeds in this case, the newly created swapchain will
automatically acquire exclusive full-screen access from
pname:pCreateInfo->oldSwapchain.

[NOTE]
====
This implicit transfer is intended to avoid exiting and entering full-screen
exclusive mode, which may otherwise cause unwanted visual updates to the
display.
====

In some cases, swapchain creation may: fail if exclusive full-screen mode is
requested for application control, but for some implementation-specific
reason exclusive full-screen access is unavailable for the particular
combination of parameters provided.
If this occurs, ename:VK_ERROR_INITIALIZATION_FAILED will be returned.

[NOTE]
====
In particular, it will fail if the pname:imageExtent member of
pname:pCreateInfo does not match the extents of the monitor.
ifdef::VK_KHR_win32_surface[]
Other reasons for failure may include the application not being set as
high-dpi aware, or if the physical device and monitor are not compatible in
this mode.
endif::VK_KHR_win32_surface[]
====

endif::VK_EXT_full_screen_exclusive[]

ifdef::VK_NV_present_barrier[]
If the pname:pNext chain of slink:VkSwapchainCreateInfoKHR includes a
slink:VkSwapchainPresentBarrierCreateInfoNV structure, then that structure
includes additional swapchain creation parameters specific to the present
barrier.
Swapchain creation may: fail if the state of the current system restricts
the usage of the present barrier feature
slink:VkSurfaceCapabilitiesPresentBarrierNV, or a swapchain itself does not
satisfy all the required conditions.
In this scenario ename:VK_ERROR_INITIALIZATION_FAILED is returned.
endif::VK_NV_present_barrier[]

ifdef::VK_NV_acquire_winrt_display[]
When the slink:VkSurfaceKHR in slink:VkSwapchainCreateInfoKHR is a display
surface, then the slink:VkDisplayModeKHR in display surface's
slink:VkDisplaySurfaceCreateInfoKHR is associated with a particular
slink:VkDisplayKHR.
Swapchain creation may: fail if that slink:VkDisplayKHR is not acquired by
the application.
In this scenario ename:VK_ERROR_INITIALIZATION_FAILED is returned.
endif::VK_NV_acquire_winrt_display[]

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

ifdef::VKSC_VERSION_1_0[]
.Valid Usage
****
include::{chapters}/commonvalidity/memory_reservation_request_count_common.adoc[]
****
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/protos/vkCreateSwapchainKHR.adoc[]
--

[open,refpage='VkSwapchainCreateInfoKHR',desc='Structure specifying parameters of a newly created swapchain object',type='structs']
--
The sname:VkSwapchainCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkSwapchainCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkSwapchainCreateFlagBitsKHR
    indicating parameters of the swapchain creation.
  * pname:surface is the surface onto which the swapchain will present
    images.
    If the creation succeeds, the swapchain becomes associated with
    pname:surface.
  * pname:minImageCount is the minimum number of presentable images that the
    application needs.
    The implementation will either create the swapchain with at least that
    many images, or it will fail to create the swapchain.
  * pname:imageFormat is a elink:VkFormat value specifying the format the
    swapchain image(s) will be created with.
  * pname:imageColorSpace is a elink:VkColorSpaceKHR value specifying the
    way the swapchain interprets image data.
  * pname:imageExtent is the size (in pixels) of the swapchain image(s).
    The behavior is platform-dependent if the image extent does not match
    the surface's pname:currentExtent as returned by
    fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR.
+
[NOTE]
====
On some platforms, it is normal that pname:maxImageExtent may: become `(0,
0)`, for example when the window is minimized.
In such a case, it is not possible to create a swapchain due to the Valid
Usage requirements
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
, unless scaling is selected through
slink:VkSwapchainPresentScalingCreateInfoKHR, if supported
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
.
====
  * pname:imageArrayLayers is the number of views in a multiview/stereo
    surface.
    For non-stereoscopic-3D applications, this value is 1.
  * pname:imageUsage is a bitmask of elink:VkImageUsageFlagBits describing
    the intended usage of the (acquired) swapchain images.
  * pname:imageSharingMode is the sharing mode used for the image(s) of the
    swapchain.
  * pname:queueFamilyIndexCount is the number of queue families having
    access to the image(s) of the swapchain when pname:imageSharingMode is
    ename:VK_SHARING_MODE_CONCURRENT.
  * pname:pQueueFamilyIndices is a pointer to an array of queue family
    indices having access to the images(s) of the swapchain when
    pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT.
  * pname:preTransform is a elink:VkSurfaceTransformFlagBitsKHR value
    describing the transform, relative to the presentation engine's natural
    orientation, applied to the image content prior to presentation.
    If it does not match the pname:currentTransform value returned by
    fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR, the presentation engine
    will transform the image content as part of the presentation operation.
  * pname:compositeAlpha is a elink:VkCompositeAlphaFlagBitsKHR value
    indicating the alpha compositing mode to use when this surface is
    composited together with other surfaces on certain window systems.
  * pname:presentMode is the presentation mode the swapchain will use.
    A swapchain's present mode determines how incoming present requests will
    be processed and queued internally.
  * pname:clipped specifies whether the Vulkan implementation is allowed to
    discard rendering operations that affect regions of the surface that are
    not visible.
  ** If pname:clipped is ename:VK_TRUE, the presentable images associated
     with the swapchain may: not own all of their pixels.
     Pixels in the presentable images that correspond to regions of the
     target surface obscured by another window on the desktop, or subject to
     some other clipping mechanism will have undefined: content when read
     back.
     Fragment shaders may: not execute for these pixels, and thus any side
     effects they would have had will not occur.
     Setting ename:VK_TRUE does not guarantee any clipping will occur, but
     allows more efficient presentation methods to be used on some
     platforms.
  ** If pname:clipped is ename:VK_FALSE, presentable images associated with
     the swapchain will own all of the pixels they contain.
+
[NOTE]
====
Applications should: set this value to ename:VK_TRUE if they do not expect
to read back the content of presentable images before presenting them or
after reacquiring them, and if their fragment shaders do not have any side
effects that require them to run for all pixels in the presentable image.
====
ifdef::VKSC_VERSION_1_0[]
  * pname:oldSwapchain must: be dlink:VK_NULL_HANDLE in Vulkan SC
    <<SCID-4>>.
endif::VKSC_VERSION_1_0[]
ifndef::VKSC_VERSION_1_0[]
  * pname:oldSwapchain is dlink:VK_NULL_HANDLE, or the existing non-retired
    swapchain currently associated with pname:surface.
    Providing a valid pname:oldSwapchain may: aid in the resource reuse, and
    also allows the application to still present any images that are already
    acquired from it.
endif::VKSC_VERSION_1_0[]

ifndef::VKSC_VERSION_1_0[]
Upon calling fname:vkCreateSwapchainKHR with an pname:oldSwapchain that is
not dlink:VK_NULL_HANDLE, pname:oldSwapchain is retired -- even if creation
of the new swapchain fails.
The new swapchain is created in the non-retired state whether or not
pname:oldSwapchain is dlink:VK_NULL_HANDLE.

Upon calling fname:vkCreateSwapchainKHR with an pname:oldSwapchain that is
not dlink:VK_NULL_HANDLE, any images from pname:oldSwapchain that are not
acquired by the application may: be freed by the implementation, which may:
occur even if creation of the new swapchain fails.
The application can: destroy pname:oldSwapchain to free all memory
associated with pname:oldSwapchain.

[NOTE]
====
Multiple retired swapchains can: be associated with the same
sname:VkSurfaceKHR through multiple uses of pname:oldSwapchain that
outnumber calls to flink:vkDestroySwapchainKHR.

After pname:oldSwapchain is retired, the application can: pass to
flink:vkQueuePresentKHR any images it had already acquired from
pname:oldSwapchain.
E.g., an application may present an image from the old swapchain before an
image from the new swapchain is ready to be presented.
As usual, flink:vkQueuePresentKHR may: fail if pname:oldSwapchain has
entered a state that causes ename:VK_ERROR_OUT_OF_DATE_KHR to be returned.

ifdef::VK_KHR_shared_presentable_image[]
The application can: continue to use a shared presentable image obtained
from pname:oldSwapchain until a presentable image is acquired from the new
swapchain, as long as it has not entered a state that causes it to return
ename:VK_ERROR_OUT_OF_DATE_KHR.
endif::VK_KHR_shared_presentable_image[]
====
endif::VKSC_VERSION_1_0[]

.Valid Usage
****
  * [[VUID-VkSwapchainCreateInfoKHR-surface-01270]]
    pname:surface must: be a surface that is supported by the device as
    determined using flink:vkGetPhysicalDeviceSurfaceSupportKHR
  * [[VUID-VkSwapchainCreateInfoKHR-minImageCount-01272]]
    pname:minImageCount must: be less than or equal to the value returned in
    the pname:maxImageCount member of the sname:VkSurfaceCapabilitiesKHR
    structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR
    for the surface if the returned pname:maxImageCount is not zero
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
  * [[VUID-VkSwapchainCreateInfoKHR-swapchainMaintenance1-10155]]
    If the <<features-swapchainMaintenance1,pname:swapchainMaintenance1>>
    feature is not enabled, then the pname:pNext chain must: not include a
    slink:VkSwapchainPresentModesCreateInfoKHR structure
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
  * [[VUID-VkSwapchainCreateInfoKHR-presentMode-02839]]
ifdef::VK_KHR_shared_presentable_image[]
    If pname:presentMode is not
    ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR nor
    ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, then
endif::VK_KHR_shared_presentable_image[]
    pname:minImageCount must: be greater than or equal to the value returned
    in the pname:minImageCount member of the sname:VkSurfaceCapabilitiesKHR
    structure returned by flink:vkGetPhysicalDeviceSurfaceCapabilitiesKHR
    for the surface
ifdef::VK_KHR_shared_presentable_image[]
  * [[VUID-VkSwapchainCreateInfoKHR-minImageCount-01383]]
    pname:minImageCount must: be `1` if pname:presentMode is either
    ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or
    ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR
endif::VK_KHR_shared_presentable_image[]
  * [[VUID-VkSwapchainCreateInfoKHR-imageFormat-01273]]
    pname:imageFormat and pname:imageColorSpace must: match the pname:format
    and pname:colorSpace members, respectively, of one of the
    sname:VkSurfaceFormatKHR structures returned by
    fname:vkGetPhysicalDeviceSurfaceFormatsKHR for the surface
  * [[VUID-VkSwapchainCreateInfoKHR-pNext-07781]]
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
    If a slink:VkSwapchainPresentScalingCreateInfoKHR structure was not
    included in the pname:pNext chain, or it is included and
    slink:VkSwapchainPresentScalingCreateInfoKHR::pname:scalingBehavior is
    zero then
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
    pname:imageExtent must: be between pname:minImageExtent and
    pname:maxImageExtent, inclusive, where pname:minImageExtent and
    pname:maxImageExtent are members of the sname:VkSurfaceCapabilitiesKHR
    structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR
    for the surface
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
  * [[VUID-VkSwapchainCreateInfoKHR-pNext-07782]]
    If a slink:VkSwapchainPresentScalingCreateInfoKHR structure was included
    in the pname:pNext chain and
    slink:VkSwapchainPresentScalingCreateInfoKHR::pname:scalingBehavior is
    not zero then pname:imageExtent must: be between
    pname:minScaledImageExtent and pname:maxScaledImageExtent, inclusive,
    where pname:minScaledImageExtent and pname:maxScaledImageExtent are
    members of the sname:VkSurfacePresentScalingCapabilitiesKHR structure
    returned by fname:vkGetPhysicalDeviceSurfaceCapabilities2KHR for the
    surface and pname:presentMode
  * [[VUID-VkSwapchainCreateInfoKHR-swapchainMaintenance1-10157]]
    If the <<features-swapchainMaintenance1,pname:swapchainMaintenance1>>
    feature is not enabled, then pname:flags must: not include
    ename:VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
  * [[VUID-VkSwapchainCreateInfoKHR-imageExtent-01689]]
    pname:imageExtent members pname:width and pname:height must: both be
    non-zero
  * [[VUID-VkSwapchainCreateInfoKHR-imageArrayLayers-01275]]
    pname:imageArrayLayers must: be greater than `0` and less than or equal
    to the pname:maxImageArrayLayers member of the
    sname:VkSurfaceCapabilitiesKHR structure returned by
    fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
  * [[VUID-VkSwapchainCreateInfoKHR-presentMode-01427]]
    If pname:presentMode is
ifdef::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
    ename:VK_PRESENT_MODE_FIFO_LATEST_READY_KHR,
endif::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
    ename:VK_PRESENT_MODE_IMMEDIATE_KHR, ename:VK_PRESENT_MODE_MAILBOX_KHR,
    ename:VK_PRESENT_MODE_FIFO_KHR or
    ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR, pname:imageUsage must: be a
    subset of the supported usage flags present in the
    pname:supportedUsageFlags member of the slink:VkSurfaceCapabilitiesKHR
    structure returned by flink:vkGetPhysicalDeviceSurfaceCapabilitiesKHR
    for pname:surface
ifdef::VK_KHR_shared_presentable_image[]
  * [[VUID-VkSwapchainCreateInfoKHR-imageUsage-01384]]
    If pname:presentMode is ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR
    or ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, pname:imageUsage
    must: be a subset of the supported usage flags present in the
    pname:sharedPresentSupportedUsageFlags member of the
    slink:VkSharedPresentSurfaceCapabilitiesKHR structure returned by
    flink:vkGetPhysicalDeviceSurfaceCapabilities2KHR for pname:surface
endif::VK_KHR_shared_presentable_image[]
  * [[VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01277]]
    If pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT,
    pname:pQueueFamilyIndices must: be a valid pointer to an array of
    pname:queueFamilyIndexCount code:uint32_t values
  * [[VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01278]]
    If pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT,
    pname:queueFamilyIndexCount must: be greater than `1`
  * [[VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01428]]
    If pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT, each
    element of pname:pQueueFamilyIndices must: be unique and must: be less
    than pname:pQueueFamilyPropertyCount returned by either
    flink:vkGetPhysicalDeviceQueueFamilyProperties
ifdef::VK_BASE_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
    or flink:vkGetPhysicalDeviceQueueFamilyProperties2
endif::VK_BASE_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
    for the pname:physicalDevice that was used to create pname:device
  * [[VUID-VkSwapchainCreateInfoKHR-preTransform-01279]]
    pname:preTransform must: be one of the bits present in the
    pname:supportedTransforms member of the sname:VkSurfaceCapabilitiesKHR
    structure returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR
    for the surface
  * [[VUID-VkSwapchainCreateInfoKHR-compositeAlpha-01280]]
    pname:compositeAlpha must: be one of the bits present in the
    pname:supportedCompositeAlpha member of the
    sname:VkSurfaceCapabilitiesKHR structure returned by
    fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
  * [[VUID-VkSwapchainCreateInfoKHR-presentMode-01281]]
    pname:presentMode must: be one of the elink:VkPresentModeKHR values
    returned by fname:vkGetPhysicalDeviceSurfacePresentModesKHR for the
    surface
ifdef::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
  * [[VUID-VkSwapchainCreateInfoKHR-presentModeFifoLatestReady-10161]]
    If the <<features-presentModeFifoLatestReady,
    pname:presentModeFifoLatestReady>> feature is not enabled,
    pname:presentMode must: not be
    ename:VK_PRESENT_MODE_FIFO_LATEST_READY_KHR
endif::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
ifdef::VK_BASE_VERSION_1_1,VK_KHR_device_group[]
  * [[VUID-VkSwapchainCreateInfoKHR-physicalDeviceCount-01429]]
ifndef::VKSC_VERSION_1_0[]
    If the logical device was created with
    slink:VkDeviceGroupDeviceCreateInfo::pname:physicalDeviceCount equal to
    1,
endif::VKSC_VERSION_1_0[]
    pname:flags must: not contain
    ename:VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR
endif::VK_BASE_VERSION_1_1,VK_KHR_device_group[]
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkSwapchainCreateInfoKHR-oldSwapchain-01933]]
    If pname:oldSwapchain is not dlink:VK_NULL_HANDLE, pname:oldSwapchain
    must: be a non-retired swapchain associated with native window referred
    to by pname:surface
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
  * [[VUID-VkSwapchainCreateInfoKHR-oldSwapchain-05073]]
    pname:oldSwapchain must: be dlink:VK_NULL_HANDLE
endif::VKSC_VERSION_1_0[]
  * [[VUID-VkSwapchainCreateInfoKHR-imageFormat-01778]]
    The <<swapchain-wsi-image-create-info, implied image creation
    parameters>> of the swapchain must: be supported as reported by
    flink:vkGetPhysicalDeviceImageFormatProperties
ifdef::VK_KHR_swapchain_mutable_format[]
  * [[VUID-VkSwapchainCreateInfoKHR-flags-03168]]
    If pname:flags contains ename:VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR
    then the pname:pNext chain must: include a
    slink:VkImageFormatListCreateInfo structure with a pname:viewFormatCount
    greater than zero and pname:pViewFormats must: have an element equal to
    pname:imageFormat
  * [[VUID-VkSwapchainCreateInfoKHR-pNext-04099]]
    If a slink:VkImageFormatListCreateInfo structure was included in the
    pname:pNext chain and
    slink:VkImageFormatListCreateInfo::pname:viewFormatCount is not zero
    then all of the formats in
    slink:VkImageFormatListCreateInfo::pname:pViewFormats must: be
    compatible with the pname:format as described in the
    <<formats-compatibility,compatibility table>>
  * [[VUID-VkSwapchainCreateInfoKHR-flags-04100]]
    If pname:flags does not contain
    ename:VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR and the pname:pNext
    chain include a slink:VkImageFormatListCreateInfo structure then
    slink:VkImageFormatListCreateInfo::pname:viewFormatCount must: be `0` or
    `1`
endif::VK_KHR_swapchain_mutable_format[]
ifdef::VK_KHR_surface_protected_capabilities[]
  * [[VUID-VkSwapchainCreateInfoKHR-flags-03187]]
    If pname:flags contains ename:VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR,
    then sname:VkSurfaceProtectedCapabilitiesKHR::pname:supportsProtected
    must: be ename:VK_TRUE in the slink:VkSurfaceProtectedCapabilitiesKHR
    structure returned by flink:vkGetPhysicalDeviceSurfaceCapabilities2KHR
    for pname:surface
endif::VK_KHR_surface_protected_capabilities[]
ifdef::VK_EXT_full_screen_exclusive+VK_KHR_win32_surface[]
  * [[VUID-VkSwapchainCreateInfoKHR-pNext-02679]]
    If the pname:pNext chain includes a
    slink:VkSurfaceFullScreenExclusiveInfoEXT structure with its
    pname:fullScreenExclusive member set to
    ename:VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, and
    pname:surface was created using flink:vkCreateWin32SurfaceKHR, a
    slink:VkSurfaceFullScreenExclusiveWin32InfoEXT structure must: be
    included in the pname:pNext chain
endif::VK_EXT_full_screen_exclusive+VK_KHR_win32_surface[]
ifdef::VK_EXT_image_compression_control[]
  * [[VUID-VkSwapchainCreateInfoKHR-pNext-06752]]
ifdef::VK_EXT_image_compression_control_swapchain[]
    If the <<features-imageCompressionControlSwapchain,
    pname:imageCompressionControlSwapchain>> feature is not enabled, the
endif::VK_EXT_image_compression_control_swapchain[]
ifndef::VK_EXT_image_compression_control_swapchain[The]
    pname:pNext chain must: not include an
    slink:VkImageCompressionControlEXT structure
endif::VK_EXT_image_compression_control[]
ifdef::VK_EXT_present_timing[]
  * [[VUID-VkSwapchainCreateInfoKHR-presentTiming-12232]]
    If none of the <<features-presentTiming, pname:presentTiming>>,
    <<features-presentAtAbsoluteTime, pname:presentAtAbsoluteTime>>, or
    <<features-presentAtRelativeTime, pname:presentAtRelativeTime>> features
    are enabled, pname:flags must: not contain
    ename:VK_SWAPCHAIN_CREATE_PRESENT_TIMING_BIT_EXT
endif::VK_EXT_present_timing[]
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkSwapchainCreateInfoKHR::pname:flags must: not contain
    ename:VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR
    <<SCID-8>>.
  * slink:VkSwapchainCreateInfoKHR::pname:oldSwapchain must: be
    dlink:VK_NULL_HANDLE <<SCID-4>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/structs/VkSwapchainCreateInfoKHR.adoc[]
--

[open,refpage='VkSwapchainCreateFlagBitsKHR',desc='Bitmask controlling swapchain creation',type='enums']
--
Bits which can: be set in slink:VkSwapchainCreateInfoKHR::pname:flags,
specifying parameters of swapchain creation, are:

include::{generated}/api/enums/VkSwapchainCreateFlagBitsKHR.adoc[]

ifdef::VK_BASE_VERSION_1_1,VK_KHR_device_group[]
  * ename:VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR specifies
    that images created from the swapchain (i.e. with the pname:swapchain
    member of slink:VkImageSwapchainCreateInfoKHR set to this swapchain's
    handle) must: use ename:VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT.
ifdef::VKSC_VERSION_1_0[]
    This flag is not supported in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]
endif::VK_BASE_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_BASE_VERSION_1_1[]
  * ename:VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR specifies that images
    created from the swapchain are protected images.
endif::VK_BASE_VERSION_1_1[]
ifdef::VK_KHR_swapchain_mutable_format[]
  * ename:VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR specifies that the
    images of the swapchain can: be used to create a sname:VkImageView with
    a different format than what the swapchain was created with.
    The list of allowed image view formats is specified by adding a
    slink:VkImageFormatListCreateInfo structure to the pname:pNext chain of
    slink:VkSwapchainCreateInfoKHR.
    In addition, this flag also specifies that the swapchain can: be created
    with usage flags that are not supported for the format the swapchain is
    created with but are supported for at least one of the allowed image
    view formats.
endif::VK_KHR_swapchain_mutable_format[]
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
  * ename:VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR specifies
    that the implementation may: defer allocation of memory associated with
    each swapchain image until its index is to be returned from
    flink:vkAcquireNextImageKHR
ifdef::VK_BASE_VERSION_1_1,VK_KHR_device_group[or flink:vkAcquireNextImage2KHR]
    for the first time.
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
ifdef::VK_KHR_present_id2[]
  * ename:VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR specifies that
    applications can: include the sname:VkPresentId2KHR structure in the
    pname:pNext chain of the slink:VkPresentInfoKHR structure to associate
    an identifier with each presentation request.
endif::VK_KHR_present_id2[]
ifdef::VK_KHR_present_wait2[]
  * ename:VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR specifies that
    applications can: use fname:vkWaitForPresent2KHR to wait for the
    presentation engine to have begun presentation of the presentation
    request associated with slink:VkPresentWait2InfoKHR::pname:presentId on
    pname:swapchain.
endif::VK_KHR_present_wait2[]
ifdef::VK_EXT_present_timing[]
  * ename:VK_SWAPCHAIN_CREATE_PRESENT_TIMING_BIT_EXT specifies that features
    supported by the swapchain device in
    slink:VkPhysicalDevicePresentTimingFeaturesEXT can: be used to collect
    timing information or schedule presentation requests at specific times.
endif::VK_EXT_present_timing[]
--

[open,refpage='VkSwapchainCreateFlagsKHR',desc='Bitmask of VkSwapchainCreateFlagBitsKHR',type='flags']
--
include::{generated}/api/flags/VkSwapchainCreateFlagsKHR.adoc[]

tname:VkSwapchainCreateFlagsKHR is a bitmask type for setting a mask of zero
or more elink:VkSwapchainCreateFlagBitsKHR.
--

ifdef::VK_BASE_VERSION_1_1,VK_KHR_device_group[]
[open,refpage='VkDeviceGroupSwapchainCreateInfoKHR',desc='Structure specifying parameters of a newly created swapchain object',type='structs']
--
If the pname:pNext chain of slink:VkSwapchainCreateInfoKHR includes a
sname:VkDeviceGroupSwapchainCreateInfoKHR structure, then that structure
includes a set of device group present modes that the swapchain can: be used
with.

The sname:VkDeviceGroupSwapchainCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkDeviceGroupSwapchainCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:modes is a bitfield of modes that the swapchain can: be used with.

If this structure is not present, pname:modes is considered to be
ename:VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR.

include::{generated}/validity/structs/VkDeviceGroupSwapchainCreateInfoKHR.adoc[]
--
endif::VK_BASE_VERSION_1_1,VK_KHR_device_group[]

ifdef::VK_AMD_display_native_hdr[]
[open,refpage='VkSwapchainDisplayNativeHdrCreateInfoAMD',desc='Structure specifying display native HDR parameters of a newly created swapchain object',type='structs']
--
If the pname:pNext chain of slink:VkSwapchainCreateInfoKHR includes a
sname:VkSwapchainDisplayNativeHdrCreateInfoAMD structure, then that
structure includes additional swapchain creation parameters specific to
display native HDR support.

The sname:VkSwapchainDisplayNativeHdrCreateInfoAMD structure is defined as:

include::{generated}/api/structs/VkSwapchainDisplayNativeHdrCreateInfoAMD.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:localDimmingEnable specifies whether local dimming is enabled for
    the swapchain.

If the pname:pNext chain of slink:VkSwapchainCreateInfoKHR does not include
this structure, the default value for pname:localDimmingEnable is
ename:VK_TRUE, meaning local dimming is initially enabled for the swapchain.

include::{generated}/validity/structs/VkSwapchainDisplayNativeHdrCreateInfoAMD.adoc[]

.Valid Usage
****
  * [[VUID-VkSwapchainDisplayNativeHdrCreateInfoAMD-localDimmingEnable-04449]]
    It is only valid to set pname:localDimmingEnable to ename:VK_TRUE if
    slink:VkDisplayNativeHdrSurfaceCapabilitiesAMD::pname:localDimmingSupport
    is supported
****
--

[open,refpage='vkSetLocalDimmingAMD',desc='Set Local Dimming',type='protos']
--
The local dimming HDR setting may also be changed over the life of a
swapchain by calling:

include::{generated}/api/protos/vkSetLocalDimmingAMD.adoc[]

  * pname:device is the device associated with pname:swapChain.
  * pname:swapChain handle to enable local dimming.
  * pname:localDimmingEnable specifies whether local dimming is enabled for
    the swapchain.

include::{generated}/validity/protos/vkSetLocalDimmingAMD.adoc[]

.Valid Usage
****
  * [[VUID-vkSetLocalDimmingAMD-localDimmingSupport-04618]]
    slink:VkDisplayNativeHdrSurfaceCapabilitiesAMD::pname:localDimmingSupport
    must: be supported
****
--
endif::VK_AMD_display_native_hdr[]

ifdef::VK_EXT_full_screen_exclusive[]
If the pname:pNext chain of slink:VkSwapchainCreateInfoKHR includes a
slink:VkSurfaceFullScreenExclusiveInfoEXT structure, then that structure
specifies the application's preferred full-screen presentation behavior.
If this structure is not present, pname:fullScreenExclusive is considered to
be ename:VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT.
endif::VK_EXT_full_screen_exclusive[]

ifdef::VK_EXT_display_control[]
[open,refpage='VkSwapchainCounterCreateInfoEXT',desc='Specify the surface counters desired',type='structs']
--
To enable surface counters when creating a swapchain, add a
sname:VkSwapchainCounterCreateInfoEXT structure to the pname:pNext chain of
slink:VkSwapchainCreateInfoKHR.
sname:VkSwapchainCounterCreateInfoEXT is defined as:

include::{generated}/api/structs/VkSwapchainCounterCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:surfaceCounters is a bitmask of elink:VkSurfaceCounterFlagBitsEXT
    specifying surface counters to enable for the swapchain.

.Valid Usage
****
  * [[VUID-VkSwapchainCounterCreateInfoEXT-surfaceCounters-01244]]
    The bits in pname:surfaceCounters must: be supported by
    slink:VkSwapchainCreateInfoKHR::pname:surface, as reported by
    flink:vkGetPhysicalDeviceSurfaceCapabilities2EXT
****

include::{generated}/validity/structs/VkSwapchainCounterCreateInfoEXT.adoc[]
--

[open,refpage='vkGetSwapchainCounterEXT',desc='Query the current value of a surface counter',type='protos']
--
:refpage: vkGetSwapchainCounterEXT

The requested counters become active when the first presentation command for
the associated swapchain is processed by the presentation engine.
To query the value of an active counter, use:

include::{generated}/api/protos/vkGetSwapchainCounterEXT.adoc[]

  * pname:device is the slink:VkDevice associated with pname:swapchain.
  * pname:swapchain is the swapchain from which to query the counter value.
  * pname:counter is a elink:VkSurfaceCounterFlagBitsEXT value specifying
    the counter to query.
  * pname:pCounterValue will return the current value of the counter.

If a counter is not available because the swapchain is out of date, the
implementation may: return ename:VK_ERROR_OUT_OF_DATE_KHR.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkGetSwapchainCounterEXT-swapchain-01245]]
    One or more present commands on pname:swapchain must: have been
    processed by the presentation engine
****

include::{generated}/validity/protos/vkGetSwapchainCounterEXT.adoc[]
--
endif::VK_EXT_display_control[]

ifdef::VK_EXT_image_compression_control[]
ifdef::VK_EXT_image_compression_control_swapchain[]
To specify compression properties for the swapchain images in this
swapchain, add a slink:VkImageCompressionControlEXT structure to the
pname:pNext chain of the slink:VkSwapchainCreateInfoKHR structure.
endif::VK_EXT_image_compression_control_swapchain[]
endif::VK_EXT_image_compression_control[]

ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
[open,refpage='VkSwapchainPresentModesCreateInfoKHR',desc='All presentation modes usable by the swapchain',type='structs']
--
Applications can: modify the presentation mode used by the swapchain on a
per-presentation basis.
However, all presentation modes the application intends to use with the
swapchain must: be specified at swapchain creation time.
To specify more than one presentation mode when creating a swapchain,
include the sname:VkSwapchainPresentModesCreateInfoKHR structure in the
pname:pNext chain of the slink:VkSwapchainCreateInfoKHR structure.

The sname:VkSwapchainPresentModesCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkSwapchainPresentModesCreateInfoKHR.adoc[]

ifdef::VK_EXT_swapchain_maintenance1[]
include::{generated}/api/structs/VkSwapchainPresentModesCreateInfoEXT.adoc[]
endif::VK_EXT_swapchain_maintenance1[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentModeCount is the number of presentation modes provided.
  * pname:pPresentModes is a list of presentation modes with
    pname:presentModeCount entries

.Valid Usage
****
  * [[VUID-VkSwapchainPresentModesCreateInfoKHR-None-07762]]
    Each entry in pPresentModes must: be one of the elink:VkPresentModeKHR
    values returned by fname:vkGetPhysicalDeviceSurfacePresentModesKHR for
    the surface
ifdef::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
  * [[VUID-VkSwapchainPresentModesCreateInfoKHR-presentModeFifoLatestReady-10160]]
    If the <<features-presentModeFifoLatestReady,
    pname:presentModeFifoLatestReady>> feature is not enabled, pPresentModes
    must: not contain ename:VK_PRESENT_MODE_FIFO_LATEST_READY_KHR
endif::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
  * [[VUID-VkSwapchainPresentModesCreateInfoKHR-pPresentModes-07763]]
    The entries in pPresentModes must: be a subset of the present modes
    returned in
    slink:VkSurfacePresentModeCompatibilityKHR::pname:pPresentModes, given
    slink:VkSwapchainCreateInfoKHR::pname:presentMode in
    slink:VkSurfacePresentModeKHR
  * [[VUID-VkSwapchainPresentModesCreateInfoKHR-presentMode-07764]]
    slink:VkSwapchainCreateInfoKHR::pname:presentMode must: be included in
    pname:pPresentModes
****

include::{generated}/validity/structs/VkSwapchainPresentModesCreateInfoKHR.adoc[]
--

[open,refpage='VkSwapchainPresentScalingCreateInfoKHR',desc='Scaling behavior when presenting to the surface',type='structs']
--
When an application presents a swapchain image with dimensions different
than those of the target surface, different behavior is possible on
different platforms per their respective specifications:

  * Presentation fails and ename:VK_ERROR_OUT_OF_DATE_KHR is returned
  * Scaling is done and ename:VK_SUCCESS or ename:VK_SUBOPTIMAL_KHR is
    returned
  * Unspecified scaling using an arbitrary combination of stretching,
    centering and/or clipping.

Applications can: define specific behavior when creating a swapchain by
including the sname:VkSwapchainPresentScalingCreateInfoKHR structure in the
pname:pNext chain of the slink:VkSwapchainCreateInfoKHR structure.

The sname:VkSwapchainPresentScalingCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkSwapchainPresentScalingCreateInfoKHR.adoc[]

ifdef::VK_EXT_swapchain_maintenance1[]
include::{generated}/api/structs/VkSwapchainPresentScalingCreateInfoEXT.adoc[]
endif::VK_EXT_swapchain_maintenance1[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:scalingBehavior is `0` or the scaling method to use when the
    dimensions of the surface and swapchain images differ.
  * pname:presentGravityX is `0` or the x-axis direction in which swapchain
    image pixels gravitate relative to the surface when
    pname:scalingBehavior does not result in a one-to-one pixel mapping
    between the scaled swapchain image and the surface.
  * pname:presentGravityY is `0` or the y-axis direction in which swapchain
    image pixels gravitate relative to the surface when
    pname:scalingBehavior does not result in a one-to-one pixel mapping
    between the scaled swapchain image and the surface.

If pname:scalingBehavior is `0`, the result of presenting a swapchain image
with dimensions that do not match the surface dimensions is implementation
and platform-dependent.
If pname:presentGravityX or pname:presentGravityY are `0`, the presentation
gravity must: match that defined by the native platform surface on platforms
which define surface gravity.

.Valid Usage
****
  * [[VUID-VkSwapchainPresentScalingCreateInfoKHR-presentGravityX-07765]]
    If pname:presentGravityX is `0`, pname:presentGravityY must: be `0`
  * [[VUID-VkSwapchainPresentScalingCreateInfoKHR-presentGravityX-07766]]
    If pname:presentGravityX is not `0`, pname:presentGravityY must: not be
    `0`
  * [[VUID-VkSwapchainPresentScalingCreateInfoKHR-scalingBehavior-07767]]
    pname:scalingBehavior must: not have more than one bit set
  * [[VUID-VkSwapchainPresentScalingCreateInfoKHR-presentGravityX-07768]]
    pname:presentGravityX must: not have more than one bit set
  * [[VUID-VkSwapchainPresentScalingCreateInfoKHR-presentGravityY-07769]]
    pname:presentGravityY must: not have more than one bit set
  * [[VUID-VkSwapchainPresentScalingCreateInfoKHR-scalingBehavior-07770]]
    pname:scalingBehavior must: be `0` or a valid scaling method for the
    surface as returned in
    slink:VkSurfacePresentScalingCapabilitiesKHR::pname:supportedPresentScaling,
    given slink:VkSwapchainCreateInfoKHR::pname:presentMode in
    slink:VkSurfacePresentModeKHR
  * [[VUID-VkSwapchainPresentScalingCreateInfoKHR-scalingBehavior-07771]]
    If the swapchain is created with
    slink:VkSwapchainPresentModesCreateInfoKHR, pname:scalingBehavior must:
    be `0` or a valid scaling method for the surface as returned in
    slink:VkSurfacePresentScalingCapabilitiesKHR::pname:supportedPresentScaling,
    given each present mode in
    slink:VkSwapchainPresentModesCreateInfoKHR::pname:pPresentModes in
    slink:VkSurfacePresentModeKHR
  * [[VUID-VkSwapchainPresentScalingCreateInfoKHR-presentGravityX-07772]]
    pname:presentGravityX must: be `0` or a valid x-axis present gravity for
    the surface as returned in
    slink:VkSurfacePresentScalingCapabilitiesKHR::pname:supportedPresentGravityX,
    given slink:VkSwapchainCreateInfoKHR::pname:presentMode in
    slink:VkSurfacePresentModeKHR
  * [[VUID-VkSwapchainPresentScalingCreateInfoKHR-presentGravityX-07773]]
    If the swapchain is created with
    slink:VkSwapchainPresentModesCreateInfoKHR, pname:presentGravityX must:
    be `0` or a valid x-axis present gravity for the surface as returned in
    slink:VkSurfacePresentScalingCapabilitiesKHR::pname:supportedPresentGravityX,
    given each present mode in
    slink:VkSwapchainPresentModesCreateInfoKHR::pname:pPresentModes in
    slink:VkSurfacePresentModeKHR
  * [[VUID-VkSwapchainPresentScalingCreateInfoKHR-presentGravityY-07774]]
    pname:presentGravityY must: be `0` or a valid y-axis present gravity for
    the surface as returned in
    slink:VkSurfacePresentScalingCapabilitiesKHR::pname:supportedPresentGravityY,
    given slink:VkSwapchainCreateInfoKHR::pname:presentMode in
    slink:VkSurfacePresentModeKHR
  * [[VUID-VkSwapchainPresentScalingCreateInfoKHR-presentGravityY-07775]]
    If the swapchain is created with
    slink:VkSwapchainPresentModesCreateInfoKHR, pname:presentGravityY must:
    be `0` or a valid y-axis present gravity for the surface as returned in
    slink:VkSurfacePresentScalingCapabilitiesKHR::pname:supportedPresentGravityY,
    given each present mode in
    slink:VkSwapchainPresentModesCreateInfoKHR::pname:pPresentModes in
    slink:VkSurfacePresentModeKHR
  * [[VUID-VkSwapchainPresentScalingCreateInfoKHR-swapchainMaintenance1-10154]]
    If the <<features-swapchainMaintenance1,pname:swapchainMaintenance1>>
    feature is not enabled, then pname:scalingBehavior,
    pname:presentGravityX, and pname:presentGravityY must: be `0`
****

include::{generated}/validity/structs/VkSwapchainPresentScalingCreateInfoKHR.adoc[]
--

endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]


ifndef::VKSC_VERSION_1_0[]
[open,refpage='vkDestroySwapchainKHR',desc='Destroy a swapchain object',type='protos']
--
To destroy a swapchain object call:

include::{generated}/api/protos/vkDestroySwapchainKHR.adoc[]

  * pname:device is the slink:VkDevice associated with pname:swapchain.
  * pname:swapchain is the swapchain to destroy.
  * pname:pAllocator is the allocator used for host memory allocated for the
    swapchain object when there is no more specific allocator available (see
    <<memory-allocation,Memory Allocation>>).

The application must: not destroy a swapchain until after completion of all
outstanding operations on images that were acquired from the swapchain.
pname:swapchain and all associated sname:VkImage handles are destroyed, and
must: not be acquired or used any more by the application.
The memory of each sname:VkImage will only be freed after that image is no
longer used by the presentation engine.
For example, if one image of the swapchain is being displayed in a window,
the memory for that image may: not be freed until the window is destroyed,
or another swapchain is created for the window.
Destroying the swapchain does not invalidate the parent sname:VkSurfaceKHR,
and a new swapchain can: be created with it.

ifdef::VK_KHR_display_swapchain[]
When a swapchain associated with a display surface is destroyed, if the
image most recently presented to the display surface is from the swapchain
being destroyed, then either any display resources modified by presenting
images from any swapchain associated with the display surface must: be
reverted by the implementation to their state prior to the first present
performed on one of these swapchains, or such resources must: be left in
their current state.
endif::VK_KHR_display_swapchain[]

ifdef::VK_EXT_full_screen_exclusive[]
If pname:swapchain has exclusive full-screen access, it is released before
the swapchain is destroyed.
endif::VK_EXT_full_screen_exclusive[]

.Valid Usage
****
  * [[VUID-vkDestroySwapchainKHR-swapchain-01282]]
    All uses of presentable images acquired from pname:swapchain must: have
    completed execution
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkDestroySwapchainKHR-swapchain-01283]]
    If sname:VkAllocationCallbacks were provided when pname:swapchain was
    created, a compatible set of callbacks must: be provided here
  * [[VUID-vkDestroySwapchainKHR-swapchain-01284]]
    If no sname:VkAllocationCallbacks were provided when pname:swapchain was
    created, pname:pAllocator must: be `NULL`
endif::VKSC_VERSION_1_0[]
****

include::{generated}/validity/protos/vkDestroySwapchainKHR.adoc[]
--
endif::VKSC_VERSION_1_0[]

ifdef::VK_KHR_display_swapchain[]
[[create_shared_swapchains]]

[open,refpage='vkCreateSharedSwapchainsKHR',desc='Create multiple swapchains that share presentable images',type='protos']
--
:refpage: vkCreateSharedSwapchainsKHR
:objectnameplural: swapchains
:objectnamecamelcase: swapchain
:objectnamestruct: VkDeviceObjectReservationCreateInfo
:objectcount: pname:swapchainCount

When the `apiext:VK_KHR_display_swapchain` extension is enabled, multiple
swapchains that share presentable images are created by calling:

include::{generated}/api/protos/vkCreateSharedSwapchainsKHR.adoc[]

  * pname:device is the device to create the swapchains for.
  * pname:swapchainCount is the number of swapchains to create.
  * pname:pCreateInfos is a pointer to an array of
    slink:VkSwapchainCreateInfoKHR structures specifying the parameters of
    the created swapchains.
  * pname:pAllocator is the allocator used for host memory allocated for the
    swapchain objects when there is no more specific allocator available
    (see <<memory-allocation,Memory Allocation>>).
  * pname:pSwapchains is a pointer to an array of slink:VkSwapchainKHR
    handles in which the created swapchain objects will be returned.

fname:vkCreateSharedSwapchainsKHR is similar to flink:vkCreateSwapchainKHR,
except that it takes an array of slink:VkSwapchainCreateInfoKHR structures,
and returns an array of swapchain objects.

The swapchain creation parameters that affect the properties and number of
presentable images must: match between all the swapchains.
If the displays used by any of the swapchains do not use the same
presentable image layout or are incompatible in a way that prevents sharing
images, swapchain creation will fail with the result code
ename:VK_ERROR_INCOMPATIBLE_DISPLAY_KHR.
If any error occurs, no swapchains will be created.
Images presented to multiple swapchains must: be re-acquired from all of
them before being modified.
After destroying one or more of the swapchains, the remaining swapchains and
the presentable images can: continue to be used.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

ifdef::VKSC_VERSION_1_0[]
.Valid Usage
****
include::{chapters}/commonvalidity/memory_reservation_request_count_common.adoc[]
****
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/protos/vkCreateSharedSwapchainsKHR.adoc[]
--
endif::VK_KHR_display_swapchain[]

[open,refpage='vkGetSwapchainImagesKHR',desc='Obtain the array of presentable images associated with a swapchain',type='protos']
--
:refpage: vkGetSwapchainImagesKHR

To obtain the array of presentable images associated with a swapchain, call:

include::{generated}/api/protos/vkGetSwapchainImagesKHR.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to query.
  * pname:pSwapchainImageCount is a pointer to an integer related to the
    number of presentable images available or queried, as described below.
  * pname:pSwapchainImages is either `NULL` or a pointer to an array of
    sname:VkImage handles.

If pname:pSwapchainImages is `NULL`, then the number of presentable images
for pname:swapchain is returned in pname:pSwapchainImageCount.
Otherwise, pname:pSwapchainImageCount must: point to a variable set by the
application to the number of elements in the pname:pSwapchainImages array,
and on return the variable is overwritten with the number of structures
actually written to pname:pSwapchainImages.
If the value of pname:pSwapchainImageCount is less than the number of
presentable images for pname:swapchain, at most pname:pSwapchainImageCount
structures will be written, and ename:VK_INCOMPLETE will be returned instead
of ename:VK_SUCCESS, to indicate that not all the available presentable
images were returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkGetSwapchainImagesKHR.adoc[]
--

[NOTE]
====
By knowing all presentable images used in the swapchain, the application can
create command buffers that reference these images prior to entering its
main rendering loop.
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
However, command buffers are not allowed to reference presentable images
created with ename:VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR
until their indices have been returned from flink:vkAcquireNextImageKHR at
least once.
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
====

Images returned by flink:vkGetSwapchainImagesKHR are fully backed by memory
before they are passed to the application, as if they are each bound
completely and contiguously to a single sname:VkDeviceMemory object
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
, unless the swapchain is created with the
ename:VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR flag
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
.
All presentable images are initially in the ename:VK_IMAGE_LAYOUT_UNDEFINED
layout, thus before using presentable images, the application must:
transition them to a valid layout for the intended use.

ifndef::VKSC_VERSION_1_0[]

Further, the lifetime of presentable images is controlled by the
implementation, so applications must: not destroy a presentable image.
See flink:vkDestroySwapchainKHR for further details on the lifetime of
presentable images.

endif::VKSC_VERSION_1_0[]

ifdef::VK_BASE_VERSION_1_1,VK_KHR_device_group[]

Images can: also be created by using flink:vkCreateImage with
slink:VkImageSwapchainCreateInfoKHR and bound to swapchain memory using
flink:vkBindImageMemory2 with slink:VkBindImageMemorySwapchainInfoKHR.
These images can: be used anywhere swapchain images are used, and are useful
in logical devices with multiple physical devices to create peer memory
bindings of swapchain memory.
These images and bindings have no effect on what memory is presented.
Unlike images retrieved from fname:vkGetSwapchainImagesKHR, these images
must: be destroyed with flink:vkDestroyImage.

endif::VK_BASE_VERSION_1_1,VK_KHR_device_group[]

[open,refpage='vkAcquireNextImageKHR',desc='Retrieve the index of the next available presentable image',type='protos']
--
:refpage: vkAcquireNextImageKHR

To acquire an available presentable image to use, and retrieve the index of
that image, call:

include::{generated}/api/protos/vkAcquireNextImageKHR.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the non-retired swapchain from which an image is
    being acquired.
  * pname:timeout specifies how long the function waits, in nanoseconds, if
    no image is available.
  * pname:semaphore is dlink:VK_NULL_HANDLE or a semaphore defining a
    <<synchronization-semaphores-signaling,semaphore signal operation>>.
  * pname:fence is dlink:VK_NULL_HANDLE or a fence to signal.
  * pname:pImageIndex is a pointer to a code:uint32_t in which the index of
    the next image to use (i.e. an index into the array of images returned
    by fname:vkGetSwapchainImagesKHR) is returned.

ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
If the pname:swapchain has been created with the
ename:VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR flag, the image
whose index is returned in pname:pImageIndex will be fully backed by memory
before this call returns to the application, as if it is bound completely
and contiguously to a single sname:VkDeviceMemory object.
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]

If pname:semaphore defines a
<<synchronization-semaphores-signaling,semaphore signal operation>>, its
first <<synchronization-dependencies-scopes, synchronization scope>>
includes acquisition of the image.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkAcquireNextImageKHR-swapchain-01285]]
    pname:swapchain must: not be in the retired state
  * [[VUID-vkAcquireNextImageKHR-semaphore-01286]]
    If pname:semaphore is not dlink:VK_NULL_HANDLE, it must: be unsignaled
  * [[VUID-vkAcquireNextImageKHR-semaphore-01779]]
    If pname:semaphore is not dlink:VK_NULL_HANDLE, it must: not have any
    uncompleted signal or wait operations pending
  * [[VUID-vkAcquireNextImageKHR-fence-01287]]
    If pname:fence is not dlink:VK_NULL_HANDLE, pname:fence must: be
    unsignaled
  * [[VUID-vkAcquireNextImageKHR-fence-10066]]
    If pname:fence is not dlink:VK_NULL_HANDLE, pname:fence must: not be
    associated with any other queue command that has not yet completed
    execution on that queue
  * [[VUID-vkAcquireNextImageKHR-semaphore-01780]]
    pname:semaphore and pname:fence must: not both be equal to
    dlink:VK_NULL_HANDLE
  * [[VUID-vkAcquireNextImageKHR-surface-07783]]
    If <<swapchain-acquire-forward-progress,forward progress>> cannot be
    guaranteed for the pname:surface used to create the pname:swapchain
    member of pname:pAcquireInfo, pname:timeout must: not be code:UINT64_MAX
ifdef::VK_BASE_VERSION_1_2,VK_KHR_timeline_semaphore[]
  * [[VUID-vkAcquireNextImageKHR-semaphore-03265]]
    pname:semaphore must: have a elink:VkSemaphoreType of
    ename:VK_SEMAPHORE_TYPE_BINARY
endif::VK_BASE_VERSION_1_2,VK_KHR_timeline_semaphore[]
****

include::{generated}/validity/protos/vkAcquireNextImageKHR.adoc[]
--

If an image is acquired successfully, fname:vkAcquireNextImageKHR must:
either return ename:VK_SUCCESS or ename:VK_SUBOPTIMAL_KHR.
The implementation may: return ename:VK_SUBOPTIMAL_KHR if the swapchain no
longer matches the surface properties exactly, but can: still be used for
presentation.

When successful, fname:vkAcquireNextImageKHR acquires a presentable image
from pname:swapchain that an application can: use, and sets
pname:pImageIndex to the index of that image within the swapchain.
The presentation engine may: not have finished reading from the image at the
time it is acquired, so the application must: use pname:semaphore and/or
pname:fence to ensure that the image layout and contents are not modified
until the presentation engine reads have completed.
Once fname:vkAcquireNextImageKHR successfully acquires an image, the
semaphore signal operation referenced by pname:semaphore, if not
dlink:VK_NULL_HANDLE, and the fence signal operation referenced by
pname:fence, if not dlink:VK_NULL_HANDLE, are submitted for execution.
If fname:vkAcquireNextImageKHR does not successfully acquire an image,
pname:semaphore and pname:fence are unaffected.
The order in which images are acquired is implementation-dependent, and may:
be different than the order the images were presented.

If pname:timeout is zero, then fname:vkAcquireNextImageKHR does not wait,
and will either successfully acquire an image, or fail and return
ename:VK_NOT_READY if no image is available.

If the specified timeout period expires before an image is acquired,
fname:vkAcquireNextImageKHR returns ename:VK_TIMEOUT.
If pname:timeout is code:UINT64_MAX, the timeout period is treated as
infinite, and fname:vkAcquireNextImageKHR will block until an image is
acquired or an error occurs.

[[swapchain-acquire-forward-progress]]
Let [eq]#S# be the number of images in pname:swapchain.
ifndef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
Let [eq]#M# be the value of
slink:VkSurfaceCapabilitiesKHR::pname:minImageCount.
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
If pname:swapchain is created with
slink:VkSwapchainPresentModesCreateInfoKHR, let [eq]#M# be the maximum of
the values in slink:VkSurfaceCapabilitiesKHR::pname:minImageCount when
queried with each present mode in
slink:VkSwapchainPresentModesCreateInfoKHR::pname:pPresentModes in
slink:VkSurfacePresentModeKHR.
Otherwise, let [eq]#M# be the value of
slink:VkSurfaceCapabilitiesKHR::pname:minImageCount without a
slink:VkSurfacePresentModeKHR as part of the query input.
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]

fname:vkAcquireNextImageKHR should: not be called if the number of images
that the application has currently acquired is greater than [eq]#S-M#.
If fname:vkAcquireNextImageKHR is called when the number of images that the
application has currently acquired is less than or equal to [eq]#S-M#,
fname:vkAcquireNextImageKHR must: return in finite time with an allowed
ename:VkResult code.

[NOTE]
====
Returning a result in finite time guarantees that the implementation cannot
deadlock an application, or suspend its execution indefinitely with correct
API usage.
Acquiring too many images at once may block indefinitely, which is covered
by valid usage when attempting to use code:UINT64_MAX.
For example, a scenario here is when a compositor holds on to images which
are currently being presented, and there are not any vacant images left to
be acquired.
====

If the swapchain images no longer match native surface properties, either
ename:VK_SUBOPTIMAL_KHR or ename:VK_ERROR_OUT_OF_DATE_KHR must: be returned.
If ename:VK_ERROR_OUT_OF_DATE_KHR is returned, no image is acquired and
attempts to present previously acquired images to the swapchain will also
fail with ename:VK_ERROR_OUT_OF_DATE_KHR.
Applications need to create a new swapchain for the surface to continue
presenting if ename:VK_ERROR_OUT_OF_DATE_KHR is returned.

[NOTE]
====
ename:VK_SUBOPTIMAL_KHR may: happen, for example, if the platform surface
has been resized but the platform is able to scale the presented images to
the new size to produce valid surface updates.
It is up to the application to decide whether it prefers to continue using
the current swapchain in this state, or to re-create the swapchain to better
match the platform surface properties.
====

If device loss occurs (see <<devsandqueues-lost-device,Lost Device>>) before
the timeout has expired, fname:vkAcquireNextImageKHR must: return in finite
time with either one of the allowed success codes, or
ename:VK_ERROR_DEVICE_LOST.

If pname:semaphore is not dlink:VK_NULL_HANDLE, the semaphore must: be
unsignaled, with no signal or wait operations pending.
It will become signaled when the application can: use the image.

[NOTE]
====
Use of pname:semaphore allows rendering operations to be recorded and
submitted before the presentation engine has completed its use of the image.
====

If pname:fence is not equal to dlink:VK_NULL_HANDLE, the fence must: be
unsignaled, with no signal operations pending.
It will become signaled when the application can: use the image.

[NOTE]
====
Applications should: not rely on fname:vkAcquireNextImageKHR blocking in
order to meter their rendering speed.
The implementation may: return from this function immediately regardless of
how many presentation requests are queued, and regardless of when queued
presentation requests will complete relative to the call.
Instead, applications can: use pname:fence to meter their frame generation
work to match the presentation rate.
====

An application must: wait until either the pname:semaphore or pname:fence is
signaled before accessing the image's data.

[NOTE]
====
When the presentable image will be accessed by some stage [eq]#S#, the
recommended idiom for ensuring correct synchronization is:

  * The slink:VkSubmitInfo used to submit the image layout transition for
    execution includes fname:vkAcquireNextImageKHR::pname:semaphore in its
    pname:pWaitSemaphores member, with the corresponding element of
    pname:pWaitDstStageMask including [eq]#S#.
  * The <<synchronization, synchronization command>> that performs any
    necessary image layout transition includes [eq]#S# in both the
    pname:srcStageMask and pname:dstStageMask.
====

After a successful return, the image indicated by pname:pImageIndex and its
data will be unmodified compared to when it was presented.

[NOTE]
====
Exclusive ownership of presentable images corresponding to a swapchain
created with ename:VK_SHARING_MODE_EXCLUSIVE as defined in
<<resources-sharing,Resource Sharing>> is not altered by a call to
fname:vkAcquireNextImageKHR.
That means upon the first acquisition from such a swapchain presentable
images are not owned by any queue family, while at subsequent acquisitions
the presentable images remain owned by the queue family the image was
previously presented on.
====

The possible return values for fname:vkAcquireNextImageKHR depend on the
pname:timeout provided:

  * ename:VK_SUCCESS is returned if an image became available.
  * ename:VK_ERROR_SURFACE_LOST_KHR is returned if the surface becomes no
    longer available.
  * ename:VK_NOT_READY is returned if pname:timeout is zero and no image was
    available.
  * ename:VK_TIMEOUT is returned if pname:timeout is greater than zero and
    less than code:UINT64_MAX, and no image became available within the time
    allowed.
  * ename:VK_SUBOPTIMAL_KHR may: be returned if an image became available,
    and the swapchain no longer matches the surface properties exactly, but
    can: still be used to present to the surface successfully.

[NOTE]
====
This may: happen, for example, if the platform surface has been resized but
the platform is able to scale the presented images to the new size to
produce valid surface updates.
It is up to the application to decide whether it prefers to continue using
the current swapchain indefinitely or temporarily in this state, or to
re-create the swapchain to better match the platform surface properties.
====

  * ename:VK_ERROR_OUT_OF_DATE_KHR is returned if the surface has changed in
    such a way that it is no longer compatible with the swapchain, and
    further presentation requests using the swapchain will fail.
    Applications must: query the new surface properties and recreate their
    swapchain if they wish to continue presenting to the surface.

If the native surface and presented image sizes no longer match,
presentation may: fail
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
unless the swapchain is created with a non-zero value in
slink:VkSwapchainPresentScalingCreateInfoKHR::pname:scalingBehavior
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
.
If presentation does succeed, the mapping from the presented image to the
native surface is
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
defined by the slink:VkSwapchainPresentScalingCreateInfoKHR structure if
provided.
Otherwise it is
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
implementation-defined.
It is the application's responsibility to detect surface size changes and
react appropriately.
If presentation fails because of a mismatch in the surface and presented
image sizes, a ename:VK_ERROR_OUT_OF_DATE_KHR error will be returned.

[NOTE]
====
For example, consider a 4x3 window/surface that gets resized to be 3x4
(taller than wider).
On some window systems, the portion of the window/surface that was
previously and still is visible (the 3x3 part) will contain the same
contents as before, while the remaining parts of the window will have
undefined: contents.
Other window systems may: squash/stretch the image to fill the new window
size without any undefined: contents, or apply some other mapping.
====

ifdef::VK_BASE_VERSION_1_1,VK_KHR_device_group[]
[open,refpage='vkAcquireNextImage2KHR',desc='Retrieve the index of the next available presentable image',type='protos']
--
:refpage: vkAcquireNextImage2KHR

To acquire an available presentable image to use, and retrieve the index of
that image, call:

include::{generated}/api/protos/vkAcquireNextImage2KHR.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:pAcquireInfo is a pointer to a slink:VkAcquireNextImageInfoKHR
    structure containing parameters of the acquire.
  * pname:pImageIndex is a pointer to a code:uint32_t value specifying the
    index of the next image to use.

ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
If the pname:swapchain has been created with the
ename:VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR flag, the image
whose index is returned in pname:pImageIndex will be fully backed by memory
before this call returns to the application.
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkAcquireNextImage2KHR-surface-07784]]
    If <<swapchain-acquire-forward-progress,forward progress>> cannot be
    guaranteed for the pname:surface used to create pname:swapchain, the
    pname:timeout member of pname:pAcquireInfo must: not be code:UINT64_MAX
****

include::{generated}/validity/protos/vkAcquireNextImage2KHR.adoc[]
--

[open,refpage='VkAcquireNextImageInfoKHR',desc='Structure specifying parameters of the acquire',type='structs']
--
The sname:VkAcquireNextImageInfoKHR structure is defined as:

include::{generated}/api/structs/VkAcquireNextImageInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:swapchain is a non-retired swapchain from which an image is
    acquired.
  * pname:timeout specifies how long the function waits, in nanoseconds, if
    no image is available.
  * pname:semaphore is dlink:VK_NULL_HANDLE or a semaphore that defines a
    <<synchronization-semaphores-signaling,semaphore signal operation>>.
  * pname:fence is dlink:VK_NULL_HANDLE or a fence to signal.
  * pname:deviceMask is a mask of physical devices for which the swapchain
    image will be ready to use when the semaphore or fence is signaled.

If flink:vkAcquireNextImageKHR is used, the device mask is considered to
include all physical devices in the logical device.

[NOTE]
====
flink:vkAcquireNextImage2KHR signals at most one semaphore, even if the
application requests waiting for multiple physical devices to be ready via
the pname:deviceMask.
However, only a single physical device can: wait on that semaphore, since
the semaphore becomes unsignaled when the wait succeeds.
For other physical devices to wait for the image to be ready, it is
necessary for the application to submit semaphore signal operation(s) to
that first physical device to signal additional semaphore(s) after the wait
succeeds, which the other physical device(s) can: wait upon.
====

.Valid Usage
****
  * [[VUID-VkAcquireNextImageInfoKHR-swapchain-01675]]
    pname:swapchain must: not be in the retired state
  * [[VUID-VkAcquireNextImageInfoKHR-semaphore-01288]]
    If pname:semaphore is not dlink:VK_NULL_HANDLE, it must: be unsignaled
  * [[VUID-VkAcquireNextImageInfoKHR-semaphore-01781]]
    If pname:semaphore is not dlink:VK_NULL_HANDLE, it must: not have any
    uncompleted signal or wait operations pending
  * [[VUID-VkAcquireNextImageInfoKHR-fence-01289]]
    If pname:fence is not dlink:VK_NULL_HANDLE, pname:fence must: be
    unsignaled
  * [[VUID-VkAcquireNextImageInfoKHR-fence-10067]]
    If pname:fence is not dlink:VK_NULL_HANDLE, pname:fence must: not be
    associated with any other queue command that has not yet completed
    execution on that queue
  * [[VUID-VkAcquireNextImageInfoKHR-semaphore-01782]]
    pname:semaphore and pname:fence must: not both be equal to
    dlink:VK_NULL_HANDLE
  * [[VUID-VkAcquireNextImageInfoKHR-deviceMask-01290]]
    pname:deviceMask must: be a valid device mask
  * [[VUID-VkAcquireNextImageInfoKHR-deviceMask-01291]]
    pname:deviceMask must: not be zero
ifdef::VK_BASE_VERSION_1_2,VK_KHR_timeline_semaphore[]
  * [[VUID-VkAcquireNextImageInfoKHR-semaphore-03266]]
    pname:semaphore must: have a elink:VkSemaphoreType of
    ename:VK_SEMAPHORE_TYPE_BINARY
endif::VK_BASE_VERSION_1_2,VK_KHR_timeline_semaphore[]
****

include::{generated}/validity/structs/VkAcquireNextImageInfoKHR.adoc[]
--
endif::VK_BASE_VERSION_1_1,VK_KHR_device_group[]

[open,refpage='vkQueuePresentKHR',desc='Queue an image for presentation',type='protos']
--
:refpage: vkQueuePresentKHR

After queueing all rendering commands and transitioning the image to the
correct layout, to queue an image for presentation, call:

include::{generated}/api/protos/vkQueuePresentKHR.adoc[]

  * pname:queue is a queue that is capable of presentation to the target
    surface's platform on the same device as the image's swapchain.
  * pname:pPresentInfo is a pointer to a slink:VkPresentInfoKHR structure
    specifying parameters of the presentation.

[NOTE]
====
There is no requirement for an application to present images in the same
order that they were acquired - applications can arbitrarily present any
image that is currently acquired.
====

[NOTE]
====
The origin of the native orientation of the surface coordinate system is not
specified in the Vulkan specification; it depends on the platform.
For most platforms the origin is by default upper-left, meaning the pixel of
the presented slink:VkImage at coordinates [eq]#(0,0)# would appear at the
upper left pixel of the platform surface (assuming
ename:VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, and the display standing the
right way up).
====

The result codes ename:VK_ERROR_OUT_OF_DATE_KHR and ename:VK_SUBOPTIMAL_KHR
have the same meaning when returned by fname:vkQueuePresentKHR as they do
when returned by fname:vkAcquireNextImageKHR.
ifdef::VK_EXT_full_screen_exclusive[]
If any pname:swapchain member of pname:pPresentInfo was created with
ename:VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT,
ename:VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT will be returned if that
swapchain does not have exclusive full-screen access, possibly for
implementation-specific reasons outside of the application's control.
endif::VK_EXT_full_screen_exclusive[]
If multiple swapchains are presented, the result code is determined by
applying the following rules in order:

  * If the device is lost, ename:VK_ERROR_DEVICE_LOST is returned.
  * If any of the target surfaces are no longer available the error
    ename:VK_ERROR_SURFACE_LOST_KHR is returned.
  * If any of the presents would have a result of
    ename:VK_ERROR_OUT_OF_DATE_KHR if issued separately then
    ename:VK_ERROR_OUT_OF_DATE_KHR is returned.
ifdef::VK_EXT_present_timing[]
  * If any of the presents would have a result of
    ename:VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT if issued separately then
    ename:VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT is returned.
endif::VK_EXT_present_timing[]
ifdef::VK_EXT_full_screen_exclusive[]
  * If any of the presents would have a result of
    ename:VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT if issued separately
    then ename:VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT is returned.
endif::VK_EXT_full_screen_exclusive[]
  * If any of the presents would have a result of ename:VK_SUBOPTIMAL_KHR if
    issued separately then ename:VK_SUBOPTIMAL_KHR is returned.
  * Otherwise ename:VK_SUCCESS is returned.

Any writes to memory backing the images referenced by the
pname:pImageIndices and pname:pSwapchains members of pname:pPresentInfo,
that are available before flink:vkQueuePresentKHR is executed, are
automatically made visible to the read access performed by the presentation
engine.
This automatic visibility operation for an image happens-after the semaphore
wait operation, and happens-before the presentation engine accesses the
image.

Presentation is a read-only operation that will not affect the content of
the presentable images.
Upon reacquiring the image and transitioning it away from the
ename:VK_IMAGE_LAYOUT_PRESENT_SRC_KHR layout, the contents will be the same
as they were prior to transitioning the image to the present source layout
and presenting it.
However, if a mechanism other than Vulkan is used to modify the platform
window associated with the swapchain, the content of all presentable images
in the swapchain becomes undefined:.

Calls to fname:vkQueuePresentKHR may: block, but must: return in finite
time.
The processing of the presentation happens in issue order with other queue
operations, but semaphores must: be used to ensure that prior rendering and
other commands in the specified queue complete before the presentation
begins.
The presentation command itself does not delay processing of subsequent
commands on the queue.
However, presentation requests sent to a particular queue are always
performed in order.
Exact presentation timing is controlled by the semantics of the presentation
engine and native platform in use.

ifdef::VK_KHR_display_swapchain[]
If an image is presented to a swapchain created from a display surface, the
mode of the associated display will be updated, if necessary, to match the
mode specified when creating the display surface.
The mode switch and presentation of the specified image will be performed as
one atomic operation.
endif::VK_KHR_display_swapchain[]

Queueing an image for presentation defines a set of _queue operations_,
including waiting on the semaphores and submitting a presentation request to
the presentation engine.
However, the scope of this set of queue operations does not include the
actual processing of the image by the presentation engine.

ifndef::VK_EXT_swapchain_maintenance1[]
// tag::common_present_fence[]

// Describes the behavior of the present fence signaled by vkQueuePresentKHR.
//
// If VK_EXT_swapchain_maintenance1 is enabled,
// then transcluded this into VkSwapchainPresentFenceInfoEXT and omit here.
// Otherwise, include here in vkQueuePresentKHR.

ifdef::VK_EXT_swapchain_maintenance1[]
The application can: provide a fence that the implementation
endif::VK_EXT_swapchain_maintenance1[]
ifndef::VK_EXT_swapchain_maintenance1[]
Regarding interaction with flink:vkQueueWaitIdle, fname:vkQueuePresentKHR
behaves as if it signals a fence payload that is managed by the
implementation and that has no associated slink:VkFence handle.
The fence
endif::VK_EXT_swapchain_maintenance1[]
will signal after all such queue operations have completed, and after the
presentation engine has taken a reference to the payloads of all objects
ifdef::VK_EXT_swapchain_maintenance1[]
provided in sname:VkPresentInfoKHR
endif::VK_EXT_swapchain_maintenance1[]
that the presentation engine accesses as part of the present operation.
The fence may: not wait for the present operation to complete.
ifdef::VK_EXT_swapchain_maintenance1[]
For all
ifdef::VK_KHR_timeline_semaphore[binary]
wait semaphores imported by the presentation engine using the equivalent of
reference transference, as described in
<<synchronization-semaphores-importing,Importing Semaphore Payloads>>, this
fence must: not signal until all such semaphore payloads have been reset by
the presentation engine.
endif::VK_EXT_swapchain_maintenance1[]

// end::common_present_fence[]
endif::VK_EXT_swapchain_maintenance1[]

If fname:vkQueuePresentKHR fails to enqueue the corresponding set of queue
operations, it may: return ename:VK_ERROR_OUT_OF_HOST_MEMORY or
ename:VK_ERROR_OUT_OF_DEVICE_MEMORY.
If it does, the implementation must: ensure that the state and contents of
any resources or synchronization primitives referenced is unaffected by the
call or its failure.

If fname:vkQueuePresentKHR fails in such a way that the implementation is
unable to make that guarantee, the implementation must: return
ename:VK_ERROR_DEVICE_LOST.

However, if the presentation request is rejected by the presentation engine
with an error ename:VK_ERROR_OUT_OF_DATE_KHR,
ifdef::VK_EXT_full_screen_exclusive[]
ename:VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,
endif::VK_EXT_full_screen_exclusive[]
or ename:VK_ERROR_SURFACE_LOST_KHR, the set of queue operations are still
considered to be enqueued and thus any <<synchronization-semaphores-waiting,
semaphore wait operation>> specified in slink:VkPresentInfoKHR will execute
when the corresponding queue operation is complete.

fname:vkQueuePresentKHR releases the acquisition of the images referenced by
pname:imageIndices.
The queue family corresponding to the queue fname:vkQueuePresentKHR is
executed on must: have ownership of the presented images as defined in
<<resources-sharing,Resource Sharing>>.
fname:vkQueuePresentKHR does not alter the queue family ownership, but the
presented images must: not be used again before they have been reacquired
using fname:vkAcquireNextImageKHR.

[NOTE]
====
The application can: continue to present any acquired images from a retired
swapchain as long as the swapchain has not entered a state that causes
flink:vkQueuePresentKHR to return ename:VK_ERROR_OUT_OF_DATE_KHR.
====

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkQueuePresentKHR-pSwapchains-01292]]
    Each element of pname:pSwapchains member of pname:pPresentInfo must: be
    a swapchain that is created for a surface for which presentation is
    supported from pname:queue as determined using a call to
    fname:vkGetPhysicalDeviceSurfaceSupportKHR
ifdef::VK_KHR_display_swapchain[]
  * [[VUID-vkQueuePresentKHR-pSwapchains-01293]]
    If more than one member of pname:pSwapchains was created from a display
    surface, all display surfaces referenced that refer to the same display
    must: use the same display mode
endif::VK_KHR_display_swapchain[]
ifdef::VK_NV_display_stereo[]
  * [[VUID-vkQueuePresentKHR-pSwapchains-10285]]
    If more than one member of pname:pSwapchains was created from a display
    surface, all display surfaces referenced that refer to the same display
    must: use the same <<wsi-displaySurfaceStereoType, pname:stereoType>>
endif::VK_NV_display_stereo[]
  * [[VUID-vkQueuePresentKHR-pWaitSemaphores-01294]]
    When a semaphore wait operation referring to a binary semaphore defined
    by the elements of the pname:pWaitSemaphores member of
    pname:pPresentInfo executes on pname:queue, there must: be no other
    queues waiting on the same semaphore
ifdef::VK_BASE_VERSION_1_2,VK_KHR_timeline_semaphore[]
  * [[VUID-vkQueuePresentKHR-pWaitSemaphores-03267]]
    All elements of the pname:pWaitSemaphores member of pname:pPresentInfo
    must: be created with a elink:VkSemaphoreType of
    ename:VK_SEMAPHORE_TYPE_BINARY
endif::VK_BASE_VERSION_1_2,VK_KHR_timeline_semaphore[]
  * [[VUID-vkQueuePresentKHR-pWaitSemaphores-03268]]
    All elements of the pname:pWaitSemaphores member of pname:pPresentInfo
    must: reference a semaphore signal operation that has been submitted for
    execution and any <<synchronization-semaphores-signaling, semaphore
    signal operations>> on which it depends must: have also been submitted
    for execution
****

include::{generated}/validity/protos/vkQueuePresentKHR.adoc[]
--

[open,refpage='VkPresentInfoKHR',desc='Structure describing parameters of a queue presentation',type='structs']
--
The sname:VkPresentInfoKHR structure is defined as:

include::{generated}/api/structs/VkPresentInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:waitSemaphoreCount is the number of semaphores to wait for before
    issuing the present request.
    The number may: be zero.
  * pname:pWaitSemaphores is `NULL` or a pointer to an array of
    slink:VkSemaphore objects with pname:waitSemaphoreCount entries, and
    specifies the semaphores to wait for before issuing the present request.
  * pname:swapchainCount is the number of swapchains being presented to by
    this command.
  * pname:pSwapchains is a pointer to an array of slink:VkSwapchainKHR
    objects with pname:swapchainCount entries.
  * pname:pImageIndices is a pointer to an array of indices into the array
    of each swapchain's presentable images, with pname:swapchainCount
    entries.
    Each entry in this array identifies the image to present on the
    corresponding entry in the pname:pSwapchains array.
  * pname:pResults is a pointer to an array of elink:VkResult typed elements
    with pname:swapchainCount entries.
    Applications that do not need per-swapchain results can: use `NULL` for
    pname:pResults.
    If non-`NULL`, each entry in pname:pResults will be set to the
    elink:VkResult for presenting the swapchain corresponding to the same
    index in pname:pSwapchains.

Before an application can: present an image, the image's layout must: be
transitioned to the ename:VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
ifndef::VK_KHR_shared_presentable_image[layout.]
ifdef::VK_KHR_shared_presentable_image[]
layout, or for a shared presentable image the
ename:VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR layout.
endif::VK_KHR_shared_presentable_image[]

[NOTE]
====
When transitioning the image to the appropriate layout, there is no need to
delay subsequent processing, or perform any visibility operations (as
flink:vkQueuePresentKHR performs automatic visibility operations).
To achieve this, the pname:dstAccessMask member of the
slink:VkImageMemoryBarrier should: be `0`, and the pname:dstStageMask
parameter should: be ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT.
====

The second <<synchronization-dependencies-scopes, synchronization scope>> of
each <<synchronization-semaphores-waiting,semaphore wait operation>> defined
by this structure includes presentation of each image indicated by
pname:pSwapchains and pname:pImageIndices.

.Valid Usage
****
  * [[VUID-VkPresentInfoKHR-pSwapchain-09231]]
    Elements of pname:pSwapchain must: be unique
  * [[VUID-VkPresentInfoKHR-pImageIndices-01430]]
    Each element of pname:pImageIndices must: be the index of a presentable
    image acquired from the swapchain specified by the corresponding element
    of the pname:pSwapchains array, and the presented image subresource
    must: be in the ename:VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
ifdef::VK_KHR_shared_presentable_image[]
    or ename:VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR
endif::VK_KHR_shared_presentable_image[]
    layout at the time the operation is executed on a sname:VkDevice
ifdef::VK_KHR_present_id[]
  * [[VUID-VkPresentInfoKHR-pNext-06235]]
    If a slink:VkPresentIdKHR structure is included in the pname:pNext
    chain, and the <<features-presentId, pname:presentId>> feature is not
    enabled, each pname:presentIds entry in that structure must: be NULL
endif::VK_KHR_present_id[]
ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
  * [[VUID-VkPresentInfoKHR-swapchainMaintenance1-10158]]
    If the <<features-swapchainMaintenance1,pname:swapchainMaintenance1>>
    feature is not enabled, then the pname:pNext chain must: not include a
    slink:VkSwapchainPresentFenceInfoKHR structure
  * [[VUID-VkPresentInfoKHR-pSwapchains-09199]]
    If any element of the pname:pSwapchains array has been created with
    slink:VkSwapchainPresentModesCreateInfoKHR, all of the elements of this
    array must: be created with slink:VkSwapchainPresentModesCreateInfoKHR
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
ifdef::VK_EXT_frame_boundary+VK_ARM_tensors[]
  * [[VUID-VkPresentInfoKHR-pNext-09759]]
    If the pname:pNext chain of this structure includes a
    slink:VkFrameBoundaryTensorsARM structure then it must: also include a
    slink:VkFrameBoundaryEXT structure
endif::VK_EXT_frame_boundary+VK_ARM_tensors[]
ifdef::VK_KHR_present_id2[]
  * [[VUID-VkPresentInfoKHR-pNext-10821]]
    If a slink:VkPresentId2KHR structure is included in the pname:pNext
    chain, and the <<features-presentId2, pname:presentId2>> feature is not
    enabled, each pname:presentIds entry in that structure must: be zero
  * [[VUID-VkPresentInfoKHR-presentId2Supported-10822]]
    If a slink:VkPresentId2KHR structure is included and contains non-zero
    presentIds, pname:presentId2Supported must: be ename:VK_TRUE in the
    slink:VkSurfaceCapabilitiesPresentId2KHR structure returned by
    flink:vkGetPhysicalDeviceSurfaceCapabilities2KHR for the pname:surface
endif::VK_KHR_present_id2[]
****

include::{generated}/validity/structs/VkPresentInfoKHR.adoc[]
--

ifdef::VK_KHR_incremental_present[]
[open,refpage='VkPresentRegionsKHR',desc='Structure hint of rectangular regions changed by vkQueuePresentKHR',type='structs']
--
When the `apiext:VK_KHR_incremental_present` extension is enabled,
additional fields can: be specified that allow an application to specify
that only certain rectangular regions of the presentable images of a
swapchain are changed.
This is an optimization hint that a presentation engine may: use to only
update the region of a surface that is actually changing.
The application still must: ensure that all pixels of a presented image
contain the desired values, in case the presentation engine ignores this
hint.
An application can: provide this hint by adding a sname:VkPresentRegionsKHR
structure to the pname:pNext chain of the sname:VkPresentInfoKHR structure.

The sname:VkPresentRegionsKHR structure is defined as:

include::{generated}/api/structs/VkPresentRegionsKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:swapchainCount is the number of swapchains being presented to by
    this command.
  * pname:pRegions is `NULL` or a pointer to an array of
    sname:VkPresentRegionKHR elements with pname:swapchainCount entries.
    If not `NULL`, each element of pname:pRegions contains the region that
    has changed since the last present to the swapchain in the corresponding
    entry in the sname:VkPresentInfoKHR::pname:pSwapchains array.

.Valid Usage
****
  * [[VUID-VkPresentRegionsKHR-swapchainCount-01260]]
    pname:swapchainCount must: be the same value as
    sname:VkPresentInfoKHR::pname:swapchainCount, where
    sname:VkPresentInfoKHR is included in the pname:pNext chain of this
    sname:VkPresentRegionsKHR structure
****

include::{generated}/validity/structs/VkPresentRegionsKHR.adoc[]
--

[open,refpage='VkPresentRegionKHR',desc='Structure containing rectangular region changed by vkQueuePresentKHR for a given VkImage',type='structs']
--
For a given image and swapchain, the region to present is specified by the
sname:VkPresentRegionKHR structure, which is defined as:

include::{generated}/api/structs/VkPresentRegionKHR.adoc[]

  * pname:rectangleCount is the number of rectangles in pname:pRectangles,
    or zero if the entire image has changed and should be presented.
  * pname:pRectangles is either `NULL` or a pointer to an array of
    sname:VkRectLayerKHR structures.
    The sname:VkRectLayerKHR structure is the framebuffer coordinates, plus
    layer, of a portion of a presentable image that has changed and must: be
    presented.
    If non-`NULL`, each entry in pname:pRectangles is a rectangle of the
    given image that has changed since the last image was presented to the
    given swapchain.
    The rectangles must: be specified relative to
    slink:VkSurfaceCapabilitiesKHR::pname:currentTransform, regardless of
    the swapchain's pname:preTransform.
    The presentation engine will apply the pname:preTransform transformation
    to the rectangles, along with any further transformation it applies to
    the image content.

include::{generated}/validity/structs/VkPresentRegionKHR.adoc[]
--

[open,refpage='VkRectLayerKHR',desc='Structure containing a rectangle, including layer, changed by vkQueuePresentKHR for a given VkImage',type='structs']
--
The sname:VkRectLayerKHR structure is defined as:

include::{generated}/api/structs/VkRectLayerKHR.adoc[]

  * pname:offset is the origin of the rectangle, in pixels.
  * pname:extent is the size of the rectangle, in pixels.
  * pname:layer is the layer of the image.
    For images with only one layer, the value of pname:layer must: be 0.

Some platforms allow the size of a surface to change, and then scale the
pixels of the image to fit the surface.
sname:VkRectLayerKHR specifies pixels of the swapchain's image(s), which
will be constant for the life of the swapchain.

.Valid Usage
****
  * [[VUID-VkRectLayerKHR-offset-04864]]
    The sum of pname:offset and pname:extent, after being transformed
    according to the pname:preTransform member of the
    slink:VkSwapchainCreateInfoKHR structure, must: be no greater than the
    pname:imageExtent member of the slink:VkSwapchainCreateInfoKHR structure
    passed to flink:vkCreateSwapchainKHR
  * [[VUID-VkRectLayerKHR-layer-01262]]
    pname:layer must: be less than the pname:imageArrayLayers member of the
    slink:VkSwapchainCreateInfoKHR structure passed to
    flink:vkCreateSwapchainKHR
****

include::{generated}/validity/structs/VkRectLayerKHR.adoc[]
--
endif::VK_KHR_incremental_present[]

ifdef::VK_KHR_display_swapchain[]
[[display_swapchain_present]]
When the `apiext:VK_KHR_display_swapchain` extension is enabled, additional
fields can: be specified when presenting an image to a swapchain by setting
slink:VkPresentInfoKHR::pname:pNext to point to a
slink:VkDisplayPresentInfoKHR structure.

[open,refpage='VkDisplayPresentInfoKHR',desc='Structure describing parameters of a queue presentation to a swapchain',type='structs']
--
The sname:VkDisplayPresentInfoKHR structure is defined as:

include::{generated}/api/structs/VkDisplayPresentInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:srcRect is a rectangular region of pixels to present.
    It must: be a subset of the image being presented.
    If sname:VkDisplayPresentInfoKHR is not specified, this region will be
    assumed to be the entire presentable image.
  * pname:dstRect is a rectangular region within the visible region of the
    swapchain's display mode.
    If sname:VkDisplayPresentInfoKHR is not specified, this region will be
    assumed to be the entire visible region of the swapchain's mode.
    If the specified rectangle is a subset of the display mode's visible
    region, content from display planes below the swapchain's plane will be
    visible outside the rectangle.
    If there are no planes below the swapchain's, the area outside the
    specified rectangle will be black.
    If portions of the specified rectangle are outside of the display's
    visible region, pixels mapping only to those portions of the rectangle
    will be discarded.
  * pname:persistent: If this is ename:VK_TRUE, the display engine will
    enable buffered mode on displays that support it.
    This allows the display engine to stop sending content to the display
    until a new image is presented.
    The display will instead maintain a copy of the last presented image.
    This allows less power to be used, but may: increase presentation
    latency.
    If sname:VkDisplayPresentInfoKHR is not specified, persistent mode will
    not be used.

If the extent of the pname:srcRect and pname:dstRect are not equal, the
presented pixels will be scaled accordingly.

.Valid Usage
****
  * [[VUID-VkDisplayPresentInfoKHR-srcRect-01257]]
    pname:srcRect must: specify a rectangular region that is a subset of the
    image being presented
  * [[VUID-VkDisplayPresentInfoKHR-dstRect-01258]]
    pname:dstRect must: specify a rectangular region that is a subset of the
    pname:visibleRegion parameter of the display mode the swapchain being
    presented uses
  * [[VUID-VkDisplayPresentInfoKHR-persistentContent-01259]]
    If the pname:persistentContent member of the
    sname:VkDisplayPropertiesKHR structure returned by
    fname:vkGetPhysicalDeviceDisplayPropertiesKHR for the display the
    present operation targets is ename:VK_FALSE, then pname:persistent must:
    be ename:VK_FALSE
****

include::{generated}/validity/structs/VkDisplayPresentInfoKHR.adoc[]
--
endif::VK_KHR_display_swapchain[]

ifdef::VK_BASE_VERSION_1_1,VK_KHR_device_group[]
[open,refpage='VkDeviceGroupPresentInfoKHR',desc='Mode and mask controlling which physical devices\' images are presented',type='structs']
--
If the pname:pNext chain of slink:VkPresentInfoKHR includes a
sname:VkDeviceGroupPresentInfoKHR structure, then that structure includes an
array of device masks and a device group present mode.

The sname:VkDeviceGroupPresentInfoKHR structure is defined as:

include::{generated}/api/structs/VkDeviceGroupPresentInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:swapchainCount is zero or the number of elements in
    pname:pDeviceMasks.
  * pname:pDeviceMasks is a pointer to an array of device masks, one for
    each element of slink:VkPresentInfoKHR::pname:pSwapchains.
  * pname:mode is a elink:VkDeviceGroupPresentModeFlagBitsKHR value
    specifying the device group present mode that will be used for this
    present.

If pname:mode is ename:VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR, then each
element of pname:pDeviceMasks selects which instance of the swapchain image
is presented.
Each element of pname:pDeviceMasks must: have exactly one bit set, and the
corresponding physical device must: have a presentation engine as reported
by slink:VkDeviceGroupPresentCapabilitiesKHR.

If pname:mode is ename:VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR, then
each element of pname:pDeviceMasks selects which instance of the swapchain
image is presented.
Each element of pname:pDeviceMasks must: have exactly one bit set, and some
physical device in the logical device must: include that bit in its
slink:VkDeviceGroupPresentCapabilitiesKHR::pname:presentMask.

If pname:mode is ename:VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR, then each
element of pname:pDeviceMasks selects which instances of the swapchain image
are component-wise summed and the sum of those images is presented.
If the sum in any component is outside the representable range, the value of
that component is undefined:.
Each element of pname:pDeviceMasks must: have a value for which all set bits
are set in one of the elements of
slink:VkDeviceGroupPresentCapabilitiesKHR::pname:presentMask.

If pname:mode is
ename:VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR, then each
element of pname:pDeviceMasks selects which instance(s) of the swapchain
images are presented.
For each bit set in each element of pname:pDeviceMasks, the corresponding
physical device must: have a presentation engine as reported by
slink:VkDeviceGroupPresentCapabilitiesKHR.

If sname:VkDeviceGroupPresentInfoKHR is not provided or pname:swapchainCount
is zero then the masks are considered to be `1`.
If sname:VkDeviceGroupPresentInfoKHR is not provided, pname:mode is
considered to be ename:VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR.

.Valid Usage
****
  * [[VUID-VkDeviceGroupPresentInfoKHR-swapchainCount-01297]]
    pname:swapchainCount must: equal `0` or
    slink:VkPresentInfoKHR::pname:swapchainCount
  * [[VUID-VkDeviceGroupPresentInfoKHR-mode-01298]]
    If pname:mode is ename:VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR, then
    each element of pname:pDeviceMasks must: have exactly one bit set, and
    the corresponding element of
    slink:VkDeviceGroupPresentCapabilitiesKHR::pname:presentMask must: be
    non-zero
  * [[VUID-VkDeviceGroupPresentInfoKHR-mode-01299]]
    If pname:mode is ename:VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR, then
    each element of pname:pDeviceMasks must: have exactly one bit set, and
    some physical device in the logical device must: include that bit in its
    slink:VkDeviceGroupPresentCapabilitiesKHR::pname:presentMask
  * [[VUID-VkDeviceGroupPresentInfoKHR-mode-01300]]
    If pname:mode is ename:VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR, then
    each element of pname:pDeviceMasks must: have a value for which all set
    bits are set in one of the elements of
    slink:VkDeviceGroupPresentCapabilitiesKHR::pname:presentMask
  * [[VUID-VkDeviceGroupPresentInfoKHR-mode-01301]]
    If pname:mode is
    ename:VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR, then for
    each bit set in each element of pname:pDeviceMasks, the corresponding
    element of slink:VkDeviceGroupPresentCapabilitiesKHR::pname:presentMask
    must: be non-zero
  * [[VUID-VkDeviceGroupPresentInfoKHR-pDeviceMasks-01302]]
    The value of each element of pname:pDeviceMasks must: be equal to the
    device mask passed in slink:VkAcquireNextImageInfoKHR::pname:deviceMask
    when the image index was last acquired
  * [[VUID-VkDeviceGroupPresentInfoKHR-mode-01303]]
    pname:mode must: have exactly one bit set, and that bit must: have been
    included in slink:VkDeviceGroupSwapchainCreateInfoKHR::pname:modes
****

include::{generated}/validity/structs/VkDeviceGroupPresentInfoKHR.adoc[]
--
endif::VK_BASE_VERSION_1_1,VK_KHR_device_group[]

ifdef::VK_EXT_present_timing[]
[open,refpage='VkPresentTimingsInfoEXT',desc='Array of VkPresentTimingInfoEXT to chain with VkPresentInfoKHR',type='structs']
--
When the <<features-presentAtAbsoluteTime, pname:presentAtAbsoluteTime>> or
<<features-presentAtRelativeTime, pname:presentAtRelativeTime>> feature is
enabled, an application can: instruct the presentation engine to attempt to
display an image at a specified time, or for a minimum duration, by
including the sname:VkPresentTimingsInfoEXT structure in the pname:pNext
chain of the slink:VkPresentInfoKHR structure.

The sname:VkPresentTimingsInfoEXT structure is defined as:

include::{generated}/api/structs/VkPresentTimingsInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:swapchainCount is the number of swapchains being presented to by
    this command.
  * pname:pTimingInfos is `NULL` or a pointer to an array of
    sname:VkPresentTimingInfoEXT elements with pname:swapchainCount entries.
    If not `NULL`, each element of pname:pTimingInfos contains timing
    information for the presentation of the image corresponding to the entry
    in the sname:VkPresentInfoKHR::pname:pImageIndices array.

.Valid Usage
****
  * [[VUID-VkPresentTimingsInfoEXT-swapchainCount-12233]]
    pname:swapchainCount must: be equal to
    slink:VkPresentInfoKHR::pname:swapchainCount
  * [[VUID-VkPresentTimingsInfoEXT-pSwapchains-12234]]
    All swapchains in slink:VkPresentInfoKHR::pname:pSwapchains must: have
    been created with the slink:VkSwapchainCreateInfoKHR::pname:flags field
    containing ename:VK_SWAPCHAIN_CREATE_PRESENT_TIMING_BIT_EXT
  * [[VUID-VkPresentTimingsInfoEXT-pSwapchains-12235]]
    For each member of sname:VkPresentInfoKHR::pname:pSwapchains, if the
    associated slink:VkPresentTimingInfoEXT::pname:targetTime is not zero,
    the swapchain's current present mode must: be
ifdef::VK_KHR_present_mode_fifo_latest_ready[]
    ename:VK_PRESENT_MODE_FIFO_LATEST_READY_KHR,
endif::VK_KHR_present_mode_fifo_latest_ready[]
    ename:VK_PRESENT_MODE_FIFO_KHR or ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR
****

include::{generated}/validity/structs/VkPresentTimingsInfoEXT.adoc[]
--

[open,refpage='VkPresentTimingInfoEXT',desc='Specifies per-present timing information',type='structs']
--
The sname:VkPresentTimingInfoEXT structure is defined as:

include::{generated}/api/structs/VkPresentTimingInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkPresentTimingInfoFlagBitsEXT
    specifying options for how to interpret the timing information.
  * pname:targetTime is zero or a value specifying the target present time
    or duration, in nanoseconds, of the presentation request.
  * pname:timeDomainId is the id of the time domain used to specify the
    absolute target present time and the timing results obtained in a
    subsequent flink:vkGetPastPresentationTimingEXT call for the current
    presentation request.
  * pname:presentStageQueries is a valid tlink:VkPresentStageFlagsEXT value
    indicating which present stages the presentation engine will collect
    timing information for.
  * pname:targetTimeDomainPresentStage is a valid
    tlink:VkPresentStageFlagsEXT specifying a single present stage used to
    interpret pname:targetTime.

If pname:targetTime is not zero, the implementation attempts to align the
ename:VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_VISIBLE_BIT_EXT present stage of
that presentation request with the time specified in pname:targetTime
according to the time domain used.
If ename:VK_PRESENT_TIMING_INFO_PRESENT_AT_NEAREST_REFRESH_CYCLE_BIT_EXT is
not set in pname:flags, it indicates that the application would strictly
prefer the image to not be visible before pname:targetTime has lapsed.

If pname:targetTime is not zero and pname:timeDomainId is associated with a
ename:VK_TIME_DOMAIN_PRESENT_STAGE_LOCAL_EXT time domain,
pname:targetTimeDomainPresentStage is used to specify which present stage's
time domain pname:targetTime is specified for.
Otherwise, pname:targetTimeDomainPresentStage is ignored.

[NOTE]
====
Some platforms, due to hardware or system limitations, may: not be able to
accurately time pname:targetTime with the actual physical event of the image
becoming visible on the display.
However, those timing capabilities may: still be useful and result in
improved animation quality.

As such, the <<features-presentAtAbsoluteTime, pname:presentAtAbsoluteTime>>
and <<features-presentAtRelativeTime, pname:presentAtRelativeTime>> features
do not provide a strict guarantee regarding the completion of the
ename:VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_VISIBLE_BIT_EXT present stage
relative to the pname:targetTime, and implementations must: strive to make
it as consistent and accurate as possible.
====

[NOTE]
====
Applications that specify an absolute present time should: regularly rebase
their calculations for their next target time on the feedback from
flink:vkGetPastPresentationTimingEXT to compensate for accumulated precision
errors or potential clock drift.
It is recommended that when targeting the time of a vertical blanking
period, applications set
ename:VK_PRESENT_TIMING_INFO_PRESENT_AT_NEAREST_REFRESH_CYCLE_BIT_EXT to
allow the implementation to compensate for small precision errors that may
cause an image to be displayed one refresh cycle later than intended.
====

.Valid Usage
****
  * [[VUID-VkPresentTimingInfoEXT-targetTime-12236]]
    If pname:targetTime is not zero and pname:flags does not contain
    ename:VK_PRESENT_TIMING_INFO_PRESENT_AT_RELATIVE_TIME_BIT_EXT, the
    <<features-presentAtAbsoluteTime, pname:presentAtAbsoluteTime>> feature
    must: be enabled and the pname:presentAtAbsoluteTimeSupported member of
    the sname:VkPresentTimingSurfaceCapabilitiesEXT returned by
    fname:vkGetPhysicalDeviceSurfaceCapabilities2KHR for the surface
    associated with the swapchain must: be ename:VK_TRUE
  * [[VUID-VkPresentTimingInfoEXT-targetTime-12237]]
    If pname:targetTime is not zero and pname:flags contains
    ename:VK_PRESENT_TIMING_INFO_PRESENT_AT_RELATIVE_TIME_BIT_EXT, the
    <<features-presentAtRelativeTime, pname:presentAtRelativeTime>> feature
    must: be enabled and the pname:presentAtRelativeTimeSupported member of
    the sname:VkPresentTimingSurfaceCapabilitiesEXT returned by
    fname:vkGetPhysicalDeviceSurfaceCapabilities2KHR for the surface
    associated with the swapchain must: be ename:VK_TRUE
  * [[VUID-VkPresentTimingInfoEXT-timeDomainId-12238]]
    If pname:timeDomainId is associated with a
    ename:VK_TIME_DOMAIN_PRESENT_STAGE_LOCAL_EXT time domain, and
    pname:targetTime is not zero, pname:targetTimeDomainPresentStage must:
    be a single tname:VkPresentStageFlagsEXT value
****

include::{generated}/validity/structs/VkPresentTimingInfoEXT.adoc[]
--

[open,refpage='VkPresentTimingInfoFlagBitsEXT',desc='Bitmask specifying present timing info flags',type='enums']
--
Bits which can: be set in slink:VkPresentTimingInfoEXT::pname:flags,
specifying options for how to interpret timing information:

include::{generated}/api/enums/VkPresentTimingInfoFlagBitsEXT.adoc[]

  * ename:VK_PRESENT_TIMING_INFO_PRESENT_AT_RELATIVE_TIME_BIT_EXT specifies
    that sname:VkPresentTimingInfoEXT::pname:targetTime is to be interpreted
    as a relative time from the previous presentation's
    ename:VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_VISIBLE_BIT_EXT stage.
    If the pname:swapchain has never been used to present an image, the
    provided pname:targetTime is ignored.
  * ename:VK_PRESENT_TIMING_INFO_PRESENT_AT_NEAREST_REFRESH_CYCLE_BIT_EXT
    specifies that the application would prefer the image to be presented
    earlier than the time specified in
    sname:VkPresentTimingInfoEXT::pname:targetTime if that time falls within
    the first half of a refresh cycle.
    In that case, the presentation engine may: choose to display the image
    at the start of that refresh cycle.
--

[open,refpage='VkPresentTimingInfoFlagsEXT',desc='Bitmask of VkPresentTimingInfoFlagBitsEXT',type='flags']
--
include::{generated}/api/flags/VkPresentTimingInfoFlagsEXT.adoc[]

tname:VkPresentTimingInfoFlagsEXT is a bitmask type for setting a mask of
zero or more elink:VkPresentTimingInfoFlagBitsEXT.
--

[open,refpage='VkPresentStageFlagBitsEXT',desc='Bitmask specifying stages of the image presentation process',type='enums']
--

Presenting an image to the user typically involves multiple stages.
Bits which can: be set to specify present stages are:

include::{generated}/api/enums/VkPresentStageFlagBitsEXT.adoc[]

  * ename:VK_PRESENT_STAGE_QUEUE_OPERATIONS_END_BIT_EXT marks the end of the
    set of queue operations enqueued by flink:vkQueuePresentKHR on the
    provided sname:VkQueue for a presentation request.
  * ename:VK_PRESENT_STAGE_REQUEST_DEQUEUED_BIT_EXT is the stage after which
    the presentation request has been dequeued from the swapchain's internal
    presentation request queue, if any, as specified by the present mode
    associated with that request.
  * ename:VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_OUT_BIT_EXT is the stage after
    which data for the first pixel of the presentation request associated
    with the image has left the presentation engine for a display hardware.
  * ename:VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_VISIBLE_BIT_EXT is the stage
    after which a display hardware has made the first pixel visible for the
    presentation request associated with the image to be presented.

[NOTE]
====
The set of queue operations delimited by
ename:VK_PRESENT_STAGE_QUEUE_OPERATIONS_END_BIT_EXT includes the wait for
the semaphores specified in slink:VkPresentInfoKHR::pname:pWaitSemaphores,
if any, and any work implicitly enqueued by the implementation.
====
--

[open,refpage='VkPresentStageFlagsEXT',desc='Bitmask of VkPresentStageFlagBitsEXT',type='flags']
--
include::{generated}/api/flags/VkPresentStageFlagsEXT.adoc[]

tname:VkPresentStageFlagsEXT is a bitmask type for setting a mask of zero or
more elink:VkPresentStageFlagBitsEXT.
--
endif::VK_EXT_present_timing[]

ifdef::VK_GOOGLE_display_timing[]
[open,refpage='VkPresentTimesInfoGOOGLE',desc='The earliest time each image should be presented',type='structs']
--
When the `apiext:VK_GOOGLE_display_timing` extension is enabled, additional
fields can: be specified that allow an application to specify the earliest
time that an image should be displayed.
This allows an application to avoid stutter that is caused by an image being
displayed earlier than planned.
Such stuttering can occur with both fixed and variable-refresh-rate
displays, because stuttering occurs when the geometry is not correctly
positioned for when the image is displayed.
An application can: instruct the presentation engine that an image should
not be displayed earlier than a specified time by adding a
sname:VkPresentTimesInfoGOOGLE structure to the pname:pNext chain of the
sname:VkPresentInfoKHR structure.

The sname:VkPresentTimesInfoGOOGLE structure is defined as:

include::{generated}/api/structs/VkPresentTimesInfoGOOGLE.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:swapchainCount is the number of swapchains being presented to by
    this command.
  * pname:pTimes is `NULL` or a pointer to an array of
    sname:VkPresentTimeGOOGLE elements with pname:swapchainCount entries.
    If not `NULL`, each element of pname:pTimes contains the earliest time
    to present the image corresponding to the entry in the
    sname:VkPresentInfoKHR::pname:pImageIndices array.

.Valid Usage
****
  * [[VUID-VkPresentTimesInfoGOOGLE-swapchainCount-01247]]
    pname:swapchainCount must: be the same value as
    sname:VkPresentInfoKHR::pname:swapchainCount, where
    sname:VkPresentInfoKHR is included in the pname:pNext chain of this
    sname:VkPresentTimesInfoGOOGLE structure
****

include::{generated}/validity/structs/VkPresentTimesInfoGOOGLE.adoc[]
--

[open,refpage='VkPresentTimeGOOGLE',desc='The earliest time image should be presented',type='structs']
--
The sname:VkPresentTimeGOOGLE structure is defined as:

include::{generated}/api/structs/VkPresentTimeGOOGLE.adoc[]

  * pname:presentID is an application-provided identification value, that
    can: be used with the results of
    flink:vkGetPastPresentationTimingGOOGLE, in order to uniquely identify
    this present.
    In order to be useful to the application, it should: be unique within
    some period of time that is meaningful to the application.
  * pname:desiredPresentTime specifies that the image given should: not be
    displayed to the user any earlier than this time.
    pname:desiredPresentTime is a time in nanoseconds, relative to a
    monotonically-increasing clock (e.g. `CLOCK_MONOTONIC` (see
    clock_gettime(2)) on Android and Linux).
    A value of zero specifies that the presentation engine may: display the
    image at any time.
    This is useful when the application desires to provide pname:presentID,
    but does not need a specific pname:desiredPresentTime.
--
endif::VK_GOOGLE_display_timing[]

ifdef::VK_KHR_present_id[]
[open,refpage='VkPresentIdKHR',desc='The list of presentation identifiers',type='structs']
--
The sname:VkPresentIdKHR structure is defined as:

include::{generated}/api/structs/VkPresentIdKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:swapchainCount is the number of swapchains being presented to the
    fname:vkQueuePresentKHR command.
  * pname:pPresentIds is `NULL` or a pointer to an array of code:uint64_t
    with pname:swapchainCount entries.
    If not `NULL`, each non-zero value in pname:pPresentIds specifies the
    present id to be associated with the presentation of the swapchain with
    the same index in the flink:vkQueuePresentKHR call.

For applications to be able to reference specific presentation events queued
by a call to fname:vkQueuePresentKHR, an identifier needs to be associated
with them.
When the <<features-presentId, pname:presentId>> feature is enabled,
applications can: include the sname:VkPresentIdKHR structure in the
pname:pNext chain of the slink:VkPresentInfoKHR structure to supply
identifiers.

Each sname:VkSwapchainKHR has a presentId associated with it.
This value is initially zero when the sname:VkSwapchainKHR is created.

When a sname:VkPresentIdKHR structure with a non-NULL pname:pPresentIds is
included in the pname:pNext chain of a slink:VkPresentInfoKHR structure,
each pname:pSwapchains entry has a presentId associated in the
pname:pPresentIds array at the same index as the swapchain in the
pname:pSwapchains array.
If this presentId is non-zero, then the application can: later use this
value to refer to that image presentation.
A value of zero indicates that this presentation has no associated
presentId.
A non-zero presentId must: be greater than any non-zero presentId passed
previously by the application for the same swapchain.

There is no requirement for any precise timing relationship between the
presentation of the image to the user and the update of the presentId value,
but implementations should: make this as close as possible to the
presentation of the first pixel in the new image to the user.

.Valid Usage
****
  * [[VUID-VkPresentIdKHR-swapchainCount-04998]]
    pname:swapchainCount must: be the same value as
    sname:VkPresentInfoKHR::pname:swapchainCount, where this
    sname:VkPresentIdKHR is in the pname:pNext chain of the
    sname:VkPresentInfoKHR structure
  * [[VUID-VkPresentIdKHR-presentIds-04999]]
    Each pname:presentIds entry must: be greater than any previous
    pname:presentIds entry passed for the associated pname:pSwapchains entry
****

include::{generated}/validity/structs/VkPresentIdKHR.adoc[]
--

ifdef::VK_KHR_present_wait[]
[open,refpage='vkWaitForPresentKHR',desc='Wait for presentation',type='protos']
--
When the <<features-presentWait, pname:presentWait>> feature is enabled, an
application can: wait for an image to be presented to the user by first
specifying a presentId for the target presentation by adding a
sname:VkPresentIdKHR structure to the pname:pNext chain of the
slink:VkPresentInfoKHR structure and then waiting for that presentation to
complete by calling:

include::{generated}/api/protos/vkWaitForPresentKHR.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the non-retired swapchain on which an image was
    queued for presentation.
  * pname:presentId is the presentation presentId to wait for.
  * pname:timeout is the timeout period in units of nanoseconds.
    pname:timeout is adjusted to the closest value allowed by the
    implementation-dependent timeout accuracy, which may: be substantially
    longer than one nanosecond, and may: be longer than the requested
    period.

fname:vkWaitForPresentKHR waits for the presentId associated with
pname:swapchain to be increased in value so that it is at least equal to
pname:presentId.

For ename:VK_PRESENT_MODE_MAILBOX_KHR (or other present mode where images
may be replaced in the presentation queue) any wait of this type associated
with such an image must: be signaled no later than a wait associated with
the replacing image would be signaled.

When the presentation has completed, the presentId associated with the
related pname:pSwapchains entry will be increased in value so that it is at
least equal to the value provided in the sname:VkPresentIdKHR structure.

There is no requirement for any precise timing relationship between the
presentation of the image to the user and the update of the presentId value,
but implementations should: make this as close as possible to the
presentation of the first pixel in the next image being presented to the
user.

The call to fname:vkWaitForPresentKHR will block until either the presentId
associated with pname:swapchain is greater than or equal to pname:presentId,
or pname:timeout nanoseconds passes.
When the swapchain becomes OUT_OF_DATE, the call will either return
ename:VK_SUCCESS (if the image was delivered to the presentation engine and
may have been presented to the user) or will return early with status
ename:VK_ERROR_OUT_OF_DATE_KHR (if the image could not be presented to the
user).

As an exception to the normal rules for objects which are externally
synchronized, the pname:swapchain passed to fname:vkWaitForPresentKHR may:
be simultaneously used by other threads in calls to functions other than
flink:vkDestroySwapchainKHR.
Access to the swapchain data associated with this extension must: be atomic
within the implementation.

.Valid Usage
****
  * [[VUID-vkWaitForPresentKHR-swapchain-04997]]
    pname:swapchain must: not be in the retired state
  * [[VUID-vkWaitForPresentKHR-presentWait-06234]]
    The <<features-presentWait, pname:presentWait>> feature must: be enabled
****

include::{generated}/validity/protos/vkWaitForPresentKHR.adoc[]
--
endif::VK_KHR_present_wait[]
endif::VK_KHR_present_id[]

ifdef::VK_KHR_present_id2[]
[open,refpage='VkPresentId2KHR',desc='The list of presentation identifiers',type='structs']
--
The sname:VkPresentId2KHR structure is defined as:

include::{generated}/api/structs/VkPresentId2KHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:swapchainCount is the number of swapchains being presented to the
    fname:vkQueuePresentKHR command.
  * pname:pPresentIds is `NULL` or a pointer to an array of uint64_t with
    pname:swapchainCount entries.
    If not `NULL`, each non-zero value in pname:pPresentIds specifies the
    present id to be associated with the presentation of the swapchain with
    the same index in the flink:vkQueuePresentKHR call.

For applications to be able to reference specific presentation events queued
by a call to fname:vkQueuePresentKHR, an identifier needs to be associated
with them.

When the slink:VkSurfaceCapabilitiesPresentId2KHR surface capability is
present for a surface, applications can: include the sname:VkPresentId2KHR
structure in the pname:pNext chain of the slink:VkPresentInfoKHR structure
to associate an identifier with each presentation request.
The pname:pPresentIds provides an identifier for the swapchain present at
the corresponding index in slink:VkPresentInfoKHR's pname:pSwapchains array.

If this presentId is non-zero, then the application can: later use this
value to refer to that image presentation.
A value of zero indicates that this presentation has no associated
presentId.
A non-zero presentId must: be greater than any non-zero presentId passed
previously by the application for the same swapchain.

ifdef::VK_KHR_present_wait2[]
If a non-zero presentId was provided, this may be used with
flink:vkWaitForPresent2KHR for the application to synchronize against the
presentation engine's processing of the presentation request.
endif::VK_KHR_present_wait2[]

[NOTE]
====
The ID namespace used by this extension must: be shared with other
extensions that allow the application to provide a 64-bit monotonically
increasing presentation ID, such as the original VK_KHR_present_id.

This is to allow existing extensions that depend on VK_KHR_present_id to use
VK_KHR_present_id2 provided IDs without change, as well as to simplify
writing future extensions that require application provided presentation
IDs.
====

.Valid Usage
****
  * [[VUID-VkPresentId2KHR-swapchainCount-10818]]
    pname:swapchainCount must: be the same value as
    sname:VkPresentInfoKHR::pname:swapchainCount, where this
    sname:VkPresentId2KHR is in the pname:pNext chain of the
    sname:VkPresentInfoKHR structure
  * [[VUID-VkPresentId2KHR-presentIds-10819]]
    Each pname:presentIds entry must: be greater than any previous
    pname:presentIds entry passed for the associated pname:pSwapchains entry
  * [[VUID-VkPresentId2KHR-None-10820]]
    The swapchain must have been created with
    ename:VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR bit set in the
    ename:VkSwapchainCreateFlagBitsKHR field
****

include::{generated}/validity/structs/VkPresentId2KHR.adoc[]
--

ifdef::VK_KHR_present_wait2[]
[open,refpage='vkWaitForPresent2KHR',desc='Wait for presentation',type='protos']
--
When the sname:VkSurfaceCapabilitiesPresentWait2KHR surface capability is
present for a given surface, an application can: wait for an image to be
presented to the user by first specifying a pname:presentId for the target
presentation by adding a sname:VkPresentId2KHR structure to the pname:pNext
chain of the slink:VkPresentInfoKHR structure and then waiting for that
presentation to complete by calling:

include::{generated}/api/protos/vkWaitForPresent2KHR.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the non-retired swapchain on which an image was
    queued for presentation.
  * pname:pPresentWait2Info is a pointer to a slink:VkPresentWait2InfoKHR
    structure specifying the parameters of the wait.

fname:vkWaitForPresent2KHR waits for the presentation engine to have begun
presentation of the presentation request associated with the
slink:VkPresentWait2InfoKHR::pname:presentId on pname:swapchain, or for
slink:VkPresentWait2InfoKHR::pname:timeout to have expired.

The wait request will complete when the timeout expires, or after the
corresponding presentation request has either taken effect within the
presentation engine or has been replaced without presentation.

The timing relationship between the presentation of the image to the user
and the wait request completing is implementation-dependent due to
variations in window system implementations.

If the pname:swapchain becomes ename:VK_ERROR_OUT_OF_DATE_KHR either before
or during this call, the call may: either return ename:VK_SUCCESS (if the
image was delivered to the presentation engine and may: have been presented
to the user) or return early with status ename:VK_ERROR_OUT_OF_DATE_KHR (if
the image could not be presented to the user).

As an exception to the normal rules for objects which are externally
synchronized, the pname:swapchain passed to fname:vkWaitForPresent2KHR may:
be simultaneously used by other threads in calls to functions other than
flink:vkDestroySwapchainKHR.
Access to the swapchain data associated with this extension must: be atomic
within the implementation.

.Valid Usage
****
  * [[VUID-vkWaitForPresent2KHR-presentWait2-10814]]
    The <<features-presentWait2, pname:presentWait2>> feature must: be
    enabled
  * [[VUID-vkWaitForPresent2KHR-None-10815]]
    The slink:VkSurfaceCapabilitiesPresentWait2KHR surface capability must:
    be present for the underlying surface
  * [[VUID-vkWaitForPresent2KHR-None-10816]]
    The swapchain must have been created with
    ename:VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR bit set in the
    ename:VkSwapchainCreateFlagBitsKHR field
  * [[VUID-vkWaitForPresent2KHR-presentId-10817]]
    The pname:presentId value must: have been associated with a
    flink:vkQueuePresentKHR request on the pname:swapchain which returned a
    non-error value
****

include::{generated}/validity/protos/vkWaitForPresent2KHR.adoc[]
--
endif::VK_KHR_present_wait2[]
endif::VK_KHR_present_id2[]

ifdef::VK_GGP_frame_token[]
[open,refpage='VkPresentFrameTokenGGP',desc='The Google Games Platform frame token',type='structs']
--
When the `apiext:VK_GGP_frame_token` extension is enabled, a Google Games
Platform frame token can: be specified when presenting an image to a
swapchain by adding a sname:VkPresentFrameTokenGGP structure to the
pname:pNext chain of the sname:VkPresentInfoKHR structure.

The sname:VkPresentFrameTokenGGP structure is defined as:

include::{generated}/api/structs/VkPresentFrameTokenGGP.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:frameToken is the Google Games Platform frame token.

.Valid Usage
****
  * [[VUID-VkPresentFrameTokenGGP-frameToken-02680]]
    pname:frameToken must: be a valid code:GgpFrameToken
****

include::{generated}/validity/structs/VkPresentFrameTokenGGP.adoc[]
--
endif::VK_GGP_frame_token[]

ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
[open,refpage='VkSwapchainPresentModeInfoKHR',desc='Presentation modes for a vkQueuePresentKHR operation',type='structs']
--
The sname:VkSwapchainPresentModeInfoKHR structure is defined as:

include::{generated}/api/structs/VkSwapchainPresentModeInfoKHR.adoc[]

ifdef::VK_EXT_swapchain_maintenance1[]
include::{generated}/api/structs/VkSwapchainPresentModeInfoEXT.adoc[]
endif::VK_EXT_swapchain_maintenance1[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:swapchainCount is the number of swapchains being presented to by
    this command.
  * pname:pPresentModes is a list of presentation modes with
    pname:swapchainCount entries.

If the pname:pNext chain of slink:VkPresentInfoKHR includes a
sname:VkSwapchainPresentModeInfoKHR structure, then that structure defines
the presentation modes used for the current and subsequent presentation
operations.

When the application changes present modes with
slink:VkSwapchainPresentModeInfoKHR, images that have already been queued
for presentation will continue to be presented according to the previous
present mode.
The current image being queued for presentation and subsequent images will
be presented according to the new present mode.
The behavior during the transition between the two modes is defined as
follows.

ifdef::VK_KHR_shared_presentable_image[]
  * Transition from ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR to
    ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR: the presentation engine
    updates the shared presentable image according to the behavior of
    ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR.
  * Transition from ename:VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR to
    ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR: the presentation
    engine may: update the shared presentable image or defer that to its
    regular refresh cycle, according to the behavior of
    ename:VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR.
endif::VK_KHR_shared_presentable_image[]
  * Transition between ename:VK_PRESENT_MODE_FIFO_KHR and
    ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR: Images continue to be appended
    to the same FIFO queue, and the behavior with respect to waiting for
    vertical blanking period will follow the new mode for current and
    subsequent images.
  * Transition from ename:VK_PRESENT_MODE_IMMEDIATE_KHR to
    ename:VK_PRESENT_MODE_FIFO_KHR or ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR
ifdef::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
    or ename:VK_PRESENT_MODE_FIFO_LATEST_READY_KHR
endif::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
    : As all prior present requests in the
    ename:VK_PRESENT_MODE_IMMEDIATE_KHR mode are applied immediately, there
    are no outstanding present operations in this mode, and current and
    subsequent images are appended to the FIFO queue and presented according
    to the new mode.
  * Transition from ename:VK_PRESENT_MODE_MAILBOX_KHR to
    ename:VK_PRESENT_MODE_FIFO_KHR or ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR
ifdef::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
    or ename:VK_PRESENT_MODE_FIFO_LATEST_READY_KHR
endif::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
    : Presentation in FIFO modes require waiting for the next vertical
    blanking period, with ename:VK_PRESENT_MODE_MAILBOX_KHR allowing the
    pending present operation to be replaced by a new one.
    In this case, the current present operation will replace the pending
    present operation and is applied according to the new mode.
  * Transition from ename:VK_PRESENT_MODE_FIFO_KHR or
    ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR
ifdef::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
    or ename:VK_PRESENT_MODE_FIFO_LATEST_READY_KHR
endif::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
    to ename:VK_PRESENT_MODE_IMMEDIATE_KHR or
    ename:VK_PRESENT_MODE_MAILBOX_KHR: If the FIFO queue is empty,
    presentation is done according to the behavior of the new mode.
    If there are present operations in the FIFO queue, once the last present
    operation is performed based on the respective vertical blanking period,
    the current and subsequent updates are applied according to the new
    mode.
ifdef::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
  * Transition between ename:VK_PRESENT_MODE_FIFO_KHR or
    ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR, and
    ename:VK_PRESENT_MODE_FIFO_LATEST_READY_KHR: Images continue to be
    appended to the same FIFO queue, and the behavior with respect to
    waiting for vertical blanking period and dequeuing requests will follow
    the new mode for current and subsequent images.
endif::VK_KHR_present_mode_fifo_latest_ready,VK_EXT_present_mode_fifo_latest_ready[]
  * The behavior during transition between any other present modes, if
    possible, is implementation defined.

.Valid Usage
****
  * [[VUID-VkSwapchainPresentModeInfoKHR-swapchainCount-07760]]
    pname:swapchainCount must: be equal to
    slink:VkPresentInfoKHR::pname:swapchainCount
  * [[VUID-VkSwapchainPresentModeInfoKHR-pPresentModes-07761]]
    Each entry in pname:pPresentModes must: be a presentation mode specified
    in slink:VkSwapchainPresentModesCreateInfoKHR::pname:pPresentModes when
    creating the entry's corresponding swapchain
****

include::{generated}/validity/structs/VkSwapchainPresentModeInfoKHR.adoc[]
--

[open,refpage='VkSwapchainPresentFenceInfoKHR',desc='Fences associated with a vkQueuePresentKHR operation',type='structs']
--
The sname:VkSwapchainPresentFenceInfoKHR structure is defined as:

include::{generated}/api/structs/VkSwapchainPresentFenceInfoKHR.adoc[]

ifdef::VK_EXT_swapchain_maintenance1[]
include::{generated}/api/structs/VkSwapchainPresentFenceInfoEXT.adoc[]
endif::VK_EXT_swapchain_maintenance1[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:swapchainCount is the number of swapchains being presented to by
    this command.
  * pname:pFences is a list of fences with pname:swapchainCount entries.
    Each entry must: be dlink:VK_NULL_HANDLE or the handle of a fence to
    signal when the relevant operations on the associated swapchain have
    completed.

The set of _queue operations_ defined by queuing an image for presentation,
as well as operations performed by the presentation engine, access the
payloads of objects associated with the presentation operation.
The associated objects include:

  * The swapchain image, its implicitly bound memory, and any other
    resources bound to that memory.
  * The wait semaphores specified when queuing the image for presentation.

// Transclude content that only appears here if
// VK_EXT_swapchain_maintenance1 is enabled.
include::{chapters}/VK_KHR_surface/wsi.adoc[tag=common_present_fence]

The application can: destroy the wait semaphores associated with a given
presentation operation when at least one of the associated fences is
signaled, and can: destroy the swapchain when the fences associated with all
past presentation requests referring to that swapchain have signaled.

Fences associated with presentations to the same swapchain on the same
slink:VkQueue must: be signaled in the same order as the present operations.

To specify a fence for each swapchain in a present operation, include the
sname:VkSwapchainPresentFenceInfoKHR structure in the pname:pNext chain of
the slink:VkPresentInfoKHR structure.

.Valid Usage
****
  * [[VUID-VkSwapchainPresentFenceInfoKHR-swapchainCount-07757]]
    pname:swapchainCount must: be equal to
    slink:VkPresentInfoKHR::pname:swapchainCount
  * [[VUID-VkSwapchainPresentFenceInfoKHR-pFences-07758]]
    Each element of pname:pFences that is not dlink:VK_NULL_HANDLE must: be
    unsignaled
  * [[VUID-VkSwapchainPresentFenceInfoKHR-pFences-07759]]
    Each element of pname:pFences that is not dlink:VK_NULL_HANDLE must: not
    be associated with any other queue command that has not yet completed
    execution on that queue
****

include::{generated}/validity/structs/VkSwapchainPresentFenceInfoKHR.adoc[]
--
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]

ifdef::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]
[open,refpage='vkReleaseSwapchainImagesKHR',desc='Release previously acquired but unused images',type='protos']
--
To release images previously acquired through
ifdef::VK_BASE_VERSION_1_1,VK_KHR_device_group[flink:vkAcquireNextImage2KHR or]
flink:vkAcquireNextImageKHR, call:

ifdef::VK_KHR_swapchain_maintenance1[]
include::{generated}/api/protos/vkReleaseSwapchainImagesKHR.adoc[]
endif::VK_KHR_swapchain_maintenance1[]

ifdef::VK_EXT_swapchain_maintenance1[]
include::{generated}/api/protos/vkReleaseSwapchainImagesEXT.adoc[]
endif::VK_EXT_swapchain_maintenance1[]

  * pname:device is the device associated with
    slink:VkReleaseSwapchainImagesInfoKHR::pname:swapchain.
  * pname:pReleaseInfo is a pointer to a
    slink:VkReleaseSwapchainImagesInfoKHR structure containing parameters of
    the release.

Only images that are not in use by the device can: be released.

Releasing images is a read-only operation that will not affect the content
of the released images.
Upon reacquiring the image, the image contents and its layout will be the
same as they were prior to releasing it.
However, if a mechanism other than Vulkan is used to modify the platform
window associated with the swapchain, the content of all presentable images
in the swapchain becomes undefined:.

[NOTE]
====
This functionality is useful during swapchain recreation, where acquired
images from the old swapchain can be released instead of presented.
====

.Valid Usage
****
  * [[VUID-vkReleaseSwapchainImagesKHR-swapchainMaintenance1-10159]]
    Feature <<features-swapchainMaintenance1,pname:swapchainMaintenance1>>
    must: be enabled
****

include::{generated}/validity/protos/vkReleaseSwapchainImagesKHR.adoc[]
--

[open,refpage='VkReleaseSwapchainImagesInfoKHR',desc='Structure describing a list of swapchain image indices to be released',type='structs']
--
The sname:VkReleaseSwapchainImagesInfoKHR structure is defined as:

include::{generated}/api/structs/VkReleaseSwapchainImagesInfoKHR.adoc[]

ifdef::VK_EXT_swapchain_maintenance1[]
include::{generated}/api/structs/VkReleaseSwapchainImagesInfoEXT.adoc[]
endif::VK_EXT_swapchain_maintenance1[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:swapchain is a swapchain to which images are being released.
  * pname:imageIndexCount is the number of image indices to be released.
  * pname:pImageIndices is a pointer to an array of indices into the array
    of pname:swapchain's presentable images, with pname:imageIndexCount
    entries.

.Valid Usage
****
  * [[VUID-VkReleaseSwapchainImagesInfoKHR-pImageIndices-07785]]
    Each element of pname:pImageIndices must: be the index of a presentable
    image acquired from the swapchain specified by pname:swapchain
  * [[VUID-VkReleaseSwapchainImagesInfoKHR-pImageIndices-07786]]
    All uses of presentable images identified by elements of
    pname:pImageIndices must: have completed execution
****

include::{generated}/validity/structs/VkReleaseSwapchainImagesInfoKHR.adoc[]
--
endif::VK_KHR_swapchain_maintenance1,VK_EXT_swapchain_maintenance1[]


ifdef::VK_EXT_hdr_metadata[]
== HDR Metadata

This section describes how to improve color reproduction of content to
better reproduce colors as seen on the display used to originally optimize
the content.

[open,refpage='vkSetHdrMetadataEXT',desc='Set HDR metadata',type='protos']
--
To provide HDR metadata to an implementation, call:

include::{generated}/api/protos/vkSetHdrMetadataEXT.adoc[]

  * pname:device is the logical device where the swapchain(s) were created.
  * pname:swapchainCount is the number of swapchains included in
    pname:pSwapchains.
  * pname:pSwapchains is a pointer to an array of pname:swapchainCount
    slink:VkSwapchainKHR handles.
  * pname:pMetadata is a pointer to an array of pname:swapchainCount
    slink:VkHdrMetadataEXT structures.

The metadata will be applied to the specified slink:VkSwapchainKHR objects
at the next flink:vkQueuePresentKHR call using that slink:VkSwapchainKHR
object.
The metadata will persist until a subsequent fname:vkSetHdrMetadataEXT
changes it.

include::{generated}/validity/protos/vkSetHdrMetadataEXT.adoc[]
--

[open,refpage='VkHdrMetadataEXT',desc='Specify HDR metadata',type='structs']
--
The sname:VkHdrMetadataEXT structure is defined as:

include::{generated}/api/structs/VkHdrMetadataEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:displayPrimaryRed is a slink:VkXYColorEXT structure specifying the
    red primary of the display used to optimize the content
  * pname:displayPrimaryGreen is a slink:VkXYColorEXT structure specifying
    the green primary of the display used to optimize the content
  * pname:displayPrimaryBlue is a slink:VkXYColorEXT structure specifying
    the blue primary of the display used to optimize the content
  * pname:whitePoint is a slink:VkXYColorEXT structure specifying the
    white-point of the display used to optimize the content
  * pname:maxLuminance is the maximum luminance of the display used to
    optimize the content in nits
  * pname:minLuminance is the minimum luminance of the display used to
    optimize the content in nits
  * pname:maxContentLightLevel is the value in nits of the desired luminance
    for the brightest pixels in the displayed image.
  * pname:maxFrameAverageLightLevel is the value in nits of the average
    luminance of the frame which has the brightest average luminance
    anywhere in the content.

If any of the above values are unknown, they can: be set to 0.

[NOTE]
====
The meta-data provided here is intended to be used as defined in the SMPTE
2086, CTA 861.3 and CIE 15:2004 specifications.
The validity and use of this data is outside the scope of Vulkan.
====

include::{generated}/validity/structs/VkHdrMetadataEXT.adoc[]
--

ifdef::VK_HUAWEI_hdr_vivid[]

[open,refpage='VkHdrVividDynamicMetadataHUAWEI',desc='specify HDR Vivid dynamic metadata',type='structs']
--
When <<features-hdrVivid, pname:hdrVivid>> feature is enabled, HDR Vivid
dynamic metadata can: be set to control the reproduction of content by
including the sname:VkHdrVividDynamicMetadataHUAWEI in the pname:pNext chain
of slink:VkHdrMetadataEXT.

The sname:VkHdrVividDynamicMetadataHUAWEI structure is defined as:

include::{generated}/api/structs/VkHdrVividDynamicMetadataHUAWEI.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:dynamicMetadataSize is the size in bytes of the dynamic metadata.
  * pname:pDynamicMetadata is a pointer to the dynamic metadata.

[NOTE]
====
The HDR Vivid metadata is intended to be used as defined in the T/UWA
005.1-2022 specification.
The validity and use of this data is outside the scope of Vulkan.
====

include::{generated}/validity/structs/VkHdrVividDynamicMetadataHUAWEI.adoc[]
--

endif::VK_HUAWEI_hdr_vivid[]

[open,refpage='VkXYColorEXT',desc='Specify X,Y chromaticity coordinates',type='structs']
--
The sname:VkXYColorEXT structure is defined as:

include::{generated}/api/structs/VkXYColorEXT.adoc[]

  * pname:x is the [eq]#x# chromaticity coordinate.
  * pname:y is the [eq]#y# chromaticity coordinate.

Chromaticity coordinates are as specified in CIE 15:2004 "`Calculation of
chromaticity coordinates`" (Section 7.3) and are limited to between 0 and 1
for real colors.
--

endif::VK_EXT_hdr_metadata[]

endif::VK_KHR_swapchain[]


ifdef::VK_AMD_anti_lag,VK_NV_low_latency2[]
[[lag-control]]
== Lag Control

Some implementations support extensions to reduce display latency and
control the swapchain present interval, as described in the remainder of
this section.

ifdef::VK_AMD_anti_lag[]
[[anti-lag]]
=== Anti-Lag

The apiext:VK_AMD_anti_lag extension lowers latency between receiving input
and displaying on the screen.
It adds a command to indicate when input is being processed for a frame, and
when that frame's images are presented.

[open,refpage='vkAntiLagUpdateAMD',desc='Provide information to reduce latency',type='protos']
--
To lower latency, call:

ifdef::VK_AMD_anti_lag[]
include::{generated}/api/protos/vkAntiLagUpdateAMD.adoc[]
endif::VK_AMD_anti_lag[]

  * pname:device is the logical device
  * pname:pData is a pointer to a slink:VkAntiLagDataAMD structure
    containing latency reduction parameters.

This command should be executed immediately before the application processes
user input.
If pname:pData is not `NULL` and
slink:VkAntiLagDataAMD::pname:pPresentationInfo is not `NULL`, this command
should: be executed again before flink:vkQueuePresentKHR, with
pname:pPresentationInfo set to matching values.

.Valid Usage
****
  * [[VUID-vkAntiLagUpdateAMD-antiLag-10061]]
    The <<features-antiLag, pname:antiLag>> feature must: be enabled
****

include::{generated}/validity/protos/vkAntiLagUpdateAMD.adoc[]
--

[open,refpage='VkAntiLagDataAMD',desc='Structure specifying the parameters for vkAntiLagUpdateAMD',type='structs']
--
The sname:VkAntiLagDataAMD structure is defined as:

include::{generated}/api/structs/VkAntiLagDataAMD.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:mode is a elink:VkAntiLagModeAMD value specifying the anti-lag
    status.
  * pname:maxFPS is the framerate limit, in frames per second, used by the
    application.
    This limit will be imposed if anti-lag is enabled.
    If the application tries to render faster, the framerate will be reduced
    to match this limit.
    A value of 0 will disable the limit.
  * pname:pPresentationInfo is a pointer to a
    slink:VkAntiLagPresentationInfoAMD structure containing information
    about the application stage.

This structure specifies anti-lag parameters.

include::{generated}/validity/structs/VkAntiLagDataAMD.adoc[]
--

[open,refpage='VkAntiLagModeAMD',desc='Set the status of the anti-lag feature',type='enums']
--
Possible values of slink:VkAntiLagDataAMD::pname:mode, specifying the
anti-lag status, are:

include::{generated}/api/enums/VkAntiLagModeAMD.adoc[]

  * ename:VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD specifies that anti-lag will
    be enabled or disabled depending on driver settings.
  * ename:VK_ANTI_LAG_MODE_ON_AMD specifies that anti-lag will be enabled.
  * ename:VK_ANTI_LAG_MODE_OFF_AMD specifies that anti-lag will be disabled.
--

[open,refpage='VkAntiLagPresentationInfoAMD',desc='Structure specifying information about stage',type='structs']
--
The sname:VkAntiLagPresentationInfoAMD structure is defined as:

include::{generated}/api/structs/VkAntiLagPresentationInfoAMD.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:stage is a elink:VkAntiLagStageAMD value specifying the current
    application stage.
  * pname:frameIndex is set just before the application processes input data
    (ename:VK_ANTI_LAG_STAGE_INPUT_AMD).
    The same pname:frameIndex value should: be set before the frame with
    current input data will be presented by flink:vkQueuePresentKHR
    (ename:VK_ANTI_LAG_STAGE_PRESENT_AMD).
    This should: be done for each frame.

This structure specifies information about the presentation stage for which
anti-lag parameters are being set.

include::{generated}/validity/structs/VkAntiLagPresentationInfoAMD.adoc[]
--

[open,refpage='VkAntiLagStageAMD',desc='Report the application stage',type='enums']
--
Possible values of slink:VkAntiLagPresentationInfoAMD::pname:stage,
specifying the current application stage, are:

include::{generated}/api/enums/VkAntiLagStageAMD.adoc[]

  * ename:VK_ANTI_LAG_STAGE_INPUT_AMD specifies the stage before processing
    input.
  * ename:VK_ANTI_LAG_STAGE_PRESENT_AMD specifies the stage before
    flink:vkQueuePresentKHR.
--
endif::VK_AMD_anti_lag[]


ifdef::VK_NV_low_latency2[]
[[low-latency2]]
=== Latency Reduction

[open,refpage='vkSetLatencySleepModeNV',desc='Enable or Disable low latency mode on a swapchain',type='protos']
--
To enable or disable low latency mode on a swapchain, call:

include::{generated}/api/protos/vkSetLatencySleepModeNV.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to enable or disable low latency mode
    on.
  * pname:pSleepModeInfo is `NULL` or a pointer to a
    slink:VkLatencySleepModeInfoNV structure specifying the parameters of
    the latency sleep mode.

If pname:pSleepModeInfo is `NULL`, fname:vkSetLatencySleepModeNV will
disable low latency mode, low latency boost, and set the minimum present
interval previously specified by slink:VkLatencySleepModeInfoNV to zero on
pname:swapchain.
As an exception to the normal rules for objects which are externally
synchronized, the swapchain passed to fname:vkSetLatencySleepModeNV may: be
simultaneously used by other threads in calls to functions other than
flink:vkDestroySwapchainKHR.
Access to the swapchain data associated with this extension must: be atomic
within the implementation.

include::{generated}/validity/protos/vkSetLatencySleepModeNV.adoc[]
--

[open,refpage='VkLatencySleepModeInfoNV',desc='Structure to set low latency mode',type='structs']
--
The sname:VkLatencySleepModeInfoNV structure is defined as:

include::{generated}/api/structs/VkLatencySleepModeInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:lowLatencyMode is the toggle to enable or disable low latency
    mode.
  * pname:lowLatencyBoost allows an application to hint to the GPU to
    increase performance to provide additional latency savings at a cost of
    increased power consumption.
  * pname:minimumIntervalUs is the microseconds between
    flink:vkQueuePresentKHR calls for a given swapchain that
    flink:vkLatencySleepNV will enforce.

If pname:lowLatencyMode is ename:VK_FALSE, pname:lowLatencyBoost will still
hint to the GPU to increase its power state and fname:vkLatencySleepNV will
still enforce pname:minimumIntervalUs between fname:vkQueuePresentKHR calls.

include::{generated}/validity/structs/VkLatencySleepModeInfoNV.adoc[]
--

[open,refpage='vkLatencySleepNV',desc='Trigger low latency mode Sleep',type='protos']
--
To provide the synchronization primitive used to delay host CPU work for
lower latency rendering, call:

include::{generated}/api/protos/vkLatencySleepNV.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to delay associated CPU work based on
    slink:VkLatencySubmissionPresentIdNV submissions.
  * pname:pSleepInfo is a pointer to a slink:VkLatencySleepInfoNV structure
    specifying the parameters of the latency sleep.

fname:vkLatencySleepNV returns immediately.
Applications should: use flink:vkWaitSemaphores with
pname:pSleepInfo->signalSemaphore to delay host CPU work.
CPU work refers to application work done before presenting which includes
but is not limited to: input sampling, simulation, command buffer recording,
command buffer submission, and present submission.
Applications should: call this function before input sampling, and exactly
once between presents.

include::{generated}/validity/protos/vkLatencySleepNV.adoc[]
--

[open,refpage='VkLatencySleepInfoNV',desc='Structure specifying the parameters of vkLatencySleepNV',type='structs']
--
The sname:VkLatencySleepInfoNV structure is defined as:

include::{generated}/api/structs/VkLatencySleepInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:signalSemaphore is a semaphore that is signaled to indicate that
    the application should: resume input sampling work.
  * pname:value is the value that pname:signalSemaphore is set to for
    resuming sampling work.

.Valid Usage
****
  * [[VUID-VkLatencySleepInfoNV-signalSemaphore-09361]]
    pname:signalSemaphore must: be a timeline semaphore
****

include::{generated}/validity/structs/VkLatencySleepInfoNV.adoc[]
--

[open,refpage='vkSetLatencyMarkerNV',desc='Pass in marker for timing info',type='protos']
--
An application can: provide timestamps at various stages of its frame
generation work by calling:

include::{generated}/api/protos/vkSetLatencyMarkerNV.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to capture timestamps on.
  * pname:pSetLatencyMarkerInfo is a pointer to a
    slink:VkSetLatencyMarkerInfoNV structure specifying the parameters of
    the marker to set.

At the beginning and end of simulation and render threads and beginning and
end of flink:vkQueuePresentKHR calls, fname:vkSetLatencyMarkerNV can: be
called to provide timestamps for the application's reference.
These timestamps are returned with a call to flink:vkGetLatencyTimingsNV
alongside driver provided timestamps at various points of interest with
regards to latency within the application.
As an exception to the normal rules for objects which are externally
synchronized, the swapchain passed to fname:vkSetLatencyMarkerNV may: be
simultaneously used by other threads in calls to functions other than
flink:vkDestroySwapchainKHR.
Access to the swapchain data associated with this extension must: be atomic
within the implementation.

include::{generated}/validity/protos/vkSetLatencyMarkerNV.adoc[]
--

[open,refpage='VkSetLatencyMarkerInfoNV',desc='Structure specifying the parameters of vkSetLatencyMarkerNV',type='structs']
--
The sname:VkSetLatencyMarkerInfoNV structure is defined as:

include::{generated}/api/structs/VkSetLatencyMarkerInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentID is an application provided value that is used to
    associate the timestamp with a fname:vkQueuePresentKHR command using
ifdef::VK_KHR_present_id[]
ifdef::VK_KHR_present_id2[slink:VkPresentIdKHR::pname:pPresentIds or]
ifndef::VK_KHR_present_id2[slink:VkPresentIdKHR::pname:pPresentIds]
endif::VK_KHR_present_id[]
ifdef::VK_KHR_present_id2[slink:VkPresentId2KHR::pname:pPresentIds]
    for a given present.
  * pname:marker is the type of timestamp to be recorded.

include::{generated}/validity/structs/VkSetLatencyMarkerInfoNV.adoc[]
--

[open,refpage='VkLatencyMarkerNV',desc='Structure used to mark different points in latency',type='enums']
--
The elink:VkLatencyMarkerNV enum is defined as:

include::{generated}/api/enums/VkLatencyMarkerNV.adoc[]

The members of the elink:VkLatencyMarkerNV are used as arguments for
flink:vkSetLatencyMarkerNV in the use cases described below:

  * ename:VK_LATENCY_MARKER_SIMULATION_START_NV should: be called at the
    start of the simulation execution each frame, but after the call to
    fname:vkLatencySleepNV.
  * ename:VK_LATENCY_MARKER_SIMULATION_END_NV should: be called at the end
    of the simulation execution each frame.
  * ename:VK_LATENCY_MARKER_RENDERSUBMIT_START_NV should: be called at the
    beginning of the render submission execution each frame.
    This should: be wherever Vulkan API calls are made and must: not span
    into asynchronous rendering.
  * ename:VK_LATENCY_MARKER_RENDERSUBMIT_END_NV should: be called at the end
    of the render submission execution each frame.
  * ename:VK_LATENCY_MARKER_PRESENT_START_NV should: be called just before
    fname:vkQueuePresentKHR.
  * ename:VK_LATENCY_MARKER_PRESENT_END_NV should: be called when
    fname:vkQueuePresentKHR returns.
  * ename:VK_LATENCY_MARKER_INPUT_SAMPLE_NV should: be called just before
    the application gathers input data.
  * ename:VK_LATENCY_MARKER_TRIGGER_FLASH_NV should: be called anywhere
    between ename:VK_LATENCY_MARKER_SIMULATION_START_NV and
    ename:VK_LATENCY_MARKER_SIMULATION_END_NV whenever a left mouse click
    occurs.
--

[open,refpage='vkGetLatencyTimingsNV',desc='Get latency marker results',type='protos']
--
To get an array containing the newest collected latency data, call:

include::{generated}/api/protos/vkGetLatencyTimingsNV.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to return data from.
  * pname:pLatencyMarkerInfo is a pointer to a
    slink:VkGetLatencyMarkerInfoNV structure specifying the parameters for
    returning latency information.

The timings returned by fname:vkGetLatencyTimingsNV contain the timestamps
requested from flink:vkSetLatencyMarkerNV and additional
implementation-specific markers defined in
slink:VkLatencyTimingsFrameReportNV.

include::{generated}/validity/protos/vkGetLatencyTimingsNV.adoc[]
--

[open,refpage='VkGetLatencyMarkerInfoNV',desc='Structure specifying the parameters of vkGetLatencyTimingsNV',type='structs']
--
The sname:VkGetLatencyMarkerInfoNV structure is defined as:

include::{generated}/api/structs/VkGetLatencyMarkerInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is either `NULL` or a pointer to a structure extending this
    structure.
  * pname:timingCount is an integer related to the number of previous frames
    of latency data available or queried, as described below.
  * pname:pTimings is either `NULL` or a pointer to an array of
    slink:VkLatencyTimingsFrameReportNV structures.

If pname:pTimings is `NULL` then the maximum number of queryable frame data
is returned in pname:timingCount.
Otherwise, pname:timingCount must: be set by the application to the number
of elements in the pname:pTimings array, and on return is overwritten with
the number of values actually written to pname:pTimings.
The elements of pname:pTimings are arranged in the order they were requested
in, with the oldest data in the first entry.

include::{generated}/validity/structs/VkGetLatencyMarkerInfoNV.adoc[]
--

[open,refpage='VkLatencyTimingsFrameReportNV',desc='Structure containing latency data',type='structs']
--
The slink:VkLatencyTimingsFrameReportNV structure describes latency data
returned by flink:vkGetLatencyTimingsNV

include::{generated}/api/structs/VkLatencyTimingsFrameReportNV.adoc[]

The members of the slink:VkLatencyTimingsFrameReportNV structure describe
the following:

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentID is the application provided value that is used to
    associate the timestamp with a fname:vkQueuePresentKHR command using
ifdef::VK_KHR_present_id[]
ifdef::VK_KHR_present_id2[slink:VkPresentIdKHR::pname:pPresentIds or]
ifndef::VK_KHR_present_id2[slink:VkPresentIdKHR::pname:pPresentIds]
endif::VK_KHR_present_id[]
ifdef::VK_KHR_present_id2[slink:VkPresentId2KHR::pname:pPresentIds]
    for a given present.
  * pname:simStartTimeUs is the timestamp written when
    fname:vkSetLatencyMarkerNV is called with the ename:VkLatencyMarkerNV
    enum ename:VK_LATENCY_MARKER_SIMULATION_START_NV.
  * pname:simEndTimeUs is the timestamp written when
    fname:vkSetLatencyMarkerNV is called with the ename:VkLatencyMarkerNV
    enum ename:VK_LATENCY_MARKER_SIMULATION_END_NV
  * pname:renderStartTimeUs is the timestamp written when
    fname:vkSetLatencyMarkerNV is called with the ename:VkLatencyMarkerNV
    enum ename:VK_LATENCY_MARKER_RENDERSUBMIT_START_NV.
  * pname:renderEndTimeUs is the timestamp written when
    fname:vkSetLatencyMarkerNV is called with the ename:VkLatencyMarkerNV
    enum ename:VK_LATENCY_MARKER_RENDERSUBMIT_END_NV.
  * pname:presentStartTimeUs is the timestamp written when
    fname:vkSetLatencyMarkerNV is called with the ename:VkLatencyMarkerNV
    enum ename:VK_LATENCY_MARKER_PRESENT_START_NV.
  * pname:presentEndTimeUs is the timestamp written when
    fname:vkSetLatencyMarkerNV is called with the ename:VkLatencyMarkerNV
    enum ename:VK_LATENCY_MARKER_PRESENT_END_NV.
  * pname:driverStartTimeUs is the timestamp written when the first
    fname:vkQueueSubmit for the frame is called.
  * pname:driverEndTimeUs is the timestamp written when the final
    fname:vkQueueSubmit hands off from the Vulkan Driver.
  * pname:osRenderQueueStartTimeUs is the timestamp written when the final
    fname:vkQueueSubmit hands off from the Vulkan Driver.
  * pname:osRenderQueueEndTimeUs is the timestamp written when the first
    submission reaches the GPU.
  * pname:gpuRenderStartTimeUs is the timestamp written when the first
    submission reaches the GPU.
  * pname:gpuRenderEndTimeUs is the timestamp written when the final
    submission finishes on the GPU for the frame.

include::{generated}/validity/structs/VkLatencyTimingsFrameReportNV.adoc[]
--

[open,refpage='VkLatencySubmissionPresentIdNV',desc='Structure used to associate a queueSubmit with a presentId',type='structs']
--
The slink:VkLatencySubmissionPresentIdNV structure is defined as:

include::{generated}/api/structs/VkLatencySubmissionPresentIdNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentID is used to associate the fname:vkQueueSubmit with the
    presentId used for a given fname:vkQueuePresentKHR via
ifdef::VK_KHR_present_id[]
ifdef::VK_KHR_present_id2[slink:VkPresentIdKHR::pname:pPresentIds or]
ifndef::VK_KHR_present_id2[slink:VkPresentIdKHR::pname:pPresentIds.]
endif::VK_KHR_present_id[]
ifdef::VK_KHR_present_id2[slink:VkPresentId2KHR::pname:pPresentIds.]

For any submission to be tracked with low latency mode pacing, it needs to
be associated with other submissions in a given present.
To associate a submission with pname:presentID for low latency mode, the
pname:pNext chain of flink:vkQueueSubmit must: include a
sname:VkLatencySubmissionPresentIdNV structure.

include::{generated}/validity/structs/VkLatencySubmissionPresentIdNV.adoc[]
--

[open,refpage='vkQueueNotifyOutOfBandNV',desc='Notify out of band queue',type='protos']
--
To mark a queue as _out of band_, so that all fname:vkQueueSubmit calls on
the queue are ignored for latency evaluation, call:

include::{generated}/api/protos/vkQueueNotifyOutOfBandNV.adoc[]

  * pname:queue is the VkQueue to be marked as out of band.
  * pname:pQueueTypeInfo is a pointer to a slink:VkOutOfBandQueueTypeInfoNV
    structure specifying the queue type.

include::{generated}/validity/protos/vkQueueNotifyOutOfBandNV.adoc[]
--

[open,refpage='VkOutOfBandQueueTypeInfoNV',desc='Structure used to describe the queue that is being marked as Out of Band',type='structs']
--
The slink:VkOutOfBandQueueTypeInfoNV structure is defined as:

include::{generated}/api/structs/VkOutOfBandQueueTypeInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:queueType describes the usage of the queue to be marked as out of
    band.

include::{generated}/validity/structs/VkOutOfBandQueueTypeInfoNV.adoc[]
--

[open,refpage='VkOutOfBandQueueTypeNV',desc='Type of out of band queue',type='enums']
--
The elink:VkOutOfBandQueueTypeNV enum is defined as:

include::{generated}/api/enums/VkOutOfBandQueueTypeNV.adoc[]

The members of the elink:VkOutOfBandQueueTypeNV are used to describe the
queue type in slink:VkOutOfBandQueueTypeInfoNV as described below:

  * ename:VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV specifies that work will be
    submitted to this queue.
  * ename:VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV specifies that this queue
    will be presented from.
--

[open,refpage='VkSwapchainLatencyCreateInfoNV',desc='Specify that a swapchain will use low latency mode',type='structs']
--
To allow low latency mode to be used by a swapchain, add a
sname:VkSwapchainLatencyCreateInfoNV structure to the pname:pNext chain of
slink:VkSwapchainCreateInfoKHR.

The sname:VkSwapchainLatencyCreateInfoNV structure is defined as:

include::{generated}/api/structs/VkSwapchainLatencyCreateInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:latencyModeEnable is ename:VK_TRUE if the created swapchain will
    utilize low latency mode, ename:VK_FALSE otherwise.

include::{generated}/validity/structs/VkSwapchainLatencyCreateInfoNV.adoc[]
--

[open,refpage='VkLatencySurfaceCapabilitiesNV',desc='Structure describing surface optimized presentation modes for use with low latency mode',type='structs']
--
The sname:VkLatencySurfaceCapabilitiesNV structure is defined as:

include::{generated}/api/structs/VkLatencySurfaceCapabilitiesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentModeCount is the number of presentation modes provided.
  * pname:pPresentModes is list of presentation modes optimized for use with
    low latency mode with pname:presentModeCount entries.

If pname:pPresentModes is `NULL`, then the number of present modes that are
optimized for use with low latency mode returned in pname:presentModeCount.
Otherwise, pname:presentModeCount must: be set by the application to the
number of elements in the pname:pPresentModes array, and on return is
overwritten with the number of values actually written to
pname:pPresentModes.
If the value of pname:presentModeCount is less than the number of optimized
present modes, at most pname:presentModeCount values will be written to
pname:pPresentModes.

include::{generated}/validity/structs/VkLatencySurfaceCapabilitiesNV.adoc[]
--
endif::VK_NV_low_latency2[]

endif::VK_AMD_anti_lag,VK_NV_low_latency2[]


ifdef::VK_NV_present_barrier[]
[[present-barrier]]
== Present Barrier

The `apiext:VK_NV_present_barrier` extension allows applications to
synchronize corresponding presentation requests across multiple swapchains
using the _present barrier_.
A swapchain is said to be using the _present barrier_ if the swapchain is
created by adding a slink:VkSwapchainPresentBarrierCreateInfoNV structure to
the pname:pNext chain of the slink:VkSwapchainCreateInfoKHR structure, and
setting
slink:VkSwapchainPresentBarrierCreateInfoNV::pname:presentBarrierEnable to
true.

A set of corresponding presentation requests is defined as exactly one
queued presentation request associated with each swapchain using the present
barrier, whether or not that queued request has executed.
A given presentation request is added, when created by calling
flink:vkQueuePresentKHR and specifying a swapchain using the present
barrier, either to the oldest existing set of corresponding requests for
which there is no existing member associated with the request's swapchain,
or to a new set of corresponding requests if no such set exists.

A set of corresponding requests is said to be _full_ when it contains one
request from each swapchain using the present barrier.
Queued presentation of an image to a swapchain using the _present barrier_
is _deferred_ by the implementation until the set of corresponding requests
is full, and the visibility operations associated with all requests in that
set, as described by flink:vkQueuePresentKHR, have completed.

Additionally, the set of swapchains using the present barrier can be in the
same process, or different processes running under the same operating
system.
And if the required synchronization hardware is connected and correctly
configured, this extension also supports applications to synchronize
corresponding presentation requests using the _present barrier_ across
distributed systems.
However, the configuration mechanism of the required hardware is outside the
scope of the Vulkan specification and this extension.

[open,refpage='VkSwapchainPresentBarrierCreateInfoNV',desc='specify the present barrier membership of this swapchain',type='structs']
--
The slink:VkSwapchainPresentBarrierCreateInfoNV structure is defined as:

include::{generated}/api/structs/VkSwapchainPresentBarrierCreateInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentBarrierEnable is a boolean value indicating a request for
    using the _present barrier_.

If the pname:pNext chain of slink:VkSwapchainCreateInfoKHR does not include
this structure, the default value for pname:presentBarrierEnable is
ename:VK_FALSE, meaning the swapchain does not request to use the present
barrier.
Additionally, when recreating a swapchain that was using the present
barrier, and the pname:pNext chain of slink:VkSwapchainCreateInfoKHR does
not include this structure, it means the swapchain will stop using the
present barrier.

include::{generated}/validity/structs/VkSwapchainPresentBarrierCreateInfoNV.adoc[]
--
endif::VK_NV_present_barrier[]


ifdef::VK_NV_present_metering[]
[[present-metering]]
=== Present Metering

[open,refpage='VkSetPresentConfigNV',desc='Structure specifying present metering configuration',type='structs']
--

Present Metering evenly paces out the next pname:numFramesPerBatch
flink:vkQueuePresentKHR presents.
This gives smoother pacing between presents in applications with frame
generation integrations.

The sname:VkSetPresentConfigNV structure is defined as:

include::{generated}/api/structs/VkSetPresentConfigNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:numFramesPerBatch is the number of frames to batch
  * pname:presentConfigFeedback will return the success or error status

The metering configuration applies to all swapchains in the array in
slink:VkPresentInfoKHR.
The configuration specified by sname:VkSetPresentConfigNV applies to the
next pname:numFramesPerBatch calls to flink:vkQueuePresentKHR and needs to
be updated every pname:numFramesPerBatch presents.

.Valid Usage
****
  * [[VUID-VkSetPresentConfigNV-numFramesPerBatch-10581]]
    pname:numFramesPerBatch must: not be larger than 8
****

include::{generated}/validity/structs/VkSetPresentConfigNV.adoc[]
--
endif::VK_NV_present_metering[]

