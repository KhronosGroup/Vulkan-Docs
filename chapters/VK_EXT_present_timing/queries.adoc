// Copyright (c) 2014-2023 Khronos Group.
//
// SPDX-License-Identifier: CC-BY-4.0

== Present Timing Queries

Traditional game and real-time-animation applications frequently use
ename:VK_PRESENT_MODE_FIFO_KHR so that presentable images are updated during
the vertical blanking period of a given refresh cycle (RC) of the
presentation engine's display.
On fixed refresh rate displays, this avoids the visual anomaly known as
tearing.

However, synchronizing the presentation of images with the RC does not
prevent all forms of visual anomalies.
Stuttering occurs when the geometry for each presentable image is not
accurately positioned for when that image will be displayed.
The geometry may appear to move too little some RCs, and too much for
others.
Sometimes the animation appears to freeze, when the same image is used for
more RCs than other images.

In order to minimize stuttering, an application needs to: 1) render and
present images at a consistent rate that is, on fixed refresh rate displays,
a multiple of the presentation engine's refresh rate; 2) correctly position
its geometry for when the presentable image will be displayed to the user.
The
ifdef::VK_EXT_present_timing[]
`VK_EXT_present_timing`
endif::VK_EXT_present_timing[]
ifdef::VK_EXT_present_timing+VK_GOOGLE_display_timing[or]
ifdef::VK_GOOGLE_display_timing[]
`VK_GOOGLE_display_timing`
endif::VK_GOOGLE_display_timing[]
extension allows an application to satisfy these needs.

The presentation engine's display typically refreshes the pixels that are
displayed to the user on a periodic basis. This period may: be fixed (Fixed
Refresh Rate, FRR) or variable (Variable Refresh Rate, VRR).

ifdef::VK_EXT_present_timing[]
[open,refpage='vkSetSwapchainPresentTimingQueueSizeEXT',desc='Allocate memory for the swapchain-internal timing results queue',type='protos']
--
In order to collect timing information about presentation, a swapchain needs
an internal queue to store asynchronously updated results until applications
collect them.

To allocate the swapchain's internal timing results queue, call:

include::{generated}/api/protos/vkSetSwapchainPresentTimingQueueSizeEXT.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to allocate a results queue for.
  * pname:size is the requested number of slots in the internal results queue.

If this function is called multiple times, the internal queue is reallocated
to fit the new pname:size. If the new pname:size is less than the current
number of outstanding results, ename:VK_NOT_READY is returned and no allocation
is performed.

.Valid Usage
****
  * pname:swapchain must: have been created with
    sname:VkSwapchainCreateInfoKHR::pname:flags containing
    ename:VK_SWAPCHAIN_CREATE_PRESENT_TIMING_BIT_EXT
****

include::{generated}/validity/protos/vkSetSwapchainPresentTimingQueueSizeEXT.adoc[]
--

[open,refpage='vkGetSwapchainTimingPropertiesEXT',desc='Obtain the display timing properties of the PE\'s display',type='protos']
--

The implementation maintains an internal monotonically increasing counter
which updates when the presentation engine's timing properties are modified.

To query the presentation engine's current timing properties for a given
swapchain, call:

include::{generated}/api/protos/vkGetSwapchainTimingPropertiesEXT.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to obtain timing properties for.
  * pname:pSwapchainTimingProperties is a pointer to an instance of the
    slink:VkSwapchainTimingPropertiesEXT structure.
  * pname:pSwapchainTimingPropertiesCounter is `NULL` or a pointer to a
    64-bit unsigned integer set by the implementation to the current value of
    the swapchain's internal timing properties counter.

include::{generated}/validity/protos/vkGetSwapchainTimingPropertiesEXT.adoc[]
--

[open,refpage='VkSwapchainTimingPropertiesEXT',desc='Structure containing the RC duration of a display',type='structs']
--

The sname:VkSwapchainTimingPropertiesEXT structure is defined as:

include::{generated}/api/structs/VkSwapchainTimingPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:refreshDuration is zero or an indication of the duration
    of a refresh cycle.
    If the presentation engine is operating as an FRR display, this is the
    number of nanoseconds from the start of one refresh cycle to the
    start of the next refresh cycle.
    If the presentation engine is operating as a VRR display
    (i.e. refresh cycles may: have variable length), this is the
    minimum number of nanoseconds from the start of one refresh cycle
    to the start of the next refresh cycle.
  * pname:variableRefreshDelay is undefined: if pname:refreshDuration is
    zero; otherwise it is a duration in nanoseconds indicating the maximum
    theoretical delay for the presentation engine to start a new refresh
    cycle upon processing a presentation request.

If pname:variableRefreshDelay is the same as pname:refreshDuration, the
presentation engine is operating as an FRR display.

Some platforms may: not provide timing properties until after at least one
image has been presented to the pname:swapchain. If timing properties
change for the pname:swapchain, these same platforms may: not provide
updated results until after at least one additional image has been
presented to the pname:swapchain.

include::{generated}/validity/structs/VkSwapchainTimingPropertiesEXT.adoc[]
--

[NOTE]
.Note
====
The rate at which an application renders and presents new images is known as
the image present rate (IPR, a.k.a. frame rate).
The inverse of IPR, or the duration between each image present, is the image
present duration (IPD).
On FRR displays, in order to provide a smooth, stutter-free animation, an
application needs its IPD to be a multiple of pname:refreshDuration.
For example, if a display has a 60Hz refresh rate, pname:refreshDuration
will be a value in nanoseconds that is approximately equal to 16.67ms.
In such a case, an application will want an IPD of 16.67ms (1X multiplier of
pname:refreshDuration), or 33.33ms (2X multiplier of pname:refreshDuration),
or 50.0ms (3X multiplier of pname:refreshDuration), etc.

In order to determine a target IPD for a display (i.e. a multiple of
pname:refreshDuration), an application needs to determine when its images
are actually displayed.
Consider an application that has an initial target IPD of 16.67ms (1X
multiplier of pname:refreshDuration).
It will therefore position the geometry of a new image 16.67ms later than
the previous image.
Let us say that this application is running on slower hardware, so that it
actually takes 20ms to render each new image.
This will create visual anomalies, because the images will not be displayed
to the user every 16.67ms, nor every 20ms.
In this case, it is better for the application to adjust its target IPD to
33.33ms (i.e. a 2X multiplier of pname:refreshDuration), and tell the
presentation engine to not present images any sooner than every 33.33ms.
This will allow the geometry to be correctly positioned for each presentable
image.

Adjustments to an application's IPD may be needed because different views of
an application's geometry can take different amounts of time to render.
For example, looking at the sky may take less time to render than looking at
multiple, complex items in a room.
In general, it is good to not frequently change IPD, as that can cause
visual anomalies.
Adjustments to a larger IPD because of late images should happen quickly,
but adjustments to a smaller IPD should only happen if the periodic
feedback of slink:VkPastPresentationTimingEXT values indicates that the
target IPD can be durably achieved.
====

[open,refpage='vkGetSwapchainTimeDomainsEXT',desc='Obtain the time domains supported by the PE for the swapchain',type='protos']
--

To query the time domain used by the presentation engine for a given swapchain,
call:

include::{generated}/api/protos/vkGetSwapchainTimeDomainsEXT.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to obtain timing properties for.
  * pname:pSwapchainTimeDomainCount is a pointer to an integer related to the
    number of time domains available or queried, as described below.
  * pname:pSwapchainTimeDomains is either `NULL` or a pointer to an array of
    slink:VkSwapchainTimeDomainPropertiesEXT structs, indicating the supported time
    domains of the presentation engine for the swapchain.

If pname:pSwapchainTimeDomains is `NULL`, then the number of time domains
supported for the given pname:swapchain is returned in
pname:pSwapchainTimeDomainCount (if this value is zero, pname:swapchain
does not currently support display timing).
Otherwise, pname:pSwapchainTimeDomainCount must: point to a variable set by the user
to the number of elements in the pname:pSwapchainTimeDomains array, and on return
the variable is overwritten with the number of values actually written to
pname:pSwapchainTimeDomains.
If the value of pname:pSwapchainTimeDomainCount is less than the number of
time domains supported, at most pname:pSwapchainTimeDomainCount values will be
written.
If pname:pSwapchainTimeDomainCount is smaller than the number of time domains
supported for the given pname:swapchain, ename:VK_INCOMPLETE will be returned
instead of ename:VK_SUCCESS to indicate that not all the available values
were returned.

include::{generated}/validity/protos/vkGetSwapchainTimeDomainsEXT.adoc[]
--

[open,refpage='VkSwapchainTimeDomainPropertiesEXT',desc='An available time domain for a swapchain',type='structs']
--

The sname:VkSwapchainTimeDomainPropertiesEXT structure is defined as:

include::{generated}/api/structs/VkSwapchainTimeDomainPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:timeDomain is a elink:VkTimeDomainEXT value representing a time
    domain that is available for the swapchain.
  * pname:timeDomainId is a unique identifier for this time domain within a
    swapchain's namespace.

[NOTE]
.Note
====
Due to the dynamic nature of their underlying sname:VkSurfaceKHR properties,
swapchains may need to expose multiple swapchain-local opaque time domains
using the same elink:VkTimeDomainEXT value, for example when a surface is
moved from one display hardware to another. Arbitrary identifiers, provided
in pname:timeDomainId, are used by the implementation to differentiate opaque
time domains of identical scopes.
====

include::{generated}/validity/structs/VkSwapchainTimeDomainPropertiesEXT.adoc[]
--

[open,refpage='vkGetPastPresentationTimingEXT',desc='Obtain timing of previously-presented images',type='protos']
--

Because of the asynchronous nature of the presentation engine, the timing
information for a given flink:vkQueuePresentKHR command only becomes
available some time later.
These time values should: be asynchronously queried, and are returned if
available.
All time values are in nanoseconds, according to the time-domain being used.

To asynchronously query the presentation engine for newly-available timing
information about one or more previous presents to a given swapchain, call:

include::{generated}/api/protos/vkGetPastPresentationTimingEXT.adoc[]

  * pname:device is the device associated with pname:swapchain.
  * pname:swapchain is the swapchain to obtain presentation timing
    information duration for.
  * pname:pPresentationTimingCount is a pointer to an integer related to the
    number of slink:VkPastPresentationTimingEXT structures to query, as
    described below.
  * pname:pPresentationTimings is `NULL` or a pointer to an an array
    of slink:VkPastPresentationTimingEXT structures.
  * pname:pSwapchainTimingPropertiesCounter is `NULL` or a pointer to a
    64-bit unsigned integer set by the implementation to the current value of
    the swapchain's internal timing properties counter.
  * pname:pTimeDomainsChanged is `NULL` or a pointer to a boolean value
    indicating if the list of supported time domains supported by the
    pname:swapchain has changed since the last call to this function.

If pname:pPresentationTimings is `NULL`, then the number of available
timing records for the given pname:swapchain is returned in
pname:pPresentationTimingCount.
Otherwise, pname:pPresentationTimingCount must: point to a variable set by
the user to the number of elements in the pname:pPresentationTimings array,
and on return the variable is overwritten with the number of structures
actually written to pname:pPresentationTimings.
If the value of pname:pPresentationTimingCount is less than the number of
newly-available timing records for the given pname:swapchain, at most
pname:pPresentationTimingCount structures are written, and
ename:VK_INCOMPLETE is returned instead of ename:VK_SUCCESS to indicate that
not all the available values were returned.

fname:vkGetPastPresentationTimingEXT may: return incomplete results,
containing only information for a subset of the requested present
stages. Further calls to fname:vkGetPastPresentationTimingEXT will keep
providing all available results for a previously incomplete entry until it
is complete.

The implementation must: return a slink:VkPastPresentationTimingEXT for
every flink:vkQueuePresentKHR referencing pname:swapchain where a non-zero
slink:VkPresentTimingInfoEXT::pname:presentStageQueries was specified and at
least one present stage has available results.

If pname:pTimeDomainsChanged is ename:VK_TRUE, applications should: query
the new list of available time domains with flink:vkGetSwapchainTimeDomainsEXT.

Timing information may: become available out of order with regards to their
associated presentation request submission order.

Upon return, zero or more slots of the pname:swapchain internal timing
results queue, equal to the number of entries written to
pname:pPresentationTimings for which pname:reportComplete is ename:VK_TRUE,
are made available for future fname:vkQueuePresentKHR calls. Elements of
pname:pPresentationTimings are arranged in ascending order of present ids.

There is no requirement for any precise timing relationship between the
completion of a present stage and the availability of any associated timing
information.

As an exception to the normal rules for objects which are externally
synchronized, pname:swapchain may: be simultaneously used by other threads
in calls to functions other than flink:vkDestroySwapchainKHR and
flink:vkCreateSwapchainKHR with pname:swapchain used as an
pname:oldSwapchain. Access to the swapchain timing information must: be
atomic within the implementation.

include::{generated}/validity/protos/vkGetPastPresentationTimingEXT.adoc[]
--

[open,refpage='VkPastPresentationTimingEXT',desc='Structure containing timing information about a previously-presented image',type='structs']
--

The sname:VkPastPresentationTimingEXT structure is defined as:

include::{generated}/api/structs/VkPastPresentationTimingEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:presentId is zero or an application-provided value that was given
    to a previous fname:vkQueuePresentKHR command via
    slink:VkPresentIdKHR::pname:pPresentIds.
  * pname:presentStageCount is a count of items contained in
    pname:pPresentStages.
  * pname:pPresentStages a pointer to an array of
    slink:VkPresentStageTimeEXT providing timing information for the
    presentation request associated with pname:presentId.
  * pname:timeDomainId is the id of the time domain used by the presentation
    engine to report times in pname:pPresentStages.
  * pname:reportComplete is ename:VK_TRUE if the presentation engine
    has reported all the requested results in pname:pPresentStages.

If pname:presentId is not zero, pname:presentStageCount must: be set by the
application to be at least equal to the number of present stages specified
in slink:VkPresentTimingInfoEXT::pname:presentStagesQueries for the
associated flink:vkQueuePresentKHR call. Otherwise, pname:presentStageCount
must: be at least equal to the highest number of present stages queried
among all presentation requests for which there are outstanding results.

Timing information for some present stages may: have a time value of 0,
indicating that results for that present stage are not available.

For systems with multiple entities operating within the presentation
engine, such as multiple displays, pname:pPresentStages will return timing
results for at least one entity which has been affected by the presentation.

pname:timeDomain may: be different than the time domain that was specified
in slink:VkPresentTimingInfoEXT::pname:timeDomain if the requirements for
using this time domain could not be met at the time the presentation engine
processed the presentation request. In such a case, the presentation engine
may: pick a time domain to fall back to and report results in that domain.
Applications can: continue to use this fallback time domain in future
flink:vkQueuePresentKHR calls, or they can: call
flink:vkGetSwapchainTimeDomainsEXT to choose from the currently supported
time domains.

include::{generated}/validity/structs/VkPastPresentationTimingEXT.adoc[]

[NOTE]
.Note
====
An application can: determine its optimal IPD in FRR scenarios by using the
sname:VkPastPresentationTimingEXT values.

For a given target present stage, if `pPresentStages[targetStageIndex].time`
is one or more refresh cycle durations later than the associated present
pname:targetPresentTime, the application knows that the image was presented
late. In order to avoid visual anomalies, it can: increase its IPD by a
multiple of the refresh cycle duration that approximately corresponds to the
difference between `pPresentStages[targetStageIndex].time` and
pname:targetPresentTime.

If `pPresentStages[targetStageIndex].time` and pname:targetPresentTime are
consistently approximately equal to each other, the application knows that
it is rendering smoothly, without stutter. In that situation, it can:
determine if a lower IPD could be durably achieved by computing the
difference between `pPresentStages[imageLatchedStageIndex].time` and
`pPresentStages[imageHandoffStageIndex].time` over multiple frames, provided
feedback for those present stages is available. If the obtained duration is
consistently larger than the difference between the current and the desired
IPD, then the desired IPD is achievable without stutter.

Frequent changes to an application's IPD can: cause visual artifacts.
Therefore, it is wise for an application to avoid frequent changes to
its IPD.
====

[NOTE]
.Note
====
The presentation engine may: change the timing properties of the
pname:swapchain for a variety of reasons.
For example, if the window system changes its mode, including the
refresh rate of the display.
Another example is if an application's surface is being composited
with other windows of a window system, and then the surface's window
becomes a borderless, full-screen window.
While composited, the timing properties may: be FRR, and while
full-screen, the timing properties may: be VRR.

The available time domains for a swapchain may: change for similar or
identical reasons.
Therefore, it is possible that the same event will cause both
pname:timingPropertiesChanged to become ename:VK_TRUE and and
pname:timeDomain to be different than the time domain requested in
slink:VkPresentTimingInfoEXT.
====
--

[open,refpage='VkPresentStageTimeEXT',desc='Associate a present stage with a timestamp',type='structs']
--
The sname:VkPresentStageTimeEXT structure is defined as:

include::{generated}/api/structs/VkPresentStageTimeEXT.adoc[]

  * pname:stage is a tlink:VkPresentStageFlagsEXT value specifying a present stage.
  * pname:time is a time in nanoseconds associated with the pname:stage.

include::{generated}/validity/structs/VkPresentStageTimeEXT.adoc[]
--
endif::VK_EXT_present_timing[]

ifdef::VK_GOOGLE_display_timing[]
include::{chapters}/VK_GOOGLE_display_timing/queries.adoc[]
endif::VK_GOOGLE_display_timing[]
