// Copyright (c) 2018-2020 The Khronos Group, Inc.
//
// SPDX-License-Identifier: CC-BY-4.0

ifdef::VK_KHR_ray_tracing_pipeline,VK_NV_ray_tracing[]

[[ray-tracing]]
= Ray Tracing

Ray tracing uses a separate rendering pipeline from both the graphics and
compute pipelines (see <<pipelines-ray-tracing,Ray Tracing Pipeline>>).

[[fig-raypipe]]
image::{images}/ray_tracing_execution.svg[align="center",title="Ray tracing pipeline execution",opts="{imageopts}"]

.Caption
****
Interaction between the different shader stages in the ray tracing pipeline
****

Within the ray tracing pipeline, code:OpTraceRayKHR can: be called to
perform a <<ray-traversal,ray traversal>> that invokes the various ray
tracing shader stages during its execution.
The relationship between the ray tracing pipeline object and the geometries
present in the acceleration structure traversed is passed into the ray
tracing command in a slink:VkBuffer object known as a _shader binding
table_.
code:OpExecuteCallableKHR can also be used in ray tracing pipelines to
invoke a <<shaders-callable,callable shader>>.

During execution, control alternates between scheduling and other
operations.
The scheduling functionality is implementation-specific and is responsible
for workload execution.
The shader stages are programmable.
<<ray-traversal, _Traversal_>>, which refers to the process of traversing
acceleration structures to find potential intersections of rays with
geometry, is fixed function.

The programmable portions of the pipeline are exposed in a single-ray
programming model, with each invocation handling one ray at a time.
Memory operations can: be synchronized using standard memory barriers.
The code:Workgroup scope and variables with a storage class of
code:Workgroup must: not be used in the ray tracing pipeline.


[[ray-tracing-shader-call]]
== Shader Call Instructions

A _shader call_ is an instruction which may: cause execution to continue
elsewhere by creating one or more invocations that execute a different
shader stage.

The shader call instructions are:

 * code:OpTraceRayKHR which may: invoke intersection, any-hit, closest hit,
   or miss shaders,
 * code:OpReportIntersectionKHR which may: invoke any-hit shaders, and
 * code:OpExecuteCallableKHR which will invoke a callable shader.

ifdef::VK_VERSION_1_1[]
The invocations created by shader call instructions are grouped into
subgroups by the implementation.
Those subgroups may: be unrelated to the subgroup of the parent invocation.
endif::VK_VERSION_1_1[]


[[ray-tracing-recursion-depth]]
Trace ray instructions can: be used recursively; invoked shaders can:
themselves execute trace ray instructions, to a maximum depth defined by the
ifdef::VK_NV_ray_tracing[]
<<limits-maxRecursionDepth, pname:maxRecursionDepth>> or
endif::VK_NV_ray_tracing[]
<<limits-maxRayRecursionDepth, pname:maxRayRecursionDepth>> limit.

Shaders directly invoked from the API always have a recursion depth of 0;
each shader executed by a trace ray instruction has a recursion depth one
higher than the recursion depth of the shader which invoked it.
Applications must: not invoke a shader with a recursion depth greater than
the value of
ifdef::VK_NV_ray_tracing[]
pname:maxRecursionDepth or
endif::VK_NV_ray_tracing[]
pname:maxPipelineRayRecursionDepth specified in the pipeline.

[[ray-tracing-repack]]
An _invocation repack instruction_ is a ray tracing shader call instruction
where the implementation may: change the set of invocations that are
executing.
When a repack instruction is encountered, the invocation is suspended and a
new invocation begins and executes the instruction.
After executing the repack instruction (which may: result in other ray
tracing shader stages executing) the new invocation ends and the original
invocation is resumed, but it may: be resumed in a different subgroup or at
a different code:SubgroupLocalInvocationId within the same subgroup.
When a subset of invocations in a subgroup execute the invocation repack
instruction, those that do not execute it remain in the same subgroup at the
same code:SubgroupLocalInvocationId.

The code:OpTraceRayKHR, code:OpReportIntersectionKHR, and
code:OpExecuteCallableKHR instructions are invocation repack instructions.

ifdef::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_2,VK_KHR_vulkan_memory_model[]
The invocations that are executing before an invocation repack instruction,
after the instruction, or are created by the instruction, are
<<shader-call-related,shader-call-related>>.
endif::VK_VERSION_1_2,VK_KHR_vulkan_memory_model[]

If the implementation changes the composition of subgroups, the values of
code:SubgroupSize, code:SubgroupLocalInvocationId,
ifdef::VK_NV_shader_sm_builtins[]
code:SMIDNV, code:WarpIDNV,
endif::VK_NV_shader_sm_builtins[]
and builtin variables that are derived from them (code:SubgroupEqMask,
code:SubgroupGeMask, code:SubgroupGtMask, code:SubgroupLeMask,
code:SubgroupLtMask) must: be changed accordingly by the invocation repack
instruction.
The application must: use <<builtin-volatile-semantics,code:Volatile
semantics>> on these code:BuiltIn variables when used in the ray generation,
closest hit, miss, intersection, and callable shaders.
Similarly, the application must: use code:Volatile semantics on any
code:RayTmaxKHR decorated code:Builtin used in an intersection shader.

[NOTE]
.Note
====
<<shaders-group-operations,Subgroup operations>> are permitted in the
programmable ray tracing shader stages.
However, shader call instructions place a bound on where results of subgroup
instructions or subgroup-scoped instructions that execute the dynamic
instance of that instruction are potentially valid.
For example, care must: be taken when using the result of a ballot operation
that was computed before an invocation repack instruction, after that repack
instruction.
The ballot may: be incorrect as the set of invocations could have changed.

ifdef::VK_EXT_subgroup_size_control[]
While the code:SubgroupSize built-in is required to be declared
code:Volatile, its value will never change unless
ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT is
set on pipeline creation, as without that bit set, its value is required to
match that of slink:VkPhysicalDeviceSubgroupProperties::pname:subgroupSize.
endif::VK_EXT_subgroup_size_control[]

ifdef::VK_KHR_shader_clock[]
For clock operations, the value of a code:Subgroup scoped
code:OpReadClockKHR read before the dynamic instance of a repack instruction
should: not be compared to the result of that clock instruction after the
repack instruction.
endif::VK_KHR_shader_clock[]
====
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_2,VK_KHR_vulkan_memory_model[]
When a ray tracing shader executes a dynamic instance of an invocation
repack instruction which results in another ray tracing shader being
invoked, their instructions are related by
<<shader-call-order,shader-call-order>>.

For ray tracing invocations that are
<<shader-call-related,shader-call-related>>:

  * <<memory-model-memory-operation,memory operations>> on
    code:StorageBuffer, code:Image, and code:ShaderRecordBufferKHR storage
    classes can: be synchronized using the
ifdef::VK_KHR_ray_tracing_pipeline[code:ShaderCallKHR]
ifndef::VK_KHR_ray_tracing_pipeline[code:Device or code:QueueFamily]
    scope.

  * the code:CallableDataKHR, code:IncomingCallableDataKHR,
    code:RayPayloadKHR, code:HitAttributeKHR, and code:IncomingRayPayloadKHR
    storage classes are <<memory-model-shader-io,system-synchronized>> and
    no application availability and visibility operations are required.

  * memory operations within a single invocation before and after the
    invocation repack instruction are ordered by
    <<memory-model-program-order,program-order>> and do not require explicit
    synchronzation.
endif::VK_VERSION_1_2,VK_KHR_vulkan_memory_model[]


[[ray-tracing-commands]]
== Ray Tracing Commands

_Ray tracing commands_ provoke work in the ray tracing pipeline.
Ray tracing commands are recorded into a command buffer and when executed by
a queue will produce work that executes according to the currently bound ray
tracing pipeline.
A ray tracing pipeline must: be bound to a command buffer before any ray
tracing commands are recorded in that command buffer.

ifdef::VK_NV_ray_tracing[]

[open,refpage='vkCmdTraceRaysNV',desc='Initialize a ray tracing dispatch',type='protos']
--
:refpage: vkCmdTraceRaysNV

To dispatch ray tracing use:

include::{generated}/api/protos/vkCmdTraceRaysNV.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:raygenShaderBindingTableBuffer is the buffer object that holds the
    shader binding table data for the ray generation shader stage.
  * pname:raygenShaderBindingOffset is the offset in bytes (relative to
    pname:raygenShaderBindingTableBuffer) of the ray generation shader being
    used for the trace.
  * pname:missShaderBindingTableBuffer is the buffer object that holds the
    shader binding table data for the miss shader stage.
  * pname:missShaderBindingOffset is the offset in bytes (relative to
    pname:missShaderBindingTableBuffer) of the miss shader being used for
    the trace.
  * pname:missShaderBindingStride is the size in bytes of each shader
    binding table record in pname:missShaderBindingTableBuffer.
  * pname:hitShaderBindingTableBuffer is the buffer object that holds the
    shader binding table data for the hit shader stages.
  * pname:hitShaderBindingOffset is the offset in bytes (relative to
    pname:hitShaderBindingTableBuffer) of the hit shader group being used
    for the trace.
  * pname:hitShaderBindingStride is the size in bytes of each shader binding
    table record in pname:hitShaderBindingTableBuffer.
  * pname:callableShaderBindingTableBuffer is the buffer object that holds
    the shader binding table data for the callable shader stage.
  * pname:callableShaderBindingOffset is the offset in bytes (relative to
    pname:callableShaderBindingTableBuffer) of the callable shader being
    used for the trace.
  * pname:callableShaderBindingStride is the size in bytes of each shader
    binding table record in pname:callableShaderBindingTableBuffer.
  * pname:width is the width of the ray trace query dimensions.
  * pname:height is height of the ray trace query dimensions.
  * pname:depth is depth of the ray trace query dimensions.

When the command is executed, a ray generation group of [eq]#pname:width
{times} pname:height {times} pname:depth# rays is assembled.

.Valid Usage
****
include::{chapters}/commonvalidity/trace_rays_common.txt[]
  * [[VUID-vkCmdTraceRaysNV-commandBuffer-04624]]
    pname:commandBuffer must: not be a protected command buffer
  * [[VUID-vkCmdTraceRaysNV-maxRecursionDepth-03625]]
    This command must: not cause a trace ray instruction to be executed from
    a shader invocation with a <<ray-tracing-recursion-depth, recursion
    depth>> greater than the value of pname:maxRecursionDepth used to create
    the bound ray tracing pipeline
  * [[VUID-vkCmdTraceRaysNV-raygenShaderBindingTableBuffer-04042]]
    If pname:raygenShaderBindingTableBuffer is non-sparse then it must: be
    bound completely and contiguously to a single sname:VkDeviceMemory
    object
  * [[VUID-vkCmdTraceRaysNV-raygenShaderBindingOffset-02455]]
    pname:raygenShaderBindingOffset must: be less than the size of
    pname:raygenShaderBindingTableBuffer
  * [[VUID-vkCmdTraceRaysNV-raygenShaderBindingOffset-02456]]
    pname:raygenShaderBindingOffset must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupBaseAlignment
  * [[VUID-vkCmdTraceRaysNV-missShaderBindingTableBuffer-04043]]
    If pname:missShaderBindingTableBuffer is non-sparse then it must: be
    bound completely and contiguously to a single sname:VkDeviceMemory
    object
  * [[VUID-vkCmdTraceRaysNV-missShaderBindingOffset-02457]]
    pname:missShaderBindingOffset must: be less than the size of
    pname:missShaderBindingTableBuffer
  * [[VUID-vkCmdTraceRaysNV-missShaderBindingOffset-02458]]
    pname:missShaderBindingOffset must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupBaseAlignment
  * [[VUID-vkCmdTraceRaysNV-hitShaderBindingTableBuffer-04044]]
    If pname:hitShaderBindingTableBuffer is non-sparse then it must: be
    bound completely and contiguously to a single sname:VkDeviceMemory
    object
  * [[VUID-vkCmdTraceRaysNV-hitShaderBindingOffset-02459]]
    pname:hitShaderBindingOffset must: be less than the size of
    pname:hitShaderBindingTableBuffer
  * [[VUID-vkCmdTraceRaysNV-hitShaderBindingOffset-02460]]
    pname:hitShaderBindingOffset must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupBaseAlignment
  * [[VUID-vkCmdTraceRaysNV-callableShaderBindingTableBuffer-04045]]
    If pname:callableShaderBindingTableBuffer is non-sparse then it must: be
    bound completely and contiguously to a single sname:VkDeviceMemory
    object
  * [[VUID-vkCmdTraceRaysNV-callableShaderBindingOffset-02461]]
    pname:callableShaderBindingOffset must: be less than the size of
    pname:callableShaderBindingTableBuffer
  * [[VUID-vkCmdTraceRaysNV-callableShaderBindingOffset-02462]]
    pname:callableShaderBindingOffset must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupBaseAlignment
  * [[VUID-vkCmdTraceRaysNV-missShaderBindingStride-02463]]
    pname:missShaderBindingStride must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupHandleSize
  * [[VUID-vkCmdTraceRaysNV-hitShaderBindingStride-02464]]
    pname:hitShaderBindingStride must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupHandleSize
  * [[VUID-vkCmdTraceRaysNV-callableShaderBindingStride-02465]]
    pname:callableShaderBindingStride must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupHandleSize
  * [[VUID-vkCmdTraceRaysNV-missShaderBindingStride-02466]]
    pname:missShaderBindingStride must: be less than or equal to
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxShaderGroupStride
  * [[VUID-vkCmdTraceRaysNV-hitShaderBindingStride-02467]]
    pname:hitShaderBindingStride must: be less than or equal to
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxShaderGroupStride
  * [[VUID-vkCmdTraceRaysNV-callableShaderBindingStride-02468]]
    pname:callableShaderBindingStride must: be less than or equal to
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxShaderGroupStride
  * [[VUID-vkCmdTraceRaysNV-width-02469]]
    pname:width must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[0]
  * [[VUID-vkCmdTraceRaysNV-height-02470]]
    pname:height must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[1]
  * [[VUID-vkCmdTraceRaysNV-depth-02471]]
    pname:depth must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[2]
****

include::{generated}/validity/protos/vkCmdTraceRaysNV.txt[]
--

endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='vkCmdTraceRaysKHR',desc='Initialize a ray tracing dispatch',type='protos']
--
:refpage: vkCmdTraceRaysKHR

To dispatch ray tracing use:

include::{generated}/api/protos/vkCmdTraceRaysKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pRaygenShaderBindingTable is a
    slink:VkStridedDeviceAddressRegionKHR that holds the shader binding
    table data for the ray generation shader stage.
  * pname:pMissShaderBindingTable is a slink:VkStridedDeviceAddressRegionKHR
    that holds the shader binding table data for the miss shader stage.
  * pname:pHitShaderBindingTable is a slink:VkStridedDeviceAddressRegionKHR
    that holds the shader binding table data for the hit shader stage.
  * pname:pCallableShaderBindingTable is a
    slink:VkStridedDeviceAddressRegionKHR that holds the shader binding
    table data for the callable shader stage.
  * pname:width is the width of the ray trace query dimensions.
  * pname:height is height of the ray trace query dimensions.
  * pname:depth is depth of the ray trace query dimensions.

When the command is executed, a ray generation group of [eq]#pname:width
{times} pname:height {times} pname:depth# rays is assembled.

.Valid Usage
****
include::{chapters}/commonvalidity/trace_rays_common.txt[]
include::{chapters}/commonvalidity/trace_rays_common_khr.txt[]
  * [[VUID-vkCmdTraceRaysKHR-commandBuffer-04625]]
    pname:commandBuffer must: not be a protected command buffer
  * [[VUID-vkCmdTraceRaysKHR-width-03626]]
    pname:width must: be less than or equal to
    [eq]#sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[0]
    {times} sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupSize[0]#
  * [[VUID-vkCmdTraceRaysKHR-height-03627]]
    pname:height must: be less than or equal to
    [eq]#sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[1]
    {times} sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupSize[1]#
  * [[VUID-vkCmdTraceRaysKHR-depth-03628]]
    pname:depth must: be less than or equal to
    [eq]#sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[2]
    {times} sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupSize[2]#
  * [[VUID-vkCmdTraceRaysKHR-width-03629]]
    [eq]#pname:width {times} pname:height {times} pname:depth# must: be less
    than or equal to
    sname:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:maxRayDispatchInvocationCount
****

include::{generated}/validity/protos/vkCmdTraceRaysKHR.txt[]
--

[open,refpage='VkStridedDeviceAddressRegionKHR',desc='Structure specifying a region of device addresses with a stride',type='structs']
--
:refpage: VkStridedDeviceAddressRegionKHR

The sname:VkStridedDeviceAddressRegionKHR structure is defined as:

include::{generated}/api/structs/VkStridedDeviceAddressRegionKHR.txt[]

  * pname:deviceAddress is the device address (as returned by the
    flink:vkGetBufferDeviceAddress command) at which the region starts.
  * pname:stride is the byte stride between consecutive elements.
  * pname:size is the size in bytes of the region starting at
    pname:deviceAddress.

.Valid Usage
****
  * [[VUID-VkStridedDeviceAddressRegionKHR-size-04631]]
    If pname:size is not zero, all addresses between pname:deviceAddress and
    [eq]#pname:deviceAddress {plus} pname:size - 1# must: be in the buffer
    device address range of the same buffer
  * [[VUID-VkStridedDeviceAddressRegionKHR-size-04632]]
    If pname:size is not zero, pname:stride must: be less than the size of
    the buffer from which pname:deviceAddress was queried
****

include::{generated}/validity/structs/VkStridedDeviceAddressRegionKHR.txt[]
--


[open,refpage='vkCmdTraceRaysIndirectKHR',desc='Initialize an indirect ray tracing dispatch',type='protos']
--
:refpage: vkCmdTraceRaysIndirectKHR

To dispatch ray tracing, with some parameters sourced on the device, use:

include::{generated}/api/protos/vkCmdTraceRaysIndirectKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pRaygenShaderBindingTable is a
    slink:VkStridedDeviceAddressRegionKHR that holds the shader binding
    table data for the ray generation shader stage.
  * pname:pMissShaderBindingTable is a slink:VkStridedDeviceAddressRegionKHR
    that holds the shader binding table data for the miss shader stage.
  * pname:pHitShaderBindingTable is a slink:VkStridedDeviceAddressRegionKHR
    that holds the shader binding table data for the hit shader stage.
  * pname:pCallableShaderBindingTable is a
    slink:VkStridedDeviceAddressRegionKHR that holds the shader binding
    table data for the callable shader stage.
  * pname:indirectDeviceAddress is a buffer device address which points to a
    slink:VkTraceRaysIndirectCommandKHR structure which contains the trace
    ray parameters.

fname:vkCmdTraceRaysIndirectKHR behaves similarly to flink:vkCmdTraceRaysKHR
except that the ray trace query dimensions are read by the device from
pname:indirectDeviceAddress during execution.

.Valid Usage
****
include::{chapters}/commonvalidity/trace_rays_common.txt[]
include::{chapters}/commonvalidity/trace_rays_common_khr.txt[]
  * [[VUID-vkCmdTraceRaysIndirectKHR-indirectDeviceAddress-03632]]
    If the buffer from which pname:indirectDeviceAddress was queried is
    non-sparse then it must: be bound completely and contiguously to a
    single sname:VkDeviceMemory object
  * [[VUID-vkCmdTraceRaysIndirectKHR-indirectDeviceAddress-03633]]
    The buffer from which pname:indirectDeviceAddress was queried must: have
    been created with the ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdTraceRaysIndirectKHR-indirectDeviceAddress-03634]]
    pname:indirectDeviceAddress must: be a multiple of `4`
  * [[VUID-vkCmdTraceRaysIndirectKHR-commandBuffer-03635]]
    pname:commandBuffer must: not be a protected command buffer
  * [[VUID-vkCmdTraceRaysIndirectKHR-indirectDeviceAddress-03636]]
    All device addresses between pname:indirectDeviceAddress and
    [eq]#pname:indirectDeviceAddress {plus}
    code:sizeof(sname:VkTraceRaysIndirectCommandKHR) - 1# must: be in the
    buffer device address range of the same buffer
  * [[VUID-vkCmdTraceRaysIndirectKHR-rayTracingPipelineTraceRaysIndirect-03637]]
    the <<features-rayTracingPipelineTraceRaysIndirect,
    sname:VkPhysicalDeviceRayTracingPipelineFeaturesKHR::pname:rayTracingPipelineTraceRaysIndirect>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkCmdTraceRaysIndirectKHR.txt[]
--

[open,refpage='VkTraceRaysIndirectCommandKHR',desc='Structure specifying the parameters of an indirect trace ray command',type='structs']
--
:refpage: VkTraceRaysIndirectCommandKHR

The sname:VkTraceRaysIndirectCommandKHR structure is defined as:

include::{generated}/api/structs/VkTraceRaysIndirectCommandKHR.txt[]

  * pname:width is the width of the ray trace query dimensions.
  * pname:height is height of the ray trace query dimensions.
  * pname:depth is depth of the ray trace query dimensions.

The members of sname:VkTraceRaysIndirectCommandKHR have the same meaning as
the similarly named parameters of flink:vkCmdTraceRaysKHR.

.Valid Usage
****
  * [[VUID-VkTraceRaysIndirectCommandKHR-width-03638]]
    pname:width must: be less than or equal to
    [eq]#sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[0]
    {times} sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupSize[0]#
  * [[VUID-VkTraceRaysIndirectCommandKHR-height-03639]]
    pname:height must: be less than or equal to
    [eq]#sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[1]
    {times} sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupSize[1]#
  * [[VUID-VkTraceRaysIndirectCommandKHR-depth-03640]]
    pname:depth must: be less than or equal to
    [eq]#sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[2]
    {times} sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupSize[2]#
  * [[VUID-VkTraceRaysIndirectCommandKHR-width-03641]]
    [eq]#pname:width {times} pname:height {times} pname:depth# must: be less
    than or equal to
    sname:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:maxRayDispatchInvocationCount
****

include::{generated}/validity/structs/VkTraceRaysIndirectCommandKHR.txt[]
--
endif::VK_KHR_ray_tracing_pipeline[]


[[shader-binding-table]]
== Shader Binding Table

A _shader binding table_ is a resource which establishes the relationship
between the ray tracing pipeline and the acceleration structures that were
built for the ray tracing pipeline.
It indicates the shaders that operate on each geometry in an acceleration
structure.
In addition, it contains the resources accessed by each shader, including
indices of textures, buffer device addresses, and constants.
The application allocates and manages _shader binding tables_ as
slink:VkBuffer objects.

Each entry in the shader binding table consists of
pname:shaderGroupHandleSize bytes of data as queried by
flink:vkGetRayTracingShaderGroupHandlesKHR to refer to the shader that it
invokes.
The remainder of the data specified by the stride is application-visible
data that can be referenced by a code:ShaderRecordBufferKHR block in the
shader.

The shader binding tables to use in a ray tracing pipeline are passed to the
ifdef::VK_NV_ray_tracing[]
flink:vkCmdTraceRaysNV,
endif::VK_NV_ray_tracing[]
flink:vkCmdTraceRaysKHR, or flink:vkCmdTraceRaysIndirectKHR commands.
Shader binding tables are read-only in shaders that are executing on the ray
tracing pipeline.

Shader variables identified with the code:ShaderRecordBufferKHR storage
class are used to access the provided shader binding table.
Such variables must: be:

  * typed as code:OpTypeStruct, or an array of this type,
  * identified with a code:Block decoration, and
  * laid out explicitly using the code:Offset, code:ArrayStride, and
    code:MatrixStride decorations as specified in
    <<interfaces-resources-layout,Offset and Stride Assignment>>.

The code:Offset decoration for any member of a code:Block-decorated variable
in the code:ShaderRecordBufferKHR storage class must: not cause the space
required for that variable to extend outside the range [eq]#[0,
pname:maxStorageBufferRange)#.

Accesses to the shader binding table from ray tracing pipelines must: be
<<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_SHADER_READ_BIT.


[[shader-binding-table-indexing-rules]]
=== Indexing Rules

In order to execute the correct shaders and access the correct resources
during a ray tracing dispatch, the implementation must: be able to locate
shader binding table entries at various stages of execution.
This is accomplished by defining a set of indexing rules that compute shader
binding table record positions relative to the buffer's base address in
memory.
The application must: organize the contents of the shader binding table's
memory in a way that application of the indexing rules will lead to correct
records.


==== Ray Generation Shaders

Only one ray generation shader is executed per ray tracing dispatch.

ifdef::VK_KHR_ray_tracing_pipeline[]
For flink:vkCmdTraceRaysKHR, the location of the ray generation shader is
specified by the pname:pRaygenShaderBindingTable->deviceAddress parameter
-- there is no indexing.
All data accessed must: be less than pname:pRaygenShaderBindingTable->size
bytes from pname:deviceAddress.
pname:pRaygenShaderBindingTable->stride is unused, and must: be equal to
pname:pRaygenShaderBindingTable->size.
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_NV_ray_tracing[]
For flink:vkCmdTraceRaysNV, the location of the ray generation shader is
specified by the pname:raygenShaderBindingTableBuffer and
pname:raygenShaderBindingOffset parameters -- there is no indexing.
endif::VK_NV_ray_tracing[]

[[shader-binding-table-hit-shader-indexing]]
==== Hit Shaders

The base for the computation of intersection, any-hit, and closest hit
shader locations is the code:instanceShaderBindingTableRecordOffset value
stored with each instance of a top-level acceleration structure
(slink:VkAccelerationStructureInstanceKHR).
This value determines the beginning of the shader binding table records for
a given instance.

In the following rule, code:geometryIndex refers to the
<<acceleration-structure-geometry-index, geometry index>> of the intersected
geometry within the instance.

The code:sbtRecordOffset and code:sbtRecordStride values are passed in as
parameters to
ifdef::VK_NV_ray_tracing[code:traceNV()]
ifdef::VK_NV_ray_tracing+VK_KHR_ray_tracing_pipeline[ or ]
ifdef::VK_KHR_ray_tracing_pipeline[code:traceRayEXT()]
calls made in the shaders.
See Section 8.19 (Ray Tracing Functions) of the OpenGL Shading Language
Specification for more details.
In SPIR-V, these correspond to the code:SBTOffset and code:SBTStride
parameters to the
ifdef::VK_NV_ray_tracing[code:OpTraceRayNV]
ifdef::VK_NV_ray_tracing+VK_KHR_ray_tracing_pipeline[ or ]
ifdef::VK_KHR_ray_tracing_pipeline[code:OpTraceRayKHR]
instruction.

The result of this computation is then added to
ifdef::VK_KHR_ray_tracing_pipeline[]
pname:pHitShaderBindingTable->deviceAddress, a device address passed to
flink:vkCmdTraceRaysKHR
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_ray_tracing+VK_KHR_ray_tracing_pipeline[, or ]
ifdef::VK_NV_ray_tracing[]
pname:hitShaderBindingOffset, a base offset passed to flink:vkCmdTraceRaysNV
endif::VK_NV_ray_tracing[]
.

ifdef::VK_KHR_ray_tracing_pipeline[]
For flink:vkCmdTraceRaysKHR, the complete rule to compute a hit shader
binding table record address in the pname:pHitShaderBindingTable is:

  {empty}:: [eq]#pname:pHitShaderBindingTable->deviceAddress {plus}
            pname:pHitShaderBindingTable->stride {times} (
            code:instanceShaderBindingTableRecordOffset {plus}
            code:geometryIndex {times} code:sbtRecordStride {plus}
            code:sbtRecordOffset )#

All data accessed must: be less than pname:pHitShaderBindingTable->size
bytes from the base address.
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_NV_ray_tracing[]
For flink:vkCmdTraceRaysNV, the offset and stride come from direct
parameters, so the full rule to compute a hit shader binding table record
address in the pname:hitShaderBindingTableBuffer is:

  {empty}:: [eq]#pname:hitShaderBindingOffset {plus}
            pname:hitShaderBindingStride {times} (
            code:instanceShaderBindingTableRecordOffset {plus}
            code:geometryIndex {times} code:sbtRecordStride {plus}
            code:sbtRecordOffset )#

endif::VK_NV_ray_tracing[]

==== Miss Shaders

A miss shader is executed whenever a ray query fails to find an intersection
for the given scene geometry.
Multiple miss shaders may: be executed throughout a ray tracing dispatch.

The base for the computation of miss shader locations is
ifdef::VK_KHR_ray_tracing_pipeline[]
pname:pMissShaderBindingTable->deviceAddress, a device address passed into
flink:vkCmdTraceRaysKHR
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_ray_tracing+VK_KHR_ray_tracing_pipeline[, or ]
ifdef::VK_NV_ray_tracing[]
pname:missShaderBindingOffset, a base offset passed into
flink:vkCmdTraceRaysNV
endif::VK_NV_ray_tracing[]
.

The code:missIndex value is passed in as a parameter to
ifdef::VK_NV_ray_tracing[code:traceNV()]
ifdef::VK_NV_ray_tracing+VK_KHR_ray_tracing_pipeline[ or ]
ifdef::VK_KHR_ray_tracing_pipeline[code:traceRayEXT()]
calls made in the shaders.
See Section 8.19 (Ray Tracing Functions) of the OpenGL Shading Language
Specification for more details.
In SPIR-V, this corresponds to the code:MissIndex parameter to the
ifdef::VK_NV_ray_tracing[code:OpTraceRayNV]
ifdef::VK_NV_ray_tracing+VK_KHR_ray_tracing_pipeline[ or ]
ifdef::VK_KHR_ray_tracing_pipeline[code:OpTraceRayKHR]
instruction.

ifdef::VK_KHR_ray_tracing_pipeline[]
For flink:vkCmdTraceRaysKHR, the complete rule to compute a miss shader
binding table record address in the pname:pMissShaderBindingTable is:

  {empty}:: [eq]#pname:pMissShaderBindingTable->deviceAddress {plus}
            pname:pMissShaderBindingTable->stride {times} code:missIndex#

All data accessed must: be less than pname:pMissShaderBindingTable->size
bytes from the base address.
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_NV_ray_tracing[]
For flink:vkCmdTraceRaysNV, the offset and stride come from direct
parameters, so the full rule to compute a miss shader binding table record
address in the pname:missShaderBindingTableBuffer is:

  {empty}:: [eq]#pname:missShaderBindingOffset {plus}
            pname:missShaderBindingStride {times} code:missIndex#

endif::VK_NV_ray_tracing[]


==== Callable Shaders

A callable shader is executed when requested by a ray tracing shader.
Multiple callable shaders may: be executed throughout a ray tracing
dispatch.

The base for the computation of callable shader locations is
ifdef::VK_KHR_ray_tracing_pipeline[]
pname:pCallableShaderBindingTable->deviceAddress, a device address passed
into flink:vkCmdTraceRaysKHR
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_ray_tracing+VK_KHR_ray_tracing_pipeline[, or ]
ifdef::VK_NV_ray_tracing[]
pname:callableShaderBindingOffset, a base offset passed into
flink:vkCmdTraceRaysNV
endif::VK_NV_ray_tracing[]
.

The code:sbtRecordIndex value is passed in as a parameter to
ifdef::VK_NV_ray_tracing[code:executeCallableNV()]
ifdef::VK_NV_ray_tracing+VK_KHR_ray_tracing_pipeline[ or ]
ifdef::VK_KHR_ray_tracing_pipeline[code:executeCallableEXT()]
calls made in the shaders.
See Section 8.19 (Ray Tracing Functions) of the OpenGL Shading Language
Specification for more details.
In SPIR-V, this corresponds to the code:SBTIndex parameter to the
ifdef::VK_NV_ray_tracing[code:OpExecuteCallableNV]
ifdef::VK_NV_ray_tracing+VK_KHR_ray_tracing_pipeline[ or ]
ifdef::VK_KHR_ray_tracing_pipeline[code:OpExecuteCallableKHR]
instruction.

ifdef::VK_KHR_ray_tracing_pipeline[]
For flink:vkCmdTraceRaysKHR, the complete rule to compute a callable shader
binding table record address in the pname:pCallableShaderBindingTable is:

  {empty}:: [eq]#pname:pCallableShaderBindingTable->deviceAddress {plus}
            pname:pCallableShaderBindingTable->stride {times}
            code:sbtRecordIndex#

All data accessed must: be less than pname:pCallableShaderBindingTable->size
bytes from the base address.
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_NV_ray_tracing[]
For flink:vkCmdTraceRaysNV, the offset and stride come from direct
parameters, so the full rule to compute a callable shader binding table
record address in the pname:callableShaderBindingTableBuffer is:

  {empty}:: [eq]#pname:callableShaderBindingOffset {plus}
            pname:callableShaderBindingStride {times} code:sbtRecordIndex#

endif::VK_NV_ray_tracing[]


[[ray-tracing-pipeline-stack]]
== Ray Tracing Pipeline Stack

Ray tracing pipelines have a potentially large set of shaders which may: be
invoked in various call chain combinations to perform ray tracing.
To store parameters for a given shader execution, an implementation may: use
a stack of data in memory.
This stack must: be sized to the sum of the stack sizes of all shaders in
any call chain executed by the application.

If the stack size is not set explicitly, the stack size for a pipeline is:

  {empty}:: [eq]#rayGenStackMax {plus} min(1,
            pname:maxPipelineRayRecursionDepth) {times}
            max(closestHitStackMax, missStackMax, intersectionStackMax
            {plus} anyHitStackMax) {plus} max(0,
            pname:maxPipelineRayRecursionDepth-1) {times}
            max(closestHitStackMax, missStackMax) {plus} 2 {times}
            callableStackMax#

where [eq]#rayGenStackMax#, [eq]#closestHitStackMax#, [eq]#missStackMax#,
[eq]#anyHitStackMax#, [eq]#intersectionStackMax#, and [eq]#callableStackMax#
are the maximum stack values queried by the respective shader stages for any
shaders in any shader groups defined by the pipeline.

This stack size is potentially significant, so an application may: want to
provide a more optimal stack size after pipeline compilation.
The value that the application provides is the maximum value of the sum of
all shaders in a call chain across all possible call chains, taking into
account any application specific knowledge about the properties of the call
chains.

[NOTE]
.Note
====
For example, if an implementation has two types of closest hit and miss
shaders that it can use but that the first level of rays will only use the
first kind (possibly reflection) and the second level will only use the
second kind (occlusion or shadow ray, for example) then the application can
compute the stack size by something similar to:

  {empty}:: [eq]#code:rayGenStack {plus} max(code:closestHit1Stack,
            code:miss1Stack) {plus} max(code:closestHit2Stack,
            code:miss2Stack)#

This is guaranteed to be no larger than the default stack size computation
which assumes that both call levels may be the larger of the two.

====

endif::VK_KHR_ray_tracing_pipeline,VK_NV_ray_tracing[]

ifdef::VK_KHR_acceleration_structure,VK_NV_ray_tracing[]
[[acceleration-structure]]
= Acceleration Structures

[[acceleration-structure-def]]
== Acceleration Structures

_Acceleration structures_ are data structures used by the implementation to
efficiently manage scene geometry as it is <<ray-traversal, traversed during
a ray tracing query>>.
The application is responsible for managing acceleration structure objects
(see <<resources-acceleration-structures,Acceleration Structures>>),
including allocation, destruction, executing builds or updates, and
synchronizing resources used during ray tracing queries.

There are two types of acceleration structures, _top level acceleration
structures_ and _bottom level acceleration structures_.

[[fig-accelstruct]]
image::{images}/accelstruct.svg[align="center",title="Acceleration Structure",opts="{imageopts}"]

.Caption
****
The diagram shows the relationship between top and bottom level acceleration
structures.
****

[[acceleration-structure-geometry]]
=== Geometry

_Geometries_ refer to a triangle or axis-aligned bounding box.

[[acceleration-structure-top-level]]
=== Top Level Acceleration Structures

Opaque acceleration structure for an array of instances.
The descriptor or device address referencing this is the starting point for
traversal.

The top level acceleration structure takes a reference to any bottom level
acceleration structure referenced by its instances.
Those bottom level acceleration structure objects must: be valid when the
top level acceleration structure is accessed.

[[acceleration-structure-bottom-level]]
=== Bottom Level Acceleration Structures

Opaque acceleration structure for an array of geometries.

[[acceleration-structure-update]]
=== Acceleration Structure Update Rules

The API defines two types of operations to produce acceleration structures
from geometry:

  * A _build_ operation is used to construct an acceleration structure.
  * An _update_ operation is used to modify an existing acceleration
    structure.

An update operation imposes certain constraints on the input, in exchange
for considerably faster execution.
When performing an update, the application is required to provide a full
description of the acceleration structure, but is prohibited from changing
anything other than instance definitions, transform matrices, and vertex or
AABB positions.
All other aspects of the description must: exactly match the one from the
original build.

More precisely, the application must: not use an update operation to do any
of the following:

  * Change primitives or instances from _active_ to _inactive_ (as defined
    in <<acceleration-structure-inactive-prims>>).
  * Change the index or vertex formats of triangle geometry.
  * Change triangle geometry transform pointers from null to non-null or
    vice versa.
  * Change the number of geometries or instances in the structure.
  * Change the geometry flags for any geometry in the structure.
  * Change the number of vertices or primitives for any geometry in the
    structure.

[[acceleration-structure-inactive-prims]]
=== Inactive Primitives and Instances

Acceleration structures allow the use of particular input values to signal
_inactive_ primitives or instances.

An _inactive_ triangle is one for which the first (X) component of each
vertex is NaN.
If any other vertex component is NaN, and the first is not, the behavior is
undefined:.
If the vertex format does not have a NaN representation, then all triangles
are considered active.

An _inactive_ instance is one whose acceleration structure handle is
dlink:VK_NULL_HANDLE.

An _inactive_ AABB is one for which the minimum X coordinate is NaN.
If any other component is NaN, and the first is not, the behavior is
undefined:.

In the above definitions, "NaN" refers to any type of NaN.
Signaling, non-signaling, quiet, loud, or otherwise.

An inactive object is considered invisible to all rays, and should: not be
represented in the acceleration structure.
Implementations should: ensure that the presence of inactive objects does
not seriously degrade traversal performance.

Inactive objects are counted in the auto-generated index sequences which are
provided to shaders via code:InstanceId and code:PrimitiveId SPIR-V
decorations.
This allows objects in the scene to change freely between the active and
inactive states, without affecting the layout of any arrays which are being
indexed using the ID values.

Any transition between the active and inactive states requires a full
acceleration structure rebuild.
Applications must: not perform an acceleration structure update where an
object is active in the source acceleration structure but would be inactive
in the destination, or vice versa.

[[acceleration-structure-building]]
=== Building Acceleration Structures

ifdef::VK_NV_ray_tracing[]
[open,refpage='vkCmdBuildAccelerationStructureNV',desc='Build an acceleration structure',type='protos']
--
:refpage: vkCmdBuildAccelerationStructureNV

To build an acceleration structure call:

include::{generated}/api/protos/vkCmdBuildAccelerationStructureNV.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pInfo contains the shared information for the acceleration
    structure's structure.
  * pname:instanceData is the buffer containing an array of
    slink:VkAccelerationStructureInstanceKHR structures defining
    acceleration structures.
    This parameter must: be `NULL` for bottom level acceleration structures.
  * pname:instanceOffset is the offset in bytes (relative to the start of
    pname:instanceData) at which the instance data is located.
  * pname:update specifies whether to update the pname:dst acceleration
    structure with the data in pname:src.
  * pname:dst is a pointer to the target acceleration structure for the
    build.
  * pname:src is a pointer to an existing acceleration structure that is to
    be used to update the pname:dst acceleration structure.
  * pname:scratch is the slink:VkBuffer that will be used as scratch memory
    for the build.
  * pname:scratchOffset is the offset in bytes relative to the start of
    pname:scratch that will be used as a scratch memory.

Accesses to pname:dst, pname:src, and pname:scratch must: be
<<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR or
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR.

.Valid Usage
****
  * [[VUID-vkCmdBuildAccelerationStructureNV-geometryCount-02241]]
    pname:geometryCount must: be less than or equal to
    slink:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxGeometryCount
  * [[VUID-vkCmdBuildAccelerationStructureNV-dst-02488]]
    pname:dst must: have been created with compatible
    slink:VkAccelerationStructureInfoNV where
    slink:VkAccelerationStructureInfoNV::pname:type and
    slink:VkAccelerationStructureInfoNV::pname:flags are identical,
    slink:VkAccelerationStructureInfoNV::pname:instanceCount and
    slink:VkAccelerationStructureInfoNV::pname:geometryCount for pname:dst
    are greater than or equal to the build size and each geometry in
    slink:VkAccelerationStructureInfoNV::pname:pGeometries for pname:dst has
    greater than or equal to the number of vertices, indices, and AABBs
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-02489]]
    If pname:update is ename:VK_TRUE, pname:src must: not be
    dlink:VK_NULL_HANDLE
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-02490]]
    If pname:update is ename:VK_TRUE, pname:src must: have been built before
    with ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV set in
    slink:VkAccelerationStructureInfoNV::pname:flags
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-02491]]
    If pname:update is ename:VK_FALSE, the pname:size member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetAccelerationStructureMemoryRequirementsNV with
    slink:VkAccelerationStructureMemoryRequirementsInfoNV::pname:accelerationStructure
    set to pname:dst and
    slink:VkAccelerationStructureMemoryRequirementsInfoNV::pname:type set to
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV
    must: be less than or equal to the size of pname:scratch minus
    pname:scratchOffset
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-02492]]
    If pname:update is ename:VK_TRUE, the pname:size member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetAccelerationStructureMemoryRequirementsNV with
    slink:VkAccelerationStructureMemoryRequirementsInfoNV::pname:accelerationStructure
    set to pname:dst and
    slink:VkAccelerationStructureMemoryRequirementsInfoNV::pname:type set to
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV
    must: be less than or equal to the size of pname:scratch minus
    pname:scratchOffset
  * [[VUID-vkCmdBuildAccelerationStructureNV-scratch-03522]]
    pname:scratch must: have been created with
    ename:VK_BUFFER_USAGE_RAY_TRACING_BIT_NV usage flag
  * [[VUID-vkCmdBuildAccelerationStructureNV-instanceData-03523]]
    If pname:instanceData is not dlink:VK_NULL_HANDLE, pname:instanceData
    must: have been created with ename:VK_BUFFER_USAGE_RAY_TRACING_BIT_NV
    usage flag
  * [[VUID-vkCmdBuildAccelerationStructureNV-accelerationStructureReference-03786]]
    Each
    slink:VkAccelerationStructureInstanceKHR::pname:accelerationStructureReference
    value in pname:instanceData must: be a valid device address containing a
    value obtained from flink:vkGetAccelerationStructureHandleNV
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-03524]]
    If pname:update is ename:VK_TRUE, then objects that were previously
    active must: not be made inactive as per
    <<acceleration-structure-inactive-prims>>
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-03525]]
    If pname:update is ename:VK_TRUE, then objects that were previously
    inactive must: not be made active as per
    <<acceleration-structure-inactive-prims>>
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-03526]]
    If pname:update is ename:VK_TRUE, the pname:src and pname:dst objects
    must: either be the same object or not have any
    <<resources-memory-aliasing, memory aliasing>>

****

include::{generated}/validity/protos/vkCmdBuildAccelerationStructureNV.txt[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='vkCmdBuildAccelerationStructuresKHR',desc='Build an acceleration structure',type='protos']
--
:refpage: vkCmdBuildAccelerationStructuresKHR
:maxinstancecheck: pname:ppBuildRangeInfos[i][j].pname:primitiveCount

To build acceleration structures call:

include::{generated}/api/protos/vkCmdBuildAccelerationStructuresKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:infoCount is the number of acceleration structures to build.
    It specifies the number of the pname:pInfos structures and
    pname:ppBuildRangeInfos pointers that must: be provided.
  * pname:pInfos is an array of pname:infoCount
    slink:VkAccelerationStructureBuildGeometryInfoKHR structures defining
    the geometry used to build each acceleration structure.
  * pname:ppBuildRangeInfos is an array of pname:infoCount pointers to
    arrays of slink:VkAccelerationStructureBuildRangeInfoKHR structures.
    Each pname:ppBuildRangeInfos[i] is an array of
    pname:pInfos[i].pname:geometryCount
    slink:VkAccelerationStructureBuildRangeInfoKHR structures defining
    dynamic offsets to the addresses where geometry data is stored, as
    defined by pname:pInfos[i].

The fname:vkCmdBuildAccelerationStructuresKHR command provides the ability
to initiate multiple acceleration structures builds, however there is no
ordering or synchronization implied between any of the individual
acceleration structure builds.

[NOTE]
.Note
====
This means that an application cannot: build a top-level acceleration
structure in the same flink:vkCmdBuildAccelerationStructuresKHR call as the
associated bottom-level or instance acceleration structures are being built.
There also cannot: be any memory aliasing between any acceleration structure
memories or scratch memories being used by any of the builds.
====

[[acceleration-structure-scratch]]
Accesses to the acceleration structure scratch buffers as identified by the
slink:VkAccelerationStructureBuildGeometryInfoKHR->pname:scratchData buffer
device addresses must: be <<synchronization-dependencies,synchronized>> with
the ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR or
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR.
Similarly for accesses to each
slink:VkAccelerationStructureBuildGeometryInfoKHR->pname:srcAccelerationStructure
and
slink:VkAccelerationStructureBuildGeometryInfoKHR->pname:dstAccelerationStructure.

Accesses to other input buffers as identified by any used values of
slink:VkAccelerationStructureGeometryTrianglesDataKHR->pname:vertexData,
slink:VkAccelerationStructureGeometryTrianglesDataKHR->pname:indexData,
slink:VkAccelerationStructureGeometryTrianglesDataKHR->pname:transformData,
slink:VkAccelerationStructureGeometryAabbsDataKHR->pname:data, and
slink:VkAccelerationStructureGeometryInstancesDataKHR->pname:data must: be
<<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_SHADER_READ_BIT.


.Valid Usage
****
include::{chapters}/commonvalidity/build_acceleration_structure_common.txt[]
include::{chapters}/commonvalidity/build_acceleration_structure_device_common.txt[]
include::{chapters}/commonvalidity/build_acceleration_structure_nonindirect_common.txt[]
****

include::{generated}/validity/protos/vkCmdBuildAccelerationStructuresKHR.txt[]
--

[open,refpage='vkCmdBuildAccelerationStructuresIndirectKHR',desc='Build an acceleration structure with some parameters provided on the device',type='protos']
--
:refpage: vkCmdBuildAccelerationStructuresIndirectKHR
:maxinstancecheck: pname:ppMaxPrimitiveCounts[i][j]

To build acceleration structures with some parameters sourced on the device
call:

include::{generated}/api/protos/vkCmdBuildAccelerationStructuresIndirectKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:infoCount is the number of acceleration structures to build.
  * pname:pInfos is an array of pname:infoCount
    slink:VkAccelerationStructureBuildGeometryInfoKHR structures defining
    the geometry used to build each acceleration structure.
  * pname:pIndirectDeviceAddresses is an array of pname:infoCount buffer
    device addresses which point to pname:pInfos[i]->pname:geometryCount
    slink:VkAccelerationStructureBuildRangeInfoKHR structures defining
    dynamic offsets to the addresses where geometry data is stored, as
    defined by pname:pInfos[i].
  * pname:pIndirectStrides is an array of pname:infoCount byte strides
    between elements of pname:pIndirectDeviceAddresses.
  * pname:ppMaxPrimitiveCounts is an array of pname:infoCount arrays of
    pname:pInfo[i]->pname:geometryCount values indicating the maximum number
    of primitives that will be built by this command for each geometry.

Accesses to acceleration structures, scratch buffers, vertex buffers, index
buffers, and instance buffers must be synchronized as with
<<acceleration-structure-scratch,vkCmdBuildAccelerationStructuresKHR>>.

Accesses to any element of pname:pIndirectDeviceAddresses must: be
<<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT.


.Valid Usage
****
include::{chapters}/commonvalidity/build_acceleration_structure_common.txt[]
include::{chapters}/commonvalidity/build_acceleration_structure_device_common.txt[]
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03645]]
    For any element of pname:pIndirectDeviceAddresses, if the buffer from
    which it was queried is non-sparse then it must: be bound completely and
    contiguously to a single slink:VkDeviceMemory object
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03646]]
    For any element of pname:pIndirectDeviceAddresses[i], all device
    addresses between pname:pIndirectDeviceAddresses[i] and
    [eq]#pname:pIndirectDeviceAddresses[i] {plus}
    (pname:pInfos[i]->geometryCount {times} pname:pIndirectStrides[i]) - 1#
    must: be in the buffer device address range of the same buffer
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03647]]
    For any element of pname:pIndirectDeviceAddresses, the buffer from which
    it was queried must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03648]]
    Each element of pname:pIndirectDeviceAddresses must: be a multiple of
    `4`
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectStrides-03787]]
    Each element of pname:pIndirectStrides must: be a multiple of `4`
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-commandBuffer-03649]]
    pname:commandBuffer must: not be a protected command buffer
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-accelerationStructureIndirectBuild-03650]]
    The <<features-accelerationStructureIndirectBuild,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructureIndirectBuild>>
    feature must: be enabled
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03651]]
    Each slink:VkAccelerationStructureBuildRangeInfoKHR structure referenced
    by any element of pname:pIndirectDeviceAddresses must: be a valid
    slink:VkAccelerationStructureBuildRangeInfoKHR structure
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03652]]
    pname:pInfos[i].pname:dstAccelerationStructure must: have been created
    with a value of slink:VkAccelerationStructureCreateInfoKHR::pname:size
    greater than or equal to the memory size required by the build
    operation, as returned by flink:vkGetAccelerationStructureBuildSizesKHR
    with [eq]#pname:pBuildInfo = pname:pInfos[i]# and
    [eq]#pname:pMaxPrimitiveCounts = pname:ppMaxPrimitiveCounts[i]#
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-ppMaxPrimitiveCounts-03653]]
    Each pname:ppMaxPrimitiveCounts[i][j] must: be greater than or equal to
    the the pname:primitiveCount value specified by the
    slink:VkAccelerationStructureBuildRangeInfoKHR structure located at
    [eq]#pname:pIndirectDeviceAddresses[i] {plus} (code:j {times}
    pname:pIndirectStrides[i])#
****

include::{generated}/validity/protos/vkCmdBuildAccelerationStructuresIndirectKHR.txt[]
--


[open,refpage='VkAccelerationStructureBuildGeometryInfoKHR',desc='Structure specifying the geometry data used to build an acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureBuildGeometryInfoKHR

The sname:VkAccelerationStructureBuildGeometryInfoKHR structure is defined
as:

include::{generated}/api/structs/VkAccelerationStructureBuildGeometryInfoKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:type is a elink:VkAccelerationStructureTypeKHR value specifying
    the type of acceleration structure being built.
  * pname:flags is a bitmask of
    elink:VkBuildAccelerationStructureFlagBitsKHR specifying additional
    parameters of the acceleration structure.
  * pname:mode is a elink:VkBuildAccelerationStructureModeKHR value
    specifying the type of operation to perform.
  * pname:srcAccelerationStructure points to an existing acceleration
    structure that is to be used to update the pname:dst acceleration
    structure when pname:mode is
    ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR.
  * pname:dstAccelerationStructure points to the target acceleration
    structure for the build.
  * pname:geometryCount specifies the number of geometries that will be
    built into pname:dstAccelerationStructure.
  * pname:pGeometries is a pointer to an array of
    slink:VkAccelerationStructureGeometryKHR structures.
  * pname:ppGeometries is a pointer to an array of pointers to
    slink:VkAccelerationStructureGeometryKHR structures.
  * pname:scratchData is the device or host address to memory that will be
    used as scratch memory for the build.

Only one of pname:pGeometries or pname:ppGeometries can: be a valid pointer,
the other must: be `NULL`.
Each element of the non-`NULL` array describes the data used to build each
acceleration structure geometry.

ifdef::VK_KHR_ray_tracing_pipeline,VK_KHR_ray_query[]
[[acceleration-structure-geometry-index]]
The index of each element of the pname:pGeometries or pname:ppGeometries
members of slink:VkAccelerationStructureBuildGeometryInfoKHR is used as the
_geometry index_ during ray traversal.
ifdef::VK_KHR_ray_tracing_pipeline[]
The geometry index is available in ray shaders via the
<<interfaces-builtin-variables-raygeometryindex,code:RayGeometryIndexKHR
built-in>>, and is <<shader-binding-table-hit-shader-indexing, used to
determine hit and intersection shaders executed during traversal>>.
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_KHR_ray_query[]
The geometry index is available to ray queries via the
code:OpRayQueryGetIntersectionGeometryIndexKHR instruction.
endif::VK_KHR_ray_query[]
endif::VK_KHR_ray_tracing_pipeline,VK_KHR_ray_query[]

.Valid Usage
****
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03654]]
    pname:type must: not be ename:VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-03788]]
    Only one of pname:pGeometries or pname:ppGeometries can: be a valid
    pointer, the other must: be `NULL`
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03789]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, the
    pname:geometryType member of elements of either pname:pGeometries or
    pname:ppGeometries must: be ename:VK_GEOMETRY_TYPE_INSTANCES_KHR
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03790]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
    pname:geometryCount must: be `1`
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03791]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
    the pname:geometryType member of elements of either pname:pGeometries or
    pname:ppGeometries must: not be ename:VK_GEOMETRY_TYPE_INSTANCES_KHR
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03792]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
    then the pname:geometryType member of each geometry in either
    pname:pGeometries or pname:ppGeometries must: be the same
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03793]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
    then pname:geometryCount must: be less than or equal to
    slink:VkPhysicalDeviceAccelerationStructurePropertiesKHR::pname:maxGeometryCount
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03794]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
    and the pname:geometryType member of either pname:pGeometries or
    pname:ppGeometries is ename:VK_GEOMETRY_TYPE_AABBS_KHR, the total number
    of AABBs in all geometries must: be less than or equal to
    slink:VkPhysicalDeviceAccelerationStructurePropertiesKHR::pname:maxPrimitiveCount
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03795]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
    and the pname:geometryType member of either pname:pGeometries or
    pname:ppGeometries is ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, the total
    number of triangles in all geometries must: be less than or equal to
    slink:VkPhysicalDeviceAccelerationStructurePropertiesKHR::pname:maxPrimitiveCount
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-03796]]
    If pname:flags has the
    ename:VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR bit set,
    then it must: not have the
    ename:VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR bit set
****
include::{generated}/validity/structs/VkAccelerationStructureBuildGeometryInfoKHR.txt[]
--

[open,refpage='VkBuildAccelerationStructureModeKHR',desc='Enum specifying the type of build operation to perform',type='enums']
--
:refpage: VkBuildAccelerationStructureModeKHR

The ename:VkBuildAccelerationStructureModeKHR enumeration is defined as:

include::{generated}/api/enums/VkBuildAccelerationStructureModeKHR.txt[]

  * ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR specifies that the
    destination acceleration structure will be built using the specified
    geometries.
  * ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR specifies that the
    destination acceleration structure will be built using data in a source
    acceleration structure, updated by the specified geometries.
--

[open,refpage='VkDeviceOrHostAddressKHR',desc='Union specifying a device or host address',type='structs']
--
:refpage: VkDeviceOrHostAddressKHR

The sname:VkDeviceOrHostAddressKHR union is defined as:

include::{generated}/api/structs/VkDeviceOrHostAddressKHR.txt[]

  * pname:deviceAddress is a buffer device address as returned by the
    flink:vkGetBufferDeviceAddressKHR command.
  * pname:hostAddress is a host memory address.

include::{generated}/validity/structs/VkDeviceOrHostAddressKHR.txt[]
--

[open,refpage='VkDeviceOrHostAddressConstKHR',desc='Union specifying a const device or host address',type='structs']
--
:refpage: VkDeviceOrHostAddressConstKHR

The sname:VkDeviceOrHostAddressConstKHR union is defined as:

include::{generated}/api/structs/VkDeviceOrHostAddressConstKHR.txt[]

  * pname:deviceAddress is a buffer device address as returned by the
    flink:vkGetBufferDeviceAddressKHR command.
  * pname:hostAddress is a const host memory address.

include::{generated}/validity/structs/VkDeviceOrHostAddressConstKHR.txt[]
--

[open,refpage='VkAccelerationStructureGeometryKHR',desc='Structure specifying geometries to be built into an acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureGeometryKHR

The sname:VkAccelerationStructureGeometryKHR structure is defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:geometryType describes which type of geometry this
    sname:VkAccelerationStructureGeometryKHR refers to.
  * pname:geometry is a slink:VkAccelerationStructureGeometryDataKHR union
    describing the geometry data for the relevant geometry type.
  * pname:flags is a bitmask of elink:VkGeometryFlagBitsKHR values
    describing additional properties of how the geometry should be built.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureGeometryKHR-geometryType-03541]]
    If pname:geometryType is ename:VK_GEOMETRY_TYPE_AABBS_KHR, the
    pname:aabbs member of pname:geometry must: be a valid
    slink:VkAccelerationStructureGeometryAabbsDataKHR structure
  * [[VUID-VkAccelerationStructureGeometryKHR-geometryType-03542]]
    If pname:geometryType is ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, the
    pname:triangles member of pname:geometry must: be a valid
    slink:VkAccelerationStructureGeometryTrianglesDataKHR structure
  * [[VUID-VkAccelerationStructureGeometryKHR-geometryType-03543]]
    If pname:geometryType is ename:VK_GEOMETRY_TYPE_INSTANCES_KHR, the
    pname:instances member of pname:geometry must: be a valid
    slink:VkAccelerationStructureGeometryInstancesDataKHR structure
****

include::{generated}/validity/structs/VkAccelerationStructureGeometryKHR.txt[]
--

[open,refpage='VkAccelerationStructureGeometryDataKHR',desc='Union specifying acceleration structure geometry data',type='structs']
--
:refpage: VkAccelerationStructureGeometryDataKHR

The sname:VkAccelerationStructureGeometryDataKHR union is defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryDataKHR.txt[]

  * pname:triangles is a
    slink:VkAccelerationStructureGeometryTrianglesDataKHR structure.
  * pname:aabbs is a slink:VkAccelerationStructureGeometryAabbsDataKHR
    struture.
  * pname:instances is a
    slink:VkAccelerationStructureGeometryInstancesDataKHR structure.

include::{generated}/validity/structs/VkAccelerationStructureGeometryDataKHR.txt[]
--

[open,refpage='VkAccelerationStructureGeometryTrianglesDataKHR',desc='Structure specifying a triangle geometry in a bottom-level acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureGeometryTrianglesDataKHR

The sname:VkAccelerationStructureGeometryTrianglesDataKHR structure is
defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryTrianglesDataKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:vertexFormat is the elink:VkFormat of each vertex element.
  * pname:vertexData is a device or host address to memory containing vertex
    data for this geometry.
  * pname:maxVertex is the highest index of a vertex that will be addressed
    by a build command using this structure.
  * pname:vertexStride is the stride in bytes between each vertex.
  * pname:indexType is the elink:VkIndexType of each index element.
  * pname:indexData is a device or host address to memory containing index
    data for this geometry.
  * pname:transformData is a device or host address to memory containing an
    optional reference to a slink:VkTransformMatrixKHR structure defining a
    transformation that should be applied to vertices in this geometry.

[NOTE]
.Note
====
Unlike the stride for vertex buffers in
slink:VkVertexInputBindingDescription for graphics pipelines which must not
exceed pname:maxVertexInputBindingStride, pname:vertexStride for
acceleration structure geometry is instead restricted to being a 32-bit
value.
====

.Valid Usage
****
  * [[VUID-VkAccelerationStructureGeometryTrianglesDataKHR-maxVertex-03655]]
    pname:maxVertex must: be greater than `0`
  * [[VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexStride-03735]]
    pname:vertexStride must: be a multiple of the size in bytes of the
    smallest component of pname:vertexFormat
  * [[VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexStride-03819]]
    pname:vertexStride must: be less than or equal to [eq]#2^32^-1#
  * [[VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexFormat-03797]]
    pname:vertexFormat must: support the
    ename:VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR in
    slink:VkFormatProperties::pname:bufferFeatures as returned by
    flink:vkGetPhysicalDeviceFormatProperties2
  * [[VUID-VkAccelerationStructureGeometryTrianglesDataKHR-indexType-03798]]
    pname:indexType must: be ename:VK_INDEX_TYPE_UINT16,
    ename:VK_INDEX_TYPE_UINT32, or ename:VK_INDEX_TYPE_NONE_KHR
****

include::{generated}/validity/structs/VkAccelerationStructureGeometryTrianglesDataKHR.txt[]
--
endif::VK_KHR_acceleration_structure[]

[open,refpage='VkTransformMatrixKHR',desc='Structure specifying a 3x4 affine transformation matrix',type='structs',alias='VkTransformMatrixNV']
--
:refpage: VkTransformMatrixKHR

The sname:VkTransformMatrixKHR structure is defined as:

include::{generated}/api/structs/VkTransformMatrixKHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/structs/VkTransformMatrixNV.txt[]
endif::VK_NV_ray_tracing[]

  * pname:matrix is a 3x4 row-major affine transformation matrix.

include::{generated}/validity/structs/VkTransformMatrixKHR.txt[]

.Valid Usage
****
  * [[VUID-VkTransformMatrixKHR-matrix-03799]]
    The first three columns of pname:matrix must: define an invertible 3x3
    matrix
****
--

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='VkAccelerationStructureGeometryAabbsDataKHR',desc='Structure specifying axis-aligned bounding box geometry in a bottom-level acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureGeometryAabbsDataKHR

The sname:VkAccelerationStructureGeometryAabbsDataKHR structure is defined
as:

include::{generated}/api/structs/VkAccelerationStructureGeometryAabbsDataKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:data is a device or host address to memory containing
    slink:VkAabbPositionsKHR structures containing position data for each
    axis-aligned bounding box in the geometry.
  * pname:stride is the stride in bytes between each entry in pname:data.
    The stride must: be a multiple of `8`.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureGeometryAabbsDataKHR-stride-03545]]
    pname:stride must: be a multiple of `8`
  * [[VUID-VkAccelerationStructureGeometryAabbsDataKHR-stride-03820]]
    pname:stride must: be less than or equal to [eq]#2^32^-1#
****

include::{generated}/validity/structs/VkAccelerationStructureGeometryAabbsDataKHR.txt[]
--
endif::VK_KHR_acceleration_structure[]

[open,refpage='VkAabbPositionsKHR',desc='Structure specifying two opposing corners of an axis-aligned bounding box',type='structs',alias='VkAabbPositionsNV']
--
:refpage: VkAabbPositionsKHR

The VkAabbPositionsKHR structure is defined as:

include::{generated}/api/structs/VkAabbPositionsKHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/structs/VkAabbPositionsNV.txt[]
endif::VK_NV_ray_tracing[]


  * pname:minX is the x position of one opposing corner of a bounding box.
  * pname:minY is the y position of one opposing corner of a bounding box.
  * pname:minZ is the z position of one opposing corner of a bounding box.
  * pname:maxX is the x position of the other opposing corner of a bounding
    box.
  * pname:maxY is the y position of the other opposing corner of a bounding
    box.
  * pname:maxZ is the z position of the other opposing corner of a bounding
    box.

.Valid Usage
****
  * [[VUID-VkAabbPositionsKHR-minX-03546]]
    pname:minX must: be less than or equal to pname:maxX
  * [[VUID-VkAabbPositionsKHR-minY-03547]]
    pname:minY must: be less than or equal to pname:maxY
  * [[VUID-VkAabbPositionsKHR-minZ-03548]]
    pname:minZ must: be less than or equal to pname:maxZ
****

include::{generated}/validity/structs/VkAabbPositionsKHR.txt[]
--

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='VkAccelerationStructureGeometryInstancesDataKHR',desc='Structure specifying a geometry consisting of instances of other acceleration structures',type='structs']
--
:refpage: VkAccelerationStructureGeometryInstancesDataKHR

The sname:VkAccelerationStructureGeometryInstancesDataKHR structure is
defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryInstancesDataKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:arrayOfPointers specifies whether pname:data is used as an array
    of addresses or just an array.
  * pname:data is either the address of an array of device or host addresses
    referencing individual slink:VkAccelerationStructureInstanceKHR
    structures if pname:arrayOfPointers is ename:VK_TRUE, or the address of
    an array of slink:VkAccelerationStructureInstanceKHR structures.

include::{generated}/validity/structs/VkAccelerationStructureGeometryInstancesDataKHR.txt[]
--
endif::VK_KHR_acceleration_structure[]

[open,refpage='VkAccelerationStructureInstanceKHR',desc='Structure specifying a single acceleration structure instance for building into an acceleration structure geometry',type='structs',alias='VkAccelerationStructureInstanceNV']
--
:refpage: VkAccelerationStructureInstanceKHR

_Acceleration structure instances_ can: be built into top-level acceleration
structures.
Each acceleration structure instance is a separate entry in the top-level
acceleration structure which includes all the geometry of a bottom-level
acceleration structure at a transformed location.
Multiple instances can: point to the same bottom level acceleration
structure.

An acceleration structure instance is defined by the structure:

include::{generated}/api/structs/VkAccelerationStructureInstanceKHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/structs/VkAccelerationStructureInstanceNV.txt[]
endif::VK_NV_ray_tracing[]

  * pname:transform is a slink:VkTransformMatrixKHR structure describing a
    transformation to be applied to the acceleration structure.
  * pname:instanceCustomIndex is a 24-bit user-specified index value
    accessible to ray shaders in the code:InstanceCustomIndexKHR built-in.
  * pname:mask is an 8-bit visibility mask for the geometry.
    The instance may: only be hit if `rayMask & instance.mask != 0`
  * pname:instanceShaderBindingTableRecordOffset is a 24-bit offset used in
    calculating the hit shader binding table index.
  * pname:flags is an 8-bit mask of elink:VkGeometryInstanceFlagBitsKHR
    values to apply to this instance.
  * pname:accelerationStructureReference is either:
  ** a device address containing the value obtained from
ifdef::VK_KHR_acceleration_structure[flink:vkGetAccelerationStructureDeviceAddressKHR]
ifdef::VK_KHR_acceleration_structure+VK_NV_ray_tracing[or]
ifdef::VK_NV_ray_tracing[flink:vkGetAccelerationStructureHandleNV]
     (used by device operations which reference acceleration structures) or,
  ** a slink:VkAccelerationStructureKHR object (used by host operations
     which reference acceleration structures).

The C language spec does not define the ordering of bit-fields, but in
practice, this struct produces the correct layout with existing compilers.
The intended bit pattern is for the following:

  * pname:instanceCustomIndex and pname:mask occupy the same memory as if a
    single code:int32_t was specified in their place
  ** pname:instanceCustomIndex occupies the 24 least significant bits of
     that memory
  ** pname:mask occupies the 8 most significant bits of that memory
  * pname:instanceShaderBindingTableRecordOffset and pname:flags occupy the
    same memory as if a single code:int32_t was specified in their place
  ** pname:instanceShaderBindingTableRecordOffset occupies the 24 least
     significant bits of that memory
  ** pname:flags occupies the 8 most significant bits of that memory

If a compiler produces code that diverges from that pattern, applications
must: employ another method to set values according to the correct bit
pattern.

include::{generated}/validity/structs/VkAccelerationStructureInstanceKHR.txt[]
--

[open,refpage='VkGeometryInstanceFlagBitsKHR',desc='Instance flag bits',type='enums',alias='VkGeometryInstanceFlagBitsNV']
--
:refpage: VkGeometryInstanceFlagBitsKHR

Possible values of pname:flags in the instance modifying the behavior of
that instance are:

include::{generated}/api/enums/VkGeometryInstanceFlagBitsKHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/enums/VkGeometryInstanceFlagBitsNV.txt[]
endif::VK_NV_ray_tracing[]

  * ename:VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR disables
    face culling for this instance.
  * ename:VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR
    indicates that the front face of the triangle for culling purposes is
    the face that is counter clockwise in object space relative to the ray
    origin.
    Because the facing is determined in object space, an instance transform
    matrix does not change the winding, but a geometry transform does.
  * ename:VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR causes this instance to
    act as though ename:VK_GEOMETRY_OPAQUE_BIT_KHR were specified on all
    geometries referenced by this instance.
    This behavior can: be overridden by the SPIR-V code:NoOpaqueKHR ray
    flag.
  * ename:VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR causes this instance
    to act as though ename:VK_GEOMETRY_OPAQUE_BIT_KHR were not specified on
    all geometries referenced by this instance.
    This behavior can: be overridden by the SPIR-V code:OpaqueKHR ray flag.

ename:VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR and
ename:VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR must: not be used in the
same flag.

--

[open,refpage='VkGeometryInstanceFlagsKHR',desc='Bitmask of VkGeometryInstanceFlagBitsKHR',type='flags',alias='VkGeometryInstanceFlagsNV']
--
:refpage: VkGeometryInstanceFlagsKHR

include::{generated}/api/flags/VkGeometryInstanceFlagsKHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/flags/VkGeometryInstanceFlagsNV.txt[]
endif::VK_NV_ray_tracing[]

tname:VkGeometryInstanceFlagsKHR is a bitmask type for setting a mask of
zero or more elink:VkGeometryInstanceFlagBitsKHR.
--

ifdef::VK_KHR_acceleration_structure[]

[open,refpage='VkAccelerationStructureBuildRangeInfoKHR',desc='Structure specifying build offsets and counts for acceleration structure builds',type='structs']
--
:refpage: VkAccelerationStructureBuildOffsetInfoKHR

sname:VkAccelerationStructureBuildRangeInfoKHR is defined as:

include::{generated}/api/structs/VkAccelerationStructureBuildRangeInfoKHR.txt[]

  * pname:primitiveCount defines the number of primitives for a
    corresponding acceleration structure geometry.
  * pname:primitiveOffset defines an offset in bytes into the memory where
    primitive data is defined.
  * pname:firstVertex is the index of the first vertex to build from for
    triangle geometry.
  * pname:transformOffset defines an offset in bytes into the memory where a
    transform matrix is defined.

The primitive count and primitive offset are interpreted differently
depending on the elink:VkGeometryTypeKHR used:

  * For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR,
    pname:primitiveCount is the number of triangles to be built, where each
    triangle is treated as 3 vertices.
  ** If the geometry uses indices, [eq]#pname:primitiveCount {times} 3#
     indices are consumed from
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:indexData,
     starting at an offset of pname:primitiveOffset.
     The value of pname:firstVertex is added to the index values before
     fetching vertices.
  ** If the geometry does not use indices, [eq]#pname:primitiveCount {times}
     3# vertices are consumed from
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexData,
     starting at an offset of [eq]#pname:primitiveOffset {plus}
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexStride
     {times} pname:firstVertex#.
  ** A single slink:VkTransformMatrixKHR structure is consumed from
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:transformData,
     at an offset of pname:transformOffset.
     This transformation matrix is used by all triangles.

  * For geometries of type ename:VK_GEOMETRY_TYPE_AABBS_KHR,
    pname:primitiveCount is the number of axis-aligned bounding boxes.
    pname:primitiveCount slink:VkAabbPositionsKHR structures are consumed
    from slink:VkAccelerationStructureGeometryAabbsDataKHR::pname:data,
    starting at an offset of pname:primitiveOffset.
  * For geometries of type ename:VK_GEOMETRY_TYPE_INSTANCES_KHR,
    pname:primitiveCount is the number of acceleration structures.
    pname:primitiveCount slink:VkAccelerationStructureInstanceKHR structures
    are consumed from
    slink:VkAccelerationStructureGeometryInstancesDataKHR::pname:data,
    starting at an offset of pname:primitiveOffset.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureBuildRangeInfoKHR-primitiveOffset-03656]]
    For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if the
    geometry uses indices, the offset pname:primitiveOffset from
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:indexData
    must: be a multiple of the element size of
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:indexType
  * [[VUID-VkAccelerationStructureBuildRangeInfoKHR-primitiveOffset-03657]]
    For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if the
    geometry doesn't use indices, the offset pname:primitiveOffset from
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexData
    must: be a multiple of the component size of
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexFormat
  * [[VUID-VkAccelerationStructureBuildRangeInfoKHR-transformOffset-03658]]
    For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, the offset
    pname:transformOffset from
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:transformData
    must: be a multiple of 16
  * [[VUID-VkAccelerationStructureBuildRangeInfoKHR-primitiveOffset-03659]]
    For geometries of type ename:VK_GEOMETRY_TYPE_AABBS_KHR, the offset
    pname:primitiveOffset from
    slink:VkAccelerationStructureGeometryAabbsDataKHR::pname:data must: be a
    multiple of 8
  * [[VUID-VkAccelerationStructureBuildRangeInfoKHR-primitiveOffset-03660]]
    For geometries of type ename:VK_GEOMETRY_TYPE_INSTANCES_KHR, the offset
    pname:primitiveOffset from
    slink:VkAccelerationStructureGeometryInstancesDataKHR::pname:data must:
    be a multiple of 16
****

include::{generated}/validity/structs/VkAccelerationStructureBuildRangeInfoKHR.txt[]
--

endif::VK_KHR_acceleration_structure[]


[[acceleration-structure-copying]]
=== Copying Acceleration Structures

An additional command exists for copying acceleration structures without
updating their contents.
The acceleration structure object can: be compacted in order to improve
performance.
Before copying, an application must: query the size of the resulting
acceleration structure.

[open,refpage='vkCmdWriteAccelerationStructuresPropertiesKHR',desc='Write acceleration structure result parameters to query results.',type='protos']
--
:refpage: vkCmdWriteAccelerationStructuresPropertiesKHR

To query acceleration structure size parameters call:

ifdef::VK_KHR_acceleration_structure[]
include::{generated}/api/protos/vkCmdWriteAccelerationStructuresPropertiesKHR.txt[]
endif::VK_KHR_acceleration_structure[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:accelerationStructureCount is the count of acceleration structures
    for which to query the property.
  * pname:pAccelerationStructures is a pointer to an array of existing
    previously built acceleration structures.
  * pname:queryType is a elink:VkQueryType value specifying the type of
    queries managed by the pool.
  * pname:queryPool is the query pool that will manage the results of the
    query.
  * pname:firstQuery is the first query index within the query pool that
    will contain the pname:accelerationStructureCount number of results.

Accesses to any of the acceleration structures listed in
pname:pAccelerationStructures must: be <<synchronization-dependencies,
synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR.

.Valid Usage
****
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryPool-02493]]
    pname:queryPool must: have been created with a pname:queryType matching
    pname:queryType
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryPool-02494]]
    The queries identified by pname:queryPool and pname:firstQuery must: be
    _unavailable_
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-buffer-03736]]
    The pname:buffer used to create each acceleration structure in
    pname:pAccelerationStructures must: be bound to device memory
include::{chapters}/commonvalidity/write_acceleration_structure_properties_common.txt[]
****

include::{generated}/validity/protos/vkCmdWriteAccelerationStructuresPropertiesKHR.txt[]
--

ifdef::VK_NV_ray_tracing[]
[open,refpage='vkCmdWriteAccelerationStructuresPropertiesNV',desc='Write acceleration structure result parameters to query results.',type='protos']
--
:refpage: vkCmdWriteAccelerationStructuresPropertiesNV

To query acceleration structure size parameters call:

include::{generated}/api/protos/vkCmdWriteAccelerationStructuresPropertiesNV.txt[]


  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:accelerationStructureCount is the count of acceleration structures
    for which to query the property.
  * pname:pAccelerationStructures is a pointer to an array of existing
    previously built acceleration structures.
  * pname:queryType is a elink:VkQueryType value specifying the type of
    queries managed by the pool.
  * pname:queryPool is the query pool that will manage the results of the
    query.
  * pname:firstQuery is the first query index within the query pool that
    will contain the pname:accelerationStructureCount number of results.

Accesses to any of the acceleration structures listed in
pname:pAccelerationStructures must: be <<synchronization-dependencies,
synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR.

.Valid Usage
****
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryPool-03755]]
    pname:queryPool must: have been created with a pname:queryType matching
    pname:queryType
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryPool-03756]]
    The queries identified by pname:queryPool and pname:firstQuery must: be
    _unavailable_
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesNV-accelerationStructure-03757]]
    pname:accelerationStructure must: be bound completely and contiguously
    to a single sname:VkDeviceMemory object via
    flink:vkBindAccelerationStructureMemoryNV

include::{chapters}/commonvalidity/write_acceleration_structure_properties_common.txt[]
****

include::{generated}/validity/protos/vkCmdWriteAccelerationStructuresPropertiesNV.txt[]
--

[open,refpage='vkCmdCopyAccelerationStructureNV',desc='Copy an acceleration structure',type='protos']
--
:refpage: vkCmdCopyAccelerationStructureNV

To copy an acceleration structure call:

include::{generated}/api/protos/vkCmdCopyAccelerationStructureNV.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:dst is the target acceleration structure for the copy.
  * pname:src is the source acceleration structure for the copy.
  * pname:mode is a elink:VkCopyAccelerationStructureModeKHR value
    specifying additional operations to perform during the copy.

Accesses to pname:src and pname:dst must: be <<synchronization-dependencies,
synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR or
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR as appropriate.

.Valid Usage
****
include::{chapters}/commonvalidity/copy_acceleration_structure_common.txt[]
****

include::{generated}/validity/protos/vkCmdCopyAccelerationStructureNV.txt[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='vkCmdCopyAccelerationStructureKHR',desc='Copy an acceleration structure',type='protos']
--
:refpage: vkCmdCopyAccelerationStructureKHR

To copy an acceleration structure call:

include::{generated}/api/protos/vkCmdCopyAccelerationStructureKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pInfo is a pointer to a slink:VkCopyAccelerationStructureInfoKHR
    structure defining the copy operation.

Accesses to pname:pInfo\->pname:src and pname:pInfo\->pname:dst must: be
<<synchronization-dependencies, synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR or
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR as appropriate.

.Valid Usage
****
  * [[VUID-vkCmdCopyAccelerationStructureKHR-buffer-03737]]
    The pname:buffer used to create pname:pInfo\->pname:src must: be bound
    to device memory
  * [[VUID-vkCmdCopyAccelerationStructureKHR-buffer-03738]]
    The pname:buffer used to create pname:pInfo\->pname:dst must: be bound
    to device memory
****

include::{generated}/validity/protos/vkCmdCopyAccelerationStructureKHR.txt[]
--

[open,refpage='VkCopyAccelerationStructureInfoKHR',desc='Parameters for copying an acceleration structure',type='structs']
--
:refpage: VkCopyAccelerationStructureInfoKHR

The sname:VkCopyAccelerationStructureInfoKHR structure is defined as:

include::{generated}/api/structs/VkCopyAccelerationStructureInfoKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:src is the source acceleration structure for the copy.
  * pname:dst is the target acceleration structure for the copy.
  * pname:mode is a elink:VkCopyAccelerationStructureModeKHR value that
    specifies additional operations to perform during the copy.

.Valid Usage
****
include::{chapters}/commonvalidity/copy_acceleration_structure_common.txt[]
****

include::{generated}/validity/structs/VkCopyAccelerationStructureInfoKHR.txt[]
--
endif::VK_KHR_acceleration_structure[]

[open,refpage='VkCopyAccelerationStructureModeKHR',desc='Acceleration structure copy mode',type='enums',alias='VkCopyAccelerationStructureModeNV']
--
:refpage: VkCopyAccelerationStructureModeKHR

Possible values of pname:mode specifying additional operations to perform
during the copy, are:

include::{generated}/api/enums/VkCopyAccelerationStructureModeKHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/enums/VkCopyAccelerationStructureModeNV.txt[]
endif::VK_NV_ray_tracing[]

  * ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR creates a direct
    copy of the acceleration structure specified in pname:src into the one
    specified by pname:dst.
    The pname:dst acceleration structure must: have been created with the
    same parameters as pname:src.
  * ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR creates a more
    compact version of an acceleration structure pname:src into pname:dst.
    The acceleration structure pname:dst must: have been created with a size
    at least as large as that returned by
    flink:vkCmdWriteAccelerationStructuresPropertiesKHR
ifdef::VK_KHR_acceleration_structure[]
    or flink:vkWriteAccelerationStructuresPropertiesKHR
endif::VK_KHR_acceleration_structure[]
    after the build of the acceleration structure specified by pname:src.
  * ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR serializes the
    acceleration structure to a semi-opaque format which can be reloaded on
    a compatible implementation.
  * ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR deserializes
    the semi-opaque serialization format in the buffer to the acceleration
    structure.
--

[open,refpage='vkCmdCopyAccelerationStructureToMemoryKHR',desc='Copy an acceleration structure to device memory',type='protos']
--
:refpage: vkCmdCopyAccelerationStructureToMemoryKHR

To copy an acceleration structure to device memory call:

include::{generated}/api/protos/vkCmdCopyAccelerationStructureToMemoryKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pInfo is an a pointer to a
    slink:VkCopyAccelerationStructureToMemoryInfoKHR structure defining the
    copy operation.

Accesses to pname:pInfo\->pname:src must: be <<synchronization-dependencies,
synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR.
Accesses to the buffer indicated by pname:pInfo\->pname:dst.deviceAddress
must: be synchronized with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR pipeline stage
and an access type of ename:VK_ACCESS_TRANSFER_WRITE_BIT.

This command produces the same results as
flink:vkCopyAccelerationStructureToMemoryKHR, but writes its result to a
device address, and is executed on the device rather than the host.
The output may: not necessarily be bit-for-bit identical, but it can be
equally used by either flink:vkCmdCopyMemoryToAccelerationStructureKHR or
flink:vkCopyMemoryToAccelerationStructureKHR.

The defined header structure for the serialized data consists of:

  * ename:VK_UUID_SIZE bytes of data matching
    sname:VkPhysicalDeviceIDProperties::pname:driverUUID
  * ename:VK_UUID_SIZE bytes of data identifying the compatibility for
    comparison using flink:vkGetDeviceAccelerationStructureCompatibilityKHR
  * A 64-bit integer of the total size matching the value queried using
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR
  * A 64-bit integer of the deserialized size to be passed in to
    sname:VkAccelerationStructureCreateInfoKHR::pname:size
  * A 64-bit integer of the count of the number of acceleration structure
    handles following.
    This will be zero for a bottom-level acceleration structure.

The corresponding handles matching the values returned by
ifdef::VK_KHR_acceleration_structure[flink:vkGetAccelerationStructureDeviceAddressKHR]
ifdef::VK_KHR_acceleration_structure+VK_NV_ray_tracing[or]
ifdef::VK_NV_ray_tracing[flink:vkGetAccelerationStructureHandleNV]
are tightly packed in the buffer following the count.
The application is expected to store a mapping between those handles and the
original application-generated bottom-level acceleration structures to
provide when deserializing.
The serialized data is written to the buffer (or read from the buffer)
according to the host endianness.

.Valid Usage
****
  * [[VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-03739]]
    pname:pInfo\->pname:dst.deviceAddress must: be a valid device address
    for a buffer bound to device memory.
  * [[VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-03740]]
   pname:pInfo\->pname:dst.deviceAddress must: be aligned to `256` bytes
  * [[VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-03741]]
    If the buffer pointed to by pname:pInfo\->pname:dst.deviceAddress is
    non-sparse then it must: be bound completely and contiguously to a
    single slink:VkDeviceMemory object
  * [[VUID-vkCmdCopyAccelerationStructureToMemoryKHR-None-03559]]
    The pname:buffer used to create pname:pInfo\->pname:src must: be bound
    to device memory
****

include::{generated}/validity/protos/vkCmdCopyAccelerationStructureToMemoryKHR.txt[]
--

[open,refpage='VkCopyAccelerationStructureToMemoryInfoKHR',desc='Parameters for serializing an acceleration structure',type='structs']
--
:refpage: VkCopyAccelerationStructureToMemoryInfoKHR

include::{generated}/api/structs/VkCopyAccelerationStructureToMemoryInfoKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:src is the source acceleration structure for the copy
  * pname:dst is the device or host address to memory which is the target
    for the copy
  * pname:mode is a elink:VkCopyAccelerationStructureModeKHR value that
    specifies additional operations to perform during the copy.

.Valid Usage
****
  * [[VUID-VkCopyAccelerationStructureToMemoryInfoKHR-dst-03561]]
    The memory pointed to by pname:dst must: be at least as large as the
    serialization size of pname:src, as reported by
    flink:vkWriteAccelerationStructuresPropertiesKHR or
    flink:vkCmdWriteAccelerationStructuresPropertiesKHR with a query type of
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR
  * [[VUID-VkCopyAccelerationStructureToMemoryInfoKHR-mode-03412]]
    pname:mode must: be
    ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR
****

include::{generated}/validity/structs/VkCopyAccelerationStructureToMemoryInfoKHR.txt[]
--

[open,refpage='vkCmdCopyMemoryToAccelerationStructureKHR',desc='Copy device memory to an acceleration structure',type='protos']
--
:refpage: vkCmdCopyMemoryToAccelerationStructureKHR

To copy device memory to an acceleration structure call:

include::{generated}/api/protos/vkCmdCopyMemoryToAccelerationStructureKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pInfo is a pointer to a
    slink:VkCopyMemoryToAccelerationStructureInfoKHR structure defining the
    copy operation.

Accesses to pname:pInfo\->pname:dst must: be <<synchronization-dependencies,
synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR.
Accesses to the buffer indicated by pname:pInfo\->pname:src.deviceAddress
must: be synchronized with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR pipeline stage
and an access type of ename:VK_ACCESS_TRANSFER_READ_BIT.

This command can accept acceleration structures produced by either
flink:vkCmdCopyAccelerationStructureToMemoryKHR or
flink:vkCopyAccelerationStructureToMemoryKHR.

The structure provided as input to deserialize is as described in
flink:vkCmdCopyAccelerationStructureToMemoryKHR, with any acceleration
structure handles filled in with the newly-queried handles to bottom level
acceleration structures created before deserialization.
These do not need to be built at deserialize time, but must: be created.

.Valid Usage
****
  * [[VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-03742]]
    pname:pInfo\->pname:src.deviceAddress must: be a valid device address
    for a buffer bound to device memory.
  * [[VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-03743]]
    pname:pInfo\->pname:src.deviceAddress must: be aligned to `256` bytes
  * [[VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-03744]]
    If the buffer pointed to by pname:pInfo\->pname:src.deviceAddress is
    non-sparse then it must: be bound completely and contiguously to a
    single slink:VkDeviceMemory object
  * [[VUID-vkCmdCopyMemoryToAccelerationStructureKHR-buffer-03745]]
    The pname:buffer used to create pname:pInfo\->pname:dst must: be bound
    to device memory
****

include::{generated}/validity/protos/vkCmdCopyMemoryToAccelerationStructureKHR.txt[]
--

[open,refpage='VkCopyMemoryToAccelerationStructureInfoKHR',desc='Parameters for deserializing an acceleration structure',type='structs']
--
:refpage: VkCopyMemoryToAccelerationStructureInfoKHR

The sname:VkCopyMemoryToAccelerationStructureInfoKHR structure is defined
as:

include::{generated}/api/structs/VkCopyMemoryToAccelerationStructureInfoKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:src is the device or host address to memory containing the source
    data for the copy.
  * pname:dst is the target acceleration structure for the copy.
  * pname:mode is a elink:VkCopyAccelerationStructureModeKHR value that
    specifies additional operations to perform during the copy.

.Valid Usage
****
  * [[VUID-VkCopyMemoryToAccelerationStructureInfoKHR-mode-03413]]
    pname:mode must: be
    ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR
  * [[VUID-VkCopyMemoryToAccelerationStructureInfoKHR-pInfo-03414]]
    The data in pname:src must: have a format compatible with the
    destination physical device as returned by
    flink:vkGetDeviceAccelerationStructureCompatibilityKHR
  * [[VUID-VkCopyMemoryToAccelerationStructureInfoKHR-dst-03746]]
    pname:dst must: have been created with a pname:size greater than or
    equal to that used to serialize the data in pname:src
****

include::{generated}/validity/structs/VkCopyMemoryToAccelerationStructureInfoKHR.txt[]
--

[open,refpage='vkGetDeviceAccelerationStructureCompatibilityKHR',desc='Check if a serialized acceleration structure is compatible with the current device',type='protos']
--
:refpage: vkGetDeviceAccelerationStructureCompatibilityKHR

To check if a serialized acceleration structure is compatible with the
current device call:

include::{generated}/api/protos/vkGetDeviceAccelerationStructureCompatibilityKHR.txt[]

  * pname:device is the device to check the version against.
  * pname:pVersionInfo points to the
    slink:VkAccelerationStructureVersionInfoKHR version information to check
    against the device.
  * pname:pCompatibility points to the
    elink:VkAccelerationStructureCompatibilityKHR compatibility return
    value.

.Valid Usage
****
// TBD
  * [[VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-rayTracingPipeline-03661]]
    The <<features-rayTracingPipeline, pname:rayTracingPipeline>> or
    <<features-rayQuery, pname:rayQuery>> feature must: be enabled
****

include::{generated}/validity/protos/vkGetDeviceAccelerationStructureCompatibilityKHR.txt[]

--

[open,refpage='VkAccelerationStructureVersionInfoKHR',desc='Acceleration structure version information',type='structs']
--
:refpage: VkAccelerationStructureVersionKHR

The sname:VkAccelerationStructureVersionInfoKHR structure is defined as:

include::{generated}/api/structs/VkAccelerationStructureVersionInfoKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pVersionData is a pointer to the version header of an acceleration
    structure as defined in flink:vkCmdCopyAccelerationStructureToMemoryKHR

[NOTE]
.Note
====
pname:pVersionData is a _pointer_ to an array of 2*ename:VK_UUID_SIZE
code:uint8_t values instead of two ename:VK_UUID_SIZE arrays as the expected
use case for this member is to be pointed at the header of an previously
serialized acceleration structure (via
flink:vkCmdCopyAccelerationStructureToMemoryKHR or
flink:vkCopyAccelerationStructureToMemoryKHR) that is loaded in memory.
Using arrays would necessitate extra memory copies of the UUIDs.
====

include::{generated}/validity/structs/VkAccelerationStructureVersionInfoKHR.txt[]

--

[open,refpage='VkAccelerationStructureCompatibilityKHR',desc='Acceleration structure compatibility',type='enums']
--

Possible values of pname:pCompatibility returned by
flink:vkGetDeviceAccelerationStructureCompatibilityKHR are:

include::{generated}/api/enums/VkAccelerationStructureCompatibilityKHR.txt[]

  * ename:VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR when the
    pname:pVersion version acceleration structure is compatibile with
    pname:device.
  * ename:VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR when the
    pname:pVersion version acceleration structure is not compatibile with
    pname:device.

--


include::raytracing-host-rtas.txt[]
endif::VK_KHR_acceleration_structure,VK_NV_ray_tracing[]
