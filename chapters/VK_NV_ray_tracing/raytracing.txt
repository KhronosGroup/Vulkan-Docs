[[ray-tracing]]
= Ray Tracing

Ray tracing uses a separate rendering pipeline from both the graphics and
compute pipelines (see <<pipelines-ray-tracing,Ray Tracing Pipeline>>).

[[fig-raypipe]]
image::{images}/ray_tracing_execution.svg[align="center",title="Ray tracing pipeline execution",opts="{imageopts}"]

.Caption
****
Interaction between the different shader stages in the ray tracing pipeline
****

Within the ray tracing pipeline, code:OpTraceRayKHR can: be called to
perform a <<ray-traversal,ray traversal>> that invokes the various ray
tracing shader stages during its execution.
The relationship between the ray tracing pipeline object and the geometries
present in the acceleration structure traversed is passed into the ray
tracing command in a slink:VkBuffer object known as a _shader binding
table_.
code:OpExecuteCallableKHR can also be used in ray tracing pipelines to
invoke a <<shaders-callable,callable shader>>.

During execution, control alternates between scheduling and other
operations.
The scheduling functionality is implementation-specific and is responsible
for workload execution.
The shader stages are programmable.
<<ray-traversal, _Traversal_>>, which refers to the process of traversing
acceleration structures to find potential intersections of rays with
geometry, is fixed function.

The programmable portions of the pipeline are exposed in a single-ray
programming model, with each invocation handling one ray at a time.
Memory operations can: be synchronized using standard memory barriers.
The code:Workgroup scope and variables with a storage class of
code:Workgroup must: not be used in the ray tracing pipeline.


[[ray-tracing-shader-call]]
== Shader Call Instructions

A _shader call_ is an instruction which may: cause execution to continue
elsewhere by creating one or more invocations that execute a different
shader stage.

The shader call instructions are:

 * code:OpTraceRayKHR which may: invoke intersection, any-hit, closest hit,
   or miss shaders,
 * code:OpReportIntersectionKHR which may: invoke any-hit shaders, and
 * code:OpExecuteCallableKHR which will invoke a callable shader.

ifdef::VK_VERSION_1_1[]
The invocations created by shader call instructions are grouped into
subgroups by the implementation.
Those subgroups may: be unrelated to the subgroup of the parent invocation.
endif::VK_VERSION_1_1[]


[[ray-tracing-recursion-depth]]
Shader call instructions can: be used recursively; invoked shaders can:
themselves execute shader call instructions, to a maximum depth defined by
the <<limits-maxRecursionDepth, pname:maxRecursionDepth>> limit.

Shaders directly invoked from the API always have a recursion depth of 0;
each shader executed by a shader call instruction has a recursion depth one
higher than the recursion depth of the shader which invoked it.
Applications must: not invoke a shader with a recursion depth greater than
the value of pname:maxRecursionDepth specified in the pipeline.

[[ray-tracing-repack]]
An _invocation repack instruction_ is a ray tracing shader call instruction
where the implementation may: change the set of invocations that are
executing.
When a repack instruction is encountered, the invocation is suspended and a
new invocation begins and executes the instruction.
After executing the repack instruction (which may: result in other ray
tracing shader stages executing) the new invocation ends and the original
invocation is resumed, but it may: be resumed in a different subgroup or at
a different code:SubgroupLocalInvocationId within the same subgroup.
When a subset of invocations in a subgroup execute the invocation repack
instruction, those that do not execute it remain in the same subgroup at the
same code:SubgroupLocalInvocationId.

The code:OpTraceRayKHR, code:OpReportIntersectionKHR, and
code:OpExecuteCallableKHR instructions are invocation repack instructions.

ifdef::VK_VERSION_1_1[]
ifdef::VK_KHR_vulkan_memory_model[]
The invocations that are executing before an invocation repack instruction,
after the instruction, or are created by the instruction, are
<<shader-call-related,shader-call-related>>.
endif::VK_KHR_vulkan_memory_model[]

If the implementation changes the composition of subgroups, the values of
code:SubgroupLocalInvocationId,
ifdef::VK_NV_shader_sm_builtins[]
code:SMIDNV, code:WarpIDNV,
endif::VK_NV_shader_sm_builtins[]
and builtin variables that are derived from them (code:SubgroupEqMask,
code:SubgroupGeMask, code:SubgroupGtMask, code:SubgroupLeMask,
code:SubgroupLtMask) must: be changed accordingly by the invocation repack
instruction.

[NOTE]
.Note
====
<<shaders-subgroup,Subgroup operations>> are permitted in the programmable
ray tracing shader stages.
However, shader call instructions place a bound on where results of subgroup
instructions or subgroup-scoped instructions that execute the dynamic
instance of that instruction are potentially valid.
For example, care must: be taken when using the result of a ballot operation
that was computed before an invocation repack instruction, after that repack
instruction.
The ballot may: be incorrect as the set of invocations could have changed.

ifdef::VK_KHR_shader_clock[]
For clock operations, the value of a code:Subgroup scoped
code:OpReadClockKHR read before the dynamic instance of a repack instruction
should: not be compared to the result of that clock instruction after the
repack instruction.
endif::VK_KHR_shader_clock[]
====
endif::VK_VERSION_1_1[]

ifdef::VK_KHR_vulkan_memory_model[]
When a ray tracing shader executes a dynamic instance of an invocation
repack instruction which results in another ray tracing shader being
invoked, their instructions are related by
<<shader-call-order,shader-call-order>>.

For ray tracing invocations that are
<<shader-call-related,shader-call-related>>:

  * <<memory-model-memory-operation,memory operations>> on
    code:StorageBuffer, code:Image, and code:ShaderRecordBufferKHR storage
    classes can: be synchronized using the
ifdef::VK_KHR_ray_tracing[code:ShaderCallKHR]
ifndef::VK_KHR_ray_tracing[code:Device or code:QueueFamily]
    scope.

  * the code:CallableDataKHR, code:IncomingCallableDataKHR,
    code:RayPayloadKHR, code:HitAttributeKHR, and code:IncomingRayPayloadKHR
    storage classes are <<memory-model-shader-io,system-synchronized>> and
    no application availability and visibility operations are required.

  * memory operations within a single invocation before and after the
    invocation repack instruction are ordered by
    <<memory-model-program-order,program-order>> and do not require explicit
    synchronzation.
endif::VK_KHR_vulkan_memory_model[]


[[ray-tracing-commands]]
== Ray Tracing Commands

_Ray tracing commands_ provoke work in the ray tracing pipeline.
Ray tracing commands are recorded into a command buffer and when executed by
a queue will produce work that executes according to the currently bound ray
tracing pipeline.
A ray tracing pipeline must: be bound to a command buffer before any ray
tracing commands are recorded in that command buffer.

ifdef::VK_NV_ray_tracing[]

[open,refpage='vkCmdTraceRaysNV',desc='Initialize a ray tracing dispatch',type='protos']
--
:refpage: vkCmdTraceRaysNV

To dispatch ray tracing use:

include::{generated}/api/protos/vkCmdTraceRaysNV.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:raygenShaderBindingTableBuffer is the buffer object that holds the
    shader binding table data for the ray generation shader stage.
  * pname:raygenShaderBindingOffset is the offset in bytes (relative to
    pname:raygenShaderBindingTableBuffer) of the ray generation shader being
    used for the trace.
  * pname:missShaderBindingTableBuffer is the buffer object that holds the
    shader binding table data for the miss shader stage.
  * pname:missShaderBindingOffset is the offset in bytes (relative to
    pname:missShaderBindingTableBuffer) of the miss shader being used for
    the trace.
  * pname:missShaderBindingStride is the size in bytes of each shader
    binding table record in pname:missShaderBindingTableBuffer.
  * pname:hitShaderBindingTableBuffer is the buffer object that holds the
    shader binding table data for the hit shader stages.
  * pname:hitShaderBindingOffset is the offset in bytes (relative to
    pname:hitShaderBindingTableBuffer) of the hit shader group being used
    for the trace.
  * pname:hitShaderBindingStride is the size in bytes of each shader binding
    table record in pname:hitShaderBindingTableBuffer.
  * pname:callableShaderBindingTableBuffer is the buffer object that holds
    the shader binding table data for the callable shader stage.
  * pname:callableShaderBindingOffset is the offset in bytes (relative to
    pname:callableShaderBindingTableBuffer) of the callable shader being
    used for the trace.
  * pname:callableShaderBindingStride is the size in bytes of each shader
    binding table record in pname:callableShaderBindingTableBuffer.
  * pname:width is the width of the ray trace query dimensions.
  * pname:height is height of the ray trace query dimensions.
  * pname:depth is depth of the ray trace query dimensions.

When the command is executed, a ray generation group of [eq]#pname:width
{times} pname:height {times} pname:depth# rays is assembled.

.Valid Usage
****
include::{chapters}/commonvalidity/trace_rays_common.txt[]
include::{chapters}/commonvalidity/draw_dispatch_nonindirect_common.txt[]
  * [[VUID-vkCmdTraceRaysNV-raygenShaderBindingTableBuffer-04042]]
    If pname:raygenShaderBindingTableBuffer is non-sparse then it must: be
    bound completely and contiguously to a single sname:VkDeviceMemory
    object
  * [[VUID-vkCmdTraceRaysNV-raygenShaderBindingOffset-02455]]
    pname:raygenShaderBindingOffset must: be less than the size of
    pname:raygenShaderBindingTableBuffer
  * [[VUID-vkCmdTraceRaysNV-raygenShaderBindingOffset-02456]]
    pname:raygenShaderBindingOffset must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupBaseAlignment
  * [[VUID-vkCmdTraceRaysNV-missShaderBindingTableBuffer-04043]]
    If pname:missShaderBindingTableBuffer is non-sparse then it must: be
    bound completely and contiguously to a single sname:VkDeviceMemory
    object
  * [[VUID-vkCmdTraceRaysNV-missShaderBindingOffset-02457]]
    pname:missShaderBindingOffset must: be less than the size of
    pname:missShaderBindingTableBuffer
  * [[VUID-vkCmdTraceRaysNV-missShaderBindingOffset-02458]]
    pname:missShaderBindingOffset must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupBaseAlignment
  * [[VUID-vkCmdTraceRaysNV-hitShaderBindingTableBuffer-04044]]
    If pname:hitShaderBindingTableBuffer is non-sparse then it must: be
    bound completely and contiguously to a single sname:VkDeviceMemory
    object
  * [[VUID-vkCmdTraceRaysNV-hitShaderBindingOffset-02459]]
    pname:hitShaderBindingOffset must: be less than the size of
    pname:hitShaderBindingTableBuffer
  * [[VUID-vkCmdTraceRaysNV-hitShaderBindingOffset-02460]]
    pname:hitShaderBindingOffset must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupBaseAlignment
  * [[VUID-vkCmdTraceRaysNV-callableShaderBindingTableBuffer-04045]]
    If pname:callableShaderBindingTableBuffer is non-sparse then it must: be
    bound completely and contiguously to a single sname:VkDeviceMemory
    object
  * [[VUID-vkCmdTraceRaysNV-callableShaderBindingOffset-02461]]
    pname:callableShaderBindingOffset must: be less than the size of
    pname:callableShaderBindingTableBuffer
  * [[VUID-vkCmdTraceRaysNV-callableShaderBindingOffset-02462]]
    pname:callableShaderBindingOffset must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupBaseAlignment
  * [[VUID-vkCmdTraceRaysNV-missShaderBindingStride-02463]]
    pname:missShaderBindingStride must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupHandleSize
  * [[VUID-vkCmdTraceRaysNV-hitShaderBindingStride-02464]]
    pname:hitShaderBindingStride must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupHandleSize
  * [[VUID-vkCmdTraceRaysNV-callableShaderBindingStride-02465]]
    pname:callableShaderBindingStride must: be a multiple of
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:shaderGroupHandleSize
  * [[VUID-vkCmdTraceRaysNV-missShaderBindingStride-02466]]
    pname:missShaderBindingStride must: be less than or equal to
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxShaderGroupStride
  * [[VUID-vkCmdTraceRaysNV-hitShaderBindingStride-02467]]
    pname:hitShaderBindingStride must: be less than or equal to
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxShaderGroupStride
  * [[VUID-vkCmdTraceRaysNV-callableShaderBindingStride-02468]]
    pname:callableShaderBindingStride must: be less than or equal to
    sname:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxShaderGroupStride
  * [[VUID-vkCmdTraceRaysNV-width-02469]]
    pname:width must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[0]
  * [[VUID-vkCmdTraceRaysNV-height-02470]]
    pname:height must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[1]
  * [[VUID-vkCmdTraceRaysNV-depth-02471]]
    pname:depth must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[2]
****

include::{generated}/validity/protos/vkCmdTraceRaysNV.txt[]
--

endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_ray_tracing[]
[open,refpage='vkCmdTraceRaysKHR',desc='Initialize a ray tracing dispatch',type='protos']
--
:refpage: vkCmdTraceRaysKHR

To dispatch ray tracing use:

include::{generated}/api/protos/vkCmdTraceRaysKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pRaygenShaderBindingTable is a slink:VkStridedBufferRegionKHR that
    holds the shader binding table data for the ray generation shader stage.
  * pname:pMissShaderBindingTable is a slink:VkStridedBufferRegionKHR that
    holds the shader binding table data for the miss shader stage.
  * pname:pHitShaderBindingTable is a slink:VkStridedBufferRegionKHR that
    holds the shader binding table data for the hit shader stage.
  * pname:pCallableShaderBindingTable is a slink:VkStridedBufferRegionKHR
    that holds the shader binding table data for the callable shader stage.
  * pname:width is the width of the ray trace query dimensions.
  * pname:height is height of the ray trace query dimensions.
  * pname:depth is depth of the ray trace query dimensions.

When the command is executed, a ray generation group of [eq]#pname:width
{times} pname:height {times} pname:depth# rays is assembled.

.Valid Usage
****
include::{chapters}/commonvalidity/trace_rays_common.txt[]
include::{chapters}/commonvalidity/trace_rays_common_khr.txt[]
include::{chapters}/commonvalidity/draw_dispatch_nonindirect_common.txt[]
  * [[VUID-vkCmdTraceRaysKHR-width-03505]]
    pname:width must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[0]
  * [[VUID-vkCmdTraceRaysKHR-height-03506]]
    pname:height must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[1]
  * [[VUID-vkCmdTraceRaysKHR-depth-03507]]
    pname:depth must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[2]
****

include::{generated}/validity/protos/vkCmdTraceRaysKHR.txt[]
--

[open,refpage='VkStridedBufferRegionKHR',desc='Structure specifying a region of a VkBuffer with a stride',type='structs']
--
:refpage: VkStridedBufferRegionKHR

The sname:VkStridedBufferRegionKHR structure is defined as:

include::{generated}/api/structs/VkStridedBufferRegionKHR.txt[]

  * pname:buffer is the buffer containing this region.
  * pname:offset is the byte offset in pname:buffer at which the region
    starts.
  * pname:stride is the byte stride between consecutive elements.
  * pname:size is the size in bytes of the region starting at pname:offset.

.Valid Usage
****
  * [[VUID-VkStridedBufferRegionKHR-buffer-03515]]
    If pname:buffer is not dlink:VK_NULL_HANDLE, pname:size plus
    pname:offset must: be less than or equal to the size of pname:buffer
  * [[VUID-VkStridedBufferRegionKHR-buffer-03516]]
    If pname:buffer is not dlink:VK_NULL_HANDLE, pname:stride must: be less
    than the size of pname:buffer
****

include::{generated}/validity/structs/VkStridedBufferRegionKHR.txt[]
--


[open,refpage='vkCmdTraceRaysIndirectKHR',desc='Initialize an indirect ray tracing dispatch',type='protos']
--
:refpage: vkCmdTraceRaysIndirectKHR

To dispatch ray tracing, with some parameters sourced on the device, use:

include::{generated}/api/protos/vkCmdTraceRaysIndirectKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pRaygenShaderBindingTable is a slink:VkStridedBufferRegionKHR that
    holds the shader binding table data for the ray generation shader stage.
  * pname:pMissShaderBindingTable is a slink:VkStridedBufferRegionKHR that
    holds the shader binding table data for the miss shader stage.
  * pname:pHitShaderBindingTable is a slink:VkStridedBufferRegionKHR that
    holds the shader binding table data for the hit shader stage.
  * pname:pCallableShaderBindingTable is a slink:VkStridedBufferRegionKHR
    that holds the shader binding table data for the callable shader stage.
  * pname:buffer is the buffer containing the trace ray parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.

fname:vkCmdTraceRaysIndirectKHR behaves similarly to flink:vkCmdTraceRaysKHR
except that the ray trace query dimensions are read by the device from
pname:buffer during execution.
The parameters of trace ray are encoded in the
slink:VkTraceRaysIndirectCommandKHR structure located at pname:offset bytes
in pname:buffer.

.Valid Usage
****
include::{chapters}/commonvalidity/trace_rays_common.txt[]
include::{chapters}/commonvalidity/trace_rays_common_khr.txt[]
include::{chapters}/commonvalidity/draw_dispatch_indirect_common.txt[]
  * [[VUID-vkCmdTraceRaysIndirectKHR-offset-03517]]
    [eq]#(pname:offset {plus}
    code:sizeof(sname:VkTraceRaysIndirectCommandKHR))# must: be less than or
    equal to the size of pname:buffer
  * [[VUID-vkCmdTraceRaysIndirectKHR-rayTracingIndirectTraceRays-03518]]
    the <<features-raytracing-indirecttraceray,
    sname:VkPhysicalDeviceRayTracingFeaturesKHR::pname:rayTracingIndirectTraceRays>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkCmdTraceRaysIndirectKHR.txt[]
--

[open,refpage='VkTraceRaysIndirectCommandKHR',desc='Structure specifying the parameters of an indirect trace ray command',type='structs']
--
:refpage: VkTraceRaysIndirectCommandKHR

The sname:VkTraceRaysIndirectCommandKHR structure is defined as:

include::{generated}/api/structs/VkTraceRaysIndirectCommandKHR.txt[]

  * pname:width is the width of the ray trace query dimensions.
  * pname:height is height of the ray trace query dimensions.
  * pname:depth is depth of the ray trace query dimensions.

The members of sname:VkTraceRaysIndirectCommandKHR have the same meaning as
the similarly named parameters of flink:vkCmdTraceRaysKHR.

.Valid Usage
****
  * [[VUID-VkTraceRaysIndirectCommandKHR-width-03519]]
    pname:width must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[0]
  * [[VUID-VkTraceRaysIndirectCommandKHR-height-03520]]
    pname:height must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[1]
  * [[VUID-VkTraceRaysIndirectCommandKHR-depth-03521]]
    pname:depth must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxComputeWorkGroupCount[2]
****

include::{generated}/validity/structs/VkTraceRaysIndirectCommandKHR.txt[]
--
endif::VK_KHR_ray_tracing[]


[[shader-binding-table]]
== Shader Binding Table

A _shader binding table_ is a resource which establishes the relationship
between the ray tracing pipeline and the acceleration structures that were
built for the ray tracing query.
It indicates the shaders that operate on each geometry in an acceleration
structure.
In addition, it contains the resources accessed by each shader, including
indices of textures and constants.
The application allocates and manages _shader binding tables_ as
slink:VkBuffer objects.

Each entry in the shader binding table consists of
pname:shaderGroupHandleSize bytes of data as queried by
flink:vkGetRayTracingShaderGroupHandlesKHR to refer to the shader that it
invokes.
The remainder of the data specified by the stride is application-visible
data that can be referenced by a code:ShaderRecordBufferKHR block in the
shader.

The shader binding tables to use in a ray tracing query are passed to
flink:vkCmdTraceRaysKHR.
Shader binding tables are read-only in shaders that are executing on the ray
tracing pipeline.


[[shader-binding-table-indexing-rules]]
=== Indexing Rules

In order to execute the correct shaders and access the correct resources
during a ray tracing dispatch, the implementation must: be able to locate
shader binding table entries at various stages of execution.
This is accomplished by defining a set of indexing rules that compute shader
binding table record positions relative to the buffer's base address in
memory.
The application must: organize the contents of the shader binding table's
memory in a way that application of the indexing rules will lead to correct
records.


==== Ray Generation Shaders

ifdef::VK_KHR_ray_tracing[]
Only one ray generation shader is executed per ray tracing dispatch.
Its location is passed into flink:vkCmdTraceRaysKHR using the
pname:pRaygenShaderBindingTable->buffer and
pname:pRaygenShaderBindingTable->offset parameters -- there is no indexing.
pname:pRaygenShaderBindingTable->stride is unused.
endif::VK_KHR_ray_tracing[]

ifdef::VK_NV_ray_tracing[]
For flink:vkCmdTraceRaysNV, the offset and stride come from direct
parameters, so the buffer and offset come from
pname:raygenShaderBindingBuffer and pname:raygenShaderBindingOffset
endif::VK_NV_ray_tracing[]

All data accessed must: be less than pname:pRaygenShaderBindingTable->size
bytes from the base offset.

==== Hit Shaders

The base for the computation of intersection, any-hit and closest hit shader
locations is the code:instanceShaderBindingTableRecordOffset value stored
with each instance of a top-level acceleration structure.
This value determines the beginning of the shader binding table records for
a given instance.
Each geometry in the instance must: map to at least one hit program record.

In the following rule, _geometryIndex_ refers to the location of the
geometry within the instance.
This index is available to ray shaders via the code:RayGeometryIndexKHR
built-in.

The code:sbtRecordStride and code:sbtRecordOffset values are passed in as
parameters to
ifdef::VK_NV_ray_tracing[code:traceNV()]
ifdef::VK_NV_ray_tracing+VK_KHR_ray_tracing[ or ]
ifdef::VK_NV_ray_tracing[code:traceRayEXT()]
calls made in the shaders.
See Section 8.19 (Ray Tracing Functions) of the OpenGL Shading Language
Specification for more details.
In SPIR-V, these correspond to the code:SBTOffset and code:SBTStride
parameters to the code:OpTraceRayKHR instruction.

The result of this computation is then added to
pname:pHitShaderBindingTable->offset
ifdef::VK_NV_ray_tracing[]
or pname:hitShaderBindingOffset
endif::VK_NV_ray_tracing[]
, a base offset passed to flink:vkCmdTraceRaysKHR
ifdef::VK_NV_ray_tracing[]
or flink:vkCmdTraceRaysNV respectively
endif::VK_NV_ray_tracing[]
.

ifdef::VK_KHR_ray_tracing[]
The complete rule to compute a hit shader binding table record address in
the pname:pHitShaderBindingTable->buffer is:

  {empty}:: [eq]#pname:pHitShaderBindingTable->offset {plus}
            pname:pHitShaderBindingTable->stride {times} (
            code:instanceShaderBindingTableRecordOffset {plus}
            _geometryIndex_ {times} code:sbtRecordStride {plus}
            code:sbtRecordOffset )#

All data accessed must: be less than pname:pHitShaderBindingTable->size
bytes from the base offset.
endif::VK_KHR_ray_tracing[]

ifdef::VK_NV_ray_tracing[]
For flink:vkCmdTraceRaysNV, the offset and stride come from direct
parameters, so the full rule is equivalently:

  {empty}:: [eq]#pname:hitShaderBindingOffset {plus}
            pname:hitShaderBindingStride {times} (
            code:instanceShaderBindingTableRecordOffset {plus}
            _geometryIndex_ {times} code:sbtRecordStride {plus}
            code:sbtRecordOffset )#

endif::VK_NV_ray_tracing[]

==== Miss Shaders

A miss shader is executed whenever a ray query fails to find an intersection
for the given scene geometry.
Multiple miss shaders may: be executed throughout a ray tracing dispatch.

The base for the computation of miss shader locations is
pname:pMissShaderBindingTable->offset, a base offset passed into
flink:vkCmdTraceRaysKHR.

The code:missIndex value is passed in as a parameter to
ifdef::VK_NV_ray_tracing[code:traceNV()]
ifdef::VK_NV_ray_tracing+VK_KHR_ray_tracing[ or ]
ifdef::VK_NV_ray_tracing[code:traceRayEXT()]
calls made in the shaders.
See Section 8.19 (Ray Tracing Functions) of the OpenGL Shading Language
Specification for more details.
In SPIR-V, this corresponds to the code:MissIndex parameter to the
code:OpTraceRayKHR instruction.

ifdef::VK_KHR_ray_tracing[]
The complete rule to compute a miss shader binding table record address in
the pname:pMissShaderBindingTable->buffer is:

  {empty}:: [eq]#pname:pMissShaderBindingTable->offset {plus}
            pname:pMissShaderBindingTable->stride {times} code:missIndex#

All data accessed must: be less than pname:pMissShaderBindingTable->size
bytes from the base offset.
endif::VK_KHR_ray_tracing[]

ifdef::VK_NV_ray_tracing[]
For flink:vkCmdTraceRaysNV, the offset and stride come from direct
parameters, so the full rule is equivalently:

  {empty}:: [eq]#pname:missShaderBindingOffset {plus}
            pname:missShaderBindingStride {times} code:missIndex#

endif::VK_NV_ray_tracing[]


==== Callable Shaders

A callable shader is executed when requested by a ray tracing shader.
Multiple callable shaders may: be executed throughout a ray tracing
dispatch.

The base for the computation of callable shader locations is
pname:pCallableShaderBindingTable->offset, a base offset passed into
flink:vkCmdTraceRaysKHR.

The code:sbtRecordIndex value is passed in as a parameter to
ifdef::VK_NV_ray_tracing[code:executeCallableNV()]
ifdef::VK_NV_ray_tracing+VK_KHR_ray_tracing[ or ]
ifdef::VK_NV_ray_tracing[code:executeCallableEXT()]
calls made in the shaders.
See Section 8.19 (Ray Tracing Functions) of the OpenGL Shading Language
Specification for more details.
In SPIR-V, this corresponds to the code:SBTIndex parameter to the
code:OpExecuteCallableKHR instruction.

ifdef::VK_KHR_ray_tracing[]
The complete rule to compute a callable shader binding table record address
in the pname:pCallableShaderBindingTable->buffer is:

  {empty}:: [eq]#pname:pCallableShaderBindingTable->offset {plus}
            pname:pCallableShaderBindingTable->stride {times}
            code:sbtRecordIndex#

All data accessed must: be less than pname:pCallableShaderBindingTable->size
bytes from the base offset.
endif::VK_KHR_ray_tracing[]

ifdef::VK_NV_ray_tracing[]
For flink:vkCmdTraceRaysNV, the offset and stride come from direct
parameters, so the full rule is equivalently:

  {empty}:: [eq]#pname:callableShaderBindingOffset {plus}
            pname:callableShaderBindingStride {times} code:sbtRecordIndex#

endif::VK_NV_ray_tracing[]


[[acceleration-structure]]
== Acceleration Structures

_Acceleration structures_ are data structures used by the implementation to
efficiently manage scene geometry as it is <<ray-traversal, traversed during
a ray tracing query>>.
The application is responsible for managing acceleration structure objects
(see <<resources-acceleration-structures,Acceleration Structures>>),
including allocation, destruction, executing builds or updates, and
synchronizing resources used during ray tracing queries.

There are two types of acceleration structures, _top level acceleration
structures_ and _bottom level acceleration structures_.

[[fig-accelstruct]]
image::{images}/accelstruct.svg[align="center",title="Acceleration Structure",opts="{imageopts}"]

.Caption
****
The diagram shows the relationship between top and bottom level acceleration
structures.
****


[[acceleration-structure-geometry]]
=== Geometry

_Geometries_ refer to a triangle or axis-aligned bounding box.


[[acceleration-structure-inactive-prims]]
=== Inactive Primitives and Instances

Acceleration structures allow the use of particular input values to signal
_inactive_ primitives or instances.

An _inactive_ triangle is one for which the first (X) component of each
vertex is NaN.
If any other vertex component is NaN, and the first is not, the behavior is
undefined:.
If the vertex format does not have a NaN representation, then all triangles
are considered active.

An _inactive_ instance is one whose acceleration structure handle is
dlink:VK_NULL_HANDLE.

An _inactive_ AABB is one for which the minimum X coordinate is NaN.
If any other component is NaN, and the first is not, the behavior is
undefined:.

In the above definitions, "NaN" refers to any type of NaN.
Signaling, non-signaling, quiet, loud, or otherwise.

An inactive object is considered invisible to all rays, and should: not be
represented in the acceleration structure.
Implementations should: ensure that the presence of inactive objects does
not seriously degrade ray tracing performance.

Inactive objects are counted in the auto-generated index sequences which are
provided to shaders via code:InstanceId and code:PrimitiveId SPIR-V
decorations.
This allows objects in the scene to change freely between the active and
inactive states, without affecting the layout of any arrays which are being
indexed using the ID values.

Any transition between the active and inactive states requires a full
acceleration structure rebuild.
An update is not sufficient.
If an inactive object is made active by an update operation (or vice versa),
the results are undefined.


[[acceleration-structure-top-level]]
=== Top Level Acceleration Structures

Opaque acceleration structure for an array of instances.
The descriptor referencing this is the starting point for tracing


[[acceleration-structure-bottom-level]]
=== Bottom Level Acceleration Structures

Opaque acceleration structure for an array of geometries.


[[acceleration-structure-building]]
=== Building Acceleration Structures

ifdef::VK_NV_ray_tracing[]
[open,refpage='vkCmdBuildAccelerationStructureNV',desc='Build an acceleration structure',type='protos']
--
:refpage: vkCmdBuildAccelerationStructureNV

To build an acceleration structure call:

include::{generated}/api/protos/vkCmdBuildAccelerationStructureNV.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pInfo contains the shared information for the acceleration
    structure's structure.
  * pname:instanceData is the buffer containing an array of
    slink:VkAccelerationStructureInstanceKHR structures defining
    acceleration structures.
    This parameter must: be `NULL` for bottom level acceleration structures.
  * pname:instanceOffset is the offset in bytes (relative to the start of
    pname:instanceData) at which the instance data is located.
  * pname:update specifies whether to update the pname:dst acceleration
    structure with the data in pname:src.
  * pname:dst is a pointer to the target acceleration structure for the
    build.
  * pname:src is a pointer to an existing acceleration structure that is to
    be used to update the pname:dst acceleration structure.
  * pname:scratch is the slink:VkBuffer that will be used as scratch memory
    for the build.
  * pname:scratchOffset is the offset in bytes relative to the start of
    pname:scratch that will be used as a scratch memory.

.Valid Usage
****
  * [[VUID-vkCmdBuildAccelerationStructureNV-geometryCount-02241]]
    pname:geometryCount must: be less than or equal to
    slink:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxGeometryCount
  * [[VUID-vkCmdBuildAccelerationStructureNV-dst-02488]]
    pname:dst must: have been created with compatible
    slink:VkAccelerationStructureInfoNV where
    slink:VkAccelerationStructureInfoNV::pname:type and
    slink:VkAccelerationStructureInfoNV::pname:flags are identical,
    slink:VkAccelerationStructureInfoNV::pname:instanceCount and
    slink:VkAccelerationStructureInfoNV::pname:geometryCount for pname:dst
    are greater than or equal to the build size and each geometry in
    slink:VkAccelerationStructureInfoNV::pname:pGeometries for pname:dst has
    greater than or equal to the number of vertices, indices, and AABBs
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-02489]]
    If pname:update is ename:VK_TRUE, pname:src must: not be
    dlink:VK_NULL_HANDLE
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-02490]]
    If pname:update is ename:VK_TRUE, pname:src must: have been built before
    with ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV set in
    slink:VkAccelerationStructureInfoNV::pname:flags
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-02491]]
    If pname:update is ename:VK_FALSE, the pname:size member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetAccelerationStructureMemoryRequirementsNV with
    slink:VkAccelerationStructureMemoryRequirementsInfoNV::pname:accelerationStructure
    set to pname:dst and
    slink:VkAccelerationStructureMemoryRequirementsInfoNV::pname:type set to
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV
    must: be less than or equal to the size of pname:scratch minus
    pname:scratchOffset
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-02492]]
    If pname:update is ename:VK_TRUE, the pname:size member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetAccelerationStructureMemoryRequirementsNV with
    slink:VkAccelerationStructureMemoryRequirementsInfoNV::pname:accelerationStructure
    set to pname:dst and
    slink:VkAccelerationStructureMemoryRequirementsInfoNV::pname:type set to
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV
    must: be less than or equal to the size of pname:scratch minus
    pname:scratchOffset
  * [[VUID-vkCmdBuildAccelerationStructureNV-scratch-03522]]
    pname:scratch must: have been created with
    ename:VK_BUFFER_USAGE_RAY_TRACING_BIT_NV usage flag
  * [[VUID-vkCmdBuildAccelerationStructureNV-instanceData-03523]]
    If pname:instanceData is not dlink:VK_NULL_HANDLE, pname:instanceData
    must: have been created with ename:VK_BUFFER_USAGE_RAY_TRACING_BIT_NV
    usage flag
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-03524]]
    If pname:update is ename:VK_TRUE, then objects that were previously
    active must: not be made inactive as per
    <<acceleration-structure-inactive-prims>>
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-03525]]
    If pname:update is ename:VK_TRUE, then objects that were previously
    inactive must: not be made active as per
    <<acceleration-structure-inactive-prims>>
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-03526]]
    If pname:update is ename:VK_TRUE, the pname:src and pname:dst objects
    must: either be the same object or not have any
    <<resources-memory-aliasing, memory aliasing>>

****

include::{generated}/validity/protos/vkCmdBuildAccelerationStructureNV.txt[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_ray_tracing[]
[open,refpage='vkCmdBuildAccelerationStructureKHR',desc='Build an acceleration structure',type='protos']
--
:refpage: vkCmdBuildAccelerationStructureKHR

To build acceleration structures call:

include::{generated}/api/protos/vkCmdBuildAccelerationStructureKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:infoCount is the number of acceleration structures to build.
    It specifies the number of the pname:pInfos structures and
    pname:ppOffsetInfos pointers that must: be provided.
  * pname:pInfos is an array of pname:infoCount
    slink:VkAccelerationStructureBuildGeometryInfoKHR structures defining
    the geometry used to build each acceleration structure.
  * pname:ppOffsetInfos is an array of pname:infoCount pointers to arrays of
    slink:VkAccelerationStructureBuildOffsetInfoKHR structures.
    Each pname:ppOffsetInfos[i] is an array of
    pname:pInfos[i].pname:geometryCount
    slink:VkAccelerationStructureBuildOffsetInfoKHR structures defining
    dynamic offsets to the addresses where geometry data is stored, as
    defined by pname:pInfos[i].

The fname:vkCmdBuildAccelerationStructureKHR command provides the ability to
initiate multiple acceleration structures builds, however there is no
ordering or synchronization implied between any of the individual
acceleration structure builds.

[NOTE]
.Note
====
This means that an application cannot: build a top-level acceleration
structure in the same flink:vkCmdBuildAccelerationStructureKHR call as the
associated bottom-level or instance acceleration structures are being built.
There also cannot: be any memory aliasing between any acceleration structure
memories or scratch memories being used by any of the builds.
====

.Valid Usage
****
include::{chapters}/commonvalidity/build_acceleration_structure_common.txt[]
  * [[VUID-vkCmdBuildAccelerationStructureKHR-update-03527]]
    If pname:update is ename:VK_FALSE, all addresses between
    pname:pInfos[i].pname:scratchData and pname:pInfos[i].pname:scratchData
    + N - 1 must: be in the buffer device address range of the same buffer,
    where N is given by the pname:size member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetAccelerationStructureMemoryRequirementsKHR with
    slink:VkAccelerationStructureMemoryRequirementsInfoKHR::pname:accelerationStructure
    set to pname:pInfos[i].pname:dstAccelerationStructure and
    slink:VkAccelerationStructureMemoryRequirementsInfoKHR::pname:type set
    to
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_KHR
  * [[VUID-vkCmdBuildAccelerationStructureKHR-update-03528]]
    If pname:update is ename:VK_TRUE, all addresses between
    pname:pInfos[i].pname:scratchData and pname:pInfos[i].pname:scratchData
    + N - 1 must: be in the buffer device address range of the same buffer,
    where N is given by the pname:size member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetAccelerationStructureMemoryRequirementsKHR with
    slink:VkAccelerationStructureMemoryRequirementsInfoKHR::pname:accelerationStructure
    set to pname:pInfos[i].pname:dstAccelerationStructure and
    slink:VkAccelerationStructureMemoryRequirementsInfoKHR::pname:type set
    to
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_KHR
  * [[VUID-vkCmdBuildAccelerationStructureKHR-pInfos-03529]]
    The buffer from which the buffer device address
    pname:pInfos[i].pname:scratchData is queried must: have been created
    with ename:VK_BUFFER_USAGE_RAY_TRACING_BIT_KHR usage flag
  * [[VUID-vkCmdBuildAccelerationStructureKHR-None-04046]]
    All slink:VkDeviceOrHostAddressKHR or
    slink:VkDeviceOrHostAddressConstKHR referenced by this command must:
    contain valid device addresses for a buffer bound to device memory.
    If the buffer is non-sparse then it must: be bound completely and
    contiguously to a single VkDeviceMemory object
  * [[VUID-vkCmdBuildAccelerationStructureKHR-None-03531]]
    All sname:VkAccelerationStructureKHR objects referenced by this command
    must: be bound to device memory
ifdef::VK_KHR_deferred_host_operations[]
  * [[VUID-vkCmdBuildAccelerationStructureKHR-pNext-03532]]
    The slink:VkDeferredOperationInfoKHR structure must: not be included in
    the pname:pNext chain of any of the provided
    slink:VkAccelerationStructureBuildGeometryInfoKHR structures
endif::VK_KHR_deferred_host_operations[]
****

include::{generated}/validity/protos/vkCmdBuildAccelerationStructureKHR.txt[]
--

[open,refpage='vkCmdBuildAccelerationStructureIndirectKHR',desc='Build an acceleration structure with some parameters provided on the device',type='protos']
--
:refpage: vkCmdBuildAccelerationStructureIndirectKHR

To build an acceleration structure with some parameters sourced on the
device call:

include::{generated}/api/protos/vkCmdBuildAccelerationStructureIndirectKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pInfo is a pointer to a
    slink:VkAccelerationStructureBuildGeometryInfoKHR structure defining the
    geometry used to build the acceleration structure.
  * pname:indirectBuffer is the slink:VkBuffer containing
    pname:pInfo->geometryCount
    slink:VkAccelerationStructureBuildOffsetInfoKHR structures defining
    dynamic offsets to the addresses where geometry data is stored, as
    defined by pname:pInfo.
  * pname:indirectOffset is the byte offset into pname:indirectBuffer where
    offset parameters begin.
  * pname:stride is the byte stride between successive sets of offset
    parameters.

.Valid Usage
****
// TODO
  * [[VUID-vkCmdBuildAccelerationStructureIndirectKHR-None-04047]]
    All slink:VkDeviceOrHostAddressKHR or
    slink:VkDeviceOrHostAddressConstKHR referenced by this command must:
    contain valid device addresses for a buffer bound to device memory.
    If the buffer is non-sparse then it must: be bound completely and
    contiguously to a single VkDeviceMemory object
  * [[VUID-vkCmdBuildAccelerationStructureIndirectKHR-None-03534]]
    All sname:VkAccelerationStructureKHR objects referenced by this command
    must: be bound to device memory
  * [[VUID-vkCmdBuildAccelerationStructureIndirectKHR-rayTracingIndirectAccelerationStructureBuild-03535]]
    The <<features-raytracing-indirectasbuild,
    sname:VkPhysicalDeviceRayTracingFeaturesKHR::pname:rayTracingIndirectAccelerationStructureBuild>>
    feature must: be enabled
ifdef::VK_KHR_deferred_host_operations[]
  * [[VUID-vkCmdBuildAccelerationStructureIndirectKHR-pNext-03536]]
    The slink:VkDeferredOperationInfoKHR structure must: not be included in
    the pname:pNext chain of any of the provided
    slink:VkAccelerationStructureBuildGeometryInfoKHR structures
endif::VK_KHR_deferred_host_operations[]
****

include::{generated}/validity/protos/vkCmdBuildAccelerationStructureIndirectKHR.txt[]
--


[open,refpage='VkAccelerationStructureBuildGeometryInfoKHR',desc='Structure specifying the geometry data used to build an acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureBuildGeometryInfoKHR

The sname:VkAccelerationStructureBuildGeometryInfoKHR structure is defined
as:

include::{generated}/api/structs/VkAccelerationStructureBuildGeometryInfoKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:type is a elink:VkAccelerationStructureTypeKHR value specifying
    the type of acceleration structure being built.
  * pname:flags is a bitmask of
    elink:VkBuildAccelerationStructureFlagBitsKHR specifying additional
    parameters of the acceleration structure.
  * pname:update specifies whether to update pname:dstAccelerationStructure
    with the data in pname:srcAccelerationStructure or not.
  * pname:srcAccelerationStructure points to an existing acceleration
    structure that is to be used to update the pname:dst acceleration
    structure when pname:update is ename:VK_TRUE.
  * pname:dstAccelerationStructure points to the target acceleration
    structure for the build.
  * pname:geometryArrayOfPointers specifies whether pname:ppGeometries is
    used as a pointer to an array of pointers or a pointer to a pointer to
    an array.
  * pname:geometryCount specifies the number of geometries that will be
    built into pname:dstAccelerationStructure.
  * pname:ppGeometries is either a pointer to an array of pointers to
    slink:VkAccelerationStructureGeometryKHR structures if
    pname:geometryArrayOfPointers is ename:VK_TRUE, or a pointer to a
    pointer to an array of slink:VkAccelerationStructureGeometryKHR
    structures if it is ename:VK_FALSE.
    Each element of the array describes the data used to build each
    acceleration structure geometry.
  * pname:scratchData is the device or host address to memory that will be
    used as scratch memory for the build.

[NOTE]
.Note
====
Elements of pname:ppGeometries are accessed as follows, based on
pname:geometryArrayOfPointers:

[source,c]
---------------------------------------------------
if (geometryArrayOfPointers) {
    use *(ppGeometries[i]);
} else {
    use (*ppGeometries)[i];
}
---------------------------------------------------
====

.Valid Usage
****
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-update-03537]]
    If pname:update is ename:VK_TRUE, pname:srcAccelerationStructure must:
    not be dlink:VK_NULL_HANDLE
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-update-03538]]
    If pname:update is ename:VK_TRUE, pname:srcAccelerationStructure must:
    have been built before with
    ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR set in
    slink:VkAccelerationStructureBuildGeometryInfoKHR::pname:flags
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-scratchData-03539]]
    pname:scratchData must: have been created with
    ename:VK_BUFFER_USAGE_RAY_TRACING_BIT_KHR usage flag
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-update-03540]]
    If pname:update is ename:VK_TRUE, the pname:srcAccelerationStructure and
    pname:dstAccelerationStructure objects must: either be the same object
    or not have any <<resources-memory-aliasing, memory aliasing>>
****

include::{generated}/validity/structs/VkAccelerationStructureBuildGeometryInfoKHR.txt[]
--

[open,refpage='VkDeviceOrHostAddressKHR',desc='Union specifying a device or host address',type='structs']
--
:refpage: VkDeviceOrHostAddressKHR

The sname:VkDeviceOrHostAddressKHR union is defined as:

include::{generated}/api/structs/VkDeviceOrHostAddressKHR.txt[]

  * pname:deviceAddress is a buffer device address as returned by the
    flink:vkGetBufferDeviceAddressKHR command.
  * pname:hostAddress is a host memory address.

include::{generated}/validity/structs/VkDeviceOrHostAddressKHR.txt[]
--

[open,refpage='VkDeviceOrHostAddressConstKHR',desc='Union specifying a const device or host address',type='structs']
--
:refpage: VkDeviceOrHostAddressConstKHR

The sname:VkDeviceOrHostAddressConstKHR union is defined as:

include::{generated}/api/structs/VkDeviceOrHostAddressConstKHR.txt[]

  * pname:deviceAddress is a buffer device address as returned by the
    flink:vkGetBufferDeviceAddressKHR command.
  * pname:hostAddress is a const host memory address.

include::{generated}/validity/structs/VkDeviceOrHostAddressConstKHR.txt[]
--

[open,refpage='VkAccelerationStructureGeometryKHR',desc='Structure specifying geometries to be built into an acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureGeometryKHR

The sname:VkAccelerationStructureGeometryKHR structure is defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:geometryType describes which type of geometry this
    sname:VkAccelerationStructureGeometryKHR refers to.
  * pname:geometry is a slink:VkAccelerationStructureGeometryDataKHR union
    describing the geometry data for the relevant geometry type.
  * pname:flags is a bitmask of elink:VkGeometryFlagBitsKHR values
    describing additional properties of how the geometry should be built.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureGeometryKHR-geometryType-03541]]
    If pname:geometryType is ename:VK_GEOMETRY_TYPE_AABBS_KHR, the
    pname:aabbs member of pname:geometry must: be a valid
    slink:VkAccelerationStructureGeometryAabbsDataKHR structure
  * [[VUID-VkAccelerationStructureGeometryKHR-geometryType-03542]]
    If pname:geometryType is ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, the
    pname:triangles member of pname:geometry must: be a valid
    slink:VkAccelerationStructureGeometryTrianglesDataKHR structure
  * [[VUID-VkAccelerationStructureGeometryKHR-geometryType-03543]]
    If pname:geometryType is ename:VK_GEOMETRY_TYPE_INSTANCES_KHR, the
    pname:instances member of pname:geometry must: be a valid
    slink:VkAccelerationStructureGeometryInstancesDataKHR structure
****

include::{generated}/validity/structs/VkAccelerationStructureGeometryKHR.txt[]
--

[open,refpage='VkAccelerationStructureGeometryDataKHR',desc='Union specifying acceleration structure geometry data',type='structs']
--
:refpage: VkAccelerationStructureGeometryDataKHR

The sname:VkAccelerationStructureGeometryDataKHR union is defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryDataKHR.txt[]

  * pname:triangles is a
    slink:VkAccelerationStructureGeometryTrianglesDataKHR structure.
  * pname:aabbs is a slink:VkAccelerationStructureGeometryAabbsDataKHR
    struture.
  * pname:instances is a
    slink:VkAccelerationStructureGeometryInstancesDataKHR structure.

include::{generated}/validity/structs/VkAccelerationStructureGeometryDataKHR.txt[]
--

[open,refpage='VkAccelerationStructureGeometryTrianglesDataKHR',desc='Structure specifying a triangle geometry in a bottom-level acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureGeometryTrianglesDataKHR

The sname:VkAccelerationStructureGeometryTrianglesDataKHR structure is
defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryTrianglesDataKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:vertexFormat is the elink:VkFormat of each vertex element.
  * pname:vertexData is a device or host address to memory containing vertex
    data for this geometry.
  * pname:vertexStride is the stride in bytes between each vertex.
  * pname:indexType is the elink:VkIndexType of each index element.
  * pname:indexData is the device or host address to memory containing index
    data for this geometry.
  * pname:transformData is a device or host address to memory containing an
    optional reference to a slink:VkTransformMatrixKHR structure defining a
    transformation that should be applied to vertices in this geometry.

.Valid Usage
****
// TODO
****

include::{generated}/validity/structs/VkAccelerationStructureGeometryTrianglesDataKHR.txt[]
--
endif::VK_KHR_ray_tracing[]

[open,refpage='VkTransformMatrixKHR',desc='Structure specifying a 3x4 affine transformation matrix',type='structs',alias='VkTransformMatrixNV']
--
:refpage: VkTransformMatrixKHR

The sname:VkTransformMatrixKHR structure is defined as:

include::{generated}/api/structs/VkTransformMatrixKHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/structs/VkTransformMatrixNV.txt[]
endif::VK_NV_ray_tracing[]

  * pname:matrix is a 3x4 row-major affine transformation matrix.

include::{generated}/validity/structs/VkTransformMatrixKHR.txt[]
--

ifdef::VK_KHR_ray_tracing[]
[open,refpage='VkAccelerationStructureGeometryAabbsDataKHR',desc='Structure specifying axis-aligned bounding box geometry in a bottom-level acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureGeometryAabbsDataKHR

The sname:VkAccelerationStructureGeometryAabbsDataKHR structure is defined
as:

include::{generated}/api/structs/VkAccelerationStructureGeometryAabbsDataKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:data is a device or host address to memory containing
    slink:VkAabbPositionsKHR structures containing position data for each
    axis-aligned bounding box in the geometry.
  * pname:stride is the stride in bytes between each entry in pname:data.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureGeometryAabbsDataKHR-data-03544]]
    pname:data must: be aligned to `8` bytes
  * [[VUID-VkAccelerationStructureGeometryAabbsDataKHR-stride-03545]]
    pname:stride must: be a multiple of `8`
****

include::{generated}/validity/structs/VkAccelerationStructureGeometryAabbsDataKHR.txt[]
--
endif::VK_KHR_ray_tracing[]

[open,refpage='VkAabbPositionsKHR',desc='Structure specifying two opposing corners of an axis-aligned bounding box',type='structs',alias='VkAabbPositionsNV']
--
:refpage: VkAabbPositionsKHR

An axis-aligned bounding box positions are defined by the structure:

include::{generated}/api/structs/VkAabbPositionsKHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/structs/VkAabbPositionsNV.txt[]
endif::VK_NV_ray_tracing[]


  * pname:minX is the x position of one opposing corner of a bounding box.
  * pname:minY is the y position of one opposing corner of a bounding box.
  * pname:minZ is the z position of one opposing corner of a bounding box.
  * pname:maxX is the x position of the other opposing corner of a bounding
    box.
  * pname:maxY is the y position of the other opposing corner of a bounding
    box.
  * pname:maxZ is the z position of the other opposing corner of a bounding
    box.

.Valid Usage
****
  * [[VUID-VkAabbPositionsKHR-minX-03546]]
    pname:minX must: be less than or equal to pname:maxX
  * [[VUID-VkAabbPositionsKHR-minY-03547]]
    pname:minY must: be less than or equal to pname:maxY
  * [[VUID-VkAabbPositionsKHR-minZ-03548]]
    pname:minZ must: be less than or equal to pname:maxZ
****

include::{generated}/validity/structs/VkAabbPositionsKHR.txt[]
--

ifdef::VK_KHR_ray_tracing[]
[open,refpage='VkAccelerationStructureGeometryInstancesDataKHR',desc='Structure specifying a geometry consisting of instances of other acceleration structures',type='structs']
--
:refpage: VkAccelerationStructureGeometryInstancesDataKHR

The sname:VkAccelerationStructureGeometryInstancesDataKHR structure is
defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryInstancesDataKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:arrayOfPointers specifies whether pname:data is used as an array
    of addresses or just an array.
  * pname:data is either the address of an array of device or host addresses
    referencing individual slink:VkAccelerationStructureInstanceKHR
    structures if pname:arrayOfPointers is ename:VK_TRUE, or the address of
    an array of slink:VkAccelerationStructureInstanceKHR structures.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureGeometryInstancesDataKHR-data-03549]]
    pname:data must: be aligned to `16` bytes
  * [[VUID-VkAccelerationStructureGeometryInstancesDataKHR-arrayOfPointers-03550]]
    If pname:arrayOfPointers is true, each pointer must: be aligned to `16`
    bytes
****

include::{generated}/validity/structs/VkAccelerationStructureGeometryInstancesDataKHR.txt[]
--
endif::VK_KHR_ray_tracing[]

[open,refpage='VkAccelerationStructureInstanceKHR',desc='Structure specifying a single acceleration structure instance for building into an acceleration structure geometry',type='structs',alias='VkAccelerationStructureInstanceNV']
--
:refpage: VkAccelerationStructureInstanceKHR

_Acceleration structure instances_ can: be built into top-level acceleration
structures.
Each acceleration structure instance is a separate entry in the top-level
acceleration structure which includes all the geometry of a bottom-level
acceleration structure at a transformed location.
Multiple instances can: point to the same bottom level acceleration
structure.

An acceleration structure instance is defined by the structure:

include::{generated}/api/structs/VkAccelerationStructureInstanceKHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/structs/VkAccelerationStructureInstanceNV.txt[]
endif::VK_NV_ray_tracing[]

  * pname:transform is a slink:VkTransformMatrixKHR structure describing a
    transformation to be applied to the acceleration structure.
  * pname:instanceCustomIndex a 24-bit user-specified index value accessible
    to ray shaders in the code:InstanceCustomIndexKHR built-in.
  * pname:mask is an 8-bit visibility mask for the geometry.
    The instance may: only be hit if `rayMask & instance.mask != 0`
  * pname:instanceShaderBindingTableRecordOffset is a 24-bit offset used in
    calculating the hit shader binding table index.
  * pname:flags is an 8-bit mask of elink:VkGeometryInstanceFlagBitsKHR
    values to apply to this instance.
  * pname:accelerationStructureReference is either:
  ** a device address containing the value obtained from
ifdef::VK_KHR_ray_tracing[flink:vkGetAccelerationStructureDeviceAddressKHR]
ifdef::VK_KHR_ray_tracing+VK_NV_ray_tracing[or]
ifdef::VK_NV_ray_tracing[flink:vkGetAccelerationStructureHandleNV]
     (used by device operations which reference acceleration structures) or,
  ** a slink:VkAccelerationStructureKHR object (used by host operations
     which reference acceleration structures).

The C language spec does not define the ordering of bit-fields, but in
practice, this struct produces the correct layout with existing compilers.
The intended bit pattern is for the following:

  * pname:instanceCustomIndex and pname:mask occupy the same memory as if a
    single code:int32_t was specified in their place
  ** pname:instanceCustomIndex occupies the 24 least significant bits of
     that memory
  ** pname:mask occupies the 8 most significant bits of that memory
  * pname:instanceShaderBindingTableRecordOffset and pname:flags occupy the
    same memory as if a single code:int32_t was specified in their place
  ** pname:instanceShaderBindingTableRecordOffset occupies the 24 least
     significant bits of that memory
  ** pname:flags occupies the 8 most significant bits of that memory

If a compiler produces code that diverges from that pattern, applications
must: employ another method to set values according to the correct bit
pattern.

.Valid Usage
****
// TODO
****

include::{generated}/validity/structs/VkAccelerationStructureInstanceKHR.txt[]
--

[open,refpage='VkGeometryInstanceFlagBitsKHR',desc='Instance flag bits',type='enums',alias='VkGeometryInstanceFlagBitsNV']
--
:refpage: VkGeometryInstanceFlagBitsKHR

Possible values of pname:flags in the instance modifying the behavior of
that instance are:,

include::{generated}/api/enums/VkGeometryInstanceFlagBitsKHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/enums/VkGeometryInstanceFlagBitsNV.txt[]
endif::VK_NV_ray_tracing[]

  * ename:VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR disables
    face culling for this instance.
  * ename:VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR
    indicates that the front face of the triangle for culling purposes is
    the face that is counter clockwise in object space relative to the ray
    origin.
    Because the facing is determined in object space, an instance transform
    matrix does not change the winding, but a geometry transform does.
  * ename:VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR causes this instance to
    act as though ename:VK_GEOMETRY_OPAQUE_BIT_KHR were specified on all
    geometries referenced by this instance.
    This behavior can: be overridden by the SPIR-V code:NoOpaqueKHR ray
    flag.
  * ename:VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR causes this instance
    to act as though ename:VK_GEOMETRY_OPAQUE_BIT_KHR were not specified on
    all geometries referenced by this instance.
    This behavior can: be overridden by the SPIR-V code:OpaqueKHR ray flag.

ename:VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR and
ename:VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR must: not be used in the
same flag.

--

[open,refpage='VkGeometryInstanceFlagsKHR',desc='Bitmask of VkGeometryInstanceFlagBitsKHR',type='flags',alias='VkGeometryInstanceFlagsNV']
--
:refpage: VkGeometryInstanceFlagsKHR

include::{generated}/api/flags/VkGeometryInstanceFlagsKHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/flags/VkGeometryInstanceFlagsNV.txt[]
endif::VK_NV_ray_tracing[]

tname:VkGeometryInstanceFlagsKHR is a bitmask type for setting a mask of
zero or more elink:VkGeometryInstanceFlagBitsKHR.
--

ifdef::VK_KHR_ray_tracing[]

[open,refpage='VkAccelerationStructureBuildOffsetInfoKHR',desc='Structure specifying build offsets and counts for acceleration structure builds',type='structs']
--
:refpage: VkAccelerationStructureBuildOffsetInfoKHR

sname:VkAccelerationStructureBuildOffsetInfoKHR is defined as:

include::{generated}/api/structs/VkAccelerationStructureBuildOffsetInfoKHR.txt[]

  * pname:primitiveCount defines the number of primitives for a
    corresponding acceleration structure geometry.
  * pname:primitiveOffset defines an offset in bytes into the memory where
    primitive data is defined.
  * pname:firstVertex is the index of the first vertex to build from for
    triangle geometry.
  * pname:transformOffset defines an offset in bytes into the memory where a
    transform matrix is defined.

The primitive count and primitive offset are interpreted differently
depending on the elink:VkGeometryTypeKHR used:

  * For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR,
    pname:primitiveCount is the number of triangles to be built, where each
    triangle is treated as 3 vertices.
  ** If the geometry uses indices, [eq]#pname:primitiveCount {times} 3#
     indices are consumed from
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:indexData,
     starting at an offset of pname:primitiveOffset.
     The value of pname:firstVertex is added to the index values before
     fetching vertices.
  ** If the geometry does not use indices, [eq]#pname:primitiveCount {times}
     3# vertices are consumed from
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexData,
     starting at an offset of [eq]#pname:primitiveOffset {plus}
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexStride
     {times} pname:firstVertex#.
  ** A single slink:VkTransformMatrixKHR structure is consumed from
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:transformData,
     at an offset of pname:transformOffset.
     This transformation matrix is used by all triangles.

  * For geometries of type ename:VK_GEOMETRY_TYPE_AABBS_KHR,
    pname:primitiveCount is the number of axis-aligned bounding boxes.
    pname:primitiveCount slink:VkAabbPositionsKHR structures are consumed
    from slink:VkAccelerationStructureGeometryAabbsDataKHR::pname:data,
    starting at an offset of pname:primitiveOffset.
  * For geometries of type ename:VK_GEOMETRY_TYPE_INSTANCES_KHR,
    pname:primitiveCount is the number of acceleration structures.
    pname:primitiveCount slink:VkAccelerationStructureInstanceKHR structures
    are consumed from
    slink:VkAccelerationStructureGeometryInstancesDataKHR::pname:data,
    starting at an offset of pname:primitiveOffset.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureBuildOffsetInfoKHR-primitiveOffset-03551]]
    For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if the
    geometry uses indices, the offset pname:primitiveOffset from
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:indexData
    must: be a multiple of the element size of
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:indexType
  * [[VUID-VkAccelerationStructureBuildOffsetInfoKHR-primitiveOffset-03552]]
    For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if the
    geometry doesn't use indices, the offset pname:primitiveOffset from
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexData
    must: be a multiple of the component size of
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexType
  * [[VUID-VkAccelerationStructureBuildOffsetInfoKHR-transformOffset-03553]]
    For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, the offset
    pname:transformOffset from
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:transformData
    must: be a multiple of 16
  * [[VUID-VkAccelerationStructureBuildOffsetInfoKHR-primitiveOffset-03554]]
    For geometries of type ename:VK_GEOMETRY_TYPE_AABBS_KHR, the offset
    pname:primitiveOffset from
    slink:VkAccelerationStructureGeometryAabbsDataKHR::pname:data must: be a
    multiple of 8
  * [[VUID-VkAccelerationStructureBuildOffsetInfoKHR-primitiveOffset-03555]]
    For geometries of type ename:VK_GEOMETRY_TYPE_INSTANCES_KHR, the offset
    pname:primitiveOffset from
    slink:VkAccelerationStructureGeometryInstancesDataKHR::pname:data must:
    be a multiple of 16
  // TODO - Almost certainly should be more here
****

include::{generated}/validity/structs/VkAccelerationStructureBuildOffsetInfoKHR.txt[]
--

endif::VK_KHR_ray_tracing[]


[[acceleration-structure-copying]]
=== Copying Acceleration Structures

An additional command exists for copying acceleration structures without
updating their contents.
The acceleration structure object can: be compacted in order to improve
performance.
Before copying, an application must: query the size of the resulting
acceleration structure.

[open,refpage='vkCmdWriteAccelerationStructuresPropertiesKHR',desc='Write acceleration structure result parameters to query results.',type='protos',alias='vkCmdWriteAccelerationStructuresPropertiesNV']
--
:refpage: vkCmdWriteAccelerationStructuresPropertiesKHR

To query acceleration structure size parameters call:

ifdef::VK_KHR_ray_tracing[]
include::{generated}/api/protos/vkCmdWriteAccelerationStructuresPropertiesKHR.txt[]
endif::VK_KHR_ray_tracing[]

ifdef::VK_KHR_ray_tracing+VK_NV_ray_tracing[or the equivalent command]

ifdef::VK_NV_ray_tracing[]
include::{generated}/api/protos/vkCmdWriteAccelerationStructuresPropertiesNV.txt[]
endif::VK_NV_ray_tracing[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:accelerationStructureCount is the count of acceleration structures
    for which to query the property.
  * pname:pAccelerationStructures is a pointer to an array of existing
    previously built acceleration structures.
  * pname:queryType is a elink:VkQueryType value specifying the type of
    queries managed by the pool.
  * pname:queryPool is the query pool that will manage the results of the
    query.
  * pname:firstQuery is the first query index within the query pool that
    will contain the pname:accelerationStructureCount number of results.

.Valid Usage
****
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryPool-02493]]
    pname:queryPool must: have been created with a pname:queryType matching
    pname:queryType
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryPool-02494]]
    The queries identified by pname:queryPool and pname:firstQuery must: be
    _unavailable_
include::{chapters}/commonvalidity/write_acceleration_structure_properties_common.txt[]
****

include::{generated}/validity/protos/vkCmdWriteAccelerationStructuresPropertiesKHR.txt[]
--

ifdef::VK_NV_ray_tracing[]
[open,refpage='vkCmdCopyAccelerationStructureNV',desc='Copy an acceleration structure',type='protos']
--
:refpage: vkCmdCopyAccelerationStructureNV

To copy an acceleration structure call:

include::{generated}/api/protos/vkCmdCopyAccelerationStructureNV.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:dst is a pointer to the target acceleration structure for the
    copy.
  * pname:src is a pointer to the source acceleration structure for the
    copy.
  * pname:mode is a elink:VkCopyAccelerationStructureModeKHR value
    specifying additional operations to perform during the copy.

.Valid Usage
****
include::{chapters}/commonvalidity/copy_acceleration_structure_common.txt[]
****

include::{generated}/validity/protos/vkCmdCopyAccelerationStructureNV.txt[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_ray_tracing[]
[open,refpage='vkCmdCopyAccelerationStructureKHR',desc='Copy an acceleration structure',type='protos']
--
:refpage: vkCmdCopyAccelerationStructureKHR

To copy an acceleration structure call:

include::{generated}/api/protos/vkCmdCopyAccelerationStructureKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pInfo is a pointer to a slink:VkCopyAccelerationStructureInfoKHR
    structure defining the copy operation.

.Valid Usage
****
  * [[VUID-vkCmdCopyAccelerationStructureKHR-None-03556]]
    All sname:VkAccelerationStructureKHR objects referenced by this command
    must: be bound to device memory
ifdef::VK_KHR_deferred_host_operations[]
  * [[VUID-vkCmdCopyAccelerationStructureKHR-pNext-03557]]
    The slink:VkDeferredOperationInfoKHR structure must: not be included in
    the pname:pNext chain of the slink:VkCopyAccelerationStructureInfoKHR
    structure
endif::VK_KHR_deferred_host_operations[]
****

include::{generated}/validity/protos/vkCmdCopyAccelerationStructureKHR.txt[]
--

[open,refpage='VkCopyAccelerationStructureInfoKHR',desc='Parameters for copying an acceleration structure',type='structs']
--
:refpage: VkCopyAccelerationStructureInfoKHR

The sname:VkCopyAccelerationStructureInfoKHR structure is defined as:

include::{generated}/api/structs/VkCopyAccelerationStructureInfoKHR.txt[]

  * pname:src is the source acceleration structure for the copy.
  * pname:dst is the target acceleration structure for the copy.
  * pname:mode is a elink:VkCopyAccelerationStructureModeKHR value that
    specifies additional operations to perform during the copy.

.Valid Usage
****
include::{chapters}/commonvalidity/copy_acceleration_structure_common.txt[]
****

include::{generated}/validity/structs/VkCopyAccelerationStructureInfoKHR.txt[]
--
endif::VK_KHR_ray_tracing[]

[open,refpage='VkCopyAccelerationStructureModeKHR',desc='Acceleration structure copy mode',type='enums',alias='VkCopyAccelerationStructureModeNV']
--
:refpage: VkCopyAccelerationStructureModeKHR

Possible values of pname:mode specifying additional operations to perform
during the copy, are:

include::{generated}/api/enums/VkCopyAccelerationStructureModeKHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/enums/VkCopyAccelerationStructureModeNV.txt[]
endif::VK_NV_ray_tracing[]

  * ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR creates a direct
    copy of the acceleration structure specified in pname:src into the one
    specified by pname:dst.
    The pname:dst acceleration structure must: have been created with the
    same parameters as pname:src.
  * ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR creates a more
    compact version of an acceleration structure pname:src into pname:dst.
    The acceleration structure pname:dst must: have been created with a
    pname:compactedSize corresponding to the one returned by
    flink:vkCmdWriteAccelerationStructuresPropertiesKHR after the build of
    the acceleration structure specified by pname:src.
  * ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR serializes the
    acceleration structure to a semi-opaque format which can be reloaded on
    a compatible implementation.
  * ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR deserializes
    the semi-opaque serialization format in the buffer to the acceleration
    structure.
--

[open,refpage='vkCmdCopyAccelerationStructureToMemoryKHR',desc='Copy an acceleration structure to device memory',type='protos']
--
:refpage: vkCmdCopyAccelerationStructureToMemoryKHR

To copy an acceleration structure to device memory call:

include::{generated}/api/protos/vkCmdCopyAccelerationStructureToMemoryKHR.txt[]

This command produces the same results as
flink:vkCopyAccelerationStructureToMemoryKHR, but writes its result to a
device address, and is executed on the device rather than the host.
The output may: not necessarily be bit-for-bit identical, but it can be
equally used by either flink:vkCmdCopyMemoryToAccelerationStructureKHR or
flink:vkCopyMemoryToAccelerationStructureKHR.

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pInfo is an a pointer to a
    slink:VkCopyAccelerationStructureToMemoryInfoKHR structure defining the
    copy operation.

The defined header structure for the serialized data consists of:

  * ename:VK_UUID_SIZE bytes of data matching
    sname:VkPhysicalDeviceIDProperties::pname:driverUUID
  * ename:VK_UUID_SIZE bytes of data identifying the compatibility for
    comparison using flink:vkGetDeviceAccelerationStructureCompatibilityKHR
  * A 64-bit integer of the total size matching the value queried using
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR
  * A 64-bit integer of the deserialized size to be passed in to
    sname:VkAccelerationStructureCreateInfoKHR::pname:compactedSize
  * A 64-bit integer of the count of the number of acceleration structure
    handles following.
    This will be zero for a bottom-level acceleration structure.

The corresponding handles matching the values returned by
ifdef::VK_KHR_ray_tracing[flink:vkGetAccelerationStructureDeviceAddressKHR]
ifdef::VK_KHR_ray_tracing+VK_NV_ray_tracing[or]
ifdef::VK_NV_ray_tracing[flink:vkGetAccelerationStructureHandleNV]
are tightly packed in the buffer following the count.
The application is expected to store a mapping between those handles and the
original application-generated bottom-level acceleration structures to
provide when deserializing.


.Valid Usage
****
  * [[VUID-vkCmdCopyAccelerationStructureToMemoryKHR-None-04048]]
    All sname:VkDeviceOrHostAddressConstKHR referenced by this command must:
    contain valid device addresses for a buffer bound to device memory.
    If the buffer is non-sparse then it must: be bound completely and
    contiguously to a single VkDeviceMemory object
  * [[VUID-vkCmdCopyAccelerationStructureToMemoryKHR-None-03559]]
    All sname:VkAccelerationStructureKHR objects referenced by this command
    must: be bound to device memory
ifdef::VK_KHR_deferred_host_operations[]
  * [[VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pNext-03560]]
    The slink:VkDeferredOperationInfoKHR structure must: not be included in
    the pname:pNext chain of the
    slink:VkCopyAccelerationStructureToMemoryInfoKHR structure
endif::VK_KHR_deferred_host_operations[]
include::{chapters}/commonvalidity/copy_acceleration_structure_to_buffer_common.txt[]
****

include::{generated}/validity/protos/vkCmdCopyAccelerationStructureToMemoryKHR.txt[]
--

[open,refpage='VkCopyAccelerationStructureToMemoryInfoKHR',desc='Parameters for serializing an acceleration structure',type='structs']
--
:refpage: VkCopyAccelerationStructureToMemoryInfoKHR

include::{generated}/api/structs/VkCopyAccelerationStructureToMemoryInfoKHR.txt[]

  * pname:src is the source acceleration structure for the copy
  * pname:dst is the device or host address to memory which is the target
    for the copy
  * pname:mode is a elink:VkCopyAccelerationStructureModeKHR value that
    specifies additional operations to perform during the copy.

.Valid Usage
****
  * [[VUID-VkCopyAccelerationStructureToMemoryInfoKHR-dst-03561]]
     The memory pointed to by pname:dst must: be at least as large as the
     serialization size of pname:src, as reported by
     ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR
include::{chapters}/commonvalidity/copy_acceleration_structure_to_buffer_common.txt[]
****

include::{generated}/validity/structs/VkCopyAccelerationStructureToMemoryInfoKHR.txt[]
--

[open,refpage='vkCmdCopyMemoryToAccelerationStructureKHR',desc='Copy device memory to an acceleration structure',type='protos']
--
:refpage: vkCmdCopyMemoryToAccelerationStructureKHR

To copy device memory to an acceleration structure call:

include::{generated}/api/protos/vkCmdCopyMemoryToAccelerationStructureKHR.txt[]

This command can accept acceleration structures produced by either
flink:vkCmdCopyAccelerationStructureToMemoryKHR or
flink:vkCopyAccelerationStructureToMemoryKHR.

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pInfo is a pointer to a
    slink:VkCopyMemoryToAccelerationStructureInfoKHR structure defining the
    copy operation.

The structure provided as input to deserialize is as described in
flink:vkCmdCopyAccelerationStructureToMemoryKHR, with any acceleration
structure handles filled in with the newly-queried handles to bottom level
acceleration structures created before deserialization.
These do not need to be built at deserialize time, but must: be created.

.Valid Usage
****
  * [[VUID-vkCmdCopyMemoryToAccelerationStructureKHR-None-04049]]
    All sname:VkDeviceOrHostAddressKHR referenced by this command must:
    contain valid device addresses for a buffer bound to device memory.
    If the buffer is non-sparse then it must: be bound completely and
    contiguously to a single VkDeviceMemory object
  * [[VUID-vkCmdCopyMemoryToAccelerationStructureKHR-None-03563]]
    All sname:VkAccelerationStructureKHR objects referenced by this command
    must: be bound to device memory
ifdef::VK_KHR_deferred_host_operations[]
  * [[VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pNext-03564]]
    The slink:VkDeferredOperationInfoKHR structure must: not be included in
    the pname:pNext chain of the
    slink:VkCopyMemoryToAccelerationStructureInfoKHR structure
endif::VK_KHR_deferred_host_operations[]
include::{chapters}/commonvalidity/copy_buffer_to_acceleration_structure_common.txt[]
****

include::{generated}/validity/protos/vkCmdCopyMemoryToAccelerationStructureKHR.txt[]
--

[open,refpage='VkCopyMemoryToAccelerationStructureInfoKHR',desc='Parameters for deserializing an acceleration structure',type='structs']
--
:refpage: VkCopyMemoryToAccelerationStructureInfoKHR

The sname:VkCopyMemoryToAccelerationStructureInfoKHR structure is defined
as:

include::{generated}/api/structs/VkCopyMemoryToAccelerationStructureInfoKHR.txt[]

  * pname:src is the device or host address to memory containing the source
    data for the copy.
  * pname:dst is the target acceleration structure for the copy.
  * pname:mode is a elink:VkCopyAccelerationStructureModeKHR value that
    specifies additional operations to perform during the copy.

.Valid Usage
****
include::{chapters}/commonvalidity/copy_buffer_to_acceleration_structure_common.txt[]
****

include::{generated}/validity/structs/VkCopyMemoryToAccelerationStructureInfoKHR.txt[]
--

[open,refpage='vkGetDeviceAccelerationStructureCompatibilityKHR',desc='Check if a serialized acceleration structure is compatible with the current device',type='protos']
--
:refpage: vkGetDeviceAccelerationStructureCompatibilityKHR

To check if a serialized acceleration structure is compatible with the
current device call:

include::{generated}/api/protos/vkGetDeviceAccelerationStructureCompatibilityKHR.txt[]

  * pname:device is the device to check the version against.
  * pname:version points to the slink:VkAccelerationStructureVersionKHR
    version information to check against the device.

This possible return values for
fname:vkGetDeviceAccelerationStructureCompatibilityKHR are:

  * ename:VK_SUCCESS is returned if an acceleration structure serialized
    with pname:version as the version information is compatible with
    pname:device.
  * ename:VK_ERROR_INCOMPATIBLE_VERSION_KHR is returned if an acceleration
    structure serialized with pname:version as the version information is
    not compatible with pname:device.

.Valid Usage
****
// TBD
  * [[VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-rayTracing-03565]]
    The <<features-raytracing, pname:rayTracing>> or <<features-rayQuery,
    pname:rayQuery>> feature must: be enabled
****

include::{generated}/validity/protos/vkGetDeviceAccelerationStructureCompatibilityKHR.txt[]

--

[open,refpage='VkAccelerationStructureVersionKHR',desc='Acceleration structure version information',type='structs']
--
:refpage: VkAccelerationStructureVersionKHR

The sname:VkAccelerationStructureVersionKHR structure is defined as:

include::{generated}/api/structs/VkAccelerationStructureVersionKHR.txt[]

  * pname:versionData is a pointer to the version header as defined in
    elink:VkCopyAccelerationStructureModeKHR

.Valid Usage
****
// TBD
****

include::{generated}/validity/structs/VkAccelerationStructureVersionKHR.txt[]

--

include::raytracing-host-rtas.txt[]
