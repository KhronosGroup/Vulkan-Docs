// Copyright (c) 2015-2020 Khronos Group. This work is licensed under a
// Creative Commons Attribution 4.0 International License; see
// http://creativecommons.org/licenses/by/4.0/

[[features]]
= Features

_Features_ describe functionality which is not supported on all
implementations.
Features are properties of the physical device.
Features are optional:, and must: be explicitly enabled before use.
Support for features is reported and enabled on a per-feature basis.

ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
[NOTE]
.Note
====
Features are reported via the basic slink:VkPhysicalDeviceFeatures
structure, as well as the extensible structure
sname:VkPhysicalDeviceFeatures2, which was added in the
`<<VK_KHR_get_physical_device_properties2>>` extension and included in
Vulkan 1.1.
When new features are added in future Vulkan versions or extensions, each
extension should: introduce one new feature structure, if needed.
This structure can: be added to the pname:pNext chain of the
sname:VkPhysicalDeviceFeatures2 structure.
====
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

For convenience, new core versions of Vulkan may: introduce new unified
features structures for features promoted from extensions.
At the same time, the extension's original features structure (if any) is
also promoted to the core API, and is an alias of the extension's structure.
This results in multiple names for the same feature: in the original
extension's feature structure and the promoted structure alias, in the
unified feature structure.
When a feature was implicitly supported and enabled in the extension, but an
explicit name was added during promotion, then the extension itself acts as
an alias for the feature as listed in the table below.

All aliases of the same feature in the core API must: be reported
consistently: either all must: be reported as supported, or none of them.
When a promoted extension is available, any corresponding feature aliases
must: be supported.

[[features-extension-aliases]]
.Extension Feature Aliases

[width="100%",options="header"]
|====
| Extension                                 | Feature(s)
ifdef::VK_VERSION_1_2[]
ifdef::VK_KHR_draw_indirect_count[]
| `<<VK_KHR_draw_indirect_count>>`          | <<features-drawIndirectCount,drawIndirectCount>>
endif::VK_KHR_draw_indirect_count[]
ifdef::VK_KHR_sampler_mirror_clamp_to_edge[]
| `<<VK_KHR_sampler_mirror_clamp_to_edge>>` | <<features-samplerMirrorClampToEdge,samplerMirrorClampToEdge>>
endif::VK_KHR_sampler_mirror_clamp_to_edge[]
ifdef::VK_EXT_descriptor_indexing[]
| `<<VK_EXT_descriptor_indexing>>`          | <<features-descriptorIndexing,descriptorIndexing>>
endif::VK_EXT_descriptor_indexing[]
ifdef::VK_EXT_sampler_filter_minmax[]
| `<<VK_EXT_sampler_filter_minmax>>`        | <<features-samplerFilterMinmax,samplerFilterMinmax>>
endif::VK_EXT_sampler_filter_minmax[]
ifdef::VK_EXT_shader_viewport_index_layer[]
| `<<VK_EXT_shader_viewport_index_layer>>`  | <<features-shaderOutputViewportIndex,shaderOutputViewportIndex>>, <<features-shaderOutputLayer,shaderOutputLayer>>
endif::VK_EXT_shader_viewport_index_layer[]
endif::VK_VERSION_1_2[]
|====

[open,refpage='vkGetPhysicalDeviceFeatures',desc='Reports capabilities of a physical device',type='protos']
--
To query supported features, call:

include::{generated}/api/protos/vkGetPhysicalDeviceFeatures.txt[]

  * pname:physicalDevice is the physical device from which to query the
    supported features.
  * pname:pFeatures is a pointer to a slink:VkPhysicalDeviceFeatures
    structure in which the physical device features are returned.
    For each feature, a value of ename:VK_TRUE specifies that the feature is
    supported on this physical device, and ename:VK_FALSE specifies that the
    feature is not supported.

include::{generated}/validity/protos/vkGetPhysicalDeviceFeatures.txt[]
--

Fine-grained features used by a logical device must: be enabled at
sname:VkDevice creation time.
If a feature is enabled that the physical device does not support,
sname:VkDevice creation will fail and return
ename:VK_ERROR_FEATURE_NOT_PRESENT.

The fine-grained features are enabled by passing a pointer to the
sname:VkPhysicalDeviceFeatures structure via the pname:pEnabledFeatures
member of the slink:VkDeviceCreateInfo structure that is passed into the
fname:vkCreateDevice call.
If a member of pname:pEnabledFeatures is set to ename:VK_TRUE or
ename:VK_FALSE, then the device will be created with the indicated feature
enabled or disabled, respectively.
ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
Features can: also be enabled by using the slink:VkPhysicalDeviceFeatures2
structure.
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

If an application wishes to enable all features supported by a device, it
can: simply pass in the sname:VkPhysicalDeviceFeatures structure that was
previously returned by fname:vkGetPhysicalDeviceFeatures.
To disable an individual feature, the application can: set the desired
member to ename:VK_FALSE in the same structure.
Setting pname:pEnabledFeatures to `NULL`
ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
and not including a slink:VkPhysicalDeviceFeatures2 in the pname:pNext chain
of slink:VkDeviceCreateInfo
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
is equivalent to setting all members of the structure to ename:VK_FALSE.

[NOTE]
.Note
====
Some features, such as pname:robustBufferAccess, may: incur a runtime
performance cost.
Application writers should: carefully consider the implications of enabling
all supported features.
====

ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

[open,refpage='vkGetPhysicalDeviceFeatures2',desc='Reports capabilities of a physical device',type='protos']
--

To query supported features defined by the core or extensions, call:

ifdef::VK_VERSION_1_1[]
include::{generated}/api/protos/vkGetPhysicalDeviceFeatures2.txt[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_get_physical_device_properties2[or the equivalent command]

ifdef::VK_KHR_get_physical_device_properties2[]
include::{generated}/api/protos/vkGetPhysicalDeviceFeatures2KHR.txt[]
endif::VK_KHR_get_physical_device_properties2[]

  * pname:physicalDevice is the physical device from which to query the
    supported features.
  * pname:pFeatures is a pointer to a slink:VkPhysicalDeviceFeatures2
    structure in which the physical device features are returned.

Each structure in pname:pFeatures and its pname:pNext chain contains members
corresponding to fine-grained features.
fname:vkGetPhysicalDeviceFeatures2 writes each member to a boolean value
indicating whether that feature is supported.

include::{generated}/validity/protos/vkGetPhysicalDeviceFeatures2.txt[]
--

[open,refpage='VkPhysicalDeviceFeatures2',desc='Structure describing the fine-grained features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFeatures2 structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceFeatures2.txt[]

ifdef::VK_KHR_get_physical_device_properties2[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceFeatures2KHR.txt[]
endif::VK_KHR_get_physical_device_properties2[]

The sname:VkPhysicalDeviceFeatures2 structure is defined as:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:features is a slink:VkPhysicalDeviceFeatures structure describing
    the fine-grained features of the Vulkan 1.0 API.

The pname:pNext chain of this structure is used to extend the structure with
features defined by extensions.
This structure can: be used in flink:vkGetPhysicalDeviceFeatures2 or can: be
included in the pname:pNext chain of a slink:VkDeviceCreateInfo structure,
in which case it controls which features are enabled in the device in lieu
of pname:pEnabledFeatures.

include::{generated}/validity/structs/VkPhysicalDeviceFeatures2.txt[]
--

endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

[open,refpage='VkPhysicalDeviceFeatures',desc='Structure describing the fine-grained features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceFeatures.txt[]

The members of the sname:VkPhysicalDeviceFeatures structure describe the
following features:

  * [[features-robustBufferAccess]] pname:robustBufferAccess specifies that
    accesses to buffers are bounds-checked against the range of the buffer
    descriptor (as determined by sname:VkDescriptorBufferInfo::pname:range,
    slink:VkBufferViewCreateInfo::pname:range, or the size of the buffer).
    Out of bounds accesses must: not cause application termination, and the
    effects of shader loads, stores, and atomics must: conform to an
    implementation-dependent behavior as described below.
  ** A buffer access is considered to be out of bounds if any of the
     following are true:
  *** The pointer was formed by code:OpImageTexelPointer and the coordinate
      is less than zero or greater than or equal to the number of whole
      elements in the bound range.
  *** The pointer was not formed by code:OpImageTexelPointer and the object
      pointed to is not wholly contained within the bound range.
ifdef::VK_VERSION_1_1,VK_KHR_variable_pointers[]
      This includes accesses performed via _variable pointers_ where the
      buffer descriptor being accessed cannot be statically determined.
      Uninitialized pointers and pointers equal to code:OpConstantNull are
      treated as pointing to a zero-sized object, so all accesses through
      such pointers are considered to be out of bounds.
endif::VK_VERSION_1_1,VK_KHR_variable_pointers[]
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
      Buffer accesses through buffer device addresses are not
      bounds-checked.
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
ifdef::VK_NV_cooperative_matrix[]
      If the
      <<features-cooperativeMatrixRobustBufferAccess,pname:cooperativeMatrixRobustBufferAccess>>
      feature is not enabled, then accesses using
      code:OpCooperativeMatrixLoadNV and code:OpCooperativeMatrixStoreNV
      may: not be bounds-checked.
endif::VK_NV_cooperative_matrix[]
+
[NOTE]
.Note
====
If a SPIR-V code:OpLoad instruction loads a structure and the tail end of
the structure is out of bounds, then all members of the structure are
considered out of bounds even if the members at the end are not statically
used.
====

  *** If
ifdef::VK_EXT_robustness2[]
      <<features-robustBufferAccess2,pname:robustBufferAccess2>> is not
      enabled and
endif::VK_EXT_robustness2[]
      any buffer access is determined to be out of bounds, then any other
      access of the same type (load, store, or atomic) to the same buffer
      that accesses an address less than 16 bytes away from the out of
      bounds address may: also be considered out of bounds.
  *** If the access is a load that reads from the same memory locations as a
      prior store in the same shader invocation, with no other intervening
      accesses to the same memory locations in that shader invocation, then
      the result of the load may: be the value stored by the store
      instruction, even if the access is out of bounds.
      If the load is code:Volatile, then an out of bounds load must: return
      the appropriate out of bounds value.
ifdef::VK_EXT_robustness2[]
  ** Accesses to descriptors written with a dlink:VK_NULL_HANDLE resource or
     view are not considered to be out of bounds.
     Instead, each type of descriptor access defines a specific behavior for
     accesses to a null descriptor.
endif::VK_EXT_robustness2[]
  ** Out-of-bounds buffer loads will return any of the following values:
ifdef::VK_EXT_robustness2[]
  *** If the access is to a uniform buffer and
      <<features-robustBufferAccess2,pname:robustBufferAccess2>> is enabled,
      loads of offsets between the end of the descriptor range and the end
      of the descriptor range rounded up to a multiple of
      <<limits-robustUniformBufferAccessSizeAlignment,robustUniformBufferAccessSizeAlignment>>
      bytes must: return either zero values or the contents of the memory at
      the offset being loaded.
      Loads of offsets past the descriptor range rounded up to a multiple of
      <<limits-robustUniformBufferAccessSizeAlignment,robustUniformBufferAccessSizeAlignment>>
      bytes must: return zero values.
  *** If the access is to a storage buffer and
      <<features-robustBufferAccess2,pname:robustBufferAccess2>> is enabled,
      loads of offsets between the end of the descriptor range and the end
      of the descriptor range rounded up to a multiple of
      <<limits-robustStorageBufferAccessSizeAlignment,robustStorageBufferAccessSizeAlignment>>
      bytes must: return either zero values or the contents of the memory at
      the offset being loaded.
      Loads of offsets past the descriptor range rounded up to a multiple of
      <<limits-robustStorageBufferAccessSizeAlignment,robustStorageBufferAccessSizeAlignment>>
      bytes must: return zero values.
      Similarly, stores to addresses between the end of the descriptor range
      and the end of the descriptor range rounded up to a multiple of
      <<limits-robustStorageBufferAccessSizeAlignment,robustStorageBufferAccessSizeAlignment>>
      bytes may: be discarded.
  *** Non-atomic accesses to storage buffers that are a multiple of 32 bits
      may: be decomposed into 32-bit accesses that are individually
      bounds-checked.
  *** If the access is to an index buffer and
      <<features-robustBufferAccess2,pname:robustBufferAccess2>> is enabled,
      zero values must: be returned.
  *** If the access is to a uniform texel buffer or storage texel buffer and
      <<features-robustBufferAccess2,pname:robustBufferAccess2>> is enabled,
      zero values must: be returned, and then
      <<textures-conversion-to-rgba,Conversion to RGBA>> is applied based on
      the buffer view's format.
endif::VK_EXT_robustness2[]
  *** Values from anywhere within the memory range(s) bound to the buffer
      (possibly including bytes of memory past the end of the buffer, up to
      the end of the bound range).
  *** Zero values, or [eq]#(0,0,0,x)# vectors for vector reads where x is a
      valid value represented in the type of the vector components and may:
      be any of:
  **** 0, 1, or the maximum representable positive integer value, for signed
       or unsigned integer components
  **** 0.0 or 1.0, for floating-point components
  ** Out-of-bounds writes may: modify values within the memory range(s)
     bound to the buffer, but must: not modify any other memory.
ifdef::VK_EXT_robustness2[]
  *** If <<features-robustBufferAccess2,pname:robustBufferAccess2>> is
      enabled, out of bounds writes must: not modify any memory.
endif::VK_EXT_robustness2[]
  ** Out-of-bounds atomics may: modify values within the memory range(s)
     bound to the buffer, but must: not modify any other memory, and return
     an undefined: value.
ifdef::VK_EXT_robustness2[]
  *** If <<features-robustBufferAccess2,pname:robustBufferAccess2>> is
      enabled, out of bounds atomics must: not modify any memory, and return
      an undefined: value.
  ** If <<features-robustBufferAccess2,pname:robustBufferAccess2>> is
     disabled, vertex
endif::VK_EXT_robustness2[]
ifndef::VK_EXT_robustness2[]
  ** Vertex
endif::VK_EXT_robustness2[]
     input attributes are considered out of bounds if the offset of the
     attribute in the bound vertex buffer range plus the size of the
     attribute is greater than either:
+
  *** code:vertexBufferRangeSize, if [eq]#code:bindingStride == 0#; or
  *** [eq]#(code:vertexBufferRangeSize - (code:vertexBufferRangeSize %
      code:bindingStride))#
+
where code:vertexBufferRangeSize is the byte size of the memory range bound
to the vertex buffer binding and code:bindingStride is the byte stride of
the corresponding vertex input binding.
Further, if any vertex input attribute using a specific vertex input binding
is out of bounds, then all vertex input attributes using that vertex input
binding for that vertex shader invocation are considered out of bounds.
  *** If a vertex input attribute is out of bounds, it will be assigned one
      of the following values:
  **** Values from anywhere within the memory range(s) bound to the buffer,
     converted according to the format of the attribute.
  **** Zero values, format converted according to the format of the
       attribute.
  **** Zero values, or [eq]#(0,0,0,x)# vectors, as described above.
ifdef::VK_EXT_robustness2[]
  ** If <<features-robustBufferAccess2,pname:robustBufferAccess2>> is
     enabled, vertex input attributes are considered out of bounds if the
     offset of the attribute in the bound vertex buffer range plus the size
     of the attribute is greater than the byte size of the memory range
     bound to the vertex buffer binding.
  *** If a vertex input attribute is out of bounds, the
      <<fxvertex-input-extraction,raw data>> extracted are zero values, and
      missing G, B, or A components are <<fxvertex-input-extraction,filled
      with [eq]#(0,0,1)#>>.
endif::VK_EXT_robustness2[]
  ** If pname:robustBufferAccess is not enabled, applications must: not
     perform out of bounds accesses.
  * [[features-fullDrawIndexUint32]] pname:fullDrawIndexUint32 specifies the
    full 32-bit range of indices is supported for indexed draw calls when
    using a elink:VkIndexType of ename:VK_INDEX_TYPE_UINT32.
    pname:maxDrawIndexedIndexValue is the maximum index value that may: be
    used (aside from the primitive restart index, which is always 2^32^-1
    when the elink:VkIndexType is ename:VK_INDEX_TYPE_UINT32).
    If this feature is supported, pname:maxDrawIndexedIndexValue must: be
    2^32^-1; otherwise it must: be no smaller than 2^24^-1.
    See <<limits-maxDrawIndexedIndexValue,maxDrawIndexedIndexValue>>.
  * [[features-imageCubeArray]] pname:imageCubeArray specifies whether image
    views with a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY can: be created, and that the
    corresponding code:SampledCubeArray and code:ImageCubeArray SPIR-V
    capabilities can: be used in shader code.
  * [[features-independentBlend]] pname:independentBlend specifies whether
    the sname:VkPipelineColorBlendAttachmentState settings are controlled
    independently per-attachment.
    If this feature is not enabled, the
    sname:VkPipelineColorBlendAttachmentState settings for all color
    attachments must: be identical.
    Otherwise, a different sname:VkPipelineColorBlendAttachmentState can: be
    provided for each bound color attachment.
  * [[features-geometryShader]] pname:geometryShader specifies whether
    geometry shaders are supported.
    If this feature is not enabled, the ename:VK_SHADER_STAGE_GEOMETRY_BIT
    and ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT enum values must: not be
    used.
    This also specifies whether shader modules can: declare the
    code:Geometry capability.
  * [[features-tessellationShader]] pname:tessellationShader specifies
    whether tessellation control and evaluation shaders are supported.
    If this feature is not enabled, the
    ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, and
    ename:VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO enum
    values must: not be used.
    This also specifies whether shader modules can: declare the
    code:Tessellation capability.
  * [[features-sampleRateShading]] pname:sampleRateShading specifies whether
    <<primsrast-sampleshading,Sample Shading>> and multisample interpolation
    are supported.
    If this feature is not enabled, the pname:sampleShadingEnable member of
    the slink:VkPipelineMultisampleStateCreateInfo structure must: be set to
    ename:VK_FALSE and the pname:minSampleShading member is ignored.
    This also specifies whether shader modules can: declare the
    code:SampleRateShading capability.
  * [[features-dualSrcBlend]] pname:dualSrcBlend specifies whether blend
    operations which take two sources are supported.
    If this feature is not enabled, the ename:VK_BLEND_FACTOR_SRC1_COLOR,
    ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
    ename:VK_BLEND_FACTOR_SRC1_ALPHA, and
    ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA enum values must: not be used
    as source or destination blending factors.
    See <<framebuffer-dsb>>.
  * [[features-logicOp]] pname:logicOp specifies whether logic operations
    are supported.
    If this feature is not enabled, the pname:logicOpEnable member of the
    slink:VkPipelineColorBlendStateCreateInfo structure must: be set to
    ename:VK_FALSE, and the pname:logicOp member is ignored.
  * [[features-multiDrawIndirect]] pname:multiDrawIndirect specifies whether
    multiple draw indirect is supported.
    If this feature is not enabled, the pname:drawCount parameter to the
    fname:vkCmdDrawIndirect and fname:vkCmdDrawIndexedIndirect commands
    must: be 0 or 1.
    The pname:maxDrawIndirectCount member of the
    sname:VkPhysicalDeviceLimits structure must: also be 1 if this feature
    is not supported.
    See <<limits-maxDrawIndirectCount,maxDrawIndirectCount>>.
  * [[features-drawIndirectFirstInstance]] pname:drawIndirectFirstInstance
    specifies whether indirect draw calls support the pname:firstInstance
    parameter.
    If this feature is not enabled, the pname:firstInstance member of all
    sname:VkDrawIndirectCommand and sname:VkDrawIndexedIndirectCommand
    structures that are provided to the fname:vkCmdDrawIndirect and
    fname:vkCmdDrawIndexedIndirect commands must: be 0.
  * [[features-depthClamp]] pname:depthClamp specifies whether depth
    clamping is supported.
    If this feature is not enabled, the pname:depthClampEnable member of the
    slink:VkPipelineRasterizationStateCreateInfo structure must: be set to
    ename:VK_FALSE.
    Otherwise, setting pname:depthClampEnable to ename:VK_TRUE will enable
    depth clamping.
  * [[features-depthBiasClamp]] pname:depthBiasClamp specifies whether depth
    bias clamping is supported.
    If this feature is not enabled, the pname:depthBiasClamp member of the
    slink:VkPipelineRasterizationStateCreateInfo structure must: be set to
    0.0 unless the ename:VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state is
    enabled, and the pname:depthBiasClamp parameter to
    fname:vkCmdSetDepthBias must: be set to 0.0.
  * [[features-fillModeNonSolid]] pname:fillModeNonSolid specifies whether
    point and wireframe fill modes are supported.
    If this feature is not enabled, the ename:VK_POLYGON_MODE_POINT and
    ename:VK_POLYGON_MODE_LINE enum values must: not be used.
  * [[features-depthBounds]] pname:depthBounds specifies whether depth
    bounds tests are supported.
    If this feature is not enabled, the pname:depthBoundsTestEnable member
    of the slink:VkPipelineDepthStencilStateCreateInfo structure must: be
    set to ename:VK_FALSE.
    When pname:depthBoundsTestEnable is set to ename:VK_FALSE, the
    pname:minDepthBounds and pname:maxDepthBounds members of the
    slink:VkPipelineDepthStencilStateCreateInfo structure are ignored.
  * [[features-wideLines]] pname:wideLines specifies whether lines with
    width other than 1.0 are supported.
    If this feature is not enabled, the pname:lineWidth member of the
    slink:VkPipelineRasterizationStateCreateInfo structure must: be set to
    1.0 unless the ename:VK_DYNAMIC_STATE_LINE_WIDTH dynamic state is
    enabled, and the pname:lineWidth parameter to fname:vkCmdSetLineWidth
    must: be set to 1.0.
    When this feature is supported, the range and granularity of supported
    line widths are indicated by the pname:lineWidthRange and
    pname:lineWidthGranularity members of the sname:VkPhysicalDeviceLimits
    structure, respectively.
  * [[features-largePoints]] pname:largePoints specifies whether points with
    size greater than 1.0 are supported.
    If this feature is not enabled, only a point size of 1.0 written by a
    shader is supported.
    The range and granularity of supported point sizes are indicated by the
    pname:pointSizeRange and pname:pointSizeGranularity members of the
    sname:VkPhysicalDeviceLimits structure, respectively.
  * [[features-alphaToOne]] pname:alphaToOne specifies whether the
    implementation is able to replace the alpha value of the color fragment
    output from the fragment shader with the maximum representable alpha
    value for fixed-point colors or 1.0 for floating-point colors.
    If this feature is not enabled, then the pname:alphaToOneEnable member
    of the slink:VkPipelineMultisampleStateCreateInfo structure must: be set
    to ename:VK_FALSE.
    Otherwise setting pname:alphaToOneEnable to ename:VK_TRUE will enable
    alpha-to-one behavior.
  * [[features-multiViewport]] pname:multiViewport specifies whether more
    than one viewport is supported.
    If this feature is not enabled:
  ** The pname:viewportCount and pname:scissorCount members of the
     slink:VkPipelineViewportStateCreateInfo structure must: be set to 1.
  ** The pname:firstViewport and pname:viewportCount parameters to the
     fname:vkCmdSetViewport command must: be set to 0 and 1, respectively.
  ** The pname:firstScissor and pname:scissorCount parameters to the
     fname:vkCmdSetScissor command must: be set to 0 and 1, respectively.
ifdef::VK_NV_scissor_exclusive[]
  ** The pname:exclusiveScissorCount member of the
     slink:VkPipelineViewportExclusiveScissorStateCreateInfoNV structure
     must: be set to 0 or 1.
  ** The pname:firstExclusiveScissor and pname:exclusiveScissorCount
     parameters to the fname:vkCmdSetExclusiveScissorNV command must: be set
     to 0 and 1, respectively.
endif::VK_NV_scissor_exclusive[]
  * [[features-samplerAnisotropy]] pname:samplerAnisotropy specifies whether
    anisotropic filtering is supported.
    If this feature is not enabled, the pname:anisotropyEnable member of the
    slink:VkSamplerCreateInfo structure must: be ename:VK_FALSE.
  * [[features-textureCompressionETC2]] pname:textureCompressionETC2
    specifies whether all of the ETC2 and EAC compressed texture formats are
    supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
  ** ename:VK_FORMAT_EAC_R11_UNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11_SNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

  * [[features-textureCompressionASTC_LDR]] pname:textureCompressionASTC_LDR
    specifies whether all of the ASTC LDR compressed texture formats are
    supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

  * [[features-textureCompressionBC]] pname:textureCompressionBC specifies
    whether all of the BC compressed texture formats are supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK
  ** ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK
  ** ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK
  ** ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK
  ** ename:VK_FORMAT_BC2_UNORM_BLOCK
  ** ename:VK_FORMAT_BC2_SRGB_BLOCK
  ** ename:VK_FORMAT_BC3_UNORM_BLOCK
  ** ename:VK_FORMAT_BC3_SRGB_BLOCK
  ** ename:VK_FORMAT_BC4_UNORM_BLOCK
  ** ename:VK_FORMAT_BC4_SNORM_BLOCK
  ** ename:VK_FORMAT_BC5_UNORM_BLOCK
  ** ename:VK_FORMAT_BC5_SNORM_BLOCK
  ** ename:VK_FORMAT_BC6H_UFLOAT_BLOCK
  ** ename:VK_FORMAT_BC6H_SFLOAT_BLOCK
  ** ename:VK_FORMAT_BC7_UNORM_BLOCK
  ** ename:VK_FORMAT_BC7_SRGB_BLOCK
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

  * [[features-occlusionQueryPrecise]] pname:occlusionQueryPrecise specifies
    whether occlusion queries returning actual sample counts are supported.
    Occlusion queries are created in a sname:VkQueryPool by specifying the
    pname:queryType of ename:VK_QUERY_TYPE_OCCLUSION in the
    slink:VkQueryPoolCreateInfo structure which is passed to
    fname:vkCreateQueryPool.
    If this feature is enabled, queries of this type can: enable
    ename:VK_QUERY_CONTROL_PRECISE_BIT in the pname:flags parameter to
    fname:vkCmdBeginQuery.
    If this feature is not supported, the implementation supports only
    boolean occlusion queries.
    When any samples are passed, boolean queries will return a non-zero
    result value, otherwise a result value of zero is returned.
    When this feature is enabled and ename:VK_QUERY_CONTROL_PRECISE_BIT is
    set, occlusion queries will report the actual number of samples passed.
  * [[features-pipelineStatisticsQuery]] pname:pipelineStatisticsQuery
    specifies whether the pipeline statistics queries are supported.
    If this feature is not enabled, queries of type
    ename:VK_QUERY_TYPE_PIPELINE_STATISTICS cannot: be created, and none of
    the elink:VkQueryPipelineStatisticFlagBits bits can: be set in the
    pname:pipelineStatistics member of the slink:VkQueryPoolCreateInfo
    structure.
  * [[features-vertexPipelineStoresAndAtomics]]
    pname:vertexPipelineStoresAndAtomics specifies whether storage buffers
    and images support stores and atomic operations in the vertex,
    tessellation, and geometry shader stages.
    If this feature is not enabled, all storage image, storage texel
    buffers, and storage buffer variables used by these stages in shader
    modules must: be decorated with the code:NonWritable decoration (or the
    code:readonly memory qualifier in GLSL).
  * [[features-fragmentStoresAndAtomics]] pname:fragmentStoresAndAtomics
    specifies whether storage buffers and images support stores and atomic
    operations in the fragment shader stage.
    If this feature is not enabled, all storage image, storage texel
    buffers, and storage buffer variables used by the fragment stage in
    shader modules must: be decorated with the code:NonWritable decoration
    (or the code:readonly memory qualifier in GLSL).
  * [[features-shaderTessellationAndGeometryPointSize]]
    pname:shaderTessellationAndGeometryPointSize specifies whether the
    code:PointSize built-in decoration is available in the tessellation
    control, tessellation evaluation, and geometry shader stages.
    If this feature is not enabled, members decorated with the
    code:PointSize built-in decoration must: not be read from or written to
    and all points written from a tessellation or geometry shader will have
    a size of 1.0.
    This also specifies whether shader modules can: declare the
    code:TessellationPointSize capability for tessellation control and
    evaluation shaders, or if the shader modules can: declare the
    code:GeometryPointSize capability for geometry shaders.
    An implementation supporting this feature must: also support one or both
    of the <<features-tessellationShader,pname:tessellationShader>> or
    <<features-geometryShader,pname:geometryShader>> features.
  * [[features-shaderImageGatherExtended]] pname:shaderImageGatherExtended
    specifies whether the extended set of image gather instructions are
    available in shader code.
    If this feature is not enabled, the code:OpImage*code:Gather
    instructions do not support the code:Offset and code:ConstOffsets
    operands.
    This also specifies whether shader modules can: declare the
    code:ImageGatherExtended capability.
  * [[features-shaderStorageImageExtendedFormats]]
    pname:shaderStorageImageExtendedFormats specifies whether all the
    "`storage image extended formats`" below are supported; if this feature
    is supported, then the ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_R16G16_SFLOAT
  ** ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32
  ** ename:VK_FORMAT_R16_SFLOAT
  ** ename:VK_FORMAT_R16G16B16A16_UNORM
  ** ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32
  ** ename:VK_FORMAT_R16G16_UNORM
  ** ename:VK_FORMAT_R8G8_UNORM
  ** ename:VK_FORMAT_R16_UNORM
  ** ename:VK_FORMAT_R8_UNORM
  ** ename:VK_FORMAT_R16G16B16A16_SNORM
  ** ename:VK_FORMAT_R16G16_SNORM
  ** ename:VK_FORMAT_R8G8_SNORM
  ** ename:VK_FORMAT_R16_SNORM
  ** ename:VK_FORMAT_R8_SNORM
  ** ename:VK_FORMAT_R16G16_SINT
  ** ename:VK_FORMAT_R8G8_SINT
  ** ename:VK_FORMAT_R16_SINT
  ** ename:VK_FORMAT_R8_SINT
  ** ename:VK_FORMAT_A2B10G10R10_UINT_PACK32
  ** ename:VK_FORMAT_R16G16_UINT
  ** ename:VK_FORMAT_R8G8_UINT
  ** ename:VK_FORMAT_R16_UINT
  ** ename:VK_FORMAT_R8_UINT
+
[NOTE]
.Note
====
pname:shaderStorageImageExtendedFormats feature only adds a guarantee of
format support, which is specified for the whole physical device.
Therefore enabling or disabling the feature via flink:vkCreateDevice has no
practical effect.

To query for additional properties, or if the feature is not supported,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats, as usual rules allow.

ename:VK_FORMAT_R32G32_UINT, ename:VK_FORMAT_R32G32_SINT, and
ename:VK_FORMAT_R32G32_SFLOAT from code:StorageImageExtendedFormats SPIR-V
capability, are already covered by core Vulkan
<<formats-mandatory-features-32bit,mandatory format support>>.
====

  * [[features-shaderStorageImageMultisample]]
    pname:shaderStorageImageMultisample specifies whether multisampled
    storage images are supported.
    If this feature is not enabled, images that are created with a
    pname:usage that includes ename:VK_IMAGE_USAGE_STORAGE_BIT must: be
    created with pname:samples equal to ename:VK_SAMPLE_COUNT_1_BIT.
    This also specifies whether shader modules can: declare the
    code:StorageImageMultisample capability.
  * [[features-shaderStorageImageReadWithoutFormat]]
    pname:shaderStorageImageReadWithoutFormat specifies whether storage
    images require a format qualifier to be specified when reading from
    storage images.
    If this feature is not enabled, the code:OpImageRead instruction must:
    not have an code:OpTypeImage of code:Unknown.
    This also specifies whether shader modules can: declare the
    code:StorageImageReadWithoutFormat capability.
  * [[features-shaderStorageImageWriteWithoutFormat]]
    pname:shaderStorageImageWriteWithoutFormat specifies whether storage
    images require a format qualifier to be specified when writing to
    storage images.
    If this feature is not enabled, the code:OpImageWrite instruction must:
    not have an code:OpTypeImage of code:Unknown.
    This also specifies whether shader modules can: declare the
    code:StorageImageWriteWithoutFormat capability.
  * [[features-shaderUniformBufferArrayDynamicIndexing]]
    pname:shaderUniformBufferArrayDynamicIndexing specifies whether arrays
    of uniform buffers can: be indexed by _dynamically uniform_ integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also specifies whether shader modules can: declare the
    code:UniformBufferArrayDynamicIndexing capability.
  * [[features-shaderSampledImageArrayDynamicIndexing]]
    pname:shaderSampledImageArrayDynamicIndexing specifies whether arrays of
    samplers or sampled images can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must: be indexed only by constant
    integral expressions when aggregated into arrays in shader code.
    This also specifies whether shader modules can: declare the
    code:SampledImageArrayDynamicIndexing capability.
  * [[features-shaderStorageBufferArrayDynamicIndexing]]
    pname:shaderStorageBufferArrayDynamicIndexing specifies whether arrays
    of storage buffers can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also specifies whether shader modules can: declare the
    code:StorageBufferArrayDynamicIndexing capability.
  * [[features-shaderStorageImageArrayDynamicIndexing]]
    pname:shaderStorageImageArrayDynamicIndexing specifies whether arrays of
    storage images can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must: be indexed only by constant
    integral expressions when aggregated into arrays in shader code.
    This also specifies whether shader modules can: declare the
    code:StorageImageArrayDynamicIndexing capability.
  * [[features-shaderClipDistance]] pname:shaderClipDistance specifies
    whether clip distances are supported in shader code.
    If this feature is not enabled, any members decorated with the
    code:ClipDistance built-in decoration must: not be read from or written
    to in shader modules.
    This also specifies whether shader modules can: declare the
    code:ClipDistance capability.
  * [[features-shaderCullDistance]] pname:shaderCullDistance specifies
    whether cull distances are supported in shader code.
    If this feature is not enabled, any members decorated with the
    code:CullDistance built-in decoration must: not be read from or written
    to in shader modules.
    This also specifies whether shader modules can: declare the
    code:CullDistance capability.
  * [[features-shaderFloat64]] pname:shaderFloat64 specifies whether 64-bit
    floats (doubles) are supported in shader code.
    If this feature is not enabled, 64-bit floating-point types must: not be
    used in shader code.
    This also specifies whether shader modules can: declare the code:Float64
    capability.
    Declaring and using 64-bit floats is enabled for all storage classes
    that SPIR-V allows with the code:Float64 capability.
  * [[features-shaderInt64]] pname:shaderInt64 specifies whether 64-bit
    integers (signed and unsigned) are supported in shader code.
    If this feature is not enabled, 64-bit integer types must: not be used
    in shader code.
    This also specifies whether shader modules can: declare the code:Int64
    capability.
    Declaring and using 64-bit integers is enabled for all storage classes
    that SPIR-V allows with the code:Int64 capability.
  * [[features-shaderInt16]] pname:shaderInt16 specifies whether 16-bit
    integers (signed and unsigned) are supported in shader code.
    If this feature is not enabled, 16-bit integer types must: not be used
    in shader code.
    This also specifies whether shader modules can: declare the code:Int16
    capability.
    However, this only enables a subset of the storage classes that SPIR-V
    allows for the code:Int16 SPIR-V capability: Declaring and using 16-bit
    integers in the code:Private, code:Workgroup, and code:Function storage
    classes is enabled, while declaring them in the interface storage
    classes (e.g., code:UniformConstant, code:Uniform, code:StorageBuffer,
    code:Input, code:Output, and code:PushConstant) is not enabled.
  * [[features-shaderResourceResidency]] pname:shaderResourceResidency
    specifies whether image operations that return resource residency
    information are supported in shader code.
    If this feature is not enabled, the code:OpImageSparse* instructions
    must: not be used in shader code.
    This also specifies whether shader modules can: declare the
    code:SparseResidency capability.
    The feature requires at least one of the ptext:sparseResidency* features
    to be supported.
  * [[features-shaderResourceMinLod]] pname:shaderResourceMinLod specifies
    whether image operations specifying the minimum resource LOD are
    supported in shader code.
    If this feature is not enabled, the code:MinLod image operand must: not
    be used in shader code.
    This also specifies whether shader modules can: declare the code:MinLod
    capability.
  * [[features-sparseBinding]] pname:sparseBinding specifies whether
    resource memory can: be managed at opaque sparse block level instead of
    at the object level.
    If this feature is not enabled, resource memory must: be bound only on a
    per-object basis using the fname:vkBindBufferMemory and
    fname:vkBindImageMemory commands.
    In this case, buffers and images must: not be created with
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT and
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in the pname:flags member
    of the slink:VkBufferCreateInfo and slink:VkImageCreateInfo structures,
    respectively.
    Otherwise resource memory can: be managed as described in
    <<sparsememory-sparseresourcefeatures,Sparse Resource Features>>.
  * [[features-sparseResidencyBuffer]] pname:sparseResidencyBuffer specifies
    whether the device can: access partially resident buffers.
    If this feature is not enabled, buffers must: not be created with
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags
    member of the slink:VkBufferCreateInfo structure.
  * [[features-sparseResidencyImage2D]] pname:sparseResidencyImage2D
    specifies whether the device can: access partially resident 2D images
    with 1 sample per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_1_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
  * [[features-sparseResidencyImage3D]] pname:sparseResidencyImage3D
    specifies whether the device can: access partially resident 3D images.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_3D must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
  * [[features-sparseResidency2Samples]] pname:sparseResidency2Samples
    specifies whether the physical device can: access partially resident 2D
    images with 2 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_2_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
  * [[features-sparseResidency4Samples]] pname:sparseResidency4Samples
    specifies whether the physical device can: access partially resident 2D
    images with 4 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_4_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
  * [[features-sparseResidency8Samples]] pname:sparseResidency8Samples
    specifies whether the physical device can: access partially resident 2D
    images with 8 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_8_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
  * [[features-sparseResidency16Samples]] pname:sparseResidency16Samples
    specifies whether the physical device can: access partially resident 2D
    images with 16 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_16_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
  * [[features-sparseResidencyAliased]] pname:sparseResidencyAliased
    specifies whether the physical device can: correctly access data aliased
    into multiple locations.
    If this feature is not enabled, the
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT and
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT enum values must: not be used
    in pname:flags members of the slink:VkBufferCreateInfo and
    slink:VkImageCreateInfo structures, respectively.
  * [[features-variableMultisampleRate]] pname:variableMultisampleRate
    specifies whether all pipelines that will be bound to a command buffer
    during a <<renderpass-noattachments, subpass which uses no attachments>>
    must: have the same value for
    slink:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples.
    If set to ename:VK_TRUE, the implementation supports variable
    multisample rates in a subpass which uses no attachments.
    If set to ename:VK_FALSE, then all pipelines bound in such a subpass
    must: have the same multisample rate.
    This has no effect in situations where a subpass uses any attachments.
  * [[features-inheritedQueries]] pname:inheritedQueries specifies whether a
    secondary command buffer may: be executed while a query is active.

include::{generated}/validity/structs/VkPhysicalDeviceFeatures.txt[]
--

ifdef::VK_VERSION_1_2[]

[open,refpage='VkPhysicalDeviceVulkan11Features',desc='Structure describing the Vulkan 1.1 features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceVulkan11Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVulkan11Features.txt[]

The members of the sname:VkPhysicalDeviceVulkan11Features structure describe
the following features:

:anchor-prefix:
include::{chapters}/features.txt[tag=VK_KHR_16bit_storage-features]
include::{chapters}/features.txt[tag=VK_KHR_multiview-features]
include::{chapters}/features.txt[tag=VK_KHR_variable_pointers-features]
include::{chapters}/features.txt[tag=VK_KHR_protected_memory-features]
include::{chapters}/features.txt[tag=VK_KHR_sampler_ycbcr_conversion-features]
include::{chapters}/features.txt[tag=VK_KHR_shader_draw_parameters-features]

If the sname:VkPhysicalDeviceVulkan11Features structure is included in the
pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled with
values indicating whether each feature is supported.
sname:VkPhysicalDeviceVulkan11Features can: also be used in the pname:pNext
chain of slink:VkDeviceCreateInfo to enable the features.

include::{generated}/validity/structs/VkPhysicalDeviceVulkan11Features.txt[]
--

[open,refpage='VkPhysicalDeviceVulkan12Features',desc='Structure describing the Vulkan 1.2 features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceVulkan12Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVulkan12Features.txt[]

The members of the sname:VkPhysicalDeviceVulkan12Features structure describe
the following features:

:anchor-prefix:
  * [[features-samplerMirrorClampToEdge]] pname:samplerMirrorClampToEdge
    indicates whether the implementation supports the
    ename:VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE sampler address mode.
    If this feature is not enabled, the
    ename:VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE sampler address mode
    must: not be used.
  * [[features-drawIndirectCount]] pname:drawIndirectCount indicates whether
    the implementation supports the flink:vkCmdDrawIndirectCount and
    flink:vkCmdDrawIndexedIndirectCount functions.
    If this feature is not enabled, these functions must: not be used.
include::{chapters}/features.txt[tag=VK_KHR_8bit_storage-features]
include::{chapters}/features.txt[tag=VK_KHR_shader_atomic_int64-features]
include::{chapters}/features.txt[tag=VK_KHR_shader_float16_int8-features]
  * [[features-descriptorIndexing]] pname:descriptorIndexing indicates
    whether the implementation supports the minimum set of descriptor
    indexing features as described in the <<features-requirements,Feature
    Requirements>> section.
    Enabling the pname:descriptorIndexing member when flink:vkCreateDevice
    is called does not imply the other minimum descriptor indexing features
    are also enabled.
    Those other descriptor indexing features must: be enabled individually
    as needed by the application.
include::{chapters}/features.txt[tag=VK_EXT_descriptor_indexing-features]
  * [[features-samplerFilterMinmax]] pname:samplerFilterMinmax indicates
    whether the implementation supports a minimum set of required formats
    supporting min/max filtering as defined by the
    <<limits-filterMinmaxSingleComponentFormats-minimum-requirements,pname:filterMinmaxSingleComponentFormats>>
    property minimum requirements.
    If this feature is not enabled, then no slink:VkSamplerCreateInfo
    pname:pNext chain can include a slink:VkSamplerReductionModeCreateInfo
    structure.
include::{chapters}/features.txt[tag=VK_EXT_scalar_block_layout-features]
include::{chapters}/features.txt[tag=VK_KHR_imageless_framebuffer-features]
include::{chapters}/features.txt[tag=VK_KHR_uniform_buffer_standard_layout-features]
include::{chapters}/features.txt[tag=VK_KHR_shader_subgroup_extended_types-features]
include::{chapters}/features.txt[tag=VK_KHR_separate_depth_stencil_layouts-features]
include::{chapters}/features.txt[tag=VK_EXT_host_query_reset-features]
include::{chapters}/features.txt[tag=VK_KHR_timeline_semaphore-features]
include::{chapters}/features.txt[tag=VK_EXT_buffer_device_address-features]
include::{chapters}/features.txt[tag=VK_KHR_vulkan_memory_model-features]
  * [[features-shaderOutputViewportIndex]] pname:shaderOutputViewportIndex
    indicates whether the implementation supports the
    code:ShaderViewportIndex SPIR-V capability enabling variables decorated
    with the code:ViewportIndex built-in to be exported from vertex or
    tessellation evaluation shaders.
    If this feature is not enabled, the code:ViewportIndex built-in
    decoration must: not be used on outputs in vertex or tessellation
    evaluation shaders.
  * [[features-shaderOutputLayer]] pname:shaderOutputLayer indicates whether
    the implementation supports the code:ShaderLayer SPIR-V capability
    enabling variables decorated with the code:Layer built-in to be exported
    from vertex or tessellation evaluation shaders.
    If this feature is not enabled, the code:Layer built-in decoration must:
    not be used on outputs in vertex or tessellation evaluation shaders.
  * [[features-subgroupBroadcastDynamicId]] If
    pname:subgroupBroadcastDynamicId is ename:VK_TRUE, the "`Id`" operand of
    code:OpGroupNonUniformBroadcast can: be dynamically uniform within a
    subgroup, and the "`Index`" operand of
    code:OpGroupNonUniformQuadBroadcast can: be dynamically uniform within
    the derivative group.
    If it is ename:VK_FALSE, these operands must: be constants.

If the sname:VkPhysicalDeviceVulkan12Features structure is included in the
pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled with
values indicating whether each feature is supported.
sname:VkPhysicalDeviceVulkan12Features can: also be used in the pname:pNext
chain of slink:VkDeviceCreateInfo to enable the features.

include::{generated}/validity/structs/VkPhysicalDeviceVulkan12Features.txt[]
--

endif::VK_VERSION_1_2[]

ifdef::VK_VERSION_1_1,VK_KHR_variable_pointers[]

[open,refpage='VkPhysicalDeviceVariablePointersFeatures',desc='Structure describing variable pointers features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceVariablePointersFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVariablePointersFeatures.txt[]

ifdef::VK_KHR_variable_pointers[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceVariablePointersFeaturesKHR.txt[]
endif::VK_KHR_variable_pointers[]

The members of the sname:VkPhysicalDeviceVariablePointersFeatures structure
describe the following features:

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_variable_pointers-features[]
  * [[{anchor-prefix}features-variablePointersStorageBuffer]]
    pname:variablePointersStorageBuffer specifies whether the implementation
    supports the SPIR-V `VariablePointersStorageBuffer` capability.
    When this feature is not enabled, shader modules must: not declare the
    `SPV_KHR_variable_pointers` extension or the
    `VariablePointersStorageBuffer` capability.
  * [[{anchor-prefix}features-variablePointers]] pname:variablePointers
    specifies whether the implementation supports the SPIR-V
    `VariablePointers` capability.
    When this feature is not enabled, shader modules must: not declare the
    `VariablePointers` capability.
// end::VK_KHR_variable_pointers-features[]

If the sname:VkPhysicalDeviceVariablePointersFeatures structure is included
in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled
with values indicating whether each feature is supported.
sname:VkPhysicalDeviceVariablePointersFeatures can: also be included in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceVariablePointersFeatures-variablePointers-01431]]
    If pname:variablePointers is enabled then
    pname:variablePointersStorageBuffer must: also be enabled
****

include::{generated}/validity/structs/VkPhysicalDeviceVariablePointersFeatures.txt[]
--

endif::VK_VERSION_1_1,VK_KHR_variable_pointers[]

ifdef::VK_VERSION_1_1,VK_KHR_multiview[]

[open,refpage='VkPhysicalDeviceMultiviewFeatures',desc='Structure describing multiview features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMultiviewFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMultiviewFeatures.txt[]

ifdef::VK_KHR_multiview[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceMultiviewFeaturesKHR.txt[]
endif::VK_KHR_multiview[]

The members of the sname:VkPhysicalDeviceMultiviewFeatures structure
describe the following features:

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_multiview-features[]
  * [[{anchor-prefix}features-multiview]] pname:multiview specifies whether
    the implementation supports multiview rendering within a render pass.
    If this feature is not enabled, the view mask of each subpass must:
    always be zero.
  * [[{anchor-prefix}features-multiview-gs]] pname:multiviewGeometryShader
    specifies whether the implementation supports multiview rendering within
    a render pass, with <<geometry,geometry shaders>>.
    If this feature is not enabled, then a pipeline compiled against a
    subpass with a non-zero view mask must: not include a geometry shader.
  * [[{anchor-prefix}features-multiview-tess]]
    pname:multiviewTessellationShader specifies whether the implementation
    supports multiview rendering within a render pass, with
    <<tessellation,tessellation shaders>>.
    If this feature is not enabled, then a pipeline compiled against a
    subpass with a non-zero view mask must: not include any tessellation
    shaders.
// end::VK_KHR_multiview-features[]

If the sname:VkPhysicalDeviceMultiviewFeatures structure is included in the
pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled with
values indicating whether each feature is supported.
sname:VkPhysicalDeviceMultiviewFeatures can: also be included in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceMultiviewFeatures-multiviewGeometryShader-00580]]
    If pname:multiviewGeometryShader is enabled then pname:multiview must:
    also be enabled
  * [[VUID-VkPhysicalDeviceMultiviewFeatures-multiviewTessellationShader-00581]]
    If pname:multiviewTessellationShader is enabled then pname:multiview
    must: also be enabled
****

include::{generated}/validity/structs/VkPhysicalDeviceMultiviewFeatures.txt[]
--

endif::VK_VERSION_1_1,VK_KHR_multiview[]

ifdef::VK_VERSION_1_2,VK_KHR_shader_atomic_int64[]
[open,refpage='VkPhysicalDeviceShaderAtomicInt64Features',desc='Structure describing features supported by VK_KHR_shader_atomic_int64',type='structs',alias='VkPhysicalDeviceShaderAtomicInt64FeaturesKHR']
--
To query 64-bit atomic support for signed and unsigned integers call
flink:vkGetPhysicalDeviceFeatures2 with a
sname:VkPhysicalDeviceShaderAtomicInt64Features structure included in the
pname:pNext chain of its pname:pFeatures parameter.

The slink:VkPhysicalDeviceShaderAtomicInt64Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderAtomicInt64Features.txt[]

ifdef::VK_KHR_shader_atomic_int64[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.txt[]
endif::VK_KHR_shader_atomic_int64[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_shader_atomic_int64-features[]
  * [[{anchor-prefix}features-shaderBufferInt64Atomics]]
    pname:shaderBufferInt64Atomics indicates whether shaders can: support
    64-bit unsigned and signed integer atomic operations on buffers.
  * [[{anchor-prefix}features-shaderSharedInt64Atomics]]
    pname:shaderSharedInt64Atomics indicates whether shaders can: support
    64-bit unsigned and signed integer atomic operations on shared memory.
// end::VK_KHR_shader_atomic_int64-features[]

include::{generated}/validity/structs/VkPhysicalDeviceShaderAtomicInt64Features.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_shader_atomic_int64[]

ifdef::VK_VERSION_1_2,VK_KHR_8bit_storage[]
[open,refpage='VkPhysicalDevice8BitStorageFeatures',desc='Structure describing features supported by VK_KHR_8bit_storage',type='structs',alias='VkPhysicalDevice8BitStorageFeaturesKHR']
--
To query 8-bit storage features additionally supported call
flink:vkGetPhysicalDeviceFeatures2 with a
sname:VkPhysicalDevice8BitStorageFeatures structure included in the
pname:pNext chain of its pname:pFeatures parameter.
The sname:VkPhysicalDevice8BitStorageFeatures structure can: also be
included in the pname:pNext chain of a slink:VkDeviceCreateInfo structure,
in which case it controls which additional features are enabled in the
device.

The slink:VkPhysicalDevice8BitStorageFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDevice8BitStorageFeatures.txt[]

ifdef::VK_KHR_8bit_storage[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDevice8BitStorageFeaturesKHR.txt[]
endif::VK_KHR_8bit_storage[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_8bit_storage-features[]
  * [[{anchor-prefix}features-storageBuffer8BitAccess]]
    pname:storageBuffer8BitAccess indicates whether objects in the
    code:StorageBuffer
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    or code:PhysicalStorageBuffer
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    storage class with the code:Block decoration can: have 8-bit integer
    members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:StorageBuffer8BitAccess capability.
  * [[{anchor-prefix}features-uniformAndStorageBuffer8BitAccess]]
    pname:uniformAndStorageBuffer8BitAccess indicates whether objects in the
    code:Uniform storage class with the code:Block decoration and in the
    code:StorageBuffer
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    or code:PhysicalStorageBuffer
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    storage class with the same decoration can: have 8-bit integer members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:UniformAndStorageBuffer8BitAccess capability.
  * [[{anchor-prefix}features-storagePushConstant8]]
    pname:storagePushConstant8 indicates whether objects in the
    code:PushConstant storage class can: have 8-bit integer members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:StoragePushConstant8 capability.
// end::VK_KHR_8bit_storage-features[]

include::{generated}/validity/structs/VkPhysicalDevice8BitStorageFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_8bit_storage[]

ifdef::VK_VERSION_1_1,VK_KHR_16bit_storage[]
[open,refpage='VkPhysicalDevice16BitStorageFeatures',desc='Structure describing features supported by VK_KHR_16bit_storage',type='structs']
--
To query 16-bit storage features additionally supported call
flink:vkGetPhysicalDeviceFeatures2 with a
sname:VkPhysicalDevice16BitStorageFeatures structure included in the
pname:pNext chain of its pname:pFeatures parameter.
The sname:VkPhysicalDevice16BitStorageFeatures structure can: also be
included in the pname:pNext chain of a slink:VkDeviceCreateInfo structure,
in which case it controls which additional features are enabled in the
device.

The slink:VkPhysicalDevice16BitStorageFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDevice16BitStorageFeatures.txt[]

ifdef::VK_KHR_16bit_storage[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDevice16BitStorageFeaturesKHR.txt[]
endif::VK_KHR_16bit_storage[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_16bit_storage-features[]
  * [[{anchor-prefix}features-storageBuffer16BitAccess]]
    pname:storageBuffer16BitAccess specifies whether objects in the
    code:StorageBuffer
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    or code:PhysicalStorageBuffer
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    storage class with the code:Block decoration can: have 16-bit integer
    and 16-bit floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:StorageBuffer16BitAccess capability.
  * [[{anchor-prefix}features-uniformAndStorageBuffer16BitAccess]]
    pname:uniformAndStorageBuffer16BitAccess specifies whether objects in
    the code:Uniform storage class with the code:Block decoration and in the
    code:StorageBuffer
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    or code:PhysicalStorageBuffer
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    storage class with the same decoration can: have 16-bit integer and
    16-bit floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:UniformAndStorageBuffer16BitAccess capability.
  * [[{anchor-prefix}features-storagePushConstant16]]
    pname:storagePushConstant16 specifies whether objects in the
    code:PushConstant storage class can: have 16-bit integer and 16-bit
    floating-point members.
    If this feature is not enabled, 16-bit integer or floating-point members
    must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:StoragePushConstant16 capability.
  * [[{anchor-prefix}features-storageInputOutput16]]
    pname:storageInputOutput16 specifies whether objects in the code:Input
    and code:Output storage classes can: have 16-bit integer and 16-bit
    floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:StorageInputOutput16 capability.
// end::VK_KHR_16bit_storage-features[]

include::{generated}/validity/structs/VkPhysicalDevice16BitStorageFeatures.txt[]
--
endif::VK_VERSION_1_1,VK_KHR_16bit_storage[]

ifdef::VK_VERSION_1_2,VK_KHR_shader_float16_int8[]
[open,refpage='VkPhysicalDeviceShaderFloat16Int8Features',desc='Structure describing features supported by VK_KHR_shader_float16_int8',type='structs',alias='VkPhysicalDeviceShaderFloat16Int8FeaturesKHR']
--
To query features additionally supported by the
`<<VK_KHR_shader_float16_int8>>` extension, call
flink:vkGetPhysicalDeviceFeatures2KHR with a
sname:VkPhysicalDeviceShaderFloat16Int8Features structure included in the
pname:pNext chain.
The sname:VkPhysicalDeviceShaderFloat16Int8Features structure can: also be
included in the pname:pNext chain of a slink:VkDeviceCreateInfo structure,
in which case it controls which additional features are enabled in the
device.

The sname:VkPhysicalDeviceShaderFloat16Int8Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderFloat16Int8Features.txt[]

ifdef::VK_KHR_shader_float16_int8[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceShaderFloat16Int8FeaturesKHR.txt[]
endif::VK_KHR_shader_float16_int8[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_shader_float16_int8-features[]
  * [[{anchor-prefix}features-shaderFloat16]] pname:shaderFloat16 indicates
    whether 16-bit floats (halfs) are supported in shader code.
    This also indicates whether shader modules can: declare the code:Float16
    capability.
    However, this only enables a subset of the storage classes that SPIR-V
    allows for the code:Float16 SPIR-V capability: Declaring and using
    16-bit floats in the code:Private, code:Workgroup, and code:Function
    storage classes is enabled, while declaring them in the interface
    storage classes (e.g., code:UniformConstant, code:Uniform,
    code:StorageBuffer, code:Input, code:Output, and code:PushConstant) is
    not enabled.
  * [[{anchor-prefix}features-shaderInt8]] pname:shaderInt8 indicates
    whether 8-bit integers (signed and unsigned) are supported in shader
    code.
    This also indicates whether shader modules can: declare the code:Int8
    capability.
    However, this only enables a subset of the storage classes that SPIR-V
    allows for the code:Int8 SPIR-V capability: Declaring and using 8-bit
    integers in the code:Private, code:Workgroup, and code:Function storage
    classes is enabled, while declaring them in the interface storage
    classes (e.g., code:UniformConstant, code:Uniform, code:StorageBuffer,
    code:Input, code:Output, and code:PushConstant) is not enabled.
// end::VK_KHR_shader_float16_int8-features[]

include::{generated}/validity/structs/VkPhysicalDeviceShaderFloat16Int8Features.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_shader_float16_int8[]

ifdef::VK_KHR_shader_clock[]
[open,refpage='VkPhysicalDeviceShaderClockFeaturesKHR',desc='Structure describing features supported by VK_KHR_shader_clock',type='structs']
--
To query shader clock support, call flink:vkGetPhysicalDeviceFeatures2 with
a sname:VkPhysicalDeviceShaderClockFeaturesKHR structure included in the
pname:pNext chain of its pname:pFeatures parameter.

The slink:VkPhysicalDeviceShaderClockFeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderClockFeaturesKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * [[features-shaderSubgroupClock]] pname:shaderSubgroupClock indicates
    whether shaders can: support code:Subgroup scoped clock reads.
  * [[features-shaderDeviceClock]] pname:shaderDeviceClock indicates whether
    shaders can: support code:Device scoped clock reads.

If the slink:VkPhysicalDeviceShaderClockFeaturesKHR structure is included in
the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled with
values indicating whether each feature is supported.
slink:VkPhysicalDeviceShaderClockFeaturesKHR can also be included in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

include::{generated}/validity/structs/VkPhysicalDeviceShaderClockFeaturesKHR.txt[]
--
endif::VK_KHR_shader_clock[]

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
[open,refpage='VkPhysicalDeviceSamplerYcbcrConversionFeatures',desc='Structure describing Y\'CbCr conversion features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR']
--
The sname:VkPhysicalDeviceSamplerYcbcrConversionFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceSamplerYcbcrConversionFeatures.txt[]

ifdef::VK_KHR_sampler_ycbcr_conversion[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.txt[]
endif::VK_KHR_sampler_ycbcr_conversion[]

The members of the sname:VkPhysicalDeviceSamplerYcbcrConversionFeatures
structure describe the following feature:

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_sampler_ycbcr_conversion-features[]
  * [[{anchor-prefix}features-sampler-YCbCr-conversion]]
    pname:samplerYcbcrConversion specifies whether the implementation
    supports <<samplers-YCbCr-conversion,sampler {YCbCr} conversion>>.
    If pname:samplerYcbcrConversion is ename:VK_FALSE, sampler {YCbCr}
    conversion is not supported, and samplers using sampler {YCbCr}
    conversion must: not be used.
// end::VK_KHR_sampler_ycbcr_conversion-features[]

include::{generated}/validity/structs/VkPhysicalDeviceSamplerYcbcrConversionFeatures.txt[]
--

endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

ifdef::VK_VERSION_1_1[]

[open,refpage='VkPhysicalDeviceProtectedMemoryFeatures',desc='Structure describing protected memory features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceProtectedMemoryFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceProtectedMemoryFeatures.txt[]

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_protected_memory-features[]
  * [[{anchor-prefix}features-protectedMemory]] pname:protectedMemory
    specifies whether protected memory is supported.
// end::VK_KHR_protected_memory-features[]

If the sname:VkPhysicalDeviceProtectedMemoryFeatures structure is included
in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled
with a value indicating whether the feature is supported.

include::{generated}/validity/structs/VkPhysicalDeviceProtectedMemoryFeatures.txt[]
--

endif::VK_VERSION_1_1[]

ifdef::VK_EXT_blend_operation_advanced[]

[open,refpage='VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT',desc='Structure describing advanced blending features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
structure describe the following features:

  * [[features-advancedBlendCoherentOperations]]
    pname:advancedBlendCoherentOperations specifies whether blending using
    <<framebuffer-blend-advanced,advanced blend operations>> is guaranteed
    to execute atomically and in <<drawing-primitive-order, primitive
    order>>.
    If this is ename:VK_TRUE,
    ename:VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT is treated the
    same as ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT, and advanced blending
    needs no additional synchronization over basic blending.
    If this is ename:VK_FALSE, then memory dependencies are required to
    guarantee order between two advanced blending operations that occur on
    the same sample.

If the sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT can: also be
included in the pname:pNext chain of slink:VkDeviceCreateInfo to enable the
features.

include::{generated}/validity/structs/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.txt[]
--

endif::VK_EXT_blend_operation_advanced[]

ifdef::VK_EXT_conditional_rendering[]

[open,refpage='VkPhysicalDeviceConditionalRenderingFeaturesEXT',desc='Structure describing if a secondary command buffer can be executed if conditional rendering is active in the primary command buffer',type='structs']
--
The sname:VkPhysicalDeviceConditionalRenderingFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceConditionalRenderingFeaturesEXT.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * [[features-conditionalRendering]] pname:conditionalRendering specifies
    whether conditional rendering is supported.
  * [[features-inheritedConditionalRendering]]
    pname:inheritedConditionalRendering specifies whether a secondary
    command buffer can: be executed while conditional rendering is active in
    the primary command buffer.

If the sname:VkPhysicalDeviceConditionalRenderingFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating the implementation-dependent behavior.
sname:VkPhysicalDeviceConditionalRenderingFeaturesEXT can: also be included
in pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

include::{generated}/validity/structs/VkPhysicalDeviceConditionalRenderingFeaturesEXT.txt[]
--

endif::VK_EXT_conditional_rendering[]

ifdef::VK_VERSION_1_1[]
[open,refpage='VkPhysicalDeviceShaderDrawParametersFeatures',desc='Structure describing shader draw parameter features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderDrawParametersFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderDrawParametersFeatures.txt[]

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_shader_draw_parameters-features[]
  * [[{anchor-prefix}features-shaderDrawParameters]]
    pname:shaderDrawParameters specifies whether shader draw parameters are
    supported.
// end::VK_KHR_shader_draw_parameters-features[]

If the sname:VkPhysicalDeviceShaderDrawParametersFeatures structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with a value indicating whether the feature is supported.

include::{generated}/validity/structs/VkPhysicalDeviceShaderDrawParametersFeatures.txt[]
--
endif::VK_VERSION_1_1[]

ifdef::VK_NV_mesh_shader[]
[open,refpage='VkPhysicalDeviceMeshShaderFeaturesNV',desc='Structure describing mesh shading features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMeshShaderFeaturesNV structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMeshShaderFeaturesNV.txt[]

  * [[features-taskShader]] pname:taskShader indicates whether the task
    shader stage is supported.
  * [[features-meshShader]] pname:meshShader indicates whether the mesh
    shader stage is supported.

If the sname:VkPhysicalDeviceMeshShaderFeaturesNV structure is included in
the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled with
a value indicating whether the feature is supported.
sname:VkPhysicalDeviceMeshShaderFeaturesNV can: also be included in
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

include::{generated}/validity/structs/VkPhysicalDeviceMeshShaderFeaturesNV.txt[]
--
endif::VK_NV_mesh_shader[]

ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
[open,refpage='VkPhysicalDeviceDescriptorIndexingFeatures',desc='Structure describing descriptor indexing features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceDescriptorIndexingFeaturesEXT']
--
The sname:VkPhysicalDeviceDescriptorIndexingFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDescriptorIndexingFeatures.txt[]

ifdef::VK_EXT_descriptor_indexing[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceDescriptorIndexingFeaturesEXT.txt[]
endif::VK_EXT_descriptor_indexing[]

The members of the sname:VkPhysicalDeviceDescriptorIndexingFeatures
structure describe the following features:

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_descriptor_indexing-features[]
  * [[{anchor-prefix}features-shaderInputAttachmentArrayDynamicIndexing]]
    pname:shaderInputAttachmentArrayDynamicIndexing indicates whether arrays
    of input attachments can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:InputAttachmentArrayDynamicIndexing capability.
  * [[{anchor-prefix}features-shaderUniformTexelBufferArrayDynamicIndexing]]
    pname:shaderUniformTexelBufferArrayDynamicIndexing indicates whether
    arrays of uniform texel buffers can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformTexelBufferArrayDynamicIndexing capability.
  * [[{anchor-prefix}features-shaderStorageTexelBufferArrayDynamicIndexing]]
    pname:shaderStorageTexelBufferArrayDynamicIndexing indicates whether
    arrays of storage texel buffers can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageTexelBufferArrayDynamicIndexing capability.
  * [[{anchor-prefix}features-shaderUniformBufferArrayNonUniformIndexing]]
    pname:shaderUniformBufferArrayNonUniformIndexing indicates whether
    arrays of uniform buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformBufferArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderSampledImageArrayNonUniformIndexing]]
    pname:shaderSampledImageArrayNonUniformIndexing indicates whether arrays
    of samplers or sampled images can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:SampledImageArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderStorageBufferArrayNonUniformIndexing]]
    pname:shaderStorageBufferArrayNonUniformIndexing indicates whether
    arrays of storage buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageBufferArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderStorageImageArrayNonUniformIndexing]]
    pname:shaderStorageImageArrayNonUniformIndexing indicates whether arrays
    of storage images can: be indexed by non-uniform integer expressions in
    shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageImageArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderInputAttachmentArrayNonUniformIndexing]]
    pname:shaderInputAttachmentArrayNonUniformIndexing indicates whether
    arrays of input attachments can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:InputAttachmentArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderUniformTexelBufferArrayNonUniformIndexing]]
    pname:shaderUniformTexelBufferArrayNonUniformIndexing indicates whether
    arrays of uniform texel buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformTexelBufferArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderStorageTexelBufferArrayNonUniformIndexing]]
    pname:shaderStorageTexelBufferArrayNonUniformIndexing indicates whether
    arrays of storage texel buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageTexelBufferArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-descriptorBindingUniformBufferUpdateAfterBind]]
    pname:descriptorBindingUniformBufferUpdateAfterBind indicates whether
    the implementation supports updating uniform buffer descriptors after a
    set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER.
  * [[{anchor-prefix}features-descriptorBindingSampledImageUpdateAfterBind]]
    pname:descriptorBindingSampledImageUpdateAfterBind indicates whether the
    implementation supports updating sampled image descriptors after a set
    is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE.
  * [[{anchor-prefix}features-descriptorBindingStorageImageUpdateAfterBind]]
    pname:descriptorBindingStorageImageUpdateAfterBind indicates whether the
    implementation supports updating storage image descriptors after a set
    is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.
  * [[{anchor-prefix}features-descriptorBindingStorageBufferUpdateAfterBind]]
    pname:descriptorBindingStorageBufferUpdateAfterBind indicates whether
    the implementation supports updating storage buffer descriptors after a
    set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER.
  * [[{anchor-prefix}features-descriptorBindingUniformTexelBufferUpdateAfterBind]]
    pname:descriptorBindingUniformTexelBufferUpdateAfterBind indicates
    whether the implementation supports updating uniform texel buffer
    descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.
  * [[{anchor-prefix}features-descriptorBindingStorageTexelBufferUpdateAfterBind]]
    pname:descriptorBindingStorageTexelBufferUpdateAfterBind indicates
    whether the implementation supports updating storage texel buffer
    descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.
  * [[{anchor-prefix}features-descriptorBindingUpdateUnusedWhilePending]]
    pname:descriptorBindingUpdateUnusedWhilePending indicates whether the
    implementation supports updating descriptors while the set is in use.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT must: not be
    used.
  * [[{anchor-prefix}features-descriptorBindingPartiallyBound]]
    pname:descriptorBindingPartiallyBound indicates whether the
    implementation supports statically using a descriptor set binding in
    which some descriptors are not valid.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT must: not be used.
  * [[{anchor-prefix}features-descriptorBindingVariableDescriptorCount]]
    pname:descriptorBindingVariableDescriptorCount indicates whether the
    implementation supports descriptor sets with a variable-sized last
    binding.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT must: not be
    used.
  * [[{anchor-prefix}features-runtimeDescriptorArray]]
    pname:runtimeDescriptorArray indicates whether the implementation
    supports the SPIR-V code:RuntimeDescriptorArray capability.
    If this feature is not enabled, descriptors must: not be declared in
    runtime arrays.
// end::VK_EXT_descriptor_indexing-features[]

If the sname:VkPhysicalDeviceDescriptorIndexingFeatures structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceDescriptorIndexingFeatures can: also be included in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceDescriptorIndexingFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]

ifdef::VK_EXT_vertex_attribute_divisor[]

[open,refpage='VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT',desc='Structure describing if fetching of vertex attribute may be repeated for instanced rendering',type='structs']
--
The sname:VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * [[features-vertexAttributeInstanceRateDivisor]]
    pname:vertexAttributeInstanceRateDivisor specifies whether vertex
    attribute fetching may be repeated in case of instanced rendering.
  * [[features-vertexAttributeInstanceRateZeroDivisor]]
    pname:vertexAttributeInstanceRateZeroDivisor specifies whether a zero
    value for sname:VkVertexInputBindingDivisorDescriptionEXT::pname:divisor
    is supported.

If the sname:VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating the implementation-dependent behavior.
sname:VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT can: also be
included in pname:pNext chain of slink:VkDeviceCreateInfo to enable the
feature.

include::{generated}/validity/structs/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.txt[]
--

endif::VK_EXT_vertex_attribute_divisor[]

ifdef::VK_EXT_astc_decode_mode[]

[open,refpage='VkPhysicalDeviceASTCDecodeFeaturesEXT',desc='Structure describing ASTC decode mode features',type='structs']
--
The sname:VkPhysicalDeviceASTCDecodeFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceASTCDecodeFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceASTCDecodeFeaturesEXT structure
describe the following features:

  * [[features-astc-decodeModeSharedExponent]]
    pname:decodeModeSharedExponent indicates whether the implementation
    supports decoding ASTC compressed formats to
    ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 internal precision.

If the sname:VkPhysicalDeviceASTCDecodeFeaturesEXT structure is included in
the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled with
values indicating whether each feature is supported.
sname:VkPhysicalDeviceASTCDecodeFeaturesEXT can: also be included in the
pname:pNext chain of flink:vkCreateDevice to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceASTCDecodeFeaturesEXT.txt[]
--

endif::VK_EXT_astc_decode_mode[]

ifdef::VK_EXT_transform_feedback[]

[open,refpage='VkPhysicalDeviceTransformFeedbackFeaturesEXT',desc='Structure describing transform feedback features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceTransformFeedbackFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT
structure describe the following features:

  * [[features-transformFeedback]] pname:transformFeedback indicates whether
    the implementation supports transform feedback and shader modules can:
    declare the code:TransformFeedback capability.

  * [[features-geometryStreams]] pname:geometryStreams indicates whether the
    implementation supports the code:GeometryStreams SPIR-V capability.

If the sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT can: also be included in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceTransformFeedbackFeaturesEXT.txt[]
--

endif::VK_EXT_transform_feedback[]

ifdef::VK_VERSION_1_2,VK_KHR_vulkan_memory_model[]
[open,refpage='VkPhysicalDeviceVulkanMemoryModelFeatures',desc='Structure describing features supported by the memory model',type='structs']
--
To query memory model features additionally supported call
flink:vkGetPhysicalDeviceFeatures2 with a
sname:VkPhysicalDeviceVulkanMemoryModelFeatures structure included in the
pname:pNext chain of its pname:pFeatures parameter.
The sname:VkPhysicalDeviceVulkanMemoryModelFeatures structure can: also be
included in the pname:pNext chain of a slink:VkDeviceCreateInfo structure,
in which case it controls which additional features are enabled in the
device.

The slink:VkPhysicalDeviceVulkanMemoryModelFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVulkanMemoryModelFeatures.txt[]

ifdef::VK_KHR_vulkan_memory_model[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.txt[]
endif::VK_KHR_vulkan_memory_model[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_vulkan_memory_model-features[]
  * [[{anchor-prefix}features-vulkanMemoryModel]] pname:vulkanMemoryModel
    indicates whether the Vulkan Memory Model is supported, as defined in
    <<memory-model,Vulkan Memory Model>>.
    This also indicates whether shader modules can: declare the
    code:VulkanMemoryModel capability.
  * [[{anchor-prefix}features-vulkanMemoryModelDeviceScope]]
    pname:vulkanMemoryModelDeviceScope indicates whether the Vulkan Memory
    Model can use code:Device scope synchronization.
    This also indicates whether shader modules can: declare the
    code:VulkanMemoryModelDeviceScope capability.
  * [[{anchor-prefix}features-vulkanMemoryModelAvailabilityVisibilityChains]]
    pname:vulkanMemoryModelAvailabilityVisibilityChains indicates whether
    the Vulkan Memory Model can use <<memory-model-availability-visibility,
    availability and visibility chains>> with more than one element.
// end::VK_KHR_vulkan_memory_model-features[]

include::{generated}/validity/structs/VkPhysicalDeviceVulkanMemoryModelFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_vulkan_memory_model[]

ifdef::VK_EXT_inline_uniform_block[]

[open,refpage='VkPhysicalDeviceInlineUniformBlockFeaturesEXT',desc='Structure describing inline uniform block features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceInlineUniformBlockFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceInlineUniformBlockFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceInlineUniformBlockFeaturesEXT
structure describe the following features:

  * [[features-inlineUniformBlock]] pname:inlineUniformBlock indicates
    whether the implementation supports inline uniform block descriptors.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT must: not be used.
  * [[features-descriptorBindingInlineUniformBlockUpdateAfterBind]]
    pname:descriptorBindingInlineUniformBlockUpdateAfterBind
ifndef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    is ename:VK_FALSE and reserved for future use.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    indicates whether the implementation supports updating inline uniform
    block descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]

If the sname:VkPhysicalDeviceInlineUniformBlockFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceInlineUniformBlockFeaturesEXT can: also be included in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceInlineUniformBlockFeaturesEXT.txt[]
--

endif::VK_EXT_inline_uniform_block[]

ifdef::VK_NV_representative_fragment_test[]
[open,refpage='VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV',desc='Structure describing the representative fragment test features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.txt[]

The members of the
sname:VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure
describe the following features:

  * [[features-representativeFragmentTest]] pname:representativeFragmentTest
    indicates whether the implementation supports the representative
    fragment test.
    See <<fragops-rep-frag-test, Representative Fragment Test>>.

If the sname:VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure
is included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it
is filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV can: also be
included in the pname:pNext chain of slink:VkDeviceCreateInfo to enable the
feature.

include::{generated}/validity/structs/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.txt[]
--
endif::VK_NV_representative_fragment_test[]

ifdef::VK_NV_scissor_exclusive[]

[open,refpage='VkPhysicalDeviceExclusiveScissorFeaturesNV',desc='Structure describing exclusive scissor features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceExclusiveScissorFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceExclusiveScissorFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceExclusiveScissorFeaturesNV
structure describe the following features:

  * [[features-exclusiveScissor]] pname:exclusiveScissor indicates that the
    implementation supports the exclusive scissor test.

See <<fragops-exclusive-scissor,Exclusive Scissor Test>> for more
information.

If the sname:VkPhysicalDeviceExclusiveScissorFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceExclusiveScissorFeaturesNV can: also be included in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable the feature.

include::{generated}/validity/structs/VkPhysicalDeviceExclusiveScissorFeaturesNV.txt[]
--
endif::VK_NV_scissor_exclusive[]

ifdef::VK_NV_corner_sampled_image[]

[open,refpage='VkPhysicalDeviceCornerSampledImageFeaturesNV',desc='Structure describing corner sampled image features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCornerSampledImageFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCornerSampledImageFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceCornerSampledImageFeaturesNV
structure describe the following features:

  * [[features-cornersampledimage]] pname:cornerSampledImage specifies
    whether images can be created with a
    slink:VkImageCreateInfo::pname:flags containing
    ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV.
    See <<resources-images-corner-sampled,Corner-Sampled Images>>.

If the sname:VkPhysicalDeviceCornerSampledImageFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceCornerSampledImageFeaturesNV can: also be included in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceCornerSampledImageFeaturesNV.txt[]
--

endif::VK_NV_corner_sampled_image[]

ifdef::VK_NV_compute_shader_derivatives[]

[open,refpage='VkPhysicalDeviceComputeShaderDerivativesFeaturesNV',desc='Structure describing compute shader derivative features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceComputeShaderDerivativesFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceComputeShaderDerivativesFeaturesNV
structure describe the following features:

  * [[features-computeShaderDerivativesQuads]]
    pname:computeDerivativeGroupQuads indicates that the implementation
    supports the code:ComputeDerivativeGroupQuadsNV SPIR-V capability.
  * [[features-computeShaderDerivativesLinear]]
    pname:computeDerivativeGroupLinear indicates that the implementation
    supports the code:ComputeDerivativeGroupLinearNV SPIR-V capability.

See <<texture-derivatives-compute,Compute Shader Derivatives>> for more
information.

If the sname:VkPhysicalDeviceComputeShaderDerivativesFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceComputeShaderDerivativesFeaturesNV can: also be
included in the pname:pNext chain of slink:VkDeviceCreateInfo to enable
features.

include::{generated}/validity/structs/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.txt[]
--

endif::VK_NV_compute_shader_derivatives[]

ifdef::VK_NV_fragment_shader_barycentric[]

[open,refpage='VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV',desc='Structure describing barycentric support in fragment shaders that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV
structure describe the following features:

  * [[features-fragmentShaderBarycentric]] pname:fragmentShaderBarycentric
    indicates that the implementation supports the code:BaryCoordNV and
    code:BaryCoordNoPerspNV SPIR-V fragment shader built-ins and supports
    the code:PerVertexNV SPIR-V decoration on fragment shader input
    variables.

See <<primsrast-barycentric,Barycentric Interpolation>> for more
information.

If the sname:VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV structure
is included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it
is filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV can: also be
included in the pname:pNext chain of slink:VkDeviceCreateInfo to enable
features.

include::{generated}/validity/structs/VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.txt[]
--

endif::VK_NV_fragment_shader_barycentric[]

ifdef::VK_NV_shader_image_footprint[]

[open,refpage='VkPhysicalDeviceShaderImageFootprintFeaturesNV',desc='Structure describing shader image footprint features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderImageFootprintFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderImageFootprintFeaturesNV.txt[]

  * [[features-imageFootprint]] pname:imageFootprint specifies whether the
    implementation supports the code:ImageFootprintNV SPIR-V capability.

See <<textures-footprint,Texel Footprint Evaluation>> for more information.

If the sname:VkPhysicalDeviceShaderImageFootprintFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceShaderImageFootprintFeaturesNV can: also be included
in the pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceShaderImageFootprintFeaturesNV.txt[]
--

endif::VK_NV_shader_image_footprint[]


ifdef::VK_NV_shading_rate_image[]

[open,refpage='VkPhysicalDeviceShadingRateImageFeaturesNV',desc='Structure describing shading rate image features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShadingRateImageFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShadingRateImageFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceShadingRateImageFeaturesNV
structure describe the following features:

  * [[features-shadingRateImage]] pname:shadingRateImage indicates that the
    implementation supports the use of a shading rate image to derive an
    effective shading rate for fragment processing.
    It also indicates that the implementation supports the
    code:ShadingRateNV SPIR-V execution mode.
  * [[features-shadingRateCoarseSampleOrder]]
    pname:shadingRateCoarseSampleOrder indicates that the implementation
    supports a user-configurable ordering of coverage samples in fragments
    larger than one pixel.

See <<primsrast-shading-rate-image, Shading Rate Image>> for more
information.

If the sname:VkPhysicalDeviceShadingRateImageFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceShadingRateImageFeaturesNV can: also be included in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceShadingRateImageFeaturesNV.txt[]
--

endif::VK_NV_shading_rate_image[]

ifdef::VK_EXT_fragment_density_map[]

[open,refpage='VkPhysicalDeviceFragmentDensityMapFeaturesEXT',desc='Structure describing fragment density map features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceFragmentDensityMapFeaturesEXT
structure describe the following features:

  * [[features-fragmentdensitymap]] pname:fragmentDensityMap specifies
    whether the implementation supports render passes with a fragment
    density map attachment.
    If this feature is not enabled and the pname:pNext chain of
    slink:VkRenderPassCreateInfo includes a
    slink:VkRenderPassFragmentDensityMapCreateInfoEXT structure,
    pname:fragmentDensityMapAttachment must: be ename:VK_ATTACHMENT_UNUSED.
  * [[features-fragmentdensitymapdynamic]] pname:fragmentDensityMapDynamic
    specifies whether the implementation supports dynamic fragment density
    map image views.
    If this feature is not enabled,
    ename:VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT must:
    not be included in slink:VkImageViewCreateInfo::pname:flags.
  * [[features-nonsubsampledimages]]
    pname:fragmentDensityMapNonSubsampledImages specifies whether the
    implementation supports regular non-subsampled image attachments with
    fragment density map render passes.
    If this feature is not enabled, render passes with a
    <<renderpass-fragmentdensitymapattachment,fragment density map
    attachment>> must: only have <<samplers-subsamplesampler,subsampled
    attachments>> bound.

If the sname:VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceFragmentDensityMapFeaturesEXT can: also be included in
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

include::{generated}/validity/structs/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.txt[]
--

endif::VK_EXT_fragment_density_map[]

ifdef::VK_VERSION_1_2,VK_EXT_scalar_block_layout[]

[open,refpage='VkPhysicalDeviceScalarBlockLayoutFeatures',desc='Structure indicating support for scalar block layouts',type='structs',alias='VkPhysicalDeviceScalarBlockLayoutFeaturesEXT']
--
The sname:VkPhysicalDeviceScalarBlockLayoutFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceScalarBlockLayoutFeatures.txt[]

ifdef::VK_EXT_scalar_block_layout[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.txt[]
endif::VK_EXT_scalar_block_layout[]

The members of the sname:VkPhysicalDeviceScalarBlockLayoutFeatures structure
describe the following features:

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_scalar_block_layout-features[]
  * [[{anchor-prefix}features-scalarBlockLayout]] pname:scalarBlockLayout
    indicates that the implementation supports the layout of resource blocks
    in shaders using <<interfaces-alignment-requirements, scalar
    alignment>>.
// end::VK_EXT_scalar_block_layout-features[]

If the sname:VkPhysicalDeviceScalarBlockLayoutFeatures structure is included
in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled
with values indicating whether the feature is supported.
sname:VkPhysicalDeviceScalarBlockLayoutFeatures can: also be included in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable this feature.

include::{generated}/validity/structs/VkPhysicalDeviceScalarBlockLayoutFeatures.txt[]
--

endif::VK_VERSION_1_2,VK_EXT_scalar_block_layout[]

ifdef::VK_VERSION_1_2,VK_KHR_uniform_buffer_standard_layout[]

[open,refpage='VkPhysicalDeviceUniformBufferStandardLayoutFeatures',desc='Structure indicating support for std430-like packing in uniform buffers',type='structs',alias='VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR']
--
The sname:VkPhysicalDeviceUniformBufferStandardLayoutFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceUniformBufferStandardLayoutFeatures.txt[]

ifdef::VK_KHR_uniform_buffer_standard_layout[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.txt[]
endif::VK_KHR_uniform_buffer_standard_layout[]

The members of the sname:VkPhysicalDeviceUniformBufferStandardLayoutFeatures
structure describe the following features:

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_uniform_buffer_standard_layout-features[]
  * [[{anchor-prefix}features-uniformBufferStandardLayout]]
    pname:uniformBufferStandardLayout indicates that the implementation
    supports the same layouts for uniform buffers as for storage and other
    kinds of buffers.
    See <<interfaces-resources-standard-layout,Standard Buffer Layout>>.
// end::VK_KHR_uniform_buffer_standard_layout-features[]

If the sname:VkPhysicalDeviceUniformBufferStandardLayoutFeatures structure
is included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it
is filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceUniformBufferStandardLayoutFeatures can: also be
included in the pname:pNext chain of slink:VkDeviceCreateInfo to enable this
feature.

include::{generated}/validity/structs/VkPhysicalDeviceUniformBufferStandardLayoutFeatures.txt[]
--

endif::VK_VERSION_1_2,VK_KHR_uniform_buffer_standard_layout[]

ifdef::VK_EXT_depth_clip_enable[]

[open,refpage='VkPhysicalDeviceDepthClipEnableFeaturesEXT',desc='Structure indicating support for explicit enable of depth clip',type='structs']
--
The sname:VkPhysicalDeviceDepthClipEnableFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDepthClipEnableFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceDepthClipEnableFeaturesEXT
structure describe the following features:

  * [[features-depthClipEnable]] pname:depthClipEnable indicates that the
    implementation supports setting the depth clipping operation explicitly
    via the slink:VkPipelineRasterizationDepthClipStateCreateInfoEXT
    pipeline state.
    Otherwise depth clipping is only enabled when
    slink:VkPipelineRasterizationStateCreateInfo::pname:depthClampEnable is
    set to ename:VK_FALSE.

If the sname:VkPhysicalDeviceDepthClipEnableFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceDepthClipEnableFeaturesEXT can: also be included in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable this feature.

include::{generated}/validity/structs/VkPhysicalDeviceDepthClipEnableFeaturesEXT.txt[]
--

endif::VK_EXT_depth_clip_enable[]

ifdef::VK_EXT_memory_priority[]

[open,refpage='VkPhysicalDeviceMemoryPriorityFeaturesEXT',desc='Structure describing memory priority features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMemoryPriorityFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMemoryPriorityFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceMemoryPriorityFeaturesEXT structure
describe the following features:

  * [[features-memoryPriority]] pname:memoryPriority indicates that the
    implementation supports memory priorities specified at memory allocation
    time via slink:VkMemoryPriorityAllocateInfoEXT.

If the sname:VkPhysicalDeviceMemoryPriorityFeaturesEXT structure is included
in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled
with values indicating whether the feature is supported.
sname:VkPhysicalDeviceMemoryPriorityFeaturesEXT can: also be included in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceMemoryPriorityFeaturesEXT.txt[]
--

endif::VK_EXT_memory_priority[]

ifdef::VK_VERSION_1_2,VK_KHR_buffer_device_address[]

[open,refpage='VkPhysicalDeviceBufferDeviceAddressFeatures',desc='Structure describing buffer address features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceBufferDeviceAddressFeaturesKHR']
--
The sname:VkPhysicalDeviceBufferDeviceAddressFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceBufferDeviceAddressFeatures.txt[]

ifdef::VK_KHR_buffer_device_address[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceBufferDeviceAddressFeaturesKHR.txt[]
endif::VK_KHR_buffer_device_address[]

The members of the sname:VkPhysicalDeviceBufferDeviceAddressFeatures
structure describe the following features:

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_buffer_device_address-features[]
  * [[{anchor-prefix}features-bufferDeviceAddress]]
    pname:bufferDeviceAddress indicates that the implementation supports
    accessing buffer memory in shaders as storage buffers via an address
    queried from flink:vkGetBufferDeviceAddress.
  * [[{anchor-prefix}features-bufferDeviceAddressCaptureReplay]]
    pname:bufferDeviceAddressCaptureReplay indicates that the implementation
    supports saving and reusing buffer and device addresses, e.g. for trace
    capture and replay.
  * [[{anchor-prefix}features-bufferDeviceAddressMultiDevice]]
    pname:bufferDeviceAddressMultiDevice indicates that the implementation
    supports the pname:bufferDeviceAddress
ifndef::VK_KHR_ray_tracing[feature]
ifdef::VK_KHR_ray_tracing[]
    and pname:rayTracing features
endif::VK_KHR_ray_tracing[]
    for logical devices created with multiple physical devices.
    If this feature is not supported, buffer
ifdef::VK_KHR_ray_tracing[]
    and acceleration structure
endif::VK_KHR_ray_tracing[]
    addresses must: not be queried on a logical device created with more
    than one physical device.
// end::VK_EXT_buffer_device_address-features[]

[NOTE]
.Note
====
pname:bufferDeviceAddressMultiDevice exists to allow certain legacy
platforms to be able to support pname:bufferDeviceAddress without needing to
support shared GPU virtual addresses for multi-device configurations.
====

See flink:vkGetBufferDeviceAddress for more information.

If the sname:VkPhysicalDeviceBufferDeviceAddressFeatures structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceBufferDeviceAddressFeatures can: also be included in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceBufferDeviceAddressFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_buffer_device_address[]

ifdef::VK_EXT_buffer_device_address[]
[open,refpage='VkPhysicalDeviceBufferDeviceAddressFeaturesEXT',desc='Structure describing buffer address features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
structure describe the following features:

  * [[features-bufferDeviceAddressEXT]] pname:bufferDeviceAddress indicates
    that the implementation supports accessing buffer memory in shaders as
    storage buffers via an address queried from
    flink:vkGetBufferDeviceAddressEXT.
  * [[features-bufferDeviceAddressCaptureReplayEXT]]
    pname:bufferDeviceAddressCaptureReplay indicates that the implementation
    supports saving and reusing buffer addresses, e.g. for trace capture and
    replay.
  * [[features-bufferDeviceAddressMultiDeviceEXT]]
    pname:bufferDeviceAddressMultiDevice indicates that the implementation
    supports the pname:bufferDeviceAddress feature for logical devices
    created with multiple physical devices.
    If this feature is not supported, buffer addresses must: not be queried
    on a logical device created with more than one physical device.

If the sname:VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceBufferDeviceAddressFeaturesEXT can: also be included
in the pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

ifdef::VK_VERSION_1_2,VK_KHR_buffer_device_address[]
[NOTE]
.Note
====
The sname:VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure has the
same members as the sname:VkPhysicalDeviceBufferDeviceAddressFeatures
structure, but the functionality indicated by the members is expressed
differently.
The features indicated by the
sname:VkPhysicalDeviceBufferDeviceAddressFeatures structure requires
additional flags to be passed at memory allocation time, and the capture and
replay mechanism is built around opaque capture addresses for buffer and
memory objects.
====
endif::VK_VERSION_1_2,VK_KHR_buffer_device_address[]

include::{generated}/validity/structs/VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.txt[]
--
endif::VK_EXT_buffer_device_address[]

ifdef::VK_NV_dedicated_allocation_image_aliasing[]

[open,refpage='VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV',desc='Structure describing dedicated allocation image aliasing features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.txt[]

The members of the
sname:VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV structure
describe the following features:

  * [[features-dedicatedAllocationImageAliasing]]
  pname:dedicatedAllocationImageAliasing indicates that the implementation
  supports aliasing of compatible image objects on a dedicated allocation.

If the sname:VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
structure is included in the pname:pNext chain of
slink:VkPhysicalDeviceFeatures2, it is filled with values indicating whether
each feature is supported.
sname:VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV can: also
be included in the pname:pNext chain of slink:VkDeviceCreateInfo to enable
features.

include::{generated}/validity/structs/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.txt[]
--

endif::VK_NV_dedicated_allocation_image_aliasing[]

ifdef::VK_VERSION_1_2,VK_KHR_imageless_framebuffer[]

[open,refpage='VkPhysicalDeviceImagelessFramebufferFeatures',desc='Structure indicating support for imageless framebuffers',type='structs',alias='VkPhysicalDeviceImagelessFramebufferFeaturesKHR']
--
The sname:VkPhysicalDeviceImagelessFramebufferFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceImagelessFramebufferFeatures.txt[]

ifdef::VK_KHR_imageless_framebuffer[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceImagelessFramebufferFeaturesKHR.txt[]
endif::VK_KHR_imageless_framebuffer[]

The members of the sname:VkPhysicalDeviceImagelessFramebufferFeatures
structure describe the following features:

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_imageless_framebuffer-features[]
  * [[{anchor-prefix}features-imagelessFramebuffer]]
    pname:imagelessFramebuffer indicates that the implementation supports
    specifying the image view for attachments at render pass begin time via
    slink:VkRenderPassAttachmentBeginInfo.
// end::VK_KHR_imageless_framebuffer-features[]

If the sname:VkPhysicalDeviceImagelessFramebufferFeatures structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceImagelessFramebufferFeatures can: also be included in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable this feature.

include::{generated}/validity/structs/VkPhysicalDeviceImagelessFramebufferFeatures.txt[]
--

endif::VK_VERSION_1_2,VK_KHR_imageless_framebuffer[]

ifdef::VK_EXT_fragment_shader_interlock[]

[open,refpage='VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT',desc='Structure describing fragment shader interlock features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
structure describe the following features:

  * [[features-fragmentShaderSampleInterlock]]
    pname:fragmentShaderSampleInterlock indicates that the implementation
    supports the code:FragmentShaderSampleInterlockEXT SPIR-V capability.

  * [[features-fragmentShaderPixelInterlock]]
    pname:fragmentShaderPixelInterlock indicates that the implementation
    supports the code:FragmentShaderPixelInterlockEXT SPIR-V capability.

  * [[features-fragmentShaderShadingRateInterlock]]
    pname:fragmentShaderShadingRateInterlock indicates that the
    implementation supports the code:FragmentShaderShadingRateInterlockEXT
    SPIR-V capability.

If the sname:VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT can: also be
included in the pname:pNext chain of slink:VkDeviceCreateInfo to enable
features.

include::{generated}/validity/structs/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.txt[]
--

endif::VK_EXT_fragment_shader_interlock[]

ifdef::VK_NV_cooperative_matrix[]

[open,refpage='VkPhysicalDeviceCooperativeMatrixFeaturesNV',desc='Structure describing cooperative matrix features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCooperativeMatrixFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCooperativeMatrixFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceCooperativeMatrixFeaturesNV
structure describe the following features:

  * [[features-cooperativeMatrix]] pname:cooperativeMatrix indicates that
    the implementation supports the code:CooperativeMatrixNV SPIR-V
    capability.
  * [[features-cooperativeMatrixRobustBufferAccess]]
    pname:cooperativeMatrixRobustBufferAccess indicates that the
    implementation supports robust buffer access for SPIR-V
    code:OpCooperativeMatrixLoadNV and code:OpCooperativeMatrixStoreNV
    instructions.

If the sname:VkPhysicalDeviceCooperativeMatrixFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceCooperativeMatrixFeaturesNV can: also be included in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceCooperativeMatrixFeaturesNV.txt[]
--

endif::VK_NV_cooperative_matrix[]

ifdef::VK_EXT_ycbcr_image_arrays[]

[open,refpage='VkPhysicalDeviceYcbcrImageArraysFeaturesEXT',desc='Structure describing extended Y\'CbCr image creation features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
structure describe the following features:

  * [[features-ycbcrImageArrays]] pname:ycbcrImageArrays indicates that the
    implementation supports creating images with a format that requires
    <<formats-requiring-sampler-ycbcr-conversion, {YCbCr} conversion>> and
    has multiple array layers.

If the sname:VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceYcbcrImageArraysFeaturesEXT can: also be included in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.txt[]
--

endif::VK_EXT_ycbcr_image_arrays[]

ifdef::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]

[open,refpage='VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures',desc='Structure describing the extended types subgroups support feature for an implementation',type='structs',alias='VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR']
--

The sname:VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.txt[]

ifdef::VK_KHR_shader_subgroup_extended_types[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR.txt[]
endif::VK_KHR_shader_subgroup_extended_types[]

The members of the sname:VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
structure describe the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_shader_subgroup_extended_types-features[]
  * [[{anchor-prefix}features-subgroup-extended-types]]
    pname:shaderSubgroupExtendedTypes is a boolean that specifies whether
    subgroup operations can use 8-bit integer, 16-bit integer, 64-bit
    integer, 16-bit floating-point, and vectors of these types in
    <<shaders-group-operations,group operations>> with
    <<shaders-scope-subgroup, subgroup scope>>if the implementation supports
    the types.
// end::VK_KHR_shader_subgroup_extended_types-features[]

If the sname:VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures structure
is included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it
is filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures can: also be
included in the pname:pNext chain of slink:VkDeviceCreateInfo to enable
features.

include::{generated}/validity/structs/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.txt[]

--

endif::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_2,VK_EXT_host_query_reset[]

[open,refpage='VkPhysicalDeviceHostQueryResetFeatures',desc='Structure describing whether queries can be reset from the host',type='structs',alias='VkPhysicalDeviceHostQueryResetFeaturesEXT']
--
The sname:VkPhysicalDeviceHostQueryResetFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceHostQueryResetFeatures.txt[]

ifdef::VK_EXT_host_query_reset[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceHostQueryResetFeaturesEXT.txt[]
endif::VK_EXT_host_query_reset[]

The members of the sname:VkPhysicalDeviceHostQueryResetFeatures structure
describe the following features:

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_host_query_reset-features[]
  * [[{anchor-prefix}features-hostQueryReset]] pname:hostQueryReset
    indicates that the implementation supports resetting queries from the
    host with flink:vkResetQueryPool.
// end::VK_EXT_host_query_reset-features[]

If the sname:VkPhysicalDeviceHostQueryResetFeatures structure is included in
the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled with
values indicating whether the feature is supported.
sname:VkPhysicalDeviceHostQueryResetFeatures can: also be included in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceHostQueryResetFeatures.txt[]
--

endif::VK_VERSION_1_2,VK_EXT_host_query_reset[]

ifdef::VK_INTEL_shader_integer_functions2[]

[open,refpage='VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL',desc='Structure describing shader integer functions that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.txt[]

The members of the
sname:VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL structure
describe the following features:

  * [[features-shaderIntegerFunctions2]] pname:shaderIntegerFunctions2
    indicates that the implementation supports the
    code:ShaderIntegerFunctions2INTEL SPIR-V capability.

If the sname:VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL structure
is included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it
is filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL can: also be
included in the pname:pNext chain of slink:VkDeviceCreateInfo to enable
features.

include::{generated}/validity/structs/VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.txt[]
--

endif::VK_INTEL_shader_integer_functions2[]


ifdef::VK_NV_coverage_reduction_mode[]
[open,refpage='VkPhysicalDeviceCoverageReductionModeFeaturesNV',desc='Structure describing the coverage reduction mode features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCoverageReductionModeFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceCoverageReductionModeFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceCoverageReductionModeFeaturesNV
structure describe the following features:

  * [[features-coverageReductionMode]] pname:coverageReductionMode indicates
    whether the implementation supports coverage reduction modes.
    See <<fragops-coverage-reduction, Coverage Reduction>>.

If the sname:VkPhysicalDeviceCoverageReductionModeFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceCoverageReductionModeFeaturesNV can: also be included
in the pname:pNext chain of slink:VkDeviceCreateInfo to enable the feature.

include::{generated}/validity/structs/VkPhysicalDeviceCoverageReductionModeFeaturesNV.txt[]
--
endif::VK_NV_coverage_reduction_mode[]

ifdef::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]

[open,refpage='VkPhysicalDeviceTimelineSemaphoreFeatures',desc='Structure describing timeline semaphore features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceTimelineSemaphoreFeaturesKHR']
--
The sname:VkPhysicalDeviceTimelineSemaphoreFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceTimelineSemaphoreFeatures.txt[]

ifdef::VK_KHR_timeline_semaphore[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceTimelineSemaphoreFeaturesKHR.txt[]
endif::VK_KHR_timeline_semaphore[]

The members of the sname:VkPhysicalDeviceTimelineSemaphoreFeatures structure
describe the following features:

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_timeline_semaphore-features[]
  * [[{anchor-prefix}features-timelineSemaphore]] pname:timelineSemaphore
    indicates whether semaphores created with a elink:VkSemaphoreType of
    ename:VK_SEMAPHORE_TYPE_TIMELINE are supported.
// end::VK_KHR_timeline_semaphore-features[]

If the sname:VkPhysicalDeviceTimelineSemaphoreFeatures structure is included
in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled
with values indicating whether each feature is supported.
sname:VkPhysicalDeviceTimelineSemaphoreFeatures can: also be included in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceTimelineSemaphoreFeatures.txt[]
--

endif::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]

ifdef::VK_EXT_index_type_uint8[]

[open,refpage='VkPhysicalDeviceIndexTypeUint8FeaturesEXT',desc='Structure describing whether uint8 index type can be used',type='structs']
--
The sname:VkPhysicalDeviceIndexTypeUint8FeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceIndexTypeUint8FeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceIndexTypeUint8FeaturesEXT structure
describe the following features:

  * [[features-indexTypeUint8]] pname:indexTypeUint8 indicates that
    ename:VK_INDEX_TYPE_UINT8_EXT can be used with
    flink:vkCmdBindIndexBuffer.

If the sname:VkPhysicalDeviceIndexTypeUint8FeaturesEXT structure is included
in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled
with values indicating whether the feature is supported.
sname:VkPhysicalDeviceIndexTypeUint8FeaturesEXT can: also be included in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::{generated}/validity/structs/VkPhysicalDeviceIndexTypeUint8FeaturesEXT.txt[]
--

endif::VK_EXT_index_type_uint8[]

ifdef::VK_NV_shader_sm_builtins[]
[open,refpage='VkPhysicalDeviceShaderSMBuiltinsFeaturesNV',desc='Structure describing the shader SM Builtins features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderSMBuiltinsFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceShaderSMBuiltinsFeaturesNV
structure describe the following features:

  * [[features-shadersmbuiltins]] pname:shaderSMBuiltins indicates whether
    the implementation supports the SPIR-V code:ShaderSMBuiltinsNV
    capability.

If the sname:VkPhysicalDeviceShaderSMBuiltinsFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceShaderSMBuiltinsFeaturesNV can: also be included in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable the feature.

include::{generated}/validity/structs/VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.txt[]
--

endif::VK_NV_shader_sm_builtins[]

ifdef::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
[open,refpage='VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures',desc='Structure describing whether the implementation can do depth and stencil image barriers separately',type='structs',alias='VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR']
--
The sname:VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.txt[]

ifdef::VK_KHR_separate_depth_stencil_layouts[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.txt[]
endif::VK_KHR_separate_depth_stencil_layouts[]

The members of the sname:VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
structure describe the following features:

ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_separate_depth_stencil_layouts-features[]
  * [[{anchor-prefix}features-separateDepthStencilLayouts]]
    pname:separateDepthStencilLayouts indicates whether the implementation
    supports a sname:VkImageMemoryBarrier for a depth/stencil image with
    only one of ename:VK_IMAGE_ASPECT_DEPTH_BIT or
    ename:VK_IMAGE_ASPECT_STENCIL_BIT set, and whether
    ename:VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
    ename:VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
    ename:VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or
    ename:VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL can be used.
// end::VK_KHR_separate_depth_stencil_layouts-features[]

If the sname:VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures structure
is included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it
is filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures can: also be
included in the pname:pNext chain of slink:VkDeviceCreateInfo to enable the
feature.

include::{generated}/validity/structs/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]

ifdef::VK_KHR_pipeline_executable_properties[]

[open,refpage='VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR',desc='Structure describing whether pipeline executable properties are available',type='structs']
--
The sname:VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR structure
is defined as:

include::{generated}/api/structs/VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.txt[]

The members of the
sname:VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR structure
describe the following features:

  * [[features-pipelineExecutableInfo]] pname:pipelineExecutableInfo
    indicates that the implementation supports reporting properties and
    statistics about the executables associated with a compiled pipeline.

If the sname:VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR
structure is included in the pname:pNext chain of
slink:VkPhysicalDeviceFeatures2, it is filled with values indicating whether
the feature is supported.
sname:VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR can: also be
included in the pname:pNext chain of slink:VkDeviceCreateInfo to enable
features.

include::{generated}/validity/structs/VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.txt[]
--

endif::VK_KHR_pipeline_executable_properties[]

ifdef::VK_EXT_shader_demote_to_helper_invocation[]
[open,refpage='VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT',desc='Structure describing the shader demote to helper invocations features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.txt[]

The members of the
sname:VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT structure
describe the following features:

  * [[features-shaderDemoteToHelperInvocation]]
    pname:shaderDemoteToHelperInvocation indicates whether the
    implementation supports the SPIR-V code:DemoteToHelperInvocationEXT
    capability.

If the sname:VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
structure is included in the pname:pNext chain of
slink:VkPhysicalDeviceFeatures2, it is filled with values indicating whether
the feature is supported.
sname:VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT can: also be
included in the pname:pNext chain of slink:VkDeviceCreateInfo to enable the
feature.

include::{generated}/validity/structs/VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.txt[]
--

endif::VK_EXT_shader_demote_to_helper_invocation[]

ifdef::VK_EXT_texel_buffer_alignment[]
[open,refpage='VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT',desc='Structure describing the texel buffer alignment features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
structure describe the following features:

  * [[features-texelBufferAlignment]] pname:texelBufferAlignment indicates
    whether the implementation uses more specific alignment requirements
    advertised in slink:VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT
    rather than
    slink:VkPhysicalDeviceLimits::pname:minTexelBufferOffsetAlignment.

If the sname:VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT can: also be included
in the pname:pNext chain of slink:VkDeviceCreateInfo to enable the feature.

include::{generated}/validity/structs/VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.txt[]
--

endif::VK_EXT_texel_buffer_alignment[]

ifdef::VK_EXT_texture_compression_astc_hdr[]

[open,refpage='VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT',desc='Structure describing ASTC HDR features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.txt[]

The members of the
sname:VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT structure
describe the following features:

  * [[features-textureCompressionASTC_HDR]] pname:textureCompressionASTC_HDR
    indicates whether all of the ASTC HDR compressed texture formats are
    supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

If the sname:VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT structure
is included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it
is filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT can: also be
included in the pname:pNext chain of flink:vkCreateDevice to enable
features.

include::{generated}/validity/structs/VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.txt[]
--
endif::VK_EXT_texture_compression_astc_hdr[]

ifdef::VK_EXT_line_rasterization[]
[open,refpage='VkPhysicalDeviceLineRasterizationFeaturesEXT',desc='Structure describing the line rasterization features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceLineRasterizationFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceLineRasterizationFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceLineRasterizationFeaturesEXT
structure describe the following features:

  * [[features-rectangularLines]] pname:rectangularLines indicates whether
    the implementation supports <<primsrast-lines,rectangular line
    rasterization>>.
  * [[features-bresenhamLines]] pname:bresenhamLines indicates whether the
    implementation supports <<primsrast-lines-bresenham,Bresenham-style line
    rasterization>>.
  * [[features-smoothLines]] pname:smoothLines indicates whether the
    implementation supports <<primsrast-lines-smooth,smooth line
    rasterization>>.
  * [[features-stippledRectangularLines]] pname:stippledRectangularLines
    indicates whether the implementation supports
    <<primsrast-lines-stipple,stippled line rasterization>> with
    ename:VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT lines, or with
    ename:VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT lines if
    slink:VkPhysicalDeviceLimits::pname:strictLines is ename:VK_TRUE.
  * [[features-stippledBresenhamLines]] pname:stippledBresenhamLines
    indicates whether the implementation supports
    <<primsrast-lines-stipple,stippled line rasterization>> with
    ename:VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT lines.
  * [[features-stippledSmoothLines]] pname:stippledSmoothLines indicates
    whether the implementation supports <<primsrast-lines-stipple,stippled
    line rasterization>> with
    ename:VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT lines.

If the sname:VkPhysicalDeviceLineRasterizationFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceLineRasterizationFeaturesEXT can: also be included in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable the feature.

include::{generated}/validity/structs/VkPhysicalDeviceLineRasterizationFeaturesEXT.txt[]
--
endif::VK_EXT_line_rasterization[]

ifdef::VK_EXT_subgroup_size_control[]
[open,refpage='VkPhysicalDeviceSubgroupSizeControlFeaturesEXT',desc='Structure describing the subgroup size control features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT
structure describe the following features:

  * [[features-subgroupSizeControl]] pname:subgroupSizeControl indicates
    whether the implementation supports controlling shader subgroup sizes
    via the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT
    flag and the
    slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT structure.
  * [[features-computeFullSubgroups]] pname:computeFullSubgroups indicates
    whether the implementation supports requiring full subgroups in compute
    shaders via the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT
    flag.

If the sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT can: also be included
in the pname:pNext chain of slink:VkDeviceCreateInfo to enable the feature.

[NOTE]
.Note
====
The sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT structure was added
in version 2 of the `<<VK_EXT_subgroup_size_control>>` extension.
Version 1 implementations of this extension will not fill out the features
structure but applications may assume that both pname:subgroupSizeControl
and pname:computeFullSubgroups are supported if the extension is supported.
(See also the <<features-requirements, Feature Requirements>> section.)
Applications are advised to add a
sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT structure to the
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features
regardless of the version of the extension supported by the implementation.
If the implementation only supports version 1, it will safely ignore the
sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT structure.
====

include::{generated}/validity/structs/VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.txt[]
--
endif::VK_EXT_subgroup_size_control[]


ifdef::VK_AMD_device_coherent_memory[]

[open,refpage='VkPhysicalDeviceCoherentMemoryFeaturesAMD',desc='Structure describing whether device coherent memory can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCoherentMemoryFeaturesAMD structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceCoherentMemoryFeaturesAMD.txt[]

The members of the sname:VkPhysicalDeviceCoherentMemoryFeaturesAMD structure
describe the following features:

  * [[features-deviceCoherentMemory]] pname:deviceCoherentMemory indicates
    that the implementation supports <<VkMemoryPropertyFlagBits,device
    coherent memory>>.

include::{generated}/validity/structs/VkPhysicalDeviceCoherentMemoryFeaturesAMD.txt[]
--

endif::VK_AMD_device_coherent_memory[]

ifdef::VK_KHR_ray_tracing[]
[open,refpage='VkPhysicalDeviceRayTracingFeaturesKHR',desc='Structure describing the ray tracing features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRayTracingFeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceRayTracingFeaturesKHR.txt[]

The members of the sname:VkPhysicalDeviceRayTracingFeaturesKHR structure
describe the following features:

  * [[features-raytracing]] pname:rayTracing indicates whether the
    implementation supports ray tracing functionality.
    See <<ray-tracing,Ray Tracing>>.
  * [[features-raytracing-sghcapturereplay]]
    pname:rayTracingShaderGroupHandleCaptureReplay indicates whether the
    implementation supports saving and reusing shader group handles, e.g.
    for trace capture and replay.
  * [[features-raytracing-sghcapturereplaymixed]]
    pname:rayTracingShaderGroupHandleCaptureReplayMixed indicates whether
    the implementation supports reuse of shader group handles being
    arbitrarily mixed with creation of non-reused shader group handles.
    If this is ename:VK_FALSE, all reused shader group handles must: be
    specified before any non-reused handles may: be created.
  * [[features-raytracing-ascapturereplay]]
    pname:rayTracingAccelerationStructureCaptureReplay indicates whether the
    implementation supports saving and reusing acceleration structure device
    addresses, e.g. for trace capture and replay.
  * [[features-raytracing-indirecttraceray]]
    pname:rayTracingIndirectTraceRays indicates whether the implementation
    supports indirect trace ray commands, e.g.
    flink:vkCmdTraceRaysIndirectKHR.
  * [[features-raytracing-indirectasbuild]]
    pname:rayTracingIndirectAccelerationStructureBuild indicates whether the
    implementation supports indirect acceleration structure build commands,
    e.g. flink:vkCmdBuildAccelerationStructureIndirectKHR.
  * [[feature-raytracing-hostascmds]]
    pname:rayTracingHostAccelerationStructureCommands indicates whether the
    implementation supports host side acceleration structure commands, e.g.
    flink:vkBuildAccelerationStructureKHR,
    flink:vkCopyAccelerationStructureKHR,
    flink:vkCopyAccelerationStructureToMemoryKHR,
    flink:vkCopyMemoryToAccelerationStructureKHR,
    flink:vkWriteAccelerationStructuresPropertiesKHR.
  * [[features-rayQuery]] pname:rayQuery indicates whether the
    implementation supports ray query (code:OpRayQueryProceedKHR)
    functionality.
  * [[features-rayTracingPrimitiveCulling]] pname:rayTracingPrimitiveCulling
    indicates whether the implementation supports
    <<ray-traversal-culling-primitive, primitive culling during ray
    traversal>>.

If the sname:VkPhysicalDeviceRayTracingFeaturesKHR structure is included in
the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled with
values indicating whether the feature is supported.
sname:VkPhysicalDeviceRayTracingFeaturesKHR can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceRayTracingFeaturesKHR-rayTracingShaderGroupHandleCaptureReplayMixed-03348]]
    If pname:rayTracingShaderGroupHandleCaptureReplayMixed is ename:VK_TRUE,
    pname:rayTracingShaderGroupHandleCaptureReplay must: also be
    ename:VK_TRUE
****

include::{generated}/validity/structs/VkPhysicalDeviceRayTracingFeaturesKHR.txt[]
--
endif::VK_KHR_ray_tracing[]


ifdef::VK_NV_device_generated_commands[]
[open,refpage='VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV',desc='Structure describing the device-generated commands features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV
structure describe the following features:

  * [[feature-device-generated-commands]] pname:deviceGeneratedCommands
    indicates whether the implementation supports functionality to generate
    commands on the device.
    See <<device-generated-commands,Device-Generated Commands>>.

If the sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV can: also be used in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

include::{generated}/validity/structs/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.txt[]
--
endif::VK_NV_device_generated_commands[]

ifdef::VK_NV_device_diagnostics_config[]
[open,refpage='VkPhysicalDeviceDiagnosticsConfigFeaturesNV',desc='Structure describing the device-generated diagnostic configuration features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDiagnosticsConfigFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDiagnosticsConfigFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceDiagnosticsConfigFeaturesNV
structure describe the following features:

  * [[features-features-diagnosticsConfig]] pname:diagnosticsConfig
    indicates whether the implementation supports the ability to configure
    diagnostic tools.

If the sname:VkPhysicalDeviceDiagnosticsConfigFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceDiagnosticsConfigFeaturesNV can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable the feature.

include::{generated}/validity/structs/VkPhysicalDeviceDiagnosticsConfigFeaturesNV.txt[]
--
endif::VK_NV_device_diagnostics_config[]

ifdef::VK_EXT_pipeline_creation_cache_control[]

[open,refpage='VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT',desc='Structure describing whether pipeline cache control can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT structure
is defined as:

include::{generated}/api/structs/VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.txt[]

The members of the
sname:VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT structure
describe the following features:

  * [[feature-pipelineCreationCacheControl]]
    pname:pipelineCreationCacheControl indicates that the implementation
    supports:
  ** The following can: be used in stext:Vk*PipelineCreateInfo::pname:flags:
  *** ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT
  *** ename:VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT
  ** The following can: be used in
     slink:VkPipelineCacheCreateInfo::pname:flags:
  *** ename:VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT

If the sname:VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT
structure is included in the pname:pNext chain of
slink:VkPhysicalDeviceFeatures2, it is filled with values indicating whether
the feature is supported.
sname:VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT can: also be
used in the pname:pNext chain of slink:VkDeviceCreateInfo to enable
features.

include::{generated}/validity/structs/VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.txt[]
--

endif::VK_EXT_pipeline_creation_cache_control[]

ifdef::VK_EXT_private_data[]
[open,refpage='VkPhysicalDevicePrivateDataFeaturesEXT',desc='Structure specifying physical device support',type='structs']
--

The sname:VkPhysicalDevicePrivateDataFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDevicePrivateDataFeaturesEXT.txt[]

The members of the sname:VkPhysicalDevicePrivateDataFeaturesEXT structure
describe the following features:

  * [[features-privateData]] pname:privateData indicates whether the
    implementation supports private data.
    See <<private-data, Private Data>>.

If the sname:VkPhysicalDevicePrivateDataFeaturesEXT structure is included in
the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled with
values indicating whether the feature is supported.
sname:VkPhysicalDevicePrivateDataFeaturesEXT can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

include::{generated}/validity/structs/VkPhysicalDevicePrivateDataFeaturesEXT.txt[]
--
endif::VK_EXT_private_data[]

ifdef::VK_EXT_robustness2[]
[open,refpage='VkPhysicalDeviceRobustness2FeaturesEXT',desc='Structure describing the out-of-bounds behavior for an implementation',type='structs']
--
The sname:VkPhysicalDeviceRobustness2FeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceRobustness2FeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceRobustness2FeaturesEXT structure
describe the following features:

    * [[features-robustBufferAccess2]] pname:robustBufferAccess2 indicates
      whether buffer accesses are tightly bounds-checked against the range
      of the descriptor.
      Uniform buffers must: be bounds-checked to the range of the
      descriptor, where the range is rounded up to a multiple of
      <<limits-robustUniformBufferAccessSizeAlignment,robustUniformBufferAccessSizeAlignment>>.
      Storage buffers must: be bounds-checked to the range of the
      descriptor, where the range is rounded up to a multiple of
      <<limits-robustStorageBufferAccessSizeAlignment,robustStorageBufferAccessSizeAlignment>>.
      Out of bounds buffer loads will return zero values, and formatted
      loads will have [eq]#(0,0,1)# values inserted for missing G, B, or A
      components based on the format.
    * [[features-robustImageAccess2]] pname:robustImageAccess2 indicates
      whether image accesses are tightly bounds-checked against the
      dimensions of the image view.
      Out of bounds image loads will return zero values, with [eq]#(0,0,1)#
      values <<textures-conversion-to-rgba,inserted for missing G, B, or A
      components>> based on the format.
    * [[features-nullDescriptor]] pname:nullDescriptor indicates whether
      descriptors can: be written with a dlink:VK_NULL_HANDLE resource or
      view, which are considered valid to access and act as if the
      descriptor were bound to nothing.

If the sname:VkPhysicalDeviceRobustness2FeaturesEXT structure is included in
the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled with
values indicating whether each feature is supported.

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceRobustness2FeaturesEXT-robustBufferAccess2-04000]]
    If pname:robustBufferAccess2 is enabled then
    <<features-robustBufferAccess, pname:robustBufferAccess>> must: also be
    enabled
****

include::{generated}/validity/structs/VkPhysicalDeviceRobustness2FeaturesEXT.txt[]
--
endif::VK_EXT_robustness2[]

ifndef::VK_EXT_robustness2[]
[[features-nullDescriptor]] nullDescriptor support requires the
`VK_EXT_robustness2` extension.
endif::VK_EXT_robustness2[]


ifdef::VK_EXT_custom_border_color[]

[open,refpage='VkPhysicalDeviceCustomBorderColorFeaturesEXT',desc='Structure describing whether custom border colors can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCustomBorderColorFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCustomBorderColorFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceCustomBorderColorFeaturesEXT
structure describe the following features:

  * [[features-customBorderColors]] pname:customBorderColors indicates that
    the implementation supports providing a pname:borderColor value with one
    of the following values at sampler creation time:
+
    ** ename:VK_BORDER_COLOR_FLOAT_CUSTOM_EXT
    ** ename:VK_BORDER_COLOR_INT_CUSTOM_EXT
+

  * [[features-customBorderColorWithoutFormat]]
    pname:customBorderColorWithoutFormat indicates that explicit formats are
    not required for custom border colors and the value of the pname:format
    member of the slink:VkSamplerCustomBorderColorCreateInfoEXT structure
    may: be ename:VK_FORMAT_UNDEFINED.
    If this feature bit is not set, applications must: provide the
    elink:VkFormat of the image view(s) being sampled by this sampler in the
    pname:format member of the slink:VkSamplerCustomBorderColorCreateInfoEXT
    structure.

include::{generated}/validity/structs/VkPhysicalDeviceCustomBorderColorFeaturesEXT.txt[]
--

endif::VK_EXT_custom_border_color[]


[[features-requirements]]
== Feature Requirements

All Vulkan graphics implementations must: support the following features:

  * <<features-robustBufferAccess, pname:robustBufferAccess>>
ifdef::VK_VERSION_1_1[]
  * <<features-multiview, pname:multiview>>, if Vulkan 1.1 is supported.
endif::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_2,VK_KHR_uniform_buffer_standard_layout[]
  * <<features-uniformBufferStandardLayout,pname:uniformBufferStandardLayout>>,
    if Vulkan 1.2 or the `<<VK_KHR_uniform_buffer_standard_layout>>`
    extension is supported.
endif::VK_VERSION_1_2,VK_KHR_uniform_buffer_standard_layout[]
ifdef::VK_KHR_variable_pointers[]
  * <<features-variablePointersStorageBuffer,
    pname:variablePointersStorageBuffer>>, if the
    `<<VK_KHR_variable_pointers>>` extension is supported.
endif::VK_KHR_variable_pointers[]
ifdef::VK_KHR_8bit_storage[]
  * <<features-StorageBuffer8BitAccess, pname:storageBuffer8BitAccess>>, if
    the `<<VK_KHR_8bit_storage>>` extension is supported.
endif::VK_KHR_8bit_storage[]
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  * If
ifdef::VK_VERSION_1_2[the <<features-descriptorIndexing,descriptorIndexing>> feature is supported, or if]
    the `<<VK_EXT_descriptor_indexing>>` extension is supported:
  ** <<features-shaderSampledImageArrayDynamicIndexing,
     pname:shaderSampledImageArrayDynamicIndexing>>
  ** <<features-shaderStorageBufferArrayDynamicIndexing,
     pname:shaderStorageBufferArrayDynamicIndexing>>
  ** <<features-shaderUniformTexelBufferArrayDynamicIndexing,
     pname:shaderUniformTexelBufferArrayDynamicIndexing>>
  ** <<features-shaderStorageTexelBufferArrayDynamicIndexing,
     pname:shaderStorageTexelBufferArrayDynamicIndexing>>
  ** <<features-shaderSampledImageArrayNonUniformIndexing,
     pname:shaderSampledImageArrayNonUniformIndexing>>
  ** <<features-shaderStorageBufferArrayNonUniformIndexing,
     pname:shaderStorageBufferArrayNonUniformIndexing>>
  ** <<features-shaderUniformTexelBufferArrayNonUniformIndexing,
     pname:shaderUniformTexelBufferArrayNonUniformIndexing>>
  ** <<features-descriptorBindingSampledImageUpdateAfterBind,
     pname:descriptorBindingSampledImageUpdateAfterBind>>
  ** <<features-descriptorBindingStorageImageUpdateAfterBind,
     pname:descriptorBindingStorageImageUpdateAfterBind>>
  ** <<features-descriptorBindingStorageBufferUpdateAfterBind,
     pname:descriptorBindingStorageBufferUpdateAfterBind>> (see also
     <<limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-descriptorBindingUniformTexelBufferUpdateAfterBind,
     pname:descriptorBindingUniformTexelBufferUpdateAfterBind>> (see also
     <<limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-descriptorBindingStorageTexelBufferUpdateAfterBind,
     pname:descriptorBindingStorageTexelBufferUpdateAfterBind>> (see also
     <<limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-descriptorBindingUpdateUnusedWhilePending,
     pname:descriptorBindingUpdateUnusedWhilePending>>
  ** <<features-descriptorBindingPartiallyBound,
     pname:descriptorBindingPartiallyBound>>
  ** <<features-runtimeDescriptorArray, pname:runtimeDescriptorArray>>
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
ifdef::VK_EXT_inline_uniform_block[]
  * <<features-inlineUniformBlock,pname:inlineUniformBlock>>, if the
    `<<VK_EXT_inline_uniform_block>>` extension is supported.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  * <<features-descriptorBindingInlineUniformBlockUpdateAfterBind,
    pname:descriptorBindingInlineUniformBlockUpdateAfterBind>>, if the
    `<<VK_EXT_inline_uniform_block>>` extension is supported; and if
ifdef::VK_VERSION_1_2[the <<features-descriptorIndexing,pname:descriptorIndexing>> feature is supported, or]
    the `<<VK_EXT_descriptor_indexing>>` extension is supported.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
endif::VK_EXT_inline_uniform_block[]
ifdef::VK_EXT_scalar_block_layout[]
  * <<features-scalarBlockLayout,pname:scalarBlockLayout>>, if the
    `<<VK_EXT_scalar_block_layout>>` extension is supported.
endif::VK_EXT_scalar_block_layout[]
ifdef::VK_VERSION_1_2[]
  * <<features-subgroupBroadcastDynamicId,
    pname:subgroupBroadcastDynamicId>>, if Vulkan 1.2 is supported.
endif::VK_VERSION_1_2[]
ifdef::VK_VERSION_1_2+VK_KHR_sampler_mirror_clamp_to_edge[]
  * <<features-samplerMirrorClampToEdge, pname:samplerMirrorClampToEdge>>,
    if the `<<VK_KHR_sampler_mirror_clamp_to_edge>>` extension is supported.
endif::VK_VERSION_1_2+VK_KHR_sampler_mirror_clamp_to_edge[]
ifdef::VK_VERSION_1_2+VK_KHR_draw_indirect_count[]
  * <<features-drawIndirectCount, pname:drawIndirectCount>>, if the
    `<<VK_KHR_draw_indirect_count>>` extension is supported.
endif::VK_VERSION_1_2+VK_KHR_draw_indirect_count[]
ifdef::VK_VERSION_1_2+VK_EXT_sampler_filter_minmax[]
  * <<features-samplerFilterMinmax, pname:samplerFilterMinmax>>, if the
    `<<VK_EXT_sampler_filter_minmax>>` extension is supported.
endif::VK_VERSION_1_2+VK_EXT_sampler_filter_minmax[]
ifdef::VK_VERSION_1_2+VK_EXT_shader_viewport_index_layer[]
  * <<features-shaderOutputViewportIndex, pname:shaderOutputViewportIndex>>,
    if the `<<VK_EXT_shader_viewport_index_layer>>` extension is supported.
  * <<features-shaderOutputLayer, pname:shaderOutputLayer>>, if the
    `<<VK_EXT_shader_viewport_index_layer>>` extension is supported.
endif::VK_VERSION_1_2+VK_EXT_shader_viewport_index_layer[]
ifdef::VK_EXT_subgroup_size_control[]
  * <<features-subgroupSizeControl, pname:subgroupSizeControl>>, if the
    `<<VK_EXT_subgroup_size_control>>` extension is supported.
  * <<features-computeFullSubgroups, pname:computeFullSubgroups>>, if the
    `<<VK_EXT_subgroup_size_control>>` extension is supported.
endif::VK_EXT_subgroup_size_control[]
ifdef::VK_VERSION_1_2,VK_KHR_imageless_framebuffer[]
  * <<features-imagelessFramebuffer, pname:imagelessFramebuffer>>, if Vulkan
    1.2 or the `<<VK_KHR_imageless_framebuffer>>` extension is supported.
endif::VK_VERSION_1_2,VK_KHR_imageless_framebuffer[]
ifdef::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
  * <<features-separateDepthStencilLayouts,
    pname:separateDepthStencilLayouts>>, if Vulkan 1.2 or the
    `<<VK_KHR_separate_depth_stencil_layouts>>` extension is supported.
endif::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
ifdef::VK_VERSION_1_2,VK_EXT_host_query_reset[]
  * <<features-hostQueryReset, pname:hostQueryReset>>, if Vulkan 1.2 or the
  `<<VK_EXT_host_query_reset>>` extension is supported.
endif::VK_VERSION_1_2,VK_EXT_host_query_reset[]
ifdef::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]
  * <<features-timelineSemaphore, pname:timelineSemaphore>>, if Vulkan 1.2
    or the `<<VK_KHR_timeline_semaphore>>` extension is supported.
endif::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]
ifdef::VK_KHR_ray_tracing[]
  * If the `<<VK_KHR_ray_tracing>>` extension is supported:
  ** <<features-raytracing, pname:rayTracing>>
  ** <<features-raytracing-indirecttraceray,
     pname:rayTracingIndirectTraceRays>>
  ** All the features required by
ifdef::VK_VERSION_1_2[the <<features-descriptorIndexing,descriptorIndexing>> feature if Vulkan 1.2 is supported, or]
    the `<<VK_EXT_descriptor_indexing>>` extension.
  ** <<features-bufferDeviceAddress, pname:bufferDeviceAddress>> from
ifdef::VK_VERSION_1_2[Vulkan 1.2 or]
    the `<<VK_KHR_buffer_device_address>>` extension.
  ** <<features-rayTracingPrimitiveCulling,
     pname:rayTracingPrimitiveCulling>>, if <<features-rayQuery,
     pname:rayQuery>> is supported.
endif::VK_KHR_ray_tracing[]
ifdef::VK_EXT_pipeline_creation_cache_control[]
  * <<feature-pipelineCreationCacheControl,
    pname:pipelineCreationCacheControl>>, if the
    `<<VK_EXT_pipeline_creation_cache_control>>` extension is supported.
endif::VK_EXT_pipeline_creation_cache_control[]
ifdef::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]
  * <<features-subgroup-extended-types, pname:shaderSubgroupExtendedTypes>>,
    if Vulkan 1.2 or the `<<VK_KHR_shader_subgroup_extended_types>>`
    extension is supported.
endif::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]
ifdef::VK_KHR_sampler_ycbcr_conversion[]
  * <<features-sampler-YCbCr-conversion, pname:samplerYcbcrConversion>>, if
    the `<<VK_KHR_sampler_ycbcr_conversion>>` extension is supported.
endif::VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_KHR_pipeline_executable_properties[]
  * <<features-pipelineExecutableInfo, pname:pipelineExecutableInfo>>, if
    the `<<VK_KHR_pipeline_executable_properties>>` extension is supported.
endif::VK_KHR_pipeline_executable_properties[]
ifdef::VK_EXT_texture_compression_astc_hdr[]
  * <<features-textureCompressionASTC_HDR,
    pname:textureCompressionASTC_HDR>>, if the
    `<<VK_EXT_texture_compression_astc_hdr>>` extension is supported.
endif::VK_EXT_texture_compression_astc_hdr[]
ifdef::VK_EXT_depth_clip_enable[]
  * <<features-depthClipEnable, pname:depthClipEnable>>, if the
    `<<VK_EXT_depth_clip_enable>>` extension is supported.
endif::VK_EXT_depth_clip_enable[]
ifdef::VK_EXT_memory_priority[]
  * <<features-memoryPriority, pname:memoryPriority>>, if the
    `<<VK_EXT_memory_priority>>` extension is supported.
endif::VK_EXT_memory_priority[]
ifdef::VK_EXT_ycbcr_image_arrays[]
  * <<features-ycbcrImageArrays, pname:ycbcrImageArrays>>, if the
    `<<VK_EXT_ycbcr_image_arrays>>` extension is supported.
endif::VK_EXT_ycbcr_image_arrays[]
ifdef::VK_EXT_index_type_uint8[]
  * <<features-indexTypeUint8, pname:indexTypeUint8>>, if the
    `<<VK_EXT_index_type_uint8>>` extension is supported.
endif::VK_EXT_index_type_uint8[]
ifdef::VK_EXT_shader_demote_to_helper_invocation[]
  * <<features-shaderDemoteToHelperInvocation,
    pname:shaderDemoteToHelperInvocation>>, if the
    `<<VK_EXT_shader_demote_to_helper_invocation>>` extension is supported.
endif::VK_EXT_shader_demote_to_helper_invocation[]
ifdef::VK_EXT_texel_buffer_alignment[]
  * <<features-texelBufferAlignment, pname:texelBufferAlignment>>, if the
    `<<VK_EXT_texel_buffer_alignment>>` extension is supported.
endif::VK_EXT_texel_buffer_alignment[]
ifdef::VK_KHR_vulkan_memory_model[]
  * <<features-vulkanMemoryModel, pname:vulkanMemoryModel>>, if the
    `<<VK_KHR_vulkan_memory_model>>` extension is supported.
endif::VK_KHR_vulkan_memory_model[]
ifdef::VK_KHR_buffer_device_address[]
  * <<features-bufferDeviceAddress, pname:bufferDeviceAddress>>, if the
    `<<VK_KHR_buffer_device_address>>` extension is supported.
endif::VK_KHR_buffer_device_address[]
ifdef::VK_KHR_performance_query[]
  * <<VkPhysicalDevicePerformanceQueryFeaturesKHR,
    pname:performanceCounterQueryPools>>, if the
    `<<VK_KHR_performance_query>>` extension is supported.
endif::VK_KHR_performance_query[]
ifdef::VK_EXT_transform_feedback[]
  * <<features-transformFeedback, pname:transformFeedback>>, if the
    `<<VK_EXT_transform_feedback>>` extension is supported.
endif::VK_EXT_transform_feedback[]
ifdef::VK_EXT_conditional_rendering[]
  * <<features-conditionalRendering, pname:conditionalRendering>>, if the
    `<<VK_EXT_conditional_rendering>>` extension is supported.
endif::VK_EXT_conditional_rendering[]
ifdef::VK_EXT_vertex_attribute_divisor[]
  * <<features-vertexAttributeInstanceRateDivisor,
    pname:vertexAttributeInstanceRateDivisor>>, if the
    `<<VK_EXT_vertex_attribute_divisor>>` extension is supported.
endif::VK_EXT_vertex_attribute_divisor[]
ifdef::VK_EXT_fragment_density_map[]
  * <<features-fragmentDensityMap, pname:fragmentDensityMap>>, if the
    `<<VK_EXT_fragment_density_map>>` extension is supported.
endif::VK_EXT_fragment_density_map[]
ifdef::VK_KHR_shader_clock[]
  * <<features-shaderSubgroupClock, pname:shaderSubgroupClock>>, if the
    `<<VK_KHR_shader_clock>>` extension is supported.
endif::VK_KHR_shader_clock[]
ifdef::VK_KHR_shader_atomic_int64[]
  * <<features-shaderBufferInt64Atomics, pname:shaderBufferInt64Atomics>>,
    if the `<<VK_KHR_shader_atomic_int64>>` extension is supported.
endif::VK_KHR_shader_atomic_int64[]
ifdef::VK_KHR_shader_float16_int8[]
  * <<features-shaderFloat16, pname:shaderFloat16>> or
    <<features-shaderInt8, pname:shaderInt8>>, if the
    `<<VK_KHR_shader_float16_int8>>` extension is supported.
endif::VK_KHR_shader_float16_int8[]
ifdef::VK_EXT_fragment_shader_interlock[]
  * <<features-fragmentShaderSampleInterlock,
    pname:fragmentShaderSampleInterlock>> or
    <<features-fragmentShaderPixelInterlock,
    pname:fragmentShaderPixelInterlock>> or
    <<features-fragmentShaderShadingRateInterlock,
    pname:fragmentShaderShadingRateInterlock>>, if the
    `<<VK_EXT_fragment_shader_interlock>>` extension is supported.
endif::VK_EXT_fragment_shader_interlock[]
ifdef::VK_EXT_line_rasterization[]
  * <<features-rectangularLines, pname:rectangularLines>> or
    <<features-bresenhamLines, pname:bresenhamLines>> or
    <<features-smoothLines, pname:smoothLines>> or
    <<features-stippledRectangularLines, pname:stippledRectangularLines>> or
    <<features-stippledBresenhamLines, pname:stippledBresenhamLines>> or
    <<features-stippledSmoothLines, pname:stippledSmoothLines>>, if the
    `<<VK_EXT_line_rasterization>>` extension is supported.
endif::VK_EXT_line_rasterization[]

All other features defined in the Specification are optional:.
