// Copyright 2015-2021 The Khronos Group, Inc.
//
// SPDX-License-Identifier: CC-BY-4.0

// This text fragment is used many times in the Features chapter.
ifdef::hidden[]
// tag::features[]
If the sname:{refpage} structure is included in the pname:pNext chain of the
slink:VkPhysicalDeviceFeatures2 structure passed to
flink:vkGetPhysicalDeviceFeatures2, it is filled in to indicate whether each
corresponding feature is supported.
sname:{refpage} can: also be used in the pname:pNext chain of
slink:VkDeviceCreateInfo to selectively enable these features.
// end::features[]
endif::hidden[]


[[features]]
= Features

_Features_ describe functionality which is not supported on all
implementations.
Features are properties of the physical device.
Features are optional:, and must: be explicitly enabled before use.
Support for features is reported and enabled on a per-feature basis.

ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
[NOTE]
.Note
====
Features are reported via the basic slink:VkPhysicalDeviceFeatures
structure, as well as the extensible structure
sname:VkPhysicalDeviceFeatures2, which was added in the
`apiext:VK_KHR_get_physical_device_properties2` extension and included in
Vulkan 1.1.
When new features are added in future Vulkan versions or extensions, each
extension should: introduce one new feature structure, if needed.
This structure can: be added to the pname:pNext chain of the
sname:VkPhysicalDeviceFeatures2 structure.
====
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

For convenience, new core versions of Vulkan may: introduce new unified
feature structures for features promoted from extensions.
At the same time, the extension's original feature structure (if any) is
also promoted to the core API, and is an alias of the extension's structure.
This results in multiple names for the same feature: in the original
extension's feature structure and the promoted structure alias, in the
unified feature structure.
When a feature was implicitly supported and enabled in the extension, but an
explicit name was added during promotion, then the extension itself acts as
an alias for the feature as listed in the table below.

All aliases of the same feature in the core API must: be reported
consistently: either all must: be reported as supported, or none of them.
When a promoted extension is available, any corresponding feature aliases
must: be supported.

[[features-extension-aliases]]
.Extension Feature Aliases

[width="100%",options="header"]
|====
| Extension                                 | Feature(s)
ifdef::VK_VERSION_1_2[]
ifdef::VK_KHR_shader_draw_parameters[]
| `apiext:VK_KHR_shader_draw_parameters`       | <<features-shaderDrawParameters,pname:shaderDrawParameters>>
endif::VK_KHR_shader_draw_parameters[]
ifdef::VK_KHR_draw_indirect_count[]
| `apiext:VK_KHR_draw_indirect_count`          | <<features-drawIndirectCount,pname:drawIndirectCount>>
endif::VK_KHR_draw_indirect_count[]
ifdef::VK_KHR_sampler_mirror_clamp_to_edge[]
| `apiext:VK_KHR_sampler_mirror_clamp_to_edge` | <<features-samplerMirrorClampToEdge,pname:samplerMirrorClampToEdge>>
endif::VK_KHR_sampler_mirror_clamp_to_edge[]
ifdef::VK_EXT_descriptor_indexing[]
| `apiext:VK_EXT_descriptor_indexing`          | <<features-descriptorIndexing,pname:descriptorIndexing>>
endif::VK_EXT_descriptor_indexing[]
ifdef::VK_EXT_sampler_filter_minmax[]
| `apiext:VK_EXT_sampler_filter_minmax`        | <<features-samplerFilterMinmax,pname:samplerFilterMinmax>>
endif::VK_EXT_sampler_filter_minmax[]
ifdef::VK_EXT_shader_viewport_index_layer[]
| `apiext:VK_EXT_shader_viewport_index_layer`  | <<features-shaderOutputViewportIndex,pname:shaderOutputViewportIndex>>, <<features-shaderOutputLayer,pname:shaderOutputLayer>>
endif::VK_EXT_shader_viewport_index_layer[]
endif::VK_VERSION_1_2[]
|====

[open,refpage='vkGetPhysicalDeviceFeatures',desc='Reports capabilities of a physical device',type='protos']
--
To query supported features, call:

include::{generated}/api/protos/vkGetPhysicalDeviceFeatures.txt[]

  * pname:physicalDevice is the physical device from which to query the
    supported features.
  * pname:pFeatures is a pointer to a slink:VkPhysicalDeviceFeatures
    structure in which the physical device features are returned.
    For each feature, a value of ename:VK_TRUE specifies that the feature is
    supported on this physical device, and ename:VK_FALSE specifies that the
    feature is not supported.

include::{generated}/validity/protos/vkGetPhysicalDeviceFeatures.txt[]
--

Fine-grained features used by a logical device must: be enabled at
sname:VkDevice creation time.
If a feature is enabled that the physical device does not support,
sname:VkDevice creation will fail and return
ename:VK_ERROR_FEATURE_NOT_PRESENT.

The fine-grained features are enabled by passing a pointer to the
sname:VkPhysicalDeviceFeatures structure via the pname:pEnabledFeatures
member of the slink:VkDeviceCreateInfo structure that is passed into the
fname:vkCreateDevice call.
If a member of pname:pEnabledFeatures is set to ename:VK_TRUE or
ename:VK_FALSE, then the device will be created with the indicated feature
enabled or disabled, respectively.
ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
Features can: also be enabled by using the slink:VkPhysicalDeviceFeatures2
structure.
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

If an application wishes to enable all features supported by a device, it
can: simply pass in the sname:VkPhysicalDeviceFeatures structure that was
previously returned by fname:vkGetPhysicalDeviceFeatures.
To disable an individual feature, the application can: set the desired
member to ename:VK_FALSE in the same structure.
Setting pname:pEnabledFeatures to `NULL`
ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
and not including a slink:VkPhysicalDeviceFeatures2 in the pname:pNext chain
of slink:VkDeviceCreateInfo
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
is equivalent to setting all members of the structure to ename:VK_FALSE.

[NOTE]
.Note
====
Some features, such as pname:robustBufferAccess, may: incur a runtime
performance cost.
Application writers should: carefully consider the implications of enabling
all supported features.
====

ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
[open,refpage='vkGetPhysicalDeviceFeatures2',desc='Reports capabilities of a physical device',type='protos']
--
To query supported features defined by the core or extensions, call:

ifdef::VK_VERSION_1_1[]
include::{generated}/api/protos/vkGetPhysicalDeviceFeatures2.txt[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_get_physical_device_properties2[or the equivalent command]

ifdef::VK_KHR_get_physical_device_properties2[]
include::{generated}/api/protos/vkGetPhysicalDeviceFeatures2KHR.txt[]
endif::VK_KHR_get_physical_device_properties2[]

  * pname:physicalDevice is the physical device from which to query the
    supported features.
  * pname:pFeatures is a pointer to a slink:VkPhysicalDeviceFeatures2
    structure in which the physical device features are returned.

Each structure in pname:pFeatures and its pname:pNext chain contains members
corresponding to fine-grained features.
fname:vkGetPhysicalDeviceFeatures2 writes each member to a boolean value
indicating whether that feature is supported.

include::{generated}/validity/protos/vkGetPhysicalDeviceFeatures2.txt[]
--

[open,refpage='VkPhysicalDeviceFeatures2',desc='Structure describing the fine-grained features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFeatures2 structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceFeatures2.txt[]

ifdef::VK_KHR_get_physical_device_properties2[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceFeatures2KHR.txt[]
endif::VK_KHR_get_physical_device_properties2[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:features is a slink:VkPhysicalDeviceFeatures structure describing
    the fine-grained features of the Vulkan 1.0 API.

The pname:pNext chain of this structure is used to extend the structure with
features defined by extensions.
This structure can: be used in flink:vkGetPhysicalDeviceFeatures2 or can: be
included in the pname:pNext chain of a slink:VkDeviceCreateInfo structure,
in which case it controls which features are enabled in the device in lieu
of pname:pEnabledFeatures.

include::{generated}/validity/structs/VkPhysicalDeviceFeatures2.txt[]
--
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

[open,refpage='VkPhysicalDeviceFeatures',desc='Structure describing the fine-grained features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceFeatures.txt[]

This structure describes the following features:

  * [[features-robustBufferAccess]] pname:robustBufferAccess specifies that
    accesses to buffers are bounds-checked against the range of the buffer
    descriptor (as determined by sname:VkDescriptorBufferInfo::pname:range,
    slink:VkBufferViewCreateInfo::pname:range, or the size of the buffer).
    Out of bounds accesses must: not cause application termination, and the
    effects of shader loads, stores, and atomics must: conform to an
    implementation-dependent behavior as described below.
  ** A buffer access is considered to be out of bounds if any of the
     following are true:
  *** The pointer was formed by code:OpImageTexelPointer and the coordinate
      is less than zero or greater than or equal to the number of whole
      elements in the bound range.
  *** The pointer was not formed by code:OpImageTexelPointer and the object
      pointed to is not wholly contained within the bound range.
ifdef::VK_VERSION_1_1,VK_KHR_variable_pointers[]
      This includes accesses performed via _variable pointers_ where the
      buffer descriptor being accessed cannot be statically determined.
      Uninitialized pointers and pointers equal to code:OpConstantNull are
      treated as pointing to a zero-sized object, so all accesses through
      such pointers are considered to be out of bounds.
endif::VK_VERSION_1_1,VK_KHR_variable_pointers[]
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
      Buffer accesses through buffer device addresses are not
      bounds-checked.
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
ifdef::VK_NV_cooperative_matrix[]
      If the
      <<features-cooperativeMatrixRobustBufferAccess,pname:cooperativeMatrixRobustBufferAccess>>
      feature is not enabled, then accesses using
      code:OpCooperativeMatrixLoadNV and code:OpCooperativeMatrixStoreNV
      may: not be bounds-checked.
endif::VK_NV_cooperative_matrix[]
+
[NOTE]
.Note
====
If a SPIR-V code:OpLoad instruction loads a structure and the tail end of
the structure is out of bounds, then all members of the structure are
considered out of bounds even if the members at the end are not statically
used.
====

  *** If
ifdef::VK_EXT_robustness2[]
      <<features-robustBufferAccess2,pname:robustBufferAccess2>> is not
      enabled and
endif::VK_EXT_robustness2[]
      any buffer access is determined to be out of bounds, then any other
      access of the same type (load, store, or atomic) to the same buffer
      that accesses an address less than 16 bytes away from the out of
      bounds address may: also be considered out of bounds.
  *** If the access is a load that reads from the same memory locations as a
      prior store in the same shader invocation, with no other intervening
      accesses to the same memory locations in that shader invocation, then
      the result of the load may: be the value stored by the store
      instruction, even if the access is out of bounds.
      If the load is code:Volatile, then an out of bounds load must: return
      the appropriate out of bounds value.
ifdef::VK_EXT_robustness2[]
  ** Accesses to descriptors written with a dlink:VK_NULL_HANDLE resource or
     view are not considered to be out of bounds.
     Instead, each type of descriptor access defines a specific behavior for
     accesses to a null descriptor.
endif::VK_EXT_robustness2[]
  ** Out-of-bounds buffer loads will return any of the following values:
ifdef::VK_EXT_robustness2[]
  *** If the access is to a uniform buffer and
      <<features-robustBufferAccess2,pname:robustBufferAccess2>> is enabled,
      loads of offsets between the end of the descriptor range and the end
      of the descriptor range rounded up to a multiple of
      <<limits-robustUniformBufferAccessSizeAlignment,robustUniformBufferAccessSizeAlignment>>
      bytes must: return either zero values or the contents of the memory at
      the offset being loaded.
      Loads of offsets past the descriptor range rounded up to a multiple of
      <<limits-robustUniformBufferAccessSizeAlignment,robustUniformBufferAccessSizeAlignment>>
      bytes must: return zero values.
  *** If the access is to a storage buffer and
      <<features-robustBufferAccess2,pname:robustBufferAccess2>> is enabled,
      loads of offsets between the end of the descriptor range and the end
      of the descriptor range rounded up to a multiple of
      <<limits-robustStorageBufferAccessSizeAlignment,robustStorageBufferAccessSizeAlignment>>
      bytes must: return either zero values or the contents of the memory at
      the offset being loaded.
      Loads of offsets past the descriptor range rounded up to a multiple of
      <<limits-robustStorageBufferAccessSizeAlignment,robustStorageBufferAccessSizeAlignment>>
      bytes must: return zero values.
      Similarly, stores to addresses between the end of the descriptor range
      and the end of the descriptor range rounded up to a multiple of
      <<limits-robustStorageBufferAccessSizeAlignment,robustStorageBufferAccessSizeAlignment>>
      bytes may: be discarded.
  *** Non-atomic accesses to storage buffers that are a multiple of 32 bits
      may: be decomposed into 32-bit accesses that are individually
      bounds-checked.
  *** If the access is to an index buffer and
      <<features-robustBufferAccess2,pname:robustBufferAccess2>> is enabled,
      zero values must: be returned.
  *** If the access is to a uniform texel buffer or storage texel buffer and
      <<features-robustBufferAccess2,pname:robustBufferAccess2>> is enabled,
      zero values must: be returned, and then
      <<textures-conversion-to-rgba,Conversion to RGBA>> is applied based on
      the buffer view's format.
endif::VK_EXT_robustness2[]
  *** Values from anywhere within the memory range(s) bound to the buffer
      (possibly including bytes of memory past the end of the buffer, up to
      the end of the bound range).
  *** Zero values, or [eq]#(0,0,0,x)# vectors for vector reads where x is a
      valid value represented in the type of the vector components and may:
      be any of:
  **** 0, 1, or the maximum representable positive integer value, for signed
       or unsigned integer components
  **** 0.0 or 1.0, for floating-point components
  ** Out-of-bounds writes may: modify values within the memory range(s)
     bound to the buffer, but must: not modify any other memory.
ifdef::VK_EXT_robustness2[]
  *** If <<features-robustBufferAccess2,pname:robustBufferAccess2>> is
      enabled, out of bounds writes must: not modify any memory.
endif::VK_EXT_robustness2[]
  ** Out-of-bounds atomics may: modify values within the memory range(s)
     bound to the buffer, but must: not modify any other memory, and return
     an undefined: value.
ifdef::VK_EXT_robustness2[]
  *** If <<features-robustBufferAccess2,pname:robustBufferAccess2>> is
      enabled, out of bounds atomics must: not modify any memory, and return
      an undefined: value.
  ** If <<features-robustBufferAccess2,pname:robustBufferAccess2>> is
     disabled, vertex
endif::VK_EXT_robustness2[]
ifndef::VK_EXT_robustness2[]
  ** Vertex
endif::VK_EXT_robustness2[]
     input attributes are considered out of bounds if the offset of the
     attribute in the bound vertex buffer range plus the size of the
     attribute is greater than either:
+
  *** code:vertexBufferRangeSize, if [eq]#code:bindingStride == 0#; or
  *** [eq]#(code:vertexBufferRangeSize - (code:vertexBufferRangeSize %
      code:bindingStride))#
+
where code:vertexBufferRangeSize is the byte size of the memory range bound
to the vertex buffer binding and code:bindingStride is the byte stride of
the corresponding vertex input binding.
Further, if any vertex input attribute using a specific vertex input binding
is out of bounds, then all vertex input attributes using that vertex input
binding for that vertex shader invocation are considered out of bounds.
  *** If a vertex input attribute is out of bounds, it will be assigned one
      of the following values:
  **** Values from anywhere within the memory range(s) bound to the buffer,
       converted according to the format of the attribute.
  **** Zero values, format converted according to the format of the
       attribute.
  **** Zero values, or [eq]#(0,0,0,x)# vectors, as described above.
ifdef::VK_EXT_robustness2[]
  ** If <<features-robustBufferAccess2,pname:robustBufferAccess2>> is
     enabled, vertex input attributes are considered out of bounds if the
     offset of the attribute in the bound vertex buffer range plus the size
     of the attribute is greater than the byte size of the memory range
     bound to the vertex buffer binding.
  *** If a vertex input attribute is out of bounds, the
      <<fxvertex-input-extraction,raw data>> extracted are zero values, and
      missing G, B, or A components are <<fxvertex-input-extraction,filled
      with [eq]#(0,0,1)#>>.
endif::VK_EXT_robustness2[]
  ** If pname:robustBufferAccess is not enabled, applications must: not
     perform out of bounds accesses.
  * [[features-fullDrawIndexUint32]] pname:fullDrawIndexUint32 specifies the
    full 32-bit range of indices is supported for indexed draw calls when
    using a elink:VkIndexType of ename:VK_INDEX_TYPE_UINT32.
    pname:maxDrawIndexedIndexValue is the maximum index value that may: be
    used (aside from the primitive restart index, which is always 2^32^-1
    when the elink:VkIndexType is ename:VK_INDEX_TYPE_UINT32).
    If this feature is supported, pname:maxDrawIndexedIndexValue must: be
    2^32^-1; otherwise it must: be no smaller than 2^24^-1.
    See <<limits-maxDrawIndexedIndexValue,maxDrawIndexedIndexValue>>.
  * [[features-imageCubeArray]] pname:imageCubeArray specifies whether image
    views with a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY can: be created, and that the
    corresponding code:SampledCubeArray and code:ImageCubeArray SPIR-V
    capabilities can: be used in shader code.
  * [[features-independentBlend]] pname:independentBlend specifies whether
    the sname:VkPipelineColorBlendAttachmentState settings are controlled
    independently per-attachment.
    If this feature is not enabled, the
    sname:VkPipelineColorBlendAttachmentState settings for all color
    attachments must: be identical.
    Otherwise, a different sname:VkPipelineColorBlendAttachmentState can: be
    provided for each bound color attachment.
  * [[features-geometryShader]] pname:geometryShader specifies whether
    geometry shaders are supported.
    If this feature is not enabled, the ename:VK_SHADER_STAGE_GEOMETRY_BIT
    and ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT enum values must: not be
    used.
    This also specifies whether shader modules can: declare the
    code:Geometry capability.
  * [[features-tessellationShader]] pname:tessellationShader specifies
    whether tessellation control and evaluation shaders are supported.
    If this feature is not enabled, the
    ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, and
    ename:VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO enum
    values must: not be used.
    This also specifies whether shader modules can: declare the
    code:Tessellation capability.
  * [[features-sampleRateShading]] pname:sampleRateShading specifies whether
    <<primsrast-sampleshading,Sample Shading>> and multisample interpolation
    are supported.
    If this feature is not enabled, the pname:sampleShadingEnable member of
    the slink:VkPipelineMultisampleStateCreateInfo structure must: be set to
    ename:VK_FALSE and the pname:minSampleShading member is ignored.
    This also specifies whether shader modules can: declare the
    code:SampleRateShading capability.
  * [[features-dualSrcBlend]] pname:dualSrcBlend specifies whether blend
    operations which take two sources are supported.
    If this feature is not enabled, the ename:VK_BLEND_FACTOR_SRC1_COLOR,
    ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
    ename:VK_BLEND_FACTOR_SRC1_ALPHA, and
    ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA enum values must: not be used
    as source or destination blending factors.
    See <<framebuffer-dsb>>.
  * [[features-logicOp]] pname:logicOp specifies whether logic operations
    are supported.
    If this feature is not enabled, the pname:logicOpEnable member of the
    slink:VkPipelineColorBlendStateCreateInfo structure must: be set to
    ename:VK_FALSE, and the pname:logicOp member is ignored.
  * [[features-multiDrawIndirect]] pname:multiDrawIndirect specifies whether
    multiple draw indirect is supported.
    If this feature is not enabled, the pname:drawCount parameter to the
    fname:vkCmdDrawIndirect and fname:vkCmdDrawIndexedIndirect commands
    must: be 0 or 1.
    The pname:maxDrawIndirectCount member of the
    sname:VkPhysicalDeviceLimits structure must: also be 1 if this feature
    is not supported.
    See <<limits-maxDrawIndirectCount,maxDrawIndirectCount>>.
  * [[features-drawIndirectFirstInstance]] pname:drawIndirectFirstInstance
    specifies whether indirect drawing calls support the pname:firstInstance
    parameter.
    If this feature is not enabled, the pname:firstInstance member of all
    sname:VkDrawIndirectCommand and sname:VkDrawIndexedIndirectCommand
    structures that are provided to the fname:vkCmdDrawIndirect and
    fname:vkCmdDrawIndexedIndirect commands must: be 0.
  * [[features-depthClamp]] pname:depthClamp specifies whether depth
    clamping is supported.
    If this feature is not enabled, the pname:depthClampEnable member of the
    slink:VkPipelineRasterizationStateCreateInfo structure must: be set to
    ename:VK_FALSE.
    Otherwise, setting pname:depthClampEnable to ename:VK_TRUE will enable
    depth clamping.
  * [[features-depthBiasClamp]] pname:depthBiasClamp specifies whether depth
    bias clamping is supported.
    If this feature is not enabled, the pname:depthBiasClamp member of the
    slink:VkPipelineRasterizationStateCreateInfo structure must: be set to
    0.0 unless the ename:VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state is
    enabled, and the pname:depthBiasClamp parameter to
    fname:vkCmdSetDepthBias must: be set to 0.0.
  * [[features-fillModeNonSolid]] pname:fillModeNonSolid specifies whether
    point and wireframe fill modes are supported.
    If this feature is not enabled, the ename:VK_POLYGON_MODE_POINT and
    ename:VK_POLYGON_MODE_LINE enum values must: not be used.
  * [[features-depthBounds]] pname:depthBounds specifies whether depth
    bounds tests are supported.
    If this feature is not enabled, the pname:depthBoundsTestEnable member
    of the slink:VkPipelineDepthStencilStateCreateInfo structure must: be
    set to ename:VK_FALSE.
    When pname:depthBoundsTestEnable is set to ename:VK_FALSE, the
    pname:minDepthBounds and pname:maxDepthBounds members of the
    slink:VkPipelineDepthStencilStateCreateInfo structure are ignored.
  * [[features-wideLines]] pname:wideLines specifies whether lines with
    width other than 1.0 are supported.
    If this feature is not enabled, the pname:lineWidth member of the
    slink:VkPipelineRasterizationStateCreateInfo structure must: be set to
    1.0 unless the ename:VK_DYNAMIC_STATE_LINE_WIDTH dynamic state is
    enabled, and the pname:lineWidth parameter to fname:vkCmdSetLineWidth
    must: be set to 1.0.
    When this feature is supported, the range and granularity of supported
    line widths are indicated by the pname:lineWidthRange and
    pname:lineWidthGranularity members of the sname:VkPhysicalDeviceLimits
    structure, respectively.
  * [[features-largePoints]] pname:largePoints specifies whether points with
    size greater than 1.0 are supported.
    If this feature is not enabled, only a point size of 1.0 written by a
    shader is supported.
    The range and granularity of supported point sizes are indicated by the
    pname:pointSizeRange and pname:pointSizeGranularity members of the
    sname:VkPhysicalDeviceLimits structure, respectively.
  * [[features-alphaToOne]] pname:alphaToOne specifies whether the
    implementation is able to replace the alpha value of the fragment shader
    color output in the <<fragops-covg, Multisample Coverage>> fragment
    operation.
    If this feature is not enabled, then the pname:alphaToOneEnable member
    of the slink:VkPipelineMultisampleStateCreateInfo structure must: be set
    to ename:VK_FALSE.
    Otherwise setting pname:alphaToOneEnable to ename:VK_TRUE will enable
    alpha-to-one behavior.
  * [[features-multiViewport]] pname:multiViewport specifies whether more
    than one viewport is supported.
    If this feature is not enabled:
  ** The pname:viewportCount and pname:scissorCount members of the
     slink:VkPipelineViewportStateCreateInfo structure must: be set to 1.
  ** The pname:firstViewport and pname:viewportCount parameters to the
     fname:vkCmdSetViewport command must: be set to 0 and 1, respectively.
  ** The pname:firstScissor and pname:scissorCount parameters to the
     fname:vkCmdSetScissor command must: be set to 0 and 1, respectively.
ifdef::VK_NV_scissor_exclusive[]
  ** The pname:exclusiveScissorCount member of the
     slink:VkPipelineViewportExclusiveScissorStateCreateInfoNV structure
     must: be set to 0 or 1.
  ** The pname:firstExclusiveScissor and pname:exclusiveScissorCount
     parameters to the fname:vkCmdSetExclusiveScissorNV command must: be set
     to 0 and 1, respectively.
endif::VK_NV_scissor_exclusive[]
  * [[features-samplerAnisotropy]] pname:samplerAnisotropy specifies whether
    anisotropic filtering is supported.
    If this feature is not enabled, the pname:anisotropyEnable member of the
    slink:VkSamplerCreateInfo structure must: be ename:VK_FALSE.
  * [[features-textureCompressionETC2]] pname:textureCompressionETC2
    specifies whether all of the ETC2 and EAC compressed texture formats are
    supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
  ** ename:VK_FORMAT_EAC_R11_UNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11_SNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

  * [[features-textureCompressionASTC_LDR]] pname:textureCompressionASTC_LDR
    specifies whether all of the ASTC LDR compressed texture formats are
    supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

  * [[features-textureCompressionBC]] pname:textureCompressionBC specifies
    whether all of the BC compressed texture formats are supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK
  ** ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK
  ** ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK
  ** ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK
  ** ename:VK_FORMAT_BC2_UNORM_BLOCK
  ** ename:VK_FORMAT_BC2_SRGB_BLOCK
  ** ename:VK_FORMAT_BC3_UNORM_BLOCK
  ** ename:VK_FORMAT_BC3_SRGB_BLOCK
  ** ename:VK_FORMAT_BC4_UNORM_BLOCK
  ** ename:VK_FORMAT_BC4_SNORM_BLOCK
  ** ename:VK_FORMAT_BC5_UNORM_BLOCK
  ** ename:VK_FORMAT_BC5_SNORM_BLOCK
  ** ename:VK_FORMAT_BC6H_UFLOAT_BLOCK
  ** ename:VK_FORMAT_BC6H_SFLOAT_BLOCK
  ** ename:VK_FORMAT_BC7_UNORM_BLOCK
  ** ename:VK_FORMAT_BC7_SRGB_BLOCK
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

  * [[features-occlusionQueryPrecise]] pname:occlusionQueryPrecise specifies
    whether occlusion queries returning actual sample counts are supported.
    Occlusion queries are created in a sname:VkQueryPool by specifying the
    pname:queryType of ename:VK_QUERY_TYPE_OCCLUSION in the
    slink:VkQueryPoolCreateInfo structure which is passed to
    fname:vkCreateQueryPool.
    If this feature is enabled, queries of this type can: enable
    ename:VK_QUERY_CONTROL_PRECISE_BIT in the pname:flags parameter to
    fname:vkCmdBeginQuery.
    If this feature is not supported, the implementation supports only
    boolean occlusion queries.
    When any samples are passed, boolean queries will return a non-zero
    result value, otherwise a result value of zero is returned.
    When this feature is enabled and ename:VK_QUERY_CONTROL_PRECISE_BIT is
    set, occlusion queries will report the actual number of samples passed.
  * [[features-pipelineStatisticsQuery]] pname:pipelineStatisticsQuery
    specifies whether the pipeline statistics queries are supported.
    If this feature is not enabled, queries of type
    ename:VK_QUERY_TYPE_PIPELINE_STATISTICS cannot: be created, and none of
    the elink:VkQueryPipelineStatisticFlagBits bits can: be set in the
    pname:pipelineStatistics member of the slink:VkQueryPoolCreateInfo
    structure.
  * [[features-vertexPipelineStoresAndAtomics]]
    pname:vertexPipelineStoresAndAtomics specifies whether storage buffers
    and images support stores and atomic operations in the vertex,
    tessellation, and geometry shader stages.
    If this feature is not enabled, all storage image, storage texel buffer,
    and storage buffer variables used by these stages in shader modules
    must: be decorated with the code:NonWritable decoration (or the
    code:readonly memory qualifier in GLSL).
  * [[features-fragmentStoresAndAtomics]] pname:fragmentStoresAndAtomics
    specifies whether storage buffers and images support stores and atomic
    operations in the fragment shader stage.
    If this feature is not enabled, all storage image, storage texel buffer,
    and storage buffer variables used by the fragment stage in shader
    modules must: be decorated with the code:NonWritable decoration (or the
    code:readonly memory qualifier in GLSL).
  * [[features-shaderTessellationAndGeometryPointSize]]
    pname:shaderTessellationAndGeometryPointSize specifies whether the
    code:PointSize built-in decoration is available in the tessellation
    control, tessellation evaluation, and geometry shader stages.
    If this feature is not enabled, members decorated with the
    code:PointSize built-in decoration must: not be read from or written to
    and all points written from a tessellation or geometry shader will have
    a size of 1.0.
    This also specifies whether shader modules can: declare the
    code:TessellationPointSize capability for tessellation control and
    evaluation shaders, or if the shader modules can: declare the
    code:GeometryPointSize capability for geometry shaders.
    An implementation supporting this feature must: also support one or both
    of the <<features-tessellationShader,pname:tessellationShader>> or
    <<features-geometryShader,pname:geometryShader>> features.
  * [[features-shaderImageGatherExtended]] pname:shaderImageGatherExtended
    specifies whether the extended set of image gather instructions are
    available in shader code.
    If this feature is not enabled, the code:OpImage*Gather instructions do
    not support the code:Offset and code:ConstOffsets operands.
    This also specifies whether shader modules can: declare the
    code:ImageGatherExtended capability.
  * [[features-shaderStorageImageExtendedFormats]]
    pname:shaderStorageImageExtendedFormats specifies whether all the
    "`storage image extended formats`" below are supported; if this feature
    is supported, then the ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_R16G16_SFLOAT
  ** ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32
  ** ename:VK_FORMAT_R16_SFLOAT
  ** ename:VK_FORMAT_R16G16B16A16_UNORM
  ** ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32
  ** ename:VK_FORMAT_R16G16_UNORM
  ** ename:VK_FORMAT_R8G8_UNORM
  ** ename:VK_FORMAT_R16_UNORM
  ** ename:VK_FORMAT_R8_UNORM
  ** ename:VK_FORMAT_R16G16B16A16_SNORM
  ** ename:VK_FORMAT_R16G16_SNORM
  ** ename:VK_FORMAT_R8G8_SNORM
  ** ename:VK_FORMAT_R16_SNORM
  ** ename:VK_FORMAT_R8_SNORM
  ** ename:VK_FORMAT_R16G16_SINT
  ** ename:VK_FORMAT_R8G8_SINT
  ** ename:VK_FORMAT_R16_SINT
  ** ename:VK_FORMAT_R8_SINT
  ** ename:VK_FORMAT_A2B10G10R10_UINT_PACK32
  ** ename:VK_FORMAT_R16G16_UINT
  ** ename:VK_FORMAT_R8G8_UINT
  ** ename:VK_FORMAT_R16_UINT
  ** ename:VK_FORMAT_R8_UINT
+
[NOTE]
.Note
====
pname:shaderStorageImageExtendedFormats feature only adds a guarantee of
format support, which is specified for the whole physical device.
Therefore enabling or disabling the feature via flink:vkCreateDevice has no
practical effect.

To query for additional properties, or if the feature is not supported,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats, as usual rules allow.

ename:VK_FORMAT_R32G32_UINT, ename:VK_FORMAT_R32G32_SINT, and
ename:VK_FORMAT_R32G32_SFLOAT from code:StorageImageExtendedFormats SPIR-V
capability, are already covered by core Vulkan
<<formats-mandatory-features-32bit,mandatory format support>>.
====

  * [[features-shaderStorageImageMultisample]]
    pname:shaderStorageImageMultisample specifies whether multisampled
    storage images are supported.
    If this feature is not enabled, images that are created with a
    pname:usage that includes ename:VK_IMAGE_USAGE_STORAGE_BIT must: be
    created with pname:samples equal to ename:VK_SAMPLE_COUNT_1_BIT.
    This also specifies whether shader modules can: declare the
    code:StorageImageMultisample and code:ImageMSArray capabilities.
  * [[features-shaderStorageImageReadWithoutFormat]]
    pname:shaderStorageImageReadWithoutFormat specifies whether storage
    images require a format qualifier to be specified when reading.
ifdef::VK_KHR_format_feature_flags2[]
    pname:shaderStorageImageReadWithoutFormat applies only to formats listed
    in the <<formats-without-shader-storage-format,storage without format>>
    list.
endif::VK_KHR_format_feature_flags2[]
  * [[features-shaderStorageImageWriteWithoutFormat]]
    pname:shaderStorageImageWriteWithoutFormat specifies whether storage
    images require a format qualifier to be specified when writing.
ifdef::VK_KHR_format_feature_flags2[]
    pname:shaderStorageImageWriteWithoutFormat applies only to formats
    listed in the <<formats-without-shader-storage-format,storage without
    format>> list.
endif::VK_KHR_format_feature_flags2[]
  * [[features-shaderUniformBufferArrayDynamicIndexing]]
    pname:shaderUniformBufferArrayDynamicIndexing specifies whether arrays
    of uniform buffers can: be indexed by _dynamically uniform_ integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also specifies whether shader modules can: declare the
    code:UniformBufferArrayDynamicIndexing capability.
  * [[features-shaderSampledImageArrayDynamicIndexing]]
    pname:shaderSampledImageArrayDynamicIndexing specifies whether arrays of
    samplers or sampled images can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must: be indexed only by constant
    integral expressions when aggregated into arrays in shader code.
    This also specifies whether shader modules can: declare the
    code:SampledImageArrayDynamicIndexing capability.
  * [[features-shaderStorageBufferArrayDynamicIndexing]]
    pname:shaderStorageBufferArrayDynamicIndexing specifies whether arrays
    of storage buffers can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also specifies whether shader modules can: declare the
    code:StorageBufferArrayDynamicIndexing capability.
  * [[features-shaderStorageImageArrayDynamicIndexing]]
    pname:shaderStorageImageArrayDynamicIndexing specifies whether arrays of
    storage images can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must: be indexed only by constant
    integral expressions when aggregated into arrays in shader code.
    This also specifies whether shader modules can: declare the
    code:StorageImageArrayDynamicIndexing capability.
  * [[features-shaderClipDistance]] pname:shaderClipDistance specifies
    whether clip distances are supported in shader code.
    If this feature is not enabled, any members decorated with the
    code:ClipDistance built-in decoration must: not be read from or written
    to in shader modules.
    This also specifies whether shader modules can: declare the
    code:ClipDistance capability.
  * [[features-shaderCullDistance]] pname:shaderCullDistance specifies
    whether cull distances are supported in shader code.
    If this feature is not enabled, any members decorated with the
    code:CullDistance built-in decoration must: not be read from or written
    to in shader modules.
    This also specifies whether shader modules can: declare the
    code:CullDistance capability.
  * [[features-shaderFloat64]] pname:shaderFloat64 specifies whether 64-bit
    floats (doubles) are supported in shader code.
    If this feature is not enabled, 64-bit floating-point types must: not be
    used in shader code.
    This also specifies whether shader modules can: declare the code:Float64
    capability.
    Declaring and using 64-bit floats is enabled for all storage classes
    that SPIR-V allows with the code:Float64 capability.
  * [[features-shaderInt64]] pname:shaderInt64 specifies whether 64-bit
    integers (signed and unsigned) are supported in shader code.
    If this feature is not enabled, 64-bit integer types must: not be used
    in shader code.
    This also specifies whether shader modules can: declare the code:Int64
    capability.
    Declaring and using 64-bit integers is enabled for all storage classes
    that SPIR-V allows with the code:Int64 capability.
  * [[features-shaderInt16]] pname:shaderInt16 specifies whether 16-bit
    integers (signed and unsigned) are supported in shader code.
    If this feature is not enabled, 16-bit integer types must: not be used
    in shader code.
    This also specifies whether shader modules can: declare the code:Int16
    capability.
    However, this only enables a subset of the storage classes that SPIR-V
    allows for the code:Int16 SPIR-V capability: Declaring and using 16-bit
    integers in the code:Private,
ifndef::VK_KHR_workgroup_memory_explicit_layout[]
    code:Workgroup,
endif::VK_KHR_workgroup_memory_explicit_layout[]
ifdef::VK_KHR_workgroup_memory_explicit_layout[]
    code:Workgroup (for non-Block variables),
endif::VK_KHR_workgroup_memory_explicit_layout[]
    and code:Function storage classes is enabled, while declaring them in
    the interface storage classes (e.g., code:UniformConstant, code:Uniform,
    code:StorageBuffer, code:Input, code:Output, and code:PushConstant) is
    not enabled.
  * [[features-shaderResourceResidency]] pname:shaderResourceResidency
    specifies whether image operations that return resource residency
    information are supported in shader code.
    If this feature is not enabled, the code:OpImageSparse* instructions
    must: not be used in shader code.
    This also specifies whether shader modules can: declare the
    code:SparseResidency capability.
    The feature requires at least one of the ptext:sparseResidency* features
    to be supported.
  * [[features-shaderResourceMinLod]] pname:shaderResourceMinLod specifies
    whether image operations specifying the minimum resource LOD are
    supported in shader code.
    If this feature is not enabled, the code:MinLod image operand must: not
    be used in shader code.
    This also specifies whether shader modules can: declare the code:MinLod
    capability.
  * [[features-sparseBinding]] pname:sparseBinding specifies whether
    resource memory can: be managed at opaque sparse block level instead of
    at the object level.
    If this feature is not enabled, resource memory must: be bound only on a
    per-object basis using the fname:vkBindBufferMemory and
    fname:vkBindImageMemory commands.
    In this case, buffers and images must: not be created with
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT and
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in the pname:flags member
    of the slink:VkBufferCreateInfo and slink:VkImageCreateInfo structures,
    respectively.
    Otherwise resource memory can: be managed as described in
    <<sparsememory-sparseresourcefeatures,Sparse Resource Features>>.
  * [[features-sparseResidencyBuffer]] pname:sparseResidencyBuffer specifies
    whether the device can: access partially resident buffers.
    If this feature is not enabled, buffers must: not be created with
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags
    member of the slink:VkBufferCreateInfo structure.
  * [[features-sparseResidencyImage2D]] pname:sparseResidencyImage2D
    specifies whether the device can: access partially resident 2D images
    with 1 sample per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_1_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
  * [[features-sparseResidencyImage3D]] pname:sparseResidencyImage3D
    specifies whether the device can: access partially resident 3D images.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_3D must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
  * [[features-sparseResidency2Samples]] pname:sparseResidency2Samples
    specifies whether the physical device can: access partially resident 2D
    images with 2 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_2_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
  * [[features-sparseResidency4Samples]] pname:sparseResidency4Samples
    specifies whether the physical device can: access partially resident 2D
    images with 4 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_4_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
  * [[features-sparseResidency8Samples]] pname:sparseResidency8Samples
    specifies whether the physical device can: access partially resident 2D
    images with 8 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_8_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
  * [[features-sparseResidency16Samples]] pname:sparseResidency16Samples
    specifies whether the physical device can: access partially resident 2D
    images with 16 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_16_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the slink:VkImageCreateInfo structure.
  * [[features-sparseResidencyAliased]] pname:sparseResidencyAliased
    specifies whether the physical device can: correctly access data aliased
    into multiple locations.
    If this feature is not enabled, the
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT and
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT enum values must: not be used
    in pname:flags members of the slink:VkBufferCreateInfo and
    slink:VkImageCreateInfo structures, respectively.
  * [[features-variableMultisampleRate]] pname:variableMultisampleRate
    specifies whether all pipelines that will be bound to a command buffer
    during a <<renderpass-noattachments, subpass which uses no attachments>>
    must: have the same value for
    slink:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples.
    If set to ename:VK_TRUE, the implementation supports variable
    multisample rates in a subpass which uses no attachments.
    If set to ename:VK_FALSE, then all pipelines bound in such a subpass
    must: have the same multisample rate.
    This has no effect in situations where a subpass uses any attachments.
  * [[features-inheritedQueries]] pname:inheritedQueries specifies whether a
    secondary command buffer may: be executed while a query is active.

include::{generated}/validity/structs/VkPhysicalDeviceFeatures.txt[]
--

ifdef::VK_VERSION_1_2[]
[open,refpage='VkPhysicalDeviceVulkan11Features',desc='Structure describing the Vulkan 1.1 features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceVulkan11Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVulkan11Features.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

:anchor-prefix:
include::{chapters}/features.txt[tag=VK_KHR_16bit_storage-features]
include::{chapters}/features.txt[tag=VK_KHR_multiview-features]
include::{chapters}/features.txt[tag=VK_KHR_variable_pointers-features]
include::{chapters}/features.txt[tag=VK_KHR_protected_memory-features]
include::{chapters}/features.txt[tag=VK_KHR_sampler_ycbcr_conversion-features]
include::{chapters}/features.txt[tag=VK_KHR_shader_draw_parameters-features]

:refpage: VkPhysicalDeviceVulkan11Features
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceVulkan11Features.txt[]
--

[open,refpage='VkPhysicalDeviceVulkan12Features',desc='Structure describing the Vulkan 1.2 features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceVulkan12Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVulkan12Features.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

:anchor-prefix:
  * [[features-samplerMirrorClampToEdge]] pname:samplerMirrorClampToEdge
    indicates whether the implementation supports the
    ename:VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE sampler address mode.
    If this feature is not enabled, the
    ename:VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE sampler address mode
    must: not be used.
  * [[features-drawIndirectCount]] pname:drawIndirectCount indicates whether
    the implementation supports the flink:vkCmdDrawIndirectCount and
    flink:vkCmdDrawIndexedIndirectCount functions.
    If this feature is not enabled, these functions must: not be used.
include::{chapters}/features.txt[tag=VK_KHR_8bit_storage-features]
include::{chapters}/features.txt[tag=VK_KHR_shader_atomic_int64-features]
include::{chapters}/features.txt[tag=VK_KHR_shader_float16_int8-features]
  * [[features-descriptorIndexing]] pname:descriptorIndexing indicates
    whether the implementation supports the minimum set of descriptor
    indexing features as described in the <<features-requirements,Feature
    Requirements>> section.
    Enabling the pname:descriptorIndexing member when flink:vkCreateDevice
    is called does not imply the other minimum descriptor indexing features
    are also enabled.
    Those other descriptor indexing features must: be enabled individually
    as needed by the application.
include::{chapters}/features.txt[tag=VK_EXT_descriptor_indexing-features]
  * [[features-samplerFilterMinmax]] pname:samplerFilterMinmax indicates
    whether the implementation supports a minimum set of required formats
    supporting min/max filtering as defined by the
    <<limits-filterMinmaxSingleComponentFormats-minimum-requirements,pname:filterMinmaxSingleComponentFormats>>
    property minimum requirements.
    If this feature is not enabled, then no slink:VkSamplerCreateInfo
    pname:pNext chain can include a slink:VkSamplerReductionModeCreateInfo
    structure.
include::{chapters}/features.txt[tag=VK_EXT_scalar_block_layout-features]
include::{chapters}/features.txt[tag=VK_KHR_imageless_framebuffer-features]
include::{chapters}/features.txt[tag=VK_KHR_uniform_buffer_standard_layout-features]
include::{chapters}/features.txt[tag=VK_KHR_shader_subgroup_extended_types-features]
include::{chapters}/features.txt[tag=VK_KHR_separate_depth_stencil_layouts-features]
include::{chapters}/features.txt[tag=VK_EXT_host_query_reset-features]
include::{chapters}/features.txt[tag=VK_KHR_timeline_semaphore-features]
include::{chapters}/features.txt[tag=VK_EXT_buffer_device_address-features]
include::{chapters}/features.txt[tag=VK_KHR_vulkan_memory_model-features]
  * [[features-shaderOutputViewportIndex]] pname:shaderOutputViewportIndex
    indicates whether the implementation supports the
    code:ShaderViewportIndex SPIR-V capability enabling variables decorated
    with the code:ViewportIndex built-in to be exported from vertex or
    tessellation evaluation shaders.
    If this feature is not enabled, the code:ViewportIndex built-in
    decoration must: not be used on outputs in vertex or tessellation
    evaluation shaders.
  * [[features-shaderOutputLayer]] pname:shaderOutputLayer indicates whether
    the implementation supports the code:ShaderLayer SPIR-V capability
    enabling variables decorated with the code:Layer built-in to be exported
    from vertex or tessellation evaluation shaders.
    If this feature is not enabled, the code:Layer built-in decoration must:
    not be used on outputs in vertex or tessellation evaluation shaders.
  * [[features-subgroupBroadcastDynamicId]] If
    pname:subgroupBroadcastDynamicId is ename:VK_TRUE, the "`Id`" operand of
    code:OpGroupNonUniformBroadcast can: be dynamically uniform within a
    subgroup, and the "`Index`" operand of
    code:OpGroupNonUniformQuadBroadcast can: be dynamically uniform within
    the derivative group.
    If it is ename:VK_FALSE, these operands must: be constants.

:refpage: VkPhysicalDeviceVulkan12Features
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceVulkan12Features.txt[]
--
endif::VK_VERSION_1_2[]

ifdef::VK_VERSION_1_1,VK_KHR_variable_pointers[]
[open,refpage='VkPhysicalDeviceVariablePointersFeatures',desc='Structure describing variable pointers features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceVariablePointerFeatures VkPhysicalDeviceVariablePointersFeaturesKHR VkPhysicalDeviceVariablePointerFeaturesKHR']
--
The sname:VkPhysicalDeviceVariablePointersFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVariablePointersFeatures.txt[]

ifdef::VK_VERSION_1_1[]
include::{generated}/api/structs/VkPhysicalDeviceVariablePointerFeatures.txt[]
endif::VK_VERSION_1_1[]

ifdef::VK_KHR_variable_pointers[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceVariablePointersFeaturesKHR.txt[]

include::{generated}/api/structs/VkPhysicalDeviceVariablePointerFeaturesKHR.txt[]
endif::VK_KHR_variable_pointers[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_variable_pointers-features[]
  * [[{anchor-prefix}features-variablePointersStorageBuffer]]
    pname:variablePointersStorageBuffer specifies whether the implementation
    supports the SPIR-V code:VariablePointersStorageBuffer capability.
    When this feature is not enabled, shader modules must: not declare the
    `SPV_KHR_variable_pointers` extension or the
    code:VariablePointersStorageBuffer capability.
  * [[{anchor-prefix}features-variablePointers]] pname:variablePointers
    specifies whether the implementation supports the SPIR-V
    code:VariablePointers capability.
    When this feature is not enabled, shader modules must: not declare the
    code:VariablePointers capability.
// end::VK_KHR_variable_pointers-features[]

:refpage: VkPhysicalDeviceVariablePointersFeatures
include::{chapters}/features.txt[tag=features]

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceVariablePointersFeatures-variablePointers-01431]]
    If pname:variablePointers is enabled then
    pname:variablePointersStorageBuffer must: also be enabled
****

include::{generated}/validity/structs/VkPhysicalDeviceVariablePointersFeatures.txt[]
--
endif::VK_VERSION_1_1,VK_KHR_variable_pointers[]

ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
[open,refpage='VkPhysicalDeviceMultiviewFeatures',desc='Structure describing multiview features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMultiviewFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMultiviewFeatures.txt[]

ifdef::VK_KHR_multiview[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceMultiviewFeaturesKHR.txt[]
endif::VK_KHR_multiview[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_multiview-features[]
  * [[{anchor-prefix}features-multiview]] pname:multiview specifies whether
    the implementation supports multiview rendering within a render pass.
    If this feature is not enabled, the view mask of each subpass must:
    always be zero.
  * [[{anchor-prefix}features-multiview-gs]] pname:multiviewGeometryShader
    specifies whether the implementation supports multiview rendering within
    a render pass, with <<geometry,geometry shaders>>.
    If this feature is not enabled, then a pipeline compiled against a
    subpass with a non-zero view mask must: not include a geometry shader.
  * [[{anchor-prefix}features-multiview-tess]]
    pname:multiviewTessellationShader specifies whether the implementation
    supports multiview rendering within a render pass, with
    <<tessellation,tessellation shaders>>.
    If this feature is not enabled, then a pipeline compiled against a
    subpass with a non-zero view mask must: not include any tessellation
    shaders.
// end::VK_KHR_multiview-features[]

:refpage: VkPhysicalDeviceMultiviewFeatures
include::{chapters}/features.txt[tag=features]

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceMultiviewFeatures-multiviewGeometryShader-00580]]
    If pname:multiviewGeometryShader is enabled then pname:multiview must:
    also be enabled
  * [[VUID-VkPhysicalDeviceMultiviewFeatures-multiviewTessellationShader-00581]]
    If pname:multiviewTessellationShader is enabled then pname:multiview
    must: also be enabled
****

include::{generated}/validity/structs/VkPhysicalDeviceMultiviewFeatures.txt[]
--
endif::VK_VERSION_1_1,VK_KHR_multiview[]

ifdef::VK_EXT_shader_atomic_float[]
[open,refpage='VkPhysicalDeviceShaderAtomicFloatFeaturesEXT',desc='Structure describing features supported by VK_EXT_shader_atomic_float',type='structs']
--
The slink:VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// tag::VK_EXT_shader_atomic_float-features[]
  * [[features-shaderBufferFloat32Atomics]] pname:shaderBufferFloat32Atomics
    indicates whether shaders can: perform 32-bit floating-point load, store
    and exchange atomic operations on storage buffers.
  * [[features-shaderBufferFloat32AtomicAdd]]
    pname:shaderBufferFloat32AtomicAdd indicates whether shaders can:
    perform 32-bit floating-point add atomic operations on storage buffers.
  * [[features-shaderBufferFloat64Atomics]] pname:shaderBufferFloat64Atomics
    indicates whether shaders can: perform 64-bit floating-point load, store
    and exchange atomic operations on storage buffers.
  * [[features-shaderBufferFloat64AtomicAdd]]
    pname:shaderBufferFloat64AtomicAdd indicates whether shaders can:
    perform 64-bit floating-point add atomic operations on storage buffers.
  * [[features-shaderSharedFloat32Atomics]] pname:shaderSharedFloat32Atomics
    indicates whether shaders can: perform 32-bit floating-point load, store
    and exchange atomic operations on shared memory.
  * [[features-shaderSharedFloat32AtomicAdd]]
    pname:shaderSharedFloat32AtomicAdd indicates whether shaders can:
    perform 32-bit floating-point add atomic operations on shared memory.
  * [[features-shaderSharedFloat64Atomics]] pname:shaderSharedFloat64Atomics
    indicates whether shaders can: perform 64-bit floating-point load, store
    and exchange atomic operations on shared memory.
  * [[features-shaderSharedFloat64AtomicAdd]]
    pname:shaderSharedFloat64AtomicAdd indicates whether shaders can:
    perform 64-bit floating-point add atomic operations on shared memory.
  * [[features-shaderImageFloat32Atomics]] pname:shaderImageFloat32Atomics
    indicates whether shaders can: perform 32-bit floating-point load, store
    and exchange atomic image operations.
  * [[features-shaderImageFloat32AtomicAdd]]
    pname:shaderImageFloat32AtomicAdd indicates whether shaders can: perform
    32-bit floating-point add atomic image operations.
  * [[features-sparseImageFloat32Atomics]] pname:sparseImageFloat32Atomics
    indicates whether 32-bit floating-point load, store and exchange atomic
    operations can: be used on sparse images.
  * [[features-sparseImageFloat32AtomicAdd]]
    pname:sparseImageFloat32AtomicAdd indicates whether 32-bit
    floating-point add atomic operations can: be used on sparse images.
// end::VK_EXT_shader_atomic_float-features[]

:refpage: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.txt[]
--
endif::VK_EXT_shader_atomic_float[]

ifdef::VK_EXT_shader_atomic_float2[]
[open,refpage='VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT',desc='Structure describing features supported by VK_EXT_shader_atomic_float2',type='structs']
--
The slink:VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// tag::VK_EXT_shader_atomic_float2-features[]
  * [[features-shaderBufferFloat16Atomics]] pname:shaderBufferFloat16Atomics
    indicates whether shaders can: perform 16-bit floating-point load,
    store, and exchange atomic operations on storage buffers.
  * [[features-shaderBufferFloat16AtomicAdd]]
    pname:shaderBufferFloat16AtomicAdd indicates whether shaders can:
    perform 16-bit floating-point add atomic operations on storage buffers.
  * [[features-shaderBufferFloat16AtomicMinMax]]
    pname:shaderBufferFloat16AtomicMinMax indicates whether shaders can:
    perform 16-bit floating-point min and max atomic operations on storage
    buffers.
  * [[features-shaderBufferFloat32AtomicMinMax]]
    pname:shaderBufferFloat32AtomicMinMax indicates whether shaders can:
    perform 32-bit floating-point min and max atomic operations on storage
    buffers.
  * [[features-shaderBufferFloat64AtomicMinMax]]
    pname:shaderBufferFloat64AtomicMinMax indicates whether shaders can:
    perform 64-bit floating-point min and max atomic operations on storage
    buffers.
  * [[features-shaderSharedFloat16Atomics]] pname:shaderSharedFloat16Atomics
    indicates whether shaders can: perform 16-bit floating-point load, store
    and exchange atomic operations on shared memory.
  * [[features-shaderSharedFloat16AtomicAdd]]
    pname:shaderSharedFloat16AtomicAdd indicates whether shaders can:
    perform 16-bit floating-point add atomic operations on shared memory.
  * [[features-shaderSharedFloat16AtomicMinMax]]
    pname:shaderSharedFloat16AtomicMinMax indicates whether shaders can:
    perform 16-bit floating-point min and max atomic operations on shared
    memory.
  * [[features-shaderSharedFloat32AtomicMinMax]]
    pname:shaderSharedFloat32AtomicMinMax indicates whether shaders can:
    perform 32-bit floating-point min and max atomic operations on shared
    memory.
  * [[features-shaderSharedFloat64AtomicMinMax]]
    pname:shaderSharedFloat64AtomicMinMax indicates whether shaders can:
    perform 64-bit floating-point min and max atomic operations on shared
    memory.
  * [[features-shaderImageFloat32AtomicMinMax]]
    pname:shaderImageFloat32AtomicMinMax indicates whether shaders can:
    perform 32-bit floating-point min and max atomic image operations.
  * [[features-sparseImageFloat32AtomicMinMax]]
    pname:sparseImageFloat32AtomicMinMax indicates whether 32-bit
    floating-point min and max atomic operations can: be used on sparse
    images.
// end::VK_EXT_shader_atomic_float2-features[]

:refpage: VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.txt[]
--
endif::VK_EXT_shader_atomic_float2[]

ifdef::VK_VERSION_1_2,VK_KHR_shader_atomic_int64[]
[open,refpage='VkPhysicalDeviceShaderAtomicInt64Features',desc='Structure describing features supported by VK_KHR_shader_atomic_int64',type='structs',alias='VkPhysicalDeviceShaderAtomicInt64FeaturesKHR']
--
The slink:VkPhysicalDeviceShaderAtomicInt64Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderAtomicInt64Features.txt[]

ifdef::VK_KHR_shader_atomic_int64[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.txt[]
endif::VK_KHR_shader_atomic_int64[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_shader_atomic_int64-features[]
  * [[{anchor-prefix}features-shaderBufferInt64Atomics]]
    pname:shaderBufferInt64Atomics indicates whether shaders can: perform
    64-bit unsigned and signed integer atomic operations on buffers.
  * [[{anchor-prefix}features-shaderSharedInt64Atomics]]
    pname:shaderSharedInt64Atomics indicates whether shaders can: perform
    64-bit unsigned and signed integer atomic operations on shared memory.
// end::VK_KHR_shader_atomic_int64-features[]

:refpage: VkPhysicalDeviceShaderAtomicInt64Features
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderAtomicInt64Features.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_shader_atomic_int64[]

ifdef::VK_EXT_shader_image_atomic_int64[]
[open,refpage='VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT',desc='Structure describing features supported by VK_EXT_shader_image_atomic_int64',type='structs']
--
The slink:VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderImageInt64Atomics]] pname:shaderImageInt64Atomics
    indicates whether shaders can: support 64-bit unsigned and signed
    integer atomic operations on images.
  * [[features-sparseImageInt64Atomics]] pname:sparseImageInt64Atomics
    indicates whether 64-bit integer atomics can: be used on sparse images.

:refpage: VkPhysicalDeviceShaderAtomicInt64FeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.txt[]
--
endif::VK_EXT_shader_image_atomic_int64[]

ifdef::VK_VERSION_1_2,VK_KHR_8bit_storage[]
[open,refpage='VkPhysicalDevice8BitStorageFeatures',desc='Structure describing features supported by VK_KHR_8bit_storage',type='structs',alias='VkPhysicalDevice8BitStorageFeaturesKHR']
--
The slink:VkPhysicalDevice8BitStorageFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDevice8BitStorageFeatures.txt[]

ifdef::VK_KHR_8bit_storage[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDevice8BitStorageFeaturesKHR.txt[]
endif::VK_KHR_8bit_storage[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_8bit_storage-features[]
  * [[{anchor-prefix}features-storageBuffer8BitAccess]]
    pname:storageBuffer8BitAccess indicates whether objects in the
    code:StorageBuffer,
ifdef::VK_KHR_ray_tracing_pipeline[code:ShaderRecordBufferKHR,]
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    or code:PhysicalStorageBuffer
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    storage class with the code:Block decoration can: have 8-bit integer
    members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:StorageBuffer8BitAccess capability.
  * [[{anchor-prefix}features-uniformAndStorageBuffer8BitAccess]]
    pname:uniformAndStorageBuffer8BitAccess indicates whether objects in the
    code:Uniform storage class with the code:Block decoration can: have
    8-bit integer members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:UniformAndStorageBuffer8BitAccess capability.
  * [[{anchor-prefix}features-storagePushConstant8]]
    pname:storagePushConstant8 indicates whether objects in the
    code:PushConstant storage class can: have 8-bit integer members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:StoragePushConstant8 capability.
// end::VK_KHR_8bit_storage-features[]

:refpage: VkPhysicalDevice8BitStorageFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDevice8BitStorageFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_8bit_storage[]

ifdef::VK_VERSION_1_1,VK_KHR_16bit_storage[]
[open,refpage='VkPhysicalDevice16BitStorageFeatures',desc='Structure describing features supported by VK_KHR_16bit_storage',type='structs']
--
The slink:VkPhysicalDevice16BitStorageFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDevice16BitStorageFeatures.txt[]

ifdef::VK_KHR_16bit_storage[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDevice16BitStorageFeaturesKHR.txt[]
endif::VK_KHR_16bit_storage[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_16bit_storage-features[]
  * [[{anchor-prefix}features-storageBuffer16BitAccess]]
    pname:storageBuffer16BitAccess specifies whether objects in the
    code:StorageBuffer,
ifdef::VK_KHR_ray_tracing_pipeline[code:ShaderRecordBufferKHR,]
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    or code:PhysicalStorageBuffer
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
    storage class with the code:Block decoration can: have 16-bit integer
    and 16-bit floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:StorageBuffer16BitAccess capability.
  * [[{anchor-prefix}features-uniformAndStorageBuffer16BitAccess]]
    pname:uniformAndStorageBuffer16BitAccess specifies whether objects in
    the code:Uniform storage class with the code:Block decoration can: have
    16-bit integer and 16-bit floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:UniformAndStorageBuffer16BitAccess capability.
  * [[{anchor-prefix}features-storagePushConstant16]]
    pname:storagePushConstant16 specifies whether objects in the
    code:PushConstant storage class can: have 16-bit integer and 16-bit
    floating-point members.
    If this feature is not enabled, 16-bit integer or floating-point members
    must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:StoragePushConstant16 capability.
  * [[{anchor-prefix}features-storageInputOutput16]]
    pname:storageInputOutput16 specifies whether objects in the code:Input
    and code:Output storage classes can: have 16-bit integer and 16-bit
    floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:StorageInputOutput16 capability.
// end::VK_KHR_16bit_storage-features[]

:refpage: VkPhysicalDevice16BitStorageFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDevice16BitStorageFeatures.txt[]
--
endif::VK_VERSION_1_1,VK_KHR_16bit_storage[]

ifdef::VK_VERSION_1_2,VK_KHR_shader_float16_int8[]
[open,refpage='VkPhysicalDeviceShaderFloat16Int8Features',desc='Structure describing features supported by VK_KHR_shader_float16_int8',type='structs',alias='VkPhysicalDeviceShaderFloat16Int8FeaturesKHR VkPhysicalDeviceFloat16Int8FeaturesKHR']
--
The sname:VkPhysicalDeviceShaderFloat16Int8Features structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderFloat16Int8Features.txt[]

ifdef::VK_KHR_shader_float16_int8[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceShaderFloat16Int8FeaturesKHR.txt[]

include::{generated}/api/structs/VkPhysicalDeviceFloat16Int8FeaturesKHR.txt[]
endif::VK_KHR_shader_float16_int8[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_shader_float16_int8-features[]
  * [[{anchor-prefix}features-shaderFloat16]] pname:shaderFloat16 indicates
    whether 16-bit floats (halfs) are supported in shader code.
    This also indicates whether shader modules can: declare the code:Float16
    capability.
    However, this only enables a subset of the storage classes that SPIR-V
    allows for the code:Float16 SPIR-V capability: Declaring and using
    16-bit floats in the code:Private,
ifndef::VK_KHR_workgroup_memory_explicit_layout[]
    code:Workgroup,
endif::VK_KHR_workgroup_memory_explicit_layout[]
ifdef::VK_KHR_workgroup_memory_explicit_layout[]
    code:Workgroup (for non-Block variables),
endif::VK_KHR_workgroup_memory_explicit_layout[]
    and code:Function storage classes is enabled, while declaring them in
    the interface storage classes (e.g., code:UniformConstant, code:Uniform,
    code:StorageBuffer, code:Input, code:Output, and code:PushConstant) is
    not enabled.
  * [[{anchor-prefix}features-shaderInt8]] pname:shaderInt8 indicates
    whether 8-bit integers (signed and unsigned) are supported in shader
    code.
    This also indicates whether shader modules can: declare the code:Int8
    capability.
    However, this only enables a subset of the storage classes that SPIR-V
    allows for the code:Int8 SPIR-V capability: Declaring and using 8-bit
    integers in the code:Private,
ifndef::VK_KHR_workgroup_memory_explicit_layout[]
    code:Workgroup,
endif::VK_KHR_workgroup_memory_explicit_layout[]
ifdef::VK_KHR_workgroup_memory_explicit_layout[]
    code:Workgroup (for non-Block variables),
endif::VK_KHR_workgroup_memory_explicit_layout[]
    and code:Function storage classes is enabled, while declaring them in
    the interface storage classes (e.g., code:UniformConstant, code:Uniform,
    code:StorageBuffer, code:Input, code:Output, and code:PushConstant) is
    not enabled.
// end::VK_KHR_shader_float16_int8-features[]

:refpage: VkPhysicalDeviceShaderFloat16Int8Features
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderFloat16Int8Features.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_shader_float16_int8[]

ifdef::VK_KHR_shader_clock[]
[open,refpage='VkPhysicalDeviceShaderClockFeaturesKHR',desc='Structure describing features supported by VK_KHR_shader_clock',type='structs']
--
The slink:VkPhysicalDeviceShaderClockFeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderClockFeaturesKHR.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderSubgroupClock]] pname:shaderSubgroupClock indicates
    whether shaders can: perform code:Subgroup scoped clock reads.
  * [[features-shaderDeviceClock]] pname:shaderDeviceClock indicates whether
    shaders can: perform code:Device scoped clock reads.

:refpage: VkPhysicalDeviceShaderClockFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderClockFeaturesKHR.txt[]
--
endif::VK_KHR_shader_clock[]

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
[open,refpage='VkPhysicalDeviceSamplerYcbcrConversionFeatures',desc='Structure describing {YCbCr} conversion features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR']
--
The sname:VkPhysicalDeviceSamplerYcbcrConversionFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceSamplerYcbcrConversionFeatures.txt[]

ifdef::VK_KHR_sampler_ycbcr_conversion[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.txt[]
endif::VK_KHR_sampler_ycbcr_conversion[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_sampler_ycbcr_conversion-features[]
  * [[{anchor-prefix}features-samplerYcbcrConversion]]
    pname:samplerYcbcrConversion specifies whether the implementation
    supports <<samplers-YCbCr-conversion,sampler {YCbCr} conversion>>.
    If pname:samplerYcbcrConversion is ename:VK_FALSE, sampler {YCbCr}
    conversion is not supported, and samplers using sampler {YCbCr}
    conversion must: not be used.
// end::VK_KHR_sampler_ycbcr_conversion-features[]

:refpage: VkPhysicalDeviceSamplerYcbcrConversionFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceSamplerYcbcrConversionFeatures.txt[]
--
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

ifdef::VK_VERSION_1_1[]
[open,refpage='VkPhysicalDeviceProtectedMemoryFeatures',desc='Structure describing protected memory features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceProtectedMemoryFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceProtectedMemoryFeatures.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_protected_memory-features[]
  * [[{anchor-prefix}features-protectedMemory]] pname:protectedMemory
    specifies whether protected memory is supported.
// end::VK_KHR_protected_memory-features[]

:refpage: VkPhysicalDeviceProtectedMemoryFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceProtectedMemoryFeatures.txt[]
--
endif::VK_VERSION_1_1[]

ifdef::VK_EXT_blend_operation_advanced[]
[open,refpage='VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT',desc='Structure describing advanced blending features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-advancedBlendCoherentOperations]]
    pname:advancedBlendCoherentOperations specifies whether blending using
    <<framebuffer-blend-advanced,advanced blend operations>> is guaranteed
    to execute atomically and in <<drawing-primitive-order, primitive
    order>>.
    If this is ename:VK_TRUE,
    ename:VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT is treated the
    same as ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT, and advanced blending
    needs no additional synchronization over basic blending.
    If this is ename:VK_FALSE, then memory dependencies are required to
    guarantee order between two advanced blending operations that occur on
    the same sample.

:refpage: VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.txt[]
--
endif::VK_EXT_blend_operation_advanced[]

ifdef::VK_EXT_conditional_rendering[]
[open,refpage='VkPhysicalDeviceConditionalRenderingFeaturesEXT',desc='Structure describing if a secondary command buffer can be executed if conditional rendering is active in the primary command buffer',type='structs']
--
The sname:VkPhysicalDeviceConditionalRenderingFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceConditionalRenderingFeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-conditionalRendering]] pname:conditionalRendering specifies
    whether conditional rendering is supported.
  * [[features-inheritedConditionalRendering]]
    pname:inheritedConditionalRendering specifies whether a secondary
    command buffer can: be executed while conditional rendering is active in
    the primary command buffer.

:refpage: VkPhysicalDeviceConditionalRenderingFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceConditionalRenderingFeaturesEXT.txt[]
--
endif::VK_EXT_conditional_rendering[]

ifdef::VK_VERSION_1_1[]
[open,refpage='VkPhysicalDeviceShaderDrawParametersFeatures',desc='Structure describing shader draw parameter features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceShaderDrawParameterFeatures']
--
The sname:VkPhysicalDeviceShaderDrawParametersFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderDrawParametersFeatures.txt[]

include::{generated}/api/structs/VkPhysicalDeviceShaderDrawParameterFeatures.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_shader_draw_parameters-features[]
  * [[{anchor-prefix}features-shaderDrawParameters]]
    pname:shaderDrawParameters specifies whether the implementation supports
    the SPIR-V code:DrawParameters capability.
    When this feature is not enabled, shader modules must: not declare the
    `SPV_KHR_shader_draw_parameters` extension or the code:DrawParameters
    capability.
// end::VK_KHR_shader_draw_parameters-features[]

:refpage: VkPhysicalDeviceShaderDrawParametersFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderDrawParametersFeatures.txt[]
--
endif::VK_VERSION_1_1[]

ifdef::VK_NV_mesh_shader[]
[open,refpage='VkPhysicalDeviceMeshShaderFeaturesNV',desc='Structure describing mesh shading features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMeshShaderFeaturesNV structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMeshShaderFeaturesNV.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-taskShader]] pname:taskShader indicates whether the task
    shader stage is supported.
  * [[features-meshShader]] pname:meshShader indicates whether the mesh
    shader stage is supported.

:refpage: VkPhysicalDeviceMeshShaderFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMeshShaderFeaturesNV.txt[]
--
endif::VK_NV_mesh_shader[]

ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
[open,refpage='VkPhysicalDeviceDescriptorIndexingFeatures',desc='Structure describing descriptor indexing features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceDescriptorIndexingFeaturesEXT']
--
The sname:VkPhysicalDeviceDescriptorIndexingFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDescriptorIndexingFeatures.txt[]

ifdef::VK_EXT_descriptor_indexing[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceDescriptorIndexingFeaturesEXT.txt[]
endif::VK_EXT_descriptor_indexing[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_descriptor_indexing-features[]
  * [[{anchor-prefix}features-shaderInputAttachmentArrayDynamicIndexing]]
    pname:shaderInputAttachmentArrayDynamicIndexing indicates whether arrays
    of input attachments can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:InputAttachmentArrayDynamicIndexing capability.
  * [[{anchor-prefix}features-shaderUniformTexelBufferArrayDynamicIndexing]]
    pname:shaderUniformTexelBufferArrayDynamicIndexing indicates whether
    arrays of uniform texel buffers can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformTexelBufferArrayDynamicIndexing capability.
  * [[{anchor-prefix}features-shaderStorageTexelBufferArrayDynamicIndexing]]
    pname:shaderStorageTexelBufferArrayDynamicIndexing indicates whether
    arrays of storage texel buffers can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageTexelBufferArrayDynamicIndexing capability.
  * [[{anchor-prefix}features-shaderUniformBufferArrayNonUniformIndexing]]
    pname:shaderUniformBufferArrayNonUniformIndexing indicates whether
    arrays of uniform buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformBufferArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderSampledImageArrayNonUniformIndexing]]
    pname:shaderSampledImageArrayNonUniformIndexing indicates whether arrays
    of samplers or sampled images can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:SampledImageArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderStorageBufferArrayNonUniformIndexing]]
    pname:shaderStorageBufferArrayNonUniformIndexing indicates whether
    arrays of storage buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageBufferArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderStorageImageArrayNonUniformIndexing]]
    pname:shaderStorageImageArrayNonUniformIndexing indicates whether arrays
    of storage images can: be indexed by non-uniform integer expressions in
    shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageImageArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderInputAttachmentArrayNonUniformIndexing]]
    pname:shaderInputAttachmentArrayNonUniformIndexing indicates whether
    arrays of input attachments can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:InputAttachmentArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderUniformTexelBufferArrayNonUniformIndexing]]
    pname:shaderUniformTexelBufferArrayNonUniformIndexing indicates whether
    arrays of uniform texel buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformTexelBufferArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-shaderStorageTexelBufferArrayNonUniformIndexing]]
    pname:shaderStorageTexelBufferArrayNonUniformIndexing indicates whether
    arrays of storage texel buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageTexelBufferArrayNonUniformIndexing capability.
  * [[{anchor-prefix}features-descriptorBindingUniformBufferUpdateAfterBind]]
    pname:descriptorBindingUniformBufferUpdateAfterBind indicates whether
    the implementation supports updating uniform buffer descriptors after a
    set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER.
  * [[{anchor-prefix}features-descriptorBindingSampledImageUpdateAfterBind]]
    pname:descriptorBindingSampledImageUpdateAfterBind indicates whether the
    implementation supports updating sampled image descriptors after a set
    is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE.
  * [[{anchor-prefix}features-descriptorBindingStorageImageUpdateAfterBind]]
    pname:descriptorBindingStorageImageUpdateAfterBind indicates whether the
    implementation supports updating storage image descriptors after a set
    is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.
  * [[{anchor-prefix}features-descriptorBindingStorageBufferUpdateAfterBind]]
    pname:descriptorBindingStorageBufferUpdateAfterBind indicates whether
    the implementation supports updating storage buffer descriptors after a
    set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER.
  * [[{anchor-prefix}features-descriptorBindingUniformTexelBufferUpdateAfterBind]]
    pname:descriptorBindingUniformTexelBufferUpdateAfterBind indicates
    whether the implementation supports updating uniform texel buffer
    descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.
  * [[{anchor-prefix}features-descriptorBindingStorageTexelBufferUpdateAfterBind]]
    pname:descriptorBindingStorageTexelBufferUpdateAfterBind indicates
    whether the implementation supports updating storage texel buffer
    descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.
  * [[{anchor-prefix}features-descriptorBindingUpdateUnusedWhilePending]]
    pname:descriptorBindingUpdateUnusedWhilePending indicates whether the
    implementation supports updating descriptors while the set is in use.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT must: not be
    used.
  * [[{anchor-prefix}features-descriptorBindingPartiallyBound]]
    pname:descriptorBindingPartiallyBound indicates whether the
    implementation supports statically using a descriptor set binding in
    which some descriptors are not valid.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT must: not be used.
  * [[{anchor-prefix}features-descriptorBindingVariableDescriptorCount]]
    pname:descriptorBindingVariableDescriptorCount indicates whether the
    implementation supports descriptor sets with a variable-sized last
    binding.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT must: not be
    used.
  * [[{anchor-prefix}features-runtimeDescriptorArray]]
    pname:runtimeDescriptorArray indicates whether the implementation
    supports the SPIR-V code:RuntimeDescriptorArray capability.
    If this feature is not enabled, descriptors must: not be declared in
    runtime arrays.
// end::VK_EXT_descriptor_indexing-features[]

:refpage: VkPhysicalDeviceDescriptorIndexingFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDescriptorIndexingFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]

ifdef::VK_EXT_vertex_attribute_divisor[]
[open,refpage='VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT',desc='Structure describing if fetching of vertex attribute may be repeated for instanced rendering',type='structs']
--
The sname:VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-vertexAttributeInstanceRateDivisor]]
    pname:vertexAttributeInstanceRateDivisor specifies whether vertex
    attribute fetching may be repeated in case of instanced rendering.
  * [[features-vertexAttributeInstanceRateZeroDivisor]]
    pname:vertexAttributeInstanceRateZeroDivisor specifies whether a zero
    value for sname:VkVertexInputBindingDivisorDescriptionEXT::pname:divisor
    is supported.

:refpage: VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.txt[]
--
endif::VK_EXT_vertex_attribute_divisor[]

ifdef::VK_EXT_astc_decode_mode[]
[open,refpage='VkPhysicalDeviceASTCDecodeFeaturesEXT',desc='Structure describing ASTC decode mode features',type='structs']
--
The sname:VkPhysicalDeviceASTCDecodeFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceASTCDecodeFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-astc-decodeModeSharedExponent]]
    pname:decodeModeSharedExponent indicates whether the implementation
    supports decoding ASTC compressed formats to
    ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 internal precision.

:refpage: VkPhysicalDeviceASTCDecodeFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceASTCDecodeFeaturesEXT.txt[]
--
endif::VK_EXT_astc_decode_mode[]

ifdef::VK_EXT_transform_feedback[]
[open,refpage='VkPhysicalDeviceTransformFeedbackFeaturesEXT',desc='Structure describing transform feedback features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceTransformFeedbackFeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-transformFeedback]] pname:transformFeedback indicates whether
    the implementation supports transform feedback and shader modules can:
    declare the code:TransformFeedback capability.
  * [[features-geometryStreams]] pname:geometryStreams indicates whether the
    implementation supports the code:GeometryStreams SPIR-V capability.

:refpage: VkPhysicalDeviceTransformFeedbackFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceTransformFeedbackFeaturesEXT.txt[]
--
endif::VK_EXT_transform_feedback[]

ifdef::VK_VERSION_1_2,VK_KHR_vulkan_memory_model[]
[open,refpage='VkPhysicalDeviceVulkanMemoryModelFeatures',desc='Structure describing features supported by the memory model',type='structs']
--
The sname:VkPhysicalDeviceVulkanMemoryModelFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceVulkanMemoryModelFeatures.txt[]

ifdef::VK_KHR_vulkan_memory_model[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.txt[]
endif::VK_KHR_vulkan_memory_model[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_vulkan_memory_model-features[]
  * [[{anchor-prefix}features-vulkanMemoryModel]] pname:vulkanMemoryModel
    indicates whether the Vulkan Memory Model is supported, as defined in
    <<memory-model,Vulkan Memory Model>>.
    This also indicates whether shader modules can: declare the
    code:VulkanMemoryModel capability.
  * [[{anchor-prefix}features-vulkanMemoryModelDeviceScope]]
    pname:vulkanMemoryModelDeviceScope indicates whether the Vulkan Memory
    Model can use code:Device scope synchronization.
    This also indicates whether shader modules can: declare the
    code:VulkanMemoryModelDeviceScope capability.
  * [[{anchor-prefix}features-vulkanMemoryModelAvailabilityVisibilityChains]]
    pname:vulkanMemoryModelAvailabilityVisibilityChains indicates whether
    the Vulkan Memory Model can use <<memory-model-availability-visibility,
    availability and visibility chains>> with more than one element.
// end::VK_KHR_vulkan_memory_model-features[]

:refpage: VkPhysicalDeviceVulkanMemoryModelFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceVulkanMemoryModelFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_vulkan_memory_model[]

ifdef::VK_EXT_inline_uniform_block[]
[open,refpage='VkPhysicalDeviceInlineUniformBlockFeaturesEXT',desc='Structure describing inline uniform block features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceInlineUniformBlockFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceInlineUniformBlockFeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-inlineUniformBlock]] pname:inlineUniformBlock indicates
    whether the implementation supports inline uniform block descriptors.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT must: not be used.
  * [[features-descriptorBindingInlineUniformBlockUpdateAfterBind]]
    pname:descriptorBindingInlineUniformBlockUpdateAfterBind
ifndef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    is ename:VK_FALSE and reserved for future use.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
    indicates whether the implementation supports updating inline uniform
    block descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]

:refpage: VkPhysicalDeviceInlineUniformBlockFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceInlineUniformBlockFeaturesEXT.txt[]
--
endif::VK_EXT_inline_uniform_block[]

ifdef::VK_NV_representative_fragment_test[]
[open,refpage='VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV',desc='Structure describing the representative fragment test features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-representativeFragmentTest]] pname:representativeFragmentTest
    indicates whether the implementation supports the representative
    fragment test.
    See <<fragops-rep-frag-test, Representative Fragment Test>>.

:refpage: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.txt[]
--
endif::VK_NV_representative_fragment_test[]

ifdef::VK_NV_scissor_exclusive[]
[open,refpage='VkPhysicalDeviceExclusiveScissorFeaturesNV',desc='Structure describing exclusive scissor features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceExclusiveScissorFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceExclusiveScissorFeaturesNV.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-exclusiveScissor]] pname:exclusiveScissor indicates that the
    implementation supports the exclusive scissor test.

See <<fragops-exclusive-scissor,Exclusive Scissor Test>> for more
information.

:refpage: VkPhysicalDeviceExclusiveScissorFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExclusiveScissorFeaturesNV.txt[]
--
endif::VK_NV_scissor_exclusive[]

ifdef::VK_NV_corner_sampled_image[]
[open,refpage='VkPhysicalDeviceCornerSampledImageFeaturesNV',desc='Structure describing corner sampled image features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCornerSampledImageFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCornerSampledImageFeaturesNV.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-cornersampledimage]] pname:cornerSampledImage specifies
    whether images can be created with a
    slink:VkImageCreateInfo::pname:flags containing
    ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV.
    See <<resources-images-corner-sampled,Corner-Sampled Images>>.

:refpage: VkPhysicalDeviceCornerSampledImageFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCornerSampledImageFeaturesNV.txt[]
--
endif::VK_NV_corner_sampled_image[]

ifdef::VK_NV_compute_shader_derivatives[]
[open,refpage='VkPhysicalDeviceComputeShaderDerivativesFeaturesNV',desc='Structure describing compute shader derivative features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceComputeShaderDerivativesFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-computeDerivativeGroupQuads]]
    pname:computeDerivativeGroupQuads indicates that the implementation
    supports the code:ComputeDerivativeGroupQuadsNV SPIR-V capability.
  * [[features-computeDerivativeGroupLinear]]
    pname:computeDerivativeGroupLinear indicates that the implementation
    supports the code:ComputeDerivativeGroupLinearNV SPIR-V capability.

See <<shaders-scope-quad, Quad shader scope>> for more information.

:refpage: VkPhysicalDeviceComputeShaderDerivativesFeaturesNVfeatures.
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.txt[]
--
endif::VK_NV_compute_shader_derivatives[]

ifdef::VK_NV_fragment_shader_barycentric[]
[open,refpage='VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV',desc='Structure describing barycentric support in fragment shaders that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-fragmentShaderBarycentric]] pname:fragmentShaderBarycentric
    indicates that the implementation supports the code:BaryCoordNV and
    code:BaryCoordNoPerspNV SPIR-V fragment shader built-ins and supports
    the code:PerVertexNV SPIR-V decoration on fragment shader input
    variables.

See <<primsrast-barycentric,Barycentric Interpolation>> for more
information.

:refpage: VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.txt[]
--
endif::VK_NV_fragment_shader_barycentric[]

ifdef::VK_NV_shader_image_footprint[]
[open,refpage='VkPhysicalDeviceShaderImageFootprintFeaturesNV',desc='Structure describing shader image footprint features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderImageFootprintFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderImageFootprintFeaturesNV.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-imageFootprint]] pname:imageFootprint specifies whether the
    implementation supports the code:ImageFootprintNV SPIR-V capability.

See <<textures-footprint,Texel Footprint Evaluation>> for more information.

:refpage: VkPhysicalDeviceShaderImageFootprintFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderImageFootprintFeaturesNV.txt[]
--
endif::VK_NV_shader_image_footprint[]

ifdef::VK_NV_shading_rate_image[]
[open,refpage='VkPhysicalDeviceShadingRateImageFeaturesNV',desc='Structure describing shading rate image features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShadingRateImageFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShadingRateImageFeaturesNV.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shadingRateImage]] pname:shadingRateImage indicates that the
    implementation supports the use of a shading rate image to derive an
    effective shading rate for fragment processing.
    It also indicates that the implementation supports the
    code:ShadingRateNV SPIR-V execution mode.
  * [[features-shadingRateCoarseSampleOrder]]
    pname:shadingRateCoarseSampleOrder indicates that the implementation
    supports a user-configurable ordering of coverage samples in fragments
    larger than one pixel.

See <<primsrast-shading-rate-image, Shading Rate Image>> for more
information.

:refpage: VkPhysicalDeviceShadingRateImageFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShadingRateImageFeaturesNV.txt[]
--
endif::VK_NV_shading_rate_image[]

ifdef::VK_EXT_fragment_density_map[]
[open,refpage='VkPhysicalDeviceFragmentDensityMapFeaturesEXT',desc='Structure describing fragment density map features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-fragmentDensityMap]] pname:fragmentDensityMap specifies
    whether the implementation supports render passes with a fragment
    density map attachment.
    If this feature is not enabled and the pname:pNext chain of
    slink:VkRenderPassCreateInfo includes a
    slink:VkRenderPassFragmentDensityMapCreateInfoEXT structure,
    pname:fragmentDensityMapAttachment must: be ename:VK_ATTACHMENT_UNUSED.
  * [[features-fragmentDensityMapDynamic]] pname:fragmentDensityMapDynamic
    specifies whether the implementation supports dynamic fragment density
    map image views.
    If this feature is not enabled,
    ename:VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT must:
    not be included in slink:VkImageViewCreateInfo::pname:flags.
  * [[features-fragmentDensityMapNonSubsampledImages]]
    pname:fragmentDensityMapNonSubsampledImages specifies whether the
    implementation supports regular non-subsampled image attachments with
    fragment density map render passes.
    If this feature is not enabled, render passes with a
    <<renderpass-fragmentdensitymapattachment,fragment density map
    attachment>> must: only have <<samplers-subsamplesampler,subsampled
    attachments>> bound.

:refpage: VkPhysicalDeviceFragmentDensityMapFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.txt[]
--
endif::VK_EXT_fragment_density_map[]

ifdef::VK_EXT_fragment_density_map2[]
[open,refpage='VkPhysicalDeviceFragmentDensityMap2FeaturesEXT',desc='Structure describing additional fragment density map features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentDensityMap2FeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-fragmentDensityMapDeferred]] pname:fragmentDensityMapDeferred
    specifies whether the implementation supports deferred reads of fragment
    density map image views.
    If this feature is not enabled,
    ename:VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT must:
    not be included in sname:VkImageViewCreateInfo::pname:flags.

:refpage: VkPhysicalDeviceFragmentDensityMap2FeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.txt[]
--
endif::VK_EXT_fragment_density_map2[]

ifdef::VK_HUAWEI_invocation_mask[]
[open,refpage='VkPhysicalDeviceInvocationMaskFeaturesHUAWEI',desc='Structure describing invocation mask features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceInvocationMaskFeaturesHUAWEI structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-invocationMask]] pname:invocationMask indicates that the
    implementation supports the use of an invocation mask image to optimize
    the ray dispatch.

:refpage: VkPhysicalDeviceInvocationMaskFeaturesHUAWEI
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.txt[]
--
endif::VK_HUAWEI_invocation_mask[]

ifdef::VK_VERSION_1_2,VK_EXT_scalar_block_layout[]
[open,refpage='VkPhysicalDeviceScalarBlockLayoutFeatures',desc='Structure indicating support for scalar block layouts',type='structs',alias='VkPhysicalDeviceScalarBlockLayoutFeaturesEXT']
--
The sname:VkPhysicalDeviceScalarBlockLayoutFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceScalarBlockLayoutFeatures.txt[]

ifdef::VK_EXT_scalar_block_layout[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.txt[]
endif::VK_EXT_scalar_block_layout[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_scalar_block_layout-features[]
  * [[{anchor-prefix}features-scalarBlockLayout]] pname:scalarBlockLayout
    indicates that the implementation supports the layout of resource blocks
    in shaders using <<interfaces-alignment-requirements, scalar
    alignment>>.
// end::VK_EXT_scalar_block_layout-features[]

:refpage: VkPhysicalDeviceScalarBlockLayoutFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceScalarBlockLayoutFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_EXT_scalar_block_layout[]

ifdef::VK_VERSION_1_2,VK_KHR_uniform_buffer_standard_layout[]
[open,refpage='VkPhysicalDeviceUniformBufferStandardLayoutFeatures',desc='Structure indicating support for std430-like packing in uniform buffers',type='structs',alias='VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR']
--
The sname:VkPhysicalDeviceUniformBufferStandardLayoutFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceUniformBufferStandardLayoutFeatures.txt[]

ifdef::VK_KHR_uniform_buffer_standard_layout[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.txt[]
endif::VK_KHR_uniform_buffer_standard_layout[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_uniform_buffer_standard_layout-features[]
  * [[{anchor-prefix}features-uniformBufferStandardLayout]]
    pname:uniformBufferStandardLayout indicates that the implementation
    supports the same layouts for uniform buffers as for storage and other
    kinds of buffers.
    See <<interfaces-resources-standard-layout,Standard Buffer Layout>>.
// end::VK_KHR_uniform_buffer_standard_layout-features[]

:refpage: VkPhysicalDeviceUniformBufferStandardLayoutFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceUniformBufferStandardLayoutFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_uniform_buffer_standard_layout[]

ifdef::VK_EXT_depth_clip_enable[]
[open,refpage='VkPhysicalDeviceDepthClipEnableFeaturesEXT',desc='Structure indicating support for explicit enable of depth clip',type='structs']
--
The sname:VkPhysicalDeviceDepthClipEnableFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDepthClipEnableFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-depthClipEnable]] pname:depthClipEnable indicates that the
    implementation supports setting the depth clipping operation explicitly
    via the slink:VkPipelineRasterizationDepthClipStateCreateInfoEXT
    pipeline state.
    Otherwise depth clipping is only enabled when
    slink:VkPipelineRasterizationStateCreateInfo::pname:depthClampEnable is
    set to ename:VK_FALSE.

:refpage: VkPhysicalDeviceDepthClipEnableFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDepthClipEnableFeaturesEXT.txt[]
--
endif::VK_EXT_depth_clip_enable[]

ifdef::VK_EXT_memory_priority[]
[open,refpage='VkPhysicalDeviceMemoryPriorityFeaturesEXT',desc='Structure describing memory priority features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMemoryPriorityFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMemoryPriorityFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-memoryPriority]] pname:memoryPriority indicates that the
    implementation supports memory priorities specified at memory allocation
    time via slink:VkMemoryPriorityAllocateInfoEXT.

:refpage: VkPhysicalDeviceMemoryPriorityFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMemoryPriorityFeaturesEXT.txt[]
--
endif::VK_EXT_memory_priority[]

ifdef::VK_VERSION_1_2,VK_KHR_buffer_device_address[]
[open,refpage='VkPhysicalDeviceBufferDeviceAddressFeatures',desc='Structure describing buffer address features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceBufferDeviceAddressFeaturesKHR']
--
The sname:VkPhysicalDeviceBufferDeviceAddressFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceBufferDeviceAddressFeatures.txt[]

ifdef::VK_KHR_buffer_device_address[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceBufferDeviceAddressFeaturesKHR.txt[]
endif::VK_KHR_buffer_device_address[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_buffer_device_address-features[]
  * [[{anchor-prefix}features-bufferDeviceAddress]]
    pname:bufferDeviceAddress indicates that the implementation supports
    accessing buffer memory in shaders as storage buffers via an address
    queried from flink:vkGetBufferDeviceAddress.
  * [[{anchor-prefix}features-bufferDeviceAddressCaptureReplay]]
    pname:bufferDeviceAddressCaptureReplay indicates that the implementation
    supports saving and reusing buffer and device addresses, e.g. for trace
    capture and replay.
  * [[{anchor-prefix}features-bufferDeviceAddressMultiDevice]]
    pname:bufferDeviceAddressMultiDevice indicates that the implementation
    supports the pname:bufferDeviceAddress
ifndef::VK_KHR_ray_tracing_pipeline+VK_KHR_ray_query[feature]
ifdef::VK_KHR_ray_tracing_pipeline[]
ifndef::VK_KHR_ray_query[]
    and pname:rayTracingPipeline features
endif::VK_KHR_ray_query[]
ifdef::VK_KHR_ray_query[]
    , pname:rayTracingPipeline and pname:rayQuery features
endif::VK_KHR_ray_query[]
endif::VK_KHR_ray_tracing_pipeline[]
ifndef::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_KHR_ray_query[]
    and pname:rayQuery features
endif::VK_KHR_ray_query[]
endif::VK_KHR_ray_tracing_pipeline[]
    for logical devices created with multiple physical devices.
    If this feature is not supported, buffer
ifdef::VK_KHR_acceleration_structure[]
    and acceleration structure
endif::VK_KHR_acceleration_structure[]
    addresses must: not be queried on a logical device created with more
    than one physical device.
// end::VK_EXT_buffer_device_address-features[]

[NOTE]
.Note
====
pname:bufferDeviceAddressMultiDevice exists to allow certain legacy
platforms to be able to support pname:bufferDeviceAddress without needing to
support shared GPU virtual addresses for multi-device configurations.
====

See flink:vkGetBufferDeviceAddress for more information.

:refpage: VkPhysicalDeviceBufferDeviceAddressFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceBufferDeviceAddressFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_buffer_device_address[]

ifdef::VK_EXT_buffer_device_address[]
[open,refpage='VkPhysicalDeviceBufferDeviceAddressFeaturesEXT',desc='Structure describing buffer address features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceBufferAddressFeaturesEXT']
--
The sname:VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.txt[]

include::{generated}/api/structs/VkPhysicalDeviceBufferAddressFeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-bufferDeviceAddressEXT]] pname:bufferDeviceAddress indicates
    that the implementation supports accessing buffer memory in shaders as
    storage buffers via an address queried from
    flink:vkGetBufferDeviceAddressEXT.
  * [[features-bufferDeviceAddressCaptureReplayEXT]]
    pname:bufferDeviceAddressCaptureReplay indicates that the implementation
    supports saving and reusing buffer addresses, e.g. for trace capture and
    replay.
  * [[features-bufferDeviceAddressMultiDeviceEXT]]
    pname:bufferDeviceAddressMultiDevice indicates that the implementation
    supports the pname:bufferDeviceAddress feature for logical devices
    created with multiple physical devices.
    If this feature is not supported, buffer addresses must: not be queried
    on a logical device created with more than one physical device.

:refpage: VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
include::{chapters}/features.txt[tag=features]

ifdef::VK_VERSION_1_2,VK_KHR_buffer_device_address[]
[NOTE]
.Note
====
The sname:VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure has the
same members as the sname:VkPhysicalDeviceBufferDeviceAddressFeatures
structure, but the functionality indicated by the members is expressed
differently.
The features indicated by the
sname:VkPhysicalDeviceBufferDeviceAddressFeatures structure requires
additional flags to be passed at memory allocation time, and the capture and
replay mechanism is built around opaque capture addresses for buffer and
memory objects.
====
endif::VK_VERSION_1_2,VK_KHR_buffer_device_address[]

include::{generated}/validity/structs/VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.txt[]
--
endif::VK_EXT_buffer_device_address[]

ifdef::VK_NV_dedicated_allocation_image_aliasing[]
[open,refpage='VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV',desc='Structure describing dedicated allocation image aliasing features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-dedicatedAllocationImageAliasing]]
    pname:dedicatedAllocationImageAliasing indicates that the implementation
    supports aliasing of compatible image objects on a dedicated allocation.

:refpage: VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.txt[]
--
endif::VK_NV_dedicated_allocation_image_aliasing[]

ifdef::VK_VERSION_1_2,VK_KHR_imageless_framebuffer[]
[open,refpage='VkPhysicalDeviceImagelessFramebufferFeatures',desc='Structure indicating support for imageless framebuffers',type='structs',alias='VkPhysicalDeviceImagelessFramebufferFeaturesKHR']
--
The sname:VkPhysicalDeviceImagelessFramebufferFeatures structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceImagelessFramebufferFeatures.txt[]

ifdef::VK_KHR_imageless_framebuffer[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceImagelessFramebufferFeaturesKHR.txt[]
endif::VK_KHR_imageless_framebuffer[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_imageless_framebuffer-features[]
  * [[{anchor-prefix}features-imagelessFramebuffer]]
    pname:imagelessFramebuffer indicates that the implementation supports
    specifying the image view for attachments at render pass begin time via
    slink:VkRenderPassAttachmentBeginInfo.
// end::VK_KHR_imageless_framebuffer-features[]

:refpage: VkPhysicalDeviceImagelessFramebufferFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceImagelessFramebufferFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_imageless_framebuffer[]

ifdef::VK_EXT_fragment_shader_interlock[]
[open,refpage='VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT',desc='Structure describing fragment shader interlock features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-fragmentShaderSampleInterlock]]
    pname:fragmentShaderSampleInterlock indicates that the implementation
    supports the code:FragmentShaderSampleInterlockEXT SPIR-V capability.
  * [[features-fragmentShaderPixelInterlock]]
    pname:fragmentShaderPixelInterlock indicates that the implementation
    supports the code:FragmentShaderPixelInterlockEXT SPIR-V capability.
  * [[features-fragmentShaderShadingRateInterlock]]
    pname:fragmentShaderShadingRateInterlock indicates that the
    implementation supports the code:FragmentShaderShadingRateInterlockEXT
    SPIR-V capability.

:refpage: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.txt[]
--
endif::VK_EXT_fragment_shader_interlock[]

ifdef::VK_NV_cooperative_matrix[]
[open,refpage='VkPhysicalDeviceCooperativeMatrixFeaturesNV',desc='Structure describing cooperative matrix features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCooperativeMatrixFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCooperativeMatrixFeaturesNV.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-cooperativeMatrix]] pname:cooperativeMatrix indicates that
    the implementation supports the code:CooperativeMatrixNV SPIR-V
    capability.
  * [[features-cooperativeMatrixRobustBufferAccess]]
    pname:cooperativeMatrixRobustBufferAccess indicates that the
    implementation supports robust buffer access for SPIR-V
    code:OpCooperativeMatrixLoadNV and code:OpCooperativeMatrixStoreNV
    instructions.

:refpage: VkPhysicalDeviceCooperativeMatrixFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCooperativeMatrixFeaturesNV.txt[]
--
endif::VK_NV_cooperative_matrix[]

ifdef::VK_EXT_ycbcr_image_arrays[]
[open,refpage='VkPhysicalDeviceYcbcrImageArraysFeaturesEXT',desc='Structure describing extended {YCbCr} image creation features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-ycbcrImageArrays]] pname:ycbcrImageArrays indicates that the
    implementation supports creating images with a format that requires
    <<formats-requiring-sampler-ycbcr-conversion, {YCbCr} conversion>> and
    has multiple array layers.

:refpage: VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.txt[]
--
endif::VK_EXT_ycbcr_image_arrays[]

ifdef::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]
[open,refpage='VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures',desc='Structure describing the extended types subgroups support feature for an implementation',type='structs',alias='VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR']
--
The sname:VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.txt[]

ifdef::VK_KHR_shader_subgroup_extended_types[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR.txt[]
endif::VK_KHR_shader_subgroup_extended_types[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_shader_subgroup_extended_types-features[]
  * [[{anchor-prefix}features-subgroup-extended-types]]
    pname:shaderSubgroupExtendedTypes is a boolean that specifies whether
    subgroup operations can use 8-bit integer, 16-bit integer, 64-bit
    integer, 16-bit floating-point, and vectors of these types in
    <<shaders-group-operations,group operations>> with
    <<shaders-scope-subgroup, subgroup scope>>, if the implementation
    supports the types.
// end::VK_KHR_shader_subgroup_extended_types-features[]

:refpage: VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_2,VK_EXT_host_query_reset[]
[open,refpage='VkPhysicalDeviceHostQueryResetFeatures',desc='Structure describing whether queries can be reset from the host',type='structs',alias='VkPhysicalDeviceHostQueryResetFeaturesEXT']
--
The sname:VkPhysicalDeviceHostQueryResetFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceHostQueryResetFeatures.txt[]

ifdef::VK_EXT_host_query_reset[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceHostQueryResetFeaturesEXT.txt[]
endif::VK_EXT_host_query_reset[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_EXT_host_query_reset-features[]
  * [[{anchor-prefix}features-hostQueryReset]] pname:hostQueryReset
    indicates that the implementation supports resetting queries from the
    host with flink:vkResetQueryPool.
// end::VK_EXT_host_query_reset-features[]

:refpage: VkPhysicalDeviceHostQueryResetFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceHostQueryResetFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_EXT_host_query_reset[]

ifdef::VK_INTEL_shader_integer_functions2[]
[open,refpage='VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL',desc='Structure describing shader integer functions that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderIntegerFunctions2]] pname:shaderIntegerFunctions2
    indicates that the implementation supports the
    code:IntegerFunctions2INTEL SPIR-V capability.

:refpage: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELfeatures.
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.txt[]
--
endif::VK_INTEL_shader_integer_functions2[]

ifdef::VK_NV_coverage_reduction_mode[]
[open,refpage='VkPhysicalDeviceCoverageReductionModeFeaturesNV',desc='Structure describing the coverage reduction mode features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCoverageReductionModeFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceCoverageReductionModeFeaturesNV.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-coverageReductionMode]] pname:coverageReductionMode indicates
    whether the implementation supports coverage reduction modes.
    See <<fragops-coverage-reduction, Coverage Reduction>>.

:refpage: VkPhysicalDeviceCoverageReductionModeFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCoverageReductionModeFeaturesNV.txt[]
--
endif::VK_NV_coverage_reduction_mode[]

ifdef::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]
[open,refpage='VkPhysicalDeviceTimelineSemaphoreFeatures',desc='Structure describing timeline semaphore features that can be supported by an implementation',type='structs',alias='VkPhysicalDeviceTimelineSemaphoreFeaturesKHR']
--
The sname:VkPhysicalDeviceTimelineSemaphoreFeatures structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceTimelineSemaphoreFeatures.txt[]

ifdef::VK_KHR_timeline_semaphore[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceTimelineSemaphoreFeaturesKHR.txt[]
endif::VK_KHR_timeline_semaphore[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_timeline_semaphore-features[]
  * [[{anchor-prefix}features-timelineSemaphore]] pname:timelineSemaphore
    indicates whether semaphores created with a elink:VkSemaphoreType of
    ename:VK_SEMAPHORE_TYPE_TIMELINE are supported.
// end::VK_KHR_timeline_semaphore-features[]

:refpage: VkPhysicalDeviceTimelineSemaphoreFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceTimelineSemaphoreFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]

ifdef::VK_EXT_index_type_uint8[]
[open,refpage='VkPhysicalDeviceIndexTypeUint8FeaturesEXT',desc='Structure describing whether uint8 index type can be used',type='structs']
--
The sname:VkPhysicalDeviceIndexTypeUint8FeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceIndexTypeUint8FeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-indexTypeUint8]] pname:indexTypeUint8 indicates that
    ename:VK_INDEX_TYPE_UINT8_EXT can be used with
    flink:vkCmdBindIndexBuffer.

:refpage: VkPhysicalDeviceIndexTypeUint8FeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceIndexTypeUint8FeaturesEXT.txt[]
--
endif::VK_EXT_index_type_uint8[]

ifdef::VK_EXT_primitive_topology_list_restart[]
[open,refpage='VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT',desc='Structure describing whether list type primitives can support primitive restart',type='structs']
--
The sname:VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT structure
is defined as:

include::{generated}/api/structs/VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.txt[]

The members of the
sname:VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT structure
describe the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-primitiveTopologyListRestart]]
    pname:primitiveTopologyListRestart indicates that list type primitives,
    ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY and
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY, can: use the
    primitive restart index value in index buffers.
  * [[features-primitiveTopologyPatchListRestart]]
    pname:primitiveTopologyPatchListRestart indicates that the
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST topology can: use the primitive
    restart index value in index buffers.

:refpage: VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.txt[]
--
endif::VK_EXT_primitive_topology_list_restart[]

ifdef::VK_NV_shader_sm_builtins[]
[open,refpage='VkPhysicalDeviceShaderSMBuiltinsFeaturesNV',desc='Structure describing the shader SM Builtins features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderSMBuiltinsFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderSMBuiltins]] pname:shaderSMBuiltins indicates whether
    the implementation supports the SPIR-V code:ShaderSMBuiltinsNV
    capability.

:refpage: VkPhysicalDeviceShaderSMBuiltinsFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.txt[]
--
endif::VK_NV_shader_sm_builtins[]

ifdef::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
[open,refpage='VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures',desc='Structure describing whether the implementation can do depth and stencil image barriers separately',type='structs',alias='VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR']
--
The sname:VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.txt[]

ifdef::VK_KHR_separate_depth_stencil_layouts[]
or the equivalent

include::{generated}/api/structs/VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.txt[]
endif::VK_KHR_separate_depth_stencil_layouts[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.

// Must have preceding whitespace
ifdef::VK_VERSION_1_2[:anchor-prefix: extension-]
ifndef::VK_VERSION_1_2[:anchor-prefix:]
// tag::VK_KHR_separate_depth_stencil_layouts-features[]
  * [[{anchor-prefix}features-separateDepthStencilLayouts]]
    pname:separateDepthStencilLayouts indicates whether the implementation
    supports a sname:VkImageMemoryBarrier for a depth/stencil image with
    only one of ename:VK_IMAGE_ASPECT_DEPTH_BIT or
    ename:VK_IMAGE_ASPECT_STENCIL_BIT set, and whether
    ename:VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
    ename:VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
    ename:VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or
    ename:VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL can be used.
// end::VK_KHR_separate_depth_stencil_layouts-features[]

:refpage: VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.txt[]
--
endif::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]

ifdef::VK_KHR_pipeline_executable_properties[]
[open,refpage='VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR',desc='Structure describing whether pipeline executable properties are available',type='structs']
--
The sname:VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR structure
is defined as:

include::{generated}/api/structs/VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-pipelineExecutableInfo]] pname:pipelineExecutableInfo
    indicates that the implementation supports reporting properties and
    statistics about the pipeline executables associated with a compiled
    pipeline.

:refpage: VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.txt[]
--
endif::VK_KHR_pipeline_executable_properties[]

ifdef::VK_EXT_shader_demote_to_helper_invocation[]
[open,refpage='VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT',desc='Structure describing the shader demote to helper invocations features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderDemoteToHelperInvocation]]
    pname:shaderDemoteToHelperInvocation indicates whether the
    implementation supports the SPIR-V code:DemoteToHelperInvocationEXT
    capability.

:refpage: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.txt[]
--
endif::VK_EXT_shader_demote_to_helper_invocation[]

ifdef::VK_EXT_texel_buffer_alignment[]
[open,refpage='VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT',desc='Structure describing the texel buffer alignment features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-texelBufferAlignment]] pname:texelBufferAlignment indicates
    whether the implementation uses more specific alignment requirements
    advertised in slink:VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT
    rather than
    slink:VkPhysicalDeviceLimits::pname:minTexelBufferOffsetAlignment.

:refpage: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.txt[]
--
endif::VK_EXT_texel_buffer_alignment[]

ifdef::VK_EXT_texture_compression_astc_hdr[]
[open,refpage='VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT',desc='Structure describing ASTC HDR features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-textureCompressionASTC_HDR]] pname:textureCompressionASTC_HDR
    indicates whether all of the ASTC HDR compressed texture formats are
    supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT
  ** ename:VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

:refpage: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.txt[]
--
endif::VK_EXT_texture_compression_astc_hdr[]

ifdef::VK_EXT_line_rasterization[]
[open,refpage='VkPhysicalDeviceLineRasterizationFeaturesEXT',desc='Structure describing the line rasterization features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceLineRasterizationFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceLineRasterizationFeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-rectangularLines]] pname:rectangularLines indicates whether
    the implementation supports <<primsrast-lines,rectangular line
    rasterization>>.
  * [[features-bresenhamLines]] pname:bresenhamLines indicates whether the
    implementation supports <<primsrast-lines-bresenham,Bresenham-style line
    rasterization>>.
  * [[features-smoothLines]] pname:smoothLines indicates whether the
    implementation supports <<primsrast-lines-smooth,smooth line
    rasterization>>.
  * [[features-stippledRectangularLines]] pname:stippledRectangularLines
    indicates whether the implementation supports
    <<primsrast-lines-stipple,stippled line rasterization>> with
    ename:VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT lines, or with
    ename:VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT lines if
    slink:VkPhysicalDeviceLimits::pname:strictLines is ename:VK_TRUE.
  * [[features-stippledBresenhamLines]] pname:stippledBresenhamLines
    indicates whether the implementation supports
    <<primsrast-lines-stipple,stippled line rasterization>> with
    ename:VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT lines.
  * [[features-stippledSmoothLines]] pname:stippledSmoothLines indicates
    whether the implementation supports <<primsrast-lines-stipple,stippled
    line rasterization>> with
    ename:VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT lines.

:refpage: VkPhysicalDeviceLineRasterizationFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceLineRasterizationFeaturesEXT.txt[]
--
endif::VK_EXT_line_rasterization[]

ifdef::VK_EXT_subgroup_size_control[]
[open,refpage='VkPhysicalDeviceSubgroupSizeControlFeaturesEXT',desc='Structure describing the subgroup size control features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-subgroupSizeControl]] pname:subgroupSizeControl indicates
    whether the implementation supports controlling shader subgroup sizes
    via the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT
    flag and the
    slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT structure.
  * [[features-computeFullSubgroups]] pname:computeFullSubgroups indicates
    whether the implementation supports requiring full subgroups in compute
    shaders via the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT
    flag.

:refpage: VkPhysicalDeviceSubgroupSizeControlFeaturesEXT
include::{chapters}/features.txt[tag=features]

[NOTE]
.Note
====
The sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT structure was added
in version 2 of the `apiext:VK_EXT_subgroup_size_control` extension.
Version 1 implementations of this extension will not fill out the features
structure but applications may assume that both pname:subgroupSizeControl
and pname:computeFullSubgroups are supported if the extension is supported.
(See also the <<features-requirements, Feature Requirements>> section.)
Applications are advised to add a
sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT structure to the
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features
regardless of the version of the extension supported by the implementation.
If the implementation only supports version 1, it will safely ignore the
sname:VkPhysicalDeviceSubgroupSizeControlFeaturesEXT structure.
====

include::{generated}/validity/structs/VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.txt[]
--
endif::VK_EXT_subgroup_size_control[]

ifdef::VK_AMD_device_coherent_memory[]
[open,refpage='VkPhysicalDeviceCoherentMemoryFeaturesAMD',desc='Structure describing whether device coherent memory can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCoherentMemoryFeaturesAMD structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceCoherentMemoryFeaturesAMD.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-deviceCoherentMemory]] pname:deviceCoherentMemory indicates
    that the implementation supports <<VkMemoryPropertyFlagBits,device
    coherent memory>>.

:refpage: VkPhysicalDeviceCoherentMemoryFeaturesAMD
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCoherentMemoryFeaturesAMD.txt[]
--
endif::VK_AMD_device_coherent_memory[]

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='VkPhysicalDeviceAccelerationStructureFeaturesKHR',desc='Structure describing the acceleration structure features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceAccelerationStructureFeaturesKHR.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-accelerationStructure]] pname:accelerationStructure indicates
    whether the implementation supports the acceleration structure
    functionality.
    See <<acceleration-structure,Acceleration Structures>>.
  * [[features-accelerationStructureCaptureReplay]]
    pname:accelerationStructureCaptureReplay indicates whether the
    implementation supports saving and reusing acceleration structure device
    addresses, e.g. for trace capture and replay.
  * [[features-accelerationStructureIndirectBuild]]
    pname:accelerationStructureIndirectBuild indicates whether the
    implementation supports indirect acceleration structure build commands,
    e.g. flink:vkCmdBuildAccelerationStructuresIndirectKHR.
  * [[features-accelerationStructureHostCommands]]
    pname:accelerationStructureHostCommands indicates whether the
    implementation supports host side acceleration structure commands, e.g.
    flink:vkBuildAccelerationStructuresKHR,
    flink:vkCopyAccelerationStructureKHR,
    flink:vkCopyAccelerationStructureToMemoryKHR,
    flink:vkCopyMemoryToAccelerationStructureKHR,
    flink:vkWriteAccelerationStructuresPropertiesKHR.
  * [[features-descriptorBindingAccelerationStructureUpdateAfterBind]]
    pname:descriptorBindingAccelerationStructureUpdateAfterBind indicates
    whether the implementation supports updating acceleration structure
    descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT must: not be used with
    ename:VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR.

:refpage: VkPhysicalDeviceAccelerationStructureFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceAccelerationStructureFeaturesKHR.txt[]
--
endif::VK_KHR_acceleration_structure[]

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='VkPhysicalDeviceRayTracingPipelineFeaturesKHR',desc='Structure describing the ray tracing features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRayTracingPipelineFeaturesKHR structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-rayTracingPipeline]] pname:rayTracingPipeline indicates
    whether the implementation supports the ray tracing pipeline
    functionality.
    See <<ray-tracing,Ray Tracing>>.
  * [[features-rayTracingPipelineShaderGroupHandleCaptureReplay]]
    pname:rayTracingPipelineShaderGroupHandleCaptureReplay indicates whether
    the implementation supports saving and reusing shader group handles,
    e.g. for trace capture and replay.
  * [[features-rayTracingPipelineShaderGroupHandleCaptureReplayMixed]]
    pname:rayTracingPipelineShaderGroupHandleCaptureReplayMixed indicates
    whether the implementation supports reuse of shader group handles being
    arbitrarily mixed with creation of non-reused shader group handles.
    If this is ename:VK_FALSE, all reused shader group handles must: be
    specified before any non-reused handles may: be created.
  * [[features-rayTracingPipelineTraceRaysIndirect]]
    pname:rayTracingPipelineTraceRaysIndirect indicates whether the
    implementation supports indirect ray tracing commands, e.g.
    flink:vkCmdTraceRaysIndirectKHR.
  * [[features-rayTraversalPrimitiveCulling]]
    pname:rayTraversalPrimitiveCulling indicates whether the implementation
    supports <<ray-traversal-culling-primitive, primitive culling during ray
    traversal>>.

:refpage: VkPhysicalDeviceRayTracingPipelineFeaturesKHR
include::{chapters}/features.txt[tag=features]

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceRayTracingPipelineFeaturesKHR-rayTracingPipelineShaderGroupHandleCaptureReplayMixed-03575]]
    If pname:rayTracingPipelineShaderGroupHandleCaptureReplayMixed is
    ename:VK_TRUE, pname:rayTracingPipelineShaderGroupHandleCaptureReplay
    must: also be ename:VK_TRUE
****

include::{generated}/validity/structs/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.txt[]
--
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_KHR_ray_query[]
[open,refpage='VkPhysicalDeviceRayQueryFeaturesKHR',desc='Structure describing the ray query features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRayQueryFeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceRayQueryFeaturesKHR.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-rayQuery]] pname:rayQuery indicates whether the
    implementation supports ray query (code:OpRayQueryProceedKHR)
    functionality.

:refpage: VkPhysicalDeviceRayQueryFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRayQueryFeaturesKHR.txt[]
--
endif::VK_KHR_ray_query[]

ifdef::VK_EXT_extended_dynamic_state[]
[open,refpage='VkPhysicalDeviceExtendedDynamicStateFeaturesEXT',desc='Structure describing what extended dynamic state can be used',type='structs']
--
The sname:VkPhysicalDeviceExtendedDynamicStateFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-extendedDynamicState]] pname:extendedDynamicState indicates
    that the implementation supports the following dynamic states:
  ** ename:VK_DYNAMIC_STATE_CULL_MODE_EXT
  ** ename:VK_DYNAMIC_STATE_FRONT_FACE_EXT
  ** ename:VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT
  ** ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT
  ** ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT
  ** ename:VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT
  ** ename:VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT
  ** ename:VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT
  ** ename:VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT
  ** ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT
  ** ename:VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT
  ** ename:VK_DYNAMIC_STATE_STENCIL_OP_EXT

:refpage: VkPhysicalDeviceExtendedDynamicStateFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.txt[]
--
endif::VK_EXT_extended_dynamic_state[]

ifdef::VK_EXT_extended_dynamic_state2[]
[open,refpage='VkPhysicalDeviceExtendedDynamicState2FeaturesEXT',desc='Structure describing what extended dynamic state can be used',type='structs']
--
The sname:VkPhysicalDeviceExtendedDynamicState2FeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-extendedDynamicState2]] pname:extendedDynamicState2 indicates
    that the implementation supports the following dynamic states:
  ** ename:VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT
  ** ename:VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT
  ** ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT
  * [[features-extendedDynamicState2LogicOp]]
    pname:extendedDynamicState2LogicOp indicates that the implementation
    supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_LOGIC_OP_EXT
  * [[features-extendedDynamicState2PatchControlPoints]]
    pname:extendedDynamicState2PatchControlPoints indicates that the
    implementation supports the following dynamic state:
  ** ename:VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT

:refpage: VkPhysicalDeviceExtendedDynamicState2FeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.txt[]
--
endif::VK_EXT_extended_dynamic_state2[]

ifdef::VK_NV_device_generated_commands[]
[open,refpage='VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV',desc='Structure describing the device-generated commands features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-deviceGeneratedCommands]] pname:deviceGeneratedCommands
    indicates whether the implementation supports functionality to generate
    commands on the device.
    See <<device-generated-commands,Device-Generated Commands>>.

:refpage: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.txt[]
--
endif::VK_NV_device_generated_commands[]

ifdef::VK_NV_device_diagnostics_config[]
[open,refpage='VkPhysicalDeviceDiagnosticsConfigFeaturesNV',desc='Structure describing the device-generated diagnostic configuration features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDiagnosticsConfigFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDiagnosticsConfigFeaturesNV.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-diagnosticsConfig]] pname:diagnosticsConfig indicates whether
    the implementation supports the ability to configure diagnostic tools.

:refpage: VkPhysicalDeviceDiagnosticsConfigFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDiagnosticsConfigFeaturesNV.txt[]
--
endif::VK_NV_device_diagnostics_config[]

ifdef::VK_EXT_device_memory_report[]
[open,refpage='VkPhysicalDeviceDeviceMemoryReportFeaturesEXT',desc='Structure describing whether device memory report callback can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDeviceMemoryReportFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-deviceMemoryReport]] pname:deviceMemoryReport indicates
    whether the implementation supports the ability to register device
    memory report callbacks.

:refpage: VkPhysicalDeviceDeviceMemoryReportFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.txt[]
--
endif::VK_EXT_device_memory_report[]

ifdef::VK_EXT_global_priority_query[]
[open,refpage='VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT',desc='Structure describing whether global priority query can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT
structure describe the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-globalPriorityQuery]] pname:globalPriorityQuery indicates
    whether the implementation supports the ability to query global queue
    priorities.

:refpage: VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT.txt[]
--
endif::VK_EXT_global_priority_query[]

ifdef::VK_EXT_pipeline_creation_cache_control[]
[open,refpage='VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT',desc='Structure describing whether pipeline cache control can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT structure
is defined as:

include::{generated}/api/structs/VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-pipelineCreationCacheControl]]
    pname:pipelineCreationCacheControl indicates that the implementation
    supports:
  ** The following can: be used in stext:Vk*PipelineCreateInfo::pname:flags:
  *** ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT
  *** ename:VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT
  ** The following can: be used in
     slink:VkPipelineCacheCreateInfo::pname:flags:
  *** ename:VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT

:refpage: VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.txt[]
--
endif::VK_EXT_pipeline_creation_cache_control[]

ifdef::VK_KHR_zero_initialize_workgroup_memory[]
[open,refpage='VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR',desc='Structure describing support for zero initialization of workgroup memory by an implementation',type='structs']
--
The sname:VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderZeroInitializeWorkgroupMemory]]
    pname:shaderZeroInitializeWorkgroupMemory specifies whether the
    implementation supports initializing a variable in Workgroup storage
    class.

:refpage: VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR.txt[]
--
endif::VK_KHR_zero_initialize_workgroup_memory[]

ifdef::VK_EXT_private_data[]
[open,refpage='VkPhysicalDevicePrivateDataFeaturesEXT',desc='Structure specifying physical device support',type='structs']
--

The sname:VkPhysicalDevicePrivateDataFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDevicePrivateDataFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-privateData]] pname:privateData indicates whether the
    implementation supports private data.
    See <<private-data, Private Data>>.

:refpage: VkPhysicalDevicePrivateDataFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePrivateDataFeaturesEXT.txt[]
--
endif::VK_EXT_private_data[]

ifdef::VK_KHR_shader_subgroup_uniform_control_flow[]
[open,refpage='VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR',desc='Structure describing support for shader subgroup uniform control flow by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderSubgroupUniformControlFlow]]
    pname:shaderSubgroupUniformControlFlow specifies whether the
    implementation supports the shader execution mode
    code:SubgroupUniformControlFlowKHR

:refpage: VkPhysicalDevicePrivateDataFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.txt[]
--
endif::VK_KHR_shader_subgroup_uniform_control_flow[]

ifdef::VK_EXT_robustness2[]
[open,refpage='VkPhysicalDeviceRobustness2FeaturesEXT',desc='Structure describing the out-of-bounds behavior for an implementation',type='structs']
--
The sname:VkPhysicalDeviceRobustness2FeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceRobustness2FeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-robustBufferAccess2]] pname:robustBufferAccess2 indicates
    whether buffer accesses are tightly bounds-checked against the range of
    the descriptor.
    Uniform buffers must: be bounds-checked to the range of the descriptor,
    where the range is rounded up to a multiple of
    <<limits-robustUniformBufferAccessSizeAlignment,robustUniformBufferAccessSizeAlignment>>.
    Storage buffers must: be bounds-checked to the range of the descriptor,
    where the range is rounded up to a multiple of
    <<limits-robustStorageBufferAccessSizeAlignment,robustStorageBufferAccessSizeAlignment>>.
    Out of bounds buffer loads will return zero values, and formatted loads
    will have [eq]#(0,0,1)# values inserted for missing G, B, or A
    components based on the format.
  * [[features-robustImageAccess2]] pname:robustImageAccess2 indicates
    whether image accesses are tightly bounds-checked against the dimensions
    of the image view.
    Out of bounds image loads will return zero values, with [eq]#(0,0,1)#
    values <<textures-conversion-to-rgba,inserted for missing G, B, or A
    components>> based on the format.
  * [[features-nullDescriptor]] pname:nullDescriptor indicates whether
    descriptors can: be written with a dlink:VK_NULL_HANDLE resource or
    view, which are considered valid to access and act as if the descriptor
    were bound to nothing.

:refpage: VkPhysicalDeviceRobustness2FeaturesEXT
include::{chapters}/features.txt[tag=features]

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceRobustness2FeaturesEXT-robustBufferAccess2-04000]]
    If pname:robustBufferAccess2 is enabled then
    <<features-robustBufferAccess, pname:robustBufferAccess>> must: also be
    enabled
****

include::{generated}/validity/structs/VkPhysicalDeviceRobustness2FeaturesEXT.txt[]
--
endif::VK_EXT_robustness2[]

ifndef::VK_EXT_robustness2[]
[[features-nullDescriptor]] nullDescriptor support requires the
`apiext:VK_EXT_robustness2` extension.
endif::VK_EXT_robustness2[]

ifdef::VK_EXT_image_robustness[]
[open,refpage='VkPhysicalDeviceImageRobustnessFeaturesEXT',desc='Structure describing the out-of-bounds behavior for an implementation',type='structs']
--
The sname:VkPhysicalDeviceImageRobustnessFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceImageRobustnessFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-robustImageAccess]] pname:robustImageAccess indicates whether
    image accesses are tightly bounds-checked against the dimensions of the
    image view.
    <<textures-input-validation,Invalid texels>> resulting from out of
    bounds image loads will be replaced as described in
    <<textures-texel-replacement,Texel Replacement>>, with either
    [eq]#(0,0,1)# or [eq]#(0,0,0)# values inserted for missing G, B, or A
    components based on the format.

:refpage: VkPhysicalDeviceImageRobustnessFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceImageRobustnessFeaturesEXT.txt[]
--
endif::VK_EXT_image_robustness[]

ifdef::VK_KHR_shader_terminate_invocation[]
[open,refpage='VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR',desc='Structure describing support for the SPIR-V code:SPV_KHR_terminate_invocation extension',type='structs']
--
The sname:VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderTerminateInvocation]] pname:shaderTerminateInvocation
    specifies whether the implementation supports SPIR-V modules that use
    the `SPV_KHR_terminate_invocation` extension.

:refpage: VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.txt[]
--
endif::VK_KHR_shader_terminate_invocation[]

ifdef::VK_EXT_custom_border_color[]
[open,refpage='VkPhysicalDeviceCustomBorderColorFeaturesEXT',desc='Structure describing whether custom border colors can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCustomBorderColorFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceCustomBorderColorFeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-customBorderColors]] pname:customBorderColors indicates that
    the implementation supports providing a pname:borderColor value with one
    of the following values at sampler creation time:
  ** ename:VK_BORDER_COLOR_FLOAT_CUSTOM_EXT
  ** ename:VK_BORDER_COLOR_INT_CUSTOM_EXT
  * [[features-customBorderColorWithoutFormat]]
    pname:customBorderColorWithoutFormat indicates that explicit formats are
    not required for custom border colors and the value of the pname:format
    member of the slink:VkSamplerCustomBorderColorCreateInfoEXT structure
    may: be ename:VK_FORMAT_UNDEFINED.
    If this feature bit is not set, applications must: provide the
    elink:VkFormat of the image view(s) being sampled by this sampler in the
    pname:format member of the slink:VkSamplerCustomBorderColorCreateInfoEXT
    structure.

:refpage: VkPhysicalDeviceCustomBorderColorFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceCustomBorderColorFeaturesEXT.txt[]
--
endif::VK_EXT_custom_border_color[]

ifdef::VK_EXT_border_color_swizzle[]
[open,refpage='VkPhysicalDeviceBorderColorSwizzleFeaturesEXT',desc='Structure describing whether samplers with custom border colors require the component swizzle specified in order to have defined behavior',type='structs']
--
The sname:VkPhysicalDeviceBorderColorSwizzleFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceBorderColorSwizzleFeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-borderColorSwizzle]] pname:borderColorSwizzle indicates that
    defined values are returned by sampled image operations when used with a
    sampler that uses a ename:VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
    ename:VK_BORDER_COLOR_INT_OPAQUE_BLACK,
    ename:VK_BORDER_COLOR_FLOAT_CUSTOM_EXT, or
    ename:VK_BORDER_COLOR_INT_CUSTOM_EXT pname:borderColor and an image view
    that uses a non-<<resources-image-views-identity-mappings,identity
    component mapping>>, when either pname:borderColorSwizzleFromImage is
    enabled or the slink:VkSamplerBorderColorComponentMappingCreateInfoEXT
    is specified.
  * [[features-borderColorSwizzleFromImage]]
    pname:borderColorSwizzleFromImage indicates that the implementation will
    return the correct border color values from sampled image operations
    under the conditions expressed above, without the application having to
    specify the border color component mapping when creating the sampler
    object.
    If this feature bit is not set, applications can: chain a
    slink:VkSamplerBorderColorComponentMappingCreateInfoEXT structure when
    creating samplers for use with image views that do not have an
    <<resources-image-views-identity-mappings,identity swizzle>> and, when
    those samplers are combined with image views using the same component
    mapping, sampled image operations that use opaque black or custom border
    colors will return the correct border color values.

:refpage: VkPhysicalDeviceBorderColorSwizzleFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceBorderColorSwizzleFeaturesEXT.txt[]
--
endif::VK_EXT_border_color_swizzle[]

ifdef::VK_KHR_portability_subset[]
[open,refpage='VkPhysicalDevicePortabilitySubsetFeaturesKHR',desc='Structure describing the features that may not be supported by an implementation of the Vulkan 1.0 Portability Subset',type='structs']
--
The sname:VkPhysicalDevicePortabilitySubsetFeaturesKHR structure is defined
as:

include::{generated}/api/structs/VkPhysicalDevicePortabilitySubsetFeaturesKHR.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-constantAlphaColorBlendFactors]]
    pname:constantAlphaColorBlendFactors indicates whether this
    implementation supports constant _alpha_ <<framebuffer-blendfactors>>
    used as source or destination _color_ <<framebuffer-blending>>.
  * [[features-events]] pname:events indicates whether this implementation
    supports synchronization using <<synchronization-events>>.
  * [[features-imageViewFormatReinterpretation]]
    pname:imageViewFormatReinterpretation indicates whether this
    implementation supports a sname:VkImageView being created with a texel
    format containing a different number of components, or a different
    number of bits in each component, than the texel format of the
    underlying sname:VkImage.
  * [[features-imageViewFormatSwizzle]] pname:imageViewFormatSwizzle
    indicates whether this implementation supports remapping format
    components using slink:VkImageViewCreateInfo::pname:components.
  * [[features-imageView2DOn3DImage]] pname:imageView2DOn3DImage indicates
    whether this implementation supports a sname:VkImage being created with
    the ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT flag set, permitting a
    2D or 2D array image view to be created on a 3D sname:VkImage.
  * [[features-multisampleArrayImage]] pname:multisampleArrayImage indicates
    whether this implementation supports a sname:VkImage being created as a
    2D array with multiple samples per texel.
  * [[features-mutableComparisonSamplers]] pname:mutableComparisonSamplers
    indicates whether this implementation allows descriptors with comparison
    samplers to be <<descriptorsets-updates, updated>>.
  * [[features-pointPolygons]] pname:pointPolygons indicates whether this
    implementation supports <<primsrast>> using a _point_
    <<primsrast-polygonmode>>.
  * [[features-samplerMipLodBias]] pname:samplerMipLodBias indicates whether
    this implementation supports setting a <<samplers-mipLodBias, mipmap LOD
    bias value>> when <<samplers, creating a sampler>>.
  * [[features-separateStencilMaskRef]] pname:separateStencilMaskRef
    indicates whether this implementation supports separate front and back
    <<fragops-stencil>> reference values.
  * [[features-shaderSampleRateInterpolationFunctions]]
    pname:shaderSampleRateInterpolationFunctions indicates whether this
    implementation supports fragment shaders which use the
    <<spirvenv-capabilities-table-InterpolationFunction,
    code:InterpolationFunction>> capability and the extended instructions
    `InterpolateAtCentroid`, `InterpolateAtOffset`, and
    `InterpolateAtSample` from the `GLSL.std.450` extended instruction set.
    This member is only meaningful if the
    <<features-sampleRateShading,sampleRateShading>> feature is supported.
  * [[features-tessellationIsolines]] pname:tessellationIsolines indicates
    whether this implementation supports
    <<tessellation-isoline-tessellation, isoline output>> from the
    <<tessellation>> stage of a graphics pipeline.
    This member is only meaningful if
    <<features-tessellationShader,tessellation shaders>> are supported.
  * [[features-tessellationPointMode]] pname:tessellationPointMode indicates
    whether this implementation supports <<tessellation-point-mode, point
    output>> from the <<tessellation>> stage of a graphics pipeline.
    This member is only meaningful if
    <<features-tessellationShader,tessellation shaders>> are supported.
  * [[features-triangleFans]] pname:triangleFans indicates whether this
    implementation supports <<drawing-triangle-fans>> primitive topology.
  * [[features-vertexAttributeAccessBeyondStride]]
    pname:vertexAttributeAccessBeyondStride indicates whether this
    implementation supports accessing a vertex input attribute beyond the
    stride of the corresponding vertex input binding.

:refpage: VkPhysicalDevicePortabilitySubsetFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePortabilitySubsetFeaturesKHR.txt[]
--
endif::VK_KHR_portability_subset[]

ifdef::VK_KHR_performance_query[]
include::VK_KHR_performance_query/features.txt[]
endif::VK_KHR_performance_query[]

ifdef::VK_EXT_4444_formats[]
[open,refpage='VkPhysicalDevice4444FormatsFeaturesEXT',desc='Structure describing additional 4444 formats supported by an implementation',type='structs']
--
The sname:VkPhysicalDevice4444FormatsFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDevice4444FormatsFeaturesEXT.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-formatA4R4G4B4]] pname:formatA4R4G4B4 indicates that the
    implementation must: support using a elink:VkFormat of
    ename:VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT with at least the following
    elink:VkFormatFeatureFlagBits:
  ** ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
  ** ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT
  ** ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
  * [[features-formatA4B4G4R4]] pname:formatA4B4G4R4 indicates that the
    implementation must: support using a elink:VkFormat of
    ename:VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT with at least the following
    elink:VkFormatFeatureFlagBits:
  ** ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
  ** ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT
  ** ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT

:refpage: VkPhysicalDevice4444FormatsFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDevice4444FormatsFeaturesEXT.txt[]
--
endif::VK_EXT_4444_formats[]

ifdef::VK_VALVE_mutable_descriptor_type[]
[open,refpage='VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE',desc='Structure describing whether the mutable descriptor type is supported',type='structs']
--
The sname:VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-mutableDescriptorType]] pname:mutableDescriptorType indicates
    that the implementation must: support using the elink:VkDescriptorType
    of ename:VK_DESCRIPTOR_TYPE_MUTABLE_VALVE with at least the following
    descriptor types, where any combination of the types must: be supported:
  ** ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE
  ** ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER

  * Additionally, pname:mutableDescriptorType indicates that:
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  ** Non-uniform descriptor indexing must: be supported if all descriptor
     types in a slink:VkMutableDescriptorTypeListVALVE for
     ename:VK_DESCRIPTOR_TYPE_MUTABLE_VALVE have the corresponding
     non-uniform indexing features enabled in
     slink:VkPhysicalDeviceDescriptorIndexingFeatures.
  ** ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT with
     pname:descriptorType of ename:VK_DESCRIPTOR_TYPE_MUTABLE_VALVE relaxes
     the list of required descriptor types to the descriptor types which
     have the corresponding update-after-bind feature enabled in
     slink:VkPhysicalDeviceDescriptorIndexingFeatures.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  ** Dynamically uniform descriptor indexing must: be supported if all
     descriptor types in a slink:VkMutableDescriptorTypeListVALVE for
     ename:VK_DESCRIPTOR_TYPE_MUTABLE_VALVE have the corresponding dynamic
     indexing features enabled.
  ** ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE must: be
     supported.
  ** ename:VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE must: be supported.

:refpage: VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE.txt[]
--
endif::VK_VALVE_mutable_descriptor_type[]

ifdef::VK_KHR_workgroup_memory_explicit_layout[]
[open,refpage='VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR',desc='Structure describing the workgroup storage explicit layout features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR structure
is defined as:

include::{generated}/api/structs/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-workgroupMemoryExplicitLayout]]
    pname:workgroupMemoryExplicitLayout indicates whether the implementation
    supports the SPIR-V code:WorkgroupMemoryExplicitLayoutKHR capability.
  * [[features-workgroupMemoryExplicitLayoutScalarBlockLayout]]
    pname:workgroupMemoryExplicitLayoutScalarBlockLayout indicates whether
    the implementation supports scalar alignment for laying out Workgroup
    Blocks.
  * [[features-workgroupMemoryExplicitLayout8BitAccess]]
    pname:workgroupMemoryExplicitLayout8BitAccess indicates whether objects
    in the code:Workgroup storage class with the code:Block decoration can:
    have 8-bit integer members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:WorkgroupMemoryExplicitLayout8BitAccessKHR capability.
  * [[features-workgroupMemoryExplicitLayout16BitAccess]]
    pname:workgroupMemoryExplicitLayout16BitAccess indicates whether objects
    in the code:Workgroup storage class with the code:Block decoration can:
    have 16-bit integer and 16-bit floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also indicates whether shader modules can: declare the
    code:WorkgroupMemoryExplicitLayout16BitAccessKHR capability.

:refpage: VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.txt[]
--
endif::VK_KHR_workgroup_memory_explicit_layout[]

ifdef::VK_KHR_synchronization2[]
[open,refpage='VkPhysicalDeviceSynchronization2FeaturesKHR',desc='Structure describing whether the implementation supports v2 synchronization commands',type='structs']
--
The sname:VkPhysicalDeviceSynchronization2FeaturesKHR structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceSynchronization2FeaturesKHR.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-synchronization2]] pname:synchronization2 indicates whether
    the implementation supports the new set of synchronization commands
    introduced in `apiext:VK_KHR_synchronization2`.

:refpage: VkPhysicalDeviceSynchronization2FeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceSynchronization2FeaturesKHR.txt[]
--
endif::VK_KHR_synchronization2[]

ifdef::VK_EXT_vertex_input_dynamic_state[]
[open,refpage='VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT',desc='Structure describing whether the dynamic vertex input state can be used',type='structs']
--
The sname:VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-vertexInputDynamicState]] pname:vertexInputDynamicState
    indicates that the implementation supports the following dynamic states:
  ** ename:VK_DYNAMIC_STATE_VERTEX_INPUT_EXT

:refpage: VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.txt[]
--
endif::VK_EXT_vertex_input_dynamic_state[]

ifdef::VK_KHR_fragment_shading_rate[]
[open,refpage='VkPhysicalDeviceFragmentShadingRateFeaturesKHR',desc='Structure indicating support for variable rate fragment shading',type='structs']
--
The sname:VkPhysicalDeviceFragmentShadingRateFeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-pipelineFragmentShadingRate]]
    pname:pipelineFragmentShadingRate indicates that the implementation
    supports the <<primsrast-fragment-shading-rate-pipeline, pipeline
    fragment shading rate>>.
  * [[features-primitiveFragmentShadingRate]]
    pname:primitiveFragmentShadingRate indicates that the implementation
    supports the <<primsrast-fragment-shading-rate-primitive, primitive
    fragment shading rate>>.
  * [[features-attachmentFragmentShadingRate]]
    pname:attachmentFragmentShadingRate indicates that the implementation
    supports the <<primsrast-fragment-shading-rate-attachment, attachment
    fragment shading rate>>.

:refpage: VkPhysicalDeviceFragmentShadingRateFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.txt[]
--
endif::VK_KHR_fragment_shading_rate[]

ifdef::VK_NV_fragment_shading_rate_enums[]
[open,refpage='VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV',desc='Structure indicating support for fragment shading rate enums',type='structs']
--
The sname:VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.txt[]

This structure describes the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-fragmentShadingRateEnums]] pname:fragmentShadingRateEnums
    indicates that the implementation supports specifying fragment shading
    rates using the ename:VkFragmentShadingRateNV enumerated type.
  * [[features-supersampleFragmentShadingRates]]
    pname:supersampleFragmentShadingRates indicates that the implementation
    supports fragment shading rate enum values indicating more than one
    invocation per fragment.
  * [[features-noInvocationFragmentShadingRates]]
    pname:noInvocationFragmentShadingRates indicates that the implementation
    supports a fragment shading rate enum value indicating that no fragment
    shaders should be invoked when that shading rate is used.

:refpage: VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.txt[]
--
endif::VK_NV_fragment_shading_rate_enums[]

ifdef::VK_NV_inherited_viewport_scissor[]
[open,refpage='VkPhysicalDeviceInheritedViewportScissorFeaturesNV',desc='Structure describing the viewport scissor inheritance behavior for an implementation',type='structs']
--
The sname:VkPhysicalDeviceInheritedViewportScissorFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceInheritedViewportScissorFeaturesNV.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
    * [[features-inheritedViewportScissor2D]]
      pname:inheritedViewportScissor2D indicates whether secondary command
      buffers can inherit most of the dynamic state affected by
ifdef::VK_EXT_extended_dynamic_state[]
      ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT,
      ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT,
endif::VK_EXT_extended_dynamic_state[]
ifdef::VK_EXT_discard_rectangles[]
      ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT,
endif::VK_EXT_discard_rectangles[]
      ename:VK_DYNAMIC_STATE_VIEWPORT or ename:VK_DYNAMIC_STATE_SCISSOR,
      from a primary command buffer.

:refpage: VkPhysicalDeviceInheritedViewportScissorFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceInheritedViewportScissorFeaturesNV.txt[]
--
endif::VK_NV_inherited_viewport_scissor[]

ifdef::VK_EXT_ycbcr_2plane_444_formats[]
[open,refpage='VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT',desc='Structure describing whether the implementation supports additional 2-plane 444 {YCbCr} formats',type='structs']
--
The sname:VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-ycbcr2plane444Formats]] pname:ycbcr2plane444Formats indicates
    that the implementation supports the following 2-plane 444 {YCbCr}
    formats:
    ** ename:VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT
    ** ename:VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT
    ** ename:VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT
    ** ename:VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT

:refpage: VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.txt[]
--
endif::VK_EXT_ycbcr_2plane_444_formats[]

ifdef::VK_EXT_color_write_enable[]
[open,refpage='VkPhysicalDeviceColorWriteEnableFeaturesEXT',desc='Structure describing whether writes to color attachments can be enabled and disabled dynamically',type='structs']
--
The sname:VkPhysicalDeviceColorWriteEnableFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceColorWriteEnableFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-colorWriteEnable]] pname:colorWriteEnable indicates that the
    implementation supports the dynamic state
    ename:VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT.

:refpage: VkPhysicalDeviceColorWriteEnableFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceColorWriteEnableFeaturesEXT.txt[]
--
endif::VK_EXT_color_write_enable[]

ifdef::VK_EXT_provoking_vertex[]
[open,refpage='VkPhysicalDeviceProvokingVertexFeaturesEXT',desc='Structure describing the provoking vertex features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceProvokingVertexFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceProvokingVertexFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-provokingVertexLast]] pname:provokingVertexLast indicates
    whether the implementation supports the
    ename:VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT
    <<VkProvokingVertexModeEXT,provoking vertex mode>> for flat shading.
  * [[features-transformFeedbackPreservesProvokingVertex]]
    pname:transformFeedbackPreservesProvokingVertex indicates that the order
    of vertices within each primitive written by transform feedback will
    preserve the provoking vertex.
    This does not apply to triangle fan primitives when
    <<limits-transformFeedbackPreservesTriangleFanProvokingVertex,pname:transformFeedbackPreservesTriangleFanProvokingVertex>>
    is ename:VK_FALSE.
    pname:transformFeedbackPreservesProvokingVertex must: be ename:VK_FALSE
    when the apiext:VK_EXT_transform_feedback extension is not supported.

:refpage: VkPhysicalDeviceProvokingVertexFeaturesEXT
include::{chapters}/features.txt[tag=features]

ifdef::VK_EXT_transform_feedback[]
When sname:VkPhysicalDeviceProvokingVertexFeaturesEXT is in the pname:pNext
chain of slink:VkDeviceCreateInfo but the
<<features-transformFeedback,transform feedback feature>> is not enabled,
the value of pname:transformFeedbackPreservesProvokingVertex is ignored.
endif::VK_EXT_transform_feedback[]

include::{generated}/validity/structs/VkPhysicalDeviceProvokingVertexFeaturesEXT.txt[]
--
endif::VK_EXT_provoking_vertex[]

ifdef::VK_EXT_pageable_device_local_memory[]
[open,refpage='VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT',desc='Structure describing whether the implementation supports pageable device-local memory',type='structs']
--
The sname:VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT structure is
defined as:

include::{generated}/api/structs/VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-pageableDeviceLocalMemory]] pname:pageableDeviceLocalMemory
    indicates that the implementation supports pageable device-local memory
    and may: transparently move device-local memory allocations to
    host-local memory to better share device-local memory with other
    applications.

:refpage: VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.txt[]
--
endif::VK_EXT_pageable_device_local_memory[]

ifdef::VK_EXT_multi_draw[]
[open,refpage='VkPhysicalDeviceMultiDrawFeaturesEXT',desc='Structure describing whether the implementation supports multi draw functionality',type='structs']
--
The sname:VkPhysicalDeviceMultiDrawFeaturesEXT structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMultiDrawFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceMultiDrawFeaturesEXT structure
describe the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-multiDraw]] pname:multiDraw indicates that the implementation
    supports flink:vkCmdDrawMultiEXT and flink:vkCmdDrawMultiIndexedEXT.

:refpage: VkPhysicalDeviceMultiDrawFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMultiDrawFeaturesEXT.txt[]
--
endif::VK_EXT_multi_draw[]

ifdef::VK_NV_ray_tracing_motion_blur[]
[open,refpage='VkPhysicalDeviceRayTracingMotionBlurFeaturesNV',desc='Structure describing the ray tracing motion blur features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRayTracingMotionBlurFeaturesNV structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-rayTracingMotionBlur]] pname:rayTracingMotionBlur indicates
    whether the implementation supports the motion blur feature.
  * [[features-rayTracingMotionBlurPipelineTraceRaysIndirect]]
    pname:rayTracingMotionBlurPipelineTraceRaysIndirect indicates whether
    the implementation supports indirect ray tracing commands with the
    motion blur feature enabled.

:refpage: VkPhysicalDeviceRayTracingMotionBlurFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.txt[]
--
endif::VK_NV_ray_tracing_motion_blur[]

ifdef::VK_HUAWEI_subpass_shading[]
[open,refpage='VkPhysicalDeviceSubpassShadingFeaturesHUAWEI',desc='Structure describing whether subpass shading is enabled',type='structs']
--
The sname:VkPhysicalDeviceSubpassShadingFeaturesHUAWEI structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.txt[]
  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-subpassShading]] pname:subpassShading specifies whether
    subpass shading is supported.

:refpage: VkPhysicalDeviceSubpassShadingFeaturesHUAWEI
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.txt[]
--
endif::VK_HUAWEI_subpass_shading[]

ifdef::VK_NV_external_memory_rdma[]
[open,refpage='VkPhysicalDeviceExternalMemoryRDMAFeaturesNV',desc='Structure describing the external memory RDMA features supported by the implementation',type='structs']
--
The sname:VkPhysicalDeviceExternalMemoryRDMAFeaturesNV structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-externalMemoryRDMA]] pname:externalMemoryRDMA indicates
    whether the implementation has support for the
    ename:VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV memory property and the
    ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV external memory
    handle type.

:refpage: VkPhysicalDeviceExternalMemoryRDMAFeaturesNV
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.txt[]
--
endif::VK_NV_external_memory_rdma[]

ifdef::VK_KHR_present_id[]
[open,refpage='VkPhysicalDevicePresentIdFeaturesKHR',desc='Structure indicating support for present id',type='structs']
--
The sname:VkPhysicalDevicePresentIdFeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDevicePresentIdFeaturesKHR.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-presentId]] pname:presentId indicates that the implementation
    supports specifying present ID values in the sname:VkPresentIdKHR
    extension to the sname:VkPresentInfoKHR struct.

:refpage: VkPhysicalDevicePresentIdFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePresentIdFeaturesKHR.txt[]
--
endif::VK_KHR_present_id[]

ifdef::VK_KHR_present_wait[]
[open,refpage='VkPhysicalDevicePresentWaitFeaturesKHR',desc='Structure indicating support for present wait',type='structs']
--
The sname:VkPhysicalDevicePresentWaitFeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDevicePresentWaitFeaturesKHR.txt[]

This structure describes the following feature:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-presentWait]] pname:presentWait indicates that the
    implementation supports fname:vkWaitForPresentKHR.

:refpage: VkPhysicalDevicePresentWaitFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDevicePresentWaitFeaturesKHR.txt[]
--
endif::VK_KHR_present_wait[]

ifdef::VK_KHR_shader_integer_dot_product[]
[open,refpage='VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR',desc='Structure describing integer dot product features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR structure is
defined as:

include::{generated}/api/structs/VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR.txt[]

The members of the sname:VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR
structure describe the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-shaderIntegerDotProduct]] pname:shaderIntegerDotProduct
    specifies whether shader modules can: declare the
    code:DotProductInputAllKHR, code:DotProductInput4x8BitKHR,
    code:DotProductInput4x8BitPackedKHR and code:DotProductKHR capabilities.

:refpage: VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR.txt[]
--
endif::VK_KHR_shader_integer_dot_product[]

ifdef::VK_EXT_rgba10x6_formats[]
[open,refpage='VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT',desc='Structure describing whether rendering to VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 formats can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT
structure describe the following features:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[features-formatRgba10x6WithoutYCbCrSampler]]
    pname:formatRgba10x6WithoutYCbCrSampler indicates that
    ename:VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 can: be used with a
    sname:VkImageView with pname:subresourceRange.aspectMask equal to
    ename:VK_IMAGE_ASPECT_COLOR_BIT without a <<samplers-YCbCr-conversion,
    sampler {YCbCr} conversion>> enabled.

:refpage: VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT.txt[]
--
endif::VK_EXT_rgba10x6_formats[]

ifdef::VK_KHR_maintenance4[]
[open,refpage='VkPhysicalDeviceMaintenance4FeaturesKHR',desc='Structure describing whether the implementation supports maintenance4 functionality',type='structs']
--
The sname:VkPhysicalDeviceMaintenance4FeaturesKHR structure is defined as:

include::{generated}/api/structs/VkPhysicalDeviceMaintenance4FeaturesKHR.txt[]

This structure describes the following features:

  * [[features-maintenance4]] pname:maintenance4 indicates that the
    implementation supports the following:
  ** The application may: destroy a slink:VkPipelineLayout object
     immediately after using it to create another object.
  ** code:LocalSizeId can: be used as an alternative to code:LocalSize to
     specify the local workgroup size with specialization constants.
  ** Images created with identical creation parameters will always have the
     same alignment requirements.
  ** The size memory requirement of a buffer or image is never greater than
     that of another buffer or image created with a greater or equal size.
  ** Push constants do not have to be initialized before they are
     dynamically accessed.
  ** The interface matching rules allow a larger output vector to match with
     a smaller input vector, with additional values being discarded.

:refpage: VkPhysicalDeviceMaintenance4FeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceMaintenance4FeaturesKHR.txt[]
--
endif::VK_KHR_maintenance4[]

ifdef::VK_KHR_dynamic_rendering[]
[open,refpage='VkPhysicalDeviceDynamicRenderingFeaturesKHR',desc='Structure indicating support for dynamic render pass instances',type='structs']
--
The sname:VkPhysicalDeviceDynamicRenderingFeaturesKHR structure is defined
as:

include::{generated}/api/structs/VkPhysicalDeviceDynamicRenderingFeaturesKHR.txt[]

The members of the sname:VkPhysicalDeviceDynamicRenderingFeaturesKHR
structure describe the following features:

  * [[features-dynamicRendering]] pname:dynamicRendering specifies that the
    implementation supports dynamic render pass instances using the
    flink:vkCmdBeginRenderingKHR command.

:refpage: VkPhysicalDeviceDynamicRenderingFeaturesKHR
include::{chapters}/features.txt[tag=features]

include::{generated}/validity/structs/VkPhysicalDeviceDynamicRenderingFeaturesKHR.txt[]
--
endif::VK_KHR_dynamic_rendering[]


[[features-requirements]]
== Feature Requirements

All Vulkan graphics implementations must: support the following features:

ifdef::VK_KHR_portability_subset[]
  * <<features-robustBufferAccess, pname:robustBufferAccess>>, unless the
    `apiext:VK_KHR_portability_subset` extension is enabled.
endif::VK_KHR_portability_subset[]
ifndef::VK_KHR_portability_subset[]
  * <<features-robustBufferAccess, pname:robustBufferAccess>>
endif::VK_KHR_portability_subset[]
ifdef::VK_VERSION_1_1[]
  * <<features-multiview, pname:multiview>>, if Vulkan 1.1 is supported.
ifdef::VK_KHR_shader_draw_parameters[]
  * <<features-shaderDrawParameters,pname:shaderDrawParameters>>, if the
    `apiext:VK_KHR_shader_draw_parameters` extension is supported.
endif::VK_KHR_shader_draw_parameters[]
endif::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_2,VK_KHR_uniform_buffer_standard_layout[]
  * <<features-uniformBufferStandardLayout,pname:uniformBufferStandardLayout>>,
    if Vulkan 1.2 or the `apiext:VK_KHR_uniform_buffer_standard_layout`
    extension is supported.
endif::VK_VERSION_1_2,VK_KHR_uniform_buffer_standard_layout[]
ifdef::VK_KHR_variable_pointers[]
  * <<features-variablePointersStorageBuffer,
    pname:variablePointersStorageBuffer>>, if the
    `apiext:VK_KHR_variable_pointers` extension is supported.
endif::VK_KHR_variable_pointers[]
ifdef::VK_KHR_8bit_storage[]
  * <<features-storageBuffer8BitAccess, pname:storageBuffer8BitAccess>>, if
    the `apiext:VK_KHR_8bit_storage` extension is supported.
endif::VK_KHR_8bit_storage[]
ifdef::VK_VERSION_1_2,VK_KHR_8bit_storage[]
  * <<features-storageBuffer8BitAccess, pname:StorageBuffer8BitAccess>>, if
    <<features-uniformAndStorageBuffer8BitAccess,
    pname:uniformAndStorageBuffer8BitAccess>> is enabled.
endif::VK_VERSION_1_2,VK_KHR_8bit_storage[]
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  * If
ifdef::VK_VERSION_1_2[the <<features-descriptorIndexing,descriptorIndexing>> feature is supported, or if]
    the `apiext:VK_EXT_descriptor_indexing` extension is supported:
  ** <<features-shaderSampledImageArrayDynamicIndexing,
     pname:shaderSampledImageArrayDynamicIndexing>>
  ** <<features-shaderStorageBufferArrayDynamicIndexing,
     pname:shaderStorageBufferArrayDynamicIndexing>>
  ** <<features-shaderUniformTexelBufferArrayDynamicIndexing,
     pname:shaderUniformTexelBufferArrayDynamicIndexing>>
  ** <<features-shaderStorageTexelBufferArrayDynamicIndexing,
     pname:shaderStorageTexelBufferArrayDynamicIndexing>>
  ** <<features-shaderSampledImageArrayNonUniformIndexing,
     pname:shaderSampledImageArrayNonUniformIndexing>>
  ** <<features-shaderStorageBufferArrayNonUniformIndexing,
     pname:shaderStorageBufferArrayNonUniformIndexing>>
  ** <<features-shaderUniformTexelBufferArrayNonUniformIndexing,
     pname:shaderUniformTexelBufferArrayNonUniformIndexing>>
  ** <<features-descriptorBindingSampledImageUpdateAfterBind,
     pname:descriptorBindingSampledImageUpdateAfterBind>>
  ** <<features-descriptorBindingStorageImageUpdateAfterBind,
     pname:descriptorBindingStorageImageUpdateAfterBind>>
  ** <<features-descriptorBindingStorageBufferUpdateAfterBind,
     pname:descriptorBindingStorageBufferUpdateAfterBind>> (see also
     <<limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-descriptorBindingUniformTexelBufferUpdateAfterBind,
     pname:descriptorBindingUniformTexelBufferUpdateAfterBind>> (see also
     <<limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-descriptorBindingStorageTexelBufferUpdateAfterBind,
     pname:descriptorBindingStorageTexelBufferUpdateAfterBind>> (see also
     <<limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-descriptorBindingUpdateUnusedWhilePending,
     pname:descriptorBindingUpdateUnusedWhilePending>>
  ** <<features-descriptorBindingPartiallyBound,
     pname:descriptorBindingPartiallyBound>>
  ** <<features-runtimeDescriptorArray, pname:runtimeDescriptorArray>>
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
ifdef::VK_EXT_inline_uniform_block[]
  * <<features-inlineUniformBlock,pname:inlineUniformBlock>>, if the
    `apiext:VK_EXT_inline_uniform_block` extension is supported.
ifdef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
  * <<features-descriptorBindingInlineUniformBlockUpdateAfterBind,
    pname:descriptorBindingInlineUniformBlockUpdateAfterBind>>, if the
    `apiext:VK_EXT_inline_uniform_block` extension is supported; and if
ifdef::VK_VERSION_1_2[the <<features-descriptorIndexing,pname:descriptorIndexing>> feature is supported, or]
    the `apiext:VK_EXT_descriptor_indexing` extension is supported.
endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[]
endif::VK_EXT_inline_uniform_block[]
ifdef::VK_EXT_scalar_block_layout[]
  * <<features-scalarBlockLayout,pname:scalarBlockLayout>>, if the
    `apiext:VK_EXT_scalar_block_layout` extension is supported.
endif::VK_EXT_scalar_block_layout[]
ifdef::VK_VERSION_1_2[]
  * <<features-subgroupBroadcastDynamicId,
    pname:subgroupBroadcastDynamicId>>, if Vulkan 1.2 is supported.
endif::VK_VERSION_1_2[]
ifdef::VK_VERSION_1_2+VK_KHR_sampler_mirror_clamp_to_edge[]
  * <<features-samplerMirrorClampToEdge, pname:samplerMirrorClampToEdge>>,
    if the `apiext:VK_KHR_sampler_mirror_clamp_to_edge` extension is
    supported.
endif::VK_VERSION_1_2+VK_KHR_sampler_mirror_clamp_to_edge[]
ifdef::VK_VERSION_1_2+VK_KHR_draw_indirect_count[]
  * <<features-drawIndirectCount, pname:drawIndirectCount>>, if the
    `apiext:VK_KHR_draw_indirect_count` extension is supported.
endif::VK_VERSION_1_2+VK_KHR_draw_indirect_count[]
ifdef::VK_VERSION_1_2+VK_EXT_sampler_filter_minmax[]
  * <<features-samplerFilterMinmax, pname:samplerFilterMinmax>>, if the
    `apiext:VK_EXT_sampler_filter_minmax` extension is supported.
endif::VK_VERSION_1_2+VK_EXT_sampler_filter_minmax[]
ifdef::VK_VERSION_1_2+VK_EXT_shader_viewport_index_layer[]
  * <<features-shaderOutputViewportIndex, pname:shaderOutputViewportIndex>>,
    if the `apiext:VK_EXT_shader_viewport_index_layer` extension is
    supported.
  * <<features-shaderOutputLayer, pname:shaderOutputLayer>>, if the
    `apiext:VK_EXT_shader_viewport_index_layer` extension is supported.
endif::VK_VERSION_1_2+VK_EXT_shader_viewport_index_layer[]
ifdef::VK_EXT_subgroup_size_control[]
  * <<features-subgroupSizeControl, pname:subgroupSizeControl>>, if the
    `apiext:VK_EXT_subgroup_size_control` extension is supported.
  * <<features-computeFullSubgroups, pname:computeFullSubgroups>>, if the
    `apiext:VK_EXT_subgroup_size_control` extension is supported.
endif::VK_EXT_subgroup_size_control[]
ifdef::VK_EXT_device_memory_report[]
  * <<features-deviceMemoryReport, pname:deviceMemoryReport>>, if the
    `apiext:VK_EXT_device_memory_report` extension is supported.
endif::VK_EXT_device_memory_report[]
ifdef::VK_EXT_global_priority_query[]
  * <<features-globalPriorityQuery, pname:globalPriorityQuery>>, if the
    `apiext:VK_EXT_global_priority_query` extension is supported.
endif::VK_EXT_global_priority_query[]
ifdef::VK_VERSION_1_2,VK_KHR_imageless_framebuffer[]
  * <<features-imagelessFramebuffer, pname:imagelessFramebuffer>>, if Vulkan
    1.2 or the `apiext:VK_KHR_imageless_framebuffer` extension is supported.
endif::VK_VERSION_1_2,VK_KHR_imageless_framebuffer[]
ifdef::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
  * <<features-separateDepthStencilLayouts,
    pname:separateDepthStencilLayouts>>, if Vulkan 1.2 or the
    `apiext:VK_KHR_separate_depth_stencil_layouts` extension is supported.
endif::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
ifdef::VK_VERSION_1_2,VK_EXT_host_query_reset[]
  * <<features-hostQueryReset, pname:hostQueryReset>>, if Vulkan 1.2 or the
    `apiext:VK_EXT_host_query_reset` extension is supported.
endif::VK_VERSION_1_2,VK_EXT_host_query_reset[]
ifdef::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]
  * <<features-timelineSemaphore, pname:timelineSemaphore>>, if Vulkan 1.2
    or the `apiext:VK_KHR_timeline_semaphore` extension is supported.
endif::VK_VERSION_1_2,VK_KHR_timeline_semaphore[]
ifdef::VK_KHR_acceleration_structure[]
  * If the `apiext:VK_KHR_acceleration_structure` extension is supported:
  ** <<features-accelerationStructure,pname:accelerationStructure>>
  ** All the features required by
ifdef::VK_VERSION_1_2[the <<features-descriptorIndexing,descriptorIndexing>> feature if Vulkan 1.2 is supported, or]
     the `apiext:VK_EXT_descriptor_indexing` extension.
  ** <<features-descriptorBindingAccelerationStructureUpdateAfterBind,
     pname:descriptorBindingAccelerationStructureUpdateAfterBind>>
  ** <<features-bufferDeviceAddress, pname:bufferDeviceAddress>> from
ifdef::VK_VERSION_1_2[Vulkan 1.2 or]
     the `apiext:VK_KHR_buffer_device_address` extension.
endif::VK_KHR_acceleration_structure[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * If the `apiext:VK_KHR_ray_tracing_pipeline` extension is supported:
  ** <<features-accelerationStructure,pname:accelerationStructure>> from
     `apiext:VK_KHR_acceleration_structure`
  ** <<features-rayTracingPipeline, pname:rayTracingPipeline>>
  ** <<features-rayTracingPipelineTraceRaysIndirect,
     pname:rayTracingPipelineTraceRaysIndirect>>
  ** <<features-rayTraversalPrimitiveCulling,
     pname:rayTraversalPrimitiveCulling>>, if <<features-rayQuery,
     pname:rayQuery>> is supported from `apiext:VK_KHR_ray_query`
  ** the `apiext:VK_KHR_pipeline_library` extension.
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_KHR_ray_query[]
  * If the `apiext:VK_KHR_ray_query` extension is supported:
  ** <<features-accelerationStructure,pname:accelerationStructure>> from
     `apiext:VK_KHR_acceleration_structure`
  ** <<features-rayQuery, pname:rayQuery>>
endif::VK_KHR_ray_query[]
ifdef::VK_EXT_pipeline_creation_cache_control[]
  * <<features-pipelineCreationCacheControl,
    pname:pipelineCreationCacheControl>>, if the
    `apiext:VK_EXT_pipeline_creation_cache_control` extension is supported.
endif::VK_EXT_pipeline_creation_cache_control[]
ifdef::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]
  * <<features-subgroup-extended-types, pname:shaderSubgroupExtendedTypes>>,
    if Vulkan 1.2 or the `apiext:VK_KHR_shader_subgroup_extended_types`
    extension is supported.
endif::VK_VERSION_1_2,VK_KHR_shader_subgroup_extended_types[]
ifdef::VK_KHR_sampler_ycbcr_conversion[]
  * <<features-samplerYcbcrConversion, pname:samplerYcbcrConversion>>, if
    the `apiext:VK_KHR_sampler_ycbcr_conversion` extension is supported.
endif::VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_KHR_pipeline_executable_properties[]
  * <<features-pipelineExecutableInfo, pname:pipelineExecutableInfo>>, if
    the `apiext:VK_KHR_pipeline_executable_properties` extension is
    supported.
endif::VK_KHR_pipeline_executable_properties[]
ifdef::VK_EXT_texture_compression_astc_hdr[]
  * <<features-textureCompressionASTC_HDR,
    pname:textureCompressionASTC_HDR>>, if the
    `apiext:VK_EXT_texture_compression_astc_hdr` extension is supported.
endif::VK_EXT_texture_compression_astc_hdr[]
ifdef::VK_EXT_depth_clip_enable[]
  * <<features-depthClipEnable, pname:depthClipEnable>>, if the
    `apiext:VK_EXT_depth_clip_enable` extension is supported.
endif::VK_EXT_depth_clip_enable[]
ifdef::VK_EXT_memory_priority[]
  * <<features-memoryPriority, pname:memoryPriority>>, if the
    `apiext:VK_EXT_memory_priority` extension is supported.
endif::VK_EXT_memory_priority[]
ifdef::VK_EXT_ycbcr_image_arrays[]
  * <<features-ycbcrImageArrays, pname:ycbcrImageArrays>>, if the
    `apiext:VK_EXT_ycbcr_image_arrays` extension is supported.
endif::VK_EXT_ycbcr_image_arrays[]
ifdef::VK_EXT_index_type_uint8[]
  * <<features-indexTypeUint8, pname:indexTypeUint8>>, if the
    `apiext:VK_EXT_index_type_uint8` extension is supported.
endif::VK_EXT_index_type_uint8[]
ifdef::VK_EXT_primitive_topology_list_restart[]
  * <<features-primitiveTopologyListRestart,
    pname:primitiveTopologyListRestart>>, if the
    `apiext:VK_EXT_primitive_topology_list_restart` extension is supported.
endif::VK_EXT_primitive_topology_list_restart[]
ifdef::VK_EXT_shader_demote_to_helper_invocation[]
  * <<features-shaderDemoteToHelperInvocation,
    pname:shaderDemoteToHelperInvocation>>, if the
    `apiext:VK_EXT_shader_demote_to_helper_invocation` extension is
    supported.
endif::VK_EXT_shader_demote_to_helper_invocation[]
ifdef::VK_EXT_texel_buffer_alignment[]
  * <<features-texelBufferAlignment, pname:texelBufferAlignment>>, if the
    `apiext:VK_EXT_texel_buffer_alignment` extension is supported.
endif::VK_EXT_texel_buffer_alignment[]
ifdef::VK_KHR_vulkan_memory_model[]
  * <<features-vulkanMemoryModel, pname:vulkanMemoryModel>>, if the
    `apiext:VK_KHR_vulkan_memory_model` extension is supported.
endif::VK_KHR_vulkan_memory_model[]
ifdef::VK_KHR_buffer_device_address[]
  * <<features-bufferDeviceAddress, pname:bufferDeviceAddress>>, if the
    `apiext:VK_KHR_buffer_device_address` extension is supported.
endif::VK_KHR_buffer_device_address[]
ifdef::VK_KHR_performance_query[]
  * <<VkPhysicalDevicePerformanceQueryFeaturesKHR,
    pname:performanceCounterQueryPools>>, if the
    `apiext:VK_KHR_performance_query` extension is supported.
endif::VK_KHR_performance_query[]
ifdef::VK_EXT_transform_feedback[]
  * <<features-transformFeedback, pname:transformFeedback>>, if the
    `apiext:VK_EXT_transform_feedback` extension is supported.
endif::VK_EXT_transform_feedback[]
ifdef::VK_EXT_conditional_rendering[]
  * <<features-conditionalRendering, pname:conditionalRendering>>, if the
    `apiext:VK_EXT_conditional_rendering` extension is supported.
endif::VK_EXT_conditional_rendering[]
ifdef::VK_EXT_vertex_attribute_divisor[]
  * <<features-vertexAttributeInstanceRateDivisor,
    pname:vertexAttributeInstanceRateDivisor>>, if the
    `apiext:VK_EXT_vertex_attribute_divisor` extension is supported.
endif::VK_EXT_vertex_attribute_divisor[]
ifdef::VK_EXT_fragment_density_map[]
  * <<features-fragmentDensityMap, pname:fragmentDensityMap>>, if the
    `apiext:VK_EXT_fragment_density_map` extension is supported.
endif::VK_EXT_fragment_density_map[]
ifdef::VK_KHR_shader_clock[]
  * <<features-shaderSubgroupClock, pname:shaderSubgroupClock>>, if the
    `apiext:VK_KHR_shader_clock` extension is supported.
endif::VK_KHR_shader_clock[]
ifdef::VK_KHR_shader_atomic_int64[]
  * <<features-shaderBufferInt64Atomics, pname:shaderBufferInt64Atomics>>,
    if the `apiext:VK_KHR_shader_atomic_int64` extension is supported.
endif::VK_KHR_shader_atomic_int64[]
ifdef::VK_VERSION_1_2,VK_KHR_shader_atomic_int64[]
  * <<features-shaderInt64, pname:shaderInt64>>, if the
    <<features-shaderSharedInt64Atomics, pname:shaderSharedInt64Atomics>> or
    <<features-shaderBufferInt64Atomics, pname:shaderBufferInt64Atomics>>
    features are supported.
endif::VK_VERSION_1_2,VK_KHR_shader_atomic_int64[]
ifdef::VK_KHR_shader_float16_int8[]
  * <<features-shaderFloat16, pname:shaderFloat16>> or
    <<features-shaderInt8, pname:shaderInt8>>, if the
    `apiext:VK_KHR_shader_float16_int8` extension is supported.
endif::VK_KHR_shader_float16_int8[]
ifdef::VK_EXT_fragment_shader_interlock[]
  * <<features-fragmentShaderSampleInterlock,
    pname:fragmentShaderSampleInterlock>> or
    <<features-fragmentShaderPixelInterlock,
    pname:fragmentShaderPixelInterlock>> or
    <<features-fragmentShaderShadingRateInterlock,
    pname:fragmentShaderShadingRateInterlock>>, if the
    `apiext:VK_EXT_fragment_shader_interlock` extension is supported.
endif::VK_EXT_fragment_shader_interlock[]
ifdef::VK_EXT_line_rasterization[]
  * <<features-rectangularLines, pname:rectangularLines>> or
    <<features-bresenhamLines, pname:bresenhamLines>> or
    <<features-smoothLines, pname:smoothLines>> or
    <<features-stippledRectangularLines, pname:stippledRectangularLines>> or
    <<features-stippledBresenhamLines, pname:stippledBresenhamLines>> or
    <<features-stippledSmoothLines, pname:stippledSmoothLines>>, if the
    `apiext:VK_EXT_line_rasterization` extension is supported.
endif::VK_EXT_line_rasterization[]
ifdef::VK_KHR_16bit_storage[]
  * <<features-storageBuffer16BitAccess, pname:storageBuffer16BitAccess>>,
    if the `apiext:VK_KHR_16bit_storage` extension is supported.
endif::VK_KHR_16bit_storage[]
ifdef::VK_VERSION_1_1,VK_KHR_16bit_storage[]
  * <<features-storageBuffer16BitAccess, pname:storageBuffer16BitAccess>>,
    if <<features-uniformAndStorageBuffer16BitAccess,
    pname:uniformAndStorageBuffer16BitAccess>> is enabled.
endif::VK_VERSION_1_1,VK_KHR_16bit_storage[]
ifdef::VK_EXT_image_robustness[]
  * <<features-robustImageAccess, pname:robustImageAccess>>, if the
    `apiext:VK_EXT_image_robustness` extension is supported.
endif::VK_EXT_image_robustness[]
ifdef::VK_EXT_4444_formats[]
  * <<features-formatA4R4G4B4, pname:formatA4R4G4B4>>, if the
    `apiext:VK_EXT_4444_formats` extension is supported.
endif::VK_EXT_4444_formats[]
ifdef::VK_VALVE_mutable_descriptor_type[]
  * <<features-mutableDescriptorType, pname:mutableDescriptorType>>, if the
    `apiext:VK_VALVE_mutable_descriptor_type` extension is supported.
endif::VK_VALVE_mutable_descriptor_type[]
ifdef::VK_EXT_shader_image_atomic_int64[]
  * <<features-shaderInt64, pname:shaderInt64>> and
    <<features-shaderImageInt64Atomics, pname:shaderImageInt64Atomics>>, if
    the `apiext:VK_EXT_shader_image_atomic_int64` extension is supported.
  * <<features-shaderImageInt64Atomics, pname:shaderImageInt64Atomics>>, if
    the <<features-sparseImageInt64Atomics, pname:sparseImageInt64Atomics>>
    feature is supported.
endif::VK_EXT_shader_image_atomic_int64[]
ifdef::VK_EXT_shader_atomic_float[]
  * <<features-shaderImageFloat32Atomics, pname:shaderImageFloat32Atomics>>,
    if the <<features-sparseImageFloat32Atomics,
    pname:sparseImageFloat32Atomics>> feature is supported.
  * <<features-shaderImageFloat32AtomicAdd,
    pname:shaderImageFloat32AtomicAdd>>, if the
    <<features-sparseImageFloat32AtomicAdd,
    pname:sparseImageFloat32AtomicAdd>> feature is supported.
endif::VK_EXT_shader_atomic_float[]
ifdef::VK_KHR_fragment_shading_rate[]
  * <<features-pipelineFragmentShadingRate,
    pname:pipelineFragmentShadingRate>>, if the
    `apiext:VK_KHR_fragment_shading_rate` extension is supported.
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_KHR_shader_terminate_invocation[]
  * <<features-shaderTerminateInvocation, pname:shaderTerminateInvocation>>
    if the `apiext:VK_KHR_shader_terminate_invocation` extension is
    supported.
endif::VK_KHR_shader_terminate_invocation[]
ifdef::VK_KHR_zero_initialize_workgroup_memory[]
  * <<features-shaderZeroInitializeWorkgroupMemory,
    pname:shaderZeroInitializeWorkgroupMem>>, if the
    `apiext:VK_KHR_zero_initialize_workgroup_memory` extension is supported.
endif::VK_KHR_zero_initialize_workgroup_memory[]
ifdef::VK_KHR_workgroup_memory_explicit_layout[]
  * <<features-workgroupMemoryExplicitLayout,
    pname:workgroupMemoryExplicitLayout>>, if the
    `apiext:VK_KHR_workgroup_memory_explicit_layout` extension is supported.
endif::VK_KHR_workgroup_memory_explicit_layout[]
ifdef::VK_EXT_vertex_input_dynamic_state[]
  * <<features-vertexInputDynamicState, pname:vertexInputDynamicState>>, if
    the `apiext:VK_EXT_vertex_input_dynamic_state` extension is supported.
endif::VK_EXT_vertex_input_dynamic_state[]
ifdef::VK_KHR_synchronization2[]
  * <<features-synchronization2, pname:synchronization2>> if the
    `apiext:VK_KHR_synchronization2` extension is supported.
endif::VK_KHR_synchronization2[]
ifdef::VK_EXT_provoking_vertex[]
  * <<features-provokingVertexLast, pname:provokingVertexLast>>, if the
    `apiext:VK_EXT_provoking_vertex` extension is supported.
endif::VK_EXT_provoking_vertex[]
ifdef::VK_KHR_shader_subgroup_uniform_control_flow[]
  * <<features-shaderSubgroupUniformControlFlow,
    pname:shaderSubgroupUniformControlFlow>>, if the
    `apiext:VK_KHR_shader_subgroup_uniform_control_flow` extension is
    supported.
endif::VK_KHR_shader_subgroup_uniform_control_flow[]
ifdef::VK_EXT_border_color_swizzle[]
  * <<features-borderColorSwizzle, pname:borderColorSwizzle>> if the
    apiext:VK_EXT_border_color_swizzle extension is supported.
endif::VK_EXT_border_color_swizzle[]
ifdef::VK_EXT_multi_draw[]
  * <<features-multiDraw, pname:multiDraw>>, if the
    `apiext:VK_EXT_multi_draw` extension is supported.
endif::VK_EXT_multi_draw[]
ifdef::VK_EXT_shader_atomic_float2[]
  * <<features-shaderImageFloat32AtomicMinMax,
    pname:shaderImageFloat32AtomicMinMax>>, if the
    <<features-sparseImageFloat32AtomicMinMax,
    pname:sparseImageFloat32AtomicMinMax>> feature is supported.
endif::VK_EXT_shader_atomic_float2[]
ifdef::VK_KHR_present_id[]
  * <<features-presentId, pname:presentId>>, if the
    `apiext:VK_KHR_present_id` extension is supported.
endif::VK_KHR_present_id[]
ifdef::VK_KHR_present_wait[]
  * <<features-presentWait, pname:presentWait>>, if the
    `apiext:VK_KHR_present_wait` extension is supported.
endif::VK_KHR_present_wait[]
ifdef::VK_KHR_shader_integer_dot_product[]
  * <<features-shaderIntegerDotProduct, pname:shaderIntegerDotProduct>> if
    the `apiext:VK_KHR_shader_integer_dot_product` extension is supported.
endif::VK_KHR_shader_integer_dot_product[]
ifdef::VK_KHR_maintenance4[]
  * <<features-maintenance4, pname:maintenance4>>, if the
    `apiext:VK_KHR_maintenance4` extension is supported.
endif::VK_KHR_maintenance4[]

All other features defined in the Specification are optional:.
