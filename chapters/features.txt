// Copyright (c) 2015-2018 Khronos Group. This work is licensed under a
// Creative Commons Attribution 4.0 International License; see
// http://creativecommons.org/licenses/by/4.0/

[[features]]
= Features, Limits, and Formats

Vulkan is designed to support a wide variety of implementations, and as such
there are a number of features, limits, and formats which are not supported
on all implementations.
Features describe functionality which is optional: and which must: be
explicitly enabled before use.
Limits describe implementation-dependent minimums, maximums, and other
device characteristics that an application may: need to be aware of.
Supported buffer and image formats may: vary across implementations.
A minimum set of format features are guaranteed, but others must: be
explicitly queried before use to ensure they are supported by the
implementation.

[NOTE]
.Note
====
The features and limits are reported via basic structures (that is
slink:VkPhysicalDeviceFeatures and slink:VkPhysicalDeviceLimits), as well as
extensible structures (sname:VkPhysicalDeviceFeatures2 and
sname:VkPhysicalDeviceProperties2) which were added in
`<<VK_KHR_get_physical_device_properties2>>` and included in Vulkan 1.1.
When new features or limits are added in future Vulkan version or
extensions, each extension should: introduce one new feature structure
and/or limit structure (as needed).
These structures can: be added to the pname:pNext chain of the
sname:VkPhysicalDeviceFeatures2 and sname:VkPhysicalDeviceProperties2
structures, respectively.
====

[[features-features]]
== Features

The Specification defines a set of optional: features that may: be supported
by a Vulkan implementation.
Support for features is reported and enabled on a per-feature basis.
Features are properties of the physical device.

[open,refpage='vkGetPhysicalDeviceFeatures',desc='Reports capabilities of a physical device',type='protos']
--

To query supported features, call:

include::../api/protos/vkGetPhysicalDeviceFeatures.txt[]

  * pname:physicalDevice is the physical device from which to query the
    supported features.
  * pname:pFeatures is a pointer to a slink:VkPhysicalDeviceFeatures
    structure in which the physical device features are returned.
    For each feature, a value of ename:VK_TRUE specifies that the feature is
    supported on this physical device, and ename:VK_FALSE specifies that the
    feature is not supported.

include::../validity/protos/vkGetPhysicalDeviceFeatures.txt[]
--

Fine-grained features used by a logical device must: be enabled at
sname:VkDevice creation time.
If a feature is enabled that the physical device does not support,
sname:VkDevice creation will fail.
If an application uses a feature without enabling it at sname:VkDevice
creation time, the device behavior is undefined.
The validation layer will warn if features are used without being enabled.

The fine-grained features are enabled by passing a pointer to the
sname:VkPhysicalDeviceFeatures structure via the pname:pEnabledFeatures
member of the sname:VkDeviceCreateInfo structure that is passed into the
fname:vkCreateDevice call.
If a member of pname:pEnabledFeatures is set to ename:VK_TRUE or
ename:VK_FALSE, then the device will be created with the indicated feature
enabled or disabled, respectively.
ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
Features can: also be enabled by using the slink:VkPhysicalDeviceFeatures2
structure.
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

If an application wishes to enable all features supported by a device, it
can: simply pass in the sname:VkPhysicalDeviceFeatures structure that was
previously returned by fname:vkGetPhysicalDeviceFeatures.
To disable an individual feature, the application can: set the desired
member to ename:VK_FALSE in the same structure.
Setting pname:pEnabledFeatures to `NULL`
ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
and not including a slink:VkPhysicalDeviceFeatures2 in the pname:pNext
member of slink:VkDeviceCreateInfo
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
is equivalent to setting all members of the structure to ename:VK_FALSE.

[NOTE]
.Note
====
Some features, such as pname:robustBufferAccess, may: incur a run-time
performance cost.
Application writers should: carefully consider the implications of enabling
all supported features.
====

ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

[open,refpage='vkGetPhysicalDeviceFeatures2',desc='Reports capabilities of a physical device',type='protos']
--

To query supported features defined by the core or extensions, call:

ifdef::VK_VERSION_1_1[]
include::../api/protos/vkGetPhysicalDeviceFeatures2.txt[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_get_physical_device_properties2[or the equivalent command]

ifdef::VK_KHR_get_physical_device_properties2[]
include::../api/protos/vkGetPhysicalDeviceFeatures2KHR.txt[]
endif::VK_KHR_get_physical_device_properties2[]

  * pname:physicalDevice is the physical device from which to query the
    supported features.
  * pname:pFeatures is a pointer to a slink:VkPhysicalDeviceFeatures2
    structure in which the physical device features are returned.

Each structure in pname:pFeatures and its pname:pNext chain contain members
corresponding to fine-grained features.
fname:vkGetPhysicalDeviceFeatures2 writes each member to a boolean value
indicating whether that feature is supported.

include::../validity/protos/vkGetPhysicalDeviceFeatures2.txt[]
--

[open,refpage='VkPhysicalDeviceFeatures2',desc='Structure describing the fine-grained features that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceFeatures2 structure is defined as:

include::../api/structs/VkPhysicalDeviceFeatures2.txt[]

ifdef::VK_KHR_get_physical_device_properties2[]
or the equivalent

include::../api/structs/VkPhysicalDeviceFeatures2KHR.txt[]
endif::VK_KHR_get_physical_device_properties2[]

The sname:VkPhysicalDeviceFeatures2 structure is defined as:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:features is a structure of type slink:VkPhysicalDeviceFeatures
    describing the fine-grained features of the Vulkan 1.0 API.

The pname:pNext chain of this structure is used to extend the structure with
features defined by extensions.
This structure can: be used in flink:vkGetPhysicalDeviceFeatures2 or can: be
in the pname:pNext chain of a slink:VkDeviceCreateInfo structure, in which
case it controls which features are enabled in the device in lieu of
pname:pEnabledFeatures.

include::../validity/structs/VkPhysicalDeviceFeatures2.txt[]
--

endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

[open,refpage='VkPhysicalDeviceFeatures',desc='Structure describing the fine-grained features that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceFeatures structure is defined as:

include::../api/structs/VkPhysicalDeviceFeatures.txt[]

The members of the sname:VkPhysicalDeviceFeatures structure describe the
following features:

  * [[features-features-robustBufferAccess]] pname:robustBufferAccess
    specifies that accesses to buffers are bounds-checked against the range
    of the buffer descriptor (as determined by
    sname:VkDescriptorBufferInfo::pname:range,
    sname:VkBufferViewCreateInfo::pname:range, or the size of the buffer).
    Out of bounds accesses must: not cause application termination, and the
    effects of shader loads, stores, and atomics must: conform to an
    implementation-dependent behavior as described below.
  ** A buffer access is considered to be out of bounds if any of the
     following are true:
  *** The pointer was formed by code:OpImageTexelPointer and the coordinate
      is less than zero or greater than or equal to the number of whole
      elements in the bound range.
  *** The pointer was not formed by code:OpImageTexelPointer and the object
      pointed to is not wholly contained within the bound range.
ifdef::VK_VERSION_1_1,VK_KHR_variable_pointers[]
      This includes accesses performed via _variable pointers_ where the
      buffer descriptor being accessed cannot be statically determined.
      Uninitialized pointers and pointers equal to code:OpConstantNull are
      treated as pointing to a zero-sized object, so all accesses through
      such pointers are considered to be out of bounds.
endif::VK_VERSION_1_1,VK_KHR_variable_pointers[]
+
[NOTE]
.Note
====
If a SPIR-V code:OpLoad instruction loads a structure and the tail end of
the structure is out of bounds, then all members of the structure are
considered out of bounds even if the members at the end are not statically
used.
====

  *** If any buffer access in a given SPIR-V block is determined to be out
      of bounds, then any other access of the same type (load, store, or
      atomic) in the same SPIR-V block that accesses an address less than 16
      bytes away from the out of bounds address may: also be considered out
      of bounds.
  ** Out-of-bounds buffer loads will return any of the following values:
  *** Values from anywhere within the memory range(s) bound to the buffer
      (possibly including bytes of memory past the end of the buffer, up to
      the end of the bound range).
  *** Zero values, or [eq]#(0,0,0,x)# vectors for vector reads where x is a
      valid value represented in the type of the vector components and may:
      be any of:
  **** 0, 1, or the maximum representable positive integer value, for signed
       or unsigned integer components
  **** 0.0 or 1.0, for floating-point components
  ** Out-of-bounds writes may: modify values within the memory range(s)
     bound to the buffer, but must: not modify any other memory.
  ** Out-of-bounds atomics may: modify values within the memory range(s)
     bound to the buffer, but must: not modify any other memory, and return
     an undefined value.
  ** Vertex input attributes are considered out of bounds if the offset of
     the attribute in the bound vertex buffer range plus the size of the
     attribute is greater than either:
+
  *** code:vertexBufferRangeSize, if [eq]#code:bindingStride == 0#; or
  *** [eq]#(code:vertexBufferRangeSize - (code:vertexBufferRangeSize %
      code:bindingStride))#
+
where code:vertexBufferRangeSize is the byte size of the memory range bound
to the vertex buffer binding and code:bindingStride is the byte stride of
the corresponding vertex input binding.
Further, if any vertex input attribute using a specific vertex input binding
is out of bounds, then all vertex input attributes using that vertex input
binding for that vertex shader invocation are considered out of bounds.
  *** If a vertex input attribute is out of bounds, it will be assigned one
      of the following values:
  **** Values from anywhere within the memory range(s) bound to the buffer,
     converted according to the format of the attribute.
  **** Zero values, format converted according to the format of the
       attribute.
  **** Zero values, or [eq]#(0,0,0,x)# vectors, as described above.
  ** If pname:robustBufferAccess is not enabled, out of bounds accesses may:
     corrupt any memory within the process and cause undefined behavior up
     to and including application termination.
  * [[features-features-fullDrawIndexUint32]] pname:fullDrawIndexUint32
    specifies the full 32-bit range of indices is supported for indexed draw
    calls when using a elink:VkIndexType of ename:VK_INDEX_TYPE_UINT32.
    pname:maxDrawIndexedIndexValue is the maximum index value that may: be
    used (aside from the primitive restart index, which is always 2^32^-1
    when the elink:VkIndexType is ename:VK_INDEX_TYPE_UINT32).
    If this feature is supported, pname:maxDrawIndexedIndexValue must: be
    2^32^-1; otherwise it must: be no smaller than 2^24^-1.
    See
    <<features-limits-maxDrawIndexedIndexValue,maxDrawIndexedIndexValue>>.
  * [[features-features-imageCubeArray]] pname:imageCubeArray specifies
    whether image views with a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY can: be created, and that the
    corresponding code:SampledCubeArray and code:ImageCubeArray SPIR-V
    capabilities can: be used in shader code.
  * [[features-features-independentBlend]] pname:independentBlend specifies
    whether the sname:VkPipelineColorBlendAttachmentState settings are
    controlled independently per-attachment.
    If this feature is not enabled, the
    sname:VkPipelineColorBlendAttachmentState settings for all color
    attachments must: be identical.
    Otherwise, a different sname:VkPipelineColorBlendAttachmentState can: be
    provided for each bound color attachment.
  * [[features-features-geometryShader]] pname:geometryShader specifies
    whether geometry shaders are supported.
    If this feature is not enabled, the ename:VK_SHADER_STAGE_GEOMETRY_BIT
    and ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT enum values must: not be
    used.
    This also specifies whether shader modules can: declare the
    code:Geometry capability.
  * [[features-features-tessellationShader]] pname:tessellationShader
    specifies whether tessellation control and evaluation shaders are
    supported.
    If this feature is not enabled, the
    ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, and
    ename:VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO enum
    values must: not be used.
    This also specifies whether shader modules can: declare the
    code:Tessellation capability.
  * [[features-features-sampleRateShading]] pname:sampleRateShading
    specifies whether <<primsrast-sampleshading,Sample Shading>> and
    multisample interpolation are supported.
    If this feature is not enabled, the pname:sampleShadingEnable member of
    the sname:VkPipelineMultisampleStateCreateInfo structure must: be set to
    ename:VK_FALSE and the pname:minSampleShading member is ignored.
    This also specifies whether shader modules can: declare the
    code:SampleRateShading capability.
  * [[features-features-dualSrcBlend]] pname:dualSrcBlend specifies whether
    blend operations which take two sources are supported.
    If this feature is not enabled, the ename:VK_BLEND_FACTOR_SRC1_COLOR,
    ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
    ename:VK_BLEND_FACTOR_SRC1_ALPHA, and
    ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA enum values must: not be used
    as source or destination blending factors.
    See <<framebuffer-dsb>>.
  * [[features-features-logicOp]] pname:logicOp specifies whether logic
    operations are supported.
    If this feature is not enabled, the pname:logicOpEnable member of the
    sname:VkPipelineColorBlendStateCreateInfo structure must: be set to
    ename:VK_FALSE, and the pname:logicOp member is ignored.
  * [[features-features-multiDrawIndirect]] pname:multiDrawIndirect
    specifies whether multiple draw indirect is supported.
    If this feature is not enabled, the pname:drawCount parameter to the
    fname:vkCmdDrawIndirect and fname:vkCmdDrawIndexedIndirect commands
    must: be 0 or 1.
    The pname:maxDrawIndirectCount member of the
    sname:VkPhysicalDeviceLimits structure must: also be 1 if this feature
    is not supported.
    See <<features-limits-maxDrawIndirectCount,maxDrawIndirectCount>>.
  * [[features-features-drawIndirectFirstInstance]]
    pname:drawIndirectFirstInstance specifies whether indirect draw calls
    support the pname:firstInstance parameter.
    If this feature is not enabled, the pname:firstInstance member of all
    sname:VkDrawIndirectCommand and sname:VkDrawIndexedIndirectCommand
    structures that are provided to the fname:vkCmdDrawIndirect and
    fname:vkCmdDrawIndexedIndirect commands must: be 0.
  * [[features-features-depthClamp]] pname:depthClamp specifies whether
    depth clamping is supported.
    If this feature is not enabled, the pname:depthClampEnable member of the
    sname:VkPipelineRasterizationStateCreateInfo structure must: be set to
    ename:VK_FALSE.
    Otherwise, setting pname:depthClampEnable to ename:VK_TRUE will enable
    depth clamping.
  * [[features-features-depthBiasClamp]] pname:depthBiasClamp specifies
    whether depth bias clamping is supported.
    If this feature is not enabled, the pname:depthBiasClamp member of the
    sname:VkPipelineRasterizationStateCreateInfo structure must: be set to
    0.0 unless the ename:VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state is
    enabled, and the pname:depthBiasClamp parameter to
    fname:vkCmdSetDepthBias must: be set to 0.0.
  * [[features-features-fillModeNonSolid]] pname:fillModeNonSolid specifies
    whether point and wireframe fill modes are supported.
    If this feature is not enabled, the ename:VK_POLYGON_MODE_POINT and
    ename:VK_POLYGON_MODE_LINE enum values must: not be used.
  * [[features-features-depthBounds]] pname:depthBounds specifies whether
    depth bounds tests are supported.
    If this feature is not enabled, the pname:depthBoundsTestEnable member
    of the sname:VkPipelineDepthStencilStateCreateInfo structure must: be
    set to ename:VK_FALSE.
    When pname:depthBoundsTestEnable is set to ename:VK_FALSE, the
    pname:minDepthBounds and pname:maxDepthBounds members of the
    sname:VkPipelineDepthStencilStateCreateInfo structure are ignored.
  * [[features-features-wideLines]] pname:wideLines specifies whether lines
    with width other than 1.0 are supported.
    If this feature is not enabled, the pname:lineWidth member of the
    sname:VkPipelineRasterizationStateCreateInfo structure must: be set to
    1.0 unless the ename:VK_DYNAMIC_STATE_LINE_WIDTH dynamic state is
    enabled, and the pname:lineWidth parameter to fname:vkCmdSetLineWidth
    must: be set to 1.0.
    When this feature is supported, the range and granularity of supported
    line widths are indicated by the pname:lineWidthRange and
    pname:lineWidthGranularity members of the sname:VkPhysicalDeviceLimits
    structure, respectively.
  * [[features-features-largePoints]] pname:largePoints specifies whether
    points with size greater than 1.0 are supported.
    If this feature is not enabled, only a point size of 1.0 written by a
    shader is supported.
    The range and granularity of supported point sizes are indicated by the
    pname:pointSizeRange and pname:pointSizeGranularity members of the
    sname:VkPhysicalDeviceLimits structure, respectively.
  * [[features-features-alphaToOne]] pname:alphaToOne specifies whether the
    implementation is able to replace the alpha value of the color fragment
    output from the fragment shader with the maximum representable alpha
    value for fixed-point colors or 1.0 for floating-point colors.
    If this feature is not enabled, then the pname:alphaToOneEnable member
    of the sname:VkPipelineMultisampleStateCreateInfo structure must: be set
    to ename:VK_FALSE.
    Otherwise setting pname:alphaToOneEnable to ename:VK_TRUE will enable
    alpha-to-one behavior.
  * [[features-features-multiViewport]] pname:multiViewport specifies
    whether more than one viewport is supported.
    If this feature is not enabled, the pname:viewportCount and
    pname:scissorCount members of the
    sname:VkPipelineViewportStateCreateInfo structure must: be set to 1.
    Similarly, the pname:viewportCount parameter to the
    fname:vkCmdSetViewport command and the pname:scissorCount parameter to
    the fname:vkCmdSetScissor command must: be 1, and the
    pname:firstViewport parameter to the fname:vkCmdSetViewport command and
    the pname:firstScissor parameter to the fname:vkCmdSetScissor command
    must: be 0.
  * [[features-features-samplerAnisotropy]] pname:samplerAnisotropy
    specifies whether anisotropic filtering is supported.
    If this feature is not enabled, the pname:anisotropyEnable member of the
    sname:VkSamplerCreateInfo structure must: be ename:VK_FALSE.
  * [[features-features-textureCompressionETC2]]
    pname:textureCompressionETC2 specifies whether all of the ETC2 and EAC
    compressed texture formats are supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
  ** ename:VK_FORMAT_EAC_R11_UNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11_SNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK
+
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
additional supported properties of individual formats.

  * [[features-features-textureCompressionASTC_LDR]]
    pname:textureCompressionASTC_LDR specifies whether all of the ASTC LDR
    compressed texture formats are supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK
+
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
additional supported properties of individual formats.

  * [[features-features-textureCompressionBC]] pname:textureCompressionBC
    specifies whether all of the BC compressed texture formats are
    supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK
  ** ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK
  ** ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK
  ** ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK
  ** ename:VK_FORMAT_BC2_UNORM_BLOCK
  ** ename:VK_FORMAT_BC2_SRGB_BLOCK
  ** ename:VK_FORMAT_BC3_UNORM_BLOCK
  ** ename:VK_FORMAT_BC3_SRGB_BLOCK
  ** ename:VK_FORMAT_BC4_UNORM_BLOCK
  ** ename:VK_FORMAT_BC4_SNORM_BLOCK
  ** ename:VK_FORMAT_BC5_UNORM_BLOCK
  ** ename:VK_FORMAT_BC5_SNORM_BLOCK
  ** ename:VK_FORMAT_BC6H_UFLOAT_BLOCK
  ** ename:VK_FORMAT_BC6H_SFLOAT_BLOCK
  ** ename:VK_FORMAT_BC7_UNORM_BLOCK
  ** ename:VK_FORMAT_BC7_SRGB_BLOCK
+
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
additional supported properties of individual formats.

  * [[features-features-occlusionQueryPrecise]] pname:occlusionQueryPrecise
    specifies whether occlusion queries returning actual sample counts are
    supported.
    Occlusion queries are created in a sname:VkQueryPool by specifying the
    pname:queryType of ename:VK_QUERY_TYPE_OCCLUSION in the
    sname:VkQueryPoolCreateInfo structure which is passed to
    fname:vkCreateQueryPool.
    If this feature is enabled, queries of this type can: enable
    ename:VK_QUERY_CONTROL_PRECISE_BIT in the pname:flags parameter to
    fname:vkCmdBeginQuery.
    If this feature is not supported, the implementation supports only
    boolean occlusion queries.
    When any samples are passed, boolean queries will return a non-zero
    result value, otherwise a result value of zero is returned.
    When this feature is enabled and ename:VK_QUERY_CONTROL_PRECISE_BIT is
    set, occlusion queries will report the actual number of samples passed.
  * [[features-features-pipelineStatisticsQuery]]
    pname:pipelineStatisticsQuery specifies whether the pipeline statistics
    queries are supported.
    If this feature is not enabled, queries of type
    ename:VK_QUERY_TYPE_PIPELINE_STATISTICS cannot: be created, and none of
    the elink:VkQueryPipelineStatisticFlagBits bits can: be set in the
    pname:pipelineStatistics member of the sname:VkQueryPoolCreateInfo
    structure.
  * [[features-features-vertexPipelineStoresAndAtomics]]
    pname:vertexPipelineStoresAndAtomics specifies whether storage buffers
    and images support stores and atomic operations in the vertex,
    tessellation, and geometry shader stages.
    If this feature is not enabled, all storage image, storage texel
    buffers, and storage buffer variables used by these stages in shader
    modules must: be decorated with the code:NonWritable decoration (or the
    code:readonly memory qualifier in GLSL).
  * [[features-features-fragmentStoresAndAtomics]]
    pname:fragmentStoresAndAtomics specifies whether storage buffers and
    images support stores and atomic operations in the fragment shader
    stage.
    If this feature is not enabled, all storage image, storage texel
    buffers, and storage buffer variables used by the fragment stage in
    shader modules must: be decorated with the code:NonWritable decoration
    (or the code:readonly memory qualifier in GLSL).
  * [[features-features-shaderTessellationAndGeometryPointSize]]
    pname:shaderTessellationAndGeometryPointSize specifies whether the
    code:PointSize built-in decoration is available in the tessellation
    control, tessellation evaluation, and geometry shader stages.
    If this feature is not enabled, members decorated with the
    code:PointSize built-in decoration must: not be read from or written to
    and all points written from a tessellation or geometry shader will have
    a size of 1.0.
    This also specifies whether shader modules can: declare the
    code:TessellationPointSize capability for tessellation control and
    evaluation shaders, or if the shader modules can: declare the
    code:GeometryPointSize capability for geometry shaders.
    An implementation supporting this feature must: also support one or both
    of the <<features-features-tessellationShader,pname:tessellationShader>>
    or <<features-features-geometryShader,pname:geometryShader>> features.
  * [[features-features-shaderImageGatherExtended]]
    pname:shaderImageGatherExtended specifies whether the extended set of
    image gather instructions are available in shader code.
    If this feature is not enabled, the code:OpImage*code:Gather
    instructions do not support the code:Offset and code:ConstOffsets
    operands.
    This also specifies whether shader modules can: declare the
    code:ImageGatherExtended capability.
  * [[features-features-shaderStorageImageExtendedFormats]]
    pname:shaderStorageImageExtendedFormats specifies whether the extended
    storage image formats are available in shader code.
    If this feature is not enabled, the formats requiring the
    code:StorageImageExtendedFormats capability are not supported for
    storage images.
    This also specifies whether shader modules can: declare the
    code:StorageImageExtendedFormats capability.
  * [[features-features-shaderStorageImageMultisample]]
    pname:shaderStorageImageMultisample specifies whether multisampled
    storage images are supported.
    If this feature is not enabled, images that are created with a
    pname:usage that includes ename:VK_IMAGE_USAGE_STORAGE_BIT must: be
    created with pname:samples equal to ename:VK_SAMPLE_COUNT_1_BIT.
    This also specifies whether shader modules can: declare the
    code:StorageImageMultisample capability.
  * [[features-features-shaderStorageImageReadWithoutFormat]]
    pname:shaderStorageImageReadWithoutFormat specifies whether storage
    images require a format qualifier to be specified when reading from
    storage images.
    If this feature is not enabled, the code:OpImageRead instruction must:
    not have an code:OpTypeImage of code:Unknown.
    This also specifies whether shader modules can: declare the
    code:StorageImageReadWithoutFormat capability.
  * [[features-features-shaderStorageImageWriteWithoutFormat]]
    pname:shaderStorageImageWriteWithoutFormat specifies whether storage
    images require a format qualifier to be specified when writing to
    storage images.
    If this feature is not enabled, the code:OpImageWrite instruction must:
    not have an code:OpTypeImage of code:Unknown.
    This also specifies whether shader modules can: declare the
    code:StorageImageWriteWithoutFormat capability.
  * [[features-features-shaderUniformBufferArrayDynamicIndexing]]
    pname:shaderUniformBufferArrayDynamicIndexing specifies whether arrays
    of uniform buffers can: be indexed by _dynamically uniform_ integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also specifies whether shader modules can: declare the
    code:UniformBufferArrayDynamicIndexing capability.
  * [[features-features-shaderSampledImageArrayDynamicIndexing]]
    pname:shaderSampledImageArrayDynamicIndexing specifies whether arrays of
    samplers or sampled images can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must: be indexed only by constant
    integral expressions when aggregated into arrays in shader code.
    This also specifies whether shader modules can: declare the
    code:SampledImageArrayDynamicIndexing capability.
  * [[features-features-shaderStorageBufferArrayDynamicIndexing]]
    pname:shaderStorageBufferArrayDynamicIndexing specifies whether arrays
    of storage buffers can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also specifies whether shader modules can: declare the
    code:StorageBufferArrayDynamicIndexing capability.
  * [[features-features-shaderStorageImageArrayDynamicIndexing]]
    pname:shaderStorageImageArrayDynamicIndexing specifies whether arrays of
    storage images can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must: be indexed only by constant
    integral expressions when aggregated into arrays in shader code.
    This also specifies whether shader modules can: declare the
    code:StorageImageArrayDynamicIndexing capability.
  * [[features-features-shaderClipDistance]] pname:shaderClipDistance
    specifies whether clip distances are supported in shader code.
    If this feature is not enabled, any members decorated with the
    code:ClipDistance built-in decoration must: not be read from or written
    to in shader modules.
    This also specifies whether shader modules can: declare the
    code:ClipDistance capability.
  * [[features-features-shaderCullDistance]] pname:shaderCullDistance
    specifies whether cull distances are supported in shader code.
    If this feature is not enabled, any members decorated with the
    code:CullDistance built-in decoration must: not be read from or written
    to in shader modules.
    This also specifies whether shader modules can: declare the
    code:CullDistance capability.
  * [[features-features-shaderFloat64]] pname:shaderFloat64 specifies
    whether 64-bit floats (doubles) are supported in shader code.
    If this feature is not enabled, 64-bit floating-point types must: not be
    used in shader code.
    This also specifies whether shader modules can: declare the code:Float64
    capability.
  * [[features-features-shaderInt64]] pname:shaderInt64 specifies whether
    64-bit integers (signed and unsigned) are supported in shader code.
    If this feature is not enabled, 64-bit integer types must: not be used
    in shader code.
    This also specifies whether shader modules can: declare the code:Int64
    capability.
  * [[features-features-shaderInt16]] pname:shaderInt16 specifies whether
    16-bit integers (signed and unsigned) are supported in shader code.
    If this feature is not enabled, 16-bit integer types must: not be used
    in shader code.
    This also specifies whether shader modules can: declare the code:Int16
    capability.
  * [[features-features-shaderResourceResidency]]
    pname:shaderResourceResidency specifies whether image operations that
    return resource residency information are supported in shader code.
    If this feature is not enabled, the code:OpImageSparse* instructions
    must: not be used in shader code.
    This also specifies whether shader modules can: declare the
    code:SparseResidency capability.
    The feature requires at least one of the ptext:sparseResidency* features
    to be supported.
  * [[features-features-shaderResourceMinLod]] pname:shaderResourceMinLod
    specifies whether image operations that specify the minimum resource LOD
    are supported in shader code.
    If this feature is not enabled, the code:MinLod image operand must: not
    be used in shader code.
    This also specifies whether shader modules can: declare the code:MinLod
    capability.
  * [[features-features-sparseBinding]] pname:sparseBinding specifies
    whether resource memory can: be managed at opaque sparse block level
    instead of at the object level.
    If this feature is not enabled, resource memory must: be bound only on a
    per-object basis using the fname:vkBindBufferMemory and
    fname:vkBindImageMemory commands.
    In this case, buffers and images must: not be created with
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT and
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in the pname:flags member
    of the sname:VkBufferCreateInfo and sname:VkImageCreateInfo structures,
    respectively.
    Otherwise resource memory can: be managed as described in
    <<sparsememory-sparseresourcefeatures,Sparse Resource Features>>.
  * [[features-features-sparseResidencyBuffer]] pname:sparseResidencyBuffer
    specifies whether the device can: access partially resident buffers.
    If this feature is not enabled, buffers must: not be created with
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags
    member of the sname:VkBufferCreateInfo structure.
  * [[features-features-sparseResidencyImage2D]]
    pname:sparseResidencyImage2D specifies whether the device can: access
    partially resident 2D images with 1 sample per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_1_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-features-sparseResidencyImage3D]]
    pname:sparseResidencyImage3D specifies whether the device can: access
    partially resident 3D images.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_3D must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-features-sparseResidency2Samples]]
    pname:sparseResidency2Samples specifies whether the physical device can:
    access partially resident 2D images with 2 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_2_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-features-sparseResidency4Samples]]
    pname:sparseResidency4Samples specifies whether the physical device can:
    access partially resident 2D images with 4 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_4_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-features-sparseResidency8Samples]]
    pname:sparseResidency8Samples specifies whether the physical device can:
    access partially resident 2D images with 8 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_8_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-features-sparseResidency16Samples]]
    pname:sparseResidency16Samples specifies whether the physical device
    can: access partially resident 2D images with 16 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_16_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-features-sparseResidencyAliased]]
    pname:sparseResidencyAliased specifies whether the physical device can:
    correctly access data aliased into multiple locations.
    If this feature is not enabled, the
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT and
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT enum values must: not be used
    in pname:flags members of the sname:VkBufferCreateInfo and
    sname:VkImageCreateInfo structures, respectively.
  * [[features-features-variableMultisampleRate]]
    pname:variableMultisampleRate specifies whether all pipelines that will
    be bound to a command buffer during a subpass with no attachments must:
    have the same value for
    sname:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples.
    If set to ename:VK_TRUE, the implementation supports variable
    multisample rates in a subpass with no attachments.
    If set to ename:VK_FALSE, then all pipelines bound in such a subpass
    must: have the same multisample rate.
    This has no effect in situations where a subpass uses any attachments.
  * [[features-features-inheritedQueries]] pname:inheritedQueries specifies
    whether a secondary command buffer may: be executed while a query is
    active.

include::../validity/structs/VkPhysicalDeviceFeatures.txt[]
--

ifdef::VK_VERSION_1_1,VK_KHR_variable_pointers[]

[open,refpage='VkPhysicalDeviceVariablePointerFeatures',desc='Structure describing variable pointers features that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceVariablePointerFeatures structure is defined as:

include::../api/structs/VkPhysicalDeviceVariablePointerFeatures.txt[]

ifdef::VK_KHR_variable_pointers[]
or the equivalent

include::../api/structs/VkPhysicalDeviceVariablePointerFeaturesKHR.txt[]
endif::VK_KHR_variable_pointers[]

The members of the sname:VkPhysicalDeviceVariablePointerFeatures structure
describe the following features:

  * [[features-features-variablePointersStorageBuffer]]
    pname:variablePointersStorageBuffer specifies whether the implementation
    supports the SPIR-V `VariablePointersStorageBuffer` capability.
    When this feature is not enabled, shader modules must: not declare the
    `SPV_KHR_variable_pointers` extension or the
    `VariablePointersStorageBuffer` capability.
  * [[features-features-variablePointers]] pname:variablePointers specifies
    whether the implementation supports the SPIR-V `VariablePointers`
    capability.
    When this feature is not enabled, shader modules must: not declare the
    `VariablePointers` capability.

If the sname:VkPhysicalDeviceVariablePointerFeatures structure is included
in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled
with values indicating whether each feature is supported.
sname:VkPhysicalDeviceVariablePointerFeatures can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceVariablePointerFeatures-variablePointers-01431]]
    If pname:variablePointers is enabled then
    pname:variablePointersStorageBuffer must: also be enabled.
****

include::../validity/structs/VkPhysicalDeviceVariablePointerFeatures.txt[]

--

endif::VK_VERSION_1_1,VK_KHR_variable_pointers[]

ifdef::VK_VERSION_1_1,VK_KHR_multiview[]

[open,refpage='VkPhysicalDeviceMultiviewFeatures',desc='Structure describing multiview features that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceMultiviewFeatures structure is defined as:

include::../api/structs/VkPhysicalDeviceMultiviewFeatures.txt[]

ifdef::VK_KHR_multiview[]
or the equivalent

include::../api/structs/VkPhysicalDeviceMultiviewFeaturesKHR.txt[]
endif::VK_KHR_multiview[]

The members of the sname:VkPhysicalDeviceMultiviewFeatures structure
describe the following features:

  * [[features-features-multiview]] pname:multiview specifies whether the
    implementation supports multiview rendering within a render pass.
    If this feature is not enabled, the view mask of each subpass must:
    always be zero.
  * [[features-features-multiview-gs]] pname:multiviewGeometryShader
    specifies whether the implementation supports multiview rendering within
    a render pass, with <<geometry,geometry shaders>>.
    If this feature is not enabled, then a pipeline compiled against a
    subpass with a non-zero view mask must: not include a geometry shader.
  * [[features-features-multiview-tess]] pname:multiviewTessellationShader
    specifies whether the implementation supports multiview rendering within
    a render pass, with <<tessellation,tessellation shaders>>.
    If this feature is not enabled, then a pipeline compiled against a
    subpass with a non-zero view mask must: not include any tessellation
    shaders.

If the sname:VkPhysicalDeviceMultiviewFeatures structure is included in the
pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled with
values indicating whether each feature is supported.
sname:VkPhysicalDeviceMultiviewFeatures can: also be used in the pname:pNext
chain of slink:VkDeviceCreateInfo to enable the features.

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceMultiviewFeatures-multiviewGeometryShader-00580]]
    If pname:multiviewGeometryShader is enabled then pname:multiview must:
    also be enabled.
  * [[VUID-VkPhysicalDeviceMultiviewFeatures-multiviewTessellationShader-00581]]
    If pname:multiviewTessellationShader is enabled then pname:multiview
    must: also be enabled.
****

include::../validity/structs/VkPhysicalDeviceMultiviewFeatures.txt[]

--

endif::VK_VERSION_1_1,VK_KHR_multiview[]

ifdef::VK_KHR_8bit_storage[]
[open,refpage='VkPhysicalDevice8BitStorageFeaturesKHR',desc='Structure describing features supported by VK_KHR_8bit_storage',type='structs']
--

To query 8-bit storage features additionally supported call
flink:vkGetPhysicalDeviceFeatures2 with a
sname:VkPhysicalDevice8BitStorageFeaturesKHR structure included in the
pname:pNext chain of its pname:pFeatures parameter.
The sname:VkPhysicalDevice8BitStorageFeaturesKHR structure can: also be in
the pname:pNext chain of a slink:VkDeviceCreateInfo structure, in which case
it controls which additional features are enabled in the device.

The slink:VkPhysicalDevice8BitStorageFeaturesKHR structure is defined as:

include::../api/structs/VkPhysicalDevice8BitStorageFeaturesKHR.txt[]

   * pname:sType is the type of this structure.
   * pname:pNext is `NULL` or a pointer to an extension-specific structure.
   * [[features-features-storageBuffer8BitAccess]]
     pname:storageBuffer8BitAccess indicates whether objects in the
     code:StorageBuffer storage class with the code:Block decoration can:
     have 8-bit integer members.
     If this feature is not enabled, 8-bit integer members must: not be used
     in such objects.
     This also indicates whether shader modules can: declare the
     code:StorageBuffer8BitAccess capability.
   * [[features-features-uniformAndStorageBuffer8BitAccess]]
     pname:uniformAndStorageBuffer8BitAccess indicates whether objects in
     the code:Uniform storage class with the code:Block decoration and in
     the code:StorageBuffer storage class with the same decoration can: have
     8-bit integer members.
     If this feature is not enabled, 8-bit integer members must: not be used
     in such objects.
     This also indicates whether shader modules can: declare the
     code:UniformAndStorageBuffer8BitAccess capability.
   * [[features-features-storagePushConstant8]] pname:storagePushConstant8
     indicates whether objects in the code:PushConstant storage class can:
     have 8-bit integer members.
     If this feature is not enabled, 8-bit integer members must: not be used
     in such objects.
     This also indicates whether shader modules can: declare the
     code:StoragePushConstant8 capability.

include::../validity/structs/VkPhysicalDevice8BitStorageFeaturesKHR.txt[]

--
endif::VK_KHR_8bit_storage[]

ifdef::VK_VERSION_1_1,VK_KHR_16bit_storage[]
[open,refpage='VkPhysicalDevice16BitStorageFeatures',desc='Structure describing features supported by VK_KHR_16bit_storage',type='structs']
--

To query 16-bit storage features additionally supported call
flink:vkGetPhysicalDeviceFeatures2 with a
sname:VkPhysicalDevice16BitStorageFeatures structure included in the
pname:pNext chain of its pname:pFeatures parameter.
The sname:VkPhysicalDevice16BitStorageFeatures structure can: also be in the
pname:pNext chain of a slink:VkDeviceCreateInfo structure, in which case it
controls which additional features are enabled in the device.

The slink:VkPhysicalDevice16BitStorageFeatures structure is defined as:

include::../api/structs/VkPhysicalDevice16BitStorageFeatures.txt[]

ifdef::VK_KHR_16bit_storage[]
or the equivalent

include::../api/structs/VkPhysicalDevice16BitStorageFeaturesKHR.txt[]
endif::VK_KHR_16bit_storage[]

   * pname:sType is the type of this structure.
   * pname:pNext is `NULL` or a pointer to an extension-specific structure.
   * [[features-features-storageBuffer16BitAccess]]
     pname:storageBuffer16BitAccess specifies whether objects in the
     code:StorageBuffer storage class with the code:Block decoration can:
     have 16-bit integer and 16-bit floating-point members.
     If this feature is not enabled, 16-bit integer or 16-bit floating-point
     members must: not be used in such objects.
     This also specifies whether shader modules can: declare the
     code:StorageBuffer16BitAccess capability.
   * [[features-features-uniformAndStorageBuffer16BitAccess]]
     pname:uniformAndStorageBuffer16BitAccess specifies whether objects in
     the code:Uniform storage class with the code:Block decoration and in
     the code:StorageBuffer storage class with the same decoration can: have
     16-bit integer and 16-bit floating-point members.
     If this feature is not enabled, 16-bit integer or 16-bit floating-point
     members must: not be used in such objects.
     This also specifies whether shader modules can: declare the
     code:UniformAndStorageBuffer16BitAccess capability.
   * [[features-features-storagePushConstant16]] pname:storagePushConstant16
     specifies whether objects in the code:PushConstant storage class can:
     have 16-bit integer and 16-bit floating-point members.
     If this feature is not enabled, 16-bit integer or floating-point
     members must: not be used in such objects.
     This also specifies whether shader modules can: declare the
     code:StoragePushConstant16 capability.
   * [[features-features-storageInputOutput16]] pname:storageInputOutput16
     specifies whether objects in the code:Input and code:Output storage
     classes can: have 16-bit integer and 16-bit floating-point members.
     If this feature is not enabled, 16-bit integer or 16-bit floating-point
     members must: not be used in such objects.
     This also specifies whether shader modules can: declare the
     code:StorageInputOutput16 capability.

include::../validity/structs/VkPhysicalDevice16BitStorageFeatures.txt[]

--
endif::VK_VERSION_1_1,VK_KHR_16bit_storage[]

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

[open,refpage='VkPhysicalDeviceSamplerYcbcrConversionFeatures',desc='Structure describing Y\'CbCr conversion features that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceSamplerYcbcrConversionFeatures structure is
defined as:

include::../api/structs/VkPhysicalDeviceSamplerYcbcrConversionFeatures.txt[]

ifdef::VK_KHR_sampler_ycbcr_conversion[]
or the equivalent

include::../api/structs/VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.txt[]
endif::VK_KHR_sampler_ycbcr_conversion[]

The members of the sname:VkPhysicalDeviceSamplerYcbcrConversionFeatures
structure describe the following feature:

  * [[features-features-sampler-YCbCr-conversion]]
    pname:samplerYcbcrConversion specifies whether the implementation
    supports <<samplers-YCbCr-conversion,sampler Y'C~B~C~R~ conversion>>.
    If pname:samplerYcbcrConversion is ename:VK_FALSE, sampler Y'C~B~C~R~
    conversion is not supported, and samplers using sampler Y'C~B~C~R~
    conversion must: not be used.

include::../validity/structs/VkPhysicalDeviceSamplerYcbcrConversionFeatures.txt[]

--

endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

ifdef::VK_VERSION_1_1[]

[open,refpage='VkPhysicalDeviceProtectedMemoryFeatures',desc='Structure describing protected memory features that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceProtectedMemoryFeatures structure is defined as:

include::../api/structs/VkPhysicalDeviceProtectedMemoryFeatures.txt[]

  * pname:protectedMemory specifies whether protected memory is supported.

If the sname:VkPhysicalDeviceProtectedMemoryFeatures structure is included
in the pname:pNext chain of flink:VkPhysicalDeviceFeatures2, it is filled
with a value indicating whether the feature is supported.

include::../validity/structs/VkPhysicalDeviceProtectedMemoryFeatures.txt[]

--

endif::VK_VERSION_1_1[]

ifdef::VK_EXT_blend_operation_advanced[]

[open,refpage='VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT',desc='Structure describing advanced blending features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure is
defined as:

include::../api/structs/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
structure describe the following features:

  * [[features-features-advancedBlendCoherentOperations]]
    pname:advancedBlendCoherentOperations specifies whether blending using
    <<framebuffer-blend-advanced,advanced blend operations>> is guaranteed
    to execute atomically and in <<drawing-primitive-order, primitive
    order>>.
    If this is ename:VK_TRUE,
    ename:VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT is treated the
    same as ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT, and advanced blending
    needs no additional synchronization over basic blending.
    If this is ename:VK_FALSE, then memory dependencies are required to
    guarantee order between two advanced blending operations that occur on
    the same sample.

If the sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT can: also be used in
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

include::../validity/structs/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.txt[]
--

endif::VK_EXT_blend_operation_advanced[]

ifdef::VK_EXT_conditional_rendering[]

[open,refpage='VkPhysicalDeviceConditionalRenderingFeaturesEXT',desc='Structure describing if a secondary command buffer can be executed if conditional rendering is active in the primary command buffer',type='structs']
--
The sname:VkPhysicalDeviceConditionalRenderingFeaturesEXT structure is
defined as:

include::../api/structs/VkPhysicalDeviceConditionalRenderingFeaturesEXT.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * [[features-features-conditionalRendering]] pname:conditionalRendering
    specifies whether conditional rendering is supported.
  * [[features-features-inheritedConditionalRendering]]
    pname:inheritedConditionalRendering specifies whether a secondary
    command buffer can: be executed while conditional rendering is active in
    the primary command buffer.

If the sname:VkPhysicalDeviceConditionalRenderingFeaturesEXT structure is
included in the pname:pNext chain of flink:VkPhysicalDeviceFeatures2, it is
filled with values indicating the implementation-dependent behavior.
sname:VkPhysicalDeviceConditionalRenderingFeaturesEXT can: also be used in
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

include::../validity/structs/VkPhysicalDeviceConditionalRenderingFeaturesEXT.txt[]

--

endif::VK_EXT_conditional_rendering[]

ifdef::VK_VERSION_1_1[]
[open,refpage='VkPhysicalDeviceShaderDrawParameterFeatures',desc='Structure describing shader draw parameter features that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceShaderDrawParameterFeatures structure is defined
as:

include::../api/structs/VkPhysicalDeviceShaderDrawParameterFeatures.txt[]

  * [[features-features-shaderDrawParameters]] pname:shaderDrawParameters
    specifies whether shader draw parameters are supported.

If the sname:VkPhysicalDeviceShaderDrawParameterFeatures structure is
included in the pname:pNext chain of flink:VkPhysicalDeviceFeatures2, it is
filled with a value indicating whether the feature is supported.

include::../validity/structs/VkPhysicalDeviceShaderDrawParameterFeatures.txt[]

--
endif::VK_VERSION_1_1[]

ifdef::VK_EXT_descriptor_indexing[]

[open,refpage='VkPhysicalDeviceDescriptorIndexingFeaturesEXT',desc='Structure describing descriptor indexing features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDescriptorIndexingFeaturesEXT structure is defined
as:

include::../api/structs/VkPhysicalDeviceDescriptorIndexingFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceDescriptorIndexingFeaturesEXT
structure describe the following features:

  * [[features-features-shaderInputAttachmentArrayDynamicIndexing]]
    pname:shaderInputAttachmentArrayDynamicIndexing indicates whether arrays
    of input attachments can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:InputAttachmentArrayDynamicIndexingEXT capability.
  * [[features-features-shaderUniformTexelBufferArrayDynamicIndexing]]
    pname:shaderUniformTexelBufferArrayDynamicIndexing indicates whether
    arrays of uniform texel buffers can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformTexelBufferArrayDynamicIndexingEXT capability.
  * [[features-features-shaderStorageTexelBufferArrayDynamicIndexing]]
    pname:shaderStorageTexelBufferArrayDynamicIndexing indicates whether
    arrays of storage texel buffers can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageTexelBufferArrayDynamicIndexingEXT capability.
  * [[features-features-shaderUniformBufferArrayNonUniformIndexing]]
    pname:shaderUniformBufferArrayNonUniformIndexing indicates whether
    arrays of uniform buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformBufferArrayNonUniformIndexingEXT capability.
  * [[features-features-shaderSampledImageArrayNonUniformIndexing]]
    pname:shaderSampledImageArrayNonUniformIndexing indicates whether arrays
    of samplers or sampled images can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:SampledImageArrayNonUniformIndexingEXT capability.
  * [[features-features-shaderStorageBufferArrayNonUniformIndexing]]
    pname:shaderStorageBufferArrayNonUniformIndexing indicates whether
    arrays of storage buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageBufferArrayNonUniformIndexingEXT capability.
  * [[features-features-shaderStorageImageArrayNonUniformIndexing]]
    pname:shaderStorageImageArrayNonUniformIndexing indicates whether arrays
    of storage images can: be indexed by non-uniform integer expressions in
    shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageImageArrayNonUniformIndexingEXT capability.
  * [[features-features-shaderInputAttachmentArrayNonUniformIndexing]]
    pname:shaderInputAttachmentArrayNonUniformIndexing indicates whether
    arrays of input attachments can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:InputAttachmentArrayNonUniformIndexingEXT capability.
  * [[features-features-shaderUniformTexelBufferArrayNonUniformIndexing]]
    pname:shaderUniformTexelBufferArrayNonUniformIndexing indicates whether
    arrays of uniform texel buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformTexelBufferArrayNonUniformIndexingEXT capability.
  * [[features-features-shaderStorageTexelBufferArrayNonUniformIndexing]]
    pname:shaderStorageTexelBufferArrayNonUniformIndexing indicates whether
    arrays of storage texel buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageTexelBufferArrayNonUniformIndexingEXT capability.
  * [[features-features-descriptorBindingUniformBufferUpdateAfterBind]]
    pname:descriptorBindingUniformBufferUpdateAfterBind indicates whether
    the implementation supports updating uniform buffer descriptors after a
    set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must: not be used
    with ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER.
  * [[features-features-descriptorBindingSampledImageUpdateAfterBind]]
    pname:descriptorBindingSampledImageUpdateAfterBind indicates whether the
    implementation supports updating sampled image descriptors after a set
    is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must: not be used
    with ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE.
  * [[features-features-descriptorBindingStorageImageUpdateAfterBind]]
    pname:descriptorBindingStorageImageUpdateAfterBind indicates whether the
    implementation supports updating storage image descriptors after a set
    is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must: not be used
    with ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.
  * [[features-features-descriptorBindingStorageBufferUpdateAfterBind]]
    pname:descriptorBindingStorageBufferUpdateAfterBind indicates whether
    the implementation supports updating storage buffer descriptors after a
    set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must: not be used
    with ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER.
  * [[features-features-descriptorBindingUniformTexelBufferUpdateAfterBind]]
    pname:descriptorBindingUniformTexelBufferUpdateAfterBind indicates
    whether the implementation supports updating uniform texel buffer
    descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must: not be used
    with ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.
  * [[features-features-descriptorBindingStorageTexelBufferUpdateAfterBind]]
    pname:descriptorBindingStorageTexelBufferUpdateAfterBind indicates
    whether the implementation supports updating storage texel buffer
    descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must: not be used
    with ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.
  * [[features-features-descriptorBindingUpdateUnusedWhilePending]]
    pname:descriptorBindingUpdateUnusedWhilePending indicates whether the
    implementation supports updating descriptors while the set is in use.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT must:
    not be used.
  * [[features-features-descriptorBindingPartiallyBound]]
    pname:descriptorBindingPartiallyBound indicates whether the
    implementation supports statically using a descriptor set binding in
    which some descriptors are not valid.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT must: not be used.
  * [[features-features-descriptorBindingVariableDescriptorCount]]
    pname:descriptorBindingVariableDescriptorCount indicates whether the
    implementation supports descriptor sets with a variable-sized last
    binding.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT must: not
    be used.
  * [[features-features-runtimeDescriptorArray]]
    pname:runtimeDescriptorArray indicates whether the implementation
    supports the SPIR-V +RuntimeDescriptorArrayEXT+ capability.
    If this feature is not enabled, descriptors must: not be declared in
    runtime arrays.

If the sname:VkPhysicalDeviceDescriptorIndexingFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it
is filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceDescriptorIndexingFeaturesEXT can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::../validity/structs/VkPhysicalDeviceDescriptorIndexingFeaturesEXT.txt[]
--

endif::VK_EXT_descriptor_indexing[]


[[features-features-requirements]]
=== Feature Requirements

All Vulkan graphics implementations must: support the following features:

  * <<features-features-robustBufferAccess, pname:robustBufferAccess>>
ifdef::VK_VERSION_1_1[]
  * <<features-features-multiview, pname:multiview>>
endif::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_1,VK_KHR_variable_pointers[]
  * <<features-features-variablePointersStorageBuffer,
    pname:variablePointersStorageBuffer>>, if the
    `<<VK_KHR_variable_pointers>>` extension is supported.
endif::VK_VERSION_1_1,VK_KHR_variable_pointers[]
ifdef::VK_KHR_8bit_storage[]
  * <<features-features-StorageBuffer8BitAccess,
    pname:storageBuffer8BitAccess>>, if the `<<VK_KHR_8bit_storage>>`
    extension is supported.
endif::VK_KHR_8bit_storage[]
ifdef::VK_EXT_descriptor_indexing[]
  * If the `<<VK_EXT_descriptor_indexing>>` extension is supported:
  ** <<features-features-shaderSampledImageArrayDynamicIndexing,
     pname:shaderSampledImageArrayDynamicIndexing>>
  ** <<features-features-shaderStorageBufferArrayDynamicIndexing,
     pname:shaderStorageBufferArrayDynamicIndexing>>
  ** <<features-features-shaderUniformTexelBufferArrayDynamicIndexing,
     pname:shaderUniformTexelBufferArrayDynamicIndexing>>
  ** <<features-features-shaderStorageTexelBufferArrayDynamicIndexing,
     pname:shaderStorageTexelBufferArrayDynamicIndexing>>
  ** <<features-features-shaderSampledImageArrayNonUniformIndexing,
     pname:shaderSampledImageArrayNonUniformIndexing>>
  ** <<features-features-shaderStorageBufferArrayNonUniformIndexing,
     pname:shaderStorageBufferArrayNonUniformIndexing>>
  ** <<features-features-shaderUniformTexelBufferArrayNonUniformIndexing,
     pname:shaderUniformTexelBufferArrayNonUniformIndexing>>
  ** <<features-features-descriptorBindingSampledImageUpdateAfterBind,
     pname:descriptorBindingSampledImageUpdateAfterBind>>
  ** <<features-features-descriptorBindingStorageImageUpdateAfterBind,
     pname:descriptorBindingStorageImageUpdateAfterBind>>
  ** <<features-features-descriptorBindingStorageBufferUpdateAfterBind,
     pname:descriptorBindingStorageBufferUpdateAfterBind>> (see also
     <<features-limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-features-descriptorBindingUniformTexelBufferUpdateAfterBind,
     pname:descriptorBindingUniformTexelBufferUpdateAfterBind>> (see also
     <<features-limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-features-descriptorBindingStorageTexelBufferUpdateAfterBind,
     pname:descriptorBindingStorageTexelBufferUpdateAfterBind>> (see also
     <<features-limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-features-descriptorBindingUpdateUnusedWhilePending,
     pname:descriptorBindingUpdateUnusedWhilePending>>
  ** <<features-features-descriptorBindingPartiallyBound,
     pname:descriptorBindingPartiallyBound>>
  ** <<features-features-runtimeDescriptorArray,
     pname:runtimeDescriptorArray>>
endif::VK_EXT_descriptor_indexing[]

All other features defined in the Specification are optional:.


[[features-limits]]
== Limits

There are a variety of implementation-dependent limits.

The sname:VkPhysicalDeviceLimits are properties of the physical device.
These are available in the pname:limits member of the
slink:VkPhysicalDeviceProperties structure which is returned from
flink:vkGetPhysicalDeviceProperties.

[open,refpage='VkPhysicalDeviceLimits',desc='Structure reporting implementation-dependent physical device limits',type='structs']
--

The sname:VkPhysicalDeviceLimits structure is defined as:

include::../api/structs/VkPhysicalDeviceLimits.txt[]

  * [[features-limits-maxImageDimension1D]] pname:maxImageDimension1D is the
    maximum dimension (pname:width) supported for all images created with an
    pname:imageType of ename:VK_IMAGE_TYPE_1D.
  * [[features-limits-maxImageDimension2D]] pname:maxImageDimension2D is the
    maximum dimension (pname:width or pname:height) supported for all images
    created with an pname:imageType of ename:VK_IMAGE_TYPE_2D and without
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.
  * [[features-limits-maxImageDimension3D]] pname:maxImageDimension3D is the
    maximum dimension (pname:width, pname:height, or pname:depth) supported
    for all images created with an pname:imageType of
    ename:VK_IMAGE_TYPE_3D.
  * [[features-limits-maxImageDimensionCube]] pname:maxImageDimensionCube is
    the maximum dimension (pname:width or pname:height) supported for all
    images created with an pname:imageType of ename:VK_IMAGE_TYPE_2D and
    with ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.
  * [[features-limits-maxImageArrayLayers]] pname:maxImageArrayLayers is the
    maximum number of layers (pname:arrayLayers) for an image.
  * [[features-limits-maxTexelBufferElements]] pname:maxTexelBufferElements
    is the maximum number of addressable texels for a buffer view created on
    a buffer which was created with the
    ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or
    ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the pname:usage
    member of the sname:VkBufferCreateInfo structure.
  * [[features-limits-maxUniformBufferRange]] pname:maxUniformBufferRange is
    the maximum value that can: be specified in the pname:range member of
    any slink:VkDescriptorBufferInfo structures passed to a call to
    flink:vkUpdateDescriptorSets for descriptors of type
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.
  * [[features-limits-maxStorageBufferRange]] pname:maxStorageBufferRange is
    the maximum value that can: be specified in the pname:range member of
    any slink:VkDescriptorBufferInfo structures passed to a call to
    flink:vkUpdateDescriptorSets for descriptors of type
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.
  * [[features-limits-maxPushConstantsSize]] pname:maxPushConstantsSize is
    the maximum size, in bytes, of the pool of push constant memory.
    For each of the push constant ranges indicated by the
    pname:pPushConstantRanges member of the sname:VkPipelineLayoutCreateInfo
    structure, [eq]#(pname:offset {plus} pname:size)# must: be less than or
    equal to this limit.
  * [[features-limits-maxMemoryAllocationCount]]
    pname:maxMemoryAllocationCount is the maximum number of device memory
    allocations, as created by flink:vkAllocateMemory, which can:
    simultaneously exist.
  * [[features-limits-maxSamplerAllocationCount]]
    pname:maxSamplerAllocationCount is the maximum number of sampler
    objects, as created by flink:vkCreateSampler, which can: simultaneously
    exist on a device.
  * [[features-limits-bufferImageGranularity]] pname:bufferImageGranularity
    is the granularity, in bytes, at which buffer or linear image resources,
    and optimal image resources can: be bound to adjacent offsets in the
    same sname:VkDeviceMemory object without aliasing.
    See <<resources-bufferimagegranularity,Buffer-Image Granularity>> for
    more details.
  * [[features-limits-sparseAddressSpaceSize]] pname:sparseAddressSpaceSize
    is the total amount of address space available, in bytes, for sparse
    memory resources.
    This is an upper bound on the sum of the size of all sparse resources,
    regardless of whether any memory is bound to them.
  * [[features-limits-maxBoundDescriptorSets]] pname:maxBoundDescriptorSets
    is the maximum number of descriptor sets that can: be simultaneously
    used by a pipeline.
    All code:DescriptorSet decorations in shader modules must: have a value
    less than pname:maxBoundDescriptorSets.
    See <<descriptorsets-sets>>.
  * [[features-limits-maxPerStageDescriptorSamplers]]
    pname:maxPerStageDescriptorSamplers is the maximum number of samplers
    that can: be accessible to a single shader stage in a pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this
    limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    A descriptor is accessible to a shader stage when the pname:stageFlags
    member of the sname:VkDescriptorSetLayoutBinding structure has the bit
    for that shader stage set.
    See <<descriptorsets-sampler>> and
    <<descriptorsets-combinedimagesampler>>.
  * [[features-limits-maxPerStageDescriptorUniformBuffers]]
    pname:maxPerStageDescriptorUniformBuffers is the maximum number of
    uniform buffers that can: be accessible to a single shader stage in a
    pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
    limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    A descriptor is accessible to a shader stage when the pname:stageFlags
    member of the sname:VkDescriptorSetLayoutBinding structure has the bit
    for that shader stage set.
    See <<descriptorsets-uniformbuffer>> and
    <<descriptorsets-uniformbufferdynamic>>.
  * [[features-limits-maxPerStageDescriptorStorageBuffers]]
    pname:maxPerStageDescriptorStorageBuffers is the maximum number of
    storage buffers that can: be accessible to a single shader stage in a
    pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
    limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    A descriptor is accessible to a pipeline shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set.
    See <<descriptorsets-storagebuffer>> and
    <<descriptorsets-storagebufferdynamic>>.
  * [[features-limits-maxPerStageDescriptorSampledImages]]
    pname:maxPerStageDescriptorSampledImages is the maximum number of
    sampled images that can: be accessible to a single shader stage in a
    pipeline layout.
    Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    A descriptor is accessible to a pipeline shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set.
    See <<descriptorsets-combinedimagesampler>>,
    <<descriptorsets-sampledimage>>, and
    <<descriptorsets-uniformtexelbuffer>>.
  * [[features-limits-maxPerStageDescriptorStorageImages]]
    pname:maxPerStageDescriptorStorageImages is the maximum number of
    storage images that can: be accessible to a single shader stage in a
    pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    A descriptor is accessible to a pipeline shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set.
    See <<descriptorsets-storageimage>>, and
    <<descriptorsets-storagetexelbuffer>>.
  * [[features-limits-maxPerStageDescriptorInputAttachments]]
    pname:maxPerStageDescriptorInputAttachments is the maximum number of
    input attachments that can: be accessible to a single shader stage in a
    pipeline layout.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT
    count against this limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    A descriptor is accessible to a pipeline shader stage when the
    pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
    structure has the bit for that shader stage set.
    These are only supported for the fragment stage.
    See <<descriptorsets-inputattachment>>.
  * [[features-limits-maxPerStageResources]] pname:maxPerStageResources is
    the maximum number of resources that can: be accessible to a single
    shader stage in a pipeline layout.
    Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, or
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    For the fragment shader stage the framebuffer color attachments also
    count against this limit.
  * [[features-limits-maxDescriptorSetSamplers]]
    pname:maxDescriptorSetSamplers is the maximum number of samplers that
    can: be included in descriptor bindings in a pipeline layout across all
    pipeline shader stages and descriptor set numbers.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this
    limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    See <<descriptorsets-sampler>> and
    <<descriptorsets-combinedimagesampler>>.
  * [[features-limits-maxDescriptorSetUniformBuffers]]
    pname:maxDescriptorSetUniformBuffers is the maximum number of uniform
    buffers that can: be included in descriptor bindings in a pipeline
    layout across all pipeline shader stages and descriptor set numbers.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
    limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    See <<descriptorsets-uniformbuffer>> and
    <<descriptorsets-uniformbufferdynamic>>.
  * [[features-limits-maxDescriptorSetUniformBuffersDynamic]]
    pname:maxDescriptorSetUniformBuffersDynamic is the maximum number of
    dynamic uniform buffers that can: be included in descriptor bindings in
    a pipeline layout across all pipeline shader stages and descriptor set
    numbers.
    Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
    limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    See <<descriptorsets-uniformbufferdynamic>>.
  * [[features-limits-maxDescriptorSetStorageBuffers]]
    pname:maxDescriptorSetStorageBuffers is the maximum number of storage
    buffers that can: be included in descriptor bindings in a pipeline
    layout across all pipeline shader stages and descriptor set numbers.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
    limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    See <<descriptorsets-storagebuffer>> and
    <<descriptorsets-storagebufferdynamic>>.
  * [[features-limits-maxDescriptorSetStorageBuffersDynamic]]
    pname:maxDescriptorSetStorageBuffersDynamic is the maximum number of
    dynamic storage buffers that can: be included in descriptor bindings in
    a pipeline layout across all pipeline shader stages and descriptor set
    numbers.
    Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
    limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    See <<descriptorsets-storagebufferdynamic>>.
  * [[features-limits-maxDescriptorSetSampledImages]]
    pname:maxDescriptorSetSampledImages is the maximum number of sampled
    images that can: be included in descriptor bindings in a pipeline layout
    across all pipeline shader stages and descriptor set numbers.
    Descriptors with a type of
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    See <<descriptorsets-combinedimagesampler>>,
    <<descriptorsets-sampledimage>>, and
    <<descriptorsets-uniformtexelbuffer>>.
  * [[features-limits-maxDescriptorSetStorageImages]]
    pname:maxDescriptorSetStorageImages is the maximum number of storage
    images that can: be included in descriptor bindings in a pipeline layout
    across all pipeline shader stages and descriptor set numbers.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    See <<descriptorsets-storageimage>>, and
    <<descriptorsets-storagetexelbuffer>>.
  * [[features-limits-maxDescriptorSetInputAttachments]]
    pname:maxDescriptorSetInputAttachments is the maximum number of input
    attachments that can: be included in descriptor bindings in a pipeline
    layout across all pipeline shader stages and descriptor set numbers.
    Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT
    count against this limit.
ifdef::VK_EXT_descriptor_indexing[]
    Only descriptors in descriptor set layouts created without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set count against this limit.
endif::VK_EXT_descriptor_indexing[]
    See <<descriptorsets-inputattachment>>.
  * [[features-limits-maxVertexInputAttributes]]
    pname:maxVertexInputAttributes is the maximum number of vertex input
    attributes that can: be specified for a graphics pipeline.
    These are described in the array of
    sname:VkVertexInputAttributeDescription structures that are provided at
    graphics pipeline creation time via the
    pname:pVertexAttributeDescriptions member of the
    sname:VkPipelineVertexInputStateCreateInfo structure.
    See <<fxvertex-attrib>> and <<fxvertex-input>>.
  * [[features-limits-maxVertexInputBindings]] pname:maxVertexInputBindings
    is the maximum number of vertex buffers that can: be specified for
    providing vertex attributes to a graphics pipeline.
    These are described in the array of
    sname:VkVertexInputBindingDescription structures that are provided at
    graphics pipeline creation time via the pname:pVertexBindingDescriptions
    member of the sname:VkPipelineVertexInputStateCreateInfo structure.
    The pname:binding member of sname:VkVertexInputBindingDescription must:
    be less than this limit.
    See <<fxvertex-input>>.
  * [[features-limits-maxVertexInputAttributeOffset]]
    pname:maxVertexInputAttributeOffset is the maximum vertex input
    attribute offset that can: be added to the vertex input binding stride.
    The pname:offset member of the sname:VkVertexInputAttributeDescription
    structure must: be less than or equal to this limit.
    See <<fxvertex-input>>.
  * [[features-limits-maxVertexInputBindingStride]]
    pname:maxVertexInputBindingStride is the maximum vertex input binding
    stride that can: be specified in a vertex input binding.
    The pname:stride member of the sname:VkVertexInputBindingDescription
    structure must: be less than or equal to this limit.
    See <<fxvertex-input>>.
  * [[features-limits-maxVertexOutputComponents]]
    pname:maxVertexOutputComponents is the maximum number of components of
    output variables which can: be output by a vertex shader.
    See <<shaders-vertex>>.
  * [[features-limits-maxTessellationGenerationLevel]]
    pname:maxTessellationGenerationLevel is the maximum tessellation
    generation level supported by the fixed-function tessellation primitive
    generator.
    See <<tessellation>>.
  * [[features-limits-maxTessellationPatchSize]]
    pname:maxTessellationPatchSize is the maximum patch size, in vertices,
    of patches that can: be processed by the tessellation control shader and
    tessellation primitive generator.
    The pname:patchControlPoints member of the
    sname:VkPipelineTessellationStateCreateInfo structure specified at
    pipeline creation time and the value provided in the code:OutputVertices
    execution mode of shader modules must: be less than or equal to this
    limit.
    See <<tessellation>>.
  * [[features-limits-maxTessellationControlPerVertexInputComponents]]
    pname:maxTessellationControlPerVertexInputComponents is the maximum
    number of components of input variables which can: be provided as
    per-vertex inputs to the tessellation control shader stage.
  * [[features-limits-maxTessellationControlPerVertexOutputComponents]]
    pname:maxTessellationControlPerVertexOutputComponents is the maximum
    number of components of per-vertex output variables which can: be output
    from the tessellation control shader stage.
  * [[features-limits-maxTessellationControlPerPatchOutputComponents]]
    pname:maxTessellationControlPerPatchOutputComponents is the maximum
    number of components of per-patch output variables which can: be output
    from the tessellation control shader stage.
  * [[features-limits-maxTessellationControlTotalOutputComponents]]
    pname:maxTessellationControlTotalOutputComponents is the maximum total
    number of components of per-vertex and per-patch output variables which
    can: be output from the tessellation control shader stage.
  * [[features-limits-maxTessellationEvaluationInputComponents]]
    pname:maxTessellationEvaluationInputComponents is the maximum number of
    components of input variables which can: be provided as per-vertex
    inputs to the tessellation evaluation shader stage.
  * [[features-limits-maxTessellationEvaluationOutputComponents]]
    pname:maxTessellationEvaluationOutputComponents is the maximum number of
    components of per-vertex output variables which can: be output from the
    tessellation evaluation shader stage.
  * [[features-limits-maxGeometryShaderInvocations]]
    pname:maxGeometryShaderInvocations is the maximum invocation count
    supported for instanced geometry shaders.
    The value provided in the code:Invocations execution mode of shader
    modules must: be less than or equal to this limit.
    See <<geometry>>.
  * [[features-limits-maxGeometryInputComponents]]
    pname:maxGeometryInputComponents is the maximum number of components of
    input variables which can: be provided as inputs to the geometry shader
    stage.
  * [[features-limits-maxGeometryOutputComponents]]
    pname:maxGeometryOutputComponents is the maximum number of components of
    output variables which can: be output from the geometry shader stage.
  * [[features-limits-maxGeometryOutputVertices]]
    pname:maxGeometryOutputVertices is the maximum number of vertices which
    can: be emitted by any geometry shader.
  * [[features-limits-maxGeometryTotalOutputComponents]]
    pname:maxGeometryTotalOutputComponents is the maximum total number of
    components of output, across all emitted vertices, which can: be output
    from the geometry shader stage.
  * [[features-limits-maxFragmentInputComponents]]
    pname:maxFragmentInputComponents is the maximum number of components of
    input variables which can: be provided as inputs to the fragment shader
    stage.
  * [[features-limits-maxFragmentOutputAttachments]]
    pname:maxFragmentOutputAttachments is the maximum number of output
    attachments which can: be written to by the fragment shader stage.
  * [[features-limits-maxFragmentDualSrcAttachments]]
    pname:maxFragmentDualSrcAttachments is the maximum number of output
    attachments which can: be written to by the fragment shader stage when
    blending is enabled and one of the dual source blend modes is in use.
    See <<framebuffer-dsb>> and
    <<features-features-dualSrcBlend,dualSrcBlend>>.
  * [[features-limits-maxFragmentCombinedOutputResources]]
    pname:maxFragmentCombinedOutputResources is the total number of storage
    buffers, storage images, and output buffers which can: be used in the
    fragment shader stage.
  * [[features-limits-maxComputeSharedMemorySize]]
    pname:maxComputeSharedMemorySize is the maximum total storage size, in
    bytes, of all variables declared with the code:WorkgroupLocal storage
    class in shader modules (or with the code:shared storage qualifier in
    GLSL) in the compute shader stage.
  * [[features-limits-maxComputeWorkGroupCount]]
    pname:maxComputeWorkGroupCount[3] is the maximum number of local
    workgroups that can: be dispatched by a single dispatch command.
    These three values represent the maximum number of local workgroups for
    the X, Y, and Z dimensions, respectively.
    The workgroup count parameters to the dispatch commands must: be less
    than or equal to the corresponding limit.
    See <<dispatch>>.
  * [[features-limits-maxComputeWorkGroupInvocations]]
    pname:maxComputeWorkGroupInvocations is the maximum total number of
    compute shader invocations in a single local workgroup.
    The product of the X, Y, and Z sizes as specified by the code:LocalSize
    execution mode in shader modules and by the object decorated by the
    code:WorkgroupSize decoration must: be less than or equal to this limit.
  * [[features-limits-maxComputeWorkGroupSize]]
    pname:maxComputeWorkGroupSize[3] is the maximum size of a local compute
    workgroup, per dimension.
    These three values represent the maximum local workgroup size in the X,
    Y, and Z dimensions, respectively.
    The pname:x, pname:y, and pname:z sizes specified by the code:LocalSize
    execution mode and by the object decorated by the code:WorkgroupSize
    decoration in shader modules must: be less than or equal to the
    corresponding limit.
  * [[features-limits-subPixelPrecisionBits]] pname:subPixelPrecisionBits is
    the number of bits of subpixel precision in framebuffer coordinates
    [eq]#x~f~# and [eq]#y~f~#.
    See <<primsrast>>.
  * [[features-limits-subTexelPrecisionBits]] pname:subTexelPrecisionBits is
    the number of bits of precision in the division along an axis of an
    image used for minification and magnification filters.
    [eq]#2^pname:subTexelPrecisionBits^# is the actual number of divisions
    along each axis of the image represented.
    Sub-texel values calculated during image sampling will snap to these
    locations when generating the filtered results.
  * [[features-limits-mipmapPrecisionBits]] pname:mipmapPrecisionBits is the
    number of bits of division that the LOD calculation for mipmap fetching
    get snapped to when determining the contribution from each mip level to
    the mip filtered results.
    [eq]#2^pname:mipmapPrecisionBits^# is the actual number of divisions.
+
[NOTE]
.Note
====
For example, if this value is 2 bits then when linearly filtering between
two levels, each level could: contribute: 0%, 33%, 66%, or 100% (this is
just an example and the amount of contribution should: be covered by
different equations in the spec).
====
  * [[features-limits-maxDrawIndexedIndexValue]]
    pname:maxDrawIndexedIndexValue is the maximum index value that can: be
    used for indexed draw calls when using 32-bit indices.
    This excludes the primitive restart index value of 0xFFFFFFFF.
    See <<features-features-fullDrawIndexUint32,fullDrawIndexUint32>>.
  * [[features-limits-maxDrawIndirectCount]] pname:maxDrawIndirectCount is
    the maximum draw count that is supported for indirect draw calls.
    See <<features-features-multiDrawIndirect,multiDrawIndirect>>.
  * [[features-limits-maxSamplerLodBias]] pname:maxSamplerLodBias is the
    maximum absolute sampler LOD bias.
    The sum of the pname:mipLodBias member of the sname:VkSamplerCreateInfo
    structure and the code:Bias operand of image sampling operations in
    shader modules (or 0 if no code:Bias operand is provided to an image
    sampling operation) are clamped to the range
    [eq]#[-pname:maxSamplerLodBias,+pname:maxSamplerLodBias]#.
    See <<samplers-mipLodBias>>.
  * [[features-limits-maxSamplerAnisotropy]] pname:maxSamplerAnisotropy is
    the maximum degree of sampler anisotropy.
    The maximum degree of anisotropic filtering used for an image sampling
    operation is the minimum of the pname:maxAnisotropy member of the
    sname:VkSamplerCreateInfo structure and this limit.
    See <<samplers-maxAnisotropy>>.
  * [[features-limits-maxViewports]] pname:maxViewports is the maximum
    number of active viewports.
    The pname:viewportCount member of the
    sname:VkPipelineViewportStateCreateInfo structure that is provided at
    pipeline creation must: be less than or equal to this limit.
  * [[features-limits-maxViewportDimensions]] pname:maxViewportDimensions[2]
    are the maximum viewport dimensions in the X (width) and Y (height)
    dimensions, respectively.
    The maximum viewport dimensions must: be greater than or equal to the
    largest image which can: be created and used as a framebuffer
    attachment.
    See <<vertexpostproc-viewport,Controlling the Viewport>>.
  * [[features-limits-viewportboundsrange]] pname:viewportBoundsRange[2] is
    the [eq]#[minimum, maximum]# range that the corners of a viewport must:
    be contained in.
    This range must: be at least [eq]#[-2 {times} pname:size, 2 {times}
    pname:size - 1]#, where [eq]#pname:size =
    max(pname:maxViewportDimensions[0], pname:maxViewportDimensions[1])#.
    See <<vertexpostproc-viewport,Controlling the Viewport>>.
+
[NOTE]
.Note
====
The intent of the pname:viewportBoundsRange limit is to allow a maximum
sized viewport to be arbitrarily shifted relative to the output target as
long as at least some portion intersects.
This would give a bounds limit of [eq]#[-pname:size {plus} 1, 2 {times}
pname:size - 1]# which would allow all possible non-empty-set intersections
of the output target and the viewport.
Since these numbers are typically powers of two, picking the signed number
range using the smallest possible number of bits ends up with the specified
range.
====
  * [[features-limits-viewportSubPixelBits]] pname:viewportSubPixelBits is
    the number of bits of subpixel precision for viewport bounds.
    The subpixel precision that floating-point viewport bounds are
    interpreted at is given by this limit.
  * [[features-limits-minMemoryMapAlignment]] pname:minMemoryMapAlignment is
    the minimum required: alignment, in bytes, of host visible memory
    allocations within the host address space.
    When mapping a memory allocation with flink:vkMapMemory, subtracting
    pname:offset bytes from the returned pointer will always produce an
    integer multiple of this limit.
    See <<memory-device-hostaccess>>.
  * [[features-limits-minTexelBufferOffsetAlignment]]
    pname:minTexelBufferOffsetAlignment is the minimum required: alignment,
    in bytes, for the pname:offset member of the
    sname:VkBufferViewCreateInfo structure for texel buffers.
    When a buffer view is created for a buffer which was created with
    ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or
    ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the pname:usage
    member of the sname:VkBufferCreateInfo structure, the pname:offset must:
    be an integer multiple of this limit.
  * [[features-limits-minUniformBufferOffsetAlignment]]
    pname:minUniformBufferOffsetAlignment is the minimum required:
    alignment, in bytes, for the pname:offset member of the
    sname:VkDescriptorBufferInfo structure for uniform buffers.
    When a descriptor of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC is updated, the
    pname:offset must: be an integer multiple of this limit.
    Similarly, dynamic offsets for uniform buffers must: be multiples of
    this limit.
  * [[features-limits-minStorageBufferOffsetAlignment]]
    pname:minStorageBufferOffsetAlignment is the minimum required:
    alignment, in bytes, for the pname:offset member of the
    sname:VkDescriptorBufferInfo structure for storage buffers.
    When a descriptor of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC is updated, the
    pname:offset must: be an integer multiple of this limit.
    Similarly, dynamic offsets for storage buffers must: be multiples of
    this limit.
  * [[features-limits-minTexelOffset]] pname:minTexelOffset is the minimum
    offset value for the code:ConstOffset image operand of any of the
    code:OpImageSample* or code:OpImageFetch* image instructions.
  * [[features-limits-maxTexelOffset]] pname:maxTexelOffset is the maximum
    offset value for the code:ConstOffset image operand of any of the
    code:OpImageSample* or code:OpImageFetch* image instructions.
  * [[features-limits-minTexelGatherOffset]] pname:minTexelGatherOffset is
    the minimum offset value for the code:Offset or code:ConstOffsets image
    operands of any of the code:OpImage*code:Gather image instructions.
  * [[features-limits-maxTexelGatherOffset]] pname:maxTexelGatherOffset is
    the maximum offset value for the code:Offset or code:ConstOffsets image
    operands of any of the code:OpImage*code:Gather image instructions.
  * [[features-limits-minInterpolationOffset]] pname:minInterpolationOffset
    is the minimum negative offset value for the code:offset operand of the
    code:InterpolateAtOffset extended instruction.
  * [[features-limits-maxInterpolationOffset]] pname:maxInterpolationOffset
    is the maximum positive offset value for the code:offset operand of the
    code:InterpolateAtOffset extended instruction.
  * [[features-limits-subPixelInterpolationOffsetBits]]
    pname:subPixelInterpolationOffsetBits is the number of subpixel
    fractional bits that the code:x and code:y offsets to the
    code:InterpolateAtOffset extended instruction may: be rounded to as
    fixed-point values.
  * [[features-limits-maxFramebufferWidth]] pname:maxFramebufferWidth is the
    maximum width for a framebuffer.
    The pname:width member of the sname:VkFramebufferCreateInfo structure
    must: be less than or equal to this limit.
  * [[features-limits-maxFramebufferHeight]] pname:maxFramebufferHeight is
    the maximum height for a framebuffer.
    The pname:height member of the sname:VkFramebufferCreateInfo structure
    must: be less than or equal to this limit.
  * [[features-limits-maxFramebufferLayers]] pname:maxFramebufferLayers is
    the maximum layer count for a layered framebuffer.
    The pname:layers member of the sname:VkFramebufferCreateInfo structure
    must: be less than or equal to this limit.
  * [[features-limits-framebufferColorSampleCounts]]
    pname:framebufferColorSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the color sample counts that are
    supported for all framebuffer color attachments with floating- or
    fixed-point formats.
    There is no limit that specifies the color sample counts that are
    supported for all color attachments with integer formats.
  * [[features-limits-framebufferDepthSampleCounts]]
    pname:framebufferDepthSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the supported depth sample counts
    for all framebuffer depth/stencil attachments, when the format includes
    a depth component.
  * pname:framebufferStencilSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the supported stencil sample
    counts for all framebuffer depth/stencil attachments, when the format
    includes a stencil component.
  * pname:framebufferNoAttachmentsSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the supported sample counts for a
    framebuffer with no attachments.
  * [[features-limits-maxColorAttachments]] pname:maxColorAttachments is the
    maximum number of color attachments that can: be used by a subpass in a
    render pass.
    The pname:colorAttachmentCount member of the sname:VkSubpassDescription
    structure must: be less than or equal to this limit.
  * [[features-limits-sampledImageColorSampleCounts]]
    pname:sampledImageColorSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the sample counts supported for
    all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage
    containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a non-integer color
    format.
  * [[features-limits-sampledImageIntegerSampleCounts]]
    pname:sampledImageIntegerSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the sample counts supported for
    all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage
    containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and an integer color
    format.
  * [[features-limits-sampledImageDepthSampleCounts]]
    pname:sampledImageDepthSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the sample counts supported for
    all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage
    containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a depth format.
  * [[features-limits-sampledImageStencilSampleCounts]]
    pname:sampledImageStencilSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the sample supported for all 2D
    images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage
    containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a stencil format.
  * [[features-limits-storageImageSampleCounts]]
    pname:storageImageSampleCounts is a bitmask^1^ of
    elink:VkSampleCountFlagBits indicating the sample counts supported for
    all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, and
    pname:usage containing ename:VK_IMAGE_USAGE_STORAGE_BIT.
  * [[features-limits-maxSampleMaskWords]] pname:maxSampleMaskWords is the
    maximum number of array elements of a variable decorated with the
    code:SampleMask built-in decoration.
  * [[features-limits-timestampComputeAndGraphics]]
    pname:timestampComputeAndGraphics specifies support for timestamps on
    all graphics and compute queues.
    If this limit is set to ename:VK_TRUE, all queues that advertise the
    ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT in the
    sname:VkQueueFamilyProperties::pname:queueFlags support
    sname:VkQueueFamilyProperties::pname:timestampValidBits of at least 36.
    See <<queries-timestamps, Timestamp Queries>>.
  * [[features-limits-timestampPeriod]] pname:timestampPeriod is the number
    of nanoseconds required: for a timestamp query to be incremented by 1.
    See <<queries-timestamps, Timestamp Queries>>.
  * [[features-limits-maxClipDistances]] pname:maxClipDistances is the
    maximum number of clip distances that can: be used in a single shader
    stage.
    The size of any array declared with the code:ClipDistance built-in
    decoration in a shader module must: be less than or equal to this limit.
  * [[features-limits-maxCullDistances]] pname:maxCullDistances is the
    maximum number of cull distances that can: be used in a single shader
    stage.
    The size of any array declared with the code:CullDistance built-in
    decoration in a shader module must: be less than or equal to this limit.
  * [[features-limits-maxCombinedClipAndCullDistances]]
    pname:maxCombinedClipAndCullDistances is the maximum combined number of
    clip and cull distances that can: be used in a single shader stage.
    The sum of the sizes of any pair of arrays declared with the
    code:ClipDistance and code:CullDistance built-in decoration used by a
    single shader stage in a shader module must: be less than or equal to
    this limit.
  * [[features-limits-discreteQueuePriorities]]
    pname:discreteQueuePriorities is the number of discrete priorities that
    can: be assigned to a queue based on the value of each member of
    sname:VkDeviceQueueCreateInfo::pname:pQueuePriorities.
    This must: be at least 2, and levels must: be spread evenly over the
    range, with at least one level at 1.0, and another at 0.0.
    See <<devsandqueues-priority>>.
  * [[features-limits-pointSizeRange]] pname:pointSizeRange[2] is the range
    [eq]#[pname:minimum,pname:maximum]# of supported sizes for points.
    Values written to variables decorated with the code:PointSize built-in
    decoration are clamped to this range.
  * [[features-limits-lineWidthRange]] pname:lineWidthRange[2] is the range
    [eq]#[pname:minimum,pname:maximum]# of supported widths for lines.
    Values specified by the pname:lineWidth member of the
    sname:VkPipelineRasterizationStateCreateInfo or the pname:lineWidth
    parameter to fname:vkCmdSetLineWidth are clamped to this range.
  * [[features-limits-pointSizeGranularity]] pname:pointSizeGranularity is
    the granularity of supported point sizes.
    Not all point sizes in the range defined by pname:pointSizeRange are
    supported.
    This limit specifies the granularity (or increment) between successive
    supported point sizes.
  * [[features-limits-lineWidthGranularity]] pname:lineWidthGranularity is
    the granularity of supported line widths.
    Not all line widths in the range defined by pname:lineWidthRange are
    supported.
    This limit specifies the granularity (or increment) between successive
    supported line widths.
  * [[features-limits-strictLines]] pname:strictLines specifies whether
    lines are rasterized according to the preferred method of rasterization.
    If set to ename:VK_FALSE, lines may: be rasterized under a relaxed set
    of rules.
    If set to ename:VK_TRUE, lines are rasterized as per the strict
    definition.
    See <<primsrast-lines-basic,Basic Line Segment Rasterization>>.
  * [[features-limits-standardSampleLocations]]
    pname:standardSampleLocations specifies whether rasterization uses the
    standard sample locations as documented in
    <<primsrast-multisampling,Multisampling>>.
    If set to ename:VK_TRUE, the implementation uses the documented sample
    locations.
    If set to ename:VK_FALSE, the implementation may: use different sample
    locations.
  * [[features-limits-optimalBufferCopyOffsetAlignment]]
    pname:optimalBufferCopyOffsetAlignment is the optimal buffer offset
    alignment in bytes for fname:vkCmdCopyBufferToImage and
    fname:vkCmdCopyImageToBuffer.
    The per texel alignment requirements are enforced, but applications
    should: use the optimal alignment for optimal performance and power use.
  * [[features-limits-optimalBufferCopyRowPitchAlignment]]
    pname:optimalBufferCopyRowPitchAlignment is the optimal buffer row pitch
    alignment in bytes for fname:vkCmdCopyBufferToImage and
    fname:vkCmdCopyImageToBuffer.
    Row pitch is the number of bytes between texels with the same X
    coordinate in adjacent rows (Y coordinates differ by one).
    The per texel alignment requirements are enforced, but applications
    should: use the optimal alignment for optimal performance and power use.
  * [[features-limits-nonCoherentAtomSize]] pname:nonCoherentAtomSize is the
    size and alignment in bytes that bounds concurrent access to
    <<memory-device-hostaccess, host-mapped device memory>>.
ifdef::VK_EXT_discard_rectangles[]
  * [[features-limits-maxDiscardRectangles]]
    slink:VkPhysicalDeviceDiscardRectanglePropertiesEXT::pname:maxDiscardRectangles
    is the maximum number of active discard rectangles.
    This limit can be queried by setting the pname:pNext pointer from a
    slink:VkPhysicalDeviceProperties2 object to an instance of
    slink:VkPhysicalDeviceDiscardRectanglePropertiesEXT and using
    fname:vkGetPhysicalDeviceProperties2 to fill out the members.
endif::VK_EXT_discard_rectangles[]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
  * [[features-limits-pointClipping]]
    slink:VkPhysicalDevicePointClippingProperties::pname:pointClippingBehavior
    defines the clipping behavior of points.
    This limit can be queried by setting the pname:pNext pointer from a
    slink:VkPhysicalDeviceProperties2 object to an instance of
    slink:VkPhysicalDevicePointClippingProperties and using
    fname:vkGetPhysicalDeviceProperties2 to fill out the members.
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
ifdef::VK_EXT_vertex_attribute_divisor[]
  * [[features-limits-maxVertexAttribDivisor]]
    sname:VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::pname:maxVertexAttribDivisor
    is the maximum value of the number of instances that will repeat the
    value of vertex attribute data when instanced rendering is enabled.
    This limit can be queried by setting the pname:pNext pointer from a
    slink:VkPhysicalDeviceProperties2 object to an instance of
    slink:VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT and using
    fname:vkGetPhysicalDeviceProperties2 to fill out the members.
endif::VK_EXT_vertex_attribute_divisor[]


// refBody VkPhysicalDeviceLimits

1::
    For all bitmasks of elink:VkSampleCountFlagBits, the sample count limits
    defined above represent the minimum supported sample counts for each
    image type.
    Individual images may: support additional sample counts, which are
    queried using flink:vkGetPhysicalDeviceImageFormatProperties as
    described in <<features-supported-sample-counts, Supported Sample
    Counts>>.

include::../validity/structs/VkPhysicalDeviceLimits.txt[]
--


[open,refpage='VkSampleCountFlagBits',desc='Bitmask specifying sample counts supported for an image used for storage operations',type='enums']
--

Bits which may: be set in the sample count limits returned by
slink:VkPhysicalDeviceLimits, as well as in other queries and structures
representing image sample counts, are:

include::../api/enums/VkSampleCountFlagBits.txt[]

  * ename:VK_SAMPLE_COUNT_1_BIT specifies an image with one sample per
    pixel.
  * ename:VK_SAMPLE_COUNT_2_BIT specifies an image with 2 samples per pixel.
  * ename:VK_SAMPLE_COUNT_4_BIT specifies an image with 4 samples per pixel.
  * ename:VK_SAMPLE_COUNT_8_BIT specifies an image with 8 samples per pixel.
  * ename:VK_SAMPLE_COUNT_16_BIT specifies an image with 16 samples per
    pixel.
  * ename:VK_SAMPLE_COUNT_32_BIT specifies an image with 32 samples per
    pixel.
  * ename:VK_SAMPLE_COUNT_64_BIT specifies an image with 64 samples per
    pixel.

--

[open,refpage='VkSampleCountFlags',desc='Bitmask of VkSampleCountFlagBits',type='enums']
--
include::../api/flags/VkSampleCountFlags.txt[]

sname:VkSampleCountFlags is a bitmask type for setting a mask of zero or
more slink:VkSampleCountFlagBits.
--

ifdef::VK_KHR_push_descriptor[]

[open,refpage='VkPhysicalDevicePushDescriptorPropertiesKHR',desc='Structure describing push descriptor limits that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDevicePushDescriptorPropertiesKHR structure is defined
as:

include::../api/structs/VkPhysicalDevicePushDescriptorPropertiesKHR.txt[]

The members of the sname:VkPhysicalDevicePushDescriptorPropertiesKHR
structure describe the following implementation-dependent limits:

  * [[features-limits-maxPushDescriptors]] pname:maxPushDescriptors is the
    maximum number of descriptors that can: be used in a descriptor set
    created with
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set.

include::../validity/structs/VkPhysicalDevicePushDescriptorPropertiesKHR.txt[]

--

endif::VK_KHR_push_descriptor[]

ifdef::VK_VERSION_1_1,VK_KHR_multiview[]

[open,refpage='VkPhysicalDeviceMultiviewProperties',desc='Structure describing multiview limits that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceMultiviewProperties structure is defined as:

include::../api/structs/VkPhysicalDeviceMultiviewProperties.txt[]

ifdef::VK_KHR_multiview[]
or the equivalent

include::../api/structs/VkPhysicalDeviceMultiviewPropertiesKHR.txt[]
endif::VK_KHR_multiview[]

The members of the sname:VkPhysicalDeviceMultiviewProperties structure
describe the following implementation-dependent limits:

  * [[features-limits-maxMultiviewViewCount]] pname:maxMultiviewViewCount is
    one greater than the maximum view index that can: be used in a subpass.
  * [[features-limits-maxMultiviewInstanceIndex]]
    pname:maxMultiviewInstanceIndex is the maximum valid value of instance
    index allowed to be generated by a drawing command recorded within a
    subpass of a multiview render pass instance.

include::../validity/structs/VkPhysicalDeviceMultiviewProperties.txt[]

If the sname:VkPhysicalDeviceMultiviewProperties structure is included in
the pname:pNext chain of slink:VkPhysicalDeviceProperties2, it is filled
with the implementation-dependent limits.

--

endif::VK_VERSION_1_1,VK_KHR_multiview[]

ifdef::VK_EXT_discard_rectangles[]

[open,refpage='VkPhysicalDeviceDiscardRectanglePropertiesEXT',desc='Structure describing discard rectangle limits that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceDiscardRectanglePropertiesEXT structure is defined
as:

include::../api/structs/VkPhysicalDeviceDiscardRectanglePropertiesEXT.txt[]

The members of the sname:VkPhysicalDeviceDiscardRectanglePropertiesEXT
structure describe the following implementation-dependent limits:

  * pname:maxDiscardRectangles is the maximum number of discard rectangles
    that can: be specified.

include::../validity/structs/VkPhysicalDeviceDiscardRectanglePropertiesEXT.txt[]

If the sname:VkPhysicalDeviceDiscardRectanglePropertiesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceProperties2, it
is filled with the implementation-dependent limits.

--

endif::VK_EXT_discard_rectangles[]

ifdef::VK_EXT_sample_locations[]

[open,refpage='VkPhysicalDeviceSampleLocationsPropertiesEXT',desc='Structure describing sample location limits that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceSampleLocationsPropertiesEXT structure is defined
as:

include::../api/structs/VkPhysicalDeviceSampleLocationsPropertiesEXT.txt[]

The members of the sname:VkPhysicalDeviceSampleLocationsPropertiesEXT
structure describe the following implementation-dependent limits:

  * [[features-limits-sampleLocationSampleCounts]]
    pname:sampleLocationSampleCounts is a bitmask of
    elink:VkSampleCountFlagBits indicating the sample counts supporting
    custom sample locations.
  * [[features-limits-maxSampleLocationGridSize]]
    pname:maxSampleLocationGridSize is the maximum size of the pixel grid in
    which sample locations can: vary that is supported for all sample counts
    in pname:sampleLocationSampleCounts.
  * [[features-limits-sampleLocationCoordinateRange]]
    pname:sampleLocationCoordinateRange[2] is the range of supported sample
    location coordinates.
  * [[features-limits-sampleLocationSubPixelBits]]
    pname:sampleLocationSubPixelBits is the number of bits of subpixel
    precision for sample locations.
  * [[features-limits-variableSampleLocations]]
    pname:variableSampleLocations specifies whether the sample locations
    used by all pipelines that will be bound to a command buffer during a
    subpass must: match.
    If set to ename:VK_TRUE, the implementation supports variable sample
    locations in a subpass.
    If set to ename:VK_FALSE, then the sample locations must: stay constant
    in each subpass.

include::../validity/structs/VkPhysicalDeviceSampleLocationsPropertiesEXT.txt[]

If the sname:VkPhysicalDeviceSampleLocationsPropertiesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceProperties2, it
is filled with the implementation-dependent limits.

--

endif::VK_EXT_sample_locations[]

ifdef::VK_EXT_external_memory_host[]

[open,refpage='VkPhysicalDeviceExternalMemoryHostPropertiesEXT',desc='Structure describing external memory host pointer limits that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceExternalMemoryHostPropertiesEXT structure is
defined as:

include::../api/structs/VkPhysicalDeviceExternalMemoryHostPropertiesEXT.txt[]

The members of the sname:VkPhysicalDeviceExternalMemoryHostPropertiesEXT
structure describe the following implementation-dependent limits:

  * [[features-limits-minImportedHostPointerAlignment]]
    pname:minImportedHostPointerAlignment is the minimum required:
    alignment, in bytes, for the base address and size of host pointers that
    can: be imported to a Vulkan memory object.

include::../validity/structs/VkPhysicalDeviceExternalMemoryHostPropertiesEXT.txt[]

If the sname:VkPhysicalDeviceExternalMemoryHostPropertiesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceProperties2KHR,
it is filled with the implementation-dependent limits.

--

endif::VK_EXT_external_memory_host[]

ifdef::VK_NVX_multiview_per_view_attributes[]

[open,refpage='VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX',desc='Structure describing multiview limits that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX structure
is defined as:

include::../api/structs/VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.txt[]

The members of the
sname:VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX structure
describe the following implementation-dependent limits:

  * [[features-limits-perViewPositionAllComponents]]
    pname:perViewPositionAllComponents is ename:VK_TRUE if the
    implementation supports per-view position values that differ in
    components other than the X component.

include::../validity/structs/VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.txt[]

If the sname:VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX
structure is included in the pname:pNext chain of
slink:VkPhysicalDeviceProperties2, it is filled with the
implementation-dependent limits.

--

endif::VK_NVX_multiview_per_view_attributes[]

ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]

[open,refpage='VkPhysicalDevicePointClippingProperties',desc='Structure describing the point clipping behavior supported by an implementation',type='structs']
--

The sname:VkPhysicalDevicePointClippingProperties structure is defined as:

include::../api/structs/VkPhysicalDevicePointClippingProperties.txt[]

ifdef::VK_KHR_maintenance2[]
or the equivalent

include::../api/structs/VkPhysicalDevicePointClippingPropertiesKHR.txt[]
endif::VK_KHR_maintenance2[]

The members of the sname:VkPhysicalDevicePointClippingProperties structure
describe the following implementation-dependent limit:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:pointClippingBehavior is the point clipping behavior supported by
    the implementation, and is of type elink:VkPointClippingBehavior.

If the sname:VkPhysicalDevicePointClippingProperties structure is included
in the pname:pNext chain of flink:VkPhysicalDeviceProperties2, it is filled
with the implementation-dependent limits.

include::../validity/structs/VkPhysicalDevicePointClippingProperties.txt[]

--

endif::VK_VERSION_1_1,VK_KHR_maintenance2[]

ifdef::VK_VERSION_1_1[]

[open,refpage='VkPhysicalDeviceSubgroupProperties',desc='Structure describing subgroup support for an implementation',type='structs']
--

The sname:VkPhysicalDeviceSubgroupProperties structure is defined as:

include::../api/structs/VkPhysicalDeviceSubgroupProperties.txt[]

The members of the sname:VkPhysicalDeviceSubgroupProperties structure
describe the following implementation-dependent limits:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:subgroupSize is the number of invocations in each subgroup.
    This will match any <<interfaces-builtin-variables-sgs,
    code:SubgroupSize>> decorated variable used in any shader module created
    on this device.
    pname:subgroupSize is at least 1 if any of the physical device's queues
    support ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT.
  * pname:supportedStages is a bitfield of elink:VkShaderStageFlagBits
    describing the shader stages that subgroup operations are supported in.
    pname:supportedStages will have the ename:VK_SHADER_STAGE_COMPUTE_BIT
    bit set if any of the physical device's queues support
    ename:VK_QUEUE_COMPUTE_BIT.
  * pname:supportedOperations is a bitmask of
    elink:VkSubgroupFeatureFlagBits specifying the sets of subgroup
    operations supported on this device.
    pname:supportedOperations will have the
    ename:VK_SUBGROUP_FEATURE_BASIC_BIT bit set if any of the physical
    device's queues support ename:VK_QUEUE_GRAPHICS_BIT or
    ename:VK_QUEUE_COMPUTE_BIT.
  * pname:quadOperationsInAllStages is a boolean that specifies whether
    <<features-features-subgroup-quad,quad subgroup operations>> are
    available in all stages, or are restricted to fragment and compute
    stages.

include::../validity/structs/VkPhysicalDeviceSubgroupProperties.txt[]

If the sname:VkPhysicalDeviceSubgroupProperties structure is included in the
pname:pNext chain of slink:VkPhysicalDeviceProperties2, it is filled with
the implementation-dependent limits.

--

[open,refpage='VkSubgroupFeatureFlagBits',desc='Enum describing what subgroup operations are supported',type='enums']
--

Bits which can: be set in
slink:VkPhysicalDeviceSubgroupProperties::pname:supportedOperations to
specify supported subgroup operations are:

include::../api/enums/VkSubgroupFeatureFlagBits.txt[]

  * [[features-features-subgroup-basic]] ename:VK_SUBGROUP_FEATURE_BASIC_BIT
    specifies the device will accept SPIR-V shader modules that contain the
    code:GroupNonUniform capability.
  * [[features-features-subgroup-vote]] ename:VK_SUBGROUP_FEATURE_VOTE_BIT
    specifies the device will accept SPIR-V shader modules that contain the
    code:GroupNonUniformVote capability.
  * [[features-features-subgroup-arithmetic]]
    ename:VK_SUBGROUP_FEATURE_ARITHMETIC_BIT specifies the device will
    accept SPIR-V shader modules that contain the
    code:GroupNonUniformArithmetic capability.
  * [[features-features-subgroup-ballot]]
    ename:VK_SUBGROUP_FEATURE_BALLOT_BIT specifies the device will accept
    SPIR-V shader modules that contain the code:GroupNonUniformBallot
    capability.
  * [[features-features-subgroup-shuffle]]
    ename:VK_SUBGROUP_FEATURE_SHUFFLE_BIT specifies the device will accept
    SPIR-V shader modules that contain the code:GroupNonUniformShuffle
    capability.
  * [[features-features-subgroup-shuffle-relative]]
    ename:VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT specifies the device will
    accept SPIR-V shader modules that contain the
    code:GroupNonUniformShuffleRelative capability.
  * [[features-features-subgroup-clustered]]
    ename:VK_SUBGROUP_FEATURE_CLUSTERED_BIT specifies the device will accept
    SPIR-V shader modules that contain the code:GroupNonUniformClustered
    capability.
  * [[features-features-subgroup-quad]] ename:VK_SUBGROUP_FEATURE_QUAD_BIT
    specifies the device will accept SPIR-V shader modules that contain the
    code:GroupNonUniformQuad capability.
ifdef::VK_NV_shader_subgroup_partitioned[]
  * [[features-features-subgroup-partitioned]]
    ename:VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV specifies the device will
    accept SPIR-V shader modules that contain the
    code:GroupNonUniformPartitionedNV capability.
endif::VK_NV_shader_subgroup_partitioned[]

--

[open,refpage='VkSubgroupFeatureFlags',desc='Bitmask of VkSubgroupFeatureFlagBits',type='enums']
--
include::../api/flags/VkSubgroupFeatureFlags.txt[]

sname:VkSubgroupFeatureFlags is a bitmask type for setting a mask of zero or
more slink:VkSubgroupFeatureFlagBits.
--

endif::VK_VERSION_1_1[]

ifdef::VK_EXT_blend_operation_advanced[]

[open,refpage='VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT',desc='Structure describing advanced blending limits that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT structure is
defined as:

include::../api/structs/VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.txt[]

The members of the sname:VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT
structure describe the following implementation-dependent limits:

  * [[features-limits-advancedBlendMaxColorAttachments]]
    pname:advancedBlendMaxColorAttachments is one greater than the highest
    color attachment index that can: be used in a subpass, for a pipeline
    that uses an <<framebuffer-blend-advanced,advanced blend operation>>.
  * [[features-limits-advancedBlendIndependentBlend]]
    pname:advancedBlendIndependentBlend specifies whether advanced blend
    operations can: vary per-attachment.
  * [[features-limits-advancedBlendNonPremultipliedSrcColor]]
    pname:advancedBlendNonPremultipliedSrcColor specifies whether the source
    color can: be treated as non-premultiplied.
    If this is ename:VK_FALSE, then
    slink:VkPipelineColorBlendAdvancedStateCreateInfoEXT::pname:srcPremultiplied
    must: be ename:VK_TRUE.
  * [[features-limits-advancedBlendNonPremultipliedDstColor]]
    pname:advancedBlendNonPremultipliedDstColor specifies whether the
    destination color can: be treated as non-premultiplied.
    If this is ename:VK_FALSE, then
    slink:VkPipelineColorBlendAdvancedStateCreateInfoEXT::pname:dstPremultiplied
    must: be ename:VK_TRUE.
  * [[features-limits-advancedBlendCorrelatedOverlap]]
    pname:advancedBlendCorrelatedOverlap specifies whether the overlap mode
    can: be treated as correlated.
    If this is ename:VK_FALSE, then
    slink:VkPipelineColorBlendAdvancedStateCreateInfoEXT::pname:blendOverlap
    must: be ename:VK_BLEND_OVERLAP_UNCORRELATED_EXT.
  * [[features-limits-advancedBlendAllOperations]]
    pname:advancedBlendAllOperations specifies whether all advanced blend
    operation enums are supported.
    See the valid usage of slink:VkPipelineColorBlendAttachmentState.

include::../validity/structs/VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.txt[]

If the sname:VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT structure
is included in the pname:pNext chain of slink:VkPhysicalDeviceProperties2,
it is filled with the implementation-dependent limits.
--

endif::VK_EXT_blend_operation_advanced[]

ifdef::VK_EXT_vertex_attribute_divisor[]

[open,refpage='VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT',desc='Structure describing max value of vertex attribute divisor that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure is
defined as:

include::../api/structs/VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.txt[]

The members of the sname:VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT
structure describe the following implementation-dependent limits:

  * [[features-limits-maxVertexAttribDivisor]] pname:maxVertexAttribDivisor
    is the maximum value of the number of instances that will repeat the
    value of vertex attribute data when instanced rendering is enabled.

include::../validity/structs/VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.txt[]

--

endif::VK_EXT_vertex_attribute_divisor[]

ifdef::VK_EXT_sampler_filter_minmax[]

[open,refpage='VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT',desc='Structure describing sampler filter minmax limits that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT structure is
defined as:

include::../api/structs/VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.txt[]

The members of the sname:VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT
structure describe the following implementation-dependent limits:

  * [[features-limits-filterMinmaxSingleComponentFormats]]
    pname:filterMinmaxSingleComponentFormats is a boolean value indicating
    whether a minimum set of required formats support min/max filtering.
  * [[features-limits-filterMinmaxImageComponentMapping]]
    pname:filterMinmaxImageComponentMapping is a boolean value indicating
    whether the implementation supports non-identity component mapping of
    the image when doing min/max filtering.

If the sname:VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceProperties2, it
is filled with the implementation-dependent limits.

If pname:filterMinmaxSingleComponentFormats is ename:VK_TRUE, the following
formats must: support the
ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT feature with
ename:VK_IMAGE_TILING_OPTIMAL, if they support
ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT.

  * ename:VK_FORMAT_R8_UNORM
  * ename:VK_FORMAT_R8_SNORM
  * ename:VK_FORMAT_R16_UNORM
  * ename:VK_FORMAT_R16_SNORM
  * ename:VK_FORMAT_R16_SFLOAT
  * ename:VK_FORMAT_R32_SFLOAT
  * ename:VK_FORMAT_D16_UNORM
  * ename:VK_FORMAT_X8_D24_UNORM_PACK32
  * ename:VK_FORMAT_D32_SFLOAT
  * ename:VK_FORMAT_D16_UNORM_S8_UINT
  * ename:VK_FORMAT_D24_UNORM_S8_UINT
  * ename:VK_FORMAT_D32_SFLOAT_S8_UINT

If the format is a depth/stencil format, this bit only specifies that the
depth aspect (not the stencil aspect) of an image of this format supports
min/max filtering, and that min/max filtering of the depth aspect is
supported when depth compare is disabled in the sampler.

If pname:filterMinmaxImageComponentMapping is ename:VK_FALSE the component
mapping of the image view used with min/max filtering must: have been
created with the pname:r component set to
ename:VK_COMPONENT_SWIZZLE_IDENTITY.
Only the pname:r component of the sampled image value is defined and the
other component values are undefined.
If pname:filterMinmaxImageComponentMapping is ename:VK_TRUE this restriction
does not apply and image component mapping works as normal.

include::../validity/structs/VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.txt[]
--

endif::VK_EXT_sampler_filter_minmax[]

ifdef::VK_VERSION_1_1[]

[open,refpage='VkPhysicalDeviceProtectedMemoryProperties',desc='Structure describing protected memory properties that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceProtectedMemoryProperties structure is defined as:

include::../api/structs/VkPhysicalDeviceProtectedMemoryProperties.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:protectedNoFault specifies whether the undefined behavior will not
    include process termination or device loss.
    If pname:protectedNoFault is ename:VK_FALSE, undefined behavior may:
    include process termination or device loss.
    If pname:protectedNoFault is ename:VK_TRUE, undefined behavior will not
    include process termination or device loss.

If the sname:VkPhysicalDeviceProtectedMemoryProperties structure is included
in the pname:pNext chain of flink:VkPhysicalDeviceProperties2, it is filled
with a value indicating the implementation-dependent behavior.

include::../validity/structs/VkPhysicalDeviceProtectedMemoryProperties.txt[]

--

endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1,VK_KHR_maintenance3[]

[open,refpage='VkPhysicalDeviceMaintenance3Properties',desc='Structure describing descriptor set properties',type='structs']
--
The sname:VkPhysicalDeviceMaintenance3Properties structure is defined as:

include::../api/structs/VkPhysicalDeviceMaintenance3Properties.txt[]

ifdef::VK_KHR_maintenance3[]
or the equivalent

include::../api/structs/VkPhysicalDeviceMaintenance3PropertiesKHR.txt[]
endif::VK_KHR_maintenance3[]

The members of the sname:VkPhysicalDeviceMaintenance3Properties structure
describe the following implementation-dependent limits:

  * [[features-limits-maxPerSetDescriptors]] pname:maxPerSetDescriptors is a
    maximum number of descriptors (summed over all descriptor types) in a
    single descriptor set that is guaranteed to satisfy any
    implementation-dependent constraints on the size of a descriptor set
    itself.
    Applications can: query whether a descriptor set that goes beyond this
    limit is supported using flink:vkGetDescriptorSetLayoutSupport.
  * [[features-limits-maxMemoryAllocationSize]]
    pname:maxMemoryAllocationSize is the maximum size of a memory allocation
    that can: be created, even if there is more space available in the heap.

If the sname:VkPhysicalDeviceMaintenance3Properties structure is included in
the pname:pNext chain of slink:VkPhysicalDeviceProperties2, it is filled
with the implementation-dependent limits.

include::../validity/structs/VkPhysicalDeviceMaintenance3Properties.txt[]
--

endif::VK_VERSION_1_1,VK_KHR_maintenance3[]

ifdef::VK_EXT_descriptor_indexing[]

[open,refpage='VkPhysicalDeviceDescriptorIndexingPropertiesEXT',desc='Structure describing descriptor indexing properties that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDescriptorIndexingPropertiesEXT structure is
defined as:

include::../api/structs/VkPhysicalDeviceDescriptorIndexingPropertiesEXT.txt[]

The members of the sname:VkPhysicalDeviceDescriptorIndexingPropertiesEXT
structure describe the following implementation-dependent limits:

  * [[features-limits-maxUpdateAfterBindDescriptorsInAllPools]]
    pname:maxUpdateAfterBindDescriptorsInAllPools is the maximum number of
    descriptors (summed over all descriptor types) that can: be created
    across all pools that are created with the
    ename:VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT bit set.
    Pool creation may: fail when this limit is exceeded, or when the space
    this limit represents is unable to satisfy a pool creation due to
    fragmentation.
  * [[features-limits-shaderUniformBufferArrayNonUniformIndexingNative]]
    pname:shaderUniformBufferArrayNonUniformIndexingNative is a boolean
    value indicating whether uniform buffer descriptors natively support
    nonuniform indexing.
    If this is ename:VK_FALSE, then a single dynamic instance of an
    instruction that nonuniformly indexes an array of uniform buffers may:
    execute multiple times in order to access all the descriptors.
  * [[features-limits-shaderSampledImageArrayNonUniformIndexingNative]]
    pname:shaderSampledImageArrayNonUniformIndexingNative is a boolean value
    indicating whether sampler and image descriptors natively support
    nonuniform indexing.
    If this is ename:VK_FALSE, then a single dynamic instance of an
    instruction that nonuniformly indexes an array of samplers or images
    may: execute multiple times in order to access all the descriptors.
  * [[features-limits-shaderStorageBufferArrayNonUniformIndexingNative]]
    pname:shaderStorageBufferArrayNonUniformIndexingNative is a boolean
    value indicating whether storage buffer descriptors natively support
    nonuniform indexing.
    If this is ename:VK_FALSE, then a single dynamic instance of an
    instruction that nonuniformly indexes an array of storage buffers may:
    execute multiple times in order to access all the descriptors.
  * [[features-limits-shaderStorageImageArrayNonUniformIndexingNative]]
    pname:shaderStorageImageArrayNonUniformIndexingNative is a boolean value
    indicating whether storage image descriptors natively support nonuniform
    indexing.
    If this is ename:VK_FALSE, then a single dynamic instance of an
    instruction that nonuniformly indexes an array of storage images may:
    execute multiple times in order to access all the descriptors.
  * [[features-limits-shaderInputAttachmentArrayNonUniformIndexingNative]]
    pname:shaderInputAttachmentArrayNonUniformIndexingNative is a boolean
    value indicating whether input attachment descriptors natively support
    nonuniform indexing.
    If this is ename:VK_FALSE, then a single dynamic instance of an
    instruction that nonuniformly indexes an array of input attachments may:
    execute multiple times in order to access all the descriptors.
  * [[features-limits-robustBufferAccessUpdateAfterBind]]
    pname:robustBufferAccessUpdateAfterBind is a boolean value indicating
    whether <<features-features-robustBufferAccess,
    pname:robustBufferAccess>> can: be enabled in a device simultaneously
    with pname:descriptorBindingUniformBufferUpdateAfterBind,
    pname:descriptorBindingStorageBufferUpdateAfterBind,
    pname:descriptorBindingUniformTexelBufferUpdateAfterBind, and/or
    pname:descriptorBindingStorageTexelBufferUpdateAfterBind.
    If this is ename:VK_FALSE, then either pname:robustBufferAccess must: be
    disabled or all of these update-after-bind features must: be disabled.
  * [[features-limits-quadDivergentImplicitLod]]
    pname:quadDivergentImplicitLod is a boolean value indicating whether
    implicit level of detail calculations for image operations have
    well-defined results when the image and/or sampler objects used for the
    instruction are not uniform within a quad.
    See <<textures-derivative-image-operations,Derivative Image
    Operations>>.
  * [[features-limits-maxPerStageDescriptorUpdateAfterBindSamplers]]
    pname:maxPerStageDescriptorUpdateAfterBindSamplers is similar to
    pname:maxPerStageDescriptorSamplers but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxPerStageDescriptorUpdateAfterBindUniformBuffers]]
    pname:maxPerStageDescriptorUpdateAfterBindUniformBuffers is similar to
    pname:maxPerStageDescriptorUniformBuffers but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxPerStageDescriptorUpdateAfterBindStorageBuffers]]
    pname:maxPerStageDescriptorUpdateAfterBindStorageBuffers is similar to
    pname:maxPerStageDescriptorStorageBuffers but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxPerStageDescriptorUpdateAfterBindSampledImages]]
    pname:maxPerStageDescriptorUpdateAfterBindSampledImages is similar to
    pname:maxPerStageDescriptorSampledImages but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxPerStageDescriptorUpdateAfterBindStorageImages]]
    pname:maxPerStageDescriptorUpdateAfterBindStorageImages is similar to
    pname:maxPerStageDescriptorStorageImages but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxPerStageDescriptorUpdateAfterBindInputAttachments]]
    pname:maxPerStageDescriptorUpdateAfterBindInputAttachments is similar to
    pname:maxPerStageDescriptorInputAttachments but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxPerStageUpdateAfterBindResources]]
    pname:maxPerStageUpdateAfterBindResources is similar to
    pname:maxPerStageResources but counts descriptors from descriptor sets
    created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxDescriptorSetUpdateAfterBindSamplers]]
    pname:maxDescriptorSetUpdateAfterBindSamplers is similar to
    pname:maxDescriptorSetSamplers but counts descriptors from descriptor
    sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxDescriptorSetUpdateAfterBindUniformBuffers]]
    pname:maxDescriptorSetUpdateAfterBindUniformBuffers is similar to
    pname:maxDescriptorSetUniformBuffers but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxDescriptorSetUpdateAfterBindUniformBuffersDynamic]]
    pname:maxDescriptorSetUpdateAfterBindUniformBuffersDynamic is similar to
    pname:maxDescriptorSetUniformBuffersDynamic but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxDescriptorSetUpdateAfterBindStorageBuffers]]
    pname:maxDescriptorSetUpdateAfterBindStorageBuffers is similar to
    pname:maxDescriptorSetStorageBuffers but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxDescriptorSetUpdateAfterBindStorageBuffersDynamic]]
    pname:maxDescriptorSetUpdateAfterBindStorageBuffersDynamic is similar to
    pname:maxDescriptorSetStorageBuffersDynamic but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxDescriptorSetUpdateAfterBindSampledImages]]
    pname:maxDescriptorSetUpdateAfterBindSampledImages is similar to
    pname:maxDescriptorSetSampledImages but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxDescriptorSetUpdateAfterBindStorageImages]]
    pname:maxDescriptorSetUpdateAfterBindStorageImages is similar to
    pname:maxDescriptorSetStorageImages but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.
  * [[features-limits-maxDescriptorSetUpdateAfterBindInputAttachments]]
    pname:maxDescriptorSetUpdateAfterBindInputAttachments is similar to
    pname:maxDescriptorSetInputAttachments but counts descriptors from
    descriptor sets created with or without the
    ename:VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    set.

If the sname:VkPhysicalDeviceDescriptorIndexingPropertiesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceProperties2KHR,
it is filled with the implementation-dependent limits.

include::../validity/structs/VkPhysicalDeviceDescriptorIndexingPropertiesEXT.txt[]
--

endif::VK_EXT_descriptor_indexing[]


ifdef::VK_EXT_conservative_rasterization[]

[open,refpage='VkPhysicalDeviceConservativeRasterizationPropertiesEXT',desc='Structure describing conservative raster properties that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceConservativeRasterizationPropertiesEXT structure
is defined as:

include::../api/structs/VkPhysicalDeviceConservativeRasterizationPropertiesEXT.txt[]

The members of the
sname:VkPhysicalDeviceConservativeRasterizationPropertiesEXT structure
describe the following implementation-dependent limits:

  * [[features-limits-primitiveOverestimationSize]]
    pname:primitiveOverestimationSize is the size in pixels the generating
    primitive is increased at each of its edges during conservative
    rasterization overestimation mode.
    Even with a size of 0.0, conservative rasterization overestimation rules
    still apply and if any part of the pixel rectangle is covered by the
    generating primitive, fragments are generated for the entire pixel.
    However implementations may: make the pixel coverage area even more
    conservative by increasing the size of the generating primitive.

  * [[features-limits-maxExtraPrimitiveOverestimationSize]]
    pname:maxExtraPrimitiveOverestimationSize is the maximum size in pixels
    of extra overestimation the implementation supports in the pipeline
    state.
    A value of 0.0 means the implementation does not support any additional
    overestimation of the generating primitive during conservative
    rasterization.
    A value above 0.0 allows the application to further increase the size of
    the generating primitive during conservative rasterization
    overestimation.

  * [[features-limits-extraPrimitiveOverestimationSizeGranularity]]
    pname:extraPrimitiveOverestimationSizeGranularity is the granularity of
    extra overestimation that can be specified in the pipeline state between
    0.0 and pname:maxExtraPrimitiveOverestimationSize inclusive.
    A value of 0.0 means the implementation can use the smallest
    representable non-zero value in the screen space pixel fixed-point grid.

  * [[features-limits-primitiveUnderestimation]]
    pname:primitiveUnderestimation is true if the implementation supports
    the ename:VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT
    conservative rasterization mode in addition to
    ename:VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT.
    Otherwise the implementation only supports
    ename:VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT.

  * [[features-limits-conservativePointAndLineRasterization]]
    pname:conservativePointAndLineRasterization is true if the
    implementation supports conservative rasterization of point and line
    primitives as well as triangle primitives.
    Otherwise the implementation only supports triangle primitives.

  * [[features-limits-degenerateTrianglesRasterized]]
    pname:degenerateTrianglesRasterized is false if the implementation culls
    primitives generated from triangles that become zero area after they are
    quantized to the fixed-point rasterization pixel grid.
    pname:degenerateTrianglesRasterized is true if these primitives are not
    culled and the provoking vertex attributes and depth value are used for
    the fragments.
    The primitive area calculation is done on the primitive generated from
    the clipped triangle if applicable.
    Zero area primitives are backfacing and the application can: enable
    backface culling if desired.

  * [[features-limits-degenerateLinesRasterized]]
    pname:degenerateLinesRasterized is false if the implementation culls
    lines that become zero length after they are quantized to the
    fixed-point rasterization pixel grid.
    pname:degenerateLinesRasterized is true if zero length lines are not
    culled and the provoking vertex attributes and depth value are used for
    the fragments.

  * [[features-limits-fullyCoveredFragmentShaderInputVariable]]
    pname:fullyCoveredFragmentShaderInputVariable is true if the
    implementation supports the SPIR-V builtin fragment shader input
    variable FullyCoveredEXT which specifies that conservative rasterization
    is enabled and the fragment pixel square is fully covered by the
    generating primitive.

  * [[features-limits-conservativeRasterizationPostDepthCoverage]]
ifdef::VK_EXT_post_depth_coverage[]
    pname:conservativeRasterizationPostDepthCoverage is true if the
    implementation supports conservative rasterization with the
    <<shaders-fragment-earlytest-postdepthcoverage,code:PostDepthCoverage>>
    execution mode enabled.
    When supported the code:SampleMask built-in input variable will reflect
    the coverage after the early per-fragment depth and stencil tests are
    applied even when conservative rasterization is enabled.
    Otherwise
    <<shaders-fragment-earlytest-postdepthcoverage,code:PostDepthCoverage>>
    execution mode must: not be used when conservative rasterization is
    enabled.
endif::VK_EXT_post_depth_coverage[]
ifndef::VK_EXT_post_depth_coverage[]
    pname:conservativeRasterizationPostDepthCoverage must: be false.
endif::VK_EXT_post_depth_coverage[]

include::../validity/structs/VkPhysicalDeviceConservativeRasterizationPropertiesEXT.txt[]

If the sname:VkPhysicalDeviceConservativeRasterizationPropertiesEXT
structure is included in the pname:pNext chain of
slink:VkPhysicalDeviceProperties2KHR, it is filled with the
implementation-dependent limits and properties.

--

endif::VK_EXT_conservative_rasterization[]


ifdef::VK_AMD_shader_core_properties[]

[open,refpage='VkPhysicalDeviceShaderCorePropertiesAMD',desc='Structure describing shader core properties that can be supported by an implementation',type='structs']
--

The sname:VkPhysicalDeviceShaderCorePropertiesAMD structure is defined as:

include::../api/structs/VkPhysicalDeviceShaderCorePropertiesAMD.txt[]

The members of the sname:VkPhysicalDeviceShaderCorePropertiesAMD structure
describe the following implementation-dependent limits:

  * [[features-limits-shaderEngineCount]] pname:shaderEngineCount is an
    unsigned integer value indicating the number of shader engines found
    inside the shader core of the physical device.
  * [[features-limits-shaderArraysPerEngineCount]]
    pname:shaderArraysPerEngineCount is an unsigned integer value indicating
    the number of shader arrays inside a shader engine.
    Each shader array has its own scan converter, set of compute units, and
    a render back end (color and depth buffers).
    Shader arrays within a shader engine share shader processor input (wave
    launcher) and shader export (export buffer) units.
    Currently, a shader engine can have one or two shader arrays.
  * [[features-limits-computeUnitsPerShaderArray]]
    pname:computeUnitsPerShaderArray is an unsigned integer value indicating
    the number of compute units within a shader array.
    A compute unit houses a set of SIMDs along with a sequencer module and a
    local data store.
  * [[features-limits-simdPerComputeUnit]] pname:simdPerComputeUnit is an
    unsigned integer value indicating the number of SIMDs inside a compute
    unit.
    Each SIMD processes a single instruction at a time.
  * [[features-limits-wavefrontSize]] pname:wavefrontSize is an unsigned
    integer value indicating the number of channels (or threads) in a
    wavefront.
  * [[features-limits-sgprsPerSimd]] pname:sgprsPerSimd is an unsigned
    integer value indicating the number of physical Scalar General Purpose
    Registers (SGPRs) per SIMD.
  * [[features-limits-minSgprAllocation]] pname:minSgprAllocation is an
    unsigned integer value indicating the minimum number of SGPRs allocated
    for a wave.
  * [[features-limits-maxSgprAllocation]] pname:maxSgprAllocation is an
    unsigned integer value indicating the maximum number of SGPRs allocated
    for a wave.
  * [[features-limits-sgprAllocationGranularity]]
    pname:sgprAllocationGranularity is an unsigned integer value indicating
    the granularity of SGPR allocation for a wave.
  * [[features-limits-vgprsPerSimd]] pname:vgprsPerSimd is an unsigned
    integer value indicating the number of physical Vector General Purpose
    Registers (VGPRs) per SIMD.
  * [[features-limits-minVgprAllocation]] pname:minVgprAllocation is an
    unsigned integer value indicating the minimum number of VGPRs allocated
    for a wave.
  * [[features-limits-maxVgprAllocation]] pname:maxVgprAllocation is an
    unsigned integer value indicating the maximum number of VGPRs allocated
    for a wave.
  * [[features-limits-vgprAllocationGranularity]]
    pname:vgprAllocationGranularity is an unsigned integer value indicating
    the granularity of VGPR allocation for a wave.

include::../validity/structs/VkPhysicalDeviceShaderCorePropertiesAMD.txt[]

If the sname:VkPhysicalDeviceShaderCorePropertiesAMD structure is included
in the pname:pNext chain of slink:VkPhysicalDeviceProperties2, it is filled
with the implementation-dependent limits.

--

endif::VK_AMD_shader_core_properties[]

[[features-limits-minmax]]
=== Limit Requirements

The following table specifies the required: minimum/maximum for all Vulkan
graphics implementations.
Where a limit corresponds to a fine-grained device feature which is
optional:, the feature name is listed with two required: limits, one when
the feature is supported and one when it is not supported.
If an implementation supports a feature, the limits reported are the same
whether or not the feature is enabled.

[[features-limits-types]]
.Required Limit Types
[width="100%",cols="<20%,<50%,<30%",options="header"]
|====
| Type                     | Limit                                      | Feature
| code:uint32_t            | pname:maxImageDimension1D                  | -
| code:uint32_t            | pname:maxImageDimension2D                  | -
| code:uint32_t            | pname:maxImageDimension3D                  | -
| code:uint32_t            | pname:maxImageDimensionCube                | -
| code:uint32_t            | pname:maxImageArrayLayers                  | -
| code:uint32_t            | pname:maxTexelBufferElements               | -
| code:uint32_t            | pname:maxUniformBufferRange                | -
| code:uint32_t            | pname:maxStorageBufferRange                | -
| code:uint32_t            | pname:maxPushConstantsSize                 | -
| code:uint32_t            | pname:maxMemoryAllocationCount             | -
| code:uint32_t            | pname:maxSamplerAllocationCount            | -
| basetype:VkDeviceSize    | pname:bufferImageGranularity               | -
| basetype:VkDeviceSize    | pname:sparseAddressSpaceSize               | sparseBinding
| code:uint32_t            | pname:maxBoundDescriptorSets               | -
| code:uint32_t            | pname:maxPerStageDescriptorSamplers        | -
| code:uint32_t            | pname:maxPerStageDescriptorUniformBuffers  | -
| code:uint32_t            | pname:maxPerStageDescriptorStorageBuffers  | -
| code:uint32_t            | pname:maxPerStageDescriptorSampledImages   | -
| code:uint32_t            | pname:maxPerStageDescriptorStorageImages   | -
| code:uint32_t            | pname:maxPerStageDescriptorInputAttachments| -
| code:uint32_t            | pname:maxPerStageResources                 | -
| code:uint32_t            | pname:maxDescriptorSetSamplers             | -
| code:uint32_t            | pname:maxDescriptorSetUniformBuffers       | -
| code:uint32_t            | pname:maxDescriptorSetUniformBuffersDynamic| -
| code:uint32_t            | pname:maxDescriptorSetStorageBuffers       | -
| code:uint32_t            | pname:maxDescriptorSetStorageBuffersDynamic| -
| code:uint32_t            | pname:maxDescriptorSetSampledImages        | -
| code:uint32_t            | pname:maxDescriptorSetStorageImages        | -
| code:uint32_t            | pname:maxDescriptorSetInputAttachments     | -
| code:uint32_t            | pname:maxVertexInputAttributes             | -
| code:uint32_t            | pname:maxVertexInputBindings               | -
| code:uint32_t            | pname:maxVertexInputAttributeOffset        | -
| code:uint32_t            | pname:maxVertexInputBindingStride          | -
| code:uint32_t            | pname:maxVertexOutputComponents            | -
| code:uint32_t            | pname:maxTessellationGenerationLevel       | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationPatchSize             | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationControlPerVertexInputComponents  | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationControlPerVertexOutputComponents | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationControlPerPatchOutputComponents  | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationControlTotalOutputComponents     | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationEvaluationInputComponents        | pname:tessellationShader
| code:uint32_t            | pname:maxTessellationEvaluationOutputComponents       | pname:tessellationShader
| code:uint32_t            | pname:maxGeometryShaderInvocations         | pname:geometryShader
| code:uint32_t            | pname:maxGeometryInputComponents           | pname:geometryShader
| code:uint32_t            | pname:maxGeometryOutputComponents          | pname:geometryShader
| code:uint32_t            | pname:maxGeometryOutputVertices            | pname:geometryShader
| code:uint32_t            | pname:maxGeometryTotalOutputComponents     | pname:geometryShader
| code:uint32_t            | pname:maxFragmentInputComponents           | -
| code:uint32_t            | pname:maxFragmentOutputAttachments         | -
| code:uint32_t            | pname:maxFragmentDualSrcAttachments        | pname:dualSrcBlend
| code:uint32_t            | pname:maxFragmentCombinedOutputResources   | -
| code:uint32_t            | pname:maxComputeSharedMemorySize           | -
| 3 {times} code:uint32_t  | pname:maxComputeWorkGroupCount             | -
| code:uint32_t            | pname:maxComputeWorkGroupInvocations       | -
| 3 {times} code:uint32_t  | pname:maxComputeWorkGroupSize              | -
| code:uint32_t            | pname:subPixelPrecisionBits                | -
| code:uint32_t            | pname:subTexelPrecisionBits                | -
| code:uint32_t            | pname:mipmapPrecisionBits                  | -
| code:uint32_t            | pname:maxDrawIndexedIndexValue             | pname:fullDrawIndexUint32
| code:uint32_t            | pname:maxDrawIndirectCount                 | pname:multiDrawIndirect
| code:float               | pname:maxSamplerLodBias                    | -
| code:float               | pname:maxSamplerAnisotropy                 | pname:samplerAnisotropy
| code:uint32_t            | pname:maxViewports                         | pname:multiViewport
| 2 {times} code:uint32_t  | pname:maxViewportDimensions                | -
| 2 {times} code:float     | pname:viewportBoundsRange                  | -
| code:uint32_t            | pname:viewportSubPixelBits                 | -
| code:size_t              | pname:minMemoryMapAlignment                | -
| basetype:VkDeviceSize    | pname:minTexelBufferOffsetAlignment        | -
| basetype:VkDeviceSize    | pname:minUniformBufferOffsetAlignment      | -
| basetype:VkDeviceSize    | pname:minStorageBufferOffsetAlignment      | -
| code:int32_t             | pname:minTexelOffset                       | -
| code:uint32_t            | pname:maxTexelOffset                       | -
| code:int32_t             | pname:minTexelGatherOffset                 | pname:shaderImageGatherExtended
| code:uint32_t            | pname:maxTexelGatherOffset                 | pname:shaderImageGatherExtended
| code:float               | pname:minInterpolationOffset               | pname:sampleRateShading
| code:float               | pname:maxInterpolationOffset               | pname:sampleRateShading
| code:uint32_t            | pname:subPixelInterpolationOffsetBits      | pname:sampleRateShading
| code:uint32_t            | pname:maxFramebufferWidth                  | -
| code:uint32_t            | pname:maxFramebufferHeight                 | -
| code:uint32_t            | pname:maxFramebufferLayers                 | -
| elink:VkSampleCountFlags | pname:framebufferColorSampleCounts         | -
| elink:VkSampleCountFlags | pname:framebufferDepthSampleCounts         | -
| elink:VkSampleCountFlags | pname:framebufferStencilSampleCounts       | -
| elink:VkSampleCountFlags | pname:framebufferNoAttachmentsSampleCounts | -
| code:uint32_t            | pname:maxColorAttachments                  | -
| elink:VkSampleCountFlags | pname:sampledImageColorSampleCounts        | -
| elink:VkSampleCountFlags | pname:sampledImageIntegerSampleCounts      | -
| elink:VkSampleCountFlags | pname:sampledImageDepthSampleCounts        | -
| elink:VkSampleCountFlags | pname:sampledImageStencilSampleCounts      | -
| elink:VkSampleCountFlags | pname:storageImageSampleCounts             | pname:shaderStorageImageMultisample
| code:uint32_t            | pname:maxSampleMaskWords                   | -
| basetype:VkBool32        | pname:timestampComputeAndGraphics          | -
| code:float               | pname:timestampPeriod                      | -
| code:uint32_t            | pname:maxClipDistances                     | pname:shaderClipDistance
| code:uint32_t            | pname:maxCullDistances                     | pname:shaderCullDistance
| code:uint32_t            | pname:maxCombinedClipAndCullDistances      | pname:shaderCullDistance
| code:uint32_t            | pname:discreteQueuePriorities              | -
| 2 {times} code:float     | pname:pointSizeRange                       | pname:largePoints
| 2 {times} code:float     | pname:lineWidthRange                       | pname:wideLines
| code:float               | pname:pointSizeGranularity                 | pname:largePoints
| code:float               | pname:lineWidthGranularity                 | pname:wideLines
| basetype:VkBool32        | pname:strictLines                          | -
| basetype:VkBool32        | pname:standardSampleLocations              | -
| basetype:VkDeviceSize    | pname:optimalBufferCopyOffsetAlignment     | -
| basetype:VkDeviceSize    | pname:optimalBufferCopyRowPitchAlignment   | -
| basetype:VkDeviceSize    | pname:nonCoherentAtomSize                  | -
ifdef::VK_EXT_discard_rectangles[]
| code:uint32_t            | pname:maxDiscardRectangles                 | `<<VK_EXT_discard_rectangles>>`
endif::VK_EXT_discard_rectangles[]
ifdef::VK_EXT_sampler_filter_minmax[]
| basetype:VkBool32        | pname:filterMinmaxSingleComponentFormats   | `<<VK_EXT_sampler_filter_minmax>>`
| basetype:VkBool32        | pname:filterMinmaxImageComponentMapping    | `<<VK_EXT_sampler_filter_minmax>>`
endif::VK_EXT_sampler_filter_minmax[]
ifdef::VK_EXT_conservative_rasterization[]
| basetype:float           | pname:primitiveOverestimationSize                 | `<<VK_EXT_conservative_rasterization>>`
| basetype:VkBool32        | pname:maxExtraPrimitiveOverestimationSize         | `<<VK_EXT_conservative_rasterization>>`
| basetype:float           | pname:extraPrimitiveOverestimationSizeGranularity | `<<VK_EXT_conservative_rasterization>>`
| basetype:VkBool32        | pname:degenerateTriangleRasterized                | `<<VK_EXT_conservative_rasterization>>`
| basetype:float           | pname:degenerateLinesRasterized                   | `<<VK_EXT_conservative_rasterization>>`
| basetype:VkBool32        | pname:fullyCoveredFragmentShaderInputVariable     | `<<VK_EXT_conservative_rasterization>>`
| basetype:VkBool32        | pname:conservativeRasterizationPostDepthCoverage  | `<<VK_EXT_conservative_rasterization>>`
endif::VK_EXT_conservative_rasterization[]
ifdef::VK_EXT_vertex_attribute_divisor[]
| code:uint32_t            | pname:maxVertexAttribDivisor               | `<<VK_EXT_vertex_attribute_divisor>>`
endif::VK_EXT_vertex_attribute_divisor[]
|====

[[features-limits-required]]
.Required Limits
[width="100%",cols="<35,<9,<14,<11",options="header"]
|====
| Limit | Unsupported Limit | Supported Limit | Limit Type^1^
| pname:maxImageDimension1D                  | - | 4096    | min
| pname:maxImageDimension2D                  | - | 4096    | min
| pname:maxImageDimension3D                  | - | 256     | min
| pname:maxImageDimensionCube                | - | 4096    | min
| pname:maxImageArrayLayers                  | - | 256     | min
| pname:maxTexelBufferElements               | - | 65536   | min
| pname:maxUniformBufferRange                | - | 16384   | min
| pname:maxStorageBufferRange                | - | 2^27^   | min
| pname:maxPushConstantsSize                 | - | 128     | min
| pname:maxMemoryAllocationCount             | - | 4096    | min
| pname:maxSamplerAllocationCount            | - | 4000    | min
| pname:bufferImageGranularity               | - | 131072  | max
| pname:sparseAddressSpaceSize               | 0 | 2^31^   | min
| pname:maxBoundDescriptorSets               | - | 4       | min
| pname:maxPerStageDescriptorSamplers        | - | 16      | min
| pname:maxPerStageDescriptorUniformBuffers  | - | 12      | min
| pname:maxPerStageDescriptorStorageBuffers  | - | 4       | min
| pname:maxPerStageDescriptorSampledImages   | - | 16      | min
| pname:maxPerStageDescriptorStorageImages   | - | 4       | min
| pname:maxPerStageDescriptorInputAttachments| - | 4       | min
| pname:maxPerStageResources                 | - | 128 ^2^ | min
| pname:maxDescriptorSetSamplers             | - | 96 ^8^  | min, _n_ {times} PerStage
| pname:maxDescriptorSetUniformBuffers       | - | 72 ^8^  | min, _n_ {times} PerStage
| pname:maxDescriptorSetUniformBuffersDynamic| - | 8       | min
| pname:maxDescriptorSetStorageBuffers       | - | 24 ^8^  | min, _n_ {times} PerStage
| pname:maxDescriptorSetStorageBuffersDynamic| - | 4       | min
| pname:maxDescriptorSetSampledImages        | - | 96 ^8^  | min, _n_ {times} PerStage
| pname:maxDescriptorSetStorageImages        | - | 24 ^8^  | min, _n_ {times} PerStage
| pname:maxDescriptorSetInputAttachments     | - | 4       | min
| pname:maxVertexInputAttributes             | - | 16      | min
| pname:maxVertexInputBindings               | - | 16      | min
| pname:maxVertexInputAttributeOffset        | - | 2047    | min
| pname:maxVertexInputBindingStride          | - | 2048    | min
| pname:maxVertexOutputComponents            | - | 64      | min
| pname:maxTessellationGenerationLevel       | 0 | 64      | min
| pname:maxTessellationPatchSize             | 0 | 32      | min
| pname:maxTessellationControlPerVertexInputComponents  | 0 |64 | min
| pname:maxTessellationControlPerVertexOutputComponents | 0 |64 | min
| pname:maxTessellationControlPerPatchOutputComponents  | 0 |120 | min
| pname:maxTessellationControlTotalOutputComponents     | 0 |2048 | min
| pname:maxTessellationEvaluationInputComponents        | 0 |64 | min
| pname:maxTessellationEvaluationOutputComponents       | 0 |64 | min
| pname:maxGeometryShaderInvocations         | 0 | 32      | min
| pname:maxGeometryInputComponents           | 0 | 64      | min
| pname:maxGeometryOutputComponents          | 0 | 64      | min
| pname:maxGeometryOutputVertices            | 0 | 256     | min
| pname:maxGeometryTotalOutputComponents     | 0 | 1024    | min
| pname:maxFragmentInputComponents           | - | 64      | min
| pname:maxFragmentOutputAttachments         | - | 4       | min
| pname:maxFragmentDualSrcAttachments        | 0 | 1       | min
| pname:maxFragmentCombinedOutputResources   | - | 4       | min
| pname:maxComputeSharedMemorySize           | - | 16384   | min
| pname:maxComputeWorkGroupCount             | - | (65535,65535,65535) | min
| pname:maxComputeWorkGroupInvocations       | - | 128     | min
| pname:maxComputeWorkGroupSize              | - | (128,128,64) | min
| pname:subPixelPrecisionBits                | - | 4       | min
| pname:subTexelPrecisionBits                | - | 4       | min
| pname:mipmapPrecisionBits                  | - | 4       | min
| pname:maxDrawIndexedIndexValue             | 2^24^-1 | 2^32^-1 | min
| pname:maxDrawIndirectCount                 | 1 | 2^16^-1 | min
| pname:maxSamplerLodBias                    | - | 2       | min
| pname:maxSamplerAnisotropy                 | 1 | 16      | min
| pname:maxViewports                         | 1 | 16      | min
| pname:maxViewportDimensions                | - | (4096,4096) ^3^  | min
| pname:viewportBoundsRange                  | - | (-8192,8191) ^4^ | (max,min)
| pname:viewportSubPixelBits                 | - | 0   | min
| pname:minMemoryMapAlignment                | - | 64  | min
| pname:minTexelBufferOffsetAlignment        | - | 256 | max
| pname:minUniformBufferOffsetAlignment      | - | 256 | max
| pname:minStorageBufferOffsetAlignment      | - | 256 | max
| pname:minTexelOffset                       | - | -8  | max
| pname:maxTexelOffset                       | - | 7   | min
| pname:minTexelGatherOffset                 | 0 | -8  | max
| pname:maxTexelGatherOffset                 | 0 | 7   | min
| pname:minInterpolationOffset               |0.0| -0.5 ^5^ | max
| pname:maxInterpolationOffset               |0.0| 0.5 - (1 ULP) ^5^ | min
| pname:subPixelInterpolationOffsetBits      | 0 | 4 ^5^ | min
| pname:maxFramebufferWidth                  | - | 4096  | min
| pname:maxFramebufferHeight                 | - | 4096  | min
| pname:maxFramebufferLayers                 | - | 256   | min
| pname:framebufferColorSampleCounts         | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:framebufferDepthSampleCounts         | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:framebufferStencilSampleCounts       | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:framebufferNoAttachmentsSampleCounts | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:maxColorAttachments                  | - | 4     | min
| pname:sampledImageColorSampleCounts        | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:sampledImageIntegerSampleCounts      | - | ename:VK_SAMPLE_COUNT_1_BIT                                  | min
| pname:sampledImageDepthSampleCounts        | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:sampledImageStencilSampleCounts      | - | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:storageImageSampleCounts             | ename:VK_SAMPLE_COUNT_1_BIT | (ename:VK_SAMPLE_COUNT_1_BIT \| ename:VK_SAMPLE_COUNT_4_BIT) | min
| pname:maxSampleMaskWords                   | - | 1     | min
| pname:timestampComputeAndGraphics          | - | -     |implementation dependent
| pname:timestampPeriod                      | - | -     |duration
| pname:maxClipDistances                     | 0 | 8     | min
| pname:maxCullDistances                     | 0 | 8     | min
| pname:maxCombinedClipAndCullDistances      | 0 | 8     | min
| pname:discreteQueuePriorities              | - | 2     | min
| pname:pointSizeRange                       | (1.0,1.0) | (1.0,64.0 - ULP)^6^| (max,min)
| pname:lineWidthRange                       | (1.0,1.0) | (1.0,8.0 - ULP)^7^ | (max,min)
| pname:pointSizeGranularity                 |  0.0 | 1.0 ^6^ | max, fixed point increment
| pname:lineWidthGranularity                 |  0.0 | 1.0 ^7^ | max, fixed point increment
| pname:strictLines                          | - | -   | implementation dependent
| pname:standardSampleLocations              | - | -   | implementation dependent
| pname:optimalBufferCopyOffsetAlignment     | - | -   | recommendation
| pname:optimalBufferCopyRowPitchAlignment   | - | -   | recommendation
| pname:nonCoherentAtomSize                  | - | 256 | max
ifdef::VK_KHR_push_descriptor[]
| pname:maxPushDescriptors                   | - | 32  | min
endif::VK_KHR_push_descriptor[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
| pname:maxMultiviewViewCount                | - |  6  | min
| pname:maxMultiviewInstanceIndex            | - |  2^27^-1  | min
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_EXT_discard_rectangles[]
| pname:maxDiscardRectangles                 | 0 | 4   | min
endif::VK_EXT_discard_rectangles[]
ifdef::VK_EXT_sample_locations[]
| pname:sampleLocationSampleCounts           | - | ename:VK_SAMPLE_COUNT_4_BIT | min
| pname:maxSampleLocationGridSize            | - | (1,1) | min
| pname:sampleLocationCoordinateRange        | - | (0.0, 0.9375) | (max,min)
| pname:sampleLocationSubPixelBits           | - | 4   | min
| pname:variableSampleLocations              | - |false| implementation dependent
endif::VK_EXT_sample_locations[]
ifdef::VK_EXT_external_memory_host[]
| pname:minImportedHostPointerAlignment      | - | 65536 | max
endif::VK_EXT_external_memory_host[]
ifdef::VK_NVX_multiview_per_view_attributes[]
| pname:perViewPositionAllComponents         | - | -   | implementation dependent
endif::VK_NVX_multiview_per_view_attributes[]
ifdef::VK_EXT_sampler_filter_minmax[]
| pname:filterMinmaxSingleComponentFormats   | - | -   | implementation dependent
| pname:filterMinmaxImageComponentMapping    | - | -   | implementation dependent
endif::VK_EXT_sampler_filter_minmax[]
ifdef::VK_EXT_blend_operation_advanced[]
| pname:advancedBlendMaxColorAttachments        | - | 1   | min
| pname:advancedBlendIndependentBlend           | - |false| implementation dependent
| pname:advancedBlendNonPremultipliedSrcColor   | - |false| implementation dependent
| pname:advancedBlendNonPremultipliedDstColor   | - |false| implementation dependent
| pname:advancedBlendCorrelatedOverlap          | - |false| implementation dependent
| pname:advancedBlendAllOperations              | - |false| implementation dependent
endif::VK_EXT_blend_operation_advanced[]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance3[]
| pname:maxPerSetDescriptors                                | - |1024 | min
| pname:maxMemoryAllocationSize                             | - | 2^30^ | min
endif::VK_VERSION_1_1,VK_KHR_maintenance3[]
ifdef::VK_EXT_conservative_rasterization[]
| pname:primitiveOverestimationSize                 | - |0.0   | min
| pname:maxExtraPrimitiveOverestimationSize         | - |0.0   | min
| pname:extraPrimitiveOverestimationSizeGranularity | - |0.0   | min
| pname:primitiveUnderestimation                    | - |false | implementation dependent
| pname:conservativePointAndLineRasterization       | - |false | implementation dependent
| pname:degenerateTrianglesRasterized               | - |false | implementation dependent
| pname:degenerateLinesRasterized                   | - |false | implementation dependent
| pname:fullyCoveredFragmentShaderInputVariable     | - |false | implementation dependent
| pname:conservativeRasterizationPostDepthCoverage  | - |false | implementation dependent
endif::VK_EXT_conservative_rasterization[]
ifdef::VK_EXT_descriptor_indexing[]
| pname:maxUpdateAfterBindDescriptorsInAllPools             | - |500000| min
| pname:shaderUniformBufferArrayNonUniformIndexingNative    | - |false| implementation dependent
| pname:shaderSampledImageArrayNonUniformIndexingNative     | - |false| implementation dependent
| pname:shaderStorageBufferArrayNonUniformIndexingNative    | - |false| implementation dependent
| pname:shaderStorageImageArrayNonUniformIndexingNative     | - |false| implementation dependent
| pname:shaderInputAttachmentArrayNonUniformIndexingNative  | - |false| implementation dependent
| pname:maxPerStageDescriptorUpdateAfterBindSamplers        | - |500000 ^9^ | min
| pname:maxPerStageDescriptorUpdateAfterBindUniformBuffers  | - |12 ^9^ | min
| pname:maxPerStageDescriptorUpdateAfterBindStorageBuffers  | - |500000 ^9^ | min
| pname:maxPerStageDescriptorUpdateAfterBindSampledImages   | - |500000 ^9^ | min
| pname:maxPerStageDescriptorUpdateAfterBindStorageImages   | - |500000 ^9^ | min
| pname:maxPerStageDescriptorUpdateAfterBindInputAttachments| - |500000 ^9^ | min
| pname:maxPerStageUpdateAfterBindResources                 | - |500000 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindSamplers             | - |500000 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindUniformBuffers       | - |72 ^8^ ^9^ | min, _n_ {times} PerStage
| pname:maxDescriptorSetUpdateAfterBindUniformBuffersDynamic| - |8 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindStorageBuffers       | - |500000 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindStorageBuffersDynamic| - |4 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindSampledImages        | - |500000 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindStorageImages        | - |500000 ^9^ | min
| pname:maxDescriptorSetUpdateAfterBindInputAttachments     | - |500000 ^9^ | min
endif::VK_EXT_descriptor_indexing[]
ifdef::VK_EXT_vertex_attribute_divisor[]
| pname:maxVertexAttribDivisor               | - | 2^16^-1   | min
endif::VK_EXT_vertex_attribute_divisor[]
|====

1::
    The *Limit Type* column specifies the limit is either the minimum limit
    all implementations must: support or the maximum limit all
    implementations must: support.
    For bitmasks a minimum limit is the least bits all implementations must:
    set, but they may: have additional bits set beyond this minimum.

2::
    The pname:maxPerStageResources must: be at least the smallest of the
    following:
+
  * the sum of the pname:maxPerStageDescriptorUniformBuffers,
    pname:maxPerStageDescriptorStorageBuffers,
    pname:maxPerStageDescriptorSampledImages,
    pname:maxPerStageDescriptorStorageImages,
    pname:maxPerStageDescriptorInputAttachments, pname:maxColorAttachments
    limits, or
  * 128.
+
It may: not be possible to reach this limit in every stage.

3::
    See
    <<features-limits-maxViewportDimensions,pname:maxViewportDimensions>>
    for the required: relationship to other limits.

4::
    See <<features-limits-viewportboundsrange,pname:viewportBoundsRange>>
    for the required: relationship to other limits.

5::
    The values pname:minInterpolationOffset and pname:maxInterpolationOffset
    describe the closed interval of supported interpolation offsets:
    [pname:minInterpolationOffset, pname:maxInterpolationOffset].
    The ULP is determined by pname:subPixelInterpolationOffsetBits.
    If pname:subPixelInterpolationOffsetBits is 4, this provides increments
    of (1/2^4^) = 0.0625, and thus the range of supported interpolation
    offsets would be [eq]#[-0.5, 0.4375]#.

6::
    The point size ULP is determined by pname:pointSizeGranularity.
    If the pname:pointSizeGranularity is 0.125, the range of supported point
    sizes must: be at least [1.0, 63.875].

7::
    The line width ULP is determined by pname:lineWidthGranularity.
    If the pname:lineWidthGranularity is 0.0625, the range of supported line
    widths must: be at least [1.0, 7.9375].

8:: The minimum ptext:maxDescriptorSet* limit is _n_ times the corresponding
    _specification_ minimum ptext:maxPerStageDescriptor* limit, where _n_ is
    the number of shader stages supported by the slink:VkPhysicalDevice.
    If all shader stages are supported, _n_ = 6 (vertex, tessellation
    control, tessellation evaluation, geometry, fragment, compute).

ifdef::VK_EXT_descriptor_indexing[]
9:: The ptext:UpdateAfterBind descriptor limits must: each be greater than
    or equal to the corresponding ptext:non-UpdateAfterBind limit.
endif::VK_EXT_descriptor_indexing[]

ifdef::VK_EXT_sample_locations[]

[[features-limits-multisample]]
== Additional Multisampling Capabilities

[open,refpage='vkGetPhysicalDeviceMultisamplePropertiesEXT',desc='Report sample count specific multisampling capabilities of a physical device',type='protos']
--

In addition to the minimum capabilities described in the previous section
(<<features-limits,Limits>>), implementations may: support additional
multisampling capabilities specific to a particular sample count.

To query additional sample count specific multisampling capabilities, call:

include::../api/protos/vkGetPhysicalDeviceMultisamplePropertiesEXT.txt[]

  * pname:physicalDevice is the physical device from which to query the
    additional multisampling capabilities.
  * pname:samples is the sample count to query the capabilities for.
  * pname:pMultisampleProperties is a pointer to a structure of type
    slink:VkMultisamplePropertiesEXT, in which information about the
    additional multisampling capabilities specific to the sample count is
    returned.

include::../validity/protos/vkGetPhysicalDeviceMultisamplePropertiesEXT.txt[]
--

[open,refpage='VkMultisamplePropertiesEXT',desc='Structure returning information about sample count specific additional multisampling capabilities',type='structs']
--

The sname:VkMultisamplePropertiesEXT structure is defined as

include::../api/structs/VkMultisamplePropertiesEXT.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:maxSampleLocationGridSize is the maximum size of the pixel grid in
    which sample locations can: vary.

include::../validity/structs/VkMultisamplePropertiesEXT.txt[]
--

If the sample count for which additional multisampling capabilities are
requested using fname:vkGetPhysicalDeviceMultisamplePropertiesEXT is set
in sname:VkPhysicalDeviceSampleLocationsEXT::
<<features-limits-sampleLocationSampleCounts,
pname:sampleLocationSampleCounts>> the pname:width and pname:height members
of sname:VkMultisamplePropertiesEXT::pname:maxSampleLocationGridSize must:
be greater than or equal to the corresponding members of
sname:VkPhysicalDeviceSampleLocationsEXT::
<<features-limits-maxSampleLocationGridSize,pname:maxSampleLocationGridSize>>,
respectively, otherwise both members must: be `0`.

endif::VK_EXT_sample_locations[]


[[features-formats]]
== Formats

The features for the set of formats (elink:VkFormat) supported by the
implementation are queried individually using the
flink:vkGetPhysicalDeviceFormatProperties command.


[[features-formats-definition]]
=== Format Definition

[open,refpage='VkFormat',desc='Available image formats',type='enums']
--

Image formats which can: be passed to, and may: be returned from Vulkan
commands, are:

include::../api/enums/VkFormat.txt[]

  * ename:VK_FORMAT_UNDEFINED specifies that the format is not specified.
  * ename:VK_FORMAT_R4G4_UNORM_PACK8 specifies a two-component, 8-bit packed
    unsigned normalized format that has a 4-bit R component in bits 4..7,
    and a 4-bit G component in bits 0..3.
  * ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16 specifies a four-component, 16-bit
    packed unsigned normalized format that has a 4-bit R component in bits
    12..15, a 4-bit G component in bits 8..11, a 4-bit B component in bits
    4..7, and a 4-bit A component in bits 0..3.
  * ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16 specifies a four-component, 16-bit
    packed unsigned normalized format that has a 4-bit B component in bits
    12..15, a 4-bit G component in bits 8..11, a 4-bit R component in bits
    4..7, and a 4-bit A component in bits 0..3.
  * ename:VK_FORMAT_R5G6B5_UNORM_PACK16 specifies a three-component, 16-bit
    packed unsigned normalized format that has a 5-bit R component in bits
    11..15, a 6-bit G component in bits 5..10, and a 5-bit B component in
    bits 0..4.
  * ename:VK_FORMAT_B5G6R5_UNORM_PACK16 specifies a three-component, 16-bit
    packed unsigned normalized format that has a 5-bit B component in bits
    11..15, a 6-bit G component in bits 5..10, and a 5-bit R component in
    bits 0..4.
  * ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16 specifies a four-component, 16-bit
    packed unsigned normalized format that has a 5-bit R component in bits
    11..15, a 5-bit G component in bits 6..10, a 5-bit B component in bits
    1..5, and a 1-bit A component in bit 0.
  * ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16 specifies a four-component, 16-bit
    packed unsigned normalized format that has a 5-bit B component in bits
    11..15, a 5-bit G component in bits 6..10, a 5-bit R component in bits
    1..5, and a 1-bit A component in bit 0.
  * ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16 specifies a four-component, 16-bit
    packed unsigned normalized format that has a 1-bit A component in bit
    15, a 5-bit R component in bits 10..14, a 5-bit G component in bits
    5..9, and a 5-bit B component in bits 0..4.
  * ename:VK_FORMAT_R8_UNORM specifies a one-component, 8-bit unsigned
    normalized format that has a single 8-bit R component.
  * ename:VK_FORMAT_R8_SNORM specifies a one-component, 8-bit signed
    normalized format that has a single 8-bit R component.
  * ename:VK_FORMAT_R8_USCALED specifies a one-component, 8-bit unsigned
    scaled integer format that has a single 8-bit R component.
  * ename:VK_FORMAT_R8_SSCALED specifies a one-component, 8-bit signed
    scaled integer format that has a single 8-bit R component.
  * ename:VK_FORMAT_R8_UINT specifies a one-component, 8-bit unsigned
    integer format that has a single 8-bit R component.
  * ename:VK_FORMAT_R8_SINT specifies a one-component, 8-bit signed integer
    format that has a single 8-bit R component.
  * ename:VK_FORMAT_R8_SRGB specifies a one-component, 8-bit unsigned
    normalized format that has a single 8-bit R component stored with sRGB
    nonlinear encoding.
  * ename:VK_FORMAT_R8G8_UNORM specifies a two-component, 16-bit unsigned
    normalized format that has an 8-bit R component in byte 0, and an 8-bit
    G component in byte 1.
  * ename:VK_FORMAT_R8G8_SNORM specifies a two-component, 16-bit signed
    normalized format that has an 8-bit R component in byte 0, and an 8-bit
    G component in byte 1.
  * ename:VK_FORMAT_R8G8_USCALED specifies a two-component, 16-bit unsigned
    scaled integer format that has an 8-bit R component in byte 0, and an
    8-bit G component in byte 1.
  * ename:VK_FORMAT_R8G8_SSCALED specifies a two-component, 16-bit signed
    scaled integer format that has an 8-bit R component in byte 0, and an
    8-bit G component in byte 1.
  * ename:VK_FORMAT_R8G8_UINT specifies a two-component, 16-bit unsigned
    integer format that has an 8-bit R component in byte 0, and an 8-bit G
    component in byte 1.
  * ename:VK_FORMAT_R8G8_SINT specifies a two-component, 16-bit signed
    integer format that has an 8-bit R component in byte 0, and an 8-bit G
    component in byte 1.
  * ename:VK_FORMAT_R8G8_SRGB specifies a two-component, 16-bit unsigned
    normalized format that has an 8-bit R component stored with sRGB
    nonlinear encoding in byte 0, and an 8-bit G component stored with sRGB
    nonlinear encoding in byte 1.
  * ename:VK_FORMAT_R8G8B8_UNORM specifies a three-component, 24-bit
    unsigned normalized format that has an 8-bit R component in byte 0, an
    8-bit G component in byte 1, and an 8-bit B component in byte 2.
  * ename:VK_FORMAT_R8G8B8_SNORM specifies a three-component, 24-bit signed
    normalized format that has an 8-bit R component in byte 0, an 8-bit G
    component in byte 1, and an 8-bit B component in byte 2.
  * ename:VK_FORMAT_R8G8B8_USCALED specifies a three-component, 24-bit
    unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit
    G component in byte 1, and an 8-bit B component in byte 2.
  * ename:VK_FORMAT_R8G8B8_SSCALED specifies a three-component, 24-bit
    signed scaled format that has an 8-bit R component in byte 0, an 8-bit G
    component in byte 1, and an 8-bit B component in byte 2.
  * ename:VK_FORMAT_R8G8B8_UINT specifies a three-component, 24-bit unsigned
    integer format that has an 8-bit R component in byte 0, an 8-bit G
    component in byte 1, and an 8-bit B component in byte 2.
  * ename:VK_FORMAT_R8G8B8_SINT specifies a three-component, 24-bit signed
    integer format that has an 8-bit R component in byte 0, an 8-bit G
    component in byte 1, and an 8-bit B component in byte 2.
  * ename:VK_FORMAT_R8G8B8_SRGB specifies a three-component, 24-bit unsigned
    normalized format that has an 8-bit R component stored with sRGB
    nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
    nonlinear encoding in byte 1, and an 8-bit B component stored with sRGB
    nonlinear encoding in byte 2.
  * ename:VK_FORMAT_B8G8R8_UNORM specifies a three-component, 24-bit
    unsigned normalized format that has an 8-bit B component in byte 0, an
    8-bit G component in byte 1, and an 8-bit R component in byte 2.
  * ename:VK_FORMAT_B8G8R8_SNORM specifies a three-component, 24-bit signed
    normalized format that has an 8-bit B component in byte 0, an 8-bit G
    component in byte 1, and an 8-bit R component in byte 2.
  * ename:VK_FORMAT_B8G8R8_USCALED specifies a three-component, 24-bit
    unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit
    G component in byte 1, and an 8-bit R component in byte 2.
  * ename:VK_FORMAT_B8G8R8_SSCALED specifies a three-component, 24-bit
    signed scaled format that has an 8-bit B component in byte 0, an 8-bit G
    component in byte 1, and an 8-bit R component in byte 2.
  * ename:VK_FORMAT_B8G8R8_UINT specifies a three-component, 24-bit unsigned
    integer format that has an 8-bit B component in byte 0, an 8-bit G
    component in byte 1, and an 8-bit R component in byte 2.
  * ename:VK_FORMAT_B8G8R8_SINT specifies a three-component, 24-bit signed
    integer format that has an 8-bit B component in byte 0, an 8-bit G
    component in byte 1, and an 8-bit R component in byte 2.
  * ename:VK_FORMAT_B8G8R8_SRGB specifies a three-component, 24-bit unsigned
    normalized format that has an 8-bit B component stored with sRGB
    nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
    nonlinear encoding in byte 1, and an 8-bit R component stored with sRGB
    nonlinear encoding in byte 2.
  * ename:VK_FORMAT_R8G8B8A8_UNORM specifies a four-component, 32-bit
    unsigned normalized format that has an 8-bit R component in byte 0, an
    8-bit G component in byte 1, an 8-bit B component in byte 2, and an
    8-bit A component in byte 3.
  * ename:VK_FORMAT_R8G8B8A8_SNORM specifies a four-component, 32-bit signed
    normalized format that has an 8-bit R component in byte 0, an 8-bit G
    component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
    component in byte 3.
  * ename:VK_FORMAT_R8G8B8A8_USCALED specifies a four-component, 32-bit
    unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit
    G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
    component in byte 3.
  * ename:VK_FORMAT_R8G8B8A8_SSCALED specifies a four-component, 32-bit
    signed scaled format that has an 8-bit R component in byte 0, an 8-bit G
    component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
    component in byte 3.
  * ename:VK_FORMAT_R8G8B8A8_UINT specifies a four-component, 32-bit
    unsigned integer format that has an 8-bit R component in byte 0, an
    8-bit G component in byte 1, an 8-bit B component in byte 2, and an
    8-bit A component in byte 3.
  * ename:VK_FORMAT_R8G8B8A8_SINT specifies a four-component, 32-bit signed
    integer format that has an 8-bit R component in byte 0, an 8-bit G
    component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
    component in byte 3.
  * ename:VK_FORMAT_R8G8B8A8_SRGB specifies a four-component, 32-bit
    unsigned normalized format that has an 8-bit R component stored with
    sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
    nonlinear encoding in byte 1, an 8-bit B component stored with sRGB
    nonlinear encoding in byte 2, and an 8-bit A component in byte 3.
  * ename:VK_FORMAT_B8G8R8A8_UNORM specifies a four-component, 32-bit
    unsigned normalized format that has an 8-bit B component in byte 0, an
    8-bit G component in byte 1, an 8-bit R component in byte 2, and an
    8-bit A component in byte 3.
  * ename:VK_FORMAT_B8G8R8A8_SNORM specifies a four-component, 32-bit signed
    normalized format that has an 8-bit B component in byte 0, an 8-bit G
    component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
    component in byte 3.
  * ename:VK_FORMAT_B8G8R8A8_USCALED specifies a four-component, 32-bit
    unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit
    G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
    component in byte 3.
  * ename:VK_FORMAT_B8G8R8A8_SSCALED specifies a four-component, 32-bit
    signed scaled format that has an 8-bit B component in byte 0, an 8-bit G
    component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
    component in byte 3.
  * ename:VK_FORMAT_B8G8R8A8_UINT specifies a four-component, 32-bit
    unsigned integer format that has an 8-bit B component in byte 0, an
    8-bit G component in byte 1, an 8-bit R component in byte 2, and an
    8-bit A component in byte 3.
  * ename:VK_FORMAT_B8G8R8A8_SINT specifies a four-component, 32-bit signed
    integer format that has an 8-bit B component in byte 0, an 8-bit G
    component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
    component in byte 3.
  * ename:VK_FORMAT_B8G8R8A8_SRGB specifies a four-component, 32-bit
    unsigned normalized format that has an 8-bit B component stored with
    sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
    nonlinear encoding in byte 1, an 8-bit R component stored with sRGB
    nonlinear encoding in byte 2, and an 8-bit A component in byte 3.
  * ename:VK_FORMAT_A8B8G8R8_UNORM_PACK32 specifies a four-component, 32-bit
    packed unsigned normalized format that has an 8-bit A component in bits
    24..31, an 8-bit B component in bits 16..23, an 8-bit G component in
    bits 8..15, and an 8-bit R component in bits 0..7.
  * ename:VK_FORMAT_A8B8G8R8_SNORM_PACK32 specifies a four-component, 32-bit
    packed signed normalized format that has an 8-bit A component in bits
    24..31, an 8-bit B component in bits 16..23, an 8-bit G component in
    bits 8..15, and an 8-bit R component in bits 0..7.
  * ename:VK_FORMAT_A8B8G8R8_USCALED_PACK32 specifies a four-component,
    32-bit packed unsigned scaled integer format that has an 8-bit A
    component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit
    G component in bits 8..15, and an 8-bit R component in bits 0..7.
  * ename:VK_FORMAT_A8B8G8R8_SSCALED_PACK32 specifies a four-component,
    32-bit packed signed scaled integer format that has an 8-bit A component
    in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G
    component in bits 8..15, and an 8-bit R component in bits 0..7.
  * ename:VK_FORMAT_A8B8G8R8_UINT_PACK32 specifies a four-component, 32-bit
    packed unsigned integer format that has an 8-bit A component in bits
    24..31, an 8-bit B component in bits 16..23, an 8-bit G component in
    bits 8..15, and an 8-bit R component in bits 0..7.
  * ename:VK_FORMAT_A8B8G8R8_SINT_PACK32 specifies a four-component, 32-bit
    packed signed integer format that has an 8-bit A component in bits
    24..31, an 8-bit B component in bits 16..23, an 8-bit G component in
    bits 8..15, and an 8-bit R component in bits 0..7.
  * ename:VK_FORMAT_A8B8G8R8_SRGB_PACK32 specifies a four-component, 32-bit
    packed unsigned normalized format that has an 8-bit A component in bits
    24..31, an 8-bit B component stored with sRGB nonlinear encoding in bits
    16..23, an 8-bit G component stored with sRGB nonlinear encoding in bits
    8..15, and an 8-bit R component stored with sRGB nonlinear encoding in
    bits 0..7.
  * ename:VK_FORMAT_A2R10G10B10_UNORM_PACK32 specifies a four-component,
    32-bit packed unsigned normalized format that has a 2-bit A component in
    bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component
    in bits 10..19, and a 10-bit B component in bits 0..9.
  * ename:VK_FORMAT_A2R10G10B10_SNORM_PACK32 specifies a four-component,
    32-bit packed signed normalized format that has a 2-bit A component in
    bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component
    in bits 10..19, and a 10-bit B component in bits 0..9.
  * ename:VK_FORMAT_A2R10G10B10_USCALED_PACK32 specifies a four-component,
    32-bit packed unsigned scaled integer format that has a 2-bit A
    component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit
    G component in bits 10..19, and a 10-bit B component in bits 0..9.
  * ename:VK_FORMAT_A2R10G10B10_SSCALED_PACK32 specifies a four-component,
    32-bit packed signed scaled integer format that has a 2-bit A component
    in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G
    component in bits 10..19, and a 10-bit B component in bits 0..9.
  * ename:VK_FORMAT_A2R10G10B10_UINT_PACK32 specifies a four-component,
    32-bit packed unsigned integer format that has a 2-bit A component in
    bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component
    in bits 10..19, and a 10-bit B component in bits 0..9.
  * ename:VK_FORMAT_A2R10G10B10_SINT_PACK32 specifies a four-component,
    32-bit packed signed integer format that has a 2-bit A component in bits
    30..31, a 10-bit R component in bits 20..29, a 10-bit G component in
    bits 10..19, and a 10-bit B component in bits 0..9.
  * ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32 specifies a four-component,
    32-bit packed unsigned normalized format that has a 2-bit A component in
    bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component
    in bits 10..19, and a 10-bit R component in bits 0..9.
  * ename:VK_FORMAT_A2B10G10R10_SNORM_PACK32 specifies a four-component,
    32-bit packed signed normalized format that has a 2-bit A component in
    bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component
    in bits 10..19, and a 10-bit R component in bits 0..9.
  * ename:VK_FORMAT_A2B10G10R10_USCALED_PACK32 specifies a four-component,
    32-bit packed unsigned scaled integer format that has a 2-bit A
    component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit
    G component in bits 10..19, and a 10-bit R component in bits 0..9.
  * ename:VK_FORMAT_A2B10G10R10_SSCALED_PACK32 specifies a four-component,
    32-bit packed signed scaled integer format that has a 2-bit A component
    in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G
    component in bits 10..19, and a 10-bit R component in bits 0..9.
  * ename:VK_FORMAT_A2B10G10R10_UINT_PACK32 specifies a four-component,
    32-bit packed unsigned integer format that has a 2-bit A component in
    bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component
    in bits 10..19, and a 10-bit R component in bits 0..9.
  * ename:VK_FORMAT_A2B10G10R10_SINT_PACK32 specifies a four-component,
    32-bit packed signed integer format that has a 2-bit A component in bits
    30..31, a 10-bit B component in bits 20..29, a 10-bit G component in
    bits 10..19, and a 10-bit R component in bits 0..9.
  * ename:VK_FORMAT_R16_UNORM specifies a one-component, 16-bit unsigned
    normalized format that has a single 16-bit R component.
  * ename:VK_FORMAT_R16_SNORM specifies a one-component, 16-bit signed
    normalized format that has a single 16-bit R component.
  * ename:VK_FORMAT_R16_USCALED specifies a one-component, 16-bit unsigned
    scaled integer format that has a single 16-bit R component.
  * ename:VK_FORMAT_R16_SSCALED specifies a one-component, 16-bit signed
    scaled integer format that has a single 16-bit R component.
  * ename:VK_FORMAT_R16_UINT specifies a one-component, 16-bit unsigned
    integer format that has a single 16-bit R component.
  * ename:VK_FORMAT_R16_SINT specifies a one-component, 16-bit signed
    integer format that has a single 16-bit R component.
  * ename:VK_FORMAT_R16_SFLOAT specifies a one-component, 16-bit signed
    floating-point format that has a single 16-bit R component.
  * ename:VK_FORMAT_R16G16_UNORM specifies a two-component, 32-bit unsigned
    normalized format that has a 16-bit R component in bytes 0..1, and a
    16-bit G component in bytes 2..3.
  * ename:VK_FORMAT_R16G16_SNORM specifies a two-component, 32-bit signed
    normalized format that has a 16-bit R component in bytes 0..1, and a
    16-bit G component in bytes 2..3.
  * ename:VK_FORMAT_R16G16_USCALED specifies a two-component, 32-bit
    unsigned scaled integer format that has a 16-bit R component in bytes
    0..1, and a 16-bit G component in bytes 2..3.
  * ename:VK_FORMAT_R16G16_SSCALED specifies a two-component, 32-bit signed
    scaled integer format that has a 16-bit R component in bytes 0..1, and a
    16-bit G component in bytes 2..3.
  * ename:VK_FORMAT_R16G16_UINT specifies a two-component, 32-bit unsigned
    integer format that has a 16-bit R component in bytes 0..1, and a 16-bit
    G component in bytes 2..3.
  * ename:VK_FORMAT_R16G16_SINT specifies a two-component, 32-bit signed
    integer format that has a 16-bit R component in bytes 0..1, and a 16-bit
    G component in bytes 2..3.
  * ename:VK_FORMAT_R16G16_SFLOAT specifies a two-component, 32-bit signed
    floating-point format that has a 16-bit R component in bytes 0..1, and a
    16-bit G component in bytes 2..3.
  * ename:VK_FORMAT_R16G16B16_UNORM specifies a three-component, 48-bit
    unsigned normalized format that has a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes
    4..5.
  * ename:VK_FORMAT_R16G16B16_SNORM specifies a three-component, 48-bit
    signed normalized format that has a 16-bit R component in bytes 0..1, a
    16-bit G component in bytes 2..3, and a 16-bit B component in bytes
    4..5.
  * ename:VK_FORMAT_R16G16B16_USCALED specifies a three-component, 48-bit
    unsigned scaled integer format that has a 16-bit R component in bytes
    0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in
    bytes 4..5.
  * ename:VK_FORMAT_R16G16B16_SSCALED specifies a three-component, 48-bit
    signed scaled integer format that has a 16-bit R component in bytes
    0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in
    bytes 4..5.
  * ename:VK_FORMAT_R16G16B16_UINT specifies a three-component, 48-bit
    unsigned integer format that has a 16-bit R component in bytes 0..1, a
    16-bit G component in bytes 2..3, and a 16-bit B component in bytes
    4..5.
  * ename:VK_FORMAT_R16G16B16_SINT specifies a three-component, 48-bit
    signed integer format that has a 16-bit R component in bytes 0..1, a
    16-bit G component in bytes 2..3, and a 16-bit B component in bytes
    4..5.
  * ename:VK_FORMAT_R16G16B16_SFLOAT specifies a three-component, 48-bit
    signed floating-point format that has a 16-bit R component in bytes
    0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in
    bytes 4..5.
  * ename:VK_FORMAT_R16G16B16A16_UNORM specifies a four-component, 64-bit
    unsigned normalized format that has a 16-bit R component in bytes 0..1,
    a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5,
    and a 16-bit A component in bytes 6..7.
  * ename:VK_FORMAT_R16G16B16A16_SNORM specifies a four-component, 64-bit
    signed normalized format that has a 16-bit R component in bytes 0..1, a
    16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5,
    and a 16-bit A component in bytes 6..7.
  * ename:VK_FORMAT_R16G16B16A16_USCALED specifies a four-component, 64-bit
    unsigned scaled integer format that has a 16-bit R component in bytes
    0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes
    4..5, and a 16-bit A component in bytes 6..7.
  * ename:VK_FORMAT_R16G16B16A16_SSCALED specifies a four-component, 64-bit
    signed scaled integer format that has a 16-bit R component in bytes
    0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes
    4..5, and a 16-bit A component in bytes 6..7.
  * ename:VK_FORMAT_R16G16B16A16_UINT specifies a four-component, 64-bit
    unsigned integer format that has a 16-bit R component in bytes 0..1, a
    16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5,
    and a 16-bit A component in bytes 6..7.
  * ename:VK_FORMAT_R16G16B16A16_SINT specifies a four-component, 64-bit
    signed integer format that has a 16-bit R component in bytes 0..1, a
    16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5,
    and a 16-bit A component in bytes 6..7.
  * ename:VK_FORMAT_R16G16B16A16_SFLOAT specifies a four-component, 64-bit
    signed floating-point format that has a 16-bit R component in bytes
    0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes
    4..5, and a 16-bit A component in bytes 6..7.
  * ename:VK_FORMAT_R32_UINT specifies a one-component, 32-bit unsigned
    integer format that has a single 32-bit R component.
  * ename:VK_FORMAT_R32_SINT specifies a one-component, 32-bit signed
    integer format that has a single 32-bit R component.
  * ename:VK_FORMAT_R32_SFLOAT specifies a one-component, 32-bit signed
    floating-point format that has a single 32-bit R component.
  * ename:VK_FORMAT_R32G32_UINT specifies a two-component, 64-bit unsigned
    integer format that has a 32-bit R component in bytes 0..3, and a 32-bit
    G component in bytes 4..7.
  * ename:VK_FORMAT_R32G32_SINT specifies a two-component, 64-bit signed
    integer format that has a 32-bit R component in bytes 0..3, and a 32-bit
    G component in bytes 4..7.
  * ename:VK_FORMAT_R32G32_SFLOAT specifies a two-component, 64-bit signed
    floating-point format that has a 32-bit R component in bytes 0..3, and a
    32-bit G component in bytes 4..7.
  * ename:VK_FORMAT_R32G32B32_UINT specifies a three-component, 96-bit
    unsigned integer format that has a 32-bit R component in bytes 0..3, a
    32-bit G component in bytes 4..7, and a 32-bit B component in bytes
    8..11.
  * ename:VK_FORMAT_R32G32B32_SINT specifies a three-component, 96-bit
    signed integer format that has a 32-bit R component in bytes 0..3, a
    32-bit G component in bytes 4..7, and a 32-bit B component in bytes
    8..11.
  * ename:VK_FORMAT_R32G32B32_SFLOAT specifies a three-component, 96-bit
    signed floating-point format that has a 32-bit R component in bytes
    0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in
    bytes 8..11.
  * ename:VK_FORMAT_R32G32B32A32_UINT specifies a four-component, 128-bit
    unsigned integer format that has a 32-bit R component in bytes 0..3, a
    32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11,
    and a 32-bit A component in bytes 12..15.
  * ename:VK_FORMAT_R32G32B32A32_SINT specifies a four-component, 128-bit
    signed integer format that has a 32-bit R component in bytes 0..3, a
    32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11,
    and a 32-bit A component in bytes 12..15.
  * ename:VK_FORMAT_R32G32B32A32_SFLOAT specifies a four-component, 128-bit
    signed floating-point format that has a 32-bit R component in bytes
    0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes
    8..11, and a 32-bit A component in bytes 12..15.
  * ename:VK_FORMAT_R64_UINT specifies a one-component, 64-bit unsigned
    integer format that has a single 64-bit R component.
  * ename:VK_FORMAT_R64_SINT specifies a one-component, 64-bit signed
    integer format that has a single 64-bit R component.
  * ename:VK_FORMAT_R64_SFLOAT specifies a one-component, 64-bit signed
    floating-point format that has a single 64-bit R component.
  * ename:VK_FORMAT_R64G64_UINT specifies a two-component, 128-bit unsigned
    integer format that has a 64-bit R component in bytes 0..7, and a 64-bit
    G component in bytes 8..15.
  * ename:VK_FORMAT_R64G64_SINT specifies a two-component, 128-bit signed
    integer format that has a 64-bit R component in bytes 0..7, and a 64-bit
    G component in bytes 8..15.
  * ename:VK_FORMAT_R64G64_SFLOAT specifies a two-component, 128-bit signed
    floating-point format that has a 64-bit R component in bytes 0..7, and a
    64-bit G component in bytes 8..15.
  * ename:VK_FORMAT_R64G64B64_UINT specifies a three-component, 192-bit
    unsigned integer format that has a 64-bit R component in bytes 0..7, a
    64-bit G component in bytes 8..15, and a 64-bit B component in bytes
    16..23.
  * ename:VK_FORMAT_R64G64B64_SINT specifies a three-component, 192-bit
    signed integer format that has a 64-bit R component in bytes 0..7, a
    64-bit G component in bytes 8..15, and a 64-bit B component in bytes
    16..23.
  * ename:VK_FORMAT_R64G64B64_SFLOAT specifies a three-component, 192-bit
    signed floating-point format that has a 64-bit R component in bytes
    0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in
    bytes 16..23.
  * ename:VK_FORMAT_R64G64B64A64_UINT specifies a four-component, 256-bit
    unsigned integer format that has a 64-bit R component in bytes 0..7, a
    64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23,
    and a 64-bit A component in bytes 24..31.
  * ename:VK_FORMAT_R64G64B64A64_SINT specifies a four-component, 256-bit
    signed integer format that has a 64-bit R component in bytes 0..7, a
    64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23,
    and a 64-bit A component in bytes 24..31.
  * ename:VK_FORMAT_R64G64B64A64_SFLOAT specifies a four-component, 256-bit
    signed floating-point format that has a 64-bit R component in bytes
    0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes
    16..23, and a 64-bit A component in bytes 24..31.
  * ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32 specifies a three-component,
    32-bit packed unsigned floating-point format that has a 10-bit B
    component in bits 22..31, an 11-bit G component in bits 11..21, an
    11-bit R component in bits 0..10.
    See <<fundamentals-fp10>> and <<fundamentals-fp11>>.
  * ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 specifies a three-component,
    32-bit packed unsigned floating-point format that has a 5-bit shared
    exponent in bits 27..31, a 9-bit B component mantissa in bits 18..26, a
    9-bit G component mantissa in bits 9..17, and a 9-bit R component
    mantissa in bits 0..8.
  * ename:VK_FORMAT_D16_UNORM specifies a one-component, 16-bit unsigned
    normalized format that has a single 16-bit depth component.
  * ename:VK_FORMAT_X8_D24_UNORM_PACK32 specifies a two-component, 32-bit
    format that has 24 unsigned normalized bits in the depth component and,
    optionally:, 8 bits that are unused.
  * ename:VK_FORMAT_D32_SFLOAT specifies a one-component, 32-bit signed
    floating-point format that has 32-bits in the depth component.
  * ename:VK_FORMAT_S8_UINT specifies a one-component, 8-bit unsigned
    integer format that has 8-bits in the stencil component.
  * ename:VK_FORMAT_D16_UNORM_S8_UINT specifies a two-component, 24-bit
    format that has 16 unsigned normalized bits in the depth component and 8
    unsigned integer bits in the stencil component.
  * ename:VK_FORMAT_D24_UNORM_S8_UINT specifies a two-component, 32-bit
    packed format that has 8 unsigned integer bits in the stencil component,
    and 24 unsigned normalized bits in the depth component.
  * ename:VK_FORMAT_D32_SFLOAT_S8_UINT specifies a two-component format that
    has 32 signed float bits in the depth component and 8 unsigned integer
    bits in the stencil component.
    There are optionally: 24-bits that are unused.
  * ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK specifies a three-component,
    block-compressed format where each 64-bit compressed texel block encodes
    a 4{times}4 rectangle of unsigned normalized RGB texel data.
    This format has no alpha and is considered opaque.
  * ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK specifies a three-component,
    block-compressed format where each 64-bit compressed texel block encodes
    a 4{times}4 rectangle of unsigned normalized RGB texel data with sRGB
    nonlinear encoding.
    This format has no alpha and is considered opaque.
  * ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK specifies a four-component,
    block-compressed format where each 64-bit compressed texel block encodes
    a 4{times}4 rectangle of unsigned normalized RGB texel data, and
    provides 1 bit of alpha.
  * ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK specifies a four-component,
    block-compressed format where each 64-bit compressed texel block encodes
    a 4{times}4 rectangle of unsigned normalized RGB texel data with sRGB
    nonlinear encoding, and provides 1 bit of alpha.
  * ename:VK_FORMAT_BC2_UNORM_BLOCK specifies a four-component,
    block-compressed format where each 128-bit compressed texel block
    encodes a 4{times}4 rectangle of unsigned normalized RGBA texel data
    with the first 64 bits encoding alpha values followed by 64 bits
    encoding RGB values.
  * ename:VK_FORMAT_BC2_SRGB_BLOCK specifies a four-component,
    block-compressed format where each 128-bit compressed texel block
    encodes a 4{times}4 rectangle of unsigned normalized RGBA texel data
    with the first 64 bits encoding alpha values followed by 64 bits
    encoding RGB values with sRGB nonlinear encoding.
  * ename:VK_FORMAT_BC3_UNORM_BLOCK specifies a four-component,
    block-compressed format where each 128-bit compressed texel block
    encodes a 4{times}4 rectangle of unsigned normalized RGBA texel data
    with the first 64 bits encoding alpha values followed by 64 bits
    encoding RGB values.
  * ename:VK_FORMAT_BC3_SRGB_BLOCK specifies a four-component,
    block-compressed format where each 128-bit compressed texel block
    encodes a 4{times}4 rectangle of unsigned normalized RGBA texel data
    with the first 64 bits encoding alpha values followed by 64 bits
    encoding RGB values with sRGB nonlinear encoding.
  * ename:VK_FORMAT_BC4_UNORM_BLOCK specifies a one-component,
    block-compressed format where each 64-bit compressed texel block encodes
    a 4{times}4 rectangle of unsigned normalized red texel data.
  * ename:VK_FORMAT_BC4_SNORM_BLOCK specifies a one-component,
    block-compressed format where each 64-bit compressed texel block encodes
    a 4{times}4 rectangle of signed normalized red texel data.
  * ename:VK_FORMAT_BC5_UNORM_BLOCK specifies a two-component,
    block-compressed format where each 128-bit compressed texel block
    encodes a 4{times}4 rectangle of unsigned normalized RG texel data with
    the first 64 bits encoding red values followed by 64 bits encoding green
    values.
  * ename:VK_FORMAT_BC5_SNORM_BLOCK specifies a two-component,
    block-compressed format where each 128-bit compressed texel block
    encodes a 4{times}4 rectangle of signed normalized RG texel data with
    the first 64 bits encoding red values followed by 64 bits encoding green
    values.
  * ename:VK_FORMAT_BC6H_UFLOAT_BLOCK specifies a three-component,
    block-compressed format where each 128-bit compressed texel block
    encodes a 4{times}4 rectangle of unsigned floating-point RGB texel data.
  * ename:VK_FORMAT_BC6H_SFLOAT_BLOCK specifies a three-component,
    block-compressed format where each 128-bit compressed texel block
    encodes a 4{times}4 rectangle of signed floating-point RGB texel data.
  * ename:VK_FORMAT_BC7_UNORM_BLOCK specifies a four-component,
    block-compressed format where each 128-bit compressed texel block
    encodes a 4{times}4 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_BC7_SRGB_BLOCK specifies a four-component,
    block-compressed format where each 128-bit compressed texel block
    encodes a 4{times}4 rectangle of unsigned normalized RGBA texel data
    with sRGB nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK specifies a three-component,
    ETC2 compressed format where each 64-bit compressed texel block encodes
    a 4{times}4 rectangle of unsigned normalized RGB texel data.
    This format has no alpha and is considered opaque.
  * ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK specifies a three-component, ETC2
    compressed format where each 64-bit compressed texel block encodes a
    4{times}4 rectangle of unsigned normalized RGB texel data with sRGB
    nonlinear encoding.
    This format has no alpha and is considered opaque.
  * ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK specifies a four-component,
    ETC2 compressed format where each 64-bit compressed texel block encodes
    a 4{times}4 rectangle of unsigned normalized RGB texel data, and
    provides 1 bit of alpha.
  * ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK specifies a four-component,
    ETC2 compressed format where each 64-bit compressed texel block encodes
    a 4{times}4 rectangle of unsigned normalized RGB texel data with sRGB
    nonlinear encoding, and provides 1 bit of alpha.
  * ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK specifies a four-component,
    ETC2 compressed format where each 128-bit compressed texel block encodes
    a 4{times}4 rectangle of unsigned normalized RGBA texel data with the
    first 64 bits encoding alpha values followed by 64 bits encoding RGB
    values.
  * ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK specifies a four-component,
    ETC2 compressed format where each 128-bit compressed texel block encodes
    a 4{times}4 rectangle of unsigned normalized RGBA texel data with the
    first 64 bits encoding alpha values followed by 64 bits encoding RGB
    values with sRGB nonlinear encoding applied.
  * ename:VK_FORMAT_EAC_R11_UNORM_BLOCK specifies a one-component, ETC2
    compressed format where each 64-bit compressed texel block encodes a
    4{times}4 rectangle of unsigned normalized red texel data.
  * ename:VK_FORMAT_EAC_R11_SNORM_BLOCK specifies a one-component, ETC2
    compressed format where each 64-bit compressed texel block encodes a
    4{times}4 rectangle of signed normalized red texel data.
  * ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK specifies a two-component, ETC2
    compressed format where each 128-bit compressed texel block encodes a
    4{times}4 rectangle of unsigned normalized RG texel data with the first
    64 bits encoding red values followed by 64 bits encoding green values.
  * ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK specifies a two-component, ETC2
    compressed format where each 128-bit compressed texel block encodes a
    4{times}4 rectangle of signed normalized RG texel data with the first 64
    bits encoding red values followed by 64 bits encoding green values.
  * ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    4{times}4 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    4{times}4 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    5{times}4 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    5{times}4 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    5{times}5 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    5{times}5 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    6{times}5 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    6{times}5 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    6{times}6 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    6{times}6 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes an
    8{times}5 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes an
    8{times}5 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes an
    8{times}6 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes an
    8{times}6 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes an
    8{times}8 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes an
    8{times}8 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    10{times}5 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    10{times}5 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    10{times}6 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    10{times}6 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    10{times}8 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    10{times}8 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    10{times}10 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    10{times}10 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    12{times}10 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    12{times}10 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
  * ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    12{times}12 rectangle of unsigned normalized RGBA texel data.
  * ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK specifies a four-component, ASTC
    compressed format where each 128-bit compressed texel block encodes a
    12{times}12 rectangle of unsigned normalized RGBA texel data with sRGB
    nonlinear encoding applied to the RGB components.
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * ename:VK_FORMAT_G8B8G8R8_422_UNORM specifies a four-component, 32-bit
    format containing a pair of G components, an R component, and a B
    component, collectively encoding a 2{times}1 rectangle of unsigned
    normalized RGB texel data.
    One G value is present at each _i_ coordinate, with the B and R values
    shared across both G values and thus recorded at half the horizontal
    resolution of the image.
    This format has an 8-bit G component for the even _i_ coordinate in byte
    0, an 8-bit B component in byte 1, an 8-bit G component for the odd _i_
    coordinate in byte 2, and an 8-bit R component in byte 3.
    Images in this format must: be defined with a width that is a multiple
    of two.
    For the purposes of the constraints on copy extents, this format is
    treated as a compressed format with a 2{times}1 compressed texel block.
  * ename:VK_FORMAT_B8G8R8G8_422_UNORM specifies a four-component, 32-bit
    format containing a pair of G components, an R component, and a B
    component, collectively encoding a 2{times}1 rectangle of unsigned
    normalized RGB texel data.
    One G value is present at each _i_ coordinate, with the B and R values
    shared across both G values and thus recorded at half the horizontal
    resolution of the image.
    This format has an 8-bit B component in byte 0, an 8-bit G component for
    the even _i_ coordinate in byte 1, an 8-bit R component in byte 2, and
    an 8-bit G component for the odd _i_ coordinate in byte 3.
    Images in this format must: be defined with a width that is a multiple
    of two.
    For the purposes of the constraints on copy extents, this format is
    treated as a compressed format with a 2{times}1 compressed texel block.
  * ename:VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM specifies an unsigned
    normalized _multi-planar format_ that has an 8-bit G component in plane
    0, an 8-bit B component in plane 1, and an 8-bit R component in plane 2.
    The horizontal and vertical dimensions of the R and B planes are halved
    relative to the image dimensions, and each R and B component is shared
    with the G components for which latexmath:[\lfloor i_G \times 0.5
    \rfloor = i_B = i_R] and latexmath:[\lfloor j_G \times 0.5 \rfloor = j_B
    = j_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane,
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
    Images in this format must: be defined with a width and height that is a
    multiple of two.
  * ename:VK_FORMAT_G8_B8R8_2PLANE_420_UNORM specifies an unsigned
    normalized _multi-planar format_ that has an 8-bit G component in plane
    0, and a two-component, 16-bit BR plane 1 consisting of an 8-bit B
    component in byte 0 and an 8-bit R component in byte 1.
    The horizontal and vertical dimensions of the BR plane is halved
    relative to the image dimensions, and each R and B value is shared with
    the G components for which latexmath:[\lfloor i_G \times 0.5 \rfloor =
    i_B = i_R] and latexmath:[\lfloor j_G \times 0.5 \rfloor = j_B = j_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane.
    Images in this format must: be defined with a width and height that is a
    multiple of two.
  * ename:VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM specifies an unsigned
    normalized _multi-planar format_ that has an 8-bit G component in plane
    0, an 8-bit B component in plane 1, and an 8-bit R component in plane 2.
    The horizontal dimension of the R and B plane is halved relative to the
    image dimensions, and each R and B value is shared with the G components
    for which latexmath:[\lfloor i_G \times 0.5 \rfloor = i_B = i_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane,
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
    Images in this format must: be defined with a width that is a multiple
    of two.
  * ename:VK_FORMAT_G8_B8R8_2PLANE_422_UNORM specifies an unsigned
    normalized _multi-planar format_ that has an 8-bit G component in plane
    0, and a two-component, 16-bit BR plane 1 consisting of an 8-bit B
    component in byte 0 and an 8-bit R component in byte 1.
    The horizontal dimensions of the BR plane is halved relative to the
    image dimensions, and each R and B value is shared with the G components
    for which latexmath:[\lfloor i_G \times 0.5 \rfloor = i_B = i_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane.
    Images in this format must: be defined with a width that is a multiple
    of two.
  * ename:VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM specifies an unsigned
    normalized _multi-planar format_ that has an 8-bit G component in plane
    0, an 8-bit B component in plane 1, and an 8-bit R component in plane 2.
    Each plane has the same dimensions and each R, G and B component
    contributes to a single texel.
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane,
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
  * ename:VK_FORMAT_R10X6_UNORM_PACK16 specifies a one-component, 16-bit
    unsigned normalized format that has a single 10-bit R component in the
    top 10 bits of a 16-bit word, with the bottom 6 bits set to 0.
  * ename:VK_FORMAT_R10X6G10X6_UNORM_2PACK16 specifies a two-component,
    32-bit unsigned normalized format that has a 10-bit R component in the
    top 10 bits of the word in bytes 0..1, and a 10-bit G component in the
    top 10 bits of the word in bytes 2..3, with the bottom 6 bits of each
    word set to 0.
  * ename:VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 specifies a
    four-component, 64-bit unsigned normalized format that has a 10-bit R
    component in the top 10 bits of the word in bytes 0..1, a 10-bit G
    component in the top 10 bits of the word in bytes 2..3, a 10-bit B
    component in the top 10 bits of the word in bytes 4..5, and a 10-bit A
    component in the top 10 bits of the word in bytes 6..7, with the bottom
    6 bits of each word set to 0.
  * ename:VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 specifies a
    four-component, 64-bit format containing a pair of G components, an R
    component, and a B component, collectively encoding a 2{times}1
    rectangle of unsigned normalized RGB texel data.
    One G value is present at each _i_ coordinate, with the B and R values
    shared across both G values and thus recorded at half the horizontal
    resolution of the image.
    This format has a 10-bit G component for the even _i_ coordinate in the
    top 10 bits of the word in bytes 0..1, a 10-bit B component in the top
    10 bits of the word in bytes 2..3, a 10-bit G component for the odd _i_
    coordinate in the top 10 bits of the word in bytes 4..5, and a 10-bit R
    component in the top 10 bits of the word in bytes 6..7, with the bottom
    6 bits of each word set to 0.
    Images in this format must: be defined with a width that is a multiple
    of two.
    For the purposes of the constraints on copy extents, this format is
    treated as a compressed format with a 2{times}1 compressed texel block.
  * ename:VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 specifies a
    four-component, 64-bit format containing a pair of G components, an R
    component, and a B component, collectively encoding a 2{times}1
    rectangle of unsigned normalized RGB texel data.
    One G value is present at each _i_ coordinate, with the B and R values
    shared across both G values and thus recorded at half the horizontal
    resolution of the image.
    This format has a 10-bit B component in the top 10 bits of the word in
    bytes 0..1, a 10-bit G component for the even _i_ coordinate in the top
    10 bits of the word in bytes 2..3, a 10-bit R component in the top 10
    bits of the word in bytes 4..5, and a 10-bit G component for the odd _i_
    coordinate in the top 10 bits of the word in bytes 6..7, with the bottom
    6 bits of each word set to 0.
    Images in this format must: be defined with a width that is a multiple
    of two.
    For the purposes of the constraints on copy extents, this format is
    treated as a compressed format with a 2{times}1 compressed texel block.
  * ename:VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 specifies an
    unsigned normalized _multi-planar format_ that has a 10-bit G component
    in the top 10 bits of each 16-bit word of plane 0, a 10-bit B component
    in the top 10 bits of each 16-bit word of plane 1, and a 10-bit R
    component in the top 10 bits of each 16-bit word of plane 2, with the
    bottom 6 bits of each word set to 0.
    The horizontal and vertical dimensions of the R and B planes are halved
    relative to the image dimensions, and each R and B component is shared
    with the G components for which latexmath:[\lfloor i_G \times 0.5
    \rfloor = i_B = i_R] and latexmath:[\lfloor j_G \times 0.5 \rfloor = j_B
    = j_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane,
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
    Images in this format must: be defined with a width and height that is a
    multiple of two.
  * ename:VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 specifies an
    unsigned normalized _multi-planar format_ that has a 10-bit G component
    in the top 10 bits of each 16-bit word of plane 0, and a two-component,
    32-bit BR plane 1 consisting of a 10-bit B component in the top 10 bits
    of the word in bytes 0..1, and a 10-bit R component in the top 10 bits
    of the word in bytes 2..3, the bottom 6 bits of each word set to 0.
    The horizontal and vertical dimensions of the BR plane is halved
    relative to the image dimensions, and each R and B value is shared with
    the G components for which latexmath:[\lfloor i_G \times 0.5 \rfloor =
    i_B = i_R] and latexmath:[\lfloor j_G \times 0.5 \rfloor = j_B = j_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane.
    Images in this format must: be defined with a width and height that is a
    multiple of two.
  * ename:VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 specifies an
    unsigned normalized _multi-planar format_ that has a 10-bit G component
    in the top 10 bits of each 16-bit word of plane 0, a 10-bit B component
    in the top 10 bits of each 16-bit word of plane 1, and a 10-bit R
    component in the top 10 bits of each 16-bit word of plane 2, with the
    bottom 6 bits of each word set to 0.
    The horizontal dimension of the R and B plane is halved relative to the
    image dimensions, and each R and B value is shared with the G components
    for which latexmath:[\lfloor i_G \times 0.5 \rfloor = i_B = i_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane,
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
    Images in this format must: be defined with a width that is a multiple
    of two.
  * ename:VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 specifies an
    unsigned normalized _multi-planar format_ that has a 10-bit G component
    in the top 10 bits of each 16-bit word of plane 0, and a two-component,
    32-bit BR plane 1 consisting of a 10-bit B component in the top 10 bits
    of the word in bytes 0..1, and a 10-bit R component in the top 10 bits
    of the word in bytes 2..3, the bottom 6 bits of each word set to 0.
    The horizontal dimensions of the BR plane is halved relative to the
    image dimensions, and each R and B value is shared with the G components
    for which latexmath:[\lfloor i_G \times 0.5 \rfloor = i_B = i_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane.
    Images in this format must: be defined with a width that is a multiple
    of two.
  * ename:VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 specifies an
    unsigned normalized _multi-planar format_ that has a 10-bit G component
    in the top 10 bits of each 16-bit word of plane 0, a 10-bit B component
    in the top 10 bits of each 16-bit word of plane 1, and a 10-bit R
    component in the top 10 bits of each 16-bit word of plane 2, with the
    bottom 6 bits of each word set to 0.
    Each plane has the same dimensions and each R, G and B component
    contributes to a single texel.
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane,
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
  * ename:VK_FORMAT_R12X4_UNORM_PACK16 specifies a one-component, 16-bit
    unsigned normalized format that has a single 12-bit R component in the
    top 12 bits of a 16-bit word, with the bottom 4 bits set to 0.
  * ename:VK_FORMAT_R12X4G12X4_UNORM_2PACK16 specifies a two-component,
    32-bit unsigned normalized format that has a 12-bit R component in the
    top 12 bits of the word in bytes 0..1, and a 12-bit G component in the
    top 12 bits of the word in bytes 2..3, with the bottom 4 bits of each
    word set to 0.
  * ename:VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 specifies a
    four-component, 64-bit unsigned normalized format that has a 12-bit R
    component in the top 12 bits of the word in bytes 0..1, a 12-bit G
    component in the top 12 bits of the word in bytes 2..3, a 12-bit B
    component in the top 12 bits of the word in bytes 4..5, and a 12-bit A
    component in the top 12 bits of the word in bytes 6..7, with the bottom
    4 bits of each word set to 0.
  * ename:VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 specifies a
    four-component, 64-bit format containing a pair of G components, an R
    component, and a B component, collectively encoding a 2{times}1
    rectangle of unsigned normalized RGB texel data.
    One G value is present at each _i_ coordinate, with the B and R values
    shared across both G values and thus recorded at half the horizontal
    resolution of the image.
    This format has a 12-bit G component for the even _i_ coordinate in the
    top 12 bits of the word in bytes 0..1, a 12-bit B component in the top
    12 bits of the word in bytes 2..3, a 12-bit G component for the odd _i_
    coordinate in the top 12 bits of the word in bytes 4..5, and a 12-bit R
    component in the top 12 bits of the word in bytes 6..7, with the bottom
    4 bits of each word set to 0.
    Images in this format must: be defined with a width that is a multiple
    of two.
    For the purposes of the constraints on copy extents, this format is
    treated as a compressed format with a 2{times}1 compressed texel block.
  * ename:VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 specifies a
    four-component, 64-bit format containing a pair of G components, an R
    component, and a B component, collectively encoding a 2{times}1
    rectangle of unsigned normalized RGB texel data.
    One G value is present at each _i_ coordinate, with the B and R values
    shared across both G values and thus recorded at half the horizontal
    resolution of the image.
    This format has a 12-bit B component in the top 12 bits of the word in
    bytes 0..1, a 12-bit G component for the even _i_ coordinate in the top
    12 bits of the word in bytes 2..3, a 12-bit R component in the top 12
    bits of the word in bytes 4..5, and a 12-bit G component for the odd _i_
    coordinate in the top 12 bits of the word in bytes 6..7, with the bottom
    4 bits of each word set to 0.
    Images in this format must: be defined with a width that is a multiple
    of two.
    For the purposes of the constraints on copy extents, this format is
    treated as a compressed format with a 2{times}1 compressed texel block.
  * ename:VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 specifies an
    unsigned normalized _multi-planar format_ that has a 12-bit G component
    in the top 12 bits of each 16-bit word of plane 0, a 12-bit B component
    in the top 12 bits of each 16-bit word of plane 1, and a 12-bit R
    component in the top 12 bits of each 16-bit word of plane 2, with the
    bottom 4 bits of each word set to 0.
    The horizontal and vertical dimensions of the R and B planes are halved
    relative to the image dimensions, and each R and B component is shared
    with the G components for which latexmath:[\lfloor i_G \times 0.5
    \rfloor = i_B = i_R] and latexmath:[\lfloor j_G \times 0.5 \rfloor = j_B
    = j_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane,
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
    Images in this format must: be defined with a width and height that is a
    multiple of two.
  * ename:VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 specifies an
    unsigned normalized _multi-planar format_ that has a 12-bit G component
    in the top 12 bits of each 16-bit word of plane 0, and a two-component,
    32-bit BR plane 1 consisting of a 12-bit B component in the top 12 bits
    of the word in bytes 0..1, and a 12-bit R component in the top 12 bits
    of the word in bytes 2..3, the bottom 4 bits of each word set to 0.
    The horizontal and vertical dimensions of the BR plane is halved
    relative to the image dimensions, and each R and B value is shared with
    the G components for which latexmath:[\lfloor i_G \times 0.5 \rfloor =
    i_B = i_R] and latexmath:[\lfloor j_G \times 0.5 \rfloor = j_B = j_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane.
    Images in this format must: be defined with a width and height that is a
    multiple of two.
  * ename:VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 specifies an
    unsigned normalized _multi-planar format_ that has a 12-bit G component
    in the top 12 bits of each 16-bit word of plane 0, a 12-bit B component
    in the top 12 bits of each 16-bit word of plane 1, and a 12-bit R
    component in the top 12 bits of each 16-bit word of plane 2, with the
    bottom 4 bits of each word set to 0.
    The horizontal dimension of the R and B plane is halved relative to the
    image dimensions, and each R and B value is shared with the G components
    for which latexmath:[\lfloor i_G \times 0.5 \rfloor = i_B = i_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane,
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
    Images in this format must: be defined with a width that is a multiple
    of two.
  * ename:VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 specifies an
    unsigned normalized _multi-planar format_ that has a 12-bit G component
    in the top 12 bits of each 16-bit word of plane 0, and a two-component,
    32-bit BR plane 1 consisting of a 12-bit B component in the top 12 bits
    of the word in bytes 0..1, and a 12-bit R component in the top 12 bits
    of the word in bytes 2..3, the bottom 4 bits of each word set to 0.
    The horizontal dimensions of the BR plane is halved relative to the
    image dimensions, and each R and B value is shared with the G components
    for which latexmath:[\lfloor i_G \times 0.5 \rfloor = i_B = i_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane.
    Images in this format must: be defined with a width that is a multiple
    of two.
  * ename:VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 specifies an
    unsigned normalized _multi-planar format_ that has a 12-bit G component
    in the top 12 bits of each 16-bit word of plane 0, a 12-bit B component
    in the top 12 bits of each 16-bit word of plane 1, and a 12-bit R
    component in the top 12 bits of each 16-bit word of plane 2, with the
    bottom 4 bits of each word set to 0.
    Each plane has the same dimensions and each R, G and B component
    contributes to a single texel.
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane,
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
  * ename:VK_FORMAT_G16B16G16R16_422_UNORM specifies a four-component,
    64-bit format containing a pair of G components, an R component, and a B
    component, collectively encoding a 2{times}1 rectangle of unsigned
    normalized RGB texel data.
    One G value is present at each _i_ coordinate, with the B and R values
    shared across both G values and thus recorded at half the horizontal
    resolution of the image.
    This format has a 16-bit G component for the even _i_ coordinate in the
    word in bytes 0..1, a 16-bit B component in the word in bytes 2..3, a
    16-bit G component for the odd _i_ coordinate in the word in bytes 4..5,
    and a 16-bit R component in the word in bytes 6..7.
    Images in this format must: be defined with a width that is a multiple
    of two.
    For the purposes of the constraints on copy extents, this format is
    treated as a compressed format with a 2{times}1 compressed texel block.
  * ename:VK_FORMAT_B16G16R16G16_422_UNORM specifies a four-component,
    64-bit format containing a pair of G components, an R component, and a B
    component, collectively encoding a 2{times}1 rectangle of unsigned
    normalized RGB texel data.
    One G value is present at each _i_ coordinate, with the B and R values
    shared across both G values and thus recorded at half the horizontal
    resolution of the image.
    This format has a 16-bit B component in the word in bytes 0..1, a 16-bit
    G component for the even _i_ coordinate in the word in bytes 2..3, a
    16-bit R component in the word in bytes 4..5, and a 16-bit G component
    for the odd _i_ coordinate in the word in bytes 6..7.
    Images in this format must: be defined with a width that is a multiple
    of two.
    For the purposes of the constraints on copy extents, this format is
    treated as a compressed format with a 2{times}1 compressed texel block.
  * ename:VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM specifies an unsigned
    normalized _multi-planar format_ that has a 16-bit G component in each
    16-bit word of plane 0, a 16-bit B component in each 16-bit word of
    plane 1, and a 16-bit R component in each 16-bit word of plane 2.
    The horizontal and vertical dimensions of the R and B planes are halved
    relative to the image dimensions, and each R and B component is shared
    with the G components for which latexmath:[\lfloor i_G \times 0.5
    \rfloor = i_B = i_R] and latexmath:[\lfloor j_G \times 0.5 \rfloor = j_B
    = j_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane,
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
    Images in this format must: be defined with a width and height that is a
    multiple of two.
  * ename:VK_FORMAT_G16_B16R16_2PLANE_420_UNORM specifies an unsigned
    normalized _multi-planar format_ that has a 16-bit G component in each
    16-bit word of plane 0, and a two-component, 32-bit BR plane 1
    consisting of a 16-bit B component in the word in bytes 0..1, and a
    16-bit R component in the word in bytes 2..3.
    The horizontal and vertical dimensions of the BR plane is halved
    relative to the image dimensions, and each R and B value is shared with
    the G components for which latexmath:[\lfloor i_G \times 0.5 \rfloor =
    i_B = i_R] and latexmath:[\lfloor j_G \times 0.5 \rfloor = j_B = j_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane.
    Images in this format must: be defined with a width and height that is a
    multiple of two.
  * ename:VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM specifies an unsigned
    normalized _multi-planar format_ that has a 16-bit G component in each
    16-bit word of plane 0, a 16-bit B component in each 16-bit word of
    plane 1, and a 16-bit R component in each 16-bit word of plane 2.
    The horizontal dimension of the R and B plane is halved relative to the
    image dimensions, and each R and B value is shared with the G components
    for which latexmath:[\lfloor i_G \times 0.5 \rfloor = i_B = i_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane,
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
    Images in this format must: be defined with a width that is a multiple
    of two.
  * ename:VK_FORMAT_G16_B16R16_2PLANE_422_UNORM specifies an unsigned
    normalized _multi-planar format_ that has a 16-bit G component in each
    16-bit word of plane 0, and a two-component, 32-bit BR plane 1
    consisting of a 16-bit B component in the word in bytes 0..1, and a
    16-bit R component in the word in bytes 2..3.
    The horizontal dimensions of the BR plane is halved relative to the
    image dimensions, and each R and B value is shared with the G components
    for which latexmath:[\lfloor i_G \times 0.5 \rfloor = i_B = i_R].
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane.
    Images in this format must: be defined with a width that is a multiple
    of two.
  * ename:VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM specifies an unsigned
    normalized _multi-planar format_ that has a 16-bit G component in each
    16-bit word of plane 0, a 16-bit B component in each 16-bit word of
    plane 1, and a 16-bit R component in each 16-bit word of plane 2.
    Each plane has the same dimensions and each R, G and B component
    contributes to a single texel.
    The location of each plane when this image is in linear layout can be
    determined via flink:vkGetImageSubresourceLayout, using
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane,
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

--


ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

[[features-formats-compatible-planes]]
==== Compatible formats of planes of multi-planar formats

Individual planes of multi-planar formats are _compatible_ with single-plane
formats if they occupy the same number of bits per data element.
In the following table, individual planes of a _multi-planar_ format are
compatible with the format listed against the relevant plane index for that
multi-planar format.

.Plane Format Compatibility Table
[width="95%",cols="1,6,3,3",options="header"]
|====
^| Plane ^| Compatible format for plane ^| Width relative to the width _w_ of the plane with the largest dimensions ^| Height relative to the height _h_ of the plane with the largest dimensions
4+| *ename:VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM*
^| 0     ^| ename:VK_FORMAT_R8_UNORM ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R8_UNORM ^| w/2 ^| h/2
^| 2     ^| ename:VK_FORMAT_R8_UNORM ^| w/2 ^| h/2
4+| *ename:VK_FORMAT_G8_B8R8_2PLANE_420_UNORM*
^| 0     ^| ename:VK_FORMAT_R8_UNORM ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R8G8_UNORM ^| w/2 ^| h/2
4+| *ename:VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM*
^| 0     ^| ename:VK_FORMAT_R8_UNORM ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R8_UNORM ^| w/2 ^| h
^| 2     ^| ename:VK_FORMAT_R8_UNORM ^| w/2 ^| h
4+| *ename:VK_FORMAT_G8_B8R8_2PLANE_422_UNORM*
^| 0     ^| ename:VK_FORMAT_R8_UNORM ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R8G8_UNORM ^| w/2 ^| h
4+| *ename:VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM*
^| 0     ^| ename:VK_FORMAT_R8_UNORM ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R8_UNORM ^| w ^| h
^| 2     ^| ename:VK_FORMAT_R8_UNORM ^| w ^| h
4+| *ename:VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16*
^| 0     ^| ename:VK_FORMAT_R10X6_UNORM_PACK16 ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R10X6_UNORM_PACK16 ^| w/2 ^| h/2
^| 2     ^| ename:VK_FORMAT_R10X6_UNORM_PACK16 ^| w/2 ^| h/2
4+| *ename:VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16*
^| 0     ^| ename:VK_FORMAT_R10X6_UNORM_PACK16 ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R10X6G10X6_UNORM_2PACK16 ^| w/2 ^| h/2
4+| *ename:VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16*
^| 0     ^| ename:VK_FORMAT_R10X6_UNORM_PACK16 ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R10X6_UNORM_PACK16 ^| w/2 ^| h
^| 2     ^| ename:VK_FORMAT_R10X6_UNORM_PACK16 ^| w/2 ^| h
4+| *ename:VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16*
^| 0     ^| ename:VK_FORMAT_R10X6_UNORM_PACK16 ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R10X6G10X6_UNORM_2PACK16 ^| w/2 ^| h
4+| *ename:VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16*
^| 0     ^| ename:VK_FORMAT_R10X6_UNORM_PACK16 ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R10X6_UNORM_PACK16 ^| w ^| h
^| 2     ^| ename:VK_FORMAT_R10X6_UNORM_PACK16 ^| w ^| h
4+| *ename:VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16*
^| 0     ^| ename:VK_FORMAT_R12X4_UNORM_PACK16 ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R12X4_UNORM_PACK16 ^| w/2 ^| h/2
^| 2     ^| ename:VK_FORMAT_R12X4_UNORM_PACK16 ^| w/2 ^| h/2
4+| *ename:VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16*
^| 0     ^| ename:VK_FORMAT_R12X4_UNORM_PACK16 ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R12X4G12X4_UNORM_2PACK16 ^| w/2 ^| h/2
4+| *ename:VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16*
^| 0     ^| ename:VK_FORMAT_R12X4_UNORM_PACK16 ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R12X4_UNORM_PACK16 ^| w/2 ^| h
^| 2     ^| ename:VK_FORMAT_R12X4_UNORM_PACK16 ^| w/2 ^| h
4+| *ename:VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16*
^| 0     ^| ename:VK_FORMAT_R12X4_UNORM_PACK16 ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R12X4G12X4_UNORM_2PACK16 ^| w/2 ^| h
4+| *ename:VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16*
^| 0     ^| ename:VK_FORMAT_R12X4_UNORM_PACK16 ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R12X4_UNORM_PACK16 ^| w ^| h
^| 2     ^| ename:VK_FORMAT_R12X4_UNORM_PACK16 ^| w ^| h
4+| *ename:VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM*
^| 0     ^| ename:VK_FORMAT_R16_UNORM ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R16_UNORM ^| w/2 ^| h/2
^| 2     ^| ename:VK_FORMAT_R16_UNORM ^| w/2 ^| h/2
4+| *ename:VK_FORMAT_G16_B16R16_2PLANE_420_UNORM*
^| 0     ^| ename:VK_FORMAT_R16_UNORM ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R16G16_UNORM ^| w/2 ^| h/2
4+| *ename:VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM*
^| 0     ^| ename:VK_FORMAT_R16_UNORM ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R16_UNORM ^| w/2 ^| h
^| 2     ^| ename:VK_FORMAT_R16_UNORM ^| w/2 ^| h
4+| *ename:VK_FORMAT_G16_B16R16_2PLANE_422_UNORM*
^| 0     ^| ename:VK_FORMAT_R16_UNORM ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R16G16_UNORM ^| w/2 ^| h
4+| *ename:VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM*
^| 0     ^| ename:VK_FORMAT_R16_UNORM ^| w ^| h
^| 1     ^| ename:VK_FORMAT_R16_UNORM ^| w ^| h
^| 2     ^| ename:VK_FORMAT_R16_UNORM ^| w ^| h
|====

endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]


[[features-formats-packed]]
==== Packed Formats

For the purposes of address alignment when accessing buffer memory
containing vertex attribute or texel data, the following formats are
considered _packed_ - whole texels or attributes are stored in a single data
element, rather than individual components occupying a single data element:

  * <<features-formats-packed-8-bit,Packed into 8-bit data types>>:
  ** ename:VK_FORMAT_R4G4_UNORM_PACK8
  * <<features-formats-packed-16-bit,Packed into 16-bit data types>>:
  ** ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16
  ** ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16
  ** ename:VK_FORMAT_R5G6B5_UNORM_PACK16
  ** ename:VK_FORMAT_B5G6R5_UNORM_PACK16
  ** ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16
  ** ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16
  ** ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16
  * <<features-formats-packed-32-bit,Packed into 32-bit data types>>:
  ** ename:VK_FORMAT_A8B8G8R8_UNORM_PACK32
  ** ename:VK_FORMAT_A8B8G8R8_SNORM_PACK32
  ** ename:VK_FORMAT_A8B8G8R8_USCALED_PACK32
  ** ename:VK_FORMAT_A8B8G8R8_SSCALED_PACK32
  ** ename:VK_FORMAT_A8B8G8R8_UINT_PACK32
  ** ename:VK_FORMAT_A8B8G8R8_SINT_PACK32
  ** ename:VK_FORMAT_A8B8G8R8_SRGB_PACK32
  ** ename:VK_FORMAT_A2R10G10B10_UNORM_PACK32
  ** ename:VK_FORMAT_A2R10G10B10_SNORM_PACK32
  ** ename:VK_FORMAT_A2R10G10B10_USCALED_PACK32
  ** ename:VK_FORMAT_A2R10G10B10_SSCALED_PACK32
  ** ename:VK_FORMAT_A2R10G10B10_UINT_PACK32
  ** ename:VK_FORMAT_A2R10G10B10_SINT_PACK32
  ** ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32
  ** ename:VK_FORMAT_A2B10G10R10_SNORM_PACK32
  ** ename:VK_FORMAT_A2B10G10R10_USCALED_PACK32
  ** ename:VK_FORMAT_A2B10G10R10_SSCALED_PACK32
  ** ename:VK_FORMAT_A2B10G10R10_UINT_PACK32
  ** ename:VK_FORMAT_A2B10G10R10_SINT_PACK32
  ** ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32
  ** ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32
  ** ename:VK_FORMAT_X8_D24_UNORM_PACK32


==== Identification of Formats

A "`format`" is represented by a single enum value.
The name of a format is usually built up by using the following pattern:

....
    VK_FORMAT_{component-format|compression-scheme}_{numeric-format}
....

The component-format indicates either the size of the R, G, B, and A
components (if they are present) in the case of a color format, or the size
of the depth (D) and stencil (S) components (if they are present) in the
case of a depth/stencil format (see below).
An X indicates a component that is unused, but may: be present for padding.

<<<

[[features-formats-numericformat]]
.Interpretation of Numeric Format
[width="95%",cols="2,10",options="header"]
|====
| Numeric format | Description
| etext:UNORM    | The components are unsigned normalized values in the range [eq]#[0,1]#
| etext:SNORM    | The components are signed normalized values in the range [eq]#[-1,1]#
| etext:USCALED  | The components are unsigned integer values that get converted to floating-point in the range [0,2^n^-1]
| etext:SSCALED  | The components are signed integer values that get converted to floating-point in the range [-2^n-1^,2^n-1^-1]
| etext:UINT     | The components are unsigned integer values in the range [0,2^n^-1]
| etext:SINT     | The components are signed integer values in the range [-2^n-1^,2^n-1^-1]
| etext:UFLOAT   | The components are unsigned floating-point numbers (used by packed, shared exponent, and some compressed formats)
| etext:SFLOAT   | The components are signed floating-point numbers
| etext:SRGB     | The R, G, and B components are unsigned normalized values that represent values using sRGB nonlinear encoding, while the A component (if one exists) is a regular unsigned normalized value
|====

The suffix etext:_PACKnn indicates that the format is packed into an
underlying type with nn bits.
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
The suffix etext:_mPACKnn is a short-hand that indicates that the format has
several components (which may or may not be stored in separate _planes_)
that are each packed into an underlying type with nn bits.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

The suffix etext:_BLOCK indicates that the format is a block-compressed
format, with the representation of multiple pixels encoded interdependently
within a region.

[[features-formats-compressionscheme]]
.Interpretation of Compression Scheme
[width="95%",cols="2,10",options="header"]
|====
| Compression scheme | Description
| etext:BC           | Block Compression. See <<appendix-compressedtex-bc>>.
| etext:ETC2         | Ericsson Texture Compression. See <<appendix-compressedtex-etc2>>.
| etext:EAC          | ETC2 Alpha Compression. See <<appendix-compressedtex-etc2>>.
| etext:ASTC         | Adaptive Scalable Texture Compression (LDR Profile). See <<appendix-compressedtex-astc>>.
|====

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
For _multi-planar_ images, the components in separate _planes_ are separated
by underscores, and the number of planes is indicated by the addition of a
etext:_2PLANE or etext:_3PLANE suffix.
Similarly, the separate aspects of depth-stencil formats are separated by
underscores, although these are not considered separate planes.
Formats are suffixed by etext:_422 to indicate that planes other than the
first are reduced in size by a factor of two horizontally or that the R and
B values appear at half the horizontal frequency of the G values, etext:_420
to indicate that planes other than the first are reduced in size by a factor
of two both horizontally and vertically, and etext:_444 for consistency to
indicate that all three planes of a three-planar image are the same size.

[NOTE]
.Note
====
No common format has a single plane containing both R and B channels but
does not store these channels at reduced horizontal resolution.
====
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]


==== Representation

Color formats must: be represented in memory in exactly the form indicated
by the format's name.
This means that promoting one format to another with more bits per component
and/or additional components must: not occur for color formats.
Depth/stencil formats have more relaxed requirements as discussed
<<features-formats-depth-stencil,below>>.
Each format has an _element size_, the number of bytes used to stored one
element or one compressed block, with the value of the element size listed
in slink:VkFormat.

The representation of non-packed formats is that the first component
specified in the name of the format is in the lowest memory addresses and
the last component specified is in the highest memory addresses.
See <<features-formats-non-packed,Byte mappings for non-packed/compressed
color formats>>.
The in-memory ordering of bytes within a component is determined by the host
endianness.

[[features-formats-non-packed]]
.Byte mappings for non-packed/compressed color formats
[options="header",cols="16*1,10",width="100%"]
|====
>|0 >|1 >|2 >|3 >|4 >|5 >|6 >|7 >|8 >|9 >|10 >|11 >|12 >|13 >|14 >|15 ^| {leftarrow} Byte
^|R 16+>s|etext:VK_FORMAT_R8_*
^|R ^|G 15+>s|etext:VK_FORMAT_R8G8_*
^|R ^|G ^|B 14+>s|etext:VK_FORMAT_R8G8B8_*
^|B ^|G ^|R 14+>s|etext:VK_FORMAT_B8G8R8_*
^|R ^|G ^|B ^|A 13+>s|etext:VK_FORMAT_R8G8B8A8_*
^|B ^|G ^|R ^|A 13+>s|etext:VK_FORMAT_B8G8R8A8_*
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
^|G~0~ ^|B ^|G~1~ ^|R 13+>s|etext:VK_FORMAT_G8B8G8R8_422_UNORM
^|B ^|G~0~ ^|R ^|G~1~ 13+>s|etext:VK_FORMAT_B8G8R8G8_422_UNORM
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
2+^|R 15+>s|etext:VK_FORMAT_R16_*
2+^|R 2+^|G 13+>s|etext:VK_FORMAT_R16G16_*
2+^|R 2+^|G 2+^|B 11+>s|etext:VK_FORMAT_R16G16B16_*
2+^|R 2+^|G 2+^|B 2+^|A 9+>s|etext:VK_FORMAT_R16G16B16A16_*
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
2+^|G~0~ 2+^|B 2+^|G~1~ 2+^|R 9+>s|etext:VK_FORMAT_G10X6B10X6G10X6R10X6_4PACK16_422_UNORM
etext:VK_FORMAT_G12X4B12X4G12X4R12X4_4PACK16_422_UNORM
etext:VK_FORMAT_G16B16G16R16_UNORM
2+^|B 2+^|G~0~ 2+^|R 2+^|G~1~ 9+>s|etext:VK_FORMAT_B10X6G10X6R10X6G10X6_4PACK16_422_UNORM
etext:VK_FORMAT_B12X4G12X4R12X4G12X4_4PACK16_422_UNORM
etext:VK_FORMAT_B16G16R16G16_422_UNORM
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
4+^|R 13+>s|etext:VK_FORMAT_R32_*
4+^|R 4+^|G 9+>s|etext:VK_FORMAT_R32G32_*
4+^|R 4+^|G 4+^|B 5+>s|etext:VK_FORMAT_R32G32B32_*
4+^|R 4+^|G 4+^|B 4+^|A >s|etext:VK_FORMAT_R32G32B32A32_*
8+^|R 9+>s|etext:VK_FORMAT_R64_*
8+^|R 8+^|G >s|etext:VK_FORMAT_R64G64_*
17+^s|etext:VK_FORMAT_R64G64B64_* as etext:VK_FORMAT_R64G64_* but with B in bytes 16-23
17+^s|etext:VK_FORMAT_R64G64B64A64_* as etext:VK_FORMAT_R64G64B64_* but with A in bytes 24-31
|====

Packed formats store multiple components within one underlying type.
The bit representation is that the first component specified in the name of
the format is in the most-significant bits and the last component specified
is in the least-significant bits of the underlying type.
The in-memory ordering of bytes comprising the underlying type is determined
by the host endianness.

[[features-formats-packed-8-bit]]
.Bit mappings for packed 8-bit formats
[options="header",cols="8*1",width="100%"]
|====
8+^h| Bit
>|~7~ >|~6~ >|~5~ >|~4~ >|~3~ >|~2~ >|~1~ >|~0~
8+^h| ename:VK_FORMAT_R4G4_UNORM_PACK8
4+^s|R 4+^s|G
^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
|====

[[features-formats-packed-16-bit]]
.Bit mappings for packed 16-bit formats
[options="header",cols="16*1",width="100%"]
|====
16+^h| Bit
>|~15~ >|~14~ >|~13~ >|~12~ >|~11~ >|~10~ >|~9~ >|~8~ >|~7~ >|~6~ >|~5~ >|~4~ >|~3~ >|~2~ >|~1~ >|~0~
16+^h|ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16
4+^s|R 4+^s|G 4+^s|B 4+^s|A
^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
16+^h|ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16
4+^s|B 4+^s|G 4+^s|R 4+^s|A
^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
16+^h|ename:VK_FORMAT_R5G6B5_UNORM_PACK16
5+^s|R 6+^s|G 5+^s|B
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~5~ ^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
16+^h|ename:VK_FORMAT_B5G6R5_UNORM_PACK16
5+^s|B 6+^s|G 5+^s|R
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~5~ ^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
16+^h|ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16
5+^s|R 5+^s|G 5+^s|B 1+^s|A
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~0~
16+^h|ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16
5+^s|B 5+^s|G 5+^s|R 1+^s|A
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~0~
16+^h|ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16
1+^s|A 5+^s|R 5+^s|G 5+^s|B
^| ~0~
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
16+^h|ename:VK_FORMAT_R10X6_UNORM_PACK16
10+^s|R 6+^s|X
^| ~9~ ^| ~8~ ^| ~7~ ^| ~6~ ^| ~5~
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~5~ ^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
16+^h|ename:VK_FORMAT_R12X4_UNORM_PACK16
12+^s|R 4+^s|X
^| ~11~ ^| ~10~
^| ~9~ ^| ~8~ ^| ~7~ ^| ~6~ ^| ~5~
^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
|====

[[features-formats-packed-32-bit]]
.Bit mappings for packed 32-bit formats
[cols="32*1",options="header"]
|====
32+^h|Bit
>|~31~ >|~30~ >|~29~ >|~28~ >|~27~ >|~26~ >|~25~ >|~24~ >|~23~ >|~22~ >|~21~ >|~20~ >|~19~ >|~18~ >|~17~ >|~16~
>|~15~ >|~14~ >|~13~ >|~12~ >|~11~ >|~10~ >|~9~ >|~8~ >|~7~ >|~6~ >|~5~ >|~4~ >|~3~ >|~2~ >|~1~ >|~0~
32+^h|etext:VK_FORMAT_A8B8G8R8_*_PACK32
8+^s|A 8+^s|B 8+^s|G 8+^s|R
^|~7~ ^|~6~ ^|~5~ ^|~4~
^|~3~ ^|~2~ ^|~1~ ^|~0~
^|~7~ ^|~6~ ^|~5~ ^|~4~
^|~3~ ^|~2~ ^|~1~ ^|~0~
^|~7~ ^|~6~ ^|~5~ ^|~4~
^|~3~ ^|~2~ ^|~1~ ^|~0~
^|~7~ ^|~6~ ^|~5~ ^|~4~
^|~3~ ^|~2~ ^|~1~ ^|~0~
32+^h|etext:VK_FORMAT_A2R10G10B10_*_PACK32
2+^s|A 10+^s|R 10+^s|G 10+^s|B
^|~1~ ^|~0~
^|~9~ ^|~8~ ^|~7~ ^|~6~ ^|~5~
^|~4~ ^|~3~ ^|~2~ ^|~1~ ^|~0~
^|~9~ ^|~8~ ^|~7~ ^|~6~ ^|~5~
^|~4~ ^|~3~ ^|~2~ ^|~1~ ^|~0~
^|~9~ ^|~8~ ^|~7~ ^|~6~ ^|~5~
^|~4~ ^|~3~ ^|~2~ ^|~1~ ^|~0~
32+^h|etext:VK_FORMAT_A2B10G10R10_*_PACK32
2+^s|A 10+^s|B 10+^s|G 10+^s|R
^|~1~ ^|~0~
^|~9~ ^|~8~ ^|~7~ ^|~6~ ^|~5~
^|~4~ ^|~3~ ^|~2~ ^|~1~ ^|~0~
^|~9~ ^|~8~ ^|~7~ ^|~6~ ^|~5~
^|~4~ ^|~3~ ^|~2~ ^|~1~ ^|~0~
^|~9~ ^|~8~ ^|~7~ ^|~6~ ^|~5~
^|~4~ ^|~3~ ^|~2~ ^|~1~ ^|~0~
32+^h|ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32
10+^s|B 11+^s|G 11+^s|R
^|~9~ ^|~8~ ^|~7~ ^|~6~ ^|~5~
^|~4~ ^|~3~ ^|~2~ ^|~1~ ^|~0~
^|~10~ ^|~9~ ^|~8~ ^|~7~ ^|~6~ ^|~5~
^|~4~ ^|~3~ ^|~2~ ^|~1~ ^|~0~
^|~10~ ^|~9~ ^|~8~ ^|~7~ ^|~6~ ^|~5~
^|~4~ ^|~3~ ^|~2~ ^|~1~ ^|~0~
32+^h|ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32
5+^s|E 9+^s|B 9+^s|G 9+^s|R
^|~4~ ^|~3~ ^|~2~ ^|~1~ ^|~0~
^|~8~ ^|~7~ ^|~6~ ^|~5~
^|~4~ ^|~3~ ^|~2~ ^|~1~ ^|~0~
^|~8~ ^|~7~ ^|~6~ ^|~5~
^|~4~ ^|~3~ ^|~2~ ^|~1~ ^|~0~
^|~8~ ^|~7~ ^|~6~ ^|~5~
^|~4~ ^|~3~ ^|~2~ ^|~1~ ^|~0~
32+^h|ename:VK_FORMAT_X8_D24_UNORM_PACK32
8+^s|X 24+^s|D
^|~7~ ^|~6~ ^|~5~ ^|~4~
^|~3~ ^|~2~ ^|~1~ ^|~0~
^|~23~ ^|~22~ ^|~21~ ^|~20~
^|~19~ ^|~18~ ^|~17~ ^|~16~
^|~15~ ^|~14~ ^|~13~ ^|~12~
^|~11~ ^|~10~ ^|~9~ ^|~8~
^|~7~ ^|~6~ ^|~5~ ^|~4~
^|~3~ ^|~2~ ^|~1~ ^|~0~
|====


[[features-formats-depth-stencil]]
==== Depth/Stencil Formats

Depth/stencil formats are considered opaque and need not be stored in the
exact number of bits per texel or component ordering indicated by the format
enum.
However, implementations must: not substitute a different depth or stencil
precision than that described in the format (e.g. D16 must: not be
implemented as D24 or D32).


[[features-formats-compatibility-classes]]
==== Format Compatibility Classes

Uncompressed color formats are _compatible_ with each other if they occupy
the same number of bits per data element.
Compressed color formats are compatible with each other if the only
difference between them is the numerical type of the uncompressed pixels
(e.g. signed vs.
unsigned, or SRGB vs.
UNORM encoding).
Each depth/stencil format is only compatible with itself.
In the <<features-formats-compatibility,following>> table, all the formats
in the same row are compatible.


[[features-formats-compatibility]]
.Compatible formats
[width="90%",cols="4,10",options="header"]
|====
| Class           | Formats
| 8-bit           | ename:VK_FORMAT_R4G4_UNORM_PACK8, +
                    ename:VK_FORMAT_R8_UNORM, +
                    ename:VK_FORMAT_R8_SNORM, +
                    ename:VK_FORMAT_R8_USCALED, +
                    ename:VK_FORMAT_R8_SSCALED, +
                    ename:VK_FORMAT_R8_UINT, +
                    ename:VK_FORMAT_R8_SINT, +
                    ename:VK_FORMAT_R8_SRGB
| 16-bit          | ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16, +
                    ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16, +
                    ename:VK_FORMAT_R5G6B5_UNORM_PACK16, +
                    ename:VK_FORMAT_B5G6R5_UNORM_PACK16, +
                    ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16, +
                    ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16, +
                    ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16, +
                    ename:VK_FORMAT_R8G8_UNORM, +
                    ename:VK_FORMAT_R8G8_SNORM, +
                    ename:VK_FORMAT_R8G8_USCALED, +
                    ename:VK_FORMAT_R8G8_SSCALED, +
                    ename:VK_FORMAT_R8G8_UINT, +
                    ename:VK_FORMAT_R8G8_SINT, +
                    ename:VK_FORMAT_R8G8_SRGB, +
                    ename:VK_FORMAT_R16_UNORM, +
                    ename:VK_FORMAT_R16_SNORM, +
                    ename:VK_FORMAT_R16_USCALED, +
                    ename:VK_FORMAT_R16_SSCALED, +
                    ename:VK_FORMAT_R16_UINT, +
                    ename:VK_FORMAT_R16_SINT, +
ifndef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
                    ename:VK_FORMAT_R16_SFLOAT
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
                    ename:VK_FORMAT_R16_SFLOAT, +
                    ename:VK_FORMAT_R10X6_UNORM_PACK16, +
                    ename:VK_FORMAT_R12X4_UNORM_PACK16
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
| 24-bit          | ename:VK_FORMAT_R8G8B8_UNORM, +
                    ename:VK_FORMAT_R8G8B8_SNORM, +
                    ename:VK_FORMAT_R8G8B8_USCALED, +
                    ename:VK_FORMAT_R8G8B8_SSCALED, +
                    ename:VK_FORMAT_R8G8B8_UINT, +
                    ename:VK_FORMAT_R8G8B8_SINT, +
                    ename:VK_FORMAT_R8G8B8_SRGB, +
                    ename:VK_FORMAT_B8G8R8_UNORM, +
                    ename:VK_FORMAT_B8G8R8_SNORM, +
                    ename:VK_FORMAT_B8G8R8_USCALED, +
                    ename:VK_FORMAT_B8G8R8_SSCALED, +
                    ename:VK_FORMAT_B8G8R8_UINT, +
                    ename:VK_FORMAT_B8G8R8_SINT, +
                    ename:VK_FORMAT_B8G8R8_SRGB
| 32-bit          | ename:VK_FORMAT_R8G8B8A8_UNORM, +
                    ename:VK_FORMAT_R8G8B8A8_SNORM, +
                    ename:VK_FORMAT_R8G8B8A8_USCALED, +
                    ename:VK_FORMAT_R8G8B8A8_SSCALED, +
                    ename:VK_FORMAT_R8G8B8A8_UINT, +
                    ename:VK_FORMAT_R8G8B8A8_SINT, +
                    ename:VK_FORMAT_R8G8B8A8_SRGB, +
                    ename:VK_FORMAT_B8G8R8A8_UNORM, +
                    ename:VK_FORMAT_B8G8R8A8_SNORM, +
                    ename:VK_FORMAT_B8G8R8A8_USCALED, +
                    ename:VK_FORMAT_B8G8R8A8_SSCALED, +
                    ename:VK_FORMAT_B8G8R8A8_UINT, +
                    ename:VK_FORMAT_B8G8R8A8_SINT, +
                    ename:VK_FORMAT_B8G8R8A8_SRGB, +
                    ename:VK_FORMAT_A8B8G8R8_UNORM_PACK32, +
                    ename:VK_FORMAT_A8B8G8R8_SNORM_PACK32, +
                    ename:VK_FORMAT_A8B8G8R8_USCALED_PACK32, +
                    ename:VK_FORMAT_A8B8G8R8_SSCALED_PACK32, +
                    ename:VK_FORMAT_A8B8G8R8_UINT_PACK32, +
                    ename:VK_FORMAT_A8B8G8R8_SINT_PACK32, +
                    ename:VK_FORMAT_A8B8G8R8_SRGB_PACK32, +
                    ename:VK_FORMAT_A2R10G10B10_UNORM_PACK32, +
                    ename:VK_FORMAT_A2R10G10B10_SNORM_PACK32, +
                    ename:VK_FORMAT_A2R10G10B10_USCALED_PACK32, +
                    ename:VK_FORMAT_A2R10G10B10_SSCALED_PACK32, +
                    ename:VK_FORMAT_A2R10G10B10_UINT_PACK32, +
                    ename:VK_FORMAT_A2R10G10B10_SINT_PACK32, +
                    ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32, +
                    ename:VK_FORMAT_A2B10G10R10_SNORM_PACK32, +
                    ename:VK_FORMAT_A2B10G10R10_USCALED_PACK32, +
                    ename:VK_FORMAT_A2B10G10R10_SSCALED_PACK32, +
                    ename:VK_FORMAT_A2B10G10R10_UINT_PACK32, +
                    ename:VK_FORMAT_A2B10G10R10_SINT_PACK32, +
                    ename:VK_FORMAT_R16G16_UNORM, +
                    ename:VK_FORMAT_R16G16_SNORM, +
                    ename:VK_FORMAT_R16G16_USCALED, +
                    ename:VK_FORMAT_R16G16_SSCALED, +
                    ename:VK_FORMAT_R16G16_UINT, +
                    ename:VK_FORMAT_R16G16_SINT, +
                    ename:VK_FORMAT_R16G16_SFLOAT, +
                    ename:VK_FORMAT_R32_UINT, +
                    ename:VK_FORMAT_R32_SINT, +
                    ename:VK_FORMAT_R32_SFLOAT, +
                    ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32, +
ifndef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
                    ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
                    ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32, +
                    ename:VK_FORMAT_R10X6G10X6_UNORM_2PACK16, +
                    ename:VK_FORMAT_R12X4G12X4_UNORM_2PACK16
| 32-bit G8B8G8R8 | ename:VK_FORMAT_G8B8G8R8_422_UNORM
| 32-bit B8G8R8G8 | ename:VK_FORMAT_B8G8R8G8_422_UNORM
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
| 48-bit          | ename:VK_FORMAT_R16G16B16_UNORM, +
                    ename:VK_FORMAT_R16G16B16_SNORM, +
                    ename:VK_FORMAT_R16G16B16_USCALED, +
                    ename:VK_FORMAT_R16G16B16_SSCALED, +
                    ename:VK_FORMAT_R16G16B16_UINT, +
                    ename:VK_FORMAT_R16G16B16_SINT, +
                    ename:VK_FORMAT_R16G16B16_SFLOAT
| 64-bit          | ename:VK_FORMAT_R16G16B16A16_UNORM, +
                    ename:VK_FORMAT_R16G16B16A16_SNORM, +
                    ename:VK_FORMAT_R16G16B16A16_USCALED, +
                    ename:VK_FORMAT_R16G16B16A16_SSCALED, +
                    ename:VK_FORMAT_R16G16B16A16_UINT, +
                    ename:VK_FORMAT_R16G16B16A16_SINT, +
                    ename:VK_FORMAT_R16G16B16A16_SFLOAT, +
                    ename:VK_FORMAT_R32G32_UINT, +
                    ename:VK_FORMAT_R32G32_SINT, +
                    ename:VK_FORMAT_R32G32_SFLOAT, +
                    ename:VK_FORMAT_R64_UINT, +
                    ename:VK_FORMAT_R64_SINT, +
                    ename:VK_FORMAT_R64_SFLOAT
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
| 64-bit R10G10B10A10 | ename:VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16
| 64-bit G10B10G10R10 | ename:VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16
| 64-bit B10G10R10G10 | ename:VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16
| 64-bit R12G12B12A12 | ename:VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16
| 64-bit G12B12G12R12 | ename:VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16
| 64-bit B12G12R12G12 | ename:VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16
| 64-bit G16B16G16R16 | ename:VK_FORMAT_G16B16G16R16_422_UNORM
| 64-bit B16G16R16G16 | ename:VK_FORMAT_B16G16R16G16_422_UNORM
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
| 96-bit          | ename:VK_FORMAT_R32G32B32_UINT, +
                    ename:VK_FORMAT_R32G32B32_SINT, +
                    ename:VK_FORMAT_R32G32B32_SFLOAT
| 128-bit         | ename:VK_FORMAT_R32G32B32A32_UINT, +
                    ename:VK_FORMAT_R32G32B32A32_SINT, +
                    ename:VK_FORMAT_R32G32B32A32_SFLOAT, +
                    ename:VK_FORMAT_R64G64_UINT, +
                    ename:VK_FORMAT_R64G64_SINT, +
                    ename:VK_FORMAT_R64G64_SFLOAT
| 192-bit         | ename:VK_FORMAT_R64G64B64_UINT, +
                    ename:VK_FORMAT_R64G64B64_SINT, +
                    ename:VK_FORMAT_R64G64B64_SFLOAT
| 256-bit         | ename:VK_FORMAT_R64G64B64A64_UINT, +
                    ename:VK_FORMAT_R64G64B64A64_SINT, +
                    ename:VK_FORMAT_R64G64B64A64_SFLOAT
| BC1_RGB         | ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK
| BC1_RGBA        | ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK
| BC2             | ename:VK_FORMAT_BC2_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC2_SRGB_BLOCK
| BC3             | ename:VK_FORMAT_BC3_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC3_SRGB_BLOCK
| BC4             | ename:VK_FORMAT_BC4_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC4_SNORM_BLOCK
| BC5             | ename:VK_FORMAT_BC5_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC5_SNORM_BLOCK
| BC6H            | ename:VK_FORMAT_BC6H_UFLOAT_BLOCK, +
                    ename:VK_FORMAT_BC6H_SFLOAT_BLOCK
| BC7             | ename:VK_FORMAT_BC7_UNORM_BLOCK, +
                    ename:VK_FORMAT_BC7_SRGB_BLOCK
| ETC2_RGB        | ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK, +
                    ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
| ETC2_RGBA       | ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK, +
                    ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
| ETC2_EAC_RGBA   | ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK, +
                    ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
| EAC_R           | ename:VK_FORMAT_EAC_R11_UNORM_BLOCK, +
                    ename:VK_FORMAT_EAC_R11_SNORM_BLOCK
| EAC_RG          | ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK, +
                    ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK
| ASTC_4x4        | ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK
| ASTC_5x4        | ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK
| ASTC_5x5        | ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK
| ASTC_6x5        | ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK
| ASTC_6x6        | ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK
| ASTC_8x5        | ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK
| ASTC_8x6        | ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK
| ASTC_8x8        | ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK
| ASTC_10x5       | ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK
| ASTC_10x6       | ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK
| ASTC_10x8       | ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK
| ASTC_10x10      | ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK
| ASTC_12x10      | ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK
| ASTC_12x12      | ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK, +
                    ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK
| D16             | ename:VK_FORMAT_D16_UNORM
| D24             | ename:VK_FORMAT_X8_D24_UNORM_PACK32
| D32             | ename:VK_FORMAT_D32_SFLOAT
| S8              | ename:VK_FORMAT_S8_UINT
| D16S8           | ename:VK_FORMAT_D16_UNORM_S8_UINT
| D24S8           | ename:VK_FORMAT_D24_UNORM_S8_UINT
| D32S8           | ename:VK_FORMAT_D32_SFLOAT_S8_UINT
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
| 8-bit 3-plane 420 | ename:VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM
| 8-bit 2-plane 420 | ename:VK_FORMAT_G8_B8R8_2PLANE_420_UNORM
| 8-bit 3-plane 422 | ename:VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM
| 8-bit 2-plane 422 | ename:VK_FORMAT_G8_B8R8_2PLANE_422_UNORM
| 8-bit 3-plane 444 | ename:VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM
| 10-bit 3-plane 420 | ename:VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16
| 10-bit 2-plane 420 | ename:VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16
| 10-bit 3-plane 422 | ename:VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16
| 10-bit 2-plane 422 | ename:VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16
| 10-bit 3-plane 444 | ename:VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16
| 12-bit 3-plane 420 | ename:VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16
| 12-bit 2-plane 420 | ename:VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16
| 12-bit 3-plane 422 | ename:VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16
| 12-bit 2-plane 422 | ename:VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16
| 12-bit 3-plane 444 | ename:VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16
| 16-bit 3-plane 420 | ename:VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM
| 16-bit 2-plane 420 | ename:VK_FORMAT_G16_B16R16_2PLANE_420_UNORM
| 16-bit 3-plane 422 | ename:VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM
| 16-bit 2-plane 422 | ename:VK_FORMAT_G16_B16R16_2PLANE_422_UNORM
| 16-bit 3-plane 444 | ename:VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
|====


[[features-formats-properties]]
=== Format Properties

[open,refpage='vkGetPhysicalDeviceFormatProperties',desc='Lists physical device\'s format capabilities',type='protos']
--

To query supported format features which are properties of the physical
device, call:

include::../api/protos/vkGetPhysicalDeviceFormatProperties.txt[]

  * pname:physicalDevice is the physical device from which to query the
    format properties.
  * pname:format is the format whose properties are queried.
  * pname:pFormatProperties is a pointer to a slink:VkFormatProperties
    structure in which physical device properties for pname:format are
    returned.

include::../validity/protos/vkGetPhysicalDeviceFormatProperties.txt[]
--

[open,refpage='VkFormatProperties',desc='Structure specifying image format properties',type='structs']
--

The sname:VkFormatProperties structure is defined as:

include::../api/structs/VkFormatProperties.txt[]

  * pname:linearTilingFeatures is a bitmask of elink:VkFormatFeatureFlagBits
    specifying features supported by images created with a pname:tiling
    parameter of ename:VK_IMAGE_TILING_LINEAR.
  * pname:optimalTilingFeatures is a bitmask of
    elink:VkFormatFeatureFlagBits specifying features supported by images
    created with a pname:tiling parameter of ename:VK_IMAGE_TILING_OPTIMAL.
  * pname:bufferFeatures is a bitmask of elink:VkFormatFeatureFlagBits
    specifying features supported by buffers.

[NOTE]
.Note
====
ifndef::VK_VERSION_1_1,VK_KHR_maintenance1[]
If no format feature flags are supported, then the only possible use would
be image transfers - which alone are not useful.
As such, if no format feature flags are supported, the format itself is not
supported, and images of that format cannot be created.
endif::VK_VERSION_1_1,VK_KHR_maintenance1[]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance1[]
If no format feature flags are supported, the format itself is not
supported, and images of that format cannot be created.
endif::VK_VERSION_1_1,VK_KHR_maintenance1[]
====

If pname:format is a block-compression format, then pname:bufferFeatures
must: not support any features for the format.

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
If pname:format is a multi-plane format then pname:linearTilingFeatures and
pname:optimalTilingFeatures must: not contain
ename:VK_FORMAT_FEATURE_DISJOINT_BIT.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

include::../validity/structs/VkFormatProperties.txt[]
--

[open,refpage='VkFormatFeatureFlagBits',desc='Bitmask specifying features supported by a buffer',type='enums']
--

Bits which can: be set in the slink:VkFormatProperties features
pname:linearTilingFeatures, pname:optimalTilingFeatures, and
pname:bufferFeatures are:

include::../api/enums/VkFormatFeatureFlagBits.txt[]

The following bits may: be set in pname:linearTilingFeatures and
pname:optimalTilingFeatures, specifying that the features are supported by
<<VkImage,images>> or <<VkImageView,image views>> created with the queried
flink:vkGetPhysicalDeviceFormatProperties::pname:format:

  * ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT specifies that an image view
    can: be <<descriptorsets-sampledimage, sampled from>>.
  * ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT specifies that an image view
    can: be used as a <<descriptorsets-storageimage, storage images>>.
  * ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT specifies that an image
    view can: be used as storage image that supports atomic operations.
  * ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT specifies that an image
    view can: be used as a framebuffer color attachment and as an input
    attachment.
  * ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT specifies that an
    image view can: be used as a framebuffer color attachment that supports
    blending and as an input attachment.
  * ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT specifies that an
    image view can: be used as a framebuffer depth/stencil attachment and as
    an input attachment.
  * ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT specifies that an image can: be
    used as pname:srcImage for the fname:vkCmdBlitImage command.
  * ename:VK_FORMAT_FEATURE_BLIT_DST_BIT specifies that an image can: be
    used as pname:dstImage for the fname:vkCmdBlitImage command.
  * ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT specifies that
    if ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT is also set, an image view
    can: be used with a sampler that has either of pname:magFilter or
    pname:minFilter set to ename:VK_FILTER_LINEAR, or pname:mipmapMode set
    to ename:VK_SAMPLER_MIPMAP_MODE_LINEAR.
    If ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT is also set, an image can be
    used as the pname:srcImage to flink:vkCmdBlitImage with a pname:filter
    of ename:VK_FILTER_LINEAR.
    This bit must: only be exposed for formats that also support the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT or
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT.
+
If the format being queried is a depth/stencil format, this bit only
specifies that the depth aspect (not the stencil aspect) of an image of this
format supports linear filtering, and that linear filtering of the depth
aspect is supported whether depth compare is enabled in the sampler or not.
If this bit is not present, linear filtering with depth compare disabled is
unsupported and linear filtering with depth compare enabled is supported,
but may: compute the filtered value in an implementation-dependent manner
which differs from the normal rules of linear filtering.
The resulting value must: be in the range [eq]#[0,1]# and should: be
proportional to, or a weighted average of, the number of comparison passes
or failures.

ifdef::VK_VERSION_1_1,VK_KHR_maintenance1[]
  * ename:VK_FORMAT_FEATURE_TRANSFER_SRC_BIT specifies that an image can: be
    used as a source image for <<copies, copy commands>>.
  * ename:VK_FORMAT_FEATURE_TRANSFER_DST_BIT specifies that an image can: be
    used as a destination image for <<copies, copy commands>> and <<clears,
    clear commands>>.
endif::VK_VERSION_1_1,VK_KHR_maintenance1[]
ifdef::VK_EXT_sampler_filter_minmax[]
  * ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT specifies
    sname:VkImage can: be used as a sampled image with a min or max
    elink:VkSamplerReductionModeEXT.
    This bit must: only be exposed for formats that also support the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT.
endif::VK_EXT_sampler_filter_minmax[]
ifdef::VK_IMG_filter_cubic[]
  * ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG specifies
    that sname:VkImage can: be used with a sampler that has either of
    pname:magFilter or pname:minFilter set to ename:VK_FILTER_CUBIC_IMG, or
    be the source image for a blit with pname:filter set to
    ename:VK_FILTER_CUBIC_IMG.
    This bit must: only be exposed for formats that also support the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT.
    If the format being queried is a depth/stencil format, this only
    specifies that the depth aspect is cubic filterable.
endif::VK_IMG_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * ename:VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT specifies that an
    application can: define a <<samplers-YCbCr-conversion,sampler Y'C~B~C~R~
    conversion>> using this format as a source, and that an image of this
    format can: be used with a sname:VkSamplerYcbcrConversionCreateInfo
    pname:xChromaOffset and/or pname:yChromaOffset of
    ename:VK_CHROMA_LOCATION_MIDPOINT.
    Otherwise both pname:xChromaOffset and pname:yChromaOffset must: be
    ename:VK_CHROMA_LOCATION_COSITED_EVEN.
    If a format does not incorporate chroma downsampling (it is not a
    "`422`" or "`420`" format) but the implementation supports sampler
    Y'C~B~C~R~ conversion for this format, the implementation must: set
    ename:VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT.
  * ename:VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT specifies that an
    application can: define a <<samplers-YCbCr-conversion,sampler Y'C~B~C~R~
    conversion>> using this format as a source, and that an image of this
    format can: be used with a sname:VkSamplerYcbcrConversionCreateInfo
    pname:xChromaOffset and/or pname:yChromaOffset of
    ename:VK_CHROMA_LOCATION_COSITED_EVEN.
    Otherwise both pname:xChromaOffset and pname:yChromaOffset must: be
    ename:VK_CHROMA_LOCATION_MIDPOINT.
    If neither ename:VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT nor
    ename:VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT is set, the
    application must: not define a <<samplers-YCbCr-conversion,sampler
    Y'C~B~C~R~ conversion>> using this format as a source.
  * ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT
    specifies that the format can do linear sampler filtering
    (min/magFilter) whilst sampler Y'C~B~C~R~ conversion is enabled.
  * ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT
    specifies that the format can have different chroma, min, and mag
    filters.
  * ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT
    specifies that reconstruction is explicit, as described in
    <<textures-chroma-reconstruction>>.
    If this bit is not present, reconstruction is implicit by default.
  * ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
    specifies that reconstruction can: be forcibly made explicit by setting
    slink:VkSamplerYcbcrConversionCreateInfo::pname:forceExplicitReconstruction
    to ename:VK_TRUE.
  * ename:VK_FORMAT_FEATURE_DISJOINT_BIT specifies that a multi-planar image
    can: have the ename:VK_IMAGE_CREATE_DISJOINT_BIT set during image
    creation.
    An implementation must: not set ename:VK_FORMAT_FEATURE_DISJOINT_BIT for
    _single-plane formats_.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

The following bits may: be set in pname:bufferFeatures, specifying that the
features are supported by <<VkBuffer,buffers>> or <<VkBufferView,buffer
views>> created with the queried
flink:vkGetPhysicalDeviceProperties::pname:format:

  * ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT specifies that the
    format can: be used to create a buffer view that can: be bound to a
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER descriptor.
  * ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT specifies that the
    format can: be used to create a buffer view that can: be bound to a
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor.
  * ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT specifies that
    atomic operations are supported on
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER with this format.
  * ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT specifies that the format can:
    be used as a vertex attribute format
    (sname:VkVertexInputAttributeDescription::pname:format).

--

[open,refpage='VkFormatFeatureFlags',desc='Bitmask of VkFormatFeatureFlagBits',type='enums']
--
include::../api/flags/VkFormatFeatureFlags.txt[]

sname:VkFormatFeatureFlags is a bitmask type for setting a mask of zero or
more slink:VkFormatFeatureFlagBits.
--

ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

[open,refpage='vkGetPhysicalDeviceFormatProperties2',desc='Lists physical device\'s format capabilities',type='protos']
--

To query supported format features which are properties of the physical
device, call:

ifdef::VK_VERSION_1_1[]
include::../api/protos/vkGetPhysicalDeviceFormatProperties2.txt[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_get_physical_device_properties2[or the equivalent command]

ifdef::VK_KHR_get_physical_device_properties2[]
include::../api/protos/vkGetPhysicalDeviceFormatProperties2KHR.txt[]
endif::VK_KHR_get_physical_device_properties2[]

  * pname:physicalDevice is the physical device from which to query the
    format properties.
  * pname:format is the format whose properties are queried.
  * pname:pFormatProperties is a pointer to a slink:VkFormatProperties2
    structure in which physical device properties for pname:format are
    returned.

fname:vkGetPhysicalDeviceFormatProperties2 behaves similarly to
flink:vkGetPhysicalDeviceFormatProperties, with the ability to return
extended information in a pname:pNext chain of output structures.

include::../validity/protos/vkGetPhysicalDeviceFormatProperties2.txt[]
--

[open,refpage='VkFormatProperties2',desc='Structure specifying image format properties',type='structs']
--

The sname:VkFormatProperties2 structure is defined as:

include::../api/structs/VkFormatProperties2.txt[]

ifdef::VK_KHR_get_physical_device_properties2[]
or the equivalent

include::../api/structs/VkFormatProperties2KHR.txt[]
endif::VK_KHR_get_physical_device_properties2[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:formatProperties is a structure of type slink:VkFormatProperties
    describing features supported by the requested format.

include::../validity/structs/VkFormatProperties2.txt[]
--

endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]


[[features-required-format-support]]
=== Required Format Support

Implementations must: support at least the following set of features on the
listed formats.
For images, these features must: be supported for every elink:VkImageType
(including arrayed and cube variants) unless otherwise noted.
These features are supported on existing formats without needing to
advertise an extension or needing to explicitly enable them.
Support for additional functionality beyond the requirements listed here is
queried using the flink:vkGetPhysicalDeviceFormatProperties command.

[NOTE]
.Note
====
The required formats are supported for all elink:VkImageCreateFlags values
as long as those flag values are otherwise allowed.
====

The following tables show which feature bits must: be supported for each
format.
ifdef::VK_VERSION_1_1,VK_KHR_maintenance1[]
Formats that are required to support
ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT must: also support
ename:VK_FORMAT_FEATURE_TRANSFER_SRC_BIT and
ename:VK_FORMAT_FEATURE_TRANSFER_DST_BIT.
endif::VK_VERSION_1_1,VK_KHR_maintenance1[]

.Key for format feature tables
[width="70%",cols="1,10"]
|====
^|{sym1} | This feature must: be supported on the named format
^|{sym2} | This feature must: be supported on at least some
of the named formats, with more information in the table
where the symbol appears
|====

.Feature bits in pname:optimalTilingFeatures
[width="70%"]
|====
ifdef::VK_VERSION_1_1,VK_KHR_maintenance1[]
|ename:VK_FORMAT_FEATURE_TRANSFER_SRC_BIT
|ename:VK_FORMAT_FEATURE_TRANSFER_DST_BIT
endif::VK_VERSION_1_1,VK_KHR_maintenance1[]
|ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
|ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT
|ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
|ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT
|ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
|ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT
|ename:VK_FORMAT_FEATURE_BLIT_DST_BIT
|ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
|ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
ifdef::VK_EXT_sampler_filter_minmax[]
|ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT
endif::VK_EXT_sampler_filter_minmax[]
|====

.Feature bits in pname:bufferFeatures
[width="70%"]
|====
|ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT
|ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT
|ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT
|ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
|====

<<<

[[features-formats-mandatory-features-subbyte]]
.Mandatory format support: sub-byte channels
[width="100%",cols="12,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|====
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT .14+^.^| {downarrow}
12+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT        .13+^.^| {downarrow}
11+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT        .12+^.^| {downarrow}
10+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT               .11+^.^| {downarrow}
9+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT     .10+^.^| {downarrow}
8+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT        .9+^.^| {downarrow}
7+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                      .8+^.^| {downarrow}
6+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT              .7+^.^| {downarrow}
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT          .6+^.^| {downarrow}
4+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                 .5+^.^| {downarrow}
3+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT   .4+^.^| {downarrow}
2+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                      .3+^.^| {downarrow}
1+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                 .2+^.^| {downarrow}
s| Format
| ename:VK_FORMAT_UNDEFINED                  |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R4G4_UNORM_PACK8           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16      |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16      | {sym1} | {sym1} | {sym1} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R5G6B5_UNORM_PACK16        | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   |   |   |   |
| ename:VK_FORMAT_B5G6R5_UNORM_PACK16        |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16      |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16      |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16      | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   |   |   |   |
|====

<<<

[[features-formats-mandatory-features-2byte]]
.Mandatory format support: 1-3 byte-sized channels
[width="100%",cols="12,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|====
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT .14+^.^| {downarrow}
12+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT        .13+^.^| {downarrow}
11+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT        .12+^.^| {downarrow}
10+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT               .11+^.^| {downarrow}
9+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT     .10+^.^| {downarrow}
8+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT        .9+^.^| {downarrow}
7+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                      .8+^.^| {downarrow}
6+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT              .7+^.^| {downarrow}
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT          .6+^.^| {downarrow}
4+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                 .5+^.^| {downarrow}
3+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT   .4+^.^| {downarrow}
2+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                      .3+^.^| {downarrow}
1+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                 .2+^.^| {downarrow}
s| Format
| ename:VK_FORMAT_R8_UNORM                   | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8_SNORM                   | {sym1} | {sym1} | {sym1} |   |   |   |   |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8_USCALED                 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8_SSCALED                 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8_UINT                    | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8_SINT                    | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8_SRGB                    |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8_UNORM                 | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8G8_SNORM                 | {sym1} | {sym1} | {sym1} |   |   |   |   |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8G8_USCALED               |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8_SSCALED               |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8_UINT                  | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8G8_SINT                  | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R8G8_SRGB                  |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_UNORM               |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_SNORM               |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_USCALED             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_SSCALED             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_UINT                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_SINT                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8_SRGB                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_UNORM               |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_SNORM               |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_USCALED             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_SSCALED             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_UINT                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_SINT                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8_SRGB                |   |   |   |   |   |   |   |   |   |   |   |   |
|====

<<<

[[features-formats-mandatory-features-4byte]]
.Mandatory format support: 4 byte-sized channels
[width="100%",cols="12,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|====
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT .14+^.^| {downarrow}
12+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT        .13+^.^| {downarrow}
11+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT        .12+^.^| {downarrow}
10+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT               .11+^.^| {downarrow}
9+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT     .10+^.^| {downarrow}
8+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT        .9+^.^| {downarrow}
7+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                      .8+^.^| {downarrow}
6+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT              .7+^.^| {downarrow}
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT          .6+^.^| {downarrow}
4+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                 .5+^.^| {downarrow}
3+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT   .4+^.^| {downarrow}
2+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                      .3+^.^| {downarrow}
1+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                 .2+^.^| {downarrow}
s| Format
| ename:VK_FORMAT_R8G8B8A8_UNORM             | {sym1} | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R8G8B8A8_SNORM             | {sym1} | {sym1} | {sym1} | {sym1} |   |   |   |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R8G8B8A8_USCALED           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8A8_SSCALED           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R8G8B8A8_UINT              | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R8G8B8A8_SINT              | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R8G8B8A8_SRGB              | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   |   |   |   |
| ename:VK_FORMAT_B8G8R8A8_UNORM             | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_B8G8R8A8_SNORM             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8A8_USCALED           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8A8_SSCALED           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8A8_UINT              |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8A8_SINT              |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B8G8R8A8_SRGB              | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   |   |   |   |
| ename:VK_FORMAT_A8B8G8R8_UNORM_PACK32      | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_A8B8G8R8_SNORM_PACK32      | {sym1} | {sym1} | {sym1} |   |   |   |   |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_A8B8G8R8_USCALED_PACK32    |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A8B8G8R8_SSCALED_PACK32    |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A8B8G8R8_UINT_PACK32       | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_A8B8G8R8_SINT_PACK32       | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_A8B8G8R8_SRGB_PACK32       | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   |   |   |   |
|====

<<<

[[features-formats-mandatory-features-10bit]]
.Mandatory format support: 10-bit channels
[width="100%",cols="12,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|====
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT .14+^.^| {downarrow}
12+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT        .13+^.^| {downarrow}
11+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT        .12+^.^| {downarrow}
10+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT               .11+^.^| {downarrow}
9+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT     .10+^.^| {downarrow}
8+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT        .9+^.^| {downarrow}
7+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                      .8+^.^| {downarrow}
6+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT              .7+^.^| {downarrow}
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT          .6+^.^| {downarrow}
4+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                 .5+^.^| {downarrow}
3+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT   .4+^.^| {downarrow}
2+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                      .3+^.^| {downarrow}
1+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                 .2+^.^| {downarrow}
s| Format
| ename:VK_FORMAT_A2R10G10B10_UNORM_PACK32   |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2R10G10B10_SNORM_PACK32   |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2R10G10B10_USCALED_PACK32 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2R10G10B10_SSCALED_PACK32 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2R10G10B10_UINT_PACK32    |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2R10G10B10_SINT_PACK32    |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32   | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_A2B10G10R10_SNORM_PACK32   |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2B10G10R10_USCALED_PACK32 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2B10G10R10_SSCALED_PACK32 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_A2B10G10R10_UINT_PACK32    | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   |   | {sym1} |   |
| ename:VK_FORMAT_A2B10G10R10_SINT_PACK32    |   |   |   |   |   |   |   |   |   |   |   |   |
|====

<<<

[[features-formats-mandatory-features-16bit]]
.Mandatory format support: 16-bit channels
[width="100%",cols="12,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|====
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT .14+^.^| {downarrow}
12+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT        .13+^.^| {downarrow}
11+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT        .12+^.^| {downarrow}
10+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT               .11+^.^| {downarrow}
9+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT     .10+^.^| {downarrow}
8+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT        .9+^.^| {downarrow}
7+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                      .8+^.^| {downarrow}
6+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT              .7+^.^| {downarrow}
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT          .6+^.^| {downarrow}
4+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                 .5+^.^| {downarrow}
3+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT   .4+^.^| {downarrow}
2+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                      .3+^.^| {downarrow}
1+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                 .2+^.^| {downarrow}
s| Format
| ename:VK_FORMAT_R16_UNORM                  |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R16_SNORM                  |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R16_USCALED                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16_SSCALED                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16_UINT                   | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R16_SINT                   | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R16_SFLOAT                 | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R16G16_UNORM               |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R16G16_SNORM               |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R16G16_USCALED             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16_SSCALED             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16_UINT                | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R16G16_SINT                | {sym1} | {sym1} |   |   |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R16G16_SFLOAT              | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} |   |
| ename:VK_FORMAT_R16G16B16_UNORM            |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16_SNORM            |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16_USCALED          |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16_SSCALED          |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16_UINT             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16_SINT             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16_SFLOAT           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16A16_UNORM         |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R16G16B16A16_SNORM         |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R16G16B16A16_USCALED       |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16A16_SSCALED       |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R16G16B16A16_UINT          | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R16G16B16A16_SINT          | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R16G16B16A16_SFLOAT        | {sym1} | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} |
|====

<<<

[[features-formats-mandatory-features-32bit]]
.Mandatory format support: 32-bit channels
[width="100%",cols="12,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|====
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT .14+^.^| {downarrow}
12+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT        .13+^.^| {downarrow}
11+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT        .12+^.^| {downarrow}
10+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT               .11+^.^| {downarrow}
9+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT     .10+^.^| {downarrow}
8+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT        .9+^.^| {downarrow}
7+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                      .8+^.^| {downarrow}
6+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT              .7+^.^| {downarrow}
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT          .6+^.^| {downarrow}
4+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                 .5+^.^| {downarrow}
3+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT   .4+^.^| {downarrow}
2+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                      .3+^.^| {downarrow}
1+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                 .2+^.^| {downarrow}
s| Format
| ename:VK_FORMAT_R32_UINT                   | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} | {sym1}
| ename:VK_FORMAT_R32_SINT                   | {sym1} | {sym1} |   | {sym1} | {sym1} | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} | {sym1}
| ename:VK_FORMAT_R32_SFLOAT                 | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R32G32_UINT                | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R32G32_SINT                | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R32G32_SFLOAT              | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R32G32B32_UINT             |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R32G32B32_SINT             |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R32G32B32_SFLOAT           |   |   |   |   |   |   |   |   |   | {sym1} |   |   |
| ename:VK_FORMAT_R32G32B32A32_UINT          | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R32G32B32A32_SINT          | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
| ename:VK_FORMAT_R32G32B32A32_SFLOAT        | {sym1} | {sym1} |   | {sym1} |   | {sym1} | {sym1} |   |   | {sym1} | {sym1} | {sym1} |
|====

<<<

[[features-formats-mandatory-features-64bit]]
.Mandatory format support: 64-bit/uneven channels
[width="100%",cols="12,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|====
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT .14+^.^| {downarrow}
12+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT        .13+^.^| {downarrow}
11+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT        .12+^.^| {downarrow}
10+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT               .11+^.^| {downarrow}
9+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT     .10+^.^| {downarrow}
8+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT        .9+^.^| {downarrow}
7+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                      .8+^.^| {downarrow}
6+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT              .7+^.^| {downarrow}
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT          .6+^.^| {downarrow}
4+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                 .5+^.^| {downarrow}
3+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT   .4+^.^| {downarrow}
2+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                      .3+^.^| {downarrow}
1+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                 .2+^.^| {downarrow}
s| Format
| ename:VK_FORMAT_R64_UINT                   |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64_SINT                   |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64_SFLOAT                 |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64_UINT                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64_SINT                |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64_SFLOAT              |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64B64_UINT             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64B64_SINT             |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64B64_SFLOAT           |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64B64A64_UINT          |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64B64A64_SINT          |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_R64G64B64A64_SFLOAT        |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32    | {sym1} | {sym1} | {sym1} |   |   |   |   |   |   |   | {sym1} |   |
| ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32     | {sym1} | {sym1} | {sym1} |   |   |   |   |   |   |   |   |   |
|====

<<<

[[features-formats-mandatory-features-depth-stencil]]
.Mandatory format support: depth/stencil with elink:VkImageType ename:VK_IMAGE_TYPE_2D
[width="100%",cols="12,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|====
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT .14+^.^| {downarrow}
12+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT        .13+^.^| {downarrow}
11+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT        .12+^.^| {downarrow}
10+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT               .11+^.^| {downarrow}
9+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT     .10+^.^| {downarrow}
8+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT        .9+^.^| {downarrow}
7+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                      .8+^.^| {downarrow}
6+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT              .7+^.^| {downarrow}
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT          .6+^.^| {downarrow}
4+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                 .5+^.^| {downarrow}
3+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT   .4+^.^| {downarrow}
2+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                      .3+^.^| {downarrow}
1+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                 .2+^.^| {downarrow}
s| Format
| ename:VK_FORMAT_D16_UNORM                  | {sym1} | {sym1} |   |   |   |   |   |   | {sym1} |   |   |   |
| ename:VK_FORMAT_X8_D24_UNORM_PACK32        |   |   |   |   |   |   |   |   | {sym2} |   |   |   |
| ename:VK_FORMAT_D32_SFLOAT                 | {sym1} | {sym1} |   |   |   |   |   |   | {sym2} |   |   |   |
| ename:VK_FORMAT_S8_UINT                    |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_D16_UNORM_S8_UINT          |   |   |   |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_D24_UNORM_S8_UINT          |   |   |   |   |   |   |   |   | {sym2} |   |   |   |
| ename:VK_FORMAT_D32_SFLOAT_S8_UINT         |   |   |   |   |   |   |   |   | {sym2} |   |   |   |
14+| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT feature must: be
supported for at least one of ename:VK_FORMAT_X8_D24_UNORM_PACK32 and
ename:VK_FORMAT_D32_SFLOAT, and must: be supported for at least one of
ename:VK_FORMAT_D24_UNORM_S8_UINT and ename:VK_FORMAT_D32_SFLOAT_S8_UINT.
|====

<<<

[[features-formats-mandatory-features-bcn]]
.Mandatory format support: BC compressed formats with elink:VkImageType ename:VK_IMAGE_TYPE_2D and ename:VK_IMAGE_TYPE_3D
[width="100%",cols="12,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|====
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT .14+^.^| {downarrow}
12+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT        .13+^.^| {downarrow}
11+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT        .12+^.^| {downarrow}
10+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT               .11+^.^| {downarrow}
9+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT     .10+^.^| {downarrow}
8+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT        .9+^.^| {downarrow}
7+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                      .8+^.^| {downarrow}
6+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT              .7+^.^| {downarrow}
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT          .6+^.^| {downarrow}
4+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                 .5+^.^| {downarrow}
3+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT   .4+^.^| {downarrow}
2+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                      .3+^.^| {downarrow}
1+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                 .2+^.^| {downarrow}
s| Format
| ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK         | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC2_UNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC2_SRGB_BLOCK             | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC3_UNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC3_SRGB_BLOCK             | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC4_UNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC4_SNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC5_UNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC5_SNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC6H_UFLOAT_BLOCK          | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC6H_SFLOAT_BLOCK          | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC7_UNORM_BLOCK            | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_BC7_SRGB_BLOCK             | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
14+| The ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must: be
supported in pname:optimalTilingFeatures for all the formats in at least
one of: this table, <<features-formats-mandatory-features-etc>>, or
<<features-formats-mandatory-features-astc>>.
|====

<<<

[[features-formats-mandatory-features-etc]]
.Mandatory format support: ETC2 and EAC compressed formats with elink:VkImageType ename:VK_IMAGE_TYPE_2D
[width="100%",cols="12,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|====
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT .14+^.^| {downarrow}
12+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT        .13+^.^| {downarrow}
11+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT        .12+^.^| {downarrow}
10+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT               .11+^.^| {downarrow}
9+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT     .10+^.^| {downarrow}
8+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT        .9+^.^| {downarrow}
7+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                      .8+^.^| {downarrow}
6+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT              .7+^.^| {downarrow}
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT          .6+^.^| {downarrow}
4+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                 .5+^.^| {downarrow}
3+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT   .4+^.^| {downarrow}
2+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                      .3+^.^| {downarrow}
1+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                 .2+^.^| {downarrow}
s| Format
| ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK    | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK     | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK  | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK   | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK  | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK   | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_EAC_R11_UNORM_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_EAC_R11_SNORM_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK     | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK     | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
14+|The ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must: be
supported in pname:optimalTilingFeatures for all the formats in at least
one of: this table, <<features-formats-mandatory-features-bcn>>, or
<<features-formats-mandatory-features-astc>>.
|====

<<<

[[features-formats-mandatory-features-astc]]
.Mandatory format support: ASTC LDR compressed formats with elink:VkImageType ename:VK_IMAGE_TYPE_2D
[width="100%",cols="12,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|====
13+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT .14+^.^| {downarrow}
12+>| ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT        .13+^.^| {downarrow}
11+>| ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT        .12+^.^| {downarrow}
10+>| ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT               .11+^.^| {downarrow}
9+>| ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT     .10+^.^| {downarrow}
8+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT        .9+^.^| {downarrow}
7+>| ename:VK_FORMAT_FEATURE_BLIT_DST_BIT                      .8+^.^| {downarrow}
6+>| ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT              .7+^.^| {downarrow}
5+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT          .6+^.^| {downarrow}
4+>| ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                 .5+^.^| {downarrow}
3+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT   .4+^.^| {downarrow}
2+>| ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT                      .3+^.^| {downarrow}
1+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                 .2+^.^| {downarrow}
s| Format
| ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK        | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK      | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK      | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK      | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK       | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK     | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK      | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK     | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK      | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK     | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
| ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK      | {sym2} | {sym2} | {sym2} |   |   |   |   |   |   |   |   |   |
14+|The ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must: be
supported in pname:optimalTilingFeatures for all the formats in at least
one of: this table, <<features-formats-mandatory-features-bcn>>, or
<<features-formats-mandatory-features-etc>>.
|====

ifdef::VK_IMG_filter_cubic[]
ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG must: be
supported for the following formats:

  * ename:VK_FORMAT_R4G4_UNORM_PACK8
  * ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16
  * ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16
  * ename:VK_FORMAT_R5G6B5_UNORM_PACK16
  * ename:VK_FORMAT_B5G6R5_UNORM_PACK16
  * ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16
  * ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16
  * ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16
  * ename:VK_FORMAT_R8_UNORM
  * ename:VK_FORMAT_R8_SNORM
  * ename:VK_FORMAT_R8_SRGB
  * ename:VK_FORMAT_R8G8_UNORM
  * ename:VK_FORMAT_R8G8_SNORM
  * ename:VK_FORMAT_R8G8_SRGB
  * ename:VK_FORMAT_R8G8B8_UNORM
  * ename:VK_FORMAT_R8G8B8_SNORM
  * ename:VK_FORMAT_R8G8B8_SRGB
  * ename:VK_FORMAT_B8G8R8_UNORM
  * ename:VK_FORMAT_B8G8R8_SNORM
  * ename:VK_FORMAT_B8G8R8_SRGB
  * ename:VK_FORMAT_R8G8B8A8_UNORM
  * ename:VK_FORMAT_R8G8B8A8_SNORM
  * ename:VK_FORMAT_R8G8B8A8_SRGB
  * ename:VK_FORMAT_B8G8R8A8_UNORM
  * ename:VK_FORMAT_B8G8R8A8_SNORM
  * ename:VK_FORMAT_B8G8R8A8_SRGB
  * ename:VK_FORMAT_A8B8G8R8_UNORM_PACK32
  * ename:VK_FORMAT_A8B8G8R8_SNORM_PACK32
  * ename:VK_FORMAT_A8B8G8R8_USCALED_PACK32
  * ename:VK_FORMAT_A8B8G8R8_SSCALED_PACK32
  * ename:VK_FORMAT_A8B8G8R8_UINT_PACK32
  * ename:VK_FORMAT_A8B8G8R8_SINT_PACK32
  * ename:VK_FORMAT_A8B8G8R8_SRGB_PACK32

If ETC2 compressed formats are supported, the following additional formats
must: support ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG:

  * ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
  * ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
  * ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK
  * ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
  * ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK
  * ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
endif::VK_IMG_filter_cubic[]

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

To be used with sname:VkImageView with pname:subresourceRange.aspectMask =
ename:VK_IMAGE_ASPECT_COLOR_BIT, <<samplers-YCbCr-conversion,sampler
Y'C~B~C~R~ conversion>> must: be enabled for the following formats:

[[features-formats-requiring-sampler-ycbcr-conversion]]
.Formats requiring sampler Y'C~B~C~R~ conversion for ename:VK_IMAGE_ASPECT_COLOR_BIT image views
[width="100%",cols="18,^3,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1",options="unbreakable"]
|====
11+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT  .11+^.^| {downarrow}
10+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT            .10+^.^| {downarrow}
9+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT             .9+^.^| {downarrow}
8+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT                              .8+^.^| {downarrow}
7+>| ename:VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT         .7+^.^| {downarrow}
6+>| ename:VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT          .6+^.^| {downarrow}
5+>| ename:VK_FORMAT_FEATURE_TRANSFER_DST_BIT                    .5+^.^| {downarrow}
4+>| ename:VK_FORMAT_FEATURE_TRANSFER_SRC_BIT                    .4+^.^| {downarrow}
3+>| ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                   .3+^.^| {downarrow}
2+>| ename:VK_FORMAT_FEATURE_DISJOINT_BIT                        .2+^.^| {downarrow}
s| Format                                                     s| Planes
| ename:VK_FORMAT_G8B8G8R8_422_UNORM                           | 1 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_B8G8R8G8_422_UNORM                           | 1 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM                    | 3 |  | {sym1} | {sym1} | {sym1} | {sym1} | | | | |
| ename:VK_FORMAT_G8_B8R8_2PLANE_420_UNORM                     | 2 |  | {sym1} | {sym1} | {sym1} | {sym1} | | | | |
| ename:VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM                    | 3 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G8_B8R8_2PLANE_422_UNORM                     | 2 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM                    | 3 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16           | 1 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16       | 1 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16       | 1 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16   | 3 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16    | 2 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16   | 3 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16    | 2 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16   | 3 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16           | 1 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16       | 1 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16       | 1 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16   | 3 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16    | 2 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16   | 3 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16    | 2 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16   | 3 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G16B16G16R16_422_UNORM                       | 1 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_B16G16R16G16_422_UNORM                       | 1 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM                 | 3 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G16_B16R16_2PLANE_420_UNORM                  | 2 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM                 | 3 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G16_B16R16_2PLANE_422_UNORM                  | 2 |  |        |        |        |        | | | | |
| ename:VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM                 | 3 |  |        |        |        |        | | | | |
12+| Format features marked {sym1} must: be supported only if slink:VkPhysicalDeviceSamplerYcbcrConversionFeatures is enabled
|====

endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]


== Additional Image Capabilities

In addition to the minimum capabilities described in the previous sections
(<<features-limits,Limits>> and <<features-formats,Formats>>),
implementations may: support additional capabilities for certain types of
images.
For example, larger dimensions or additional sample counts for certain image
types, or additional capabilities for _linear_ tiling format images.

[open,refpage='vkGetPhysicalDeviceImageFormatProperties',desc='Lists physical device\'s image format capabilities',type='protos']
--

To query additional capabilities specific to image types, call:

include::../api/protos/vkGetPhysicalDeviceImageFormatProperties.txt[]

  * pname:physicalDevice is the physical device from which to query the
    image capabilities.
  * pname:format is a elink:VkFormat value specifying the image format,
    corresponding to slink:VkImageCreateInfo::pname:format.
  * pname:type is a elink:VkImageType value specifying the image type,
    corresponding to slink:VkImageCreateInfo::pname:imageType.
  * pname:tiling is a elink:VkImageTiling value specifying the image tiling,
    corresponding to slink:VkImageCreateInfo::pname:tiling.
  * pname:usage is a bitmask of elink:VkImageUsageFlagBits specifying the
    intended usage of the image, corresponding to
    slink:VkImageCreateInfo::pname:usage.
  * pname:flags is a bitmask of elink:VkImageCreateFlagBits specifying
    additional parameters of the image, corresponding to
    slink:VkImageCreateInfo::pname:flags.
  * pname:pImageFormatProperties points to an instance of the
    slink:VkImageFormatProperties structure in which capabilities are
    returned.

The pname:format, pname:type, pname:tiling, pname:usage, and pname:flags
parameters correspond to parameters that would be consumed by
flink:vkCreateImage (as members of sname:VkImageCreateInfo).

If pname:format is not a supported image format, or if the combination of
pname:format, pname:type, pname:tiling, pname:usage, and pname:flags is not
supported for images, then fname:vkGetPhysicalDeviceImageFormatProperties
returns ename:VK_ERROR_FORMAT_NOT_SUPPORTED.

The limitations on an image format that are reported by
fname:vkGetPhysicalDeviceImageFormatProperties have the following property:
if code:usage1 and code:usage2 of type elink:VkImageUsageFlags are such that
the bits set in code:usage1 are a subset of the bits set in code:usage2, and
code:flags1 and code:flags2 of type elink:VkImageCreateFlags are such that
the bits set in code:flags1 are a subset of the bits set in code:flags2,
then the limitations for code:usage1 and code:flags1 must: be no more strict
than the limitations for code:usage2 and code:flags2, for all values of
pname:format, pname:type, and pname:tiling.

include::../validity/protos/vkGetPhysicalDeviceImageFormatProperties.txt[]
--

[open,refpage='VkImageFormatProperties',desc='Structure specifying an image format properties',type='structs']
--

The sname:VkImageFormatProperties structure is defined as:

include::../api/structs/VkImageFormatProperties.txt[]

  * pname:maxExtent are the maximum image dimensions.
    See the <<features-extentperimagetype,Allowed Extent Values>> section
    below for how these values are constrained by pname:type.
  * pname:maxMipLevels is the maximum number of mipmap levels.
    pname:maxMipLevels must: be equal to [eq]#{lceil}log~2~(max(pname:width,
    pname:height, pname:depth)){rceil} {plus} 1#, where [eq]#pname:width#,
    [eq]#pname:height#, and [eq]#pname:depth# are taken from the
    corresponding members of pname:maxExtent, except when one of the
    following conditions is true, in which case it may: instead be `1`:
    ** fname:vkGetPhysicalDeviceImageFormatProperties::pname:tiling was
       ename:VK_IMAGE_TILING_LINEAR
ifdef::VK_VERSION_1_1,VK_KHR_external_memory_capabilities[]
    ** the slink:VkPhysicalDeviceImageFormatInfo2::pname:pNext chain
       included an instance of slink:VkPhysicalDeviceExternalImageFormatInfo
       with a handle type included in the pname:handleTypes member for which
       mipmap image support is not required
endif::VK_VERSION_1_1,VK_KHR_external_memory_capabilities[]
  * pname:maxArrayLayers is the maximum number of array layers.
    pname:maxArrayLayers must: either be equal to 1 or be greater than or
    equal to the pname:maxImageArrayLayers member of
    slink:VkPhysicalDeviceLimits.
    A value of 1 is valid only if pname:tiling is
    ename:VK_IMAGE_TILING_LINEAR or if pname:type is ename:VK_IMAGE_TYPE_3D.
  * pname:sampleCounts is a bitmask of elink:VkSampleCountFlagBits
    specifying all the supported sample counts for this image as described
    <<features-supported-sample-counts, below>>.
  * pname:maxResourceSize is an upper bound on the total image size in
    bytes, inclusive of all image subresources.
    Implementations may: have an address space limit on total size of a
    resource, which is advertised by this property.
    pname:maxResourceSize must: be at least 2^31^.

[NOTE]
.Note
====
There is no mechanism to query the size of an image before creating it, to
compare that size against pname:maxResourceSize.
If an application attempts to create an image that exceeds this limit, the
creation will fail and flink:vkCreateImage will return
ename:VK_ERROR_OUT_OF_DEVICE_MEMORY.
While the advertised limit must: be at least 2^31^, it may: not be possible
to create an image that approaches that size, particularly for
ename:VK_IMAGE_TYPE_1D.
====

If the combination of parameters to
fname:vkGetPhysicalDeviceImageFormatProperties is not supported by the
implementation for use in flink:vkCreateImage, then all members of
sname:VkImageFormatProperties will be filled with zero.

[NOTE]
.Note
====
Filling sname:VkImageFormatProperties with zero for unsupported formats is
an exception to the usual rule that output structures have undefined
contents on error.
This exception was unintentional, but is preserved for backwards
compatibility.
====

include::../validity/structs/VkImageFormatProperties.txt[]
--

ifdef::VK_NV_external_memory_capabilities[]
include::./VK_NV_external_memory_capabilities/external_image_format.txt[]
endif::VK_NV_external_memory_capabilities[]

ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

[open,refpage='vkGetPhysicalDeviceImageFormatProperties2',desc='Lists physical device\'s image format capabilities',type='protos']
--

To query additional capabilities specific to image types, call:

ifdef::VK_VERSION_1_1[]
include::../api/protos/vkGetPhysicalDeviceImageFormatProperties2.txt[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_get_physical_device_properties2[or the equivalent command]

ifdef::VK_KHR_get_physical_device_properties2[]
include::../api/protos/vkGetPhysicalDeviceImageFormatProperties2KHR.txt[]
endif::VK_KHR_get_physical_device_properties2[]

  * pname:physicalDevice is the physical device from which to query the
    image capabilities.
  * pname:pImageFormatInfo points to an instance of the
    slink:VkPhysicalDeviceImageFormatInfo2 structure, describing the
    parameters that would be consumed by flink:vkCreateImage.
  * pname:pImageFormatProperties points to an instance of the
    slink:VkImageFormatProperties2 structure in which capabilities are
    returned.

fname:vkGetPhysicalDeviceImageFormatProperties2 behaves similarly to
flink:vkGetPhysicalDeviceImageFormatProperties, with the ability to return
extended information in a pname:pNext chain of output structures.

ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
.Valid Usage
****
  * [[VUID-vkGetPhysicalDeviceImageFormatProperties2-pNext-01868]]
    If the pname:pNext chain of pname:pImageFormatProperties contains an
    instance of slink:VkAndroidHardwareBufferUsageANDROID, the pname:pNext
    chain of pname:pImageFormatInfo must: contain an instance of
    slink:VkPhysicalDeviceExternalImageFormatInfo with pname:handleType set
    to
    ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID.
****
endif::VK_ANDROID_external_memory_android_hardware_buffer[]

include::../validity/protos/vkGetPhysicalDeviceImageFormatProperties2.txt[]
--

[open,refpage='VkPhysicalDeviceImageFormatInfo2',desc='Structure specifying image creation parameters',type='structs']
--

The sname:VkPhysicalDeviceImageFormatInfo2 structure is defined as:

include::../api/structs/VkPhysicalDeviceImageFormatInfo2.txt[]

ifdef::VK_KHR_get_physical_device_properties2[]
or the equivalent

include::../api/structs/VkPhysicalDeviceImageFormatInfo2KHR.txt[]
endif::VK_KHR_get_physical_device_properties2[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
    The pname:pNext chain of sname:VkPhysicalDeviceImageFormatInfo2 is used
    to provide additional image parameters to
    fname:vkGetPhysicalDeviceImageFormatProperties2.
  * pname:format is a elink:VkFormat value indicating the image format,
    corresponding to slink:VkImageCreateInfo::pname:format.
  * pname:type is a elink:VkImageType value indicating the image type,
    corresponding to slink:VkImageCreateInfo::pname:imageType.
  * pname:tiling is a elink:VkImageTiling value indicating the image tiling,
    corresponding to slink:VkImageCreateInfo::pname:tiling.
  * pname:usage is a bitmask of elink:VkImageUsageFlagBits indicating the
    intended usage of the image, corresponding to
    slink:VkImageCreateInfo::pname:usage.
  * pname:flags is a bitmask of elink:VkImageCreateFlagBits indicating
    additional parameters of the image, corresponding to
    slink:VkImageCreateInfo::pname:flags.

The members of sname:VkPhysicalDeviceImageFormatInfo2 correspond to the
arguments to flink:vkGetPhysicalDeviceImageFormatProperties, with
pname:sType and pname:pNext added for extensibility.

include::../validity/structs/VkPhysicalDeviceImageFormatInfo2.txt[]
--

[open,refpage='VkImageFormatProperties2',desc='Structure specifying an image format properties',type='structs']
--

The sname:VkImageFormatProperties2 structure is defined as:

include::../api/structs/VkImageFormatProperties2.txt[]

ifdef::VK_KHR_get_physical_device_properties2[]
or the equivalent

include::../api/structs/VkImageFormatProperties2KHR.txt[]
endif::VK_KHR_get_physical_device_properties2[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
    The pname:pNext chain of sname:VkImageFormatProperties2 is used to allow
    the specification of additional capabilities to be returned from
    fname:vkGetPhysicalDeviceImageFormatProperties2.
  * pname:imageFormatProperties is an instance of a
    slink:VkImageFormatProperties structure in which capabilities are
    returned.

If the combination of parameters to
fname:vkGetPhysicalDeviceImageFormatProperties2 is not supported by the
implementation for use in flink:vkCreateImage, then all members of
pname:imageFormatProperties will be filled with zero.

[NOTE]
.Note
====
Filling pname:imageFormatProperties with zero for unsupported formats is an
exception to the usual rule that output structures have undefined contents
on error.
This exception was unintentional, but is preserved for backwards
compatibility.
This exeption only applies to pname:imageFormatProperties, not pname:sType,
pname:pNext, or any structures chained from pname:pNext.
====

include::../validity/structs/VkImageFormatProperties2.txt[]
--

ifdef::VK_AMD_texture_gather_bias_lod[]
[open,refpage='VkTextureLODGatherFormatPropertiesAMD',desc='Structure informing whether or not texture gather bias/LOD functionality is supported for a given image format and a given physical device.',type='structs']
--

To determine if texture gather functions that take explicit LOD and/or bias
argument values can be used with a given image format, add
slink:VkImageFormatProperties2 to the pname:pNext chain of the
slink:VkPhysicalDeviceImageFormatInfo2 structure and
slink:VkTextureLODGatherFormatPropertiesAMD to the pname:pNext chain of the
slink:VkImageFormatProperties2 structure.

The sname:VkTextureLODGatherFormatPropertiesAMD structure is defined as:

include::../api/structs/VkTextureLODGatherFormatPropertiesAMD.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL`.
  * pname:supportsTextureGatherLODBiasAMD tells if the image format can be
    used with texture gather bias/LOD functions, as introduced by the
    `<<VK_AMD_texture_gather_bias_lod>>` extension.
    This field is set by the implementation.
    User-specified value is ignored.

--
endif::VK_AMD_texture_gather_bias_lod[]

ifdef::VK_VERSION_1_1,VK_KHR_external_memory_capabilities[]
[open,refpage='VkPhysicalDeviceExternalImageFormatInfo',desc='Structure specifying external image creation parameters',type='structs']
--

To determine the image capabilities compatible with an external memory
handle type, add slink:VkPhysicalDeviceExternalImageFormatInfo to the
pname:pNext chain of the slink:VkPhysicalDeviceImageFormatInfo2 structure
and sname:VkExternalImageFormatProperties to the pname:pNext chain of the
slink:VkImageFormatProperties2 structure.

The sname:VkPhysicalDeviceExternalImageFormatInfo structure is defined as:

include::../api/structs/VkPhysicalDeviceExternalImageFormatInfo.txt[]

ifdef::VK_KHR_external_memory_capabilities[]
or the equivalent

include::../api/structs/VkPhysicalDeviceExternalImageFormatInfoKHR.txt[]
endif::VK_KHR_external_memory_capabilities[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:handleType is a elink:VkExternalMemoryHandleTypeFlagBits value
    specifying the memory handle type that will be used with the memory
    associated with the image.

If pname:handleType is 0, flink:vkGetPhysicalDeviceImageFormatProperties2
will behave as if slink:VkPhysicalDeviceExternalImageFormatInfo was not
present, and slink:VkExternalImageFormatProperties will be ignored.

If pname:handleType is not compatible with the pname:format, pname:type,
pname:tiling, pname:usage, and pname:flags specified in
slink:VkPhysicalDeviceImageFormatInfo2, then
flink:vkGetPhysicalDeviceImageFormatProperties2 returns
ename:VK_ERROR_FORMAT_NOT_SUPPORTED.

include::../validity/structs/VkPhysicalDeviceExternalImageFormatInfo.txt[]
--

[open,refpage='VkExternalMemoryHandleTypeFlagBits',desc='Bit specifying external memory handle types',type='enums']
--

Possible values of
slink:VkPhysicalDeviceExternalImageFormatInfo::pname:handleType, specifying
an external memory handle type, are:

include::../api/enums/VkExternalMemoryHandleTypeFlagBits.txt[]

ifdef::VK_KHR_external_memory_capabilities[]
or the equivalent

include::../api/enums/VkExternalMemoryHandleTypeFlagBitsKHR.txt[]
endif::VK_KHR_external_memory_capabilities[]

  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT specifies a POSIX
    file descriptor handle that has only limited valid usage outside of
    Vulkan and other compatible APIs.
    It must: be compatible with the POSIX system calls ftext:dup,
    ftext:dup2, ftext:close, and the non-standard system call ftext:dup3.
    Additionally, it must: be transportable over a socket using an
    code:SCM_RIGHTS control message.
    It owns a reference to the underlying memory resource represented by its
    Vulkan memory object.
  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT specifies an NT
    handle that has only limited valid usage outside of Vulkan and other
    compatible APIs.
    It must: be compatible with the functions ftext:DuplicateHandle,
    ftext:CloseHandle, ftext:CompareObjectHandles,
    ftext:GetHandleInformation, and ftext:SetHandleInformation.
    It owns a reference to the underlying memory resource represented by its
    Vulkan memory object.
  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT specifies a
    global share handle that has only limited valid usage outside of Vulkan
    and other compatible APIs.
    It is not compatible with any native APIs.
    It does not own a reference to the underlying memory resource
    represented its Vulkan memory object, and will therefore become invalid
    when all Vulkan memory objects associated with it are destroyed.
  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT specifies an NT
    handle returned by code:IDXGIResource1::code:CreateSharedHandle
    referring to a Direct3D 10 or 11 texture resource.
    It owns a reference to the memory used by the Direct3D resource.
  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT specifies a
    global share handle returned by code:IDXGIResource::code:GetSharedHandle
    referring to a Direct3D 10 or 11 texture resource.
    It does not own a reference to the underlying Direct3D resource, and
    will therefore become invalid when all Vulkan memory objects and
    Direct3D resources associated with it are destroyed.
  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT specifies an NT
    handle returned by code:ID3D12Device::code:CreateSharedHandle referring
    to a Direct3D 12 heap resource.
    It owns a reference to the resources used by the Direct3D heap.
  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT specifies an NT
    handle returned by code:ID3D12Device::code:CreateSharedHandle referring
    to a Direct3D 12 committed resource.
    It owns a reference to the memory used by the Direct3D resource.
ifdef::VK_EXT_external_memory_host[]
  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT specifies a
    host pointer returned by a host memory allocation command.
    It does not own a reference to the underlying memory resource, and will
    therefore become invalid if the host memory is freed.
  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT
    specifies a host pointer to _host mapped foreign memory_.
    It does not own a reference to the underlying memory resource, and will
    therefore become invalid if the foreign memory is unmapped or otherwise
    becomes no longer available.
endif::VK_EXT_external_memory_host[]
ifdef::VK_EXT_external_memory_dma_buf[]
  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT is a file
    descriptor for a Linux dma_buf.
    It owns a reference to the underlying memory resource represented by its
    Vulkan memory object.
endif::VK_EXT_external_memory_dma_buf[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID
    specifies an code:AHardwareBuffer object defined by the Android NDK.
    See <<memory-external-android-hardware-buffer,Android Hardware Buffers>>
    for more details of this handle type.
endif::VK_ANDROID_external_memory_android_hardware_buffer[]

<<<

Some external memory handle types can only be shared within the same
underlying physical device and/or the same driver version, as defined in the
following table:

[[external-memory-handle-types-compatibility]]
.External memory handle types compatibility
|====
| Handle type | sname:VkPhysicalDeviceIDProperties::pname:driverUUID | sname:VkPhysicalDeviceIDProperties::pname:deviceUUID
| ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT | Must match | Must match
| ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT | Must match | Must match
| ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT | Must match | Must match
| ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT | Must match | Must match
| ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT | Must match | Must match
| ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT | Must match | Must match
| ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT | Must match | Must match
ifdef::VK_EXT_external_memory_host[]
| ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT | No restriction | No restriction
| ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT | No restriction | No restriction
endif::VK_EXT_external_memory_host[]
ifdef::VK_EXT_external_memory_dma_buf[]
| ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT | No restriction | No restriction
endif::VK_EXT_external_memory_dma_buf[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
| ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID | No restriction | No restriction
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
|====

ifdef::VK_EXT_external_memory_host[]
[NOTE]
.Note
====
The above table does not restrict the drivers and devices with which
ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT and
ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT may:
be shared, as these handle types inherently mean memory that does not come
from the same device, as they import memory from the host or a foreign
device, respectively.
====
endif::VK_EXT_external_memory_host[]

ifdef::VK_EXT_external_memory_dma_buf[]
[NOTE]
.Note
====
Even though the above table does not restrict the drivers and devices with
which ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT may: be shared,
query mechanisms exist in the Vulkan API that prevent the import of
incompatible dma-bufs (such as flink:vkGetMemoryFdPropertiesKHR) and that
prevent incompatible usage of dma-bufs (such as
slink:VkPhysicalDeviceExternalBufferInfoKHR and
slink:VkPhysicalDeviceExternalImageFormatInfoKHR).
====
endif::VK_EXT_external_memory_dma_buf[]

--

[open,refpage='VkExternalMemoryHandleTypeFlags',desc='Bitmask of VkExternalMemoryHandleTypeFlagBits',type='enums']
--
include::../api/flags/VkExternalMemoryHandleTypeFlags.txt[]

ifdef::VK_KHR_external_memory_capabilities[]
or the equivalent

include::../api/flags/VkExternalMemoryHandleTypeFlagsKHR.txt[]
endif::VK_KHR_external_memory_capabilities[]

sname:VkExternalMemoryHandleTypeFlags is a bitmask type for setting a mask
of zero or more slink:VkExternalMemoryHandleTypeFlagBits.
--

[open,refpage='VkExternalImageFormatProperties',desc='Structure specifying supported external handle properties',type='structs']
--

The sname:VkExternalImageFormatProperties structure is defined as:

include::../api/structs/VkExternalImageFormatProperties.txt[]

ifdef::VK_KHR_external_memory_capabilities[]
or the equivalent

include::../api/structs/VkExternalImageFormatPropertiesKHR.txt[]
endif::VK_KHR_external_memory_capabilities[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:externalMemoryProperties is an instance of the
    slink:VkExternalMemoryProperties structure specifying various
    capabilities of the external handle type when used with the specified
    image creation parameters.

include::../validity/structs/VkExternalImageFormatProperties.txt[]
--

[open,refpage='VkExternalMemoryProperties',desc='Structure specifying external memory handle type capabilities',type='structs']
--

The sname:VkExternalMemoryProperties structure is defined as:

include::../api/structs/VkExternalMemoryProperties.txt[]

ifdef::VK_KHR_external_memory_capabilities[]
or the equivalent

include::../api/structs/VkExternalMemoryPropertiesKHR.txt[]
endif::VK_KHR_external_memory_capabilities[]

  * pname:externalMemoryFeatures is a bitmask of
    elink:VkExternalMemoryFeatureFlagBits specifying the features of
    pname:handleType.
  * pname:exportFromImportedHandleTypes is a bitmask of
    slink:VkExternalMemoryHandleTypeFlagBits specifying which types of
    imported handle pname:handleType can: be exported from.
  * pname:compatibleHandleTypes is a bitmask of
    slink:VkExternalMemoryHandleTypeFlagBits specifying handle types which
    can: be specified at the same time as pname:handleType when creating an
    image compatible with external memory.

pname:compatibleHandleTypes must: include at least pname:handleType.
Inclusion of a handle type in pname:compatibleHandleTypes does not imply the
values returned in slink:VkImageFormatProperties2 will be the same when
slink:VkPhysicalDeviceExternalImageFormatInfo::pname:handleType is set to
that type.
The application is responsible for querying the capabilities of all handle
types intended for concurrent use in a single image and intersecting them to
obtain the compatible set of capabilities.

include::../validity/structs/VkExternalMemoryProperties.txt[]
--

[open,refpage='VkExternalMemoryFeatureFlagBits',desc='Bitmask specifying features of an external memory handle type',type='enums']
--

Bits which may: be set in
slink:VkExternalMemoryProperties::pname:externalMemoryFeatures, specifying
features of an external memory handle type, are:

include::../api/enums/VkExternalMemoryFeatureFlagBits.txt[]

ifdef::VK_KHR_external_memory_capabilities[]
or the equivalent

include::../api/enums/VkExternalMemoryFeatureFlagBitsKHR.txt[]
endif::VK_KHR_external_memory_capabilities[]

  * ename:VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT specifies that
    images or buffers created with the specified parameters and handle type
    must: use the mechanisms defined in the `<<VK_NV_dedicated_allocation>>`
    extension to create (or import) a dedicated allocation for the image or
    buffer.
  * ename:VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT specifies that handles
    of this type can: be exported from Vulkan memory objects.
  * ename:VK_INTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT specifies that handles
    of this type can: be imported as Vulkan memory objects.

Because their semantics in external APIs roughly align with that of an image
or buffer with a dedicated allocation in Vulkan, implementations are
required: to report ename:VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT for
the following external handle types:

  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT
  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT
  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
  * ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID
    for images only
endif::VK_ANDROID_external_memory_android_hardware_buffer[]

ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
Implementations must: not report
ename:VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT for buffers with
external handle type
ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID.
endif::VK_ANDROID_external_memory_android_hardware_buffer[]

--

[open,refpage='VkExternalMemoryFeatureFlags',desc='Bitmask of VkExternalMemoryFeatureFlagBits',type='enums']
--
include::../api/flags/VkExternalMemoryFeatureFlags.txt[]

ifdef::VK_KHR_external_memory_capabilities[]
or the equivalent

include::../api/flags/VkExternalMemoryFeatureFlagsKHR.txt[]
endif::VK_KHR_external_memory_capabilities[]

sname:VkExternalMemoryFeatureFlags is a bitmask type for setting a mask of
zero or more slink:VkExternalMemoryFeatureFlagBits.
--

endif::VK_VERSION_1_1,VK_KHR_external_memory_capabilities[]

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

[open,refpage='VkSamplerYcbcrConversionImageFormatProperties',desc='Structure specifying combined image sampler descriptor count for multi-planar images',type='structs']
--

To determine the number of combined image samplers required to support a
multi-planar format, add slink:VkSamplerYcbcrConversionImageFormatProperties
to the pname:pNext chain of the slink:VkImageFormatProperties2 structure in
a call to fname:vkGetPhysicalDeviceImageFormatProperties2.

The sname:VkSamplerYcbcrConversionImageFormatProperties structure is defined
as:

include::../api/structs/VkSamplerYcbcrConversionImageFormatProperties.txt[]

ifdef::VK_KHR_sampler_ycbcr_conversion[]
or the equivalent

include::../api/structs/VkSamplerYcbcrConversionImageFormatPropertiesKHR.txt[]
endif::VK_KHR_sampler_ycbcr_conversion[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:combinedImageSamplerDescriptorCount is the number of combined
    image sampler descriptors that the implementation uses to access the
    format.

include::../validity/structs/VkSamplerYcbcrConversionImageFormatProperties.txt[]
--

pname:combinedImageSamplerDescriptorCount affects only the count towards the
pname:maxDescriptorSetSamplers, pname:maxDescriptorSetSampledImages,
pname:maxPerStageDescriptorSamplers, and
pname:maxPerStageDescriptorSampledImages limits, and does not affect binding
numbers in the slink:VkDescriptorSetLayoutBinding.

pname:combinedImageSamplerDescriptorCount is a number between 1 and the
number of planes in the format.

endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]

[open,refpage='VkAndroidHardwareBufferUsageANDROID',desc='Struct containing Android hardware buffer usage flags',type='structs']
--
To obtain optimal Android hardware buffer usage flags for specific image
creation parameters, attach an instance of
sname:VkAndroidHardwareBufferUsageANDROID to the pname:pNext chain of a
slink:VkImageFormatProperties2 structure passed to
slink:vkGetPhysicalDeviceImageFormatProperties2.
This structure is defined as:

include::../api/structs/VkAndroidHardwareBufferUsageANDROID.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:androidHardwareBufferUsage returns the Android hardware buffer
    usage flags.

The pname:androidHardwareBufferUsage field must: include Android hardware
buffer usage flags listed in the
<<memory-external-android-hardware-buffer-usage,AHardwareBuffer Usage
Equivalence>> table when the corresponding Vulkan image usage or image
creation flags are included in the pname:usage or pname:flags fields of
slink:VkPhysicalDeviceImageFormatInfo2.
It must: include at least one GPU usage flag
(code:AHARDWAREBUFFER_USAGE_GPU_*), even if none of the corresponding Vulkan
usages or flags are requested.

.Note
[NOTE]
====
Requiring at least one GPU usage flag ensures that Android hardware buffer
memory will be allocated in a memory pool accessible to the Vulkan
implementation, and that specializing the memory layout based on usage flags
does not prevent it from being compatible with Vulkan.
Implementations may: avoid unnecessary restrictions caused by this
requirement by using vendor usage flags to indicate that only the Vulkan
uses indicated in slink:VkImageFormatProperties2 are required.
====

include::../validity/structs/VkAndroidHardwareBufferUsageANDROID.txt[]
--

endif::VK_ANDROID_external_memory_android_hardware_buffer[]

endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]


[[features-supported-sample-counts]]
=== Supported Sample Counts
fname:vkGetPhysicalDeviceImageFormatProperties returns a bitmask of
elink:VkSampleCountFlagBits in pname:sampleCounts specifying the supported
sample counts for the image parameters.

pname:sampleCounts will be set to ename:VK_SAMPLE_COUNT_1_BIT if at least
one of the following conditions is true:

  * pname:tiling is ename:VK_IMAGE_TILING_LINEAR
  * pname:type is not ename:VK_IMAGE_TYPE_2D
  * pname:flags contains ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT
  * Neither the ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT flag nor the
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT flag in
    sname:VkFormatProperties::pname:optimalTilingFeatures returned by
    flink:vkGetPhysicalDeviceFormatProperties is set
ifdef::VK_VERSION_1_1,VK_KHR_external_memory_capabilities[]
  * pname:VkPhysicalDeviceExternalImageFormatInfoKHR::pname:handleType is an
    external handle type for which multisampled image support is not
    required.
endif::VK_VERSION_1_1,VK_KHR_external_memory_capabilities[]

Otherwise, the bits set in pname:sampleCounts will be the sample counts
supported for the specified values of pname:usage and pname:format.
For each bit set in pname:usage, the supported sample counts relate to the
limits in sname:VkPhysicalDeviceLimits as follows:

  * If pname:usage includes ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT and
    pname:format is a floating- or fixed-point color format, a superset of
    sname:VkPhysicalDeviceLimits::pname:framebufferColorSampleCounts
  * If pname:usage includes
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and pname:format
    includes a depth aspect, a superset of
    sname:VkPhysicalDeviceLimits::pname:framebufferDepthSampleCounts
  * If pname:usage includes
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and pname:format
    includes a stencil aspect, a superset of
    sname:VkPhysicalDeviceLimits::pname:framebufferStencilSampleCounts
  * If pname:usage includes ename:VK_IMAGE_USAGE_SAMPLED_BIT, and
    pname:format includes a color aspect, a superset of
    sname:VkPhysicalDeviceLimits::pname:sampledImageColorSampleCounts
  * If pname:usage includes ename:VK_IMAGE_USAGE_SAMPLED_BIT, and
    pname:format includes a depth aspect, a superset of
    sname:VkPhysicalDeviceLimits::pname:sampledImageDepthSampleCounts
  * If pname:usage includes ename:VK_IMAGE_USAGE_SAMPLED_BIT, and
    pname:format is an integer format, a superset of
    sname:VkPhysicalDeviceLimits::pname:sampledImageIntegerSampleCounts
  * If pname:usage includes ename:VK_IMAGE_USAGE_STORAGE_BIT, a superset of
    sname:VkPhysicalDeviceLimits::pname:storageImageSampleCounts

If multiple bits are set in pname:usage, pname:sampleCounts will be the
intersection of the per-usage values described above.

If none of the bits described above are set in pname:usage, then there is no
corresponding limit in sname:VkPhysicalDeviceLimits.
In this case, pname:sampleCounts must: include at least
ename:VK_SAMPLE_COUNT_1_BIT.


[[features-extentperimagetype]]
=== Allowed Extent Values Based On Image Type

Implementations may: support extent values larger than the
<<features-limits-minmax, required minimum/maximum values>> for certain
types of images subject to the constraints below.

[NOTE]
.Note
====
Implementations must: support images with dimensions up to the
<<features-limits-minmax, required minimum/maximum values>> for all types of
images.
It follows that the query for additional capabilities must: return extent
values that are at least as large as the required values.
====

For ename:VK_IMAGE_TYPE_1D:

  * [eq]#pname:maxExtent.width {geq}
         slink:VkPhysicalDeviceLimits.pname:maxImageDimension1D#
  * [eq]#pname:maxExtent.height = 1#
  * [eq]#pname:maxExtent.depth = 1#

For ename:VK_IMAGE_TYPE_2D when pname:flags does not contain
ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT:

  * [eq]#pname:maxExtent.width {geq}
         slink:VkPhysicalDeviceLimits.pname:maxImageDimension2D#
  * [eq]#pname:maxExtent.height {geq}
         slink:VkPhysicalDeviceLimits.pname:maxImageDimension2D#
  * [eq]#pname:maxExtent.depth = 1#

For ename:VK_IMAGE_TYPE_2D when pname:flags contains
ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT:

  * [eq]#pname:maxExtent.width {geq}
         slink:VkPhysicalDeviceLimits.pname:maxImageDimensionCube#
  * [eq]#pname:maxExtent.height {geq}
         slink:VkPhysicalDeviceLimits.pname:maxImageDimensionCube#
  * [eq]#pname:maxExtent.depth = 1#

For ename:VK_IMAGE_TYPE_3D:

  * [eq]#pname:maxExtent.width {geq}
         slink:VkPhysicalDeviceLimits.pname:maxImageDimension3D#
  * [eq]#pname:maxExtent.height {geq}
         slink:VkPhysicalDeviceLimits.pname:maxImageDimension3D#
  * [eq]#pname:maxExtent.depth {geq}
         slink:VkPhysicalDeviceLimits.pname:maxImageDimension3D#


ifdef::VK_VERSION_1_1,VK_KHR_external_memory_capabilities[]
== Additional Buffer Capabilities

In addition to the capabilities described in the previous sections
(<<features-limits,Limits>> and <<features-formats,Formats>>),
implementations may support additional buffer capabilities.

[open,refpage='vkGetPhysicalDeviceExternalBufferProperties',desc='Query external handle types supported by buffers',type='protos']
--

To query the external handle types supported by buffers, call:

ifdef::VK_VERSION_1_1[]
include::../api/protos/vkGetPhysicalDeviceExternalBufferProperties.txt[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_external_memory_capabilities[or the equivalent command]

ifdef::VK_KHR_external_memory_capabilities[]
include::../api/protos/vkGetPhysicalDeviceExternalBufferPropertiesKHR.txt[]
endif::VK_KHR_external_memory_capabilities[]

  * pname:physicalDevice is the physical device from which to query the
    buffer capabilities.
  * pname:pExternalBufferInfo points to an instance of the
    slink:VkPhysicalDeviceExternalBufferInfo structure, describing the
    parameters that would be consumed by flink:vkCreateBuffer.
  * pname:pExternalBufferProperties points to an instance of the
    slink:VkExternalBufferProperties structure in which capabilities are
    returned.

include::../validity/protos/vkGetPhysicalDeviceExternalBufferProperties.txt[]
--

[open,refpage='VkPhysicalDeviceExternalBufferInfo',desc='Structure specifying buffer creation parameters',type='structs']
--

The sname:VkPhysicalDeviceExternalBufferInfo structure is defined as:

include::../api/structs/VkPhysicalDeviceExternalBufferInfo.txt[]

ifdef::VK_KHR_external_memory_capabilities[]
or the equivalent

include::../api/structs/VkPhysicalDeviceExternalBufferInfoKHR.txt[]
endif::VK_KHR_external_memory_capabilities[]

  * pname:sType is the type of this structure
  * pname:pNext is NULL or a pointer to an extension-specific structure.
  * pname:flags is a bitmask of elink:VkBufferCreateFlagBits describing
    additional parameters of the buffer, corresponding to
    slink:VkBufferCreateInfo::pname:flags.
  * pname:usage is a bitmask of elink:VkBufferUsageFlagBits describing the
    intended usage of the buffer, corresponding to
    slink:VkBufferCreateInfo::pname:usage.
  * pname:handleType is a elink:VkExternalMemoryHandleTypeFlagBits value
    specifying the memory handle type that will be used with the memory
    associated with the buffer.

include::../validity/structs/VkPhysicalDeviceExternalBufferInfo.txt[]
--

[open,refpage='VkExternalBufferProperties',desc='Structure specifying supported external handle capabilities',type='structs']
--

The sname:VkExternalBufferProperties structure is defined as:

include::../api/structs/VkExternalBufferProperties.txt[]

ifdef::VK_KHR_external_memory_capabilities[]
or the equivalent

include::../api/structs/VkExternalBufferPropertiesKHR.txt[]
endif::VK_KHR_external_memory_capabilities[]

  * pname:sType is the type of this structure
  * pname:pNext is NULL or a pointer to an extension-specific structure.
  * pname:externalMemoryProperties is an instance of the
    slink:VkExternalMemoryProperties structure specifying various
    capabilities of the external handle type when used with the specified
    buffer creation parameters.

include::../validity/structs/VkExternalBufferProperties.txt[]
--

endif::VK_VERSION_1_1,VK_KHR_external_memory_capabilities[]


ifdef::VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities[]
== Optional Semaphore Capabilities

[open,refpage='vkGetPhysicalDeviceExternalSemaphoreProperties',desc='Function for querying external semaphore handle capabilities.',type='protos']
--

Semaphores may: support import and export of their
<<synchronization-semaphores-payloads, payload>> to external handles.
To query the external handle types supported by semaphores, call:

ifdef::VK_VERSION_1_1[]
include::../api/protos/vkGetPhysicalDeviceExternalSemaphoreProperties.txt[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_external_semaphore_capabilities[or the equivalent command]

ifdef::VK_KHR_external_semaphore_capabilities[]
include::../api/protos/vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.txt[]
endif::VK_KHR_external_semaphore_capabilities[]

  * pname:physicalDevice is the physical device from which to query the
    semaphore capabilities.
  * pname:pExternalSemaphoreInfo points to an instance of the
    slink:VkPhysicalDeviceExternalSemaphoreInfo structure, describing the
    parameters that would be consumed by flink:vkCreateSemaphore.
  * pname:pExternalSemaphoreProperties points to an instance of the
    slink:VkExternalSemaphoreProperties structure in which capabilities are
    returned.

include::../validity/protos/vkGetPhysicalDeviceExternalSemaphoreProperties.txt[]
--

[open,refpage='VkPhysicalDeviceExternalSemaphoreInfo',desc='Structure specifying semaphore creation parameters.',type='structs']
--

The sname:VkPhysicalDeviceExternalSemaphoreInfo structure is defined as:

include::../api/structs/VkPhysicalDeviceExternalSemaphoreInfo.txt[]

ifdef::VK_KHR_external_semaphore_capabilities[]
or the equivalent

include::../api/structs/VkPhysicalDeviceExternalSemaphoreInfoKHR.txt[]
endif::VK_KHR_external_semaphore_capabilities[]

  * pname:sType is the type of this structure
  * pname:pNext is NULL or a pointer to an extension-specific structure.
  * pname:handleType is a elink:VkExternalSemaphoreHandleTypeFlagBits value
    specifying the external semaphore handle type for which capabilities
    will be returned.

include::../validity/structs/VkPhysicalDeviceExternalSemaphoreInfo.txt[]
--

[open,refpage='VkExternalSemaphoreHandleTypeFlagBits',desc='Bitmask of valid external semaphore handle types',type='enums']
--

Bits which may: be set in
slink:VkPhysicalDeviceExternalSemaphoreInfo::pname:handleType, specifying an
external semaphore handle type, are:

include::../api/enums/VkExternalSemaphoreHandleTypeFlagBits.txt[]

ifdef::VK_KHR_external_semaphore_capabilities[]
or the equivalent

include::../api/enums/VkExternalSemaphoreHandleTypeFlagBitsKHR.txt[]
endif::VK_KHR_external_semaphore_capabilities[]

  * ename:VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT specifies a POSIX
    file descriptor handle that has only limited valid usage outside of
    Vulkan and other compatible APIs.
    It must: be compatible with the POSIX system calls code:dup, code:dup2,
    code:close, and the non-standard system call code:dup3.
    Additionally, it must: be transportable over a socket using an
    code:SCM_RIGHTS control message.
    It owns a reference to the underlying synchronization primitive
    represented by its Vulkan semaphore object.
  * ename:VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT specifies an NT
    handle that has only limited valid usage outside of Vulkan and other
    compatible APIs.
    It must: be compatible with the functions code:DuplicateHandle,
    code:CloseHandle, code:CompareObjectHandles, code:GetHandleInformation,
    and code:SetHandleInformation.
    It owns a reference to the underlying synchronization primitive
    represented by its Vulkan semaphore object.
  * ename:VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT specifies a
    global share handle that has only limited valid usage outside of Vulkan
    and other compatible APIs.
    It is not compatible with any native APIs.
    It does not own a reference to the underlying synchronization primitive
    represented its Vulkan semaphore object, and will therefore become
    invalid when all Vulkan semaphore objects associated with it are
    destroyed.
  * ename:VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT specifies an NT
    handle returned by code:ID3D12Device::code:CreateSharedHandle referring
    to a Direct3D 12 fence.
    It owns a reference to the underlying synchronization primitive
    associated with the Direct3D fence.
  * ename:VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT specifies a POSIX
    file descriptor handle to a Linux Sync File or Android Fence object.
    It can be used with any native API accepting a valid sync file or fence
    as input.
    It owns a reference to the underlying synchronization primitive
    associated with the file descriptor.
    Implementations which support importing this handle type must: accept
    any type of sync or fence FD supported by the native system they are
    running on.

[NOTE]
.Note
====
Handles of type ename:VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT
generated by the implementation may represent either Linux Sync Files or
Android Fences at the implementation's discretion.
Applications should: only use operations defined for both types of file
descriptors, unless they know via means external to Vulkan the type of the
file descriptor, or are prepared to deal with the system-defined operation
failures resulting from using the wrong type.
====

<<<

Some external semaphore handle types can only be shared within the same
underlying physical device and/or the same driver version, as defined in the
following table:

[[external-semaphore-handle-types-compatibility]]
.External semaphore handle types compatibility
|====
| Handle type | sname:VkPhysicalDeviceIDProperties::pname:driverUUID | sname:VkPhysicalDeviceIDProperties::pname:deviceUUID
| ename:VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT | Must match | Must match
| ename:VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT | Must match | Must match
| ename:VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT | Must match | Must match
| ename:VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT | Must match | Must match
| ename:VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT | No restriction | No restriction
|====

--

[open,refpage='VkExternalSemaphoreHandleTypeFlags',desc='Bitmask of VkExternalSemaphoreHandleTypeFlagBits',type='enums']
--
include::../api/flags/VkExternalSemaphoreHandleTypeFlags.txt[]

ifdef::VK_KHR_external_semaphore_capabilities[]
or the equivalent

include::../api/flags/VkExternalSemaphoreHandleTypeFlagsKHR.txt[]
endif::VK_KHR_external_semaphore_capabilities[]

sname:VkExternalSemaphoreHandleTypeFlags is a bitmask type for setting a
mask of zero or more slink:VkExternalSemaphoreHandleTypeFlagBits.
--

[open,refpage='VkExternalSemaphoreProperties',desc='Structure describing supported external semaphore handle features',type='structs']
--

The sname:VkExternalSemaphoreProperties structure is defined as:

include::../api/structs/VkExternalSemaphoreProperties.txt[]

ifdef::VK_KHR_external_semaphore_capabilities[]
or the equivalent

include::../api/structs/VkExternalSemaphorePropertiesKHR.txt[]
endif::VK_KHR_external_semaphore_capabilities[]

  * pname:exportFromImportedHandleTypes is a bitmask of
    elink:VkExternalSemaphoreHandleTypeFlagBits specifying which types of
    imported handle pname:handleType can: be exported from.
  * pname:compatibleHandleTypes is a bitmask of
    elink:VkExternalSemaphoreHandleTypeFlagBits specifying handle types
    which can: be specified at the same time as pname:handleType when
    creating a semaphore.
  * pname:externalSemaphoreFeatures is a bitmask of
    elink:VkExternalSemaphoreFeatureFlagBits describing the features of
    pname:handleType.

If pname:handleType is not supported by the implementation, then
slink:VkExternalSemaphoreProperties::pname:externalSemaphoreFeatures will be
set to zero.

include::../validity/structs/VkExternalSemaphoreProperties.txt[]
--

[open,refpage='VkExternalSemaphoreFeatureFlagBits',desc='Bitfield describing features of an external semaphore handle type',type='enums']
--

Possible values of
slink:VkExternalSemaphoreProperties::pname:externalSemaphoreFeatures,
specifying the features of an external semaphore handle type, are:

include::../api/enums/VkExternalSemaphoreFeatureFlagBits.txt[]

ifdef::VK_KHR_external_semaphore_capabilities[]
or the equivalent

include::../api/enums/VkExternalSemaphoreFeatureFlagBitsKHR.txt[]
endif::VK_KHR_external_semaphore_capabilities[]

  * ename:VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT specifies that
    handles of this type can: be exported from Vulkan semaphore objects.
  * ename:VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT specifies that
    handles of this type can: be imported as Vulkan semaphore objects.

--

[open,refpage='VkExternalSemaphoreFeatureFlags',desc='Bitmask of VkExternalSemaphoreFeatureFlagBitsKHR',type='enums']
--
include::../api/flags/VkExternalSemaphoreFeatureFlags.txt[]

ifdef::VK_KHR_external_semaphore_capabilities[]
or the equivalent

include::../api/flags/VkExternalSemaphoreFeatureFlagsKHR.txt[]
endif::VK_KHR_external_semaphore_capabilities[]

sname:VkExternalSemaphoreFeatureFlags is a bitmask type for setting a mask
of zero or more slink:VkExternalSemaphoreFeatureFlagBits.
--

endif::VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities[]


ifdef::VK_VERSION_1_1,VK_KHR_external_fence_capabilities[]

== Optional Fence Capabilities

[open,refpage='vkGetPhysicalDeviceExternalFenceProperties',desc='Function for querying external fence handle capabilities.',type='protos']
--

Fences may: support import and export of their
<<synchronization-fences-payloads, payload>> to external handles.
To query the external handle types supported by fences, call:

ifdef::VK_VERSION_1_1[]
include::../api/protos/vkGetPhysicalDeviceExternalFenceProperties.txt[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_external_fence_capabilities[or the equivalent command]

ifdef::VK_KHR_external_fence_capabilities[]
include::../api/protos/vkGetPhysicalDeviceExternalFencePropertiesKHR.txt[]
endif::VK_KHR_external_fence_capabilities[]

  * pname:physicalDevice is the physical device from which to query the
    fence capabilities.
  * pname:pExternalFenceInfo points to an instance of the
    slink:VkPhysicalDeviceExternalFenceInfo structure, describing the
    parameters that would be consumed by flink:vkCreateFence.
  * pname:pExternalFenceProperties points to an instance of the
    slink:VkExternalFenceProperties structure in which capabilities are
    returned.

include::../validity/protos/vkGetPhysicalDeviceExternalFenceProperties.txt[]
--

[open,refpage='VkPhysicalDeviceExternalFenceInfo',desc='Structure specifying fence creation parameters.',type='structs']
--

The sname:VkPhysicalDeviceExternalFenceInfo structure is defined as:

include::../api/structs/VkPhysicalDeviceExternalFenceInfo.txt[]

ifdef::VK_KHR_external_fence_capabilities[]
or the equivalent

include::../api/structs/VkPhysicalDeviceExternalFenceInfoKHR.txt[]
endif::VK_KHR_external_fence_capabilities[]

  * pname:sType is the type of this structure
  * pname:pNext is NULL or a pointer to an extension-specific structure.
  * pname:handleType is a elink:VkExternalFenceHandleTypeFlagBits value
    indicating an external fence handle type for which capabilities will be
    returned.

[NOTE]
.Note
====
Handles of type ename:VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT generated by
the implementation may represent either Linux Sync Files or Android Fences
at the implementation's discretion.
Applications should: only use operations defined for both types of file
descriptors, unless they know via means external to Vulkan the type of the
file descriptor, or are prepared to deal with the system-defined operation
failures resulting from using the wrong type.
====

include::../validity/structs/VkPhysicalDeviceExternalFenceInfo.txt[]
--

[open,refpage='VkExternalFenceHandleTypeFlagBits',desc='Bitmask of valid external fence handle types',type='enums']
--

Bits which may: be set in
slink:VkPhysicalDeviceExternalFenceInfo::pname:handleType, and in the
pname:exportFromImportedHandleTypes and pname:compatibleHandleTypes members
of slink:VkExternalFenceProperties, to indicate external fence handle types,
are:

include::../api/enums/VkExternalFenceHandleTypeFlagBits.txt[]

ifdef::VK_KHR_external_fence_capabilities[]
or the equivalent

include::../api/enums/VkExternalFenceHandleTypeFlagBitsKHR.txt[]
endif::VK_KHR_external_fence_capabilities[]

  * ename:VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT specifies a POSIX file
    descriptor handle that has only limited valid usage outside of Vulkan
    and other compatible APIs.
    It must: be compatible with the POSIX system calls code:dup, code:dup2,
    code:close, and the non-standard system call code:dup3.
    Additionally, it must: be transportable over a socket using an
    code:SCM_RIGHTS control message.
    It owns a reference to the underlying synchronization primitive
    represented by its Vulkan fence object.
  * ename:VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT specifies an NT
    handle that has only limited valid usage outside of Vulkan and other
    compatible APIs.
    It must: be compatible with the functions code:DuplicateHandle,
    code:CloseHandle, code:CompareObjectHandles, code:GetHandleInformation,
    and code:SetHandleInformation.
    It owns a reference to the underlying synchronization primitive
    represented by its Vulkan fence object.
  * ename:VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT specifies a
    global share handle that has only limited valid usage outside of Vulkan
    and other compatible APIs.
    It is not compatible with any native APIs.
    It does not own a reference to the underlying synchronization primitive
    represented by its Vulkan fence object, and will therefore become
    invalid when all Vulkan fence objects associated with it are destroyed.
  * ename:VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT specifies a POSIX file
    descriptor handle to a Linux Sync File or Android Fence.
    It can be used with any native API accepting a valid sync file or fence
    as input.
    It owns a reference to the underlying synchronization primitive
    associated with the file descriptor.
    Implementations which support importing this handle type must: accept
    any type of sync or fence FD supported by the native system they are
    running on.

<<<

Some external fence handle types can only be shared within the same
underlying physical device and/or the same driver version, as defined in the
following table:

[[external-fence-handle-types-compatibility]]
.External fence handle types compatibility
|====
| Handle type | sname:VkPhysicalDeviceIDProperties::pname:driverUUID | sname:VkPhysicalDeviceIDProperties::pname:deviceUUID
| ename:VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT | Must match | Must match
| ename:VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT | Must match | Must match
| ename:VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT | Must match | Must match
| ename:VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT | No restriction | No restriction
|====

--

[open,refpage='VkExternalFenceHandleTypeFlags',desc='Bitmask of VkExternalFenceHandleTypeFlagBits',type='enums']
--
include::../api/flags/VkExternalFenceHandleTypeFlags.txt[]

ifdef::VK_KHR_external_fence_capabilities[]
or the equivalent

include::../api/flags/VkExternalFenceHandleTypeFlagsKHR.txt[]
endif::VK_KHR_external_fence_capabilities[]

sname:VkExternalFenceHandleTypeFlags is a bitmask type for setting a mask of
zero or more slink:VkExternalFenceHandleTypeFlagBits.
--

[open,refpage='VkExternalFenceProperties',desc='Structure describing supported external fence handle features',type='structs']
--

The sname:VkExternalFenceProperties structure is defined as:

include::../api/structs/VkExternalFenceProperties.txt[]

ifdef::VK_KHR_external_fence_capabilities[]
or the equivalent

include::../api/structs/VkExternalFencePropertiesKHR.txt[]
endif::VK_KHR_external_fence_capabilities[]

  * pname:exportFromImportedHandleTypes is a bitmask of
    elink:VkExternalFenceHandleTypeFlagBits indicating which types of
    imported handle pname:handleType can: be exported from.
  * pname:compatibleHandleTypes is a bitmask of
    elink:VkExternalFenceHandleTypeFlagBits specifying handle types which
    can: be specified at the same time as pname:handleType when creating a
    fence.
  * pname:externalFenceFeatures is a bitmask of
    elink:VkExternalFenceFeatureFlagBits indicating the features of
    pname:handleType.

If pname:handleType is not supported by the implementation, then
slink:VkExternalFenceProperties::pname:externalFenceFeatures will be set to
zero.

include::../validity/structs/VkExternalFenceProperties.txt[]
--

[open,refpage='VkExternalFenceFeatureFlagBits',desc='Bitfield describing features of an external fence handle type',type='enums']
--
Bits which may: be set in
slink:VkExternalFenceProperties::pname:externalFenceFeatures, indicating
features of a fence external handle type, are:

include::../api/enums/VkExternalFenceFeatureFlagBits.txt[]

ifdef::VK_KHR_external_fence_capabilities[]
or the equivalent

include::../api/enums/VkExternalFenceFeatureFlagBitsKHR.txt[]
endif::VK_KHR_external_fence_capabilities[]

  * ename:VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT specifies handles of this
    type can: be exported from Vulkan fence objects.
  * ename:VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT specifies handles of this
    type can: be imported to Vulkan fence objects.
--

[open,refpage='VkExternalFenceFeatureFlags',desc='Bitmask of VkExternalFenceFeatureFlagBits',type='enums']
--
include::../api/flags/VkExternalFenceFeatureFlags.txt[]

ifdef::VK_KHR_external_fence_capabilities[]
or the equivalent

include::../api/flags/VkExternalFenceFeatureFlagsKHR.txt[]
endif::VK_KHR_external_fence_capabilities[]

sname:VkExternalFenceFeatureFlags is a bitmask type for setting a mask of
zero or more slink:VkExternalFenceFeatureFlagBits.
--

endif::VK_VERSION_1_1,VK_KHR_external_fence_capabilities[]
