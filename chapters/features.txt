// Copyright (c) 2015-2019 Khronos Group. This work is licensed under a
// Creative Commons Attribution 4.0 International License; see
// http://creativecommons.org/licenses/by/4.0/

[[features]]
= Features

_Features_ describe functionality which is not supported on all
implementations.
Features are properties of the physical device.
Features are optional:, and must: be explicitly enabled before use.
Support for features is reported and enabled on a per-feature basis.

[NOTE]
.Note
====
Features are reported via the basic slink:VkPhysicalDeviceFeatures
structure, as well as the extensible structure
sname:VkPhysicalDeviceFeatures2, which was added in the
`<<VK_KHR_get_physical_device_properties2>>` extension and included in
Vulkan 1.1.
When new features are added in future Vulkan versions or extensions, each
extension should: introduce one new feature structure, if needed.
This structure can: be added to the pname:pNext chain of the
sname:VkPhysicalDeviceFeatures2 structure.
====

[open,refpage='vkGetPhysicalDeviceFeatures',desc='Reports capabilities of a physical device',type='protos']
--
To query supported features, call:

include::../api/protos/vkGetPhysicalDeviceFeatures.txt[]

  * pname:physicalDevice is the physical device from which to query the
    supported features.
  * pname:pFeatures is a pointer to a slink:VkPhysicalDeviceFeatures
    structure in which the physical device features are returned.
    For each feature, a value of ename:VK_TRUE specifies that the feature is
    supported on this physical device, and ename:VK_FALSE specifies that the
    feature is not supported.

include::../validity/protos/vkGetPhysicalDeviceFeatures.txt[]
--

Fine-grained features used by a logical device must: be enabled at
sname:VkDevice creation time.
If a feature is enabled that the physical device does not support,
sname:VkDevice creation will fail.
If an application uses a feature without enabling it at sname:VkDevice
creation time, the device behavior is undefined:.
The validation layer will warn if features are used without being enabled.

The fine-grained features are enabled by passing a pointer to the
sname:VkPhysicalDeviceFeatures structure via the pname:pEnabledFeatures
member of the sname:VkDeviceCreateInfo structure that is passed into the
fname:vkCreateDevice call.
If a member of pname:pEnabledFeatures is set to ename:VK_TRUE or
ename:VK_FALSE, then the device will be created with the indicated feature
enabled or disabled, respectively.
ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
Features can: also be enabled by using the slink:VkPhysicalDeviceFeatures2
structure.
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

If an application wishes to enable all features supported by a device, it
can: simply pass in the sname:VkPhysicalDeviceFeatures structure that was
previously returned by fname:vkGetPhysicalDeviceFeatures.
To disable an individual feature, the application can: set the desired
member to ename:VK_FALSE in the same structure.
Setting pname:pEnabledFeatures to `NULL`
ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
and not including a slink:VkPhysicalDeviceFeatures2 in the pname:pNext
member of slink:VkDeviceCreateInfo
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
is equivalent to setting all members of the structure to ename:VK_FALSE.

[NOTE]
.Note
====
Some features, such as pname:robustBufferAccess, may: incur a run-time
performance cost.
Application writers should: carefully consider the implications of enabling
all supported features.
====

ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

[open,refpage='vkGetPhysicalDeviceFeatures2',desc='Reports capabilities of a physical device',type='protos']
--

To query supported features defined by the core or extensions, call:

ifdef::VK_VERSION_1_1[]
include::../api/protos/vkGetPhysicalDeviceFeatures2.txt[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_get_physical_device_properties2[or the equivalent command]

ifdef::VK_KHR_get_physical_device_properties2[]
include::../api/protos/vkGetPhysicalDeviceFeatures2KHR.txt[]
endif::VK_KHR_get_physical_device_properties2[]

  * pname:physicalDevice is the physical device from which to query the
    supported features.
  * pname:pFeatures is a pointer to a slink:VkPhysicalDeviceFeatures2
    structure in which the physical device features are returned.

Each structure in pname:pFeatures and its pname:pNext chain contain members
corresponding to fine-grained features.
fname:vkGetPhysicalDeviceFeatures2 writes each member to a boolean value
indicating whether that feature is supported.

include::../validity/protos/vkGetPhysicalDeviceFeatures2.txt[]
--

[open,refpage='VkPhysicalDeviceFeatures2',desc='Structure describing the fine-grained features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFeatures2 structure is defined as:

include::../api/structs/VkPhysicalDeviceFeatures2.txt[]

ifdef::VK_KHR_get_physical_device_properties2[]
or the equivalent

include::../api/structs/VkPhysicalDeviceFeatures2KHR.txt[]
endif::VK_KHR_get_physical_device_properties2[]

The sname:VkPhysicalDeviceFeatures2 structure is defined as:

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:features is a structure of type slink:VkPhysicalDeviceFeatures
    describing the fine-grained features of the Vulkan 1.0 API.

The pname:pNext chain of this structure is used to extend the structure with
features defined by extensions.
This structure can: be used in flink:vkGetPhysicalDeviceFeatures2 or can: be
in the pname:pNext chain of a slink:VkDeviceCreateInfo structure, in which
case it controls which features are enabled in the device in lieu of
pname:pEnabledFeatures.

include::../validity/structs/VkPhysicalDeviceFeatures2.txt[]
--

endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]

[open,refpage='VkPhysicalDeviceFeatures',desc='Structure describing the fine-grained features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFeatures structure is defined as:

include::../api/structs/VkPhysicalDeviceFeatures.txt[]

The members of the sname:VkPhysicalDeviceFeatures structure describe the
following features:

  * [[features-robustBufferAccess]] pname:robustBufferAccess specifies that
    accesses to buffers are bounds-checked against the range of the buffer
    descriptor (as determined by sname:VkDescriptorBufferInfo::pname:range,
    sname:VkBufferViewCreateInfo::pname:range, or the size of the buffer).
    Out of bounds accesses must: not cause application termination, and the
    effects of shader loads, stores, and atomics must: conform to an
    implementation-dependent behavior as described below.
  ** A buffer access is considered to be out of bounds if any of the
     following are true:
  *** The pointer was formed by code:OpImageTexelPointer and the coordinate
      is less than zero or greater than or equal to the number of whole
      elements in the bound range.
  *** The pointer was not formed by code:OpImageTexelPointer and the object
      pointed to is not wholly contained within the bound range.
ifdef::VK_VERSION_1_1,VK_KHR_variable_pointers[]
      This includes accesses performed via _variable pointers_ where the
      buffer descriptor being accessed cannot be statically determined.
      Uninitialized pointers and pointers equal to code:OpConstantNull are
      treated as pointing to a zero-sized object, so all accesses through
      such pointers are considered to be out of bounds.
endif::VK_VERSION_1_1,VK_KHR_variable_pointers[]
ifdef::VK_EXT_buffer_device_address[]
      Buffer accesses through buffer device addresses are not
      bounds-checked.
endif::VK_EXT_buffer_device_address[]
ifdef::VK_NV_cooperative_matrix[]
      If the
      <<features-cooperativeMatrixRobustBufferAccess,pname:cooperativeMatrixRobustBufferAccess>>
      feature is not enabled, then accesses using
      code:OpCooperativeMatrixLoadNV and code:OpCooperativeMatrixStoreNV
      may: not be bounds-checked.
endif::VK_NV_cooperative_matrix[]
+
[NOTE]
.Note
====
If a SPIR-V code:OpLoad instruction loads a structure and the tail end of
the structure is out of bounds, then all members of the structure are
considered out of bounds even if the members at the end are not statically
used.
====

  *** If any buffer access in a given SPIR-V block is determined to be out
      of bounds, then any other access of the same type (load, store, or
      atomic) in the same SPIR-V block that accesses an address less than 16
      bytes away from the out of bounds address may: also be considered out
      of bounds.
  ** Out-of-bounds buffer loads will return any of the following values:
  *** Values from anywhere within the memory range(s) bound to the buffer
      (possibly including bytes of memory past the end of the buffer, up to
      the end of the bound range).
  *** Zero values, or [eq]#(0,0,0,x)# vectors for vector reads where x is a
      valid value represented in the type of the vector components and may:
      be any of:
  **** 0, 1, or the maximum representable positive integer value, for signed
       or unsigned integer components
  **** 0.0 or 1.0, for floating-point components
  ** Out-of-bounds writes may: modify values within the memory range(s)
     bound to the buffer, but must: not modify any other memory.
  ** Out-of-bounds atomics may: modify values within the memory range(s)
     bound to the buffer, but must: not modify any other memory, and return
     an undefined: value.
  ** Vertex input attributes are considered out of bounds if the offset of
     the attribute in the bound vertex buffer range plus the size of the
     attribute is greater than either:
+
  *** code:vertexBufferRangeSize, if [eq]#code:bindingStride == 0#; or
  *** [eq]#(code:vertexBufferRangeSize - (code:vertexBufferRangeSize %
      code:bindingStride))#
+
where code:vertexBufferRangeSize is the byte size of the memory range bound
to the vertex buffer binding and code:bindingStride is the byte stride of
the corresponding vertex input binding.
Further, if any vertex input attribute using a specific vertex input binding
is out of bounds, then all vertex input attributes using that vertex input
binding for that vertex shader invocation are considered out of bounds.
  *** If a vertex input attribute is out of bounds, it will be assigned one
      of the following values:
  **** Values from anywhere within the memory range(s) bound to the buffer,
     converted according to the format of the attribute.
  **** Zero values, format converted according to the format of the
       attribute.
  **** Zero values, or [eq]#(0,0,0,x)# vectors, as described above.
  ** If pname:robustBufferAccess is not enabled, out of bounds accesses may:
     corrupt any memory within the process and cause undefined: behavior up
     to and including application termination.
  * [[features-fullDrawIndexUint32]] pname:fullDrawIndexUint32 specifies the
    full 32-bit range of indices is supported for indexed draw calls when
    using a elink:VkIndexType of ename:VK_INDEX_TYPE_UINT32.
    pname:maxDrawIndexedIndexValue is the maximum index value that may: be
    used (aside from the primitive restart index, which is always 2^32^-1
    when the elink:VkIndexType is ename:VK_INDEX_TYPE_UINT32).
    If this feature is supported, pname:maxDrawIndexedIndexValue must: be
    2^32^-1; otherwise it must: be no smaller than 2^24^-1.
    See <<limits-maxDrawIndexedIndexValue,maxDrawIndexedIndexValue>>.
  * [[features-imageCubeArray]] pname:imageCubeArray specifies whether image
    views with a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY can: be created, and that the
    corresponding code:SampledCubeArray and code:ImageCubeArray SPIR-V
    capabilities can: be used in shader code.
  * [[features-independentBlend]] pname:independentBlend specifies whether
    the sname:VkPipelineColorBlendAttachmentState settings are controlled
    independently per-attachment.
    If this feature is not enabled, the
    sname:VkPipelineColorBlendAttachmentState settings for all color
    attachments must: be identical.
    Otherwise, a different sname:VkPipelineColorBlendAttachmentState can: be
    provided for each bound color attachment.
  * [[features-geometryShader]] pname:geometryShader specifies whether
    geometry shaders are supported.
    If this feature is not enabled, the ename:VK_SHADER_STAGE_GEOMETRY_BIT
    and ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT enum values must: not be
    used.
    This also specifies whether shader modules can: declare the
    code:Geometry capability.
  * [[features-tessellationShader]] pname:tessellationShader specifies
    whether tessellation control and evaluation shaders are supported.
    If this feature is not enabled, the
    ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, and
    ename:VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO enum
    values must: not be used.
    This also specifies whether shader modules can: declare the
    code:Tessellation capability.
  * [[features-sampleRateShading]] pname:sampleRateShading specifies whether
    <<primsrast-sampleshading,Sample Shading>> and multisample interpolation
    are supported.
    If this feature is not enabled, the pname:sampleShadingEnable member of
    the sname:VkPipelineMultisampleStateCreateInfo structure must: be set to
    ename:VK_FALSE and the pname:minSampleShading member is ignored.
    This also specifies whether shader modules can: declare the
    code:SampleRateShading capability.
  * [[features-dualSrcBlend]] pname:dualSrcBlend specifies whether blend
    operations which take two sources are supported.
    If this feature is not enabled, the ename:VK_BLEND_FACTOR_SRC1_COLOR,
    ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
    ename:VK_BLEND_FACTOR_SRC1_ALPHA, and
    ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA enum values must: not be used
    as source or destination blending factors.
    See <<framebuffer-dsb>>.
  * [[features-logicOp]] pname:logicOp specifies whether logic operations
    are supported.
    If this feature is not enabled, the pname:logicOpEnable member of the
    sname:VkPipelineColorBlendStateCreateInfo structure must: be set to
    ename:VK_FALSE, and the pname:logicOp member is ignored.
  * [[features-multiDrawIndirect]] pname:multiDrawIndirect specifies whether
    multiple draw indirect is supported.
    If this feature is not enabled, the pname:drawCount parameter to the
    fname:vkCmdDrawIndirect and fname:vkCmdDrawIndexedIndirect commands
    must: be 0 or 1.
    The pname:maxDrawIndirectCount member of the
    sname:VkPhysicalDeviceLimits structure must: also be 1 if this feature
    is not supported.
    See <<limits-maxDrawIndirectCount,maxDrawIndirectCount>>.
  * [[features-drawIndirectFirstInstance]] pname:drawIndirectFirstInstance
    specifies whether indirect draw calls support the pname:firstInstance
    parameter.
    If this feature is not enabled, the pname:firstInstance member of all
    sname:VkDrawIndirectCommand and sname:VkDrawIndexedIndirectCommand
    structures that are provided to the fname:vkCmdDrawIndirect and
    fname:vkCmdDrawIndexedIndirect commands must: be 0.
  * [[features-depthClamp]] pname:depthClamp specifies whether depth
    clamping is supported.
    If this feature is not enabled, the pname:depthClampEnable member of the
    sname:VkPipelineRasterizationStateCreateInfo structure must: be set to
    ename:VK_FALSE.
    Otherwise, setting pname:depthClampEnable to ename:VK_TRUE will enable
    depth clamping.
  * [[features-depthBiasClamp]] pname:depthBiasClamp specifies whether depth
    bias clamping is supported.
    If this feature is not enabled, the pname:depthBiasClamp member of the
    sname:VkPipelineRasterizationStateCreateInfo structure must: be set to
    0.0 unless the ename:VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state is
    enabled, and the pname:depthBiasClamp parameter to
    fname:vkCmdSetDepthBias must: be set to 0.0.
  * [[features-fillModeNonSolid]] pname:fillModeNonSolid specifies whether
    point and wireframe fill modes are supported.
    If this feature is not enabled, the ename:VK_POLYGON_MODE_POINT and
    ename:VK_POLYGON_MODE_LINE enum values must: not be used.
  * [[features-depthBounds]] pname:depthBounds specifies whether depth
    bounds tests are supported.
    If this feature is not enabled, the pname:depthBoundsTestEnable member
    of the sname:VkPipelineDepthStencilStateCreateInfo structure must: be
    set to ename:VK_FALSE.
    When pname:depthBoundsTestEnable is set to ename:VK_FALSE, the
    pname:minDepthBounds and pname:maxDepthBounds members of the
    sname:VkPipelineDepthStencilStateCreateInfo structure are ignored.
  * [[features-wideLines]] pname:wideLines specifies whether lines with
    width other than 1.0 are supported.
    If this feature is not enabled, the pname:lineWidth member of the
    sname:VkPipelineRasterizationStateCreateInfo structure must: be set to
    1.0 unless the ename:VK_DYNAMIC_STATE_LINE_WIDTH dynamic state is
    enabled, and the pname:lineWidth parameter to fname:vkCmdSetLineWidth
    must: be set to 1.0.
    When this feature is supported, the range and granularity of supported
    line widths are indicated by the pname:lineWidthRange and
    pname:lineWidthGranularity members of the sname:VkPhysicalDeviceLimits
    structure, respectively.
  * [[features-largePoints]] pname:largePoints specifies whether points with
    size greater than 1.0 are supported.
    If this feature is not enabled, only a point size of 1.0 written by a
    shader is supported.
    The range and granularity of supported point sizes are indicated by the
    pname:pointSizeRange and pname:pointSizeGranularity members of the
    sname:VkPhysicalDeviceLimits structure, respectively.
  * [[features-alphaToOne]] pname:alphaToOne specifies whether the
    implementation is able to replace the alpha value of the color fragment
    output from the fragment shader with the maximum representable alpha
    value for fixed-point colors or 1.0 for floating-point colors.
    If this feature is not enabled, then the pname:alphaToOneEnable member
    of the sname:VkPipelineMultisampleStateCreateInfo structure must: be set
    to ename:VK_FALSE.
    Otherwise setting pname:alphaToOneEnable to ename:VK_TRUE will enable
    alpha-to-one behavior.
  * [[features-multiViewport]] pname:multiViewport specifies whether more
    than one viewport is supported.
    If this feature is not enabled:
  ** The pname:viewportCount and pname:scissorCount members of the
     sname:VkPipelineViewportStateCreateInfo structure must: be set to 1.
  ** The pname:firstViewport and pname:viewportCount parameters to the
     fname:vkCmdSetViewport command must: be set to 0 and 1, respectively.
  ** The pname:firstScissor and pname:scissorCount parameters to the
     fname:vkCmdSetScissor command must: be set to 0 and 1, respectively.
ifdef::VK_NV_scissor_exclusive[]
  ** The pname:exclusiveScissorCount member of the
     sname:VkPipelineViewportExclusiveScissorStateCreateInfoNV structure
     must: be set to 0 or 1.
  ** The pname:firstExclusiveScissor and pname:exclusiveScissorCount
     parameters to the fname:vkCmdSetExclusiveScissorNV command must: be set
     to 0 and 1, respectively.
endif::VK_NV_scissor_exclusive[]
  * [[features-samplerAnisotropy]] pname:samplerAnisotropy specifies whether
    anisotropic filtering is supported.
    If this feature is not enabled, the pname:anisotropyEnable member of the
    sname:VkSamplerCreateInfo structure must: be ename:VK_FALSE.
  * [[features-textureCompressionETC2]] pname:textureCompressionETC2
    specifies whether all of the ETC2 and EAC compressed texture formats are
    supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK
  ** ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
  ** ename:VK_FORMAT_EAC_R11_UNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11_SNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK
  ** ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

  * [[features-textureCompressionASTC_LDR]] pname:textureCompressionASTC_LDR
    specifies whether all of the ASTC LDR compressed texture formats are
    supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK
  ** ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK
  ** ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

  * [[features-textureCompressionBC]] pname:textureCompressionBC specifies
    whether all of the BC compressed texture formats are supported.
    If this feature is enabled, then the
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT and
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must:
    be supported in pname:optimalTilingFeatures for the following formats:
+
  ** ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK
  ** ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK
  ** ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK
  ** ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK
  ** ename:VK_FORMAT_BC2_UNORM_BLOCK
  ** ename:VK_FORMAT_BC2_SRGB_BLOCK
  ** ename:VK_FORMAT_BC3_UNORM_BLOCK
  ** ename:VK_FORMAT_BC3_SRGB_BLOCK
  ** ename:VK_FORMAT_BC4_UNORM_BLOCK
  ** ename:VK_FORMAT_BC4_SNORM_BLOCK
  ** ename:VK_FORMAT_BC5_UNORM_BLOCK
  ** ename:VK_FORMAT_BC5_SNORM_BLOCK
  ** ename:VK_FORMAT_BC6H_UFLOAT_BLOCK
  ** ename:VK_FORMAT_BC6H_SFLOAT_BLOCK
  ** ename:VK_FORMAT_BC7_UNORM_BLOCK
  ** ename:VK_FORMAT_BC7_SRGB_BLOCK
+
To query for additional properties, or if the feature is not enabled,
flink:vkGetPhysicalDeviceFormatProperties and
flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
supported properties of individual formats as normal.

  * [[features-occlusionQueryPrecise]] pname:occlusionQueryPrecise specifies
    whether occlusion queries returning actual sample counts are supported.
    Occlusion queries are created in a sname:VkQueryPool by specifying the
    pname:queryType of ename:VK_QUERY_TYPE_OCCLUSION in the
    sname:VkQueryPoolCreateInfo structure which is passed to
    fname:vkCreateQueryPool.
    If this feature is enabled, queries of this type can: enable
    ename:VK_QUERY_CONTROL_PRECISE_BIT in the pname:flags parameter to
    fname:vkCmdBeginQuery.
    If this feature is not supported, the implementation supports only
    boolean occlusion queries.
    When any samples are passed, boolean queries will return a non-zero
    result value, otherwise a result value of zero is returned.
    When this feature is enabled and ename:VK_QUERY_CONTROL_PRECISE_BIT is
    set, occlusion queries will report the actual number of samples passed.
  * [[features-pipelineStatisticsQuery]] pname:pipelineStatisticsQuery
    specifies whether the pipeline statistics queries are supported.
    If this feature is not enabled, queries of type
    ename:VK_QUERY_TYPE_PIPELINE_STATISTICS cannot: be created, and none of
    the elink:VkQueryPipelineStatisticFlagBits bits can: be set in the
    pname:pipelineStatistics member of the sname:VkQueryPoolCreateInfo
    structure.
  * [[features-vertexPipelineStoresAndAtomics]]
    pname:vertexPipelineStoresAndAtomics specifies whether storage buffers
    and images support stores and atomic operations in the vertex,
    tessellation, and geometry shader stages.
    If this feature is not enabled, all storage image, storage texel
    buffers, and storage buffer variables used by these stages in shader
    modules must: be decorated with the code:NonWritable decoration (or the
    code:readonly memory qualifier in GLSL).
  * [[features-fragmentStoresAndAtomics]] pname:fragmentStoresAndAtomics
    specifies whether storage buffers and images support stores and atomic
    operations in the fragment shader stage.
    If this feature is not enabled, all storage image, storage texel
    buffers, and storage buffer variables used by the fragment stage in
    shader modules must: be decorated with the code:NonWritable decoration
    (or the code:readonly memory qualifier in GLSL).
  * [[features-shaderTessellationAndGeometryPointSize]]
    pname:shaderTessellationAndGeometryPointSize specifies whether the
    code:PointSize built-in decoration is available in the tessellation
    control, tessellation evaluation, and geometry shader stages.
    If this feature is not enabled, members decorated with the
    code:PointSize built-in decoration must: not be read from or written to
    and all points written from a tessellation or geometry shader will have
    a size of 1.0.
    This also specifies whether shader modules can: declare the
    code:TessellationPointSize capability for tessellation control and
    evaluation shaders, or if the shader modules can: declare the
    code:GeometryPointSize capability for geometry shaders.
    An implementation supporting this feature must: also support one or both
    of the <<features-tessellationShader,pname:tessellationShader>> or
    <<features-geometryShader,pname:geometryShader>> features.
  * [[features-shaderImageGatherExtended]] pname:shaderImageGatherExtended
    specifies whether the extended set of image gather instructions are
    available in shader code.
    If this feature is not enabled, the code:OpImage*code:Gather
    instructions do not support the code:Offset and code:ConstOffsets
    operands.
    This also specifies whether shader modules can: declare the
    code:ImageGatherExtended capability.
  * [[features-shaderStorageImageExtendedFormats]]
    pname:shaderStorageImageExtendedFormats specifies whether all the
    extended storage image formats are available in shader code.
    If this feature is enabled then the
    ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT feature must: be supported in
    pname:optimalTilingFeatures for all of the extended formats.
    To query for additional properties, or if the feature is not enabled,
    flink:vkGetPhysicalDeviceFormatProperties and
    flink:vkGetPhysicalDeviceImageFormatProperties can: be used to check for
    supported properties of individual formats as normal.
  * [[features-shaderStorageImageMultisample]]
    pname:shaderStorageImageMultisample specifies whether multisampled
    storage images are supported.
    If this feature is not enabled, images that are created with a
    pname:usage that includes ename:VK_IMAGE_USAGE_STORAGE_BIT must: be
    created with pname:samples equal to ename:VK_SAMPLE_COUNT_1_BIT.
    This also specifies whether shader modules can: declare the
    code:StorageImageMultisample capability.
  * [[features-shaderStorageImageReadWithoutFormat]]
    pname:shaderStorageImageReadWithoutFormat specifies whether storage
    images require a format qualifier to be specified when reading from
    storage images.
    If this feature is not enabled, the code:OpImageRead instruction must:
    not have an code:OpTypeImage of code:Unknown.
    This also specifies whether shader modules can: declare the
    code:StorageImageReadWithoutFormat capability.
  * [[features-shaderStorageImageWriteWithoutFormat]]
    pname:shaderStorageImageWriteWithoutFormat specifies whether storage
    images require a format qualifier to be specified when writing to
    storage images.
    If this feature is not enabled, the code:OpImageWrite instruction must:
    not have an code:OpTypeImage of code:Unknown.
    This also specifies whether shader modules can: declare the
    code:StorageImageWriteWithoutFormat capability.
  * [[features-shaderUniformBufferArrayDynamicIndexing]]
    pname:shaderUniformBufferArrayDynamicIndexing specifies whether arrays
    of uniform buffers can: be indexed by _dynamically uniform_ integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also specifies whether shader modules can: declare the
    code:UniformBufferArrayDynamicIndexing capability.
  * [[features-shaderSampledImageArrayDynamicIndexing]]
    pname:shaderSampledImageArrayDynamicIndexing specifies whether arrays of
    samplers or sampled images can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must: be indexed only by constant
    integral expressions when aggregated into arrays in shader code.
    This also specifies whether shader modules can: declare the
    code:SampledImageArrayDynamicIndexing capability.
  * [[features-shaderStorageBufferArrayDynamicIndexing]]
    pname:shaderStorageBufferArrayDynamicIndexing specifies whether arrays
    of storage buffers can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also specifies whether shader modules can: declare the
    code:StorageBufferArrayDynamicIndexing capability.
  * [[features-shaderStorageImageArrayDynamicIndexing]]
    pname:shaderStorageImageArrayDynamicIndexing specifies whether arrays of
    storage images can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must: be indexed only by constant
    integral expressions when aggregated into arrays in shader code.
    This also specifies whether shader modules can: declare the
    code:StorageImageArrayDynamicIndexing capability.
  * [[features-shaderClipDistance]] pname:shaderClipDistance specifies
    whether clip distances are supported in shader code.
    If this feature is not enabled, any members decorated with the
    code:ClipDistance built-in decoration must: not be read from or written
    to in shader modules.
    This also specifies whether shader modules can: declare the
    code:ClipDistance capability.
  * [[features-shaderCullDistance]] pname:shaderCullDistance specifies
    whether cull distances are supported in shader code.
    If this feature is not enabled, any members decorated with the
    code:CullDistance built-in decoration must: not be read from or written
    to in shader modules.
    This also specifies whether shader modules can: declare the
    code:CullDistance capability.
  * [[features-shaderFloat64]] pname:shaderFloat64 specifies whether 64-bit
    floats (doubles) are supported in shader code.
    If this feature is not enabled, 64-bit floating-point types must: not be
    used in shader code.
    This also specifies whether shader modules can: declare the code:Float64
    capability.
  * [[features-shaderInt64]] pname:shaderInt64 specifies whether 64-bit
    integers (signed and unsigned) are supported in shader code.
    If this feature is not enabled, 64-bit integer types must: not be used
    in shader code.
    This also specifies whether shader modules can: declare the code:Int64
    capability.
  * [[features-shaderInt16]] pname:shaderInt16 specifies whether 16-bit
    integers (signed and unsigned) are supported in shader code.
    If this feature is not enabled, 16-bit integer types must: not be used
    in shader code.
    This also specifies whether shader modules can: declare the code:Int16
    capability.
  * [[features-shaderResourceResidency]] pname:shaderResourceResidency
    specifies whether image operations that return resource residency
    information are supported in shader code.
    If this feature is not enabled, the code:OpImageSparse* instructions
    must: not be used in shader code.
    This also specifies whether shader modules can: declare the
    code:SparseResidency capability.
    The feature requires at least one of the ptext:sparseResidency* features
    to be supported.
  * [[features-shaderResourceMinLod]] pname:shaderResourceMinLod specifies
    whether image operations that specify the minimum resource LOD are
    supported in shader code.
    If this feature is not enabled, the code:MinLod image operand must: not
    be used in shader code.
    This also specifies whether shader modules can: declare the code:MinLod
    capability.
  * [[features-sparseBinding]] pname:sparseBinding specifies whether
    resource memory can: be managed at opaque sparse block level instead of
    at the object level.
    If this feature is not enabled, resource memory must: be bound only on a
    per-object basis using the fname:vkBindBufferMemory and
    fname:vkBindImageMemory commands.
    In this case, buffers and images must: not be created with
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT and
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in the pname:flags member
    of the sname:VkBufferCreateInfo and sname:VkImageCreateInfo structures,
    respectively.
    Otherwise resource memory can: be managed as described in
    <<sparsememory-sparseresourcefeatures,Sparse Resource Features>>.
  * [[features-sparseResidencyBuffer]] pname:sparseResidencyBuffer specifies
    whether the device can: access partially resident buffers.
    If this feature is not enabled, buffers must: not be created with
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags
    member of the sname:VkBufferCreateInfo structure.
  * [[features-sparseResidencyImage2D]] pname:sparseResidencyImage2D
    specifies whether the device can: access partially resident 2D images
    with 1 sample per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_1_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-sparseResidencyImage3D]] pname:sparseResidencyImage3D
    specifies whether the device can: access partially resident 3D images.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_3D must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-sparseResidency2Samples]] pname:sparseResidency2Samples
    specifies whether the physical device can: access partially resident 2D
    images with 2 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_2_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-sparseResidency4Samples]] pname:sparseResidency4Samples
    specifies whether the physical device can: access partially resident 2D
    images with 4 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_4_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-sparseResidency8Samples]] pname:sparseResidency8Samples
    specifies whether the physical device can: access partially resident 2D
    images with 8 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_8_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-sparseResidency16Samples]] pname:sparseResidency16Samples
    specifies whether the physical device can: access partially resident 2D
    images with 16 samples per pixel.
    If this feature is not enabled, images with an pname:imageType of
    ename:VK_IMAGE_TYPE_2D and pname:samples set to
    ename:VK_SAMPLE_COUNT_16_BIT must: not be created with
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member
    of the sname:VkImageCreateInfo structure.
  * [[features-sparseResidencyAliased]] pname:sparseResidencyAliased
    specifies whether the physical device can: correctly access data aliased
    into multiple locations.
    If this feature is not enabled, the
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT and
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT enum values must: not be used
    in pname:flags members of the sname:VkBufferCreateInfo and
    sname:VkImageCreateInfo structures, respectively.
  * [[features-variableMultisampleRate]] pname:variableMultisampleRate
    specifies whether all pipelines that will be bound to a command buffer
    during a subpass with no attachments must: have the same value for
    sname:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples.
    If set to ename:VK_TRUE, the implementation supports variable
    multisample rates in a subpass with no attachments.
    If set to ename:VK_FALSE, then all pipelines bound in such a subpass
    must: have the same multisample rate.
    This has no effect in situations where a subpass uses any attachments.
  * [[features-inheritedQueries]] pname:inheritedQueries specifies whether a
    secondary command buffer may: be executed while a query is active.

include::../validity/structs/VkPhysicalDeviceFeatures.txt[]
--

ifdef::VK_VERSION_1_1,VK_KHR_variable_pointers[]

[open,refpage='VkPhysicalDeviceVariablePointerFeatures',desc='Structure describing variable pointers features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceVariablePointerFeatures structure is defined as:

include::../api/structs/VkPhysicalDeviceVariablePointerFeatures.txt[]

ifdef::VK_KHR_variable_pointers[]
or the equivalent

include::../api/structs/VkPhysicalDeviceVariablePointerFeaturesKHR.txt[]
endif::VK_KHR_variable_pointers[]

The members of the sname:VkPhysicalDeviceVariablePointerFeatures structure
describe the following features:

  * [[features-variablePointersStorageBuffer]]
    pname:variablePointersStorageBuffer specifies whether the implementation
    supports the SPIR-V `VariablePointersStorageBuffer` capability.
    When this feature is not enabled, shader modules must: not declare the
    `SPV_KHR_variable_pointers` extension or the
    `VariablePointersStorageBuffer` capability.
  * [[features-variablePointers]] pname:variablePointers specifies whether
    the implementation supports the SPIR-V `VariablePointers` capability.
    When this feature is not enabled, shader modules must: not declare the
    `VariablePointers` capability.

If the sname:VkPhysicalDeviceVariablePointerFeatures structure is included
in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled
with values indicating whether each feature is supported.
sname:VkPhysicalDeviceVariablePointerFeatures can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceVariablePointerFeatures-variablePointers-01431]]
    If pname:variablePointers is enabled then
    pname:variablePointersStorageBuffer must: also be enabled.
****

include::../validity/structs/VkPhysicalDeviceVariablePointerFeatures.txt[]
--

endif::VK_VERSION_1_1,VK_KHR_variable_pointers[]

ifdef::VK_VERSION_1_1,VK_KHR_multiview[]

[open,refpage='VkPhysicalDeviceMultiviewFeatures',desc='Structure describing multiview features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMultiviewFeatures structure is defined as:

include::../api/structs/VkPhysicalDeviceMultiviewFeatures.txt[]

ifdef::VK_KHR_multiview[]
or the equivalent

include::../api/structs/VkPhysicalDeviceMultiviewFeaturesKHR.txt[]
endif::VK_KHR_multiview[]

The members of the sname:VkPhysicalDeviceMultiviewFeatures structure
describe the following features:

  * [[features-multiview]] pname:multiview specifies whether the
    implementation supports multiview rendering within a render pass.
    If this feature is not enabled, the view mask of each subpass must:
    always be zero.
  * [[features-multiview-gs]] pname:multiviewGeometryShader specifies
    whether the implementation supports multiview rendering within a render
    pass, with <<geometry,geometry shaders>>.
    If this feature is not enabled, then a pipeline compiled against a
    subpass with a non-zero view mask must: not include a geometry shader.
  * [[features-multiview-tess]] pname:multiviewTessellationShader specifies
    whether the implementation supports multiview rendering within a render
    pass, with <<tessellation,tessellation shaders>>.
    If this feature is not enabled, then a pipeline compiled against a
    subpass with a non-zero view mask must: not include any tessellation
    shaders.

If the sname:VkPhysicalDeviceMultiviewFeatures structure is included in the
pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled with
values indicating whether each feature is supported.
sname:VkPhysicalDeviceMultiviewFeatures can: also be used in the pname:pNext
chain of slink:VkDeviceCreateInfo to enable the features.

.Valid Usage
****
  * [[VUID-VkPhysicalDeviceMultiviewFeatures-multiviewGeometryShader-00580]]
    If pname:multiviewGeometryShader is enabled then pname:multiview must:
    also be enabled.
  * [[VUID-VkPhysicalDeviceMultiviewFeatures-multiviewTessellationShader-00581]]
    If pname:multiviewTessellationShader is enabled then pname:multiview
    must: also be enabled.
****

include::../validity/structs/VkPhysicalDeviceMultiviewFeatures.txt[]
--

endif::VK_VERSION_1_1,VK_KHR_multiview[]

ifdef::VK_KHR_shader_atomic_int64[]
[open,refpage='VkPhysicalDeviceShaderAtomicInt64FeaturesKHR',desc='Structure describing features supported by VK_KHR_shader_atomic_int64',type='structs']
--
To query 64-bit atomic support for signed and unsigned integers call
flink:vkGetPhysicalDeviceFeatures2 with a
sname:VkPhysicalDeviceShaderAtomicInt64FeaturesKHR structure included in the
pname:pNext chain of its pname:pFeatures parameter.

The slink:VkPhysicalDeviceShaderAtomicInt64FeaturesKHR structure is defined
as:

include::../api/structs/VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * [[features-shaderBufferInt64Atomics]] pname:shaderBufferInt64Atomics
    indicates whether shaders can: support 64-bit unsigned and signed
    integer atomic operations on buffers.
  * [[features-shaderSharedInt64Atomics]] pname:shaderSharedInt64Atomics
    indicates whether shaders can: support 64-bit unsigned and signed
    integer atomic operations on shared memory.

include::../validity/structs/VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.txt[]
--
endif::VK_KHR_shader_atomic_int64[]

ifdef::VK_KHR_8bit_storage[]
[open,refpage='VkPhysicalDevice8BitStorageFeaturesKHR',desc='Structure describing features supported by VK_KHR_8bit_storage',type='structs']
--
To query 8-bit storage features additionally supported call
flink:vkGetPhysicalDeviceFeatures2 with a
sname:VkPhysicalDevice8BitStorageFeaturesKHR structure included in the
pname:pNext chain of its pname:pFeatures parameter.
The sname:VkPhysicalDevice8BitStorageFeaturesKHR structure can: also be in
the pname:pNext chain of a slink:VkDeviceCreateInfo structure, in which case
it controls which additional features are enabled in the device.

The slink:VkPhysicalDevice8BitStorageFeaturesKHR structure is defined as:

include::../api/structs/VkPhysicalDevice8BitStorageFeaturesKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * [[features-storageBuffer8BitAccess]] pname:storageBuffer8BitAccess
    indicates whether objects in the code:StorageBuffer
ifdef::VK_EXT_buffer_device_address[]
    or code:PhysicalStorageBufferEXT
endif::VK_EXT_buffer_device_address[]
    storage class with the code:Block decoration can: have 8-bit integer
    members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:StorageBuffer8BitAccess capability.
  * [[features-uniformAndStorageBuffer8BitAccess]]
    pname:uniformAndStorageBuffer8BitAccess indicates whether objects in the
    code:Uniform storage class with the code:Block decoration and in the
    code:StorageBuffer
ifdef::VK_EXT_buffer_device_address[]
    or code:PhysicalStorageBufferEXT
endif::VK_EXT_buffer_device_address[]
    storage class with the same decoration can: have 8-bit integer members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:UniformAndStorageBuffer8BitAccess capability.
  * [[features-storagePushConstant8]] pname:storagePushConstant8 indicates
    whether objects in the code:PushConstant storage class can: have 8-bit
    integer members.
    If this feature is not enabled, 8-bit integer members must: not be used
    in such objects.
    This also indicates whether shader modules can: declare the
    code:StoragePushConstant8 capability.

include::../validity/structs/VkPhysicalDevice8BitStorageFeaturesKHR.txt[]
--
endif::VK_KHR_8bit_storage[]

ifdef::VK_VERSION_1_1,VK_KHR_16bit_storage[]
[open,refpage='VkPhysicalDevice16BitStorageFeatures',desc='Structure describing features supported by VK_KHR_16bit_storage',type='structs']
--
To query 16-bit storage features additionally supported call
flink:vkGetPhysicalDeviceFeatures2 with a
sname:VkPhysicalDevice16BitStorageFeatures structure included in the
pname:pNext chain of its pname:pFeatures parameter.
The sname:VkPhysicalDevice16BitStorageFeatures structure can: also be in the
pname:pNext chain of a slink:VkDeviceCreateInfo structure, in which case it
controls which additional features are enabled in the device.

The slink:VkPhysicalDevice16BitStorageFeatures structure is defined as:

include::../api/structs/VkPhysicalDevice16BitStorageFeatures.txt[]

ifdef::VK_KHR_16bit_storage[]
or the equivalent

include::../api/structs/VkPhysicalDevice16BitStorageFeaturesKHR.txt[]
endif::VK_KHR_16bit_storage[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * [[features-storageBuffer16BitAccess]] pname:storageBuffer16BitAccess
    specifies whether objects in the code:StorageBuffer
ifdef::VK_EXT_buffer_device_address[]
    or code:PhysicalStorageBufferEXT
endif::VK_EXT_buffer_device_address[]
    storage class with the code:Block decoration can: have 16-bit integer
    and 16-bit floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:StorageBuffer16BitAccess capability.
  * [[features-uniformAndStorageBuffer16BitAccess]]
    pname:uniformAndStorageBuffer16BitAccess specifies whether objects in
    the code:Uniform storage class with the code:Block decoration and in the
    code:StorageBuffer
ifdef::VK_EXT_buffer_device_address[]
    or code:PhysicalStorageBufferEXT
endif::VK_EXT_buffer_device_address[]
    storage class with the same decoration can: have 16-bit integer and
    16-bit floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:UniformAndStorageBuffer16BitAccess capability.
  * [[features-storagePushConstant16]] pname:storagePushConstant16 specifies
    whether objects in the code:PushConstant storage class can: have 16-bit
    integer and 16-bit floating-point members.
    If this feature is not enabled, 16-bit integer or floating-point members
    must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:StoragePushConstant16 capability.
  * [[features-storageInputOutput16]] pname:storageInputOutput16 specifies
    whether objects in the code:Input and code:Output storage classes can:
    have 16-bit integer and 16-bit floating-point members.
    If this feature is not enabled, 16-bit integer or 16-bit floating-point
    members must: not be used in such objects.
    This also specifies whether shader modules can: declare the
    code:StorageInputOutput16 capability.

include::../validity/structs/VkPhysicalDevice16BitStorageFeatures.txt[]
--
endif::VK_VERSION_1_1,VK_KHR_16bit_storage[]

ifdef::VK_KHR_shader_float16_int8[]
[open,refpage='VkPhysicalDeviceFloat16Int8FeaturesKHR',desc='Structure describing features supported by VK_KHR_shader_float16_int8',type='structs']
--
To query features additionally supported by the
`<<VK_KHR_shader_float16_int8>>` extension, call
flink:vkGetPhysicalDeviceFeatures2KHR with a
sname:VkPhysicalDeviceFloat16Int8FeaturesKHR structure in the pname:pNext
chain.
The sname:VkPhysicalDeviceFloat16Int8FeaturesKHR structure can: also be in
the pname:pNext chain of a slink:VkDeviceCreateInfo structure, in which case
it controls which additional features are enabled in the device.

The sname:VkPhysicalDeviceFloat16Int8FeaturesKHR structure is defined as:

include::../api/structs/VkPhysicalDeviceFloat16Int8FeaturesKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * [[features-shaderFloat16]] pname:shaderFloat16 indicates whether 16-bit
    floats (halfs) are supported in shader code.
    This also indicates whether shader modules can: declare the code:Float16
    capability.
  * [[features-shaderInt8]] pname:shaderInt8 indicates whether 8-bit
    integers (signed and unsigned) are supported in shader code.
    This also indicates whether shader modules can: declare the code:Int8
    capability.

include::../validity/structs/VkPhysicalDeviceFloat16Int8FeaturesKHR.txt[]
--
endif::VK_KHR_shader_float16_int8[]

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
[open,refpage='VkPhysicalDeviceSamplerYcbcrConversionFeatures',desc='Structure describing Y\'CbCr conversion features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceSamplerYcbcrConversionFeatures structure is
defined as:

include::../api/structs/VkPhysicalDeviceSamplerYcbcrConversionFeatures.txt[]

ifdef::VK_KHR_sampler_ycbcr_conversion[]
or the equivalent

include::../api/structs/VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.txt[]
endif::VK_KHR_sampler_ycbcr_conversion[]

The members of the sname:VkPhysicalDeviceSamplerYcbcrConversionFeatures
structure describe the following feature:

  * [[features-sampler-YCbCr-conversion]] pname:samplerYcbcrConversion
    specifies whether the implementation supports
    <<samplers-YCbCr-conversion,sampler Y'C~B~C~R~ conversion>>.
    If pname:samplerYcbcrConversion is ename:VK_FALSE, sampler Y'C~B~C~R~
    conversion is not supported, and samplers using sampler Y'C~B~C~R~
    conversion must: not be used.

include::../validity/structs/VkPhysicalDeviceSamplerYcbcrConversionFeatures.txt[]
--

endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

ifdef::VK_VERSION_1_1[]

[open,refpage='VkPhysicalDeviceProtectedMemoryFeatures',desc='Structure describing protected memory features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceProtectedMemoryFeatures structure is defined as:

include::../api/structs/VkPhysicalDeviceProtectedMemoryFeatures.txt[]

  * pname:protectedMemory specifies whether protected memory is supported.

If the sname:VkPhysicalDeviceProtectedMemoryFeatures structure is included
in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled
with a value indicating whether the feature is supported.

include::../validity/structs/VkPhysicalDeviceProtectedMemoryFeatures.txt[]
--

endif::VK_VERSION_1_1[]

ifdef::VK_EXT_blend_operation_advanced[]

[open,refpage='VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT',desc='Structure describing advanced blending features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure is
defined as:

include::../api/structs/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
structure describe the following features:

  * [[features-advancedBlendCoherentOperations]]
    pname:advancedBlendCoherentOperations specifies whether blending using
    <<framebuffer-blend-advanced,advanced blend operations>> is guaranteed
    to execute atomically and in <<drawing-primitive-order, primitive
    order>>.
    If this is ename:VK_TRUE,
    ename:VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT is treated the
    same as ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT, and advanced blending
    needs no additional synchronization over basic blending.
    If this is ename:VK_FALSE, then memory dependencies are required to
    guarantee order between two advanced blending operations that occur on
    the same sample.

If the sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT can: also be used in
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

include::../validity/structs/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.txt[]
--

endif::VK_EXT_blend_operation_advanced[]

ifdef::VK_EXT_conditional_rendering[]

[open,refpage='VkPhysicalDeviceConditionalRenderingFeaturesEXT',desc='Structure describing if a secondary command buffer can be executed if conditional rendering is active in the primary command buffer',type='structs']
--
The sname:VkPhysicalDeviceConditionalRenderingFeaturesEXT structure is
defined as:

include::../api/structs/VkPhysicalDeviceConditionalRenderingFeaturesEXT.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * [[features-conditionalRendering]] pname:conditionalRendering specifies
    whether conditional rendering is supported.
  * [[features-inheritedConditionalRendering]]
    pname:inheritedConditionalRendering specifies whether a secondary
    command buffer can: be executed while conditional rendering is active in
    the primary command buffer.

If the sname:VkPhysicalDeviceConditionalRenderingFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating the implementation-dependent behavior.
sname:VkPhysicalDeviceConditionalRenderingFeaturesEXT can: also be used in
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

include::../validity/structs/VkPhysicalDeviceConditionalRenderingFeaturesEXT.txt[]
--

endif::VK_EXT_conditional_rendering[]

ifdef::VK_VERSION_1_1[]
[open,refpage='VkPhysicalDeviceShaderDrawParameterFeatures',desc='Structure describing shader draw parameter features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderDrawParameterFeatures structure is defined
as:

include::../api/structs/VkPhysicalDeviceShaderDrawParameterFeatures.txt[]

  * [[features-shaderDrawParameters]] pname:shaderDrawParameters specifies
    whether shader draw parameters are supported.

If the sname:VkPhysicalDeviceShaderDrawParameterFeatures structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with a value indicating whether the feature is supported.

include::../validity/structs/VkPhysicalDeviceShaderDrawParameterFeatures.txt[]
--
endif::VK_VERSION_1_1[]

ifdef::VK_NV_mesh_shader[]
[open,refpage='VkPhysicalDeviceMeshShaderFeaturesNV',desc='Structure describing mesh shading features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMeshShaderFeaturesNV structure is defined as:

include::../api/structs/VkPhysicalDeviceMeshShaderFeaturesNV.txt[]

  * [[features-taskShader]] pname:taskShader indicates whether the task
    shader stage is supported.
  * [[features-meshShader]] pname:meshShader indicates whether the mesh
    shader stage is supported.

If the sname:VkPhysicalDeviceMeshShaderFeaturesNV structure is included in
the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is filled with
a value indicating whether the feature is supported.
sname:VkPhysicalDeviceMeshShaderFeaturesNV can: also be used in pname:pNext
chain of slink:VkDeviceCreateInfo to enable the features.

include::../validity/structs/VkPhysicalDeviceMeshShaderFeaturesNV.txt[]
--
endif::VK_NV_mesh_shader[]

ifdef::VK_EXT_descriptor_indexing[]

[open,refpage='VkPhysicalDeviceDescriptorIndexingFeaturesEXT',desc='Structure describing descriptor indexing features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDescriptorIndexingFeaturesEXT structure is defined
as:

include::../api/structs/VkPhysicalDeviceDescriptorIndexingFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceDescriptorIndexingFeaturesEXT
structure describe the following features:

  * [[features-shaderInputAttachmentArrayDynamicIndexing]]
    pname:shaderInputAttachmentArrayDynamicIndexing indicates whether arrays
    of input attachments can: be indexed by dynamically uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:InputAttachmentArrayDynamicIndexingEXT capability.
  * [[features-shaderUniformTexelBufferArrayDynamicIndexing]]
    pname:shaderUniformTexelBufferArrayDynamicIndexing indicates whether
    arrays of uniform texel buffers can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformTexelBufferArrayDynamicIndexingEXT capability.
  * [[features-shaderStorageTexelBufferArrayDynamicIndexing]]
    pname:shaderStorageTexelBufferArrayDynamicIndexing indicates whether
    arrays of storage texel buffers can: be indexed by dynamically uniform
    integer expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must: be indexed only by
    constant integral expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageTexelBufferArrayDynamicIndexingEXT capability.
  * [[features-shaderUniformBufferArrayNonUniformIndexing]]
    pname:shaderUniformBufferArrayNonUniformIndexing indicates whether
    arrays of uniform buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformBufferArrayNonUniformIndexingEXT capability.
  * [[features-shaderSampledImageArrayNonUniformIndexing]]
    pname:shaderSampledImageArrayNonUniformIndexing indicates whether arrays
    of samplers or sampled images can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:SampledImageArrayNonUniformIndexingEXT capability.
  * [[features-shaderStorageBufferArrayNonUniformIndexing]]
    pname:shaderStorageBufferArrayNonUniformIndexing indicates whether
    arrays of storage buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageBufferArrayNonUniformIndexingEXT capability.
  * [[features-shaderStorageImageArrayNonUniformIndexing]]
    pname:shaderStorageImageArrayNonUniformIndexing indicates whether arrays
    of storage images can: be indexed by non-uniform integer expressions in
    shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageImageArrayNonUniformIndexingEXT capability.
  * [[features-shaderInputAttachmentArrayNonUniformIndexing]]
    pname:shaderInputAttachmentArrayNonUniformIndexing indicates whether
    arrays of input attachments can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:InputAttachmentArrayNonUniformIndexingEXT capability.
  * [[features-shaderUniformTexelBufferArrayNonUniformIndexing]]
    pname:shaderUniformTexelBufferArrayNonUniformIndexing indicates whether
    arrays of uniform texel buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:UniformTexelBufferArrayNonUniformIndexingEXT capability.
  * [[features-shaderStorageTexelBufferArrayNonUniformIndexing]]
    pname:shaderStorageTexelBufferArrayNonUniformIndexing indicates whether
    arrays of storage texel buffers can: be indexed by non-uniform integer
    expressions in shader code.
    If this feature is not enabled, resources with a descriptor type of
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must: not be indexed by
    non-uniform integer expressions when aggregated into arrays in shader
    code.
    This also indicates whether shader modules can: declare the
    code:StorageTexelBufferArrayNonUniformIndexingEXT capability.
  * [[features-descriptorBindingUniformBufferUpdateAfterBind]]
    pname:descriptorBindingUniformBufferUpdateAfterBind indicates whether
    the implementation supports updating uniform buffer descriptors after a
    set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must: not be used
    with ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER.
  * [[features-descriptorBindingSampledImageUpdateAfterBind]]
    pname:descriptorBindingSampledImageUpdateAfterBind indicates whether the
    implementation supports updating sampled image descriptors after a set
    is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must: not be used
    with ename:VK_DESCRIPTOR_TYPE_SAMPLER,
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE.
  * [[features-descriptorBindingStorageImageUpdateAfterBind]]
    pname:descriptorBindingStorageImageUpdateAfterBind indicates whether the
    implementation supports updating storage image descriptors after a set
    is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must: not be used
    with ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.
  * [[features-descriptorBindingStorageBufferUpdateAfterBind]]
    pname:descriptorBindingStorageBufferUpdateAfterBind indicates whether
    the implementation supports updating storage buffer descriptors after a
    set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must: not be used
    with ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER.
  * [[features-descriptorBindingUniformTexelBufferUpdateAfterBind]]
    pname:descriptorBindingUniformTexelBufferUpdateAfterBind indicates
    whether the implementation supports updating uniform texel buffer
    descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must: not be used
    with ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.
  * [[features-descriptorBindingStorageTexelBufferUpdateAfterBind]]
    pname:descriptorBindingStorageTexelBufferUpdateAfterBind indicates
    whether the implementation supports updating storage texel buffer
    descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must: not be used
    with ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.
  * [[features-descriptorBindingUpdateUnusedWhilePending]]
    pname:descriptorBindingUpdateUnusedWhilePending indicates whether the
    implementation supports updating descriptors while the set is in use.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT must:
    not be used.
  * [[features-descriptorBindingPartiallyBound]]
    pname:descriptorBindingPartiallyBound indicates whether the
    implementation supports statically using a descriptor set binding in
    which some descriptors are not valid.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT must: not be used.
  * [[features-descriptorBindingVariableDescriptorCount]]
    pname:descriptorBindingVariableDescriptorCount indicates whether the
    implementation supports descriptor sets with a variable-sized last
    binding.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT must: not
    be used.
  * [[features-runtimeDescriptorArray]] pname:runtimeDescriptorArray
    indicates whether the implementation supports the SPIR-V
    code:RuntimeDescriptorArrayEXT capability.
    If this feature is not enabled, descriptors must: not be declared in
    runtime arrays.

If the sname:VkPhysicalDeviceDescriptorIndexingFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it
is filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceDescriptorIndexingFeaturesEXT can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::../validity/structs/VkPhysicalDeviceDescriptorIndexingFeaturesEXT.txt[]
--

endif::VK_EXT_descriptor_indexing[]

ifdef::VK_EXT_vertex_attribute_divisor[]

[open,refpage='VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT',desc='Structure describing if fetching of vertex attribute may be repeated for instanced rendering',type='structs']
--
The sname:VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT structure is
defined as:

include::../api/structs/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * [[features-vertexAttributeInstanceRateDivisor]]
    pname:vertexAttributeInstanceRateDivisor specifies whether vertex
    attribute fetching may be repeated in case of instanced rendering.
  * [[features-vertexAttributeInstanceRateZeroDivisor]]
    pname:vertexAttributeInstanceRateZeroDivisor specifies whether a zero
    value for sname:VkVertexInputBindingDivisorDescriptionEXT::pname:divisor
    is supported.

If the sname:VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating the implementation-dependent behavior.
sname:VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT can: also be used in
pname:pNext chain of slink:VkDeviceCreateInfo to enable the feature.

include::../validity/structs/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.txt[]
--

endif::VK_EXT_vertex_attribute_divisor[]

ifdef::VK_EXT_astc_decode_mode[]

[open,refpage='VkPhysicalDeviceASTCDecodeFeaturesEXT',desc='Structure describing ASTC decode mode features',type='structs']
--
The sname:VkPhysicalDeviceASTCDecodeFeaturesEXT structure is defined as:

include::../api/structs/VkPhysicalDeviceASTCDecodeFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceASTCDecodeFeaturesEXT structure
describe the following features:

  * [[features-astc-decodeModeSharedExponent]]
    pname:decodeModeSharedExponent indicates whether the implementation
    supports decoding ASTC compressed formats to
    ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 internal precision.

If the sname:VkPhysicalDeviceASTCDecodeFeaturesEXT structure is included in
the pname:pNext chain of flink:vkGetPhysicalDeviceFeatures2KHR, it is filled
with values indicating whether each feature is supported.
sname:VkPhysicalDeviceASTCDecodeFeaturesEXT can: also be used in the
pname:pNext chain of flink:vkCreateDevice to enable features.

include::../validity/structs/VkPhysicalDeviceASTCDecodeFeaturesEXT.txt[]
--

endif::VK_EXT_astc_decode_mode[]

ifdef::VK_EXT_transform_feedback[]

[open,refpage='VkPhysicalDeviceTransformFeedbackFeaturesEXT',desc='Structure describing transform feedback features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT structure is defined
as:

include::../api/structs/VkPhysicalDeviceTransformFeedbackFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT
structure describe the following features:

  * [[features-transformFeedback]] pname:transformFeedback indicates whether
    the implementation supports transform feedback and shader modules can:
    declare the code:TransformFeedback capability.

  * [[features-geometryStreams]] pname:geometryStreams indicates whether the
    implementation supports the code:GeometryStreams SPIR-V capability.

If the sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it
is filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::../validity/structs/VkPhysicalDeviceTransformFeedbackFeaturesEXT.txt[]
--

endif::VK_EXT_transform_feedback[]

ifdef::VK_KHR_vulkan_memory_model[]
[open,refpage='VkPhysicalDeviceVulkanMemoryModelFeaturesKHR',desc='Structure describing features supported by VK_KHR_vulkan_memory_model',type='structs']
--
To query memory model features additionally supported call
flink:vkGetPhysicalDeviceFeatures2 with a
sname:VkPhysicalDeviceVulkanMemoryModelFeaturesKHR structure included in the
pname:pNext chain of its pname:pFeatures parameter.
The sname:VkPhysicalDeviceVulkanMemoryModelFeaturesKHR structure can: also
be in the pname:pNext chain of a slink:VkDeviceCreateInfo structure, in
which case it controls which additional features are enabled in the device.

The slink:VkPhysicalDeviceVulkanMemoryModelFeaturesKHR structure is defined
as:

include::../api/structs/VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * [[features-vulkanMemoryModel]] pname:vulkanMemoryModel indicates whether
    the Vulkan Memory Model is supported, as defined in
    <<memory-model,Vulkan Memory Model>>.
    This also indicates whether shader modules can: declare the
    code:VulkanMemoryModelKHR capability.
  * [[features-vulkanMemoryModelDeviceScope]]
    pname:vulkanMemoryModelDeviceScope indicates whether the Vulkan Memory
    Model can use code:Device scope synchronization.
    This also indicates whether shader modules can: declare the
    code:VulkanMemoryModelDeviceScopeKHR capability.
  * [[features-vulkanMemoryModelAvailabilityVisibilityChains]]
    pname:vulkanMemoryModelAvailabilityVisibilityChains indicates whether
    the Vulkan Memory Model can use <<memory-model-availability-visibility,
    availability and visibility chains>> with more than one element.

include::../validity/structs/VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.txt[]
--
endif::VK_KHR_vulkan_memory_model[]

ifdef::VK_EXT_inline_uniform_block[]

[open,refpage='VkPhysicalDeviceInlineUniformBlockFeaturesEXT',desc='Structure describing inline uniform block features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceInlineUniformBlockFeaturesEXT structure is defined
as:

include::../api/structs/VkPhysicalDeviceInlineUniformBlockFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceInlineUniformBlockFeaturesEXT
structure describe the following features:

  * [[features-inlineUniformBlock]] pname:inlineUniformBlock indicates
    whether the implementation supports inline uniform block descriptors.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT must: not be used.
  * [[features-descriptorBindingInlineUniformBlockUpdateAfterBind]]
    pname:descriptorBindingInlineUniformBlockUpdateAfterBind
ifndef::VK_EXT_descriptor_indexing[]
    is ename:VK_FALSE and reserved for future use.
endif::VK_EXT_descriptor_indexing[]
ifdef::VK_EXT_descriptor_indexing[]
    indicates whether the implementation supports updating inline uniform
    block descriptors after a set is bound.
    If this feature is not enabled,
    ename:VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must: not be used
    with ename:VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT.
endif::VK_EXT_descriptor_indexing[]

If the sname:VkPhysicalDeviceInlineUniformBlockFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceInlineUniformBlockFeaturesEXT can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::../validity/structs/VkPhysicalDeviceInlineUniformBlockFeaturesEXT.txt[]
--

endif::VK_EXT_inline_uniform_block[]

ifdef::VK_NV_representative_fragment_test[]
[open,refpage='VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV',desc='Structure describing the representative fragment test features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure is
defined as:

include::../api/structs/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.txt[]

The members of the
sname:VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure
describe the following features:

  * [[features-representativeFragmentTest]] pname:representativeFragmentTest
    indicates whether the implementation supports the representative
    fragment test.
    See <<fragops-rep-frag-test, Representative Fragment Test>>.

If the sname:VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure
is included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR,
it is filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV can: also be used
in the pname:pNext chain of slink:VkDeviceCreateInfo to enable the feature.

include::../validity/structs/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.txt[]
--
endif::VK_NV_representative_fragment_test[]

ifdef::VK_NV_scissor_exclusive[]

[open,refpage='VkPhysicalDeviceExclusiveScissorFeaturesNV',desc='Structure describing exclusive scissor features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceExclusiveScissorFeaturesNV structure is defined
as:

include::../api/structs/VkPhysicalDeviceExclusiveScissorFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceExclusiveScissorFeaturesNV
structure describe the following features:

  * [[features-exclusiveScissor]] pname:exclusiveScissor indicates that the
    implementation supports the exclusive scissor test.

See <<fragops-exclusive-scissor,Exclusive Scissor Test>> for more
information.

If the sname:VkPhysicalDeviceExclusiveScissorFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it
is filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceExclusiveScissorFeaturesNV can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable the feature.

include::../validity/structs/VkPhysicalDeviceExclusiveScissorFeaturesNV.txt[]
--
endif::VK_NV_scissor_exclusive[]

ifdef::VK_NV_corner_sampled_image[]

[open,refpage='VkPhysicalDeviceCornerSampledImageFeaturesNV',desc='Structure describing corner sampled image features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCornerSampledImageFeaturesNV structure is defined
as:

include::../api/structs/VkPhysicalDeviceCornerSampledImageFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceCornerSampledImageFeaturesNV
structure describe the following features:

  * [[features-cornersampledimage]] pname:cornerSampledImage specifies
    whether images can be created with a
    slink:VkImageCreateInfo::pname:flags containing
    ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV.
    See <<resources-images-corner-sampled,Corner-Sampled Images>>.

If the sname:VkPhysicalDeviceCornerSampledImageFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it
is filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceCornerSampledImageFeaturesNV can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::../validity/structs/VkPhysicalDeviceCornerSampledImageFeaturesNV.txt[]
--

endif::VK_NV_corner_sampled_image[]

ifdef::VK_NV_compute_shader_derivatives[]

[open,refpage='VkPhysicalDeviceComputeShaderDerivativesFeaturesNV',desc='Structure describing compute shader derivative features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceComputeShaderDerivativesFeaturesNV structure is
defined as:

include::../api/structs/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceComputeShaderDerivativesFeaturesNV
structure describe the following features:

  * [[features-computeShaderDerivativesQuads]]
    pname:computeDerivativeGroupQuads indicates that the implementation
    supports the code:ComputeDerivativeGroupQuadsNV SPIR-V capability.
  * [[features-computeShaderDerivativesLinear]]
    pname:computeDerivativeGroupLinear indicates that the implementation
    supports the code:ComputeDerivativeGroupLinearNV SPIR-V capability.

See <<texture-derivatives-compute,Compute Shader Derivatives>> for more
information.

If the sname:VkPhysicalDeviceComputeShaderDerivativesFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it
is filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceComputeShaderDerivativesFeaturesNV can: also be used
in the pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::../validity/structs/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.txt[]
--

endif::VK_NV_compute_shader_derivatives[]

ifdef::VK_NV_fragment_shader_barycentric[]

[open,refpage='VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV',desc='Structure describing barycentric support in fragment shaders that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV structure is
defined as:

include::../api/structs/VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV
structure describe the following features:

  * [[features-fragmentShaderBarycentric]] pname:fragmentShaderBarycentric
    indicates that the implementation supports the code:BaryCoordNV and
    code:BaryCoordNoPerspNV SPIR-V fragment shader built-ins and supports
    the code:PerVertexNV SPIR-V decoration on fragment shader input
    variables.

See <<primsrast-barycentric,Barycentric Interpolation>> for more
information.

If the sname:VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV structure
is included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR,
it is filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV can: also be used
in the pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::../validity/structs/VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.txt[]
--

endif::VK_NV_fragment_shader_barycentric[]

ifdef::VK_NV_shader_image_footprint[]

[open,refpage='VkPhysicalDeviceShaderImageFootprintFeaturesNV',desc='Structure describing shader image footprint features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShaderImageFootprintFeaturesNV structure is
defined as:

include::../api/structs/VkPhysicalDeviceShaderImageFootprintFeaturesNV.txt[]

  * [[features-imageFootprint]] pname:imageFootprint specifies whether the
    implementation supports the code:ImageFootprintNV SPIR-V capability.

See <<textures-footprint,Texel Footprint Evaluation>> for more information.

If the sname:VkPhysicalDeviceShaderImageFootprintFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it
is filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceShaderImageFootprintFeaturesNV can: also be used in
the pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::../validity/structs/VkPhysicalDeviceShaderImageFootprintFeaturesNV.txt[]
--

endif::VK_NV_shader_image_footprint[]


ifdef::VK_NV_shading_rate_image[]

[open,refpage='VkPhysicalDeviceShadingRateImageFeaturesNV',desc='Structure describing shading rate image features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceShadingRateImageFeaturesNV structure is defined
as:

include::../api/structs/VkPhysicalDeviceShadingRateImageFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceShadingRateImageFeaturesNV
structure describe the following features:

  * [[features-shadingRateImage]] pname:shadingRateImage indicates that the
    implementation supports the use of a shading rate image to derive an
    effective shading rate for fragment processing.
    It also indicates that the implementation supports the
    code:ShadingRateNV SPIR-V execution mode.
  * [[features-shadingRateCoarseSampleOrder]]
    pname:shadingRateCoarseSampleOrder indicates that the implementation
    supports a user-configurable ordering of coverage samples in fragments
    larger than one pixel.

See <<primsrast-shading-rate-image, Shading Rate Image>> for more
information.

If the sname:VkPhysicalDeviceShadingRateImageFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it
is filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceShadingRateImageFeaturesNV can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::../validity/structs/VkPhysicalDeviceShadingRateImageFeaturesNV.txt[]
--

endif::VK_NV_shading_rate_image[]

ifdef::VK_EXT_fragment_density_map[]

[open,refpage='VkPhysicalDeviceFragmentDensityMapFeaturesEXT',desc='Structure describing fragment density map features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure is defined
as:

include::../api/structs/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceFragmentDensityMapFeaturesEXT
structure describe the following features:

  * [[features-fragmentdensitymap]] pname:fragmentDensityMap specifies
    whether the implementation supports render passes with a fragment
    density map attachment.
    If this feature is not enabled and the pname:pNext chain of
    sname:VkRenderPassCreateInfo contains
    sname:VkRenderPassFragmentDensityMapCreateInfoEXT,
    pname:fragmentDensityMapAttachment must: be ename:VK_ATTACHMENT_UNUSED.
  * [[features-fragmentdensitymapdynamic]] pname:fragmentDensityMapDynamic
    specifies whether the implementation supports dynamic fragment density
    map image views.
    If this feature is not enabled,
    ename:VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT must:
    not be included in sname:VkImageViewCreateInfo::pname:flags.
  * [[features-nonsubsampledimages]]
    pname:fragmentDensityMapNonSubsampledImages specifies whether the
    implementation supports regular non-subsampled image attachments with
    fragment density map render passes.
    If this feature is not enabled, render passes with a
    <<renderpass-fragmentdensitymapattachment,fragment density map
    attachment>> must: only have <<resources-subsampledimages,subsampled
    attachments>> bound.

If the sname:VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2, it is
filled with values indicating whether each feature is supported.
sname:VkPhysicalDeviceFragmentDensityMapFeaturesEXT can: also be used in
pname:pNext chain of slink:VkDeviceCreateInfo to enable the features.

include::../validity/structs/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.txt[]
--

endif::VK_EXT_fragment_density_map[]

ifdef::VK_EXT_scalar_block_layout[]

[open,refpage='VkPhysicalDeviceScalarBlockLayoutFeaturesEXT',desc='Structure indicating support for scalar block layouts',type='structs']
--
The sname:VkPhysicalDeviceScalarBlockLayoutFeaturesEXT structure is defined
as:

include::../api/structs/VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceScalarBlockLayoutFeaturesEXT
structure describe the following features:

  * [[features-scalarBlockLayout]] pname:scalarBlockLayout indicates that
    the implementation supports the layout of resource blocks in shaders
    using <<interfaces-scalar-block-layout, scalar alignment>>.

If the sname:VkPhysicalDeviceScalarBlockLayoutFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it
is filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceScalarBlockLayoutFeaturesEXT can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable this feature.

include::../validity/structs/VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.txt[]
--

endif::VK_EXT_scalar_block_layout[]

ifdef::VK_EXT_depth_clip_enable[]

[open,refpage='VkPhysicalDeviceDepthClipEnableFeaturesEXT',desc='Structure indicating support for explicit enable of depth clip',type='structs']
--
The sname:VkPhysicalDeviceDepthClipEnableFeaturesEXT structure is defined
as:

include::../api/structs/VkPhysicalDeviceDepthClipEnableFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceDepthClipEnableFeaturesEXT
structure describe the following features:

  * [[features-depthClipEnable]] pname:depthClipEnable indicates that the
    implementation supports setting the depth clipping operation explicitly
    via the slink:VkPipelineRasterizationDepthClipStateCreateInfoEXT
    pipeline state.
    Otherwise depth clipping is only enabled when
    sname:VkPipelineRasterizationStateCreateInfo::pname:depthClampEnable is
    set to ename:VK_FALSE.

If the sname:VkPhysicalDeviceDepthClipEnableFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it
is filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceDepthClipEnableFeaturesEXT can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable this feature.

include::../validity/structs/VkPhysicalDeviceDepthClipEnableFeaturesEXT.txt[]
--

endif::VK_EXT_depth_clip_enable[]

ifdef::VK_EXT_memory_priority[]

[open,refpage='VkPhysicalDeviceMemoryPriorityFeaturesEXT',desc='Structure describing memory priority features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceMemoryPriorityFeaturesEXT structure is defined as:

include::../api/structs/VkPhysicalDeviceMemoryPriorityFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceMemoryPriorityFeaturesEXT structure
describe the following features:

  * [[features-memoryPriority]] pname:memoryPriority indicates that the
    implementation supports memory priorities specified at memory allocation
    time via slink:VkMemoryPriorityAllocateInfoEXT.

If the sname:VkPhysicalDeviceMemoryPriorityFeaturesEXT structure is included
in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it is filled
with values indicating whether the feature is supported.
sname:VkPhysicalDeviceMemoryPriorityFeaturesEXT can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::../validity/structs/VkPhysicalDeviceMemoryPriorityFeaturesEXT.txt[]
--

endif::VK_EXT_memory_priority[]

ifdef::VK_EXT_buffer_device_address[]

[open,refpage='VkPhysicalDeviceBufferAddressFeaturesEXT',desc='Structure describing buffer address features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceBufferAddressFeaturesEXT structure is defined as:

include::../api/structs/VkPhysicalDeviceBufferAddressFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceBufferAddressFeaturesEXT structure
describe the following features:

  * [[features-bufferDeviceAddress]] pname:bufferDeviceAddress indicates
    that the implementation supports accessing buffer memory in shaders as
    storage buffers via an address queried from
    flink:vkGetBufferDeviceAddressEXT.
  * [[features-bufferDeviceAddressCaptureReplay]]
    pname:bufferDeviceAddressCaptureReplay indicates that the implementation
    supports saving and reusing buffer addresses, e.g. for trace capture and
    replay.
  * [[features-bufferDeviceAddressMultiDevice]]
    pname:bufferDeviceAddressMultiDevice indicates that the implementation
    supports the pname:bufferDeviceAddress feature for logical devices
    created with multiple physical devices.
    If this feature is not supported, buffer addresses must: not be queried
    on a logical device created with more than one physical device.

[NOTE]
.Note
====
pname:bufferDeviceAddressMultiDevice exists to allow certain legacy
platforms to be able to support pname:bufferDeviceAddress without needing to
support shared GPU virtual addresses for multi-device configurations.
====

See flink:vkGetBufferDeviceAddressEXT for more information.

If the sname:VkPhysicalDeviceBufferAddressFeaturesEXT structure is included
in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it is filled
with values indicating whether the feature is supported.
sname:VkPhysicalDeviceBufferAddressFeaturesEXT can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::../validity/structs/VkPhysicalDeviceBufferAddressFeaturesEXT.txt[]
--

endif::VK_EXT_buffer_device_address[]

ifdef::VK_NV_dedicated_allocation_image_aliasing[]

[open,refpage='VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV',desc='Structure describing dedicated allocation image aliasing features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
structure is defined as:

include::../api/structs/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.txt[]

The members of the
sname:VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV structure
describe the following features:

  * [[features-dedicatedAllocationImageAliasing]]
  pname:dedicatedAllocationImageAliasing indicates that the implementation
  supports aliasing of compatible image objects on a dedicated allocation.

If the sname:VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
structure is included in the pname:pNext chain of
slink:VkPhysicalDeviceFeatures2KHR, it is filled with values indicating
whether each feature is supported.
sname:VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV can: also
be used in the pname:pNext chain of slink:VkDeviceCreateInfo to enable
features.

include::../validity/structs/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.txt[]
--

endif::VK_NV_dedicated_allocation_image_aliasing[]

ifdef::VK_NV_cooperative_matrix[]

[open,refpage='VkPhysicalDeviceCooperativeMatrixFeaturesNV',desc='Structure describing cooperative matrix features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceCooperativeMatrixFeaturesNV structure is defined
as:

include::../api/structs/VkPhysicalDeviceCooperativeMatrixFeaturesNV.txt[]

The members of the sname:VkPhysicalDeviceCooperativeMatrixFeaturesNV
structure describe the following features:

  * [[features-cooperativeMatrix]] pname:cooperativeMatrix indicates that
    the implementation supports the code:CooperativeMatrixNV SPIR-V
    capability.
  * [[features-cooperativeMatrixRobustBufferAccess]]
    pname:cooperativeMatrixRobustBufferAccess indicates that the
    implementation supports robust buffer access for SPIR-V
    code:OpCooperativeMatrixLoadNV and code:OpCooperativeMatrixStoreNV
    instructions.

If the sname:VkPhysicalDeviceCooperativeMatrixFeaturesNV structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it
is filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceCooperativeMatrixFeaturesNV can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::../validity/structs/VkPhysicalDeviceCooperativeMatrixFeaturesNV.txt[]
--

endif::VK_NV_cooperative_matrix[]

ifdef::VK_EXT_ycbcr_image_arrays[]

[open,refpage='VkPhysicalDeviceYcbcrImageArraysFeaturesEXT',desc='Structure describing extended Y'C~B~C~R~ image creation features that can be supported by an implementation',type='structs']
--
The sname:VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure is defined
as:

include::../api/structs/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.txt[]

The members of the sname:VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
structure describe the following features:

  * [[features-ycbcrImageArrays]] pname:ycbcrImageArrays indicates that the
    implementation supports creating images with a format that requires
    <<formats-requiring-sampler-ycbcr-conversion, Y'C~B~C~R~ conversion>>
    and has multiple array layers.

If the sname:VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure is
included in the pname:pNext chain of slink:VkPhysicalDeviceFeatures2KHR, it
is filled with values indicating whether the feature is supported.
sname:VkPhysicalDeviceYcbcrImageArraysFeaturesEXT can: also be used in the
pname:pNext chain of slink:VkDeviceCreateInfo to enable features.

include::../validity/structs/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.txt[]
--

endif::VK_EXT_ycbcr_image_arrays[]


[[features-requirements]]
== Feature Requirements

All Vulkan graphics implementations must: support the following features:

  * <<features-robustBufferAccess, pname:robustBufferAccess>>
ifdef::VK_VERSION_1_1[]
  * <<features-multiview, pname:multiview>>
endif::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_1,VK_KHR_variable_pointers[]
  * <<features-variablePointersStorageBuffer,
    pname:variablePointersStorageBuffer>>, if the
    `<<VK_KHR_variable_pointers>>` extension is supported.
endif::VK_VERSION_1_1,VK_KHR_variable_pointers[]
ifdef::VK_KHR_8bit_storage[]
  * <<features-StorageBuffer8BitAccess, pname:storageBuffer8BitAccess>>, if
    the `<<VK_KHR_8bit_storage>>` extension is supported.
endif::VK_KHR_8bit_storage[]
ifdef::VK_EXT_descriptor_indexing[]
  * If the `<<VK_EXT_descriptor_indexing>>` extension is supported:
  ** <<features-shaderSampledImageArrayDynamicIndexing,
     pname:shaderSampledImageArrayDynamicIndexing>>
  ** <<features-shaderStorageBufferArrayDynamicIndexing,
     pname:shaderStorageBufferArrayDynamicIndexing>>
  ** <<features-shaderUniformTexelBufferArrayDynamicIndexing,
     pname:shaderUniformTexelBufferArrayDynamicIndexing>>
  ** <<features-shaderStorageTexelBufferArrayDynamicIndexing,
     pname:shaderStorageTexelBufferArrayDynamicIndexing>>
  ** <<features-shaderSampledImageArrayNonUniformIndexing,
     pname:shaderSampledImageArrayNonUniformIndexing>>
  ** <<features-shaderStorageBufferArrayNonUniformIndexing,
     pname:shaderStorageBufferArrayNonUniformIndexing>>
  ** <<features-shaderUniformTexelBufferArrayNonUniformIndexing,
     pname:shaderUniformTexelBufferArrayNonUniformIndexing>>
  ** <<features-descriptorBindingSampledImageUpdateAfterBind,
     pname:descriptorBindingSampledImageUpdateAfterBind>>
  ** <<features-descriptorBindingStorageImageUpdateAfterBind,
     pname:descriptorBindingStorageImageUpdateAfterBind>>
  ** <<features-descriptorBindingStorageBufferUpdateAfterBind,
     pname:descriptorBindingStorageBufferUpdateAfterBind>> (see also
     <<limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-descriptorBindingUniformTexelBufferUpdateAfterBind,
     pname:descriptorBindingUniformTexelBufferUpdateAfterBind>> (see also
     <<limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-descriptorBindingStorageTexelBufferUpdateAfterBind,
     pname:descriptorBindingStorageTexelBufferUpdateAfterBind>> (see also
     <<limits-robustBufferAccessUpdateAfterBind,
     pname:robustBufferAccessUpdateAfterBind>>)
  ** <<features-descriptorBindingUpdateUnusedWhilePending,
     pname:descriptorBindingUpdateUnusedWhilePending>>
  ** <<features-descriptorBindingPartiallyBound,
     pname:descriptorBindingPartiallyBound>>
  ** <<features-runtimeDescriptorArray, pname:runtimeDescriptorArray>>
endif::VK_EXT_descriptor_indexing[]
ifdef::VK_EXT_inline_uniform_block[]
  * <<features-inlineUniformBlock,pname:inlineUniformBlock>>, if the
    `<<VK_EXT_inline_uniform_block>>` extension is supported.
ifdef::VK_EXT_descriptor_indexing[]
  * <<features-descriptorBindingInlineUniformBlockUpdateAfterBind,
    pname:descriptorBindingInlineUniformBlockUpdateAfterBind>>, if the
    `<<VK_EXT_inline_uniform_block>>` and `<<VK_EXT_descriptor_indexing>>`
    extensions are both supported.
endif::VK_EXT_descriptor_indexing[]
endif::VK_EXT_inline_uniform_block[]
ifdef::VK_EXT_scalar_block_layout[]
  * <<features-scalarBlockLayout,pname:scalarBlockLayout>>, if the
    `<<VK_EXT_scalar_block_layout>>` extension is supported.
endif::VK_EXT_scalar_block_layout[]

All other features defined in the Specification are optional:.
