// Copyright (c) 2015-2018 Khronos Group. This work is licensed under a
// Creative Commons Attribution 4.0 International License; see
// http://creativecommons.org/licenses/by/4.0/

[[drawing]]
= Drawing Commands

_Drawing commands_ (commands with ftext:Draw in the name) provoke work in a
graphics pipeline.
Drawing commands are recorded into a command buffer and when executed by a
queue, will produce work which executes according to the bound graphics
pipeline.
A graphics pipeline must: be bound to a command buffer before any drawing
commands are recorded in that command buffer.

[open,refpage='VkPipelineInputAssemblyStateCreateInfo',desc='Structure specifying parameters of a newly created pipeline input assembly state',type='structs']
--

Each draw is made up of zero or more vertices and zero or more instances,
which are processed by the device and result in the assembly of primitives.
Primitives are assembled according to the pname:pInputAssemblyState member
of the sname:VkGraphicsPipelineCreateInfo structure, which is of type
sname:VkPipelineInputAssemblyStateCreateInfo:

include::../api/structs/VkPipelineInputAssemblyStateCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags is reserved for future use.
  * pname:topology is a elink:VkPrimitiveTopology defining the primitive
    topology, as described below.
  * pname:primitiveRestartEnable controls whether a special vertex index
    value is treated as restarting the assembly of primitives.
    This enable only applies to indexed draws (flink:vkCmdDrawIndexed and
    flink:vkCmdDrawIndexedIndirect), and the special index value is either
    0xFFFFFFFF when the pname:indexType parameter of
    fname:vkCmdBindIndexBuffer is equal to ename:VK_INDEX_TYPE_UINT32, or
    0xFFFF when pname:indexType is equal to ename:VK_INDEX_TYPE_UINT16.
    Primitive restart is not allowed for "`list`" topologies.

Restarting the assembly of primitives discards the most recent index values
if those elements formed an incomplete primitive, and restarts the primitive
assembly using the subsequent indices, but only assembling the immediately
following element through the end of the originally specified elements.
The primitive restart index value comparison is performed before adding the
pname:vertexOffset value to the index value.

.Valid Usage
****
  * [[VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00428]]
    If pname:topology is ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, pname:primitiveRestartEnable
    must: be ename:VK_FALSE
  * [[VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00429]]
    If the <<features-features-geometryShader,geometry shaders>> feature is
    not enabled, pname:topology must: not be any of
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY
  * [[VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00430]]
    If the <<features-features-tessellationShader,tessellation shaders>>
    feature is not enabled, pname:topology must: not be
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST
****

include::../validity/structs/VkPipelineInputAssemblyStateCreateInfo.txt[]
--

[open,refpage='VkPipelineInputAssemblyStateCreateFlags',desc='Reserved for future use',type='enums']
--
include::../api/flags/VkPipelineInputAssemblyStateCreateFlags.txt[]

sname:VkPipelineInputAssemblyStateCreateFlags is a bitmask type for setting
a mask, but is currently reserved for future use.
--


[[drawing-primitive-topologies]]
== Primitive Topologies

[open,refpage='VkPrimitiveTopology',desc='Supported primitive topologies',type='enums']
--

_Primitive topology_ determines how consecutive vertices are organized into
primitives, and determines the type of primitive that is used at the
beginning of the graphics pipeline.
The effective topology for later stages of the pipeline is altered by
tessellation or geometry shading (if either is in use) and depends on the
execution modes of those shaders.
Supported topologies are defined by elink:VkPrimitiveTopology and include:

include::../api/enums/VkPrimitiveTopology.txt[]

--

Each primitive topology, and its construction from a list of vertices, is
summarized below with a supporting diagram.
In each diagram, the numbered points show the sequencing of vertices in
order within the vertex arrays; however the positions chosen are arbitrary
and for illustration only.
Vertices connected with solid lines belong to the main primitives.
In the primitive types with adjacency, the vertices connected by dashed
lines are the adjacent vertices that are accessible in a geometry shader.

[NOTE]
.Note
====
The terminology {ldquo}vertex [eq]#i# {rdquo} means {ldquo}the vertex with
index [eq]#i# in the ordered list of vertices defining this
primitive{rdquo}.
====

[NOTE]
.Note
====
Depending on the <<primsrast-polygonmode,polygon mode>>, a _polygon
primitive_ generated from a drawing command with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY, or
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY is rendered in one
of several ways, such as outlining its border or filling its interior.
The order of vertices in such a primitive is significant during
<<primsrast-polygons-basic,polygon rasterization>> and
<<shaders-fragment,fragment shading>>.
====


=== Point Lists

A series of individual points are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST.
Each vertex defines a separate point.

.Point Lists
[%inline]
image::images/primitive_topology_point_list.svg[align="center"]


=== Line Lists

Lists of line segments, with each segment defined by a pair of vertices, are
specified with pname:topology ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST.
The first two vertices define the first segment, with subsequent pairs of
vertices each defining one more segment.
If the number of vertices is odd, then the last vertex is ignored.

.Line Lists
[%inline]
image::images/primitive_topology_line_list.svg[align="center"]


=== Line Strips

A series of one or more connected line segments are specified with
pname:topology ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP.
In this case, the first vertex specifies the first segment's start point
while the second vertex specifies the first segment's endpoint and the
second segment's start point.
In general, vertex [eq]#i# (for [eq]#i > 0#) specifies the beginning of the
[eq]##i##th segment and the end of the previous segment.
The last vertex specifies the end of the last segment.
If only one vertex is specified, then no primitive is generated.

.Line Strips
[%inline]
image::images/primitive_topology_line_strip.svg[align="center"]


=== Triangle Lists

Lists of separate triangles are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST.
In this case, vertices [eq]#3 i#, [eq]#3 i {plus} 1#, and [eq]#3 i {plus} 2#
(in that order) determine a triangle for each [eq]#i = 0, 1, ..., n-1#,
where there are [eq]#3 n {plus} k# vertices drawn.
[eq]#k# is either 0, 1, or 2; if [eq]#k# is not zero, the final [eq]#k#
vertices are ignored.

.Triangle Lists
[%inline]
image::images/primitive_topology_triangle_list.svg[align="center"]


=== Triangle Strips

A triangle strip is a series of triangles connected along shared edges, and
is specified with pname:topology ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP.
In this case, the first three vertices define the first triangle, and their
order is significant.
Each subsequent vertex defines a new triangle using that point along with
the last two vertices from the previous triangle.
If fewer than three vertices are specified, no primitive is produced.
The order of vertices in successive triangles changes as shown in the figure
below, so that all triangle faces have the same orientation.

.Triangle Strips
[%inline]
image::images/primitive_topology_triangle_strip.svg[align="center"]


=== Triangle Fans

A triangle fan is specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN.
It is similar to a triangle strip, but changes the vertex replaced from the
previous triangle so that all triangles in the fan share a common vertex.

.Triangle Fans
[%inline]
image::images/primitive_topology_triangle_fan.svg[align="center"]


=== Line Lists With Adjacency

Lines with adjacency are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, and are independent
line segments where each endpoint has a corresponding _adjacent_ vertex that
is accessible in a <<geometry,geometry shader>>.
If a geometry shader is not active, the adjacent vertices are ignored.

A line segment is drawn from vertex [eq]#4 i {plus} 1# to vertex [eq]#4 i
{plus} 2# for each [eq]#i = 0, 1, ..., n-1#, where there are [eq]#4 n {plus}
k# vertices.
[eq]#k# is either 0, 1, 2, or 3; if [eq]#k# is not zero, the final [eq]#k#
vertices are ignored.
For line segment [eq]#i#, vertices [eq]#4 i# and [eq]#4 i {plus} 3# vertices
are considered adjacent to vertices [eq]#4 i {plus} 1# and [eq]#4 i {plus}
2#, respectively.

.Line Lists With Adjacency
[%inline]
image::images/primitive_topology_line_list_with_adjacency.svg[align="center"]


=== Line Strips With Adjacency

Line strips with adjacency are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY and are similar to
line strips, except that each line segment has a pair of adjacent vertices
that are accessible in a geometry shader.
If a geometry shader is not active, the adjacent vertices are ignored.

A line segment is drawn from vertex [eq]#i {plus} 1# vertex to vertex [eq]#i
{plus} 2# for each [eq]#i = 0, 1, ..., n-1#, where there are [eq]#n {plus}
3# vertices.
If there are fewer than four vertices, all vertices are ignored.
For line segment [eq]#i#, vertices [eq]#i# and [eq]#i {plus} 3# are
considered adjacent to vertices [eq]#i {plus} 1# and [eq]#i {plus} 2#,
respectively.

.Line Strips With Adjacency
[%inline]
image::images/primitive_topology_line_strip_with_adjacency.svg[align="center"]


=== Triangle Lists With Adjacency

Triangles with adjacency are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY, and are similar to
separate triangles except that each triangle edge has an adjacent vertex
that is accessible in a geometry shader.
If a geometry shader is not active, the adjacent vertices are ignored.

Vertices [eq]#6 i#, [eq]#6 i {plus} 2#, and [eq]#6 i {plus} 4# (in that
order) determine a triangle for each [eq]#i = 0, 1, ..., n-1#, where there
are [eq]#6 n+k# vertices.
[eq]#k# is either 0, 1, 2, 3, 4, or 5; if [eq]#k# is non-zero, the final
[eq]#k# vertices are ignored.
For triangle [eq]#i#, vertices [eq]#6 i {plus} 1#, [eq]#6 i {plus} 3#, and
[eq]#6 i {plus} 5# vertices are considered adjacent to edges from vertex
[eq]#6 i# to [eq]#6 i {plus} 2#, from [eq]#6 i {plus} 2# to [eq]#6 i {plus}
4#, and from [eq]#6 i {plus} 4# to [eq]#6 i# vertices, respectively.

.Triangle Lists With Adjacency
[%inline]
image::images/primitive_topology_triangle_list_with_adjacency.svg[align="center"]


=== Triangle Strips With Adjacency

Triangle strips with adjacency are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY, and are similar
to triangle strips except that each triangle edge has an adjacent vertex
that is accessible in a geometry shader.
If a geometry shader is not active, the adjacent vertices are ignored.

In triangle strips with adjacency, [eq]#n# triangles are drawn where there
are [eq]#2 (n {plus} 2) {plus} k# vertices.
[eq]#k# is either 0 or 1; if [eq]#k# is 1, the final vertex is ignored.
If there are fewer than 6 vertices, the entire primitive is ignored.

.Triangle Strips With Adjacency
[%inline]
image::images/primitive_topology_triangle_strip_with_adjacency.svg[align="center"]

The table below illustrates the vertices and order used to draw each
triangle, and which vertices are considered adjacent to each edge of those
triangles.
Each triangle is drawn using the vertices whose numbers are in the *1st*,
*2nd*, and *3rd* columns under *Primitive Vertices*, in that order.
The vertices in the 1/2, 2/3, and 3/1 columns under *Adjacent Vertices* are
considered adjacent to the edges from the first to the second, from the
second to the third, and from the third to the first vertex of the triangle,
respectively.
The six rows correspond to six cases: the first and only triangle [eq]#(i =
0, n = 1)#, the first triangle of several [eq]#(i = 0, n > 0)#, _odd_ middle
triangles [eq]#(i = 1, 3, 5 ...)#, _even_ middle triangles [eq]#(i = 2, 4,
6, ...)#, and special cases for the last triangle, when [eq]#i# is either
even or odd.
For the purposes of this table, both the first vertex and first triangle are
numbered [eq]#0#.

[[trigenadj]]
.Triangles generated by triangle strips with adjacency
[options="header", cols="2,1,1,1,1,1,1"]
|====
|                                3+| Primitive Vertices                                         3+| Adjacent Vertices
| Primitive                        | 1st                | 2nd                | 3rd                | 1/2         | 2/3                | 3/1
| only ([eq]#i = 0, n = 1#)        | 0                  | 2                  | 4                  | 1           | 5                  | 3
| first ([eq]#i = 0#)              | 0                  | 2                  | 4                  | 1           | 6                  | 3
| middle ([eq]#i# odd)             | [eq]#2 i {plus} 2# | [eq]#2 i#          | [eq]#2 i {plus} 4# | [eq]#2 i-2# | [eq]#2 i {plus} 3# | [eq]#2 i {plus} 6#
| middle ([eq]#i# even)            | [eq]#2 i#          | [eq]#2 i {plus} 2# | [eq]#2 i {plus} 4# | [eq]#2 i-2# | [eq]#2 i {plus} 6# | [eq]#2 i {plus} 3#
| last ([eq]#i=n-1#, [eq]#i# odd)  | [eq]#2 i {plus} 2# | [eq]#2 i#          | [eq]#2 i {plus} 4# | [eq]#2 i-2# | [eq]#2 i {plus} 3# | [eq]#2 i {plus} 5#
| last ([eq]#i=n-1#, [eq]#i# even) | [eq]#2 i#          | [eq]#2 i {plus} 2# | [eq]#2 i {plus} 4# | [eq]#2 i-2# | [eq]#2 i {plus} 5# | [eq]#2 i {plus} 3#
|====


[[drawing-primitive-topologies-patches]]
=== Separate Patches

Separate patches are specified with pname:topology
ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST.
A patch is an ordered collection of vertices used for
<<tessellation,primitive tessellation>>.
The vertices comprising a patch have no implied geometric ordering, and are
used by tessellation shaders and the fixed-function tessellator to generate
new point, line, or triangle primitives.

Each patch in the series has a fixed number of vertices, specified by the
pname:patchControlPoints member of the
slink:VkPipelineTessellationStateCreateInfo structure passed to
flink:vkCreateGraphicsPipelines.
Once assembled and vertex shaded, these patches are provided as input to the
tessellation control shader stage.

If the number of vertices in a patch is given by [eq]#v#, vertices [eq]#v
{times} i# through [eq]#v {times} i {plus} v - 1# (in that order) determine
a patch for each [eq]#i = 0, 1, ..., n-1#, where there are [eq]#v {times} n
{plus} k# vertices.
[eq]#k# is in the range [eq]#[0, v - 1]#; if [eq]#k# is not zero, the final
[eq]#k# vertices are ignored.


[[drawing-primitive-order]]
== Primitive Order

Primitives generated by <<drawing, drawing commands>> progress through the
stages of the <<synchronization-pipeline-stages-types, graphics pipeline>>
in _primitive order_.
Primitive order is initially determined in the following way:

  . Submission order determines the initial ordering
  . For indirect draw commands, the order in which accessed instances of the
    slink:VkDrawIndirectCommand are stored in pname:buffer, from lower
    indirect buffer addresses to higher addresses.
  . If a draw command includes multiple instances, the order in which
    instances are executed, from lower numbered instances to higher.
  . The order in which primitives are specified by a draw command:
  ** For non-indexed draws, from vertices with a lower numbered
     code:vertexIndex to a higher numbered code:vertexIndex.
  ** For indexed draws, vertices sourced from a lower index buffer addresses
     to higher addresses.

Within this order implementations further sort primitives:

[start=5]
  . If tessellation shading is active, by an implementation-dependent order
    of new primitives generated by <<tessellation-primitive-order,
    tessellation>>.
  . If geometry shading is active, by the order new primitives are generated
    by <<geometry-ordering, geometry shading>>.
  . If the <<primsrast-polygonmode,polygon mode>> is not
    ename:VK_POLYGON_MODE_FILL,
ifdef::VK_NV_fill_rectangle[]
    or ename:VK_POLYGON_MODE_FILL_RECTANGLE_NV,
endif::VK_NV_fill_rectangle[]
    by an implementation-dependent ordering of the new primitives generated
    within the original primitive.

Primitive order is later used to define <<primrast-order, rasterization
order>>, which determines the order in which fragments output results to a
framebuffer.


== Programmable Primitive Shading

Once primitives are assembled, they proceed to the vertex shading stage of
the pipeline.
If the draw includes multiple instances, then the set of primitives is sent
to the vertex shading stage multiple times, once for each instance.

It is undefined whether vertex shading occurs on vertices that are discarded
as part of incomplete primitives, but if it does occur then it operates as
if they were vertices in complete primitives and such invocations can: have
side effects.

Vertex shading receives two per-vertex inputs from the primitive assembly
stage - the code:vertexIndex and the code:instanceIndex.
How these values are generated is defined below, with each command.

Drawing commands fall roughly into two categories:

  * Non-indexed drawing commands present a sequential code:vertexIndex to
    the vertex shader.
    The sequential index is generated automatically by the device (see
    <<fxvertex,Fixed-Function Vertex Processing>> for details on both
    specifying the vertex attributes indexed by code:vertexIndex, as well as
    binding vertex buffers containing those attributes to a command buffer).
    These commands are:
  ** flink:vkCmdDraw
  ** flink:vkCmdDrawIndirect
ifdef::VK_KHR_draw_indirect_count[]
  ** flink:vkCmdDrawIndirectCountKHR
endif::VK_KHR_draw_indirect_count[]
ifdef::VK_AMD_draw_indirect_count[]
  ** flink:vkCmdDrawIndirectCountAMD.
endif::VK_AMD_draw_indirect_count[]
  * Indexed drawing commands read index values from an _index buffer_ and
    use this to compute the code:vertexIndex value for the vertex shader.
    These commands are:
  ** flink:vkCmdDrawIndexed
  ** flink:vkCmdDrawIndexedIndirect
ifdef::VK_KHR_draw_indirect_count[]
  ** flink:vkCmdDrawIndexedIndirectCountKHR
endif::VK_KHR_draw_indirect_count[]
ifdef::VK_AMD_draw_indirect_count[]
  ** flink:vkCmdDrawIndexedIndirectCountAMD.
endif::VK_AMD_draw_indirect_count[]


[open,refpage='vkCmdBindIndexBuffer',desc='Bind an index buffer to a command buffer',type='protos']
--

To bind an index buffer to a command buffer, call:

include::../api/protos/vkCmdBindIndexBuffer.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer being bound.
  * pname:offset is the starting offset in bytes within pname:buffer used in
    index buffer address calculations.
  * pname:indexType is a elink:VkIndexType value specifying whether indices
    are treated as 16 bits or 32 bits.

.Valid Usage
****
  * [[VUID-vkCmdBindIndexBuffer-offset-00431]]
    pname:offset must: be less than the size of pname:buffer
  * [[VUID-vkCmdBindIndexBuffer-offset-00432]]
    The sum of pname:offset and the address of the range of
    sname:VkDeviceMemory object that is backing pname:buffer, must: be a
    multiple of the type indicated by pname:indexType
  * [[VUID-vkCmdBindIndexBuffer-buffer-00433]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT flag
  * [[VUID-vkCmdBindIndexBuffer-buffer-00434]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
****

include::../validity/protos/vkCmdBindIndexBuffer.txt[]
--


[open,refpage='VkIndexType',desc='Type of index buffer indices',type='enums']
--

Possible values of flink:vkCmdBindIndexBuffer::pname:indexType, specifying
the size of indices, are:

include::../api/enums/VkIndexType.txt[]

  * ename:VK_INDEX_TYPE_UINT16 specifies that indices are 16-bit unsigned
    integer values.
  * ename:VK_INDEX_TYPE_UINT32 specifies that indices are 32-bit unsigned
    integer values.

--

The parameters for each drawing command are specified directly in the
command or read from buffer memory, depending on the command.
Drawing commands that source their parameters from buffer memory are known
as _indirect_ drawing commands.

All drawing commands interact with the
<<features-features-robustBufferAccess, Robust Buffer Access>> feature.

[open,refpage='vkCmdDraw',desc='Draw primitives',type='protos']
--

To record a non-indexed draw, call:

include::../api/protos/vkCmdDraw.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:vertexCount is the number of vertices to draw.
  * pname:instanceCount is the number of instances to draw.
  * pname:firstVertex is the index of the first vertex to draw.
  * pname:firstInstance is the instance ID of the first instance to draw.

When the command is executed, primitives are assembled using the current
primitive topology and pname:vertexCount consecutive vertex indices with the
first code:vertexIndex value equal to pname:firstVertex.
The primitives are drawn pname:instanceCount times with code:instanceIndex
starting with pname:firstInstance and increasing sequentially for each
instance.
The assembled primitives execute the bound graphics pipeline.

.Valid Usage
****
  * [[VUID-vkCmdDraw-renderPass-00435]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDraw-subpass-00436]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDraw-None-00437]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDraw-None-00438]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDraw-None-00439]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDraw-None-00440]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDraw-None-00441]]
    For a given vertex buffer binding, any attribute data fetched must: be
    entirely contained within the corresponding vertex buffer binding, as
    described in <<fxvertex-input>>
  * [[VUID-vkCmdDraw-None-00442]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDraw-None-00443]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDraw-None-00444]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDraw-None-00445]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDraw-None-00446]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDraw-None-00447]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDraw-None-00448]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDraw-None-00449]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDraw-None-01499]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
  * [[VUID-vkCmdDraw-None-02009]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
ifdef::VK_IMG_filter_cubic[]
  * [[VUID-vkCmdDraw-None-02010]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG.
  * [[VUID-vkCmdDraw-None-00452]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_IMG_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDraw-maxMultiviewInstanceIndex-00453]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDraw-commandBuffer-01850]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
  * [[VUID-vkCmdDraw-commandBuffer-01851]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer,
    that image or buffer must: not be an unprotected image or unprotected
    buffer.
  * [[VUID-vkCmdDraw-commandBuffer-01852]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage other than the framebuffer-space pipeline stages in the
    sname:VkPipeline object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS
    reads from or writes to any image or buffer, the image or buffer must:
    not be a protected image or protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDraw-sampleLocationsEnable-01512]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
****

include::../validity/protos/vkCmdDraw.txt[]
--

[open,refpage='vkCmdDrawIndexed',desc='Issue an indexed draw into a command buffer',type='protos']
--

To record an indexed draw, call:

include::../api/protos/vkCmdDrawIndexed.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:indexCount is the number of vertices to draw.
  * pname:instanceCount is the number of instances to draw.
  * pname:firstIndex is the base index within the index buffer.
  * pname:vertexOffset is the value added to the vertex index before
    indexing into the vertex buffer.
  * pname:firstInstance is the instance ID of the first instance to draw.

When the command is executed, primitives are assembled using the current
primitive topology and pname:indexCount vertices whose indices are retrieved
from the index buffer.
The index buffer is treated as an array of tightly packed unsigned integers
of size defined by the flink:vkCmdBindIndexBuffer::pname:indexType parameter
with which the buffer was bound.

The first vertex index is at an offset of pname:firstIndex * code:indexSize
+ pname:offset within the bound index buffer, where pname:offset is the
offset specified by fname:vkCmdBindIndexBuffer and code:indexSize is the
byte size of the type specified by pname:indexType.
Subsequent index values are retrieved from consecutive locations in the
index buffer.
Indices are first compared to the primitive restart value, then zero
extended to 32 bits (if the code:indexType is ename:VK_INDEX_TYPE_UINT16)
and have pname:vertexOffset added to them, before being supplied as the
code:vertexIndex value.

The primitives are drawn pname:instanceCount times with code:instanceIndex
starting with pname:firstInstance and increasing sequentially for each
instance.
The assembled primitives execute the bound graphics pipeline.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndexed-renderPass-00454]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexed-subpass-00455]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexed-None-00456]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexed-None-00457]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexed-None-00458]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndexed-None-00459]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndexed-None-00460]]
    For a given vertex buffer binding, any attribute data fetched must: be
    entirely contained within the corresponding vertex buffer binding, as
    described in <<fxvertex-input>>
  * [[VUID-vkCmdDrawIndexed-None-00461]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndexed-None-00462]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndexed-indexSize-00463]]
    [eq]#(pname:indexSize * (pname:firstIndex {plus} pname:indexCount)
    {plus} pname:offset)# must: be less than or equal to the size of the
    bound index buffer, with indexSize being based on the type specified by
    pname:indexType, where the index buffer, pname:indexType, and
    pname:offset are specified via fname:vkCmdBindIndexBuffer
  * [[VUID-vkCmdDrawIndexed-None-00464]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndexed-None-00465]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndexed-None-00466]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndexed-None-00467]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndexed-None-00468]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndexed-None-00469]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndexed-None-02011]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndexed-None-01500]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_IMG_filter_cubic[]
  * [[VUID-vkCmdDrawIndexed-None-02012]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG.
  * [[VUID-vkCmdDrawIndexed-None-00472]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_IMG_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndexed-maxMultiviewInstanceIndex-00473]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndexed-commandBuffer-01853]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
  * [[VUID-vkCmdDrawIndexed-commandBuffer-01854]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer,
    that image or buffer must: not be an unprotected image or unprotected
    buffer.
  * [[VUID-vkCmdDrawIndexed-commandBuffer-01855]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage other than the framebuffer-space pipeline stages in the
    sname:VkPipeline object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS
    reads from or writes to any image or buffer, the image or buffer must:
    not be a protected image or protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndexed-sampleLocationsEnable-01513]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
****

include::../validity/protos/vkCmdDrawIndexed.txt[]
--

[open,refpage='vkCmdDrawIndirect',desc='Issue an indirect draw into a command buffer',type='protos']
--

To record a non-indexed indirect draw, call:

include::../api/protos/vkCmdDrawIndirect.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:drawCount is the number of draws to execute, and can: be zero.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndirect behaves similarly to flink:vkCmdDraw except that the
parameters are read by the device from a buffer during execution.
pname:drawCount draws are executed by the command, with parameters taken
from pname:buffer starting at pname:offset and increasing by pname:stride
bytes for each successive draw.
The parameters of each draw are encoded in an array of
slink:VkDrawIndirectCommand structures.
If pname:drawCount is less than or equal to one, pname:stride is ignored.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndirect-buffer-00474]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndirect-buffer-01660]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndirect-offset-00475]]
    pname:offset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndirect-drawCount-00476]]
    If pname:drawCount is greater than `1`, pname:stride must: be a multiple
    of `4` and must: be greater than or equal to
    code:sizeof(sname:VkDrawIndirectCommand)
  * [[VUID-vkCmdDrawIndirect-drawCount-00477]]
    If the <<features-features-multiDrawIndirect,multi-draw indirect>>
    feature is not enabled, pname:drawCount must: be `0` or `1`
  * [[VUID-vkCmdDrawIndirect-firstInstance-00478]]
    If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndirectCommand structures accessed by this command must: be
    code:0
  * [[VUID-vkCmdDrawIndirect-renderPass-00479]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndirect-subpass-00480]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndirect-None-00481]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirect-None-00482]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirect-None-00483]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndirect-None-00484]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndirect-None-00485]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndirect-None-00486]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndirect-drawCount-00487]]
    If pname:drawCount is equal to `1`, [eq]#(pname:offset {plus}
    code:sizeof(slink:VkDrawIndirectCommand))# must: be less than or equal
    to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirect-drawCount-00488]]
    If pname:drawCount is greater than `1`, [eq]#(pname:stride {times}
    (pname:drawCount - 1) {plus} pname:offset {plus}
    code:sizeof(slink:VkDrawIndirectCommand))# must: be less than or equal
    to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirect-drawCount-00489]]
    pname:drawCount must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * [[VUID-vkCmdDrawIndirect-None-00490]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndirect-None-00491]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndirect-None-00492]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndirect-None-00493]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndirect-None-00494]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndirect-None-00495]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndirect-None-02013]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndirect-None-01501]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_IMG_filter_cubic[]
  * [[VUID-vkCmdDrawIndirect-None-02014]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG.
  * [[VUID-vkCmdDrawIndirect-None-00498]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_IMG_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndirect-maxMultiviewInstanceIndex-00499]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndirect-commandBuffer-01856]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
  * [[VUID-vkCmdDrawIndirect-commandBuffer-01857]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer,
    that image or buffer must: not be an unprotected image or unprotected
    buffer.
  * [[VUID-vkCmdDrawIndirect-commandBuffer-01858]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage other than the framebuffer-space pipeline stages in the
    sname:VkPipeline object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS
    reads from or writes to any image or buffer, the image or buffer must:
    not be a protected image or protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndirect-sampleLocationsEnable-01514]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
****

include::../validity/protos/vkCmdDrawIndirect.txt[]
--

[open,refpage='VkDrawIndirectCommand',desc='Structure specifying a draw indirect command',type='structs',xrefs='vkCmdDrawIndirect']
--

The sname:VkDrawIndirectCommand structure is defined as:

include::../api/structs/VkDrawIndirectCommand.txt[]

  * pname:vertexCount is the number of vertices to draw.
  * pname:instanceCount is the number of instances to draw.
  * pname:firstVertex is the index of the first vertex to draw.
  * pname:firstInstance is the instance ID of the first instance to draw.

The members of sname:VkDrawIndirectCommand have the same meaning as the
similarly named parameters of flink:vkCmdDraw.

.Valid Usage
****
  * [[VUID-VkDrawIndirectCommand-None-00500]]
    For a given vertex buffer binding, any attribute data fetched must: be
    entirely contained within the corresponding vertex buffer binding, as
    described in <<fxvertex-input>>
  * [[VUID-VkDrawIndirectCommand-firstInstance-00501]]
    If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, pname:firstInstance must: be code:0
****

include::../validity/structs/VkDrawIndirectCommand.txt[]

--

ifdef::VK_KHR_draw_indirect_count[]
[open,refpage='vkCmdDrawIndirectCountKHR',desc='Perform an indirect draw with the draw count sourced from a buffer',type='protos']
--

To record a non-indexed draw call with a draw call count sourced from a
buffer, call:

include::../api/protos/vkCmdDrawIndirectCountKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:countBuffer is the buffer containing the draw count.
  * pname:countBufferOffset is the byte offset into pname:countBuffer where
    the draw count begins.
  * pname:maxDrawCount specifies the maximum number of draws that will be
    executed.
    The actual number of executed draw calls is the minimum of the count
    specified in pname:countBuffer and pname:maxDrawCount.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndirectCountKHR behaves similarly to flink:vkCmdDrawIndirect
except that the draw count is read by the device from a buffer during
execution.
The command will read an unsigned 32-bit integer from pname:countBuffer
located at pname:countBufferOffset and use this as the draw count.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndirectCountKHR-buffer-03104]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndirectCountKHR-buffer-03105]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndirectCountKHR-countBuffer-03106]]
    If pname:countBuffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndirectCountKHR-countBuffer-03107]]
    pname:countBuffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndirectCountKHR-offset-03108]]
    pname:offset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndirectCountKHR-countBufferOffset-03109]]
    pname:countBufferOffset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndirectCountKHR-stride-03110]]
    pname:stride must: be a multiple of `4` and must: be greater than or
    equal to sizeof(sname:VkDrawIndirectCommand)
  * [[VUID-vkCmdDrawIndirectCountKHR-maxDrawCount-03111]]
    If pname:maxDrawCount is greater than or equal to `1`,
    [eq]#(pname:stride {times} (pname:maxDrawCount - 1) {plus} pname:offset
    {plus} sizeof(sname:VkDrawIndirectCommand))# must: be less than or equal
    to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirectCountKHR-firstInstance-03112]]
    If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndirectCommand structures accessed by this command must: be
    code:0
  * [[VUID-vkCmdDrawIndirectCountKHR-renderPass-03113]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndirectCountKHR-subpass-03114]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03115]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03116]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03117]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03118]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03119]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03120]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndirectCountKHR-countBuffer-03121]]
    If the count stored in pname:countBuffer is equal to `1`,
    [eq]#(pname:offset {plus} sizeof(sname:VkDrawIndirectCommand))# must: be
    less than or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirectCountKHR-countBuffer-03122]]
    If the count stored in pname:countBuffer is greater than `1`,
    [eq]#(pname:stride {times} (pname:drawCount - 1) {plus} pname:offset
    {plus} sizeof(sname:VkDrawIndirectCommand))# must: be less than or equal
    to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirectCountKHR-countBuffer-03123]]
    The count stored in pname:countBuffer must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03124]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03125]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03126]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03127]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03128]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03129]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndirectCountKHR-None-02015]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03131]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_IMG_filter_cubic[]
  * [[VUID-vkCmdDrawIndirectCountKHR-None-02016]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG.
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03170]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_IMG_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndirectCountKHR-maxMultiviewInstanceIndex-03132]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndirectCountKHR-commandBuffer-03133]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
  * [[VUID-vkCmdDrawIndirectCountKHR-commandBuffer-03134]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer,
    that image or buffer must: not be an unprotected image or unprotected
    buffer.
  * [[VUID-vkCmdDrawIndirectCountKHR-commandBuffer-03135]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage other than the framebuffer-space pipeline stages in the
    sname:VkPipeline object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS
    reads from or writes to any image or buffer, the image or buffer must:
    not be a protected image or protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndirectCountKHR-sampleLocationsEnable-03171]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
****

include::../validity/protos/vkCmdDrawIndirectCountKHR.txt[]

--
endif::VK_KHR_draw_indirect_count[]

ifdef::VK_AMD_draw_indirect_count[]
[open,refpage='vkCmdDrawIndirectCountAMD',desc='Perform an indirect draw with the draw count sourced from a buffer',type='protos']
--

To record a non-indexed draw call with a draw call count sourced from a
buffer, call:

include::../api/protos/vkCmdDrawIndirectCountAMD.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:countBuffer is the buffer containing the draw count.
  * pname:countBufferOffset is the byte offset into pname:countBuffer where
    the draw count begins.
  * pname:maxDrawCount specifies the maximum number of draws that will be
    executed.
    The actual number of executed draw calls is the minimum of the count
    specified in pname:countBuffer and pname:maxDrawCount.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndirectCountAMD behaves similarly to flink:vkCmdDrawIndirect
except that the draw count is read by the device from a buffer during
execution.
The command will read an unsigned 32-bit integer from pname:countBuffer
located at pname:countBufferOffset and use this as the draw count.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndirectCountAMD-buffer-01661]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndirectCountAMD-buffer-01662]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndirectCountAMD-countBuffer-01663]]
    If pname:countBuffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndirectCountAMD-countBuffer-01664]]
    pname:countBuffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndirectCountAMD-offset-00502]]
    pname:offset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndirectCountAMD-countBufferOffset-00503]]
    pname:countBufferOffset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndirectCountAMD-stride-00504]]
    pname:stride must: be a multiple of `4` and must: be greater than or
    equal to code:sizeof(sname:VkDrawIndirectCommand)
  * [[VUID-vkCmdDrawIndirectCountAMD-maxDrawCount-00505]]
    If pname:maxDrawCount is greater than or equal to `1`,
    [eq]#(pname:stride {times} (pname:maxDrawCount - 1) {plus} pname:offset
    {plus} code:sizeof(sname:VkDrawIndirectCommand))# must: be less than or
    equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirectCountAMD-firstInstance-00506]]
    If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndirectCommand structures accessed by this command must: be
    code:0
  * [[VUID-vkCmdDrawIndirectCountAMD-renderPass-00507]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndirectCountAMD-subpass-00508]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00509]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00510]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00511]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00512]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00513]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00514]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndirectCountAMD-countBuffer-00515]]
    If the count stored in pname:countBuffer is equal to `1`,
    [eq]#(pname:offset {plus} code:sizeof(sname:VkDrawIndirectCommand))#
    must: be less than or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirectCountAMD-countBuffer-00516]]
    If the count stored in pname:countBuffer is greater than `1`,
    [eq]#(pname:stride {times} (pname:drawCount - 1) {plus} pname:offset
    {plus} code:sizeof(sname:VkDrawIndirectCommand))# must: be less than or
    equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirectCountAMD-countBuffer-00517]]
    The count stored in pname:countBuffer must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00518]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00519]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00520]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00521]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00522]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00523]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndirectCountAMD-None-02017]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndirectCountAMD-None-01502]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndirectCountAMD-maxMultiviewInstanceIndex-00525]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndirectCountAMD-commandBuffer-01859]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
  * [[VUID-vkCmdDrawIndirectCountAMD-commandBuffer-01860]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer,
    that image or buffer must: not be an unprotected image or unprotected
    buffer.
  * [[VUID-vkCmdDrawIndirectCountAMD-commandBuffer-01861]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage other than the framebuffer-space pipeline stages in the
    sname:VkPipeline object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS
    reads from or writes to any image or buffer, the image or buffer must:
    not be a protected image or protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndirectCountAMD-sampleLocationsEnable-01515]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
****

include::../validity/protos/vkCmdDrawIndirectCountAMD.txt[]

--
endif::VK_AMD_draw_indirect_count[]

[open,refpage='vkCmdDrawIndexedIndirect',desc='Perform an indexed indirect draw',type='protos']
--

To record an indexed indirect draw, call:

include::../api/protos/vkCmdDrawIndexedIndirect.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:drawCount is the number of draws to execute, and can: be zero.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndexedIndirect behaves similarly to flink:vkCmdDrawIndexed
except that the parameters are read by the device from a buffer during
execution.
pname:drawCount draws are executed by the command, with parameters taken
from pname:buffer starting at pname:offset and increasing by pname:stride
bytes for each successive draw.
The parameters of each draw are encoded in an array of
slink:VkDrawIndexedIndirectCommand structures.
If pname:drawCount is less than or equal to one, pname:stride is ignored.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndexedIndirect-buffer-00526]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndexedIndirect-buffer-01665]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndexedIndirect-offset-00527]]
    pname:offset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndexedIndirect-drawCount-00528]]
    If pname:drawCount is greater than `1`, pname:stride must: be a multiple
    of `4` and must: be greater than or equal to
    code:sizeof(sname:VkDrawIndexedIndirectCommand)
  * [[VUID-vkCmdDrawIndexedIndirect-drawCount-00529]]
    If the <<features-features-multiDrawIndirect,multi-draw indirect>>
    feature is not enabled, pname:drawCount must: be `0` or `1`
  * [[VUID-vkCmdDrawIndexedIndirect-firstInstance-00530]]
    If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndexedIndirectCommand structures accessed by this command
    must: be code:0
  * [[VUID-vkCmdDrawIndexedIndirect-renderPass-00531]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexedIndirect-subpass-00532]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexedIndirect-None-00533]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexedIndirect-None-00534]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexedIndirect-None-00535]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndexedIndirect-None-00536]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndexedIndirect-None-00537]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndexedIndirect-None-00538]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndexedIndirect-drawCount-00539]]
    If pname:drawCount is equal to `1`, [eq]#(pname:offset {plus}
    code:sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than or
    equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirect-drawCount-00540]]
    If pname:drawCount is greater than `1`, [eq]#(pname:stride {times}
    (pname:drawCount - 1) {plus} pname:offset {plus}
    code:sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than or
    equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirect-drawCount-00541]]
    pname:drawCount must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * [[VUID-vkCmdDrawIndexedIndirect-None-00542]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndexedIndirect-None-00543]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndexedIndirect-None-00544]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndexedIndirect-None-00545]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndexedIndirect-None-00546]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndexedIndirect-None-00547]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndexedIndirect-None-02018]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndexedIndirect-None-01503]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_IMG_filter_cubic[]
  * [[VUID-vkCmdDrawIndexedIndirect-None-02019]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG.
  * [[VUID-vkCmdDrawIndexedIndirect-None-00550]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_IMG_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndexedIndirect-maxMultiviewInstanceIndex-00551]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndexedIndirect-commandBuffer-01862]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
  * [[VUID-vkCmdDrawIndexedIndirect-commandBuffer-01863]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer,
    that image or buffer must: not be an unprotected image or unprotected
    buffer.
  * [[VUID-vkCmdDrawIndexedIndirect-commandBuffer-01864]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage other than the framebuffer-space pipeline stages in the
    sname:VkPipeline object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS
    reads from or writes to any image or buffer, the image or buffer must:
    not be a protected image or protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndexedIndirect-sampleLocationsEnable-01516]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
****

include::../validity/protos/vkCmdDrawIndexedIndirect.txt[]
--

[open,refpage='VkDrawIndexedIndirectCommand',desc='Structure specifying a draw indexed indirect command',type='structs',xrefs='vkCmdDrawIndexedIndirect']
--

The sname:VkDrawIndexedIndirectCommand structure is defined as:

include::../api/structs/VkDrawIndexedIndirectCommand.txt[]

  * pname:indexCount is the number of vertices to draw.
  * pname:instanceCount is the number of instances to draw.
  * pname:firstIndex is the base index within the index buffer.
  * pname:vertexOffset is the value added to the vertex index before
    indexing into the vertex buffer.
  * pname:firstInstance is the instance ID of the first instance to draw.

The members of sname:VkDrawIndexedIndirectCommand have the same meaning as
the similarly named parameters of flink:vkCmdDrawIndexed.

.Valid Usage
****
  * [[VUID-VkDrawIndexedIndirectCommand-None-00552]]
    For a given vertex buffer binding, any attribute data fetched must: be
    entirely contained within the corresponding vertex buffer binding, as
    described in <<fxvertex-input>>
  * [[VUID-VkDrawIndexedIndirectCommand-indexSize-00553]]
    [eq]#(pname:indexSize * (pname:firstIndex {plus} pname:indexCount)
    {plus} pname:offset)# must: be less than or equal to the size of the
    bound index buffer, with pname:indexSize being based on the type
    specified by pname:indexType, where the index buffer, pname:indexType,
    and pname:offset are specified via fname:vkCmdBindIndexBuffer
  * [[VUID-VkDrawIndexedIndirectCommand-firstInstance-00554]]
    If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, pname:firstInstance must: be code:0
****

include::../validity/structs/VkDrawIndexedIndirectCommand.txt[]

--

ifdef::VK_KHR_draw_indirect_count[]
[open,refpage='vkCmdDrawIndexedIndirectCountKHR',desc='Perform an indexed indirect draw with the draw count sourced from a buffer',type='protos']
--

To record an indexed draw call with a draw call count sourced from a buffer,
call:

include::../api/protos/vkCmdDrawIndexedIndirectCountKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:countBuffer is the buffer containing the draw count.
  * pname:countBufferOffset is the byte offset into pname:countBuffer where
    the draw count begins.
  * pname:maxDrawCount specifies the maximum number of draws that will be
    executed.
    The actual number of executed draw calls is the minimum of the count
    specified in pname:countBuffer and pname:maxDrawCount.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndexedIndirectCountKHR behaves similarly to
flink:vkCmdDrawIndexedIndirect except that the draw count is read by the
device from a buffer during execution.
The command will read an unsigned 32-bit integer from pname:countBuffer
located at pname:countBufferOffset and use this as the draw count.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-buffer-03136]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-buffer-03137]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03138]]
    If pname:countBuffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03139]]
    pname:countBuffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-offset-03140]]
    pname:offset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-countBufferOffset-03141]]
    pname:countBufferOffset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-stride-03142]]
    pname:stride must: be a multiple of `4` and must: be greater than or
    equal to sizeof(sname:VkDrawIndexedIndirectCommand)
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-maxDrawCount-03143]]
    If pname:maxDrawCount is greater than or equal to `1`,
    [eq]#(pname:stride {times} (pname:maxDrawCount - 1) {plus} pname:offset
    {plus} sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than
    or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-firstInstance-03144]]
    If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndexedIndirectCommand structures accessed by this command
    must: be code:0
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-renderPass-03145]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-subpass-03146]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03147]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03148]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03149]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03150]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03151]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03152]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03153]]
    If count stored in pname:countBuffer is equal to `1`, [eq]#(pname:offset
    {plus} sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than
    or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03154]]
    If count stored in pname:countBuffer is greater than `1`,
    [eq]#(pname:stride {times} (pname:drawCount - 1) {plus} pname:offset
    {plus} sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than
    or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-drawCount-03155]]
    pname:drawCount must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03156]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03157]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03158]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03159]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03160]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03161]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-02020]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03163]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_IMG_filter_cubic[]
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-02021]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG.
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03173]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_IMG as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_IMG_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-maxMultiviewInstanceIndex-03164]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-03165]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-03166]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer,
    that image or buffer must: not be an unprotected image or unprotected
    buffer.
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-03167]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage other than the framebuffer-space pipeline stages in the
    sname:VkPipeline object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS
    reads from or writes to any image or buffer, the image or buffer must:
    not be a protected image or protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-sampleLocationsEnable-03174]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
****

include::../validity/protos/vkCmdDrawIndexedIndirectCountKHR.txt[]

--
endif::VK_KHR_draw_indirect_count[]


ifdef::VK_AMD_draw_indirect_count[]
[open,refpage='vkCmdDrawIndexedIndirectCountAMD',desc='Perform an indexed indirect draw with the draw count sourced from a buffer',type='protos']
--

To record an indexed draw call with a draw call count sourced from a buffer,
call:

include::../api/protos/vkCmdDrawIndexedIndirectCountAMD.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:countBuffer is the buffer containing the draw count.
  * pname:countBufferOffset is the byte offset into pname:countBuffer where
    the draw count begins.
  * pname:maxDrawCount specifies the maximum number of draws that will be
    executed.
    The actual number of executed draw calls is the minimum of the count
    specified in pname:countBuffer and pname:maxDrawCount.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndexedIndirectCountAMD behaves similarly to
flink:vkCmdDrawIndexedIndirect except that the draw count is read by the
device from a buffer during execution.
The command will read an unsigned 32-bit integer from pname:countBuffer
located at pname:countBufferOffset and use this as the draw count.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-buffer-01666]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-buffer-01667]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-01668]]
    If pname:countBuffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-01669]]
    pname:countBuffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-offset-00555]]
    pname:offset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-countBufferOffset-00556]]
    pname:countBufferOffset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-stride-00557]]
    pname:stride must: be a multiple of `4` and must: be greater than or
    equal to code:sizeof(sname:VkDrawIndexedIndirectCommand)
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-maxDrawCount-00558]]
    If pname:maxDrawCount is greater than or equal to `1`,
    [eq]#(pname:stride {times} (pname:maxDrawCount - 1) {plus} pname:offset
    {plus} code:sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less
    than or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-firstInstance-00559]]
    If the
    <<features-features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndexedIndirectCommand structures accessed by this command
    must: be `0`
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-renderPass-00560]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-subpass-00561]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00562]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00563]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00564]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00565]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00566]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00567]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-00568]]
    If count stored in pname:countBuffer is equal to `1`, [eq]#(pname:offset
    {plus} code:sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less
    than or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-00569]]
    If count stored in pname:countBuffer is greater than `1`,
    [eq]#(pname:stride {times} (pname:drawCount - 1) {plus} pname:offset
    {plus} code:sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less
    than or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-drawCount-00570]]
    pname:drawCount must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00571]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00572]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00573]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00574]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00575]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00576]]
    If the <<features-features-robustBufferAccess,robust buffer access>>
    feature is not enabled, and any shader stage in the sname:VkPipeline
    object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage
    buffer, it must: not access values outside of the range of that buffer
    specified in the bound descriptor set
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-02022]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-01504]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-maxMultiviewInstanceIndex-00578]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-01865]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-01866]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer,
    that image or buffer must: not be an unprotected image or unprotected
    buffer.
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-01867]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage other than the framebuffer-space pipeline stages in the
    sname:VkPipeline object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS
    reads from or writes to any image or buffer, the image or buffer must:
    not be a protected image or protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-sampleLocationsEnable-01517]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
****

include::../validity/protos/vkCmdDrawIndexedIndirectCountAMD.txt[]

--
endif::VK_AMD_draw_indirect_count[]

ifdef::VK_EXT_conditional_rendering[]

[[drawing-conditional-rendering]]
== Conditional Rendering
Certain rendering commands can: be executed conditionally based on a value
in buffer memory.
These rendering commands are limited to <<drawing,drawing commands>>,
<<dispatch,dispatching commands>>, and clearing attachments with
flink:vkCmdClearAttachments within a conditional rendering block which is
defined by commands flink:vkCmdBeginConditionalRenderingEXT and
flink:vkCmdEndConditionalRenderingEXT.
Other rendering commands remain unaffected by conditional rendering.

[[active-conditional-rendering]]
After beginning conditional rendering, it is considered _active_ within the
command buffer it was called until it is ended with
flink:vkCmdEndConditionalRenderingEXT.

Conditional rendering must: begin and end in the same command buffer.
When conditional rendering is active, a primary command buffer can: execute
secondary command buffers if the
<<features-features-inheritedConditionalRendering, inherited conditional
rendering>> feature is enabled.
For a secondary command buffer to be executed while conditional rendering is
active in the primary command buffer, it must: set the
pname:conditionalRenderingEnable flag of
slink:VkCommandBufferInheritanceConditionalRenderingInfoEXT, as described in
the <<commandbuffers-recording, Command Buffer Recording>> section.

Conditional rendering must: also either begin and end inside the same
subpass of a render pass instance, or must: both begin and end outside of a
render pass instance (i.e. contain entire render pass instances).

[open,refpage='vkCmdBeginConditionalRenderingEXT',desc='Define the beginning of a conditional rendering block',type='protos']
--

To begin conditional rendering, call:

include::../api/protos/vkCmdBeginConditionalRenderingEXT.txt[]

  * pname:commandBuffer is the command buffer into which this command will
    be recorded.
  * pname:pConditionalRenderingBegin is a pointer to an instance of the
    slink:VkConditionalRenderingBeginInfoEXT structure specifying the
    parameters of conditional rendering.

.Valid Usage
****
  * [[VUID-vkCmdBeginConditionalRenderingEXT-None-01980]]
    Conditional rendering must: not already be
    <<active-conditional-rendering,active>>
****

include::../validity/protos/vkCmdBeginConditionalRenderingEXT.txt[]
--

[open,refpage='VkConditionalRenderingBeginInfoEXT',desc='Structure specifying conditional rendering begin info',type='structs']
--

The sname:VkConditionalRenderingBeginInfoEXT structure is defined as:

include::../api/structs/VkConditionalRenderingBeginInfoEXT.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:buffer is a buffer containing the predicate for conditional
    rendering.
  * pname:offset is the byte offset into pname:buffer where the predicate is
    located.
  * pname:flags is a bitmask of elink:VkConditionalRenderingFlagsEXT
    specifying the behavior of conditional rendering.

If the 32-bit value at pname:offset in pname:buffer memory is zero, then the
rendering commands are discarded, otherwise they are executed as normal.
If the value of the predicate in buffer memory changes while conditional
rendering is active, the rendering commands may: be discarded in an
implementation-dependent way.
Some implementations may latch the value of the predicate upon beginning
conditional rendering while others may read it before every rendering
command.

.Valid Usage
****
  * [[VUID-VkConditionalRenderingBeginInfoEXT-buffer-01981]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-VkConditionalRenderingBeginInfoEXT-buffer-01982]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT bit set
  * [[VUID-VkConditionalRenderingBeginInfoEXT-offset-01983]]
    pname:offset must: be less than the size of pname:buffer by at least 32
    bits.
  * [[VUID-VkConditionalRenderingBeginInfoEXT-offset-01984]]
    pname:offset must: be a multiple of 4
****

[open,refpage='VkConditionalRenderingFlagBitsEXT',desc='Specify the behavior of conditional rendering',type='enums']
--

Bits which can: be set in
flink:vkCmdBeginConditionalRenderingEXT::pname:flags specifying the behavior
of conditional rendering are:

include::../api/enums/VkConditionalRenderingFlagBitsEXT.txt[]

  * ename:VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT specifies the condition
    used to determine whether to discard rendering commands or not.
    That is, if the 32-bit predicate read from pname:buffer memory at
    pname:offset is zero, the rendering commands are not discarded, and if
    non zero, then they are discarded.

--

[open,refpage='VkConditionalRenderingFlagsEXT',desc='Bitmask of VkConditionalRenderingFlagBitsEXT',type='enums']
--
include::../api/flags/VkConditionalRenderingFlagsEXT.txt[]

sname:VkConditionalRenderingFlagsEXT is a bitmask type for setting a mask of
zero or more slink:VkConditionalRenderingFlagBitsEXT.

[open,refpage='vkCmdEndConditionalRenderingEXT',desc='Define the end of a conditional rendering block',type='protos']
--

To end conditional rendering, call:

include::../api/protos/vkCmdEndConditionalRenderingEXT.txt[]

  * pname:commandBuffer is the command buffer into which this command will
    be recorded.

Once ended, conditional rendering becomes inactive.

.Valid Usage
****
  * [[VUID-vkCmdEndConditionalRenderingEXT-None-01985]]
    Conditional rendering must: be <<active-conditional-rendering,active>>
  * [[VUID-vkCmdEndConditionalRenderingEXT-None-01986]]
    If conditional rendering was made
    <<active-conditional-rendering,active>> outside of a render pass
    instance, it must not be ended inside a render pass instance
  * [[VUID-vkCmdEndConditionalRenderingEXT-None-01987]]
    If conditional rendering was made
    <<active-conditional-rendering,active>> within a subpass it must be
    ended in the same subpass
****

include::../validity/protos/vkCmdEndConditionalRenderingEXT.txt[]
--

endif::VK_EXT_conditional_rendering[]
