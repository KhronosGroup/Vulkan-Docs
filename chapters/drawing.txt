// Copyright (c) 2015-2019 Khronos Group. This work is licensed under a
// Creative Commons Attribution 4.0 International License; see
// http://creativecommons.org/licenses/by/4.0/

[[drawing]]
= Drawing Commands

_Drawing commands_ (commands with ftext:Draw in the name) provoke work in a
graphics pipeline.
Drawing commands are recorded into a command buffer and when executed by a
queue, will produce work which executes according to the bound graphics
pipeline.
A graphics pipeline must: be bound to a command buffer before any drawing
commands are recorded in that command buffer.

[open,refpage='VkPipelineInputAssemblyStateCreateInfo',desc='Structure specifying parameters of a newly created pipeline input assembly state',type='structs']
--


ifdef::VK_NV_mesh_shader[]
Drawing can be achieved in two modes:

  * <<drawing-mesh-shading,Programmable Mesh Shading>>, the mesh shader
    assembles primitives, or
  * <<drawing-primitive-shading,Programmable Primitive Shading>>, the input
    primitives are assembled

as follows.
endif::VK_NV_mesh_shader[]

Each draw is made up of zero or more vertices and zero or more instances,
which are processed by the device and result in the assembly of primitives.
Primitives are assembled according to the pname:pInputAssemblyState member
of the sname:VkGraphicsPipelineCreateInfo structure, which is of type
sname:VkPipelineInputAssemblyStateCreateInfo:

include::../api/structs/VkPipelineInputAssemblyStateCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:flags is reserved for future use.
  * pname:topology is a elink:VkPrimitiveTopology defining the primitive
    topology, as described below.
  * pname:primitiveRestartEnable controls whether a special vertex index
    value is treated as restarting the assembly of primitives.
    This enable only applies to indexed draws (flink:vkCmdDrawIndexed and
    flink:vkCmdDrawIndexedIndirect), and the special index value is either
    0xFFFFFFFF when the pname:indexType parameter of
    fname:vkCmdBindIndexBuffer is equal to ename:VK_INDEX_TYPE_UINT32, or
    0xFFFF when pname:indexType is equal to ename:VK_INDEX_TYPE_UINT16.
    Primitive restart is not allowed for "`list`" topologies.

Restarting the assembly of primitives discards the most recent index values
if those elements formed an incomplete primitive, and restarts the primitive
assembly using the subsequent indices, but only assembling the immediately
following element through the end of the originally specified elements.
The primitive restart index value comparison is performed before adding the
pname:vertexOffset value to the index value.

.Valid Usage
****
  * [[VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00428]]
    If pname:topology is ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, pname:primitiveRestartEnable
    must: be ename:VK_FALSE
  * [[VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00429]]
    If the <<features-geometryShader,geometry shaders>> feature is not
    enabled, pname:topology must: not be any of
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or
    ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY
  * [[VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00430]]
    If the <<features-tessellationShader,tessellation shaders>> feature is
    not enabled, pname:topology must: not be
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST
****

include::../validity/structs/VkPipelineInputAssemblyStateCreateInfo.txt[]
--

[open,refpage='VkPipelineInputAssemblyStateCreateFlags',desc='Reserved for future use',type='flags']
--
include::../api/flags/VkPipelineInputAssemblyStateCreateFlags.txt[]

tname:VkPipelineInputAssemblyStateCreateFlags is a bitmask type for setting
a mask, but is currently reserved for future use.
--


[[drawing-primitive-topologies]]
== Primitive Topologies


_Primitive topology_ determines how consecutive vertices are organized into
primitives, and determines the type of primitive that is used at the
beginning of the graphics pipeline.
The effective topology for later stages of the pipeline is altered by
tessellation or geometry shading (if either is in use) and depends on the
execution modes of those shaders.
ifdef::VK_NV_mesh_shader[]
In the case of mesh shading the only effective topology is defined by the
execution mode of the mesh shader.
endif::VK_NV_mesh_shader[]

[open,refpage='VkPrimitiveTopology',desc='Supported primitive topologies',type='enums']
--

The primitive topologies defined by elink:VkPrimitiveTopology are:

include::../api/enums/VkPrimitiveTopology.txt[]

  * ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST specifies a series of
    <<drawing-point-lists,separate point primitives>>.
  * ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST specifies a series of
    <<drawing-line-lists,separate line primitives>>.
  * ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP specifies a series of
    <<drawing-line-strips,connected line primitives>> with consecutive lines
    sharing a vertex.
  * ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST specifies a series of
    <<drawing-triangle-lists,separate triangle primitives>>.
  * ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP specifies a series of
    <<drawing-triangle-strips,connected triangle primitives>> with
    consecutive triangles sharing an edge.
  * ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN specifies a series of
    <<drawing-triangle-fans,connected triangle primitives>> with all
    triangles sharing a common vertex.
  * ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY specifies a series
    <<drawing-line-lists-with-adjacency,separate line primitives with
    adjacency>>.
  * ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY specifies a series
    <<drawing-line-strips-with-adjacency,connected line primitives with
    adjacency>>, with consecutive primitives sharing three vertices.
  * ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY specifies a
    series <<drawing-line-lists-with-adjacency,separate triangle primitives
    with adjacency>>.
  * ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY specifies
    <<drawing-line-lists-with-adjacency,connected triangle primitives with
    adjacency>>, with consecutive triangles sharing an edge.
  * ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST specifies
    <<drawing-patch-lists,separate patch primitives>>.

Each primitive topology, and its construction from a list of vertices, is
described in detail below with a supporting diagram, according to the
following key:

[cols="1,2,9"]
|====
^.^| image:images/primitive_topology_key_vertex.svg[opts="{imageopts}"]
.^| Vertex
| A point in 3-dimensional space.
  Positions chosen within the diagrams are arbitrary and for
  illustration only.

^.^| image:images/primitive_topology_key_vertex_number.svg[opts="{imageopts}"]
.^| Vertex Number
| Sequence position of a vertex within the provided vertex data.

^.^| image:images/primitive_topology_key_provoking_vertex.svg[opts="{imageopts}"]
.^| Provoking Vertex
| Provoking vertex within the main primitive.
  The arrow points along an edge of the relevant primitive, following winding order.
  Used in <<vertexpostproc-flatshading, flat shading>>.

^.^| image:images/primitive_topology_key_edge.svg[opts="{imageopts}"]
.^| Primitive Edge
| An edge connecting the points of a main primitive.

^.^| image:images/primitive_topology_key_adjacency_edge.svg[opts="{imageopts}"]
.^| Adjacency Edge
| Points connected by these lines do not contribute to a main primitive,
  and are only accessible in a <<geometry,geometry shader>>.

^.^| image:images/primitive_topology_key_winding_order.svg[opts="{imageopts}"]
.^| Winding Order
| The relative order in which vertices are defined within a primitive,
  used in the <<primsrast-polygons-basic,facing determination>>.
  This ordering has no specific start or end point.
|====

The diagrams are supported with mathematical definitions where the vertices
and primitives are numbered starting from [eq]#0#; [eq]#vertex~0~# is the
first vertex in the provided data and [eq]#primitive~0~# is the first
primitive in the set of primitives defined by the vertices and topology.
--


[[drawing-point-lists]]
=== Point Lists

When the topology is ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST, each
consecutive vertex defines a single point primitive, according to the
equation:

  :: [eq]#primitive~i~ = {vertex~i~}#

As there is only one vertex, that vertex is the provoking vertex.
The number of primitives generated is equal to [eq]#pname:vertexCount#.

image::images/primitive_topology_point_list.svg[align="center",opts="{imageopts}"]


[[drawing-line-lists]]
=== Line Lists

When the pname:topology is ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST, each
consecutive pair of vertices defines a single line primitive, according to
the equation:

  :: [eq]#primitive~i~ = {vertex~2i~, vertex~2i+1~}#

The provoking vertex for [eq]#primitive~i~# is [eq]#vertex~2i~#.
The number of primitives generated is equal to
[eq]#{lfloor}pname:vertexCount/2{rfloor}#.

image::images/primitive_topology_line_list.svg[align="center",opts="{imageopts}"]


[[drawing-line-strips]]
=== Line Strips

When the pname:topology is ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP, one line
primitive is defined by each vertex and the following vertex, according to
the equation:

  :: [eq]#primitive~i~ = {vertex~i~, vertex~i+1~}#

The provoking vertex for [eq]#primitive~i~# is [eq]#vertex~i~#.
The number of primitives generated is equal to
[eq]#max(0,pname:vertexCount-1)#.


image::images/primitive_topology_line_strip.svg[align="center",opts="{imageopts}"]


[[drawing-triangle-lists]]
=== Triangle Lists

When the pname:topology is ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, each
consecutive set of three vertices defines a single triangle primitive,
according to the equation:

  :: [eq]#primitive~i~ = {vertex~3i~, vertex~3i+1~, vertex~3i+2~}#

The provoking vertex for [eq]#primitive~i~# is [eq]#vertex~3i~#.
The number of primitives generated is equal to
[eq]#{lfloor}pname:vertexCount/3{rfloor}#.

image::images/primitive_topology_triangle_list.svg[align="center",opts="{imageopts}"]


[[drawing-triangle-strips]]
=== Triangle Strips

When the pname:topology is ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP, one
triangle primitive is defined by each vertex and the two vertices that
follow it, according to the equation:

  :: [eq]#primitive~i~ = {vertex~i~, vertex~i+(1+i%2)~, vertex~i+(2-i%2)~}#

The provoking vertex for [eq]#primitive~i~# is [eq]#vertex~i~#.
The number of primitives generated is equal to
[eq]#max(0,pname:vertexCount-2)#.

image::images/primitive_topology_triangle_strip.svg[align="center",opts="{imageopts}"]

[NOTE]
.Note
====
The ordering of the vertices in each successive triangle is reversed, so
that the winding order is consistent throughout the strip.
====


[[drawing-triangle-fans]]
=== Triangle Fans

When the pname:topology is ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
triangle primitives are defined around a shared common vertex, according to
the equation:

  :: [eq]#primitive~i~ = {vertex~i+1~, vertex~i+2~, vertex~0~}#

The provoking vertex for [eq]#primitive~i~# is [eq]#vertex~i+1~#.
The number of primitives generated is equal to
[eq]#max(0,pname:vertexCount-2)#.

image::images/primitive_topology_triangle_fan.svg[align="center",opts="{imageopts}"]


[[drawing-line-lists-with-adjacency]]
=== Line Lists With Adjacency

When the pname:topology is
ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, each consecutive set
of four vertices defines a single line primitive with adjacency, according
to the equation:

  :: [eq]#primitive~i~ = {vertex~4i~, vertex~4i+1~,
     vertex~4i+2~,vertex~4i+3~}#

A line primitive is described by the second and third vertices of the total
primitive, with the remaining two vertices only accessible in a
<<geometry,geometry shader>>.

The provoking vertex for [eq]#primitive~i~# is [eq]#vertex~4i+1~#.
The number of primitives generated is equal to
[eq]#{lfloor}pname:vertexCount/4{rfloor}#.

image::images/primitive_topology_line_list_with_adjacency.svg[align="center",opts="{imageopts}"]


[[drawing-line-strips-with-adjacency]]
=== Line Strips With Adjacency

When the pname:topology is
ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY, one line primitive
with adjacency is defined by each vertex and the following vertex, according
to the equation:

  :: [eq]#primitive~i~ = {vertex~i~, vertex~i+1~, vertex~i+2~, vertex~i+3~}#

A line primitive is described by the second and third vertices of the total
primitive, with the remaining two vertices only accessible in a
<<geometry,geometry shader>>.

The provoking vertex for [eq]#primitive~i~# is [eq]#vertex~i+1~#.
The number of primitives generated is equal to
[eq]#max(0,pname:vertexCount-3)#.

image::images/primitive_topology_line_strip_with_adjacency.svg[align="center",opts="{imageopts}"]


[[drawing-triangle-lists-with-adjacency]]
=== Triangle Lists With Adjacency

When the pname:topology is
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY, each consecutive
set of six vertices defines a single triangle primitive with adjacency,
according to the equations:

  :: [eq]#primitive~i~ = {vertex~6i~, vertex~6i+1~, vertex~6i+2~,
     vertex~6i+3~, vertex~6i+4~, vertex~6i+5~}#

A triangle primitive is described by the first, third, and fifth vertices of
the total primitive, with the remaining three vertices only accessible in a
<<geometry,geometry shader>>.

The provoking vertex for [eq]#primitive~i~# is [eq]#vertex~6i~#.
The number of primitives generated is equal to
[eq]#{lfloor}pname:vertexCount/6{rfloor}#.

image::images/primitive_topology_triangle_list_with_adjacency.svg[align="center",opts="{imageopts}"]


[[drawing-triangle-strips-with-adjacency]]
=== Triangle Strips With Adjacency

When the pname:topology is
ename:VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY, one triangle
primitive with adjacency is defined by each vertex and the following 5
vertices.

The number of primitives generated, [eq]#n#, is equal to [eq]#{lfloor}max(0,
pname:vertexCount - 4)/2{rfloor}#.

If [eq]#n=1#, the primitive is defined as:

  :: [eq]#primitive = {vertex~0~, vertex~1~, vertex~2~, vertex~5~,
     vertex~4~, vertex~3~}#

If [eq]#n>1#, the total primitive consists of different vertices according
to where it is in the strip:

  :: [eq]#primitive~i~ = {vertex~2i~, vertex~2i+1~, vertex~2i+2~,
     vertex~2i+6~, vertex~2i+4~, vertex~2i+3~}# when [eq]#i=0#
  :: [eq]#primitive~i~ = {vertex~2i~, vertex~2i+3~, vertex~2i+4~,
     vertex~2i+6~, vertex~2i+2~, vertex~2i-2~}# when [eq]#i>0#, [eq]#i<n-1#,
     and [eq]#i%2=1#
  :: [eq]#primitive~i~ = {vertex~2i~, vertex~2i-2~, vertex~2i+2~,
     vertex~2i+6~, vertex~2i+4~, vertex~2i+3~}# when [eq]#i>0#, [eq]#i<n-1#,
     and [eq]#i%2=0#
  :: [eq]#primitive~i~ = {vertex~2i~, vertex~2i+3~, vertex~2i+4~,
     vertex~2i+5~, vertex~2i+2~, vertex~2i-2~}# when [eq]#i=n-1# and
     [eq]#i%2=1#
  :: [eq]#primitive~i~ = {vertex~2i~, vertex~2i-2~, vertex~2i+2~,
     vertex~2i+5~, vertex~2i+4~, vertex~2i+3~}# when [eq]#i=n-1# and
     [eq]#i%2=0#

A triangle primitive is described by the first, third, and fifth vertices of
the total primitive in all cases, with the remaining three vertices only
accessible in a <<geometry,geometry shader>>.

[NOTE]
.Note
====
The ordering of the vertices in each successive triangle is altered so that
the winding order is consistent throughout the strip.
====

The provoking vertex for [eq]#primitive~i~# is always [eq]#vertex~2i~#.

image::images/primitive_topology_triangle_strip_with_adjacency.svg[align="center",opts="{imageopts}"]


[[drawing-patch-lists]]
=== Patch Lists

When the pname:topology is ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, each
consecutive set of [eq]#v# vertices defines a single patch primitive,
according to the equation:

  :: [eq]#primitive~i~ = {vertex~vi~, vertex~vi+1~, ..., vertex~vi+(v-2)~,
     vertex~vi+(v-1)~}#

where [eq]#v# is equal to
slink:VkPipelineTessellationStateCreateInfo::pname:patchControlPoints.

Patch lists are never passed to <<vertexpostproc, vertex post-processing>>,
and as such no provoking vertex is defined for patch primitives.
The number of primitives generated is equal to
[eq]#{lfloor}pname:vertexCount/v{rfloor}#.

The vertices comprising a patch have no implied geometry, and are used as
inputs to tessellation shaders and the fixed-function tessellator to
generate new point, line, or triangle primitives.


[[drawing-primitive-order]]
== Primitive Order

Primitives generated by <<drawing, drawing commands>> progress through the
stages of the <<synchronization-pipeline-stages-types, graphics pipeline>>
in _primitive order_.
Primitive order is initially determined in the following way:

  . Submission order determines the initial ordering
  . For indirect draw commands, the order in which accessed instances of the
    slink:VkDrawIndirectCommand are stored in pname:buffer, from lower
    indirect buffer addresses to higher addresses.
  . If a draw command includes multiple instances, the order in which
    instances are executed, from lower numbered instances to higher.
  . The order in which primitives are specified by a draw command:
  ** For non-indexed draws, from vertices with a lower numbered
     code:vertexIndex to a higher numbered code:vertexIndex.
  ** For indexed draws, vertices sourced from a lower index buffer addresses
     to higher addresses.
ifdef::VK_NV_mesh_shader[]
  ** For draws using mesh shaders, the order is provided by <<mesh-ordering,
     mesh shading>>.
endif::VK_NV_mesh_shader[]

Within this order implementations further sort primitives:

[start=5]
  . If tessellation shading is active, by an implementation-dependent order
    of new primitives generated by <<tessellation-primitive-order,
    tessellation>>.
  . If geometry shading is active, by the order new primitives are generated
    by <<geometry-ordering, geometry shading>>.
  . If the <<primsrast-polygonmode,polygon mode>> is not
    ename:VK_POLYGON_MODE_FILL,
ifdef::VK_NV_fill_rectangle[]
    or ename:VK_POLYGON_MODE_FILL_RECTANGLE_NV,
endif::VK_NV_fill_rectangle[]
    by an implementation-dependent ordering of the new primitives generated
    within the original primitive.

Primitive order is later used to define <<primrast-order, rasterization
order>>, which determines the order in which fragments output results to a
framebuffer.


[[drawing-primitive-shading]]
== Programmable Primitive Shading

Once primitives are assembled, they proceed to the vertex shading stage of
the pipeline.
If the draw includes multiple instances, then the set of primitives is sent
to the vertex shading stage multiple times, once for each instance.

It is implementation-dependent whether vertex shading occurs on vertices
that are discarded as part of incomplete primitives, but if it does occur
then it operates as if they were vertices in complete primitives and such
invocations can: have side effects.

Vertex shading receives two per-vertex inputs from the primitive assembly
stage - the code:vertexIndex and the code:instanceIndex.
How these values are generated is defined below, with each command.

Drawing commands fall roughly into two categories:

  * Non-indexed drawing commands present a sequential code:vertexIndex to
    the vertex shader.
    The sequential index is generated automatically by the device (see
    <<fxvertex,Fixed-Function Vertex Processing>> for details on both
    specifying the vertex attributes indexed by code:vertexIndex, as well as
    binding vertex buffers containing those attributes to a command buffer).
    These commands are:
  ** flink:vkCmdDraw
  ** flink:vkCmdDrawIndirect
ifdef::VK_KHR_draw_indirect_count[]
  ** flink:vkCmdDrawIndirectCountKHR
endif::VK_KHR_draw_indirect_count[]
ifdef::VK_AMD_draw_indirect_count[]
  ** flink:vkCmdDrawIndirectCountAMD.
endif::VK_AMD_draw_indirect_count[]
  * Indexed drawing commands read index values from an _index buffer_ and
    use this to compute the code:vertexIndex value for the vertex shader.
    These commands are:
  ** flink:vkCmdDrawIndexed
  ** flink:vkCmdDrawIndexedIndirect
ifdef::VK_KHR_draw_indirect_count[]
  ** flink:vkCmdDrawIndexedIndirectCountKHR
endif::VK_KHR_draw_indirect_count[]
ifdef::VK_AMD_draw_indirect_count[]
  ** flink:vkCmdDrawIndexedIndirectCountAMD.
endif::VK_AMD_draw_indirect_count[]


[open,refpage='vkCmdBindIndexBuffer',desc='Bind an index buffer to a command buffer',type='protos']
--

To bind an index buffer to a command buffer, call:

include::../api/protos/vkCmdBindIndexBuffer.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer being bound.
  * pname:offset is the starting offset in bytes within pname:buffer used in
    index buffer address calculations.
  * pname:indexType is a elink:VkIndexType value specifying whether indices
    are treated as 16 bits or 32 bits.

.Valid Usage
****
  * [[VUID-vkCmdBindIndexBuffer-offset-00431]]
    pname:offset must: be less than the size of pname:buffer
  * [[VUID-vkCmdBindIndexBuffer-offset-00432]]
    The sum of pname:offset and the address of the range of
    sname:VkDeviceMemory object that is backing pname:buffer, must: be a
    multiple of the type indicated by pname:indexType
  * [[VUID-vkCmdBindIndexBuffer-buffer-00433]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT flag
  * [[VUID-vkCmdBindIndexBuffer-buffer-00434]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
ifdef::VK_NV_ray_tracing[]
  * [[VUID-vkCmdBindIndexBuffer-indexType-02507]]
    pname:indexType must: not be ename:VK_INDEX_TYPE_NONE_NV.
endif::VK_NV_ray_tracing[]
****

include::../validity/protos/vkCmdBindIndexBuffer.txt[]
--


[open,refpage='VkIndexType',desc='Type of index buffer indices',type='enums']
--

Possible values of flink:vkCmdBindIndexBuffer::pname:indexType, specifying
the size of indices, are:

include::../api/enums/VkIndexType.txt[]

  * ename:VK_INDEX_TYPE_UINT16 specifies that indices are 16-bit unsigned
    integer values.
  * ename:VK_INDEX_TYPE_UINT32 specifies that indices are 32-bit unsigned
    integer values.
ifdef::VK_NV_ray_tracing[]
  * ename:VK_INDEX_TYPE_NONE_NV specifies that no indices are provided.
endif::VK_NV_ray_tracing[]
--

The parameters for each drawing command are specified directly in the
command or read from buffer memory, depending on the command.
Drawing commands that source their parameters from buffer memory are known
as _indirect_ drawing commands.

All drawing commands interact with the <<features-robustBufferAccess, Robust
Buffer Access>> feature.

[open,refpage='vkCmdDraw',desc='Draw primitives',type='protos']
--

To record a non-indexed draw, call:

include::../api/protos/vkCmdDraw.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:vertexCount is the number of vertices to draw.
  * pname:instanceCount is the number of instances to draw.
  * pname:firstVertex is the index of the first vertex to draw.
  * pname:firstInstance is the instance ID of the first instance to draw.

When the command is executed, primitives are assembled using the current
primitive topology and pname:vertexCount consecutive vertex indices with the
first code:vertexIndex value equal to pname:firstVertex.
The primitives are drawn pname:instanceCount times with code:instanceIndex
starting with pname:firstInstance and increasing sequentially for each
instance.
The assembled primitives execute the bound graphics pipeline.

.Valid Usage
****
  * [[VUID-vkCmdDraw-renderPass-00435]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDraw-subpass-00436]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDraw-None-00437]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDraw-None-00438]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDraw-None-00439]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDraw-None-00440]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDraw-None-00441]]
    For a given vertex buffer binding, any attribute data fetched must: be
    entirely contained within the corresponding vertex buffer binding, as
    described in <<fxvertex-input>>
  * [[VUID-vkCmdDraw-None-00442]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDraw-None-00443]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDraw-None-00444]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDraw-None-00445]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDraw-None-00446]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDraw-None-00447]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDraw-None-00448]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDraw-None-00449]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDraw-None-01499]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
  * [[VUID-vkCmdDraw-None-02009]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
ifdef::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDraw-None-02010]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
ifndef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDraw-None-00452]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_EXT_filter_cubic[]
ifdef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDraw-filterCubic-02613]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: have a elink:VkImageViewType and format
    that supports cubic filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubic
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
  * [[VUID-vkCmdDraw-filterCubicMinmax-02614]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT with
    a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must: have
    a elink:VkImageViewType and format that supports cubic filtering
    together with minmax filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubicMinmax
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
endif::VK_EXT_filter_cubic[]
endif::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDraw-maxMultiviewInstanceIndex-00453]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDraw-commandBuffer-01850]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
  * [[VUID-vkCmdDraw-commandBuffer-01851]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer,
    that image or buffer must: not be an unprotected image or unprotected
    buffer.
  * [[VUID-vkCmdDraw-commandBuffer-01852]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage other than the framebuffer-space pipeline stages in the
    sname:VkPipeline object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS
    reads from or writes to any image or buffer, the image or buffer must:
    not be a protected image or protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDraw-sampleLocationsEnable-01512]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
ifdef::VK_NV_corner_sampled_image[]
  * [[VUID-vkCmdDraw-flags-02042]]
    Any slink:VkImage created with a slink:VkImageCreateInfo::pname:flags
    containing ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a
    result of this command must: only be sampled using a
    elink:VkSamplerAddressMode of
    ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
endif::VK_NV_corner_sampled_image[]
****

include::../validity/protos/vkCmdDraw.txt[]
--

[open,refpage='vkCmdDrawIndexed',desc='Issue an indexed draw into a command buffer',type='protos']
--

To record an indexed draw, call:

include::../api/protos/vkCmdDrawIndexed.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:indexCount is the number of vertices to draw.
  * pname:instanceCount is the number of instances to draw.
  * pname:firstIndex is the base index within the index buffer.
  * pname:vertexOffset is the value added to the vertex index before
    indexing into the vertex buffer.
  * pname:firstInstance is the instance ID of the first instance to draw.

When the command is executed, primitives are assembled using the current
primitive topology and pname:indexCount vertices whose indices are retrieved
from the index buffer.
The index buffer is treated as an array of tightly packed unsigned integers
of size defined by the flink:vkCmdBindIndexBuffer::pname:indexType parameter
with which the buffer was bound.

The first vertex index is at an offset of pname:firstIndex * code:indexSize
+ pname:offset within the bound index buffer, where pname:offset is the
offset specified by fname:vkCmdBindIndexBuffer and code:indexSize is the
byte size of the type specified by pname:indexType.
Subsequent index values are retrieved from consecutive locations in the
index buffer.
Indices are first compared to the primitive restart value, then zero
extended to 32 bits (if the code:indexType is ename:VK_INDEX_TYPE_UINT16)
and have pname:vertexOffset added to them, before being supplied as the
code:vertexIndex value.

The primitives are drawn pname:instanceCount times with code:instanceIndex
starting with pname:firstInstance and increasing sequentially for each
instance.
The assembled primitives execute the bound graphics pipeline.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndexed-renderPass-00454]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexed-subpass-00455]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexed-None-00456]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexed-None-00457]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexed-None-00458]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndexed-None-00459]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndexed-None-00460]]
    For a given vertex buffer binding, any attribute data fetched must: be
    entirely contained within the corresponding vertex buffer binding, as
    described in <<fxvertex-input>>
  * [[VUID-vkCmdDrawIndexed-None-00461]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndexed-None-00462]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndexed-indexSize-00463]]
    [eq]#(code:indexSize * (pname:firstIndex {plus} pname:indexCount) {plus}
    pname:offset)# must: be less than or equal to the size of the bound
    index buffer, with code:indexSize being based on the type specified by
    pname:indexType, where the index buffer, pname:indexType, and
    pname:offset are specified via fname:vkCmdBindIndexBuffer
  * [[VUID-vkCmdDrawIndexed-None-00464]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndexed-None-00465]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndexed-None-00466]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndexed-None-00467]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndexed-None-00468]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndexed-None-00469]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndexed-None-02011]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndexed-None-01500]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndexed-None-02012]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
ifndef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndexed-None-00472]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_EXT_filter_cubic[]
ifdef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndexed-filterCubic-02615]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: have a elink:VkImageViewType and format
    that supports cubic filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubic
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
  * [[VUID-vkCmdDrawIndexed-filterCubicMinmax-02616]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT with
    a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must: have
    a elink:VkImageViewType and format that supports cubic filtering
    together with minmax filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubicMinmax
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
endif::VK_EXT_filter_cubic[]
endif::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndexed-maxMultiviewInstanceIndex-00473]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndexed-commandBuffer-01853]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
  * [[VUID-vkCmdDrawIndexed-commandBuffer-01854]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer,
    that image or buffer must: not be an unprotected image or unprotected
    buffer.
  * [[VUID-vkCmdDrawIndexed-commandBuffer-01855]]
    If pname:commandBuffer is a protected command buffer, and any pipeline
    stage other than the framebuffer-space pipeline stages in the
    sname:VkPipeline object bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS
    reads from or writes to any image or buffer, the image or buffer must:
    not be a protected image or protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndexed-sampleLocationsEnable-01513]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
ifdef::VK_NV_corner_sampled_image[]
  * [[VUID-vkCmdDrawIndexed-flags-02043]]
    Any slink:VkImage created with a slink:VkImageCreateInfo::pname:flags
    containing ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a
    result of this command must: only be sampled using a
    elink:VkSamplerAddressMode of
    ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
endif::VK_NV_corner_sampled_image[]
****

include::../validity/protos/vkCmdDrawIndexed.txt[]
--

[open,refpage='vkCmdDrawIndirect',desc='Issue an indirect draw into a command buffer',type='protos']
--

To record a non-indexed indirect draw, call:

include::../api/protos/vkCmdDrawIndirect.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:drawCount is the number of draws to execute, and can: be zero.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndirect behaves similarly to flink:vkCmdDraw except that the
parameters are read by the device from a buffer during execution.
pname:drawCount draws are executed by the command, with parameters taken
from pname:buffer starting at pname:offset and increasing by pname:stride
bytes for each successive draw.
The parameters of each draw are encoded in an array of
slink:VkDrawIndirectCommand structures.
If pname:drawCount is less than or equal to one, pname:stride is ignored.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndirect-buffer-00474]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndirect-buffer-01660]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndirect-offset-00475]]
    pname:offset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndirect-drawCount-00476]]
    If pname:drawCount is greater than `1`, pname:stride must: be a multiple
    of `4` and must: be greater than or equal to
    code:sizeof(sname:VkDrawIndirectCommand)
  * [[VUID-vkCmdDrawIndirect-drawCount-00477]]
    If the <<features-multiDrawIndirect,multi-draw indirect>> feature is not
    enabled, pname:drawCount must: be `0` or `1`
  * [[VUID-vkCmdDrawIndirect-firstInstance-00478]]
    If the <<features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndirectCommand structures accessed by this command must: be
    code:0
  * [[VUID-vkCmdDrawIndirect-renderPass-00479]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndirect-subpass-00480]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndirect-None-00481]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirect-None-00482]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirect-None-00483]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndirect-None-00484]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndirect-None-00485]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndirect-None-00486]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndirect-drawCount-00487]]
    If pname:drawCount is equal to `1`, [eq]#(pname:offset {plus}
    code:sizeof(slink:VkDrawIndirectCommand))# must: be less than or equal
    to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirect-drawCount-00488]]
    If pname:drawCount is greater than `1`, [eq]#(pname:stride {times}
    (pname:drawCount - 1) {plus} pname:offset {plus}
    code:sizeof(slink:VkDrawIndirectCommand))# must: be less than or equal
    to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirect-drawCount-00489]]
    pname:drawCount must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * [[VUID-vkCmdDrawIndirect-None-00490]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndirect-None-00491]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndirect-None-00492]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndirect-None-00493]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndirect-None-00494]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndirect-None-00495]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndirect-None-02013]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndirect-None-01501]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndirect-None-02014]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
ifndef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndirect-None-00498]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_EXT_filter_cubic[]
ifdef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndirect-filterCubic-02617]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: have a elink:VkImageViewType and format
    that supports cubic filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubic
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
  * [[VUID-vkCmdDrawIndirect-filterCubicMinmax-02618]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT with
    a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must: have
    a elink:VkImageViewType and format that supports cubic filtering
    together with minmax filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubicMinmax
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
endif::VK_EXT_filter_cubic[]
endif::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndirect-maxMultiviewInstanceIndex-00499]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndirect-commandBuffer-02640]]
    pname:commandBuffer must: not be a protected command buffer
  * [[VUID-vkCmdDrawIndirect-commandBuffer-01856]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndirect-sampleLocationsEnable-01514]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
ifdef::VK_NV_corner_sampled_image[]
  * [[VUID-vkCmdDrawIndirect-flags-02044]]
    Any slink:VkImage created with a slink:VkImageCreateInfo::pname:flags
    containing ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a
    result of this command must: only be sampled using a
    elink:VkSamplerAddressMode of
    ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
endif::VK_NV_corner_sampled_image[]
****

include::../validity/protos/vkCmdDrawIndirect.txt[]
--

[open,refpage='VkDrawIndirectCommand',desc='Structure specifying a draw indirect command',type='structs',xrefs='vkCmdDrawIndirect']
--

The sname:VkDrawIndirectCommand structure is defined as:

include::../api/structs/VkDrawIndirectCommand.txt[]

  * pname:vertexCount is the number of vertices to draw.
  * pname:instanceCount is the number of instances to draw.
  * pname:firstVertex is the index of the first vertex to draw.
  * pname:firstInstance is the instance ID of the first instance to draw.

The members of sname:VkDrawIndirectCommand have the same meaning as the
similarly named parameters of flink:vkCmdDraw.

.Valid Usage
****
  * [[VUID-VkDrawIndirectCommand-None-00500]]
    For a given vertex buffer binding, any attribute data fetched must: be
    entirely contained within the corresponding vertex buffer binding, as
    described in <<fxvertex-input>>
  * [[VUID-VkDrawIndirectCommand-firstInstance-00501]]
    If the <<features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, pname:firstInstance must: be code:0
****

include::../validity/structs/VkDrawIndirectCommand.txt[]

--

ifdef::VK_KHR_draw_indirect_count[]
[open,refpage='vkCmdDrawIndirectCountKHR',desc='Perform an indirect draw with the draw count sourced from a buffer',type='protos']
--

To record a non-indexed draw call with a draw call count sourced from a
buffer, call:

include::../api/protos/vkCmdDrawIndirectCountKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:countBuffer is the buffer containing the draw count.
  * pname:countBufferOffset is the byte offset into pname:countBuffer where
    the draw count begins.
  * pname:maxDrawCount specifies the maximum number of draws that will be
    executed.
    The actual number of executed draw calls is the minimum of the count
    specified in pname:countBuffer and pname:maxDrawCount.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndirectCountKHR behaves similarly to flink:vkCmdDrawIndirect
except that the draw count is read by the device from a buffer during
execution.
The command will read an unsigned 32-bit integer from pname:countBuffer
located at pname:countBufferOffset and use this as the draw count.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndirectCountKHR-buffer-03104]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndirectCountKHR-buffer-03105]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndirectCountKHR-countBuffer-03106]]
    If pname:countBuffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndirectCountKHR-countBuffer-03107]]
    pname:countBuffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndirectCountKHR-offset-03108]]
    pname:offset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndirectCountKHR-countBufferOffset-03109]]
    pname:countBufferOffset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndirectCountKHR-stride-03110]]
    pname:stride must: be a multiple of `4` and must: be greater than or
    equal to sizeof(sname:VkDrawIndirectCommand)
  * [[VUID-vkCmdDrawIndirectCountKHR-maxDrawCount-03111]]
    If pname:maxDrawCount is greater than or equal to `1`,
    [eq]#(pname:stride {times} (pname:maxDrawCount - 1) {plus} pname:offset
    {plus} sizeof(sname:VkDrawIndirectCommand))# must: be less than or equal
    to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirectCountKHR-firstInstance-03112]]
    If the <<features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndirectCommand structures accessed by this command must: be
    code:0
  * [[VUID-vkCmdDrawIndirectCountKHR-renderPass-03113]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndirectCountKHR-subpass-03114]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03115]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03116]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03117]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03118]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03119]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03120]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndirectCountKHR-countBuffer-03121]]
    If the count stored in pname:countBuffer is equal to `1`,
    [eq]#(pname:offset {plus} sizeof(sname:VkDrawIndirectCommand))# must: be
    less than or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirectCountKHR-countBuffer-03122]]
    If the count stored in pname:countBuffer is greater than `1`,
    [eq]#(pname:stride {times} (pname:drawCount - 1) {plus} pname:offset
    {plus} sizeof(sname:VkDrawIndirectCommand))# must: be less than or equal
    to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirectCountKHR-countBuffer-03123]]
    The count stored in pname:countBuffer must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03124]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03125]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03126]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03127]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03128]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03129]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndirectCountKHR-None-02015]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03131]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndirectCountKHR-None-02016]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
ifndef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndirectCountKHR-None-03170]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_EXT_filter_cubic[]
ifdef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndirectCountKHR-filterCubic-02619]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: have a elink:VkImageViewType and format
    that supports cubic filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubic
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
  * [[VUID-vkCmdDrawIndirectCountKHR-filterCubicMinmax-02620]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT with
    a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must: have
    a elink:VkImageViewType and format that supports cubic filtering
    together with minmax filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubicMinmax
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
endif::VK_EXT_filter_cubic[]
endif::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndirectCountKHR-maxMultiviewInstanceIndex-03132]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndirectCountKHR-commandBuffer-02641]]
    pname:commandBuffer must: not be a protected command buffer
  * [[VUID-vkCmdDrawIndirectCountKHR-commandBuffer-03133]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndirectCountKHR-sampleLocationsEnable-03171]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
ifdef::VK_NV_corner_sampled_image[]
  * [[VUID-vkCmdDrawIndirectCountKHR-flags-02045]]
    Any slink:VkImage created with a slink:VkImageCreateInfo::pname:flags
    containing ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a
    result of this command must: only be sampled using a
    elink:VkSamplerAddressMode of
    ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
endif::VK_NV_corner_sampled_image[]
****

include::../validity/protos/vkCmdDrawIndirectCountKHR.txt[]

--
endif::VK_KHR_draw_indirect_count[]

ifdef::VK_AMD_draw_indirect_count[]
[open,refpage='vkCmdDrawIndirectCountAMD',desc='Perform an indirect draw with the draw count sourced from a buffer',type='protos']
--

To record a non-indexed draw call with a draw call count sourced from a
buffer, call:

include::../api/protos/vkCmdDrawIndirectCountAMD.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:countBuffer is the buffer containing the draw count.
  * pname:countBufferOffset is the byte offset into pname:countBuffer where
    the draw count begins.
  * pname:maxDrawCount specifies the maximum number of draws that will be
    executed.
    The actual number of executed draw calls is the minimum of the count
    specified in pname:countBuffer and pname:maxDrawCount.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndirectCountAMD behaves similarly to flink:vkCmdDrawIndirect
except that the draw count is read by the device from a buffer during
execution.
The command will read an unsigned 32-bit integer from pname:countBuffer
located at pname:countBufferOffset and use this as the draw count.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndirectCountAMD-buffer-01661]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndirectCountAMD-buffer-01662]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndirectCountAMD-countBuffer-01663]]
    If pname:countBuffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndirectCountAMD-countBuffer-01664]]
    pname:countBuffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndirectCountAMD-offset-00502]]
    pname:offset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndirectCountAMD-countBufferOffset-00503]]
    pname:countBufferOffset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndirectCountAMD-stride-00504]]
    pname:stride must: be a multiple of `4` and must: be greater than or
    equal to code:sizeof(sname:VkDrawIndirectCommand)
  * [[VUID-vkCmdDrawIndirectCountAMD-maxDrawCount-00505]]
    If pname:maxDrawCount is greater than or equal to `1`,
    [eq]#(pname:stride {times} (pname:maxDrawCount - 1) {plus} pname:offset
    {plus} code:sizeof(sname:VkDrawIndirectCommand))# must: be less than or
    equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirectCountAMD-firstInstance-00506]]
    If the <<features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndirectCommand structures accessed by this command must: be
    code:0
  * [[VUID-vkCmdDrawIndirectCountAMD-renderPass-00507]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndirectCountAMD-subpass-00508]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00509]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00510]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00511]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00512]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00513]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00514]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndirectCountAMD-countBuffer-00515]]
    If the count stored in pname:countBuffer is equal to `1`,
    [eq]#(pname:offset {plus} code:sizeof(sname:VkDrawIndirectCommand))#
    must: be less than or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirectCountAMD-countBuffer-00516]]
    If the count stored in pname:countBuffer is greater than `1`,
    [eq]#(pname:stride {times} (pname:drawCount - 1) {plus} pname:offset
    {plus} code:sizeof(sname:VkDrawIndirectCommand))# must: be less than or
    equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndirectCountAMD-countBuffer-00517]]
    The count stored in pname:countBuffer must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00518]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00519]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00520]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00521]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00522]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndirectCountAMD-None-00523]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndirectCountAMD-None-02017]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndirectCountAMD-None-01502]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndirectCountAMD-maxMultiviewInstanceIndex-00525]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndirectCountAMD-commandBuffer-02642]]
    pname:commandBuffer must: not be a protected command buffer
  * [[VUID-vkCmdDrawIndirectCountAMD-commandBuffer-01859]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndirectCountAMD-sampleLocationsEnable-01515]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
ifdef::VK_NV_corner_sampled_image[]
  * [[VUID-vkCmdDrawIndirectCountAMD-flags-02046]]
    Any slink:VkImage created with a slink:VkImageCreateInfo::pname:flags
    containing ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a
    result of this command must: only be sampled using a
    elink:VkSamplerAddressMode of
    ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
endif::VK_NV_corner_sampled_image[]
****

include::../validity/protos/vkCmdDrawIndirectCountAMD.txt[]

--
endif::VK_AMD_draw_indirect_count[]

[open,refpage='vkCmdDrawIndexedIndirect',desc='Perform an indexed indirect draw',type='protos']
--

To record an indexed indirect draw, call:

include::../api/protos/vkCmdDrawIndexedIndirect.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:drawCount is the number of draws to execute, and can: be zero.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndexedIndirect behaves similarly to flink:vkCmdDrawIndexed
except that the parameters are read by the device from a buffer during
execution.
pname:drawCount draws are executed by the command, with parameters taken
from pname:buffer starting at pname:offset and increasing by pname:stride
bytes for each successive draw.
The parameters of each draw are encoded in an array of
slink:VkDrawIndexedIndirectCommand structures.
If pname:drawCount is less than or equal to one, pname:stride is ignored.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndexedIndirect-buffer-00526]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndexedIndirect-buffer-01665]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndexedIndirect-offset-00527]]
    pname:offset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndexedIndirect-drawCount-00528]]
    If pname:drawCount is greater than `1`, pname:stride must: be a multiple
    of `4` and must: be greater than or equal to
    code:sizeof(sname:VkDrawIndexedIndirectCommand)
  * [[VUID-vkCmdDrawIndexedIndirect-drawCount-00529]]
    If the <<features-multiDrawIndirect,multi-draw indirect>> feature is not
    enabled, pname:drawCount must: be `0` or `1`
  * [[VUID-vkCmdDrawIndexedIndirect-firstInstance-00530]]
    If the <<features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndexedIndirectCommand structures accessed by this command
    must: be code:0
  * [[VUID-vkCmdDrawIndexedIndirect-renderPass-00531]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexedIndirect-subpass-00532]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexedIndirect-None-00533]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexedIndirect-None-00534]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexedIndirect-None-00535]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndexedIndirect-None-00536]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndexedIndirect-None-00537]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndexedIndirect-None-00538]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndexedIndirect-drawCount-00539]]
    If pname:drawCount is equal to `1`, [eq]#(pname:offset {plus}
    code:sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than or
    equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirect-drawCount-00540]]
    If pname:drawCount is greater than `1`, [eq]#(pname:stride {times}
    (pname:drawCount - 1) {plus} pname:offset {plus}
    code:sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than or
    equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirect-drawCount-00541]]
    pname:drawCount must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * [[VUID-vkCmdDrawIndexedIndirect-None-00542]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndexedIndirect-None-00543]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndexedIndirect-None-00544]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndexedIndirect-None-00545]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndexedIndirect-None-00546]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndexedIndirect-None-00547]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndexedIndirect-None-02018]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndexedIndirect-None-01503]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndexedIndirect-None-02019]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
ifndef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndexedIndirect-None-00550]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_EXT_filter_cubic[]
ifdef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndexedIndirect-filterCubic-02621]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: have a elink:VkImageViewType and format
    that supports cubic filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubic
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
  * [[VUID-vkCmdDrawIndexedIndirect-filterCubicMinmax-02622]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT with
    a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must: have
    a elink:VkImageViewType and format that supports cubic filtering
    together with minmax filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubicMinmax
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
endif::VK_EXT_filter_cubic[]
endif::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndexedIndirect-maxMultiviewInstanceIndex-00551]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndexedIndirect-commandBuffer-02643]]
    pname:commandBuffer must: not be a protected command buffer
  * [[VUID-vkCmdDrawIndexedIndirect-commandBuffer-01862]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndexedIndirect-sampleLocationsEnable-01516]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
ifdef::VK_NV_corner_sampled_image[]
  * [[VUID-vkCmdDrawIndexedIndirect-flags-02047]]
    Any slink:VkImage created with a slink:VkImageCreateInfo::pname:flags
    containing ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a
    result of this command must: only be sampled using a
    elink:VkSamplerAddressMode of
    ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
endif::VK_NV_corner_sampled_image[]
****

include::../validity/protos/vkCmdDrawIndexedIndirect.txt[]
--

[open,refpage='VkDrawIndexedIndirectCommand',desc='Structure specifying a draw indexed indirect command',type='structs',xrefs='vkCmdDrawIndexedIndirect']
--

The sname:VkDrawIndexedIndirectCommand structure is defined as:

include::../api/structs/VkDrawIndexedIndirectCommand.txt[]

  * pname:indexCount is the number of vertices to draw.
  * pname:instanceCount is the number of instances to draw.
  * pname:firstIndex is the base index within the index buffer.
  * pname:vertexOffset is the value added to the vertex index before
    indexing into the vertex buffer.
  * pname:firstInstance is the instance ID of the first instance to draw.

The members of sname:VkDrawIndexedIndirectCommand have the same meaning as
the similarly named parameters of flink:vkCmdDrawIndexed.

.Valid Usage
****
  * [[VUID-VkDrawIndexedIndirectCommand-None-00552]]
    For a given vertex buffer binding, any attribute data fetched must: be
    entirely contained within the corresponding vertex buffer binding, as
    described in <<fxvertex-input>>
  * [[VUID-VkDrawIndexedIndirectCommand-indexSize-00553]]
    [eq]#(code:indexSize * (pname:firstIndex {plus} pname:indexCount) {plus}
    pname:offset)# must: be less than or equal to the size of the bound
    index buffer, with code:indexSize being based on the type specified by
    pname:indexType, where the index buffer, pname:indexType, and
    pname:offset are specified via fname:vkCmdBindIndexBuffer
  * [[VUID-VkDrawIndexedIndirectCommand-firstInstance-00554]]
    If the <<features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, pname:firstInstance must: be code:0
****

include::../validity/structs/VkDrawIndexedIndirectCommand.txt[]

--

ifdef::VK_KHR_draw_indirect_count[]
[open,refpage='vkCmdDrawIndexedIndirectCountKHR',desc='Perform an indexed indirect draw with the draw count sourced from a buffer',type='protos']
--

To record an indexed draw call with a draw call count sourced from a buffer,
call:

include::../api/protos/vkCmdDrawIndexedIndirectCountKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:countBuffer is the buffer containing the draw count.
  * pname:countBufferOffset is the byte offset into pname:countBuffer where
    the draw count begins.
  * pname:maxDrawCount specifies the maximum number of draws that will be
    executed.
    The actual number of executed draw calls is the minimum of the count
    specified in pname:countBuffer and pname:maxDrawCount.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndexedIndirectCountKHR behaves similarly to
flink:vkCmdDrawIndexedIndirect except that the draw count is read by the
device from a buffer during execution.
The command will read an unsigned 32-bit integer from pname:countBuffer
located at pname:countBufferOffset and use this as the draw count.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-buffer-03136]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-buffer-03137]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03138]]
    If pname:countBuffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03139]]
    pname:countBuffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-offset-03140]]
    pname:offset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-countBufferOffset-03141]]
    pname:countBufferOffset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-stride-03142]]
    pname:stride must: be a multiple of `4` and must: be greater than or
    equal to sizeof(sname:VkDrawIndexedIndirectCommand)
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-maxDrawCount-03143]]
    If pname:maxDrawCount is greater than or equal to `1`,
    [eq]#(pname:stride {times} (pname:maxDrawCount - 1) {plus} pname:offset
    {plus} sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than
    or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-firstInstance-03144]]
    If the <<features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndexedIndirectCommand structures accessed by this command
    must: be code:0
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-renderPass-03145]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-subpass-03146]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03147]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03148]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03149]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03150]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03151]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03152]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03153]]
    If count stored in pname:countBuffer is equal to `1`, [eq]#(pname:offset
    {plus} sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than
    or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03154]]
    If count stored in pname:countBuffer is greater than `1`,
    [eq]#(pname:stride {times} (pname:drawCount - 1) {plus} pname:offset
    {plus} sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less than
    or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-drawCount-03155]]
    pname:drawCount must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03156]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03157]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03158]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03159]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03160]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03161]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-02020]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03163]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-02021]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
ifndef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-None-03173]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_EXT_filter_cubic[]
ifdef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-filterCubic-02623]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: have a elink:VkImageViewType and format
    that supports cubic filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubic
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-filterCubicMinmax-02624]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT with
    a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must: have
    a elink:VkImageViewType and format that supports cubic filtering
    together with minmax filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubicMinmax
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
endif::VK_EXT_filter_cubic[]
endif::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-maxMultiviewInstanceIndex-03164]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-02644]]
    pname:commandBuffer must: not be a protected command buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-03165]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-sampleLocationsEnable-03174]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
ifdef::VK_NV_corner_sampled_image[]
  * [[VUID-vkCmdDrawIndexedIndirectCountKHR-flags-02048]]
    Any slink:VkImage created with a slink:VkImageCreateInfo::pname:flags
    containing ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a
    result of this command must: only be sampled using a
    elink:VkSamplerAddressMode of
    ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
endif::VK_NV_corner_sampled_image[]
****

include::../validity/protos/vkCmdDrawIndexedIndirectCountKHR.txt[]

--
endif::VK_KHR_draw_indirect_count[]


ifdef::VK_AMD_draw_indirect_count[]
[open,refpage='vkCmdDrawIndexedIndirectCountAMD',desc='Perform an indexed indirect draw with the draw count sourced from a buffer',type='protos']
--

To record an indexed draw call with a draw call count sourced from a buffer,
call:

include::../api/protos/vkCmdDrawIndexedIndirectCountAMD.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:buffer is the buffer containing draw parameters.
  * pname:offset is the byte offset into pname:buffer where parameters
    begin.
  * pname:countBuffer is the buffer containing the draw count.
  * pname:countBufferOffset is the byte offset into pname:countBuffer where
    the draw count begins.
  * pname:maxDrawCount specifies the maximum number of draws that will be
    executed.
    The actual number of executed draw calls is the minimum of the count
    specified in pname:countBuffer and pname:maxDrawCount.
  * pname:stride is the byte stride between successive sets of draw
    parameters.

fname:vkCmdDrawIndexedIndirectCountAMD behaves similarly to
flink:vkCmdDrawIndexedIndirect except that the draw count is read by the
device from a buffer during execution.
The command will read an unsigned 32-bit integer from pname:countBuffer
located at pname:countBufferOffset and use this as the draw count.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-buffer-01666]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-buffer-01667]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-01668]]
    If pname:countBuffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-01669]]
    pname:countBuffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-offset-00555]]
    pname:offset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-countBufferOffset-00556]]
    pname:countBufferOffset must: be a multiple of `4`
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-stride-00557]]
    pname:stride must: be a multiple of `4` and must: be greater than or
    equal to code:sizeof(sname:VkDrawIndexedIndirectCommand)
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-maxDrawCount-00558]]
    If pname:maxDrawCount is greater than or equal to `1`,
    [eq]#(pname:stride {times} (pname:maxDrawCount - 1) {plus} pname:offset
    {plus} code:sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less
    than or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-firstInstance-00559]]
    If the <<features-drawIndirectFirstInstance,drawIndirectFirstInstance>>
    feature is not enabled, all the pname:firstInstance members of the
    sname:VkDrawIndexedIndirectCommand structures accessed by this command
    must: be `0`
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-renderPass-00560]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-subpass-00561]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS.
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00562]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00563]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00564]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00565]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00566]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00567]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-00568]]
    If count stored in pname:countBuffer is equal to `1`, [eq]#(pname:offset
    {plus} code:sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less
    than or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-00569]]
    If count stored in pname:countBuffer is greater than `1`,
    [eq]#(pname:stride {times} (pname:drawCount - 1) {plus} pname:offset
    {plus} code:sizeof(sname:VkDrawIndexedIndirectCommand))# must: be less
    than or equal to the size of pname:buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-drawCount-00570]]
    pname:drawCount must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxDrawIndirectCount
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00571]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00572]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00573]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00574]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00575]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-00576]]
    If the <<features-robustBufferAccess,robust buffer access>> feature is
    not enabled, and any shader stage in the sname:VkPipeline object bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it
    must: not access values outside of the range of that buffer specified in
    the bound descriptor set
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-02022]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-None-01504]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command.
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-maxMultiviewInstanceIndex-00578]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-02645]]
    pname:commandBuffer must: not be a protected command buffer
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-01865]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-sampleLocationsEnable-01517]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
ifdef::VK_NV_corner_sampled_image[]
  * [[VUID-vkCmdDrawIndexedIndirectCountAMD-flags-02049]]
    Any slink:VkImage created with a slink:VkImageCreateInfo::pname:flags
    containing ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a
    result of this command must: only be sampled using a
    elink:VkSamplerAddressMode of
    ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
endif::VK_NV_corner_sampled_image[]
****

include::../validity/protos/vkCmdDrawIndexedIndirectCountAMD.txt[]

--
endif::VK_AMD_draw_indirect_count[]

ifdef::VK_EXT_transform_feedback[]
[[drawing-transform-feedback]]
=== Drawing Transform Feedback

It is possible to draw vertex data that was previously captured during
active <<vertexpostproc-transform-feedback,transform feedback>> by binding
one or more of the transform feedback buffers as vertex buffers.
A pipeline barrier is required between using the buffers as transform
feedback buffers and vertex buffers to ensure all writes to the transform
feedback buffers are visible when the data is read as vertex attributes.
The source access is ename:VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT and
the destination access is ename:VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT for the
pipeline stages ename:VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT and
ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT respectively.
The value written to the counter buffer by
flink:vkCmdEndTransformFeedbackEXT can: be used to determine the vertex
count for the draw.
A pipeline barrier is required between using the counter buffer for
fname:vkCmdEndTransformFeedbackEXT and fname:vkCmdDrawIndirectByteCountEXT
where the source access is
ename:VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT and the destination
access is ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT for the pipeline stages
ename:VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT and
ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT respectively.

[open,refpage='vkCmdDrawIndirectByteCountEXT',desc='Draw primitives where the vertex count is derived from the counter byte value in the counter buffer',type='protos']
--

To record a non-indexed draw call, where the vertex count is based on a byte
count read from a buffer and the passed in vertex stride parameter, call:

include::../api/protos/vkCmdDrawIndirectByteCountEXT.txt[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:instanceCount is the number of instances to draw.
  * pname:firstInstance is the instance ID of the first instance to draw.
  * pname:counterBuffer is the buffer handle from where the byte count is
    read.
  * pname:counterBufferOffset is the offset into the buffer used to read the
    byte count, which is used to calculate the vertex count for this draw
    call.
  * pname:counterOffset is subtracted from the byte count read from the
    pname:counterBuffer at the pname:counterBufferOffset
  * pname:vertexStride is the stride in bytes between each element of the
    vertex data that is used to calculate the vertex count from the counter
    value.
    This value is typically the same value that was used in the graphics
    pipeline state when the transform feedback was captured as the
    code:XfbStride.

When the command is executed, primitives are assembled in the same way as
done with flink:vkCmdDraw except the pname:vertexCount is calculated based
on the byte count read from pname:counterBuffer at offset
pname:counterBufferOffset.
The assembled primitives execute the bound graphics pipeline.

The effective pname:vertexCount is calculated as follows:

[source,c]
---------------------------------------------------
const uint32_t * counterBufferPtr = (const uint8_t *)counterBuffer.address + counterBufferOffset;
vertexCount = floor(max(0, (*counterBufferPtr - counterOffset)) / vertexStride);
---------------------------------------------------

The effective pname:firstVertex is zero.

.Valid Usage
****
  * [[VUID-vkCmdDrawIndirectByteCountEXT-transformFeedback-02287]]
    sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT::pname:transformFeedback
    must: be enabled
  * [[VUID-vkCmdDrawIndirectByteCountEXT-transformFeedbackDraw-02288]]
    The implementation must: support
    sname:VkPhysicalDeviceTransformFeedbackPropertiesEXT::pname:transformFeedbackDraw
  * [[VUID-vkCmdDrawIndirectByteCountEXT-vertexStride-02289]]
    pname:vertexStride must: be greater than 0 and less than or equal to
    slink:VkPhysicalDeviceLimits::pname:maxTransformFeedbackBufferDataStride
  * [[VUID-vkCmdDrawIndirectByteCountEXT-counterBuffer-02290]]
    pname:counterBuffer must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-vkCmdDrawIndirectByteCountEXT-renderPass-02291]]
    The current render pass must: be <<renderpass-compatibility,compatible>>
    with the pname:renderPass member of the
    sname:VkGraphicsPipelineCreateInfo structure specified when creating the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndirectByteCountEXT-subpass-02292]]
    The subpass index of the current render pass must: be equal to the
    pname:subpass member of the sname:VkGraphicsPipelineCreateInfo structure
    specified when creating the sname:VkPipeline bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02293]]
    For each set _n_ that is statically used by the sname:VkPipeline bound
    to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must: have
    been bound to _n_ at ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for set _n_, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02294]]
    For each push constant that is statically used by the sname:VkPipeline
    bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value
    must: have been set for ename:VK_PIPELINE_BIND_POINT_GRAPHICS, with a
    sname:VkPipelineLayout that is compatible for push constants, with the
    sname:VkPipelineLayout used to create the current sname:VkPipeline, as
    described in <<descriptorsets-compatibility>>
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02295]]
    Descriptors in each bound descriptor set, specified via
    fname:vkCmdBindDescriptorSets, must: be valid if they are statically
    used by the bound sname:VkPipeline object, specified via
    fname:vkCmdBindPipeline
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02296]]
    All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point's interface must: have valid buffers
    bound
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02297]]
    For a given vertex buffer binding, any attribute data fetched must: be
    entirely contained within the corresponding vertex buffer binding, as
    described in <<fxvertex-input>>
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02298]]
    A valid graphics pipeline must: be bound to the current command buffer
    with ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02299]]
    If the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that
    state must: have been set on the current command buffer
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02300]]
    Every input attachment used by the current subpass must: be bound to the
    pipeline via a descriptor set
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02301]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used to sample from any
    sname:VkImage with a sname:VkImageView of the type
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE,
    ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02302]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions with
    code:ImplicitLod, code:Dref or code:Proj in their name, in any shader
    stage
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02303]]
    If any sname:VkSampler object that is accessed from a shader by the
    sname:VkPipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS uses
    unnormalized coordinates, it must: not be used with any of the SPIR-V
    `OpImageSample*` or `OpImageSparseSample*` instructions that includes a
    LOD bias or any offset values, in any shader stage
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02304]]
    Image subresources used as attachments in the current render pass must:
    not be accessed in any way other than as an attachment by this command
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02305]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_LINEAR as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
ifdef::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02306]]
    If a sname:VkImageView is sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
ifndef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndirectByteCountEXT-None-02307]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: not have a elink:VkImageViewType of
    ename:VK_IMAGE_VIEW_TYPE_3D, ename:VK_IMAGE_VIEW_TYPE_CUBE, or
    ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
endif::VK_EXT_filter_cubic[]
ifdef::VK_EXT_filter_cubic[]
  * [[VUID-vkCmdDrawIndirectByteCountEXT-filterCubic-02625]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT as a
    result of this command must: have a elink:VkImageViewType and format
    that supports cubic filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubic
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
  * [[VUID-vkCmdDrawIndirectByteCountEXT-filterCubicMinmax-02626]]
    Any slink:VkImageView being sampled with ename:VK_FILTER_CUBIC_EXT with
    a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must: have
    a elink:VkImageViewType and format that supports cubic filtering
    together with minmax filtering, as specified by
    sname:VkFilterCubicImageViewImageFormatPropertiesEXT::pname:filterCubicMinmax
    returned by fname:vkGetPhysicalDeviceImageFormatProperties2
endif::VK_EXT_filter_cubic[]
endif::VK_IMG_filter_cubic,VK_EXT_filter_cubic[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-vkCmdDrawIndirectByteCountEXT-maxMultiviewInstanceIndex-02308]]
    If the draw is recorded in a render pass instance with multiview
    enabled, the maximum instance index must: be less than or equal to
    slink:VkPhysicalDeviceMultiviewProperties::pname:maxMultiviewInstanceIndex
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-vkCmdDrawIndirectByteCountEXT-commandBuffer-02646]]
    pname:commandBuffer must: not be a protected command buffer
  * [[VUID-vkCmdDrawIndirectByteCountEXT-commandBuffer-02309]]
    If pname:commandBuffer is an unprotected command buffer, and any
    pipeline stage in the sname:VkPipeline object bound to
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image
    or buffer, that image or buffer must: not be a protected image or
    protected buffer
endif::VK_VERSION_1_1[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdDrawIndirectByteCountEXT-sampleLocationsEnable-02312]]
    If the bound graphics pipeline was created with
    slink:VkPipelineSampleLocationsStateCreateInfoEXT::pname:sampleLocationsEnable
    set to ename:VK_TRUE and the current subpass has a depth/stencil
    attachment, then that attachment must: have been created with the
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
endif::VK_EXT_sample_locations[]
****

include::../validity/protos/vkCmdDrawIndirectByteCountEXT.txt[]
--

endif::VK_EXT_transform_feedback[]

ifdef::VK_EXT_conditional_rendering[]

[[drawing-conditional-rendering]]
== Conditional Rendering
Certain rendering commands can: be executed conditionally based on a value
in buffer memory.
These rendering commands are limited to <<drawing,drawing commands>>,
<<dispatch,dispatching commands>>, and clearing attachments with
flink:vkCmdClearAttachments within a conditional rendering block which is
defined by commands flink:vkCmdBeginConditionalRenderingEXT and
flink:vkCmdEndConditionalRenderingEXT.
Other rendering commands remain unaffected by conditional rendering.

[[active-conditional-rendering]]
After beginning conditional rendering, it is considered _active_ within the
command buffer it was called until it is ended with
flink:vkCmdEndConditionalRenderingEXT.

Conditional rendering must: begin and end in the same command buffer.
When conditional rendering is active, a primary command buffer can: execute
secondary command buffers if the <<features-inheritedConditionalRendering,
inherited conditional rendering>> feature is enabled.
For a secondary command buffer to be executed while conditional rendering is
active in the primary command buffer, it must: set the
pname:conditionalRenderingEnable flag of
slink:VkCommandBufferInheritanceConditionalRenderingInfoEXT, as described in
the <<commandbuffers-recording, Command Buffer Recording>> section.

Conditional rendering must: also either begin and end inside the same
subpass of a render pass instance, or must: both begin and end outside of a
render pass instance (i.e. contain entire render pass instances).

[open,refpage='vkCmdBeginConditionalRenderingEXT',desc='Define the beginning of a conditional rendering block',type='protos']
--

To begin conditional rendering, call:

include::../api/protos/vkCmdBeginConditionalRenderingEXT.txt[]

  * pname:commandBuffer is the command buffer into which this command will
    be recorded.
  * pname:pConditionalRenderingBegin is a pointer to an instance of the
    slink:VkConditionalRenderingBeginInfoEXT structure specifying the
    parameters of conditional rendering.

.Valid Usage
****
  * [[VUID-vkCmdBeginConditionalRenderingEXT-None-01980]]
    Conditional rendering must: not already be
    <<active-conditional-rendering,active>>
****

include::../validity/protos/vkCmdBeginConditionalRenderingEXT.txt[]
--

[open,refpage='VkConditionalRenderingBeginInfoEXT',desc='Structure specifying conditional rendering begin info',type='structs']
--

The sname:VkConditionalRenderingBeginInfoEXT structure is defined as:

include::../api/structs/VkConditionalRenderingBeginInfoEXT.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:buffer is a buffer containing the predicate for conditional
    rendering.
  * pname:offset is the byte offset into pname:buffer where the predicate is
    located.
  * pname:flags is a bitmask of tlink:VkConditionalRenderingFlagsEXT
    specifying the behavior of conditional rendering.

If the 32-bit value at pname:offset in pname:buffer memory is zero, then the
rendering commands are discarded, otherwise they are executed as normal.
If the value of the predicate in buffer memory changes while conditional
rendering is active, the rendering commands may: be discarded in an
implementation-dependent way.
Some implementations may latch the value of the predicate upon beginning
conditional rendering while others may read it before every rendering
command.

.Valid Usage
****
  * [[VUID-VkConditionalRenderingBeginInfoEXT-buffer-01981]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-VkConditionalRenderingBeginInfoEXT-buffer-01982]]
    pname:buffer must: have been created with the
    ename:VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT bit set
  * [[VUID-VkConditionalRenderingBeginInfoEXT-offset-01983]]
    pname:offset must: be less than the size of pname:buffer by at least 32
    bits.
  * [[VUID-VkConditionalRenderingBeginInfoEXT-offset-01984]]
    pname:offset must: be a multiple of 4
****

include::../validity/structs/VkConditionalRenderingBeginInfoEXT.txt[]

--

[open,refpage='VkConditionalRenderingFlagBitsEXT',desc='Specify the behavior of conditional rendering',type='enums']
--

Bits which can: be set in
flink:vkCmdBeginConditionalRenderingEXT::pname:flags specifying the behavior
of conditional rendering are:

include::../api/enums/VkConditionalRenderingFlagBitsEXT.txt[]

  * ename:VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT specifies the condition
    used to determine whether to discard rendering commands or not.
    That is, if the 32-bit predicate read from pname:buffer memory at
    pname:offset is zero, the rendering commands are not discarded, and if
    non zero, then they are discarded.

--

[open,refpage='VkConditionalRenderingFlagsEXT',desc='Bitmask of VkConditionalRenderingFlagBitsEXT',type='flags']
--
include::../api/flags/VkConditionalRenderingFlagsEXT.txt[]

tname:VkConditionalRenderingFlagsEXT is a bitmask type for setting a mask of
zero or more elink:VkConditionalRenderingFlagBitsEXT.
--

[open,refpage='vkCmdEndConditionalRenderingEXT',desc='Define the end of a conditional rendering block',type='protos']
--

To end conditional rendering, call:

include::../api/protos/vkCmdEndConditionalRenderingEXT.txt[]

  * pname:commandBuffer is the command buffer into which this command will
    be recorded.

Once ended, conditional rendering becomes inactive.

.Valid Usage
****
  * [[VUID-vkCmdEndConditionalRenderingEXT-None-01985]]
    Conditional rendering must: be <<active-conditional-rendering,active>>
  * [[VUID-vkCmdEndConditionalRenderingEXT-None-01986]]
    If conditional rendering was made
    <<active-conditional-rendering,active>> outside of a render pass
    instance, it must not be ended inside a render pass instance
  * [[VUID-vkCmdEndConditionalRenderingEXT-None-01987]]
    If conditional rendering was made
    <<active-conditional-rendering,active>> within a subpass it must be
    ended in the same subpass
****

include::../validity/protos/vkCmdEndConditionalRenderingEXT.txt[]
--

endif::VK_EXT_conditional_rendering[]

ifdef::VK_NV_mesh_shader[]
include::VK_NV_mesh_shader/drawing.txt[]
endif::VK_NV_mesh_shader[]
