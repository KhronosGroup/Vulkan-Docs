// Copyright 2015-2024 The Khronos Group Inc.
//
// SPDX-License-Identifier: CC-BY-4.0

[[resources]]
= Resource Creation

Vulkan supports two primary resource types: _buffers_ and _images_.
Resources are views of memory with associated formatting and dimensionality.
Buffers provide access to raw arrays of bytes, whereas images can: be
multidimensional and may: have associated metadata.

ifdef::VK_NV_ray_tracing,VK_KHR_acceleration_structure[]
Other resource types, such as <<resources-acceleration-structures,
acceleration structures>>
ifdef::VK_EXT_opacity_micromap[]
and <<resources-micromaps, micromaps>>
endif::VK_EXT_opacity_micromap[]
use buffers as the backing store for opaque data structures.
endif::VK_NV_ray_tracing,VK_KHR_acceleration_structure[]


[[resources-buffers]]
== Buffers

[open,refpage='VkBuffer',desc='Opaque handle to a buffer object',type='handles']
--
Buffers represent linear arrays of data which are used for various purposes
by binding them to a graphics or compute pipeline via descriptor sets or
certain commands, or by directly specifying them as parameters to certain
commands.

Buffers are represented by sname:VkBuffer handles:

include::{generated}/api/handles/VkBuffer.adoc[]
--

[open,refpage='vkCreateBuffer',desc='Create a new buffer object',type='protos']
--
:refpage: vkCreateBuffer
:objectnameplural: buffers
:objectnamecamelcase: buffer
:objectnamestruct: VkDeviceObjectReservationCreateInfo
:objectcount: 1

To create buffers, call:

include::{generated}/api/protos/vkCreateBuffer.adoc[]

  * pname:device is the logical device that creates the buffer object.
  * pname:pCreateInfo is a pointer to a slink:VkBufferCreateInfo structure
    containing parameters affecting creation of the buffer.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pBuffer is a pointer to a slink:VkBuffer handle in which the
    resulting buffer object is returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkCreateBuffer-device-09664]]
    pname:device must: support at least one queue family with one of the
ifdef::VK_KHR_video_encode_queue[]
    ename:VK_QUEUE_VIDEO_ENCODE_BIT_KHR,
endif::VK_KHR_video_encode_queue[]
ifdef::VK_KHR_video_decode_queue[]
    ename:VK_QUEUE_VIDEO_DECODE_BIT_KHR,
endif::VK_KHR_video_decode_queue[]
ifndef::VKSC_VERSION_1_0[ename:VK_QUEUE_SPARSE_BINDING_BIT,]
    ename:VK_QUEUE_TRANSFER_BIT, ename:VK_QUEUE_COMPUTE_BIT, or
    ename:VK_QUEUE_GRAPHICS_BIT capabilities
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkCreateBuffer-flags-00911]]
    If the pname:flags member of pname:pCreateInfo includes
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
ifdef::VK_NV_extended_sparse_address_space[]
    and the <<features-extendedSparseAddressSpace,
    pname:extendedSparseAddressSpace>> feature is not enabled,
endif::VK_NV_extended_sparse_address_space[]
    creating this sname:VkBuffer must: not cause the total required sparse
    memory for all currently valid sparse resources on the device to exceed
    sname:VkPhysicalDeviceLimits::pname:sparseAddressSpaceSize
ifdef::VK_NV_extended_sparse_address_space[]
  * [[VUID-vkCreateBuffer-flags-09383]]
    If the pname:flags member of pname:pCreateInfo includes
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT, the
    <<features-extendedSparseAddressSpace,
    pname:extendedSparseAddressSpace>> feature is enabled, and the
    pname:usage member of pname:pCreateInfo contains bits not in
    sname:VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV::pname:extendedSparseBufferUsageFlags,
    creating this sname:VkBuffer must: not cause the total required sparse
    memory for all currently valid sparse resources on the device, excluding
    sname:VkBuffer created with pname:usage member of pname:pCreateInfo
    containing bits in
    sname:VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV::pname:extendedSparseBufferUsageFlags
    and sname:VkImage created with pname:usage member of pname:pCreateInfo
    containing bits in
    sname:VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV::pname:extendedSparseImageUsageFlags,
    to exceed sname:VkPhysicalDeviceLimits::pname:sparseAddressSpaceSize
  * [[VUID-vkCreateBuffer-flags-09384]]
    If the pname:flags member of pname:pCreateInfo includes
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT and the
    <<features-extendedSparseAddressSpace,
    pname:extendedSparseAddressSpace>> feature is enabled, creating this
    sname:VkBuffer must: not cause the total required sparse memory for all
    currently valid sparse resources on the device to exceed
    sname:VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV::pname:extendedSparseAddressSpaceSize
endif::VK_NV_extended_sparse_address_space[]
endif::VKSC_VERSION_1_0[]
include::{chapters}/commonvalidity/memory_reservation_request_count_common.adoc[]
ifdef::VK_FUCHSIA_buffer_collection[]
  * [[VUID-vkCreateBuffer-pNext-06387]]
    If using the slink:VkBuffer for an import operation from a
    slink:VkBufferCollectionFUCHSIA where a
    slink:VkBufferCollectionBufferCreateInfoFUCHSIA has been chained to
    pname:pNext, pname:pCreateInfo must: match the
    slink:VkBufferConstraintsInfoFUCHSIA::pname:createInfo used when setting
    the constraints on the buffer collection with
    flink:vkSetBufferCollectionBufferConstraintsFUCHSIA
endif::VK_FUCHSIA_buffer_collection[]
****

include::{generated}/validity/protos/vkCreateBuffer.adoc[]
--

[open,refpage='VkBufferCreateInfo',desc='Structure specifying the parameters of a newly created buffer object',type='structs']
--
:refpage: VkBufferCreateInfo

The sname:VkBufferCreateInfo structure is defined as:

include::{generated}/api/structs/VkBufferCreateInfo.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkBufferCreateFlagBits specifying
    additional parameters of the buffer.
  * pname:size is the size in bytes of the buffer to be created.
  * pname:usage is a bitmask of elink:VkBufferUsageFlagBits specifying
    allowed usages of the buffer.
  * pname:sharingMode is a elink:VkSharingMode value specifying the sharing
    mode of the buffer when it will be accessed by multiple queue families.
  * pname:queueFamilyIndexCount is the number of entries in the
    pname:pQueueFamilyIndices array.
  * pname:pQueueFamilyIndices is a pointer to an array of queue families
    that will access this buffer.
    It is ignored if pname:sharingMode is not
    ename:VK_SHARING_MODE_CONCURRENT.

ifdef::VK_KHR_maintenance5[]
If the pname:pNext chain includes a slink:VkBufferUsageFlags2CreateInfoKHR
structure, slink:VkBufferUsageFlags2CreateInfoKHR::pname:usage from that
structure is used instead of pname:usage from this structure.
endif::VK_KHR_maintenance5[]

.Valid Usage
****
include::{chapters}/commonvalidity/buffer_usage_flags_common.adoc[]
  * [[VUID-VkBufferCreateInfo-size-00912]]
    pname:size must: be greater than `0`
  * [[VUID-VkBufferCreateInfo-sharingMode-00913]]
    If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT,
    pname:pQueueFamilyIndices must: be a valid pointer to an array of
    pname:queueFamilyIndexCount code:uint32_t values
  * [[VUID-VkBufferCreateInfo-sharingMode-00914]]
    If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT,
    pname:queueFamilyIndexCount must: be greater than `1`
  * [[VUID-VkBufferCreateInfo-sharingMode-01419]]
    If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT, each element
    of pname:pQueueFamilyIndices must: be unique and must: be less than
    pname:pQueueFamilyPropertyCount returned by
ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
    either flink:vkGetPhysicalDeviceQueueFamilyProperties2 or
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
    flink:vkGetPhysicalDeviceQueueFamilyProperties for the
    pname:physicalDevice that was used to create pname:device
  * [[VUID-VkBufferCreateInfo-flags-00915]]
ifndef::VKSC_VERSION_1_0[]
    If the <<features-sparseBinding, pname:sparseBinding>> feature is not
    enabled,
endif::VKSC_VERSION_1_0[]
    pname:flags must: not contain ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT
  * [[VUID-VkBufferCreateInfo-flags-00916]]
ifndef::VKSC_VERSION_1_0[]
    If the <<features-sparseResidencyBuffer, pname:sparseResidencyBuffer>>
    feature is not enabled,
endif::VKSC_VERSION_1_0[]
    pname:flags must: not contain
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT
  * [[VUID-VkBufferCreateInfo-flags-00917]]
ifndef::VKSC_VERSION_1_0[]
    If the <<features-sparseResidencyAliased, pname:sparseResidencyAliased>>
    feature is not enabled,
endif::VKSC_VERSION_1_0[]
    pname:flags must: not contain ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkBufferCreateInfo-flags-00918]]
    If pname:flags contains ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT or
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT, it must: also contain
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT
endif::VKSC_VERSION_1_0[]
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
  * [[VUID-VkBufferCreateInfo-pNext-00920]]
    If the pname:pNext chain includes a
    slink:VkExternalMemoryBufferCreateInfo structure, its pname:handleTypes
    member must: only contain bits that are also in
    slink:VkExternalBufferProperties::pname:externalMemoryProperties.compatibleHandleTypes,
    as returned by flink:vkGetPhysicalDeviceExternalBufferProperties with
    pname:pExternalBufferInfo->handleType equal to any one of the handle
    types specified in
    slink:VkExternalMemoryBufferCreateInfo::pname:handleTypes
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-VkBufferCreateInfo-flags-01887]]
    If the <<features-protectedMemory, pname:protectedMemory>> feature is
    not enabled, pname:flags must: not contain
    ename:VK_BUFFER_CREATE_PROTECTED_BIT
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkBufferCreateInfo-None-01888]]
    If any of the bits ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT are set,
    ename:VK_BUFFER_CREATE_PROTECTED_BIT must: not also be set
endif::VKSC_VERSION_1_0[]
endif::VK_VERSION_1_1[]
ifdef::VK_NV_dedicated_allocation[]
  * [[VUID-VkBufferCreateInfo-pNext-01571]]
    If the pname:pNext chain includes a
    slink:VkDedicatedAllocationBufferCreateInfoNV structure, and the
    pname:dedicatedAllocation member of the chained structure is
    ename:VK_TRUE, then pname:flags must: not include
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT
endif::VK_NV_dedicated_allocation[]
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
ifdef::VK_EXT_buffer_device_address[]
  * [[VUID-VkBufferCreateInfo-deviceAddress-02604]]
    If slink:VkBufferDeviceAddressCreateInfoEXT::pname:deviceAddress is not
    zero, pname:flags must: include
    ename:VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
endif::VK_EXT_buffer_device_address[]
ifdef::VK_VERSION_1_2,VK_KHR_buffer_device_address[]
  * [[VUID-VkBufferCreateInfo-opaqueCaptureAddress-03337]]
    If
    slink:VkBufferOpaqueCaptureAddressCreateInfo::pname:opaqueCaptureAddress
    is not zero, pname:flags must: include
    ename:VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
endif::VK_VERSION_1_2,VK_KHR_buffer_device_address[]
  * [[VUID-VkBufferCreateInfo-flags-03338]]
    If pname:flags includes
    ename:VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT, the
ifndef::VK_EXT_buffer_device_address[]
    <<features-bufferDeviceAddressCaptureReplay,
    pname:bufferDeviceAddressCaptureReplay>> feature
endif::VK_EXT_buffer_device_address[]
ifdef::VK_EXT_buffer_device_address[]
    <<features-bufferDeviceAddressCaptureReplayEXT,
    pname:bufferDeviceAddressCaptureReplay>> feature
endif::VK_EXT_buffer_device_address[]
    must: be enabled
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
ifdef::VK_KHR_video_decode_queue[]
  * [[VUID-VkBufferCreateInfo-usage-04813]]
    If pname:usage includes ename:VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR
    or ename:VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR,
ifdef::VK_KHR_video_maintenance1[]
    and pname:flags does not include
    ename:VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR,
endif::VK_KHR_video_maintenance1[]
    then the pname:pNext chain must: include a
    slink:VkVideoProfileListInfoKHR structure with pname:profileCount
    greater than `0` and pname:pProfiles including at least one
    slink:VkVideoProfileInfoKHR structure with a pname:videoCodecOperation
    member specifying a decode operation
endif::VK_KHR_video_decode_queue[]
ifdef::VK_KHR_video_encode_queue[]
  * [[VUID-VkBufferCreateInfo-usage-04814]]
    If pname:usage includes ename:VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR
    or ename:VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR,
ifdef::VK_KHR_video_maintenance1[]
    and pname:flags does not include
    ename:VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR,
endif::VK_KHR_video_maintenance1[]
    then the pname:pNext chain must: include a
    slink:VkVideoProfileListInfoKHR structure with pname:profileCount
    greater than `0` and pname:pProfiles including at least one
    slink:VkVideoProfileInfoKHR structure with a pname:videoCodecOperation
    member specifying an encode operation
endif::VK_KHR_video_encode_queue[]
ifdef::VK_KHR_video_maintenance1[]
  * [[VUID-VkBufferCreateInfo-flags-08325]]
    If pname:flags includes
    ename:VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR, then
    <<features-videoMaintenance1,pname:videoMaintenance1>> must: be enabled
endif::VK_KHR_video_maintenance1[]
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
  * [[VUID-VkBufferCreateInfo-size-06409]]
    pname:size must: be less than or equal to
    slink:VkPhysicalDeviceMaintenance4Properties::pname:maxBufferSize
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]
ifdef::VK_EXT_descriptor_buffer[]
  * [[VUID-VkBufferCreateInfo-usage-08097]]
    If pname:usage includes
    ename:VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT, creating this
    sname:VkBuffer must: not cause the total required space for all
    currently valid buffers using this flag on the device to exceed
    slink:VkPhysicalDeviceDescriptorBufferPropertiesEXT::pname:samplerDescriptorBufferAddressSpaceSize
    or
    slink:VkPhysicalDeviceDescriptorBufferPropertiesEXT::pname:descriptorBufferAddressSpaceSize
  * [[VUID-VkBufferCreateInfo-usage-08098]]
    If pname:usage includes
    ename:VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT, creating this
    sname:VkBuffer must: not cause the total required space for all
    currently valid buffers using this flag on the device to exceed
    slink:VkPhysicalDeviceDescriptorBufferPropertiesEXT::pname:resourceDescriptorBufferAddressSpaceSize
    or
    slink:VkPhysicalDeviceDescriptorBufferPropertiesEXT::pname:descriptorBufferAddressSpaceSize
  * [[VUID-VkBufferCreateInfo-flags-08099]]
    If pname:flags includes
    ename:VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, the
    <<features-descriptorBufferCaptureReplay,
    pname:descriptorBufferCaptureReplay>> feature must: be enabled
  * [[VUID-VkBufferCreateInfo-pNext-08100]]
    If the pname:pNext chain includes a
    slink:VkOpaqueCaptureDescriptorDataCreateInfoEXT structure, pname:flags
    must: contain
    ename:VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
  * [[VUID-VkBufferCreateInfo-usage-08101]]
    If pname:usage includes
    ename:VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT, the
    <<features-descriptorBufferPushDescriptors,
    pname:descriptorBufferPushDescriptors>> feature must: be enabled
  * [[VUID-VkBufferCreateInfo-usage-08102]]
    If pname:usage includes
    ename:VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT
    <<limits-bufferlessPushDescriptors,
    sname:VkPhysicalDeviceDescriptorBufferPropertiesEXT::pname:bufferlessPushDescriptors>>
    must: be ename:VK_FALSE
  * [[VUID-VkBufferCreateInfo-usage-08103]]
    If pname:usage includes
    ename:VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT,
    pname:usage must: contain at least one of
    ename:VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT or
    ename:VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT
endif::VK_EXT_descriptor_buffer[]
  * [[VUID-VkBufferCreateInfo-flags-09641]]
    If pname:flags includes ename:VK_BUFFER_CREATE_PROTECTED_BIT, then
    pname:usage must: not contain any of the following bits
ifdef::VK_EXT_transform_feedback[** ename:VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT]
ifdef::VK_EXT_transform_feedback[** ename:VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT]
ifdef::VK_EXT_conditional_rendering[** ename:VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT]
ifdef::VK_KHR_acceleration_structure[** ename:VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR]
ifdef::VK_KHR_acceleration_structure[** ename:VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR]
ifdef::VK_KHR_ray_tracing_pipeline[** ename:VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR]
ifdef::VK_EXT_descriptor_buffer[** ename:VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT]
ifdef::VK_EXT_descriptor_buffer[** ename:VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT]
ifdef::VK_EXT_descriptor_buffer[** ename:VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT]
ifdef::VK_EXT_opacity_micromap[** ename:VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT]
ifdef::VK_EXT_opacity_micromap[** ename:VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT]
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkBufferCreateInfo::pname:flags must: not contain any of the
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or
    ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT flags <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/structs/VkBufferCreateInfo.adoc[]
--

ifdef::VK_KHR_maintenance5[]
[open,refpage='VkBufferUsageFlags2CreateInfoKHR',desc='Extended buffer usage flags',type='structs']
--
The sname:VkBufferUsageFlags2CreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkBufferUsageFlags2CreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:usage is a bitmask of elink:VkBufferUsageFlagBits2KHR specifying
    allowed usages of the buffer.

If this structure is included in the pname:pNext chain of a buffer creation
structure, pname:usage is used instead of the corresponding pname:usage
value passed in that creation structure, allowing additional usage flags to
be specified.
If this structure is included in the pname:pNext chain of a buffer query
structure, the usage flags of the buffer are returned in pname:usage of this
structure, and the usage flags representable in pname:usage of the buffer
query structure are also returned in that field.

include::{generated}/validity/structs/VkBufferUsageFlags2CreateInfoKHR.adoc[]
--

[open,refpage='VkBufferUsageFlagBits2KHR',desc='Bitmask controlling how a pipeline is created',type='enums']
--
Bits which can: be set in
slink:VkBufferUsageFlags2CreateInfoKHR::pname:usage, specifying usage
behavior of a buffer, are:

include::{generated}/api/enums/VkBufferUsageFlagBits2KHR.adoc[]

// Note - when editing this section, make sure that any relevant changes
// are mirrored in VkBufferUsageFlagBits2KHR/VkBufferUsageFlagBits

  * ename:VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR specifies that the buffer
    can: be used as the source of a _transfer command_ (see the definition
    of <<synchronization-pipeline-stages-transfer,
    ename:VK_PIPELINE_STAGE_TRANSFER_BIT>>).
  * ename:VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR specifies that the buffer
    can: be used as the destination of a transfer command.
  * ename:VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR specifies that the
    buffer can: be used to create a sname:VkBufferView suitable for
    occupying a sname:VkDescriptorSet slot of type
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.
  * ename:VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR specifies that the
    buffer can: be used to create a sname:VkBufferView suitable for
    occupying a sname:VkDescriptorSet slot of type
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.
  * ename:VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR specifies that the buffer
    can: be used in a sname:VkDescriptorBufferInfo suitable for occupying a
    sname:VkDescriptorSet slot either of type
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.
  * ename:VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR specifies that the buffer
    can: be used in a sname:VkDescriptorBufferInfo suitable for occupying a
    sname:VkDescriptorSet slot either of type
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.
  * ename:VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR specifies that the buffer
    is suitable for passing as the pname:buffer parameter to
ifdef::VK_KHR_maintenance5[flink:vkCmdBindIndexBuffer2KHR and]
    flink:vkCmdBindIndexBuffer.
  * ename:VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR specifies that the buffer
    is suitable for passing as an element of the pname:pBuffers array to
    flink:vkCmdBindVertexBuffers.
  * ename:VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR specifies that the
    buffer is suitable for passing as the pname:buffer parameter to
    flink:vkCmdDrawIndirect, flink:vkCmdDrawIndexedIndirect,
ifdef::VK_NV_mesh_shader[]
    flink:vkCmdDrawMeshTasksIndirectNV,
    flink:vkCmdDrawMeshTasksIndirectCountNV,
endif::VK_NV_mesh_shader[]
ifdef::VK_EXT_mesh_shader[]
    fname:vkCmdDrawMeshTasksIndirectEXT,
    fname:vkCmdDrawMeshTasksIndirectCountEXT,
endif::VK_EXT_mesh_shader[]
ifdef::VK_HUAWEI_cluster_culling_shader[]
    flink:vkCmdDrawClusterIndirectHUAWEI,
endif::VK_HUAWEI_cluster_culling_shader[]
    or flink:vkCmdDispatchIndirect.
ifdef::VK_NV_device_generated_commands[]
    It is also suitable for passing as the pname:buffer member of
    sname:VkIndirectCommandsStreamNV, or pname:sequencesCountBuffer or
    pname:sequencesIndexBuffer or pname:preprocessedBuffer member of
    sname:VkGeneratedCommandsInfoNV
endif::VK_NV_device_generated_commands[]
ifdef::VK_EXT_conditional_rendering[]
  * ename:VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT specifies that the
    buffer is suitable for passing as the pname:buffer parameter to
    flink:vkCmdBeginConditionalRenderingEXT.
endif::VK_EXT_conditional_rendering[]
ifdef::VK_EXT_transform_feedback[]
  * ename:VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT specifies that
    the buffer is suitable for using for binding as a transform feedback
    buffer with flink:vkCmdBindTransformFeedbackBuffersEXT.
  * ename:VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT
    specifies that the buffer is suitable for using as a counter buffer with
    flink:vkCmdBeginTransformFeedbackEXT and
    flink:vkCmdEndTransformFeedbackEXT.
endif::VK_EXT_transform_feedback[]
ifdef::VK_EXT_descriptor_buffer[]
  * ename:VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT specifies that
    the buffer is suitable to contain sampler and combined image sampler
    descriptors when bound as a descriptor buffer.
    Buffers containing combined image sampler descriptors must: also specify
    ename:VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT.
  * ename:VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT specifies
    that the buffer is suitable to contain resource descriptors when bound
    as a descriptor buffer.
  * ename:VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT
    specifies that the buffer, when bound, can: be used by the
    implementation to support push descriptors when using descriptor
    buffers.
endif::VK_EXT_descriptor_buffer[]
ifdef::VK_NV_ray_tracing[]
  * ename:VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV specifies that the buffer is
    suitable for use in flink:vkCmdTraceRaysNV.
endif::VK_NV_ray_tracing[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * ename:VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR specifies that the
    buffer is suitable for use as a <<shader-binding-table,Shader Binding
    Table>>.
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_KHR_acceleration_structure[]
  * ename:VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR
    specifies that the buffer is suitable for use as a read-only input to an
    <<acceleration-structure-building,acceleration structure build>>.
  * ename:VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR specifies
    that the buffer is suitable for storage space for a
    slink:VkAccelerationStructureKHR.
endif::VK_KHR_acceleration_structure[]
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
  * ename:VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR specifies that the
    buffer can: be used to retrieve a buffer device address via
    flink:vkGetBufferDeviceAddress and use that address to access the
    buffer's memory from a shader.
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
ifdef::VK_KHR_video_decode_queue[]
  * ename:VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR specifies that the
    buffer can: be used as the source video bitstream buffer in a
    <<video-decode-operations, video decode operation>>.
  * ename:VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR is reserved for future
    use.
endif::VK_KHR_video_decode_queue[]
ifdef::VK_KHR_video_encode_queue[]
  * ename:VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR specifies that the
    buffer can: be used as the destination video bitstream buffer in a
    <<video-encode-operations, video encode operation>>.
  * ename:VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR is reserved for future
    use.
endif::VK_KHR_video_encode_queue[]
ifdef::VK_AMDX_shader_enqueue[]
  * ename:VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX specifies that
    the buffer can: be used for as scratch memory for
    <<executiongraphs,execution graph dispatch>>.
endif::VK_AMDX_shader_enqueue[]
--

[open,refpage='VkBufferUsageFlags2KHR',desc='Bitmask of VkBufferUsageFlagBits2KHR',type='flags']
--
include::{generated}/api/flags/VkBufferUsageFlags2KHR.adoc[]

tname:VkBufferUsageFlags2KHR is a bitmask type for setting a mask of zero or
more elink:VkBufferUsageFlagBits2KHR.
--
endif::VK_KHR_maintenance5[]

[open,refpage='VkBufferUsageFlagBits',desc='Bitmask specifying allowed usage of a buffer',type='enums']
--
Bits which can: be set in slink:VkBufferCreateInfo::pname:usage, specifying
usage behavior of a buffer, are:

include::{generated}/api/enums/VkBufferUsageFlagBits.adoc[]

// Note - when editing this section, make sure that any relevant changes
// are mirrored in VkBufferUsageFlagBits2KHR/VkBufferUsageFlagBits

  * ename:VK_BUFFER_USAGE_TRANSFER_SRC_BIT specifies that the buffer can: be
    used as the source of a _transfer command_ (see the definition of
    <<synchronization-pipeline-stages-transfer,
    ename:VK_PIPELINE_STAGE_TRANSFER_BIT>>).
  * ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT specifies that the buffer can: be
    used as the destination of a transfer command.
  * ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT specifies that the buffer
    can: be used to create a sname:VkBufferView suitable for occupying a
    sname:VkDescriptorSet slot of type
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.
  * ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT specifies that the buffer
    can: be used to create a sname:VkBufferView suitable for occupying a
    sname:VkDescriptorSet slot of type
    ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.
  * ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT specifies that the buffer can:
    be used in a sname:VkDescriptorBufferInfo suitable for occupying a
    sname:VkDescriptorSet slot either of type
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.
  * ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT specifies that the buffer can:
    be used in a sname:VkDescriptorBufferInfo suitable for occupying a
    sname:VkDescriptorSet slot either of type
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.
  * ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT specifies that the buffer is
    suitable for passing as the pname:buffer parameter to
ifdef::VK_KHR_maintenance5[flink:vkCmdBindIndexBuffer2KHR and]
    flink:vkCmdBindIndexBuffer.
  * ename:VK_BUFFER_USAGE_VERTEX_BUFFER_BIT specifies that the buffer is
    suitable for passing as an element of the pname:pBuffers array to
    flink:vkCmdBindVertexBuffers.
  * ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT specifies that the buffer is
    suitable for passing as the pname:buffer parameter to
    flink:vkCmdDrawIndirect, flink:vkCmdDrawIndexedIndirect,
ifdef::VK_NV_mesh_shader[]
    flink:vkCmdDrawMeshTasksIndirectNV,
    flink:vkCmdDrawMeshTasksIndirectCountNV,
endif::VK_NV_mesh_shader[]
ifdef::VK_EXT_mesh_shader[]
    fname:vkCmdDrawMeshTasksIndirectEXT,
    fname:vkCmdDrawMeshTasksIndirectCountEXT,
endif::VK_EXT_mesh_shader[]
ifdef::VK_HUAWEI_cluster_culling_shader[]
    flink:vkCmdDrawClusterIndirectHUAWEI,
endif::VK_HUAWEI_cluster_culling_shader[]
    or flink:vkCmdDispatchIndirect.
ifdef::VK_NV_device_generated_commands[]
    It is also suitable for passing as the pname:buffer member of
    sname:VkIndirectCommandsStreamNV, or pname:sequencesCountBuffer or
    pname:sequencesIndexBuffer or pname:preprocessedBuffer member of
    sname:VkGeneratedCommandsInfoNV
endif::VK_NV_device_generated_commands[]
ifdef::VK_EXT_conditional_rendering[]
  * ename:VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT specifies that the
    buffer is suitable for passing as the pname:buffer parameter to
    flink:vkCmdBeginConditionalRenderingEXT.
endif::VK_EXT_conditional_rendering[]
ifdef::VK_EXT_transform_feedback[]
  * ename:VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT specifies that
    the buffer is suitable for using for binding as a transform feedback
    buffer with flink:vkCmdBindTransformFeedbackBuffersEXT.
  * ename:VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT
    specifies that the buffer is suitable for using as a counter buffer with
    flink:vkCmdBeginTransformFeedbackEXT and
    flink:vkCmdEndTransformFeedbackEXT.
endif::VK_EXT_transform_feedback[]
ifdef::VK_EXT_descriptor_buffer[]
  * ename:VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT specifies that
    the buffer is suitable to contain sampler and combined image sampler
    descriptors when bound as a descriptor buffer.
    Buffers containing combined image sampler descriptors must: also specify
    ename:VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT.
  * ename:VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT specifies that
    the buffer is suitable to contain resource descriptors when bound as a
    descriptor buffer.
  * ename:VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT
    specifies that the buffer, when bound, can: be used by the
    implementation to support push descriptors when using descriptor
    buffers.
endif::VK_EXT_descriptor_buffer[]
ifdef::VK_NV_ray_tracing[]
  * ename:VK_BUFFER_USAGE_RAY_TRACING_BIT_NV specifies that the buffer is
    suitable for use in flink:vkCmdTraceRaysNV.
endif::VK_NV_ray_tracing[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * ename:VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR specifies that the
    buffer is suitable for use as a <<shader-binding-table,Shader Binding
    Table>>.
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_KHR_acceleration_structure[]
  * ename:VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR
    specifies that the buffer is suitable for use as a read-only input to an
    <<acceleration-structure-building,acceleration structure build>>.
  * ename:VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR specifies
    that the buffer is suitable for storage space for a
    slink:VkAccelerationStructureKHR.
endif::VK_KHR_acceleration_structure[]
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
  * ename:VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT specifies that the
    buffer can: be used to retrieve a buffer device address via
    flink:vkGetBufferDeviceAddress and use that address to access the
    buffer's memory from a shader.
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
ifdef::VK_KHR_video_decode_queue[]
  * ename:VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR specifies that the buffer
    can: be used as the source video bitstream buffer in a
    <<video-decode-operations, video decode operation>>.
  * ename:VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR is reserved for future
    use.
endif::VK_KHR_video_decode_queue[]
ifdef::VK_KHR_video_encode_queue[]
  * ename:VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR specifies that the buffer
    can: be used as the destination video bitstream buffer in a
    <<video-encode-operations, video encode operation>>.
  * ename:VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR is reserved for future
    use.
endif::VK_KHR_video_encode_queue[]
ifdef::VK_AMDX_shader_enqueue[]
  * ename:VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX specifies that
    the buffer can: be used for as scratch memory for
    <<executiongraphs,execution graph dispatch>>.
endif::VK_AMDX_shader_enqueue[]
--

[open,refpage='VkBufferUsageFlags',desc='Bitmask of VkBufferUsageFlagBits',type='flags']
--
include::{generated}/api/flags/VkBufferUsageFlags.adoc[]

tname:VkBufferUsageFlags is a bitmask type for setting a mask of zero or
more elink:VkBufferUsageFlagBits.
--

[open,refpage='VkBufferCreateFlagBits',desc='Bitmask specifying additional parameters of a buffer',type='enums']
--
Bits which can: be set in slink:VkBufferCreateInfo::pname:flags, specifying
additional parameters of a buffer, are:

include::{generated}/api/enums/VkBufferCreateFlagBits.adoc[]

  * ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT specifies that the buffer will
    be backed using sparse memory binding.
ifdef::VKSC_VERSION_1_0[]
    This flag is not supported in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]
  * ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT specifies that the buffer
    can: be partially backed using sparse memory binding.
    Buffers created with this flag must: also be created with the
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag.
ifdef::VKSC_VERSION_1_0[]
    This flag is not supported in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]
  * ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT specifies that the buffer will
    be backed using sparse memory binding with memory ranges that might also
    simultaneously be backing another buffer (or another portion of the same
    buffer).
    Buffers created with this flag must: also be created with the
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag.
ifdef::VKSC_VERSION_1_0[]
    This flag is not supported in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]
ifdef::VK_VERSION_1_1[]
  * ename:VK_BUFFER_CREATE_PROTECTED_BIT specifies that the buffer is a
    protected buffer.
endif::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
  * ename:VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT specifies that
    the buffer's address can: be saved and reused on a subsequent run (e.g.
    for trace capture and replay), see
    slink:VkBufferOpaqueCaptureAddressCreateInfo for more detail.
endif::VK_VERSION_1_2,VK_EXT_buffer_device_address,VK_KHR_buffer_device_address[]
ifdef::VK_EXT_descriptor_buffer[]
  * ename:VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
    specifies that the buffer can: be used with descriptor buffers when
    capturing and replaying (e.g. for trace capture and replay), see
    slink:VkOpaqueCaptureDescriptorDataCreateInfoEXT for more detail.
endif::VK_EXT_descriptor_buffer[]
ifdef::VK_KHR_video_maintenance1[]
  * ename:VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR specifies that
    the buffer can: be used in <<video-coding,video coding operations>>
    without having to specify at buffer creation time the set of video
    profiles the buffer will be used with.
endif::VK_KHR_video_maintenance1[]

See <<sparsememory-sparseresourcefeatures,Sparse Resource Features>> and
<<features, Physical Device Features>> for details of the sparse memory
features supported on a device.
--

[open,refpage='VkBufferCreateFlags',desc='Bitmask of VkBufferCreateFlagBits',type='flags']
--
include::{generated}/api/flags/VkBufferCreateFlags.adoc[]

tname:VkBufferCreateFlags is a bitmask type for setting a mask of zero or
more elink:VkBufferCreateFlagBits.
--

ifdef::VK_NV_dedicated_allocation[]
[open,refpage='VkDedicatedAllocationBufferCreateInfoNV',desc='Specify that a buffer is bound to a dedicated memory resource',type='structs']
--
If the pname:pNext chain includes a
sname:VkDedicatedAllocationBufferCreateInfoNV structure, then that structure
includes an enable controlling whether the buffer will have a dedicated
memory allocation bound to it.

The sname:VkDedicatedAllocationBufferCreateInfoNV structure is defined as:

include::{generated}/api/structs/VkDedicatedAllocationBufferCreateInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:dedicatedAllocation specifies whether the buffer will have a
    dedicated allocation bound to it.

include::{generated}/validity/structs/VkDedicatedAllocationBufferCreateInfoNV.adoc[]
--
endif::VK_NV_dedicated_allocation[]

ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
[open,refpage='VkExternalMemoryBufferCreateInfo',desc='Specify that a buffer may be backed by external memory',type='structs']
--
To define a set of external memory handle types that may: be used as backing
store for a buffer, add a slink:VkExternalMemoryBufferCreateInfo structure
to the pname:pNext chain of the slink:VkBufferCreateInfo structure.
The sname:VkExternalMemoryBufferCreateInfo structure is defined as:

include::{generated}/api/structs/VkExternalMemoryBufferCreateInfo.adoc[]

ifdef::VK_KHR_external_memory[]
or the equivalent

include::{generated}/api/structs/VkExternalMemoryBufferCreateInfoKHR.adoc[]
endif::VK_KHR_external_memory[]

[NOTE]
====
A sname:VkExternalMemoryBufferCreateInfo structure with a non-zero
pname:handleTypes field must be included in the creation parameters for a
buffer that will be bound to memory that is either exported or imported.
====

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:handleTypes is zero or a bitmask of
    elink:VkExternalMemoryHandleTypeFlagBits specifying one or more external
    memory handle types.

include::{generated}/validity/structs/VkExternalMemoryBufferCreateInfo.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_external_memory[]

ifdef::VK_VERSION_1_2,VK_KHR_buffer_device_address[]
[open,refpage='VkBufferOpaqueCaptureAddressCreateInfo',desc='Request a specific address for a buffer',type='structs',alias='VkBufferOpaqueCaptureAddressCreateInfoKHR']
--
To request a specific device address for a buffer, add a
slink:VkBufferOpaqueCaptureAddressCreateInfo structure to the pname:pNext
chain of the slink:VkBufferCreateInfo structure.
The sname:VkBufferOpaqueCaptureAddressCreateInfo structure is defined as:

include::{generated}/api/structs/VkBufferOpaqueCaptureAddressCreateInfo.adoc[]

ifdef::VK_KHR_buffer_device_address[]
or the equivalent

include::{generated}/api/structs/VkBufferOpaqueCaptureAddressCreateInfoKHR.adoc[]
endif::VK_KHR_buffer_device_address[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:opaqueCaptureAddress is the opaque capture address requested for
    the buffer.

If pname:opaqueCaptureAddress is zero, no specific address is requested.

If pname:opaqueCaptureAddress is not zero, then it should: be an address
retrieved from flink:vkGetBufferOpaqueCaptureAddress for an identically
created buffer on the same implementation.

If this structure is not present, it is as if pname:opaqueCaptureAddress is
zero.

Apps should: avoid creating buffers with app-provided addresses and
implementation-provided addresses in the same process, to reduce the
likelihood of ename:VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS errors.

[NOTE]
====
The expected usage for this is that a trace capture/replay tool will add the
ename:VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT flag to all buffers
that use ename:VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, and during capture
will save the queried opaque device addresses in the trace.
During replay, the buffers will be created specifying the original address
so any address values stored in the trace data will remain valid.

Implementations are expected to separate such buffers in the GPU address
space so normal allocations will avoid using these addresses.
Apps/tools should avoid mixing app-provided and implementation-provided
addresses for buffers created with
ename:VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT, to avoid address
space allocation conflicts.
====

include::{generated}/validity/structs/VkBufferOpaqueCaptureAddressCreateInfo.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_buffer_device_address[]

ifdef::VK_EXT_buffer_device_address[]
[open,refpage='VkBufferDeviceAddressCreateInfoEXT',desc='Request a specific address for a buffer',type='structs']
--
ifdef::VK_VERSION_1_2,VK_KHR_buffer_device_address[]
Alternatively, to
endif::VK_VERSION_1_2,VK_KHR_buffer_device_address[]
ifndef::VK_VERSION_1_2,VK_KHR_buffer_device_address[]
To
endif::VK_VERSION_1_2,VK_KHR_buffer_device_address[]
request a specific device address for a buffer, add a
slink:VkBufferDeviceAddressCreateInfoEXT structure to the pname:pNext chain
of the slink:VkBufferCreateInfo structure.
The sname:VkBufferDeviceAddressCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkBufferDeviceAddressCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:deviceAddress is the device address requested for the buffer.

If pname:deviceAddress is zero, no specific address is requested.

If pname:deviceAddress is not zero, then it must: be an address retrieved
from an identically created buffer on the same implementation.
The buffer must: also be bound to an identically created
sname:VkDeviceMemory object.

If this structure is not present, it is as if pname:deviceAddress is zero.

Apps should: avoid creating buffers with app-provided addresses and
implementation-provided addresses in the same process, to reduce the
likelihood of ename:VK_ERROR_INVALID_DEVICE_ADDRESS_EXT errors.

include::{generated}/validity/structs/VkBufferDeviceAddressCreateInfoEXT.adoc[]
--
endif::VK_EXT_buffer_device_address[]


ifdef::VK_FUCHSIA_buffer_collection[]
[open,refpage='VkBufferCollectionBufferCreateInfoFUCHSIA',desc='Create a VkBufferCollectionFUCHSIA-compatible VkBuffer',type='structs']
--
The sname:VkBufferCollectionBufferCreateInfoFUCHSIA structure is defined as:

include::{generated}/api/structs/VkBufferCollectionBufferCreateInfoFUCHSIA.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure
  * pname:collection is the slink:VkBufferCollectionFUCHSIA handle
  * pname:index is the index of the buffer in the buffer collection from
    which the memory will be imported

.Valid Usage
****
  * [[VUID-VkBufferCollectionBufferCreateInfoFUCHSIA-index-06388]]
    pname:index must: be less than
    slink:VkBufferCollectionPropertiesFUCHSIA::pname:bufferCount
****

include::{generated}/validity/structs/VkBufferCollectionBufferCreateInfoFUCHSIA.adoc[]
--
endif::VK_FUCHSIA_buffer_collection[]

[open,refpage='vkDestroyBuffer',desc='Destroy a buffer object',type='protos']
--
To destroy a buffer, call:

include::{generated}/api/protos/vkDestroyBuffer.adoc[]

  * pname:device is the logical device that destroys the buffer.
  * pname:buffer is the buffer to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyBuffer-buffer-00922]]
    All submitted commands that refer to pname:buffer, either directly or
    via a sname:VkBufferView, must: have completed execution
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkDestroyBuffer-buffer-00923]]
    If sname:VkAllocationCallbacks were provided when pname:buffer was
    created, a compatible set of callbacks must: be provided here
  * [[VUID-vkDestroyBuffer-buffer-00924]]
    If no sname:VkAllocationCallbacks were provided when pname:buffer was
    created, pname:pAllocator must: be `NULL`
endif::VKSC_VERSION_1_0[]
****

include::{generated}/validity/protos/vkDestroyBuffer.adoc[]
--


[[resources-buffer-views]]
== Buffer Views

[open,refpage='VkBufferView',desc='Opaque handle to a buffer view object',type='handles']
--
A _buffer view_ represents a contiguous range of a buffer and a specific
format to be used to interpret the data.
Buffer views are used to enable shaders to access buffer contents using
<<textures,image operations>>.
In order to create a valid buffer view, the buffer must: have been created
with at least one of the following usage flags:

  * ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT
  * ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT

Buffer views are represented by sname:VkBufferView handles:

include::{generated}/api/handles/VkBufferView.adoc[]
--

[open,refpage='vkCreateBufferView',desc='Create a new buffer view object',type='protos']
--
:refpage: vkCreateBufferView
:objectnameplural: buffer views
:objectnamecamelcase: bufferView
:objectnamestruct: VkDeviceObjectReservationCreateInfo
:objectcount: 1

To create a buffer view, call:

include::{generated}/api/protos/vkCreateBufferView.adoc[]

  * pname:device is the logical device that creates the buffer view.
  * pname:pCreateInfo is a pointer to a slink:VkBufferViewCreateInfo
    structure containing parameters to be used to create the buffer view.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pView is a pointer to a slink:VkBufferView handle in which the
    resulting buffer view object is returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkCreateBufferView-device-09665]]
    pname:device must: support at least one queue family with one of the
    ename:VK_QUEUE_COMPUTE_BIT or ename:VK_QUEUE_GRAPHICS_BIT capabilities
ifdef::VKSC_VERSION_1_0[]
include::{chapters}/commonvalidity/memory_reservation_request_count_common.adoc[]
endif::VKSC_VERSION_1_0[]
****

include::{generated}/validity/protos/vkCreateBufferView.adoc[]
--

[open,refpage='VkBufferViewCreateInfo',desc='Structure specifying parameters of a newly created buffer view',type='structs']
--
The sname:VkBufferViewCreateInfo structure is defined as:

include::{generated}/api/structs/VkBufferViewCreateInfo.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:buffer is a slink:VkBuffer on which the view will be created.
  * pname:format is a elink:VkFormat describing the format of the data
    elements in the buffer.
  * pname:offset is an offset in bytes from the base address of the buffer.
    Accesses to the buffer view from shaders use addressing that is relative
    to this starting offset.
  * pname:range is a size in bytes of the buffer view.
    If pname:range is equal to ename:VK_WHOLE_SIZE, the range from
    pname:offset to the end of the buffer is used.
    If ename:VK_WHOLE_SIZE is used and the remaining size of the buffer is
    not a multiple of the <<texel-block-size, texel block size>> of
    pname:format, the nearest smaller multiple is used.

[[resources-buffer-views-usage]]
The buffer view has a _buffer view usage_ identifying which descriptor types
can be created from it.
This usage
ifdef::VK_KHR_maintenance5[]
can: be defined by including the slink:VkBufferUsageFlags2CreateInfoKHR
structure in the pname:pNext chain, and specifying the pname:usage value
there.
If this structure is not included, it
endif::VK_KHR_maintenance5[]
is equal to the slink:VkBufferCreateInfo::pname:usage value used to create
pname:buffer.

.Valid Usage
****
  * [[VUID-VkBufferViewCreateInfo-offset-00925]]
    pname:offset must: be less than the size of pname:buffer
  * [[VUID-VkBufferViewCreateInfo-range-00928]]
    If pname:range is not equal to ename:VK_WHOLE_SIZE, pname:range must: be
    greater than `0`
  * [[VUID-VkBufferViewCreateInfo-range-00929]]
    If pname:range is not equal to ename:VK_WHOLE_SIZE, pname:range must: be
    an integer multiple of the texel block size of pname:format
  * [[VUID-VkBufferViewCreateInfo-range-00930]]
    If pname:range is not equal to ename:VK_WHOLE_SIZE, the number of texel
    buffer elements given by [eq]#({lfloor}pname:range / (texel block
    size){rfloor} {times} (texels per block))# where texel block size and
    texels per block are as defined in the <<formats-compatibility,
    Compatible Formats>> table for pname:format, must: be less than or equal
    to sname:VkPhysicalDeviceLimits::pname:maxTexelBufferElements
  * [[VUID-VkBufferViewCreateInfo-offset-00931]]
    If pname:range is not equal to ename:VK_WHOLE_SIZE, the sum of
    pname:offset and pname:range must: be less than or equal to the size of
    pname:buffer
  * [[VUID-VkBufferViewCreateInfo-range-04059]]
    If pname:range is equal to ename:VK_WHOLE_SIZE, the number of texel
    buffer elements given by [eq]#({lfloor}(size - pname:offset) / (texel
    block size){rfloor} {times} (texels per block))# where size is the size
    of pname:buffer, and texel block size and texels per block are as
    defined in the <<formats-compatibility, Compatible Formats>> table for
    pname:format, must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxTexelBufferElements
  * [[VUID-VkBufferViewCreateInfo-buffer-00932]]
    pname:buffer must: have been created with a pname:usage value containing
    at least one of ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or
    ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT
  * [[VUID-VkBufferViewCreateInfo-format-08778]]
    If the <<resources-buffer-views-usage, buffer view usage>> contains
    ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT, then
    <<resources-buffer-view-format-features,format features>> of
    pname:format must: contain
    ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT
  * [[VUID-VkBufferViewCreateInfo-format-08779]]
    If the <<resources-buffer-views-usage, buffer view usage>> contains
    ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, then
    <<resources-buffer-view-format-features,format features>> of
    pname:format must: contain
    ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT
  * [[VUID-VkBufferViewCreateInfo-buffer-00935]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-VkBufferViewCreateInfo-offset-02749]]
ifdef::VK_VERSION_1_3,VK_EXT_texel_buffer_alignment[]
    If the <<features-texelBufferAlignment, pname:texelBufferAlignment>>
    feature is not enabled,
endif::VK_VERSION_1_3,VK_EXT_texel_buffer_alignment[]
    pname:offset must: be a multiple of
    sname:VkPhysicalDeviceLimits::pname:minTexelBufferOffsetAlignment
ifdef::VK_VERSION_1_3,VK_EXT_texel_buffer_alignment[]
  * [[VUID-VkBufferViewCreateInfo-buffer-02750]]
    If the <<features-texelBufferAlignment, pname:texelBufferAlignment>>
    feature is enabled and if pname:buffer was created with pname:usage
    containing ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, pname:offset
    must: be a multiple of the lesser of
    slink:VkPhysicalDeviceTexelBufferAlignmentProperties::pname:storageTexelBufferOffsetAlignmentBytes
    or, if
    slink:VkPhysicalDeviceTexelBufferAlignmentProperties::pname:storageTexelBufferOffsetSingleTexelAlignment
    is ename:VK_TRUE, the size of a texel of the requested pname:format.
    If the size of a texel is a multiple of three bytes, then the size of a
    single component of pname:format is used instead
  * [[VUID-VkBufferViewCreateInfo-buffer-02751]]
    If the <<features-texelBufferAlignment, pname:texelBufferAlignment>>
    feature is enabled and if pname:buffer was created with pname:usage
    containing ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT, pname:offset
    must: be a multiple of the lesser of
    slink:VkPhysicalDeviceTexelBufferAlignmentProperties::pname:uniformTexelBufferOffsetAlignmentBytes
    or, if
    slink:VkPhysicalDeviceTexelBufferAlignmentProperties::pname:uniformTexelBufferOffsetSingleTexelAlignment
    is ename:VK_TRUE, the size of a texel of the requested pname:format.
    If the size of a texel is a multiple of three bytes, then the size of a
    single component of pname:format is used instead
endif::VK_VERSION_1_3,VK_EXT_texel_buffer_alignment[]
ifdef::VK_EXT_metal_objects[]
  * [[VUID-VkBufferViewCreateInfo-pNext-06782]]
    If the pname:pNext chain includes a
    slink:VkExportMetalObjectCreateInfoEXT structure, its
    pname:exportObjectType member must: be
    ename:VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT
endif::VK_EXT_metal_objects[]
ifdef::VK_KHR_maintenance5[]
  * [[VUID-VkBufferViewCreateInfo-pNext-08780]]
    If the pname:pNext chain includes a
    slink:VkBufferUsageFlags2CreateInfoKHR, its pname:usage must: not
    contain any other bit than
    ename:VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR or
    ename:VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR
  * [[VUID-VkBufferViewCreateInfo-pNext-08781]]
    If the pname:pNext chain includes a
    slink:VkBufferUsageFlags2CreateInfoKHR, its pname:usage must: be a
    subset of the slink:VkBufferCreateInfo::pname:usage specified or
    slink:VkBufferUsageFlags2CreateInfoKHR::pname:usage from
    slink:VkBufferCreateInfo::pname:pNext when creating pname:buffer
endif::VK_KHR_maintenance5[]
****

include::{generated}/validity/structs/VkBufferViewCreateInfo.adoc[]
--

[open,refpage='VkBufferViewCreateFlags',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkBufferViewCreateFlags.adoc[]

tname:VkBufferViewCreateFlags is a bitmask type for setting a mask, but is
currently reserved for future use.
--

[open,refpage='vkDestroyBufferView',desc='Destroy a buffer view object',type='protos']
--
To destroy a buffer view, call:

include::{generated}/api/protos/vkDestroyBufferView.adoc[]

  * pname:device is the logical device that destroys the buffer view.
  * pname:bufferView is the buffer view to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyBufferView-bufferView-00936]]
    All submitted commands that refer to pname:bufferView must: have
    completed execution
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkDestroyBufferView-bufferView-00937]]
    If sname:VkAllocationCallbacks were provided when pname:bufferView was
    created, a compatible set of callbacks must: be provided here
  * [[VUID-vkDestroyBufferView-bufferView-00938]]
    If no sname:VkAllocationCallbacks were provided when pname:bufferView
    was created, pname:pAllocator must: be `NULL`
endif::VKSC_VERSION_1_0[]
****

include::{generated}/validity/protos/vkDestroyBufferView.adoc[]
--


[[resources-buffer-view-format-features]]
=== Buffer View Format Features

Valid uses of a slink:VkBufferView may: depend on the buffer view's _format
features_, defined below.
Such constraints are documented in the affected valid usage statement.

ifndef::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
  * The buffer view's set of _format features_ is the value of
    slink:VkFormatProperties::pname:bufferFeatures found by calling
    flink:vkGetPhysicalDeviceFormatProperties on the same pname:format as
    slink:VkBufferViewCreateInfo::pname:format.
endif::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
ifdef::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
  * If Vulkan 1.3 is supported or the `apiext:VK_KHR_format_feature_flags2`
    extension is supported, then the buffer view's set of _format features_
    is the value of slink:VkFormatProperties3::pname:bufferFeatures found by
    calling flink:vkGetPhysicalDeviceFormatProperties2 on the same
    pname:format as slink:VkBufferViewCreateInfo::pname:format.
endif::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]


[[resources-images]]
== Images

[open,refpage='VkImage',desc='Opaque handle to an image object',type='handles']
--
Images represent multidimensional - up to 3 - arrays of data which can: be
used for various purposes (e.g. attachments, textures), by binding them to a
graphics or compute pipeline via descriptor sets, or by directly specifying
them as parameters to certain commands.

Images are represented by sname:VkImage handles:

include::{generated}/api/handles/VkImage.adoc[]
--

[open,refpage='vkCreateImage',desc='Create a new image object',type='protos']
--
:refpage: vkCreateImage
:objectnameplural: images
:objectnamecamelcase: image
:objectnamestruct: VkDeviceObjectReservationCreateInfo
:objectcount: 1

To create images, call:

include::{generated}/api/protos/vkCreateImage.adoc[]

  * pname:device is the logical device that creates the image.
  * pname:pCreateInfo is a pointer to a slink:VkImageCreateInfo structure
    containing parameters to be used to create the image.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pImage is a pointer to a slink:VkImage handle in which the
    resulting image object is returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkCreateImage-device-09666]]
    pname:device must: support at least one queue family with one of the
ifdef::VK_KHR_video_encode_queue[]
    ename:VK_QUEUE_VIDEO_ENCODE_BIT_KHR,
endif::VK_KHR_video_encode_queue[]
ifdef::VK_KHR_video_decode_queue[]
    ename:VK_QUEUE_VIDEO_DECODE_BIT_KHR,
endif::VK_KHR_video_decode_queue[]
ifdef::VK_NV_optical_flow[]
    ename:VK_QUEUE_OPTICAL_FLOW_BIT_NV,
endif::VK_NV_optical_flow[]
ifndef::VKSC_VERSION_1_0[ename:VK_QUEUE_SPARSE_BINDING_BIT,]
    ename:VK_QUEUE_TRANSFER_BIT, ename:VK_QUEUE_COMPUTE_BIT, or
    ename:VK_QUEUE_GRAPHICS_BIT capabilities
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkCreateImage-flags-00939]]
    If the pname:flags member of pname:pCreateInfo includes
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
ifdef::VK_NV_extended_sparse_address_space[]
    and the <<features-extendedSparseAddressSpace,
    pname:extendedSparseAddressSpace>> feature is not enabled,
endif::VK_NV_extended_sparse_address_space[]
    creating this sname:VkImage must: not cause the total required sparse
    memory for all currently valid sparse resources on the device to exceed
    sname:VkPhysicalDeviceLimits::pname:sparseAddressSpaceSize
ifdef::VK_NV_extended_sparse_address_space[]
  * [[VUID-vkCreateImage-flags-09385]]
    If the pname:flags member of pname:pCreateInfo includes
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT, the
    <<features-extendedSparseAddressSpace,
    pname:extendedSparseAddressSpace>> feature is enabled, and the
    pname:usage member of pname:pCreateInfo contains bits not in
    sname:VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV::pname:extendedSparseImageUsageFlags,
    creating this sname:VkImage must: not cause the total required sparse
    memory for all currently valid sparse resources on the device, excluding
    sname:VkBuffer created with pname:usage member of pname:pCreateInfo
    containing bits in
    sname:VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV::pname:extendedSparseBufferUsageFlags
    and sname:VkImage created with pname:usage member of pname:pCreateInfo
    containing bits in
    sname:VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV::pname:extendedSparseImageUsageFlags,
    to exceed sname:VkPhysicalDeviceLimits::pname:sparseAddressSpaceSize
  * [[VUID-vkCreateImage-flags-09386]]
    If the pname:flags member of pname:pCreateInfo includes
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT and the
    <<features-extendedSparseAddressSpace,
    pname:extendedSparseAddressSpace>> feature is enabled, creating this
    sname:VkImage must: not cause the total required sparse memory for all
    currently valid sparse resources on the device to exceed
    sname:VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV::pname:extendedSparseAddressSpaceSize
endif::VK_NV_extended_sparse_address_space[]
endif::VKSC_VERSION_1_0[]
include::{chapters}/commonvalidity/memory_reservation_request_count_common.adoc[]
ifdef::VK_FUCHSIA_buffer_collection[]
  * [[VUID-vkCreateImage-pNext-06389]]
    If a slink:VkBufferCollectionImageCreateInfoFUCHSIA has been chained to
    pname:pNext, pname:pCreateInfo must: match the
    <<sysmem-chosen-create-infos,Sysmem chosen sname:VkImageCreateInfo>>
    excepting members slink:VkImageCreateInfo::pname:extent and
    slink:VkImageCreateInfo::pname:usage in the match criteria
endif::VK_FUCHSIA_buffer_collection[]
****

include::{generated}/validity/protos/vkCreateImage.adoc[]
--

[open,refpage='VkImageCreateInfo',desc='Structure specifying the parameters of a newly created image object',type='structs']
--
The sname:VkImageCreateInfo structure is defined as:

include::{generated}/api/structs/VkImageCreateInfo.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkImageCreateFlagBits describing
    additional parameters of the image.
  * pname:imageType is a elink:VkImageType value specifying the basic
    dimensionality of the image.
    Layers in array textures do not count as a dimension for the purposes of
    the image type.
  * pname:format is a elink:VkFormat describing the format and type of the
    texel blocks that will be contained in the image.
  * pname:extent is a slink:VkExtent3D describing the number of data
    elements in each dimension of the base level.
  * pname:mipLevels describes the number of levels of detail available for
    minified sampling of the image.
  * pname:arrayLayers is the number of layers in the image.
  * pname:samples is a elink:VkSampleCountFlagBits value specifying the
    number of <<primsrast-multisampling,samples per texel>>.
  * pname:tiling is a elink:VkImageTiling value specifying the tiling
    arrangement of the texel blocks in memory.
  * pname:usage is a bitmask of elink:VkImageUsageFlagBits describing the
    intended usage of the image.
  * pname:sharingMode is a elink:VkSharingMode value specifying the sharing
    mode of the image when it will be accessed by multiple queue families.
  * pname:queueFamilyIndexCount is the number of entries in the
    pname:pQueueFamilyIndices array.
  * pname:pQueueFamilyIndices is a pointer to an array of queue families
    that will access this image.
    It is ignored if pname:sharingMode is not
    ename:VK_SHARING_MODE_CONCURRENT.
  * pname:initialLayout is a elink:VkImageLayout value specifying the
    initial elink:VkImageLayout of all image subresources of the image.
    See <<resources-image-layouts,Image Layouts>>.

Images created with pname:tiling equal to ename:VK_IMAGE_TILING_LINEAR have
further restrictions on their limits and capabilities compared to images
created with pname:tiling equal to ename:VK_IMAGE_TILING_OPTIMAL.
Creation of images with tiling ename:VK_IMAGE_TILING_LINEAR may: not be
supported unless other parameters meet all of the constraints:

  * pname:imageType is ename:VK_IMAGE_TYPE_2D
  * pname:format is not a depth/stencil format
  * pname:mipLevels is 1
  * pname:arrayLayers is 1
  * pname:samples is ename:VK_SAMPLE_COUNT_1_BIT
  * pname:usage only includes ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT and/or
    ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
Images created with one of the <<formats-requiring-sampler-ycbcr-conversion,
formats that require a sampler {YCbCr} conversion>>, have further
restrictions on their limits and capabilities compared to images created
with other formats.
Creation of images with a format requiring
<<formats-requiring-sampler-ycbcr-conversion, {YCbCr} conversion>> may: not
be supported unless other parameters meet all of the constraints:

  * pname:imageType is ename:VK_IMAGE_TYPE_2D
  * pname:mipLevels is 1
  * pname:arrayLayers is 1, unless
ifdef::VK_EXT_ycbcr_image_arrays[]
    the pname:ycbcrImageArrays feature is enabled, or
endif::VK_EXT_ycbcr_image_arrays[]
    otherwise indicated by
    slink:VkImageFormatProperties::pname:maxArrayLayers, as returned by
    flink:vkGetPhysicalDeviceImageFormatProperties
  * pname:samples is ename:VK_SAMPLE_COUNT_1_BIT
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

Implementations may: support additional limits and capabilities beyond those
listed above.

To determine the set of valid pname:usage bits for a given format, call
flink:vkGetPhysicalDeviceFormatProperties.

If the size of the resultant image would exceed pname:maxResourceSize, then
flink:vkCreateImage must: fail and return
ename:VK_ERROR_OUT_OF_DEVICE_MEMORY.
This failure may: occur even when all image creation parameters satisfy
their valid usage requirements.

ifdef::VK_EXT_host_image_copy[]
If the implementation reports ename:VK_TRUE in
slink:VkPhysicalDeviceHostImageCopyPropertiesEXT::pname:identicalMemoryTypeRequirements,
usage of ename:VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT must: not affect the
memory type requirements of the image as described in
ifndef::VKSC_VERSION_1_0[]
<<sparsememory-memory-requirements,Sparse Resource Memory Requirements>> and
endif::VKSC_VERSION_1_0[]
<<resources-association,Resource Memory Association>>.
endif::VK_EXT_host_image_copy[]

ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
[NOTE]
====
For images created without ename:VK_IMAGE_CREATE_EXTENDED_USAGE_BIT a
pname:usage bit is valid if it is supported for the format the image is
created with.

For images created with ename:VK_IMAGE_CREATE_EXTENDED_USAGE_BIT a
pname:usage bit is valid if it is supported for at least one of the formats
a sname:VkImageView created from the image can: have (see
<<resources-image-views,Image Views>> for more detail).
====
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]

[[resources-image-creation-limits]]
.Image Creation Limits
****
Valid values for some image creation parameters are limited by a numerical
upper bound or by inclusion in a bitset.
For example, slink:VkImageCreateInfo::pname:arrayLayers is limited by
pname:imageCreateMaxArrayLayers, defined below; and
slink:VkImageCreateInfo::pname:samples is limited by
pname:imageCreateSampleCounts, also defined below.

Several limiting values are defined below, as well as assisting values from
which the limiting values are derived.
The limiting values are referenced by the relevant valid usage statements of
slink:VkImageCreateInfo.

ifdef::VK_EXT_image_drm_format_modifier[]
  * Let `uint64_t imageCreateDrmFormatModifiers[]` be the set of
    <<glossary-drm-format-modifier,Linux DRM format modifiers>> that the
    resultant image may: have.
  ** If pname:tiling is not ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,
     then pname:imageCreateDrmFormatModifiers is empty.
  ** If slink:VkImageCreateInfo::pname:pNext contains
     slink:VkImageDrmFormatModifierExplicitCreateInfoEXT, then
     pname:imageCreateDrmFormatModifiers contains exactly one modifier,
     slink:VkImageDrmFormatModifierExplicitCreateInfoEXT::pname:drmFormatModifier.
  ** If slink:VkImageCreateInfo::pname:pNext contains
     slink:VkImageDrmFormatModifierListCreateInfoEXT, then
     pname:imageCreateDrmFormatModifiers contains the entire array
     slink:VkImageDrmFormatModifierListCreateInfoEXT::pname:pDrmFormatModifiers.
endif::VK_EXT_image_drm_format_modifier[]

  * Let `VkBool32 imageCreateMaybeLinear` indicate if the resultant image
    may be <<glossary-linear-resource,linear>>.
ifndef::VK_EXT_image_drm_format_modifier[]
    (The definition below is trivial because certain extensions are disabled
    in this build of the specification).
endif::VK_EXT_image_drm_format_modifier[]
  ** If pname:tiling is ename:VK_IMAGE_TILING_LINEAR, then
     pname:imageCreateMaybeLinear is ename:VK_TRUE.
  ** If pname:tiling is ename:VK_IMAGE_TILING_OPTIMAL, then
     pname:imageCreateMaybeLinear is ename:VK_FALSE.
ifdef::VK_EXT_image_drm_format_modifier[]
  ** If pname:tiling is ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then
     pname:imageCreateMaybeLinear is ename:VK_TRUE if and only if
     pname:imageCreateDrmFormatModifiers contains
     etext:DRM_FORMAT_MOD_LINEAR.
endif::VK_EXT_image_drm_format_modifier[]

  * Let `VkFormatFeatureFlags imageCreateFormatFeatures` be the set of valid
    _format features_ available during image creation.
  ** If pname:tiling is ename:VK_IMAGE_TILING_LINEAR, then
     pname:imageCreateFormatFeatures is the value of
     slink:VkFormatProperties::pname:linearTilingFeatures found by calling
     flink:vkGetPhysicalDeviceFormatProperties with parameter pname:format
     equal to slink:VkImageCreateInfo::pname:format.
  ** If pname:tiling is ename:VK_IMAGE_TILING_OPTIMAL,
ifdef::VK_ANDROID_external_memory_android_hardware_buffer,VK_QNX_external_memory_screen_buffer[]
     and if the pname:pNext chain includes no
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
     slink:VkExternalFormatANDROID
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
     or
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
     slink:VkExternalFormatQNX
endif::VK_QNX_external_memory_screen_buffer[]
     structure with non-zero pname:externalFormat,
endif::VK_ANDROID_external_memory_android_hardware_buffer,VK_QNX_external_memory_screen_buffer[]
     then pname:imageCreateFormatFeatures is the value of
     slink:VkFormatProperties::pname:optimalTilingFeatures found by calling
     flink:vkGetPhysicalDeviceFormatProperties with parameter pname:format
     equal to slink:VkImageCreateInfo::pname:format.
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
  ** If pname:tiling is ename:VK_IMAGE_TILING_OPTIMAL, and if the
     pname:pNext chain includes a slink:VkExternalFormatANDROID structure
     with non-zero pname:externalFormat, then
     pname:imageCreateFormatFeatures is the value of
     slink:VkAndroidHardwareBufferFormatPropertiesANDROID::pname:formatFeatures
     obtained by flink:vkGetAndroidHardwareBufferPropertiesANDROID with a
     matching pname:externalFormat value.
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
  ** If pname:tiling is ename:VK_IMAGE_TILING_OPTIMAL, and if the
     pname:pNext chain includes a slink:VkExternalFormatQNX structure with
     non-zero pname:externalFormat, then pname:imageCreateFormatFeatures is
     the value of
     slink:VkScreenBufferFormatPropertiesQNX::pname:formatFeatures obtained
     by flink:vkGetScreenBufferPropertiesQNX with a matching
     pname:externalFormat value.
endif::VK_QNX_external_memory_screen_buffer[]
ifdef::VK_FUCHSIA_buffer_collection[]
  ** If the pname:pNext chain includes a
     slink:VkBufferCollectionImageCreateInfoFUCHSIA structure, then
     pname:imageCreateFormatFeatures is the value of
     slink:VkBufferCollectionPropertiesFUCHSIA::pname:formatFeatures found
     by calling flink:vkGetBufferCollectionPropertiesFUCHSIA with a
     parameter pname:collection equal to
     slink:VkBufferCollectionImageCreateInfoFUCHSIA::pname:collection
endif::VK_FUCHSIA_buffer_collection[]
ifdef::VK_EXT_image_drm_format_modifier[]
  ** If pname:tiling is ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then
     the value of pname:imageCreateFormatFeatures is found by calling
     flink:vkGetPhysicalDeviceFormatProperties2 with
     slink:VkImageFormatProperties::pname:format equal to
     slink:VkImageCreateInfo::pname:format and with
     slink:VkDrmFormatModifierPropertiesListEXT chained into
     slink:VkFormatProperties2; by collecting all members of the returned
     array
     slink:VkDrmFormatModifierPropertiesListEXT::pname:pDrmFormatModifierProperties
     whose pname:drmFormatModifier belongs to
     pname:imageCreateDrmFormatModifiers; and by taking the bitwise
     intersection, over the collected array members, of
     pname:drmFormatModifierTilingFeatures.
     (The resultant pname:imageCreateFormatFeatures may: be empty).
endif::VK_EXT_image_drm_format_modifier[]

ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
  * Let `VkImageFormatProperties2 imageCreateImageFormatPropertiesList[]` be
ifdef::VK_ANDROID_external_memory_android_hardware_buffer,VK_QNX_external_memory_screen_buffer[]
    defined as follows.
  ** If slink:VkImageCreateInfo::pname:pNext contains no
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
     slink:VkExternalFormatANDROID
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
     or
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
     slink:VkExternalFormatQNX
endif::VK_QNX_external_memory_screen_buffer[]
     structure with non-zero pname:externalFormat, then
     pname:imageCreateImageFormatPropertiesList is
endif::VK_ANDROID_external_memory_android_hardware_buffer,VK_QNX_external_memory_screen_buffer[]
     the list of structures obtained by calling
     flink:vkGetPhysicalDeviceImageFormatProperties2, possibly multiple
     times, as follows:
  *** The parameters slink:VkPhysicalDeviceImageFormatInfo2::pname:format,
      pname:imageType, pname:tiling, pname:usage, and pname:flags must: be
      equal to those in slink:VkImageCreateInfo.
  *** If slink:VkImageCreateInfo::pname:pNext contains a
      slink:VkExternalMemoryImageCreateInfo structure whose
      pname:handleTypes is not `0`, then
      slink:VkPhysicalDeviceImageFormatInfo2::pname:pNext must: contain a
      slink:VkPhysicalDeviceExternalImageFormatInfo structure whose
      pname:handleType is not `0`; and
      flink:vkGetPhysicalDeviceImageFormatProperties2 must: be called for
      each handle type in
      slink:VkExternalMemoryImageCreateInfo::pname:handleTypes, successively
      setting
      slink:VkPhysicalDeviceExternalImageFormatInfo::pname:handleType on
      each call.
  *** If slink:VkImageCreateInfo::pname:pNext contains no
      slink:VkExternalMemoryImageCreateInfo structure, or contains a
      structure whose pname:handleTypes is `0`, then
      slink:VkPhysicalDeviceImageFormatInfo2::pname:pNext must: either
      contain no slink:VkPhysicalDeviceExternalImageFormatInfo structure, or
      contain a structure whose pname:handleType is `0`.
ifdef::VK_KHR_video_queue[]
  *** If slink:VkImageCreateInfo::pname:pNext contains a
      slink:VkVideoProfileListInfoKHR structure then
      slink:VkPhysicalDeviceImageFormatInfo2::pname:pNext must: also contain
      the same slink:VkVideoProfileListInfoKHR structure on each call.
endif::VK_KHR_video_queue[]
ifdef::VK_EXT_image_drm_format_modifier[]
  *** If pname:tiling is ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,
      then:
  **** slink:VkPhysicalDeviceImageFormatInfo2::pname:pNext must: contain a
       slink:VkPhysicalDeviceImageDrmFormatModifierInfoEXT structure where
       pname:sharingMode is equal to
       slink:VkImageCreateInfo::pname:sharingMode;
  **** if pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT, then
       pname:queueFamilyIndexCount and pname:pQueueFamilyIndices must: be
       equal to those in slink:VkImageCreateInfo;
  **** if pname:flags contains ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
       then the slink:VkImageFormatListCreateInfo structure included in the
       pname:pNext chain of slink:VkPhysicalDeviceImageFormatInfo2 must: be
       equivalent to the one included in the pname:pNext chain of
       slink:VkImageCreateInfo;
ifdef::VK_EXT_image_compression_control[]
  **** if slink:VkImageCreateInfo::pname:pNext contains a
       slink:VkImageCompressionControlEXT structure, then the
       slink:VkPhysicalDeviceImageFormatInfo2::pname:pNext chain must:
       contain an equivalent structure;
endif::VK_EXT_image_compression_control[]
  **** flink:vkGetPhysicalDeviceImageFormatProperties2 must: be called for
       each modifier in pname:imageCreateDrmFormatModifiers, successively
       setting
       slink:VkPhysicalDeviceImageDrmFormatModifierInfoEXT::pname:drmFormatModifier
       on each call.
  *** If pname:tiling is not ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,
      then slink:VkPhysicalDeviceImageFormatInfo2::pname:pNext must: contain
      no slink:VkPhysicalDeviceImageDrmFormatModifierInfoEXT structure.
endif::VK_EXT_image_drm_format_modifier[]
  *** If any call to flink:vkGetPhysicalDeviceImageFormatProperties2 returns
      an error, then pname:imageCreateImageFormatPropertiesList is defined
      to be the empty list.
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
  ** If slink:VkImageCreateInfo::pname:pNext contains a
     slink:VkExternalFormatANDROID structure with non-zero
     pname:externalFormat, then pname:imageCreateImageFormatPropertiesList
     contains a single element where:
  *** sname:VkImageFormatProperties::pname:maxMipLevels is
      [eq]#{lfloor}log~2~(max(pname:extent.width, pname:extent.height,
      pname:extent.depth)){rfloor} {plus} 1#.
  *** sname:VkImageFormatProperties::pname:maxArrayLayers is
      slink:VkPhysicalDeviceLimits::pname:maxImageArrayLayers.
  *** Each component of sname:VkImageFormatProperties::pname:maxExtent is
      slink:VkPhysicalDeviceLimits::pname:maxImageDimension2D.
  *** sname:VkImageFormatProperties::pname:sampleCounts contains exactly
      ename:VK_SAMPLE_COUNT_1_BIT.
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
endif::VK_VERSION_1_1,VK_KHR_external_memory[]

  * Let `uint32_t imageCreateMaxMipLevels` be
ifndef::VK_VERSION_1_1,VK_KHR_external_memory[]
    the value of slink:VkImageFormatProperties::pname:maxMipLevels found by
    calling flink:vkGetPhysicalDeviceImageFormatProperties with parameters
    pname:format, pname:imageType, pname:tiling, pname:usage, and
    pname:flags equal to those in slink:VkImageCreateInfo.
    If flink:vkGetPhysicalDeviceFormatProperties returns an error, then the
    value of pname:imageCreateMaxMipLevels is undefined:.
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
    the minimum value of slink:VkImageFormatProperties::pname:maxMipLevels
    in pname:imageCreateImageFormatPropertiesList.
    The value is undefined: if pname:imageCreateImageFormatPropertiesList is
    empty.
endif::VK_VERSION_1_1,VK_KHR_external_memory[]

  * Let `uint32_t imageCreateMaxArrayLayers` be
ifndef::VK_VERSION_1_1,VK_KHR_external_memory[]
    defined analogously to pname:imageCreateMaxMipLevels.
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
    the minimum value of slink:VkImageFormatProperties::pname:maxArrayLayers
    in pname:imageCreateImageFormatPropertiesList.
    The value is undefined: if pname:imageCreateImageFormatPropertiesList is
    empty.
endif::VK_VERSION_1_1,VK_KHR_external_memory[]

  * Let `VkExtent3D imageCreateMaxExtent` be
ifndef::VK_VERSION_1_1,VK_KHR_external_memory[]
    defined analogously to pname:imageCreateMaxMipLevels.
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
    the component-wise minimum over all
    slink:VkImageFormatProperties::pname:maxExtent values in
    pname:imageCreateImageFormatPropertiesList.
    The value is undefined: if pname:imageCreateImageFormatPropertiesList is
    empty.
endif::VK_VERSION_1_1,VK_KHR_external_memory[]

  * Let `VkSampleCountFlags imageCreateSampleCounts` be
ifndef::VK_VERSION_1_1,VK_KHR_external_memory[]
    defined analogously to pname:imageCreateMaxMipLevels.
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
    the intersection of each
    slink:VkImageFormatProperties::pname:sampleCounts in
    pname:imageCreateImageFormatPropertiesList.
    The value is undefined: if pname:imageCreateImageFormatPropertiesList is
    empty.
endif::VK_VERSION_1_1,VK_KHR_external_memory[]

ifdef::VK_KHR_video_queue[]
  * Let `VkVideoFormatPropertiesKHR videoFormatProperties[]` be defined as
    follows.
  ** If slink:VkImageCreateInfo::pname:pNext contains a
     slink:VkVideoProfileListInfoKHR structure, then `videoFormatProperties`
     is the list of structures obtained by calling
     flink:vkGetPhysicalDeviceVideoFormatPropertiesKHR with
     slink:VkPhysicalDeviceVideoFormatInfoKHR::pname:imageUsage equal to the
     pname:usage member of slink:VkImageCreateInfo and
     slink:VkPhysicalDeviceVideoFormatInfoKHR::pname:pNext containing the
     same slink:VkVideoProfileListInfoKHR structure chained to
     slink:VkImageCreateInfo.
  ** If slink:VkImageCreateInfo::pname:pNext contains no
     slink:VkVideoProfileListInfoKHR structure, then `videoFormatProperties`
     is an empty list.
  * Let `VkBool32 supportedVideoFormat` indicate if the image parameters are
    supported by the specified video profiles.
  ** `supportedVideoFormat` is ename:VK_TRUE if there exists an element in
     the `videoFormatProperties` list for which all of the following
     conditions are true:
  *** slink:VkImageCreateInfo::pname:format equals
      slink:VkVideoFormatPropertiesKHR::pname:format.
  *** slink:VkImageCreateInfo::pname:flags only contains bits also set in
      slink:VkVideoFormatPropertiesKHR::pname:imageCreateFlags.
  *** slink:VkImageCreateInfo::pname:imageType equals
      slink:VkVideoFormatPropertiesKHR::pname:imageType.
  *** slink:VkImageCreateInfo::pname:tiling equals
      slink:VkVideoFormatPropertiesKHR::pname:imageTiling.
  *** slink:VkImageCreateInfo::pname:usage only contains bits also set in
      slink:VkVideoFormatPropertiesKHR::pname:imageUsageFlags, or
      slink:VkImageCreateInfo::pname:flags includes
      ename:VK_IMAGE_CREATE_EXTENDED_USAGE_BIT.
  ** Otherwise `supportedVideoFormat` is ename:VK_FALSE.
endif::VK_KHR_video_queue[]
****

.Valid Usage
****
  * [[VUID-VkImageCreateInfo-imageCreateMaxMipLevels-02251]]
    Each of the following values (as described in
    <<resources-image-creation-limits,Image Creation Limits>>) must: not be
    undefined: : pname:imageCreateMaxMipLevels,
    pname:imageCreateMaxArrayLayers, pname:imageCreateMaxExtent, and
    pname:imageCreateSampleCounts
  * [[VUID-VkImageCreateInfo-sharingMode-00941]]
    If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT,
    pname:pQueueFamilyIndices must: be a valid pointer to an array of
    pname:queueFamilyIndexCount code:uint32_t values
  * [[VUID-VkImageCreateInfo-sharingMode-00942]]
    If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT,
    pname:queueFamilyIndexCount must: be greater than `1`
ifndef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
  * [[VUID-VkImageCreateInfo-sharingMode-01392]]
    If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT, each element
    of pname:pQueueFamilyIndices must: be unique and must: be less than
    pname:pQueueFamilyPropertyCount returned by
    flink:vkGetPhysicalDeviceQueueFamilyProperties for the
    pname:physicalDevice that was used to create pname:device
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
ifdef::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
  * [[VUID-VkImageCreateInfo-sharingMode-01420]]
    If pname:sharingMode is ename:VK_SHARING_MODE_CONCURRENT, each element
    of pname:pQueueFamilyIndices must: be unique and must: be less than
    pname:pQueueFamilyPropertyCount returned by either
    flink:vkGetPhysicalDeviceQueueFamilyProperties or
    flink:vkGetPhysicalDeviceQueueFamilyProperties2 for the
    pname:physicalDevice that was used to create pname:device
endif::VK_VERSION_1_1,VK_KHR_get_physical_device_properties2[]
ifndef::VK_ANDROID_external_memory_android_hardware_buffer[]
  * [[VUID-VkImageCreateInfo-format-00943]]
    pname:format must: not be ename:VK_FORMAT_UNDEFINED
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
  * [[VUID-VkImageCreateInfo-pNext-01974]]
    If the pname:pNext chain includes a slink:VkExternalFormatANDROID
    structure, and its pname:externalFormat member is non-zero the
    pname:format must: be ename:VK_FORMAT_UNDEFINED
  * [[VUID-VkImageCreateInfo-pNext-01975]]
    If the pname:pNext chain does not include a
    slink:VkExternalFormatANDROID structure, or does and its
    pname:externalFormat member is `0`, the pname:format must: not be
    ename:VK_FORMAT_UNDEFINED
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
  * [[VUID-VkImageCreateInfo-extent-00944]]
    pname:extent.width must: be greater than `0`
  * [[VUID-VkImageCreateInfo-extent-00945]]
    pname:extent.height must: be greater than `0`
  * [[VUID-VkImageCreateInfo-extent-00946]]
    pname:extent.depth must: be greater than `0`
  * [[VUID-VkImageCreateInfo-mipLevels-00947]]
    pname:mipLevels must: be greater than `0`
  * [[VUID-VkImageCreateInfo-arrayLayers-00948]]
    pname:arrayLayers must: be greater than `0`
  * [[VUID-VkImageCreateInfo-flags-00949]]
    If pname:flags contains ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
    pname:imageType must: be ename:VK_IMAGE_TYPE_2D
  * [[VUID-VkImageCreateInfo-flags-08865]]
    If pname:flags contains ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
    pname:extent.width and pname:extent.height must: be equal
  * [[VUID-VkImageCreateInfo-flags-08866]]
    If pname:flags contains ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
    pname:arrayLayers must: be greater than or equal to 6
ifdef::VK_EXT_fragment_density_map[]
  * [[VUID-VkImageCreateInfo-flags-02557]]
    If pname:flags contains
    ename:VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, pname:imageType must:
    be ename:VK_IMAGE_TYPE_2D
endif::VK_EXT_fragment_density_map[]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance1[]
  * [[VUID-VkImageCreateInfo-flags-00950]]
    If pname:flags contains ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    pname:imageType must: be ename:VK_IMAGE_TYPE_3D
  * [[VUID-VkImageCreateInfo-flags-09403]]
    If pname:flags contains ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    pname:flags must: not include ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT, or
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
endif::VK_VERSION_1_1,VK_KHR_maintenance1[]
ifdef::VK_EXT_image_2d_view_of_3d[]
  * [[VUID-VkImageCreateInfo-flags-07755]]
    If pname:flags contains
    ename:VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT, pname:imageType must:
    be ename:VK_IMAGE_TYPE_3D
endif::VK_EXT_image_2d_view_of_3d[]
  * [[VUID-VkImageCreateInfo-extent-02252]]
    pname:extent.width must: be less than or equal to
    pname:imageCreateMaxExtent.width (as defined in
    <<resources-image-creation-limits,Image Creation Limits>>)
  * [[VUID-VkImageCreateInfo-extent-02253]]
    pname:extent.height must: be less than or equal to
    pname:imageCreateMaxExtent.height (as defined in
    <<resources-image-creation-limits,Image Creation Limits>>)
  * [[VUID-VkImageCreateInfo-extent-02254]]
    pname:extent.depth must: be less than or equal to
    pname:imageCreateMaxExtent.depth (as defined in
    <<resources-image-creation-limits,Image Creation Limits>>)
  * [[VUID-VkImageCreateInfo-imageType-00956]]
    If pname:imageType is ename:VK_IMAGE_TYPE_1D, both pname:extent.height
    and pname:extent.depth must: be `1`
  * [[VUID-VkImageCreateInfo-imageType-00957]]
    If pname:imageType is ename:VK_IMAGE_TYPE_2D, pname:extent.depth must:
    be `1`
  * [[VUID-VkImageCreateInfo-mipLevels-00958]]
    pname:mipLevels must: be less than or equal to the number of levels in
    the complete mipmap chain based on [eq]#pname:extent.width#,
    [eq]#pname:extent.height#, and [eq]#pname:extent.depth#
  * [[VUID-VkImageCreateInfo-mipLevels-02255]]
    pname:mipLevels must: be less than or equal to
    pname:imageCreateMaxMipLevels (as defined in
    <<resources-image-creation-limits,Image Creation Limits>>)
  * [[VUID-VkImageCreateInfo-arrayLayers-02256]]
    pname:arrayLayers must: be less than or equal to
    pname:imageCreateMaxArrayLayers (as defined in
    <<resources-image-creation-limits,Image Creation Limits>>)
  * [[VUID-VkImageCreateInfo-imageType-00961]]
    If pname:imageType is ename:VK_IMAGE_TYPE_3D, pname:arrayLayers must: be
    `1`
  * [[VUID-VkImageCreateInfo-samples-02257]]
    If pname:samples is not ename:VK_SAMPLE_COUNT_1_BIT, then
    pname:imageType must: be ename:VK_IMAGE_TYPE_2D, pname:flags must: not
    contain ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, pname:mipLevels must:
    be equal to `1`, and pname:imageCreateMaybeLinear (as defined in
    <<resources-image-creation-limits,Image Creation Limits>>) must: be
    ename:VK_FALSE,
ifdef::VK_EXT_fragment_density_map[]
  * [[VUID-VkImageCreateInfo-samples-02558]]
    If pname:samples is not ename:VK_SAMPLE_COUNT_1_BIT, pname:usage must:
    not contain ename:VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT
endif::VK_EXT_fragment_density_map[]
  * [[VUID-VkImageCreateInfo-usage-00963]]
    If pname:usage includes ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    then bits other than ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT must: not be set
  * [[VUID-VkImageCreateInfo-usage-00964]]
    If pname:usage includes ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, pname:extent.width must: be
    less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxFramebufferWidth
  * [[VUID-VkImageCreateInfo-usage-00965]]
    If pname:usage includes ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, pname:extent.height must: be
    less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxFramebufferHeight
ifdef::VK_EXT_fragment_density_map[]
ifndef::VK_QCOM_fragment_density_map_offset[]
  * [[VUID-VkImageCreateInfo-usage-02559]]
    If pname:usage includes
    ename:VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, pname:extent.width
    must: be less than or equal to
    latexmath:[\left\lceil{\frac{maxFramebufferWidth}{minFragmentDensityTexelSize_{width}}}\right\rceil]
  * [[VUID-VkImageCreateInfo-usage-02560]]
    If pname:usage includes
    ename:VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, pname:extent.height
    must: be less than or equal to
    latexmath:[\left\lceil{\frac{maxFramebufferHeight}{minFragmentDensityTexelSize_{height}}}\right\rceil]
endif::VK_QCOM_fragment_density_map_offset[]
ifdef::VK_QCOM_fragment_density_map_offset[]
  * [[VUID-VkImageCreateInfo-fragmentDensityMapOffset-06514]]
    If the <<features-fragmentDensityMapOffset,
    pname:fragmentDensityMapOffset>> feature is not enabled and pname:usage
    includes ename:VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,
    pname:extent.width must: be less than or equal to
    latexmath:[\left\lceil{\frac{maxFramebufferWidth}{minFragmentDensityTexelSize_{width}}}\right\rceil]
  * [[VUID-VkImageCreateInfo-fragmentDensityMapOffset-06515]]
    If the <<features-fragmentDensityMapOffset,
    pname:fragmentDensityMapOffset>> feature is not enabled and pname:usage
    includes ename:VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,
    pname:extent.height must: be less than or equal to
    latexmath:[\left\lceil{\frac{maxFramebufferHeight}{minFragmentDensityTexelSize_{height}}}\right\rceil]
endif::VK_QCOM_fragment_density_map_offset[]
endif::VK_EXT_fragment_density_map[]
  * [[VUID-VkImageCreateInfo-usage-00966]]
    If pname:usage includes ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    pname:usage must: also contain at least one of
    ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, or
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
  * [[VUID-VkImageCreateInfo-samples-02258]]
    pname:samples must: be a valid elink:VkSampleCountFlagBits value that is
    set in pname:imageCreateSampleCounts (as defined in
    <<resources-image-creation-limits,Image Creation Limits>>)
  * [[VUID-VkImageCreateInfo-usage-00968]]
    If the <<features-shaderStorageImageMultisample,
    pname:shaderStorageImageMultisample>> feature is not enabled, and
    pname:usage contains ename:VK_IMAGE_USAGE_STORAGE_BIT, pname:samples
    must: be ename:VK_SAMPLE_COUNT_1_BIT
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkImageCreateInfo-flags-00969]]
    If the <<features-sparseBinding, pname:sparseBinding>> feature is not
    enabled, pname:flags must: not contain
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT
  * [[VUID-VkImageCreateInfo-flags-01924]]
    If the <<features-sparseResidencyAliased, pname:sparseResidencyAliased>>
    feature is not enabled, pname:flags must: not contain
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT
  * [[VUID-VkImageCreateInfo-tiling-04121]]
    If pname:tiling is ename:VK_IMAGE_TILING_LINEAR, pname:flags must: not
    contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * [[VUID-VkImageCreateInfo-imageType-00970]]
    If pname:imageType is ename:VK_IMAGE_TYPE_1D, pname:flags must: not
    contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * [[VUID-VkImageCreateInfo-imageType-00971]]
    If the <<features-sparseResidencyImage2D, pname:sparseResidencyImage2D>>
    feature is not enabled, and pname:imageType is ename:VK_IMAGE_TYPE_2D,
    pname:flags must: not contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * [[VUID-VkImageCreateInfo-imageType-00972]]
    If the <<features-sparseResidencyImage3D, pname:sparseResidencyImage3D>>
    feature is not enabled, and pname:imageType is ename:VK_IMAGE_TYPE_3D,
    pname:flags must: not contain ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * [[VUID-VkImageCreateInfo-imageType-00973]]
    If the <<features-sparseResidency2Samples,
    pname:sparseResidency2Samples>> feature is not enabled, pname:imageType
    is ename:VK_IMAGE_TYPE_2D, and pname:samples is
    ename:VK_SAMPLE_COUNT_2_BIT, pname:flags must: not contain
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * [[VUID-VkImageCreateInfo-imageType-00974]]
    If the <<features-sparseResidency4Samples,
    pname:sparseResidency4Samples>> feature is not enabled, pname:imageType
    is ename:VK_IMAGE_TYPE_2D, and pname:samples is
    ename:VK_SAMPLE_COUNT_4_BIT, pname:flags must: not contain
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * [[VUID-VkImageCreateInfo-imageType-00975]]
    If the <<features-sparseResidency8Samples,
    pname:sparseResidency8Samples>> feature is not enabled, pname:imageType
    is ename:VK_IMAGE_TYPE_2D, and pname:samples is
    ename:VK_SAMPLE_COUNT_8_BIT, pname:flags must: not contain
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * [[VUID-VkImageCreateInfo-imageType-00976]]
    If the <<features-sparseResidency16Samples,
    pname:sparseResidency16Samples>> feature is not enabled, pname:imageType
    is ename:VK_IMAGE_TYPE_2D, and pname:samples is
    ename:VK_SAMPLE_COUNT_16_BIT, pname:flags must: not contain
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
  * [[VUID-VkImageCreateInfo-flags-00987]]
    If pname:flags contains ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT or
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT, it must: also contain
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT
  * [[VUID-VkImageCreateInfo-None-01925]]
    If any of the bits ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set,
    ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT must: not also be set
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
  * [[VUID-VkImageCreateInfo-flags-05062]]
    pname:flags must: not contain ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT, or
    ename:VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
endif::VKSC_VERSION_1_0[]
ifdef::VK_VERSION_1_1[]
  * [[VUID-VkImageCreateInfo-flags-01890]]
    If the <<features-protectedMemory, pname:protectedMemory>> feature is
    not enabled, pname:flags must: not contain
    ename:VK_IMAGE_CREATE_PROTECTED_BIT
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkImageCreateInfo-None-01891]]
    If any of the bits ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set,
    ename:VK_IMAGE_CREATE_PROTECTED_BIT must: not also be set
endif::VKSC_VERSION_1_0[]
endif::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
ifdef::VK_NV_external_memory[]
  * [[VUID-VkImageCreateInfo-pNext-00988]]
    If the pname:pNext chain includes a
    slink:VkExternalMemoryImageCreateInfoNV structure, it must: not contain
    a slink:VkExternalMemoryImageCreateInfo structure
endif::VK_NV_external_memory[]
  * [[VUID-VkImageCreateInfo-pNext-00990]]
    If the pname:pNext chain includes a
    slink:VkExternalMemoryImageCreateInfo structure, its pname:handleTypes
    member must: only contain bits that are also in
    slink:VkExternalImageFormatProperties::pname:externalMemoryProperties.compatibleHandleTypes,
    as returned by flink:vkGetPhysicalDeviceImageFormatProperties2 with
    pname:format, pname:imageType, pname:tiling, pname:usage, and
    pname:flags equal to those in this structure, and with a
    slink:VkPhysicalDeviceExternalImageFormatInfo structure included in the
    pname:pNext chain, with a pname:handleType equal to any one of the
    handle types specified in
    slink:VkExternalMemoryImageCreateInfo::pname:handleTypes
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
ifdef::VK_NV_external_memory+VK_NV_external_memory_capabilities[]
  * [[VUID-VkImageCreateInfo-pNext-00991]]
    If the pname:pNext chain includes a
    slink:VkExternalMemoryImageCreateInfoNV structure, its pname:handleTypes
    member must: only contain bits that are also in
    slink:VkExternalImageFormatPropertiesNV::pname:externalMemoryProperties.compatibleHandleTypes,
    as returned by flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV
    with pname:format, pname:imageType, pname:tiling, pname:usage, and
    pname:flags equal to those in this structure, and with
    pname:externalHandleType equal to any one of the handle types specified
    in slink:VkExternalMemoryImageCreateInfoNV::pname:handleTypes
endif::VK_NV_external_memory+VK_NV_external_memory_capabilities[]
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkImageCreateInfo-physicalDeviceCount-01421]]
    If the logical device was created with
    slink:VkDeviceGroupDeviceCreateInfo::pname:physicalDeviceCount equal to
    1, pname:flags must: not contain
    ename:VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
  * [[VUID-VkImageCreateInfo-flags-02259]]
    If pname:flags contains
    ename:VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT, then
    pname:mipLevels must: be one, pname:arrayLayers must: be one,
    pname:imageType must: be ename:VK_IMAGE_TYPE_2D.
    and pname:imageCreateMaybeLinear (as defined in
    <<resources-image-creation-limits,Image Creation Limits>>) must: be
    ename:VK_FALSE
endif::VKSC_VERSION_1_0[]
endif::VK_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
  * [[VUID-VkImageCreateInfo-flags-01572]]
    If pname:flags contains
    ename:VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, then pname:format
    must: be a <<compressed_image_formats,compressed image format>>
  * [[VUID-VkImageCreateInfo-flags-01573]]
    If pname:flags contains
    ename:VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, then pname:flags
    must: also contain ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
  * [[VUID-VkImageCreateInfo-initialLayout-00993]]
    pname:initialLayout must: be ename:VK_IMAGE_LAYOUT_UNDEFINED or
    ename:VK_IMAGE_LAYOUT_PREINITIALIZED
ifdef::VK_VERSION_1_1,VK_KHR_external_memory,VK_NV_external_memory[]
  * [[VUID-VkImageCreateInfo-pNext-01443]]
    If the pname:pNext chain includes a
    slink:VkExternalMemoryImageCreateInfo or
    sname:VkExternalMemoryImageCreateInfoNV structure whose
    pname:handleTypes member is not `0`, pname:initialLayout must: be
    ename:VK_IMAGE_LAYOUT_UNDEFINED
endif::VK_VERSION_1_1,VK_KHR_external_memory,VK_NV_external_memory[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkImageCreateInfo-format-06410]]
    If the image pname:format is one of the
    <<formats-requiring-sampler-ycbcr-conversion, formats that require a
    sampler {YCbCr} conversion>>, pname:mipLevels must: be 1
  * [[VUID-VkImageCreateInfo-format-06411]]
    If the image pname:format is one of the
    <<formats-requiring-sampler-ycbcr-conversion, formats that require a
    sampler {YCbCr} conversion>>, pname:samples must: be
    ename:VK_SAMPLE_COUNT_1_BIT
  * [[VUID-VkImageCreateInfo-format-06412]]
    If the image pname:format is one of the
    <<formats-requiring-sampler-ycbcr-conversion, formats that require a
    sampler {YCbCr} conversion>>, pname:imageType must: be
    ename:VK_IMAGE_TYPE_2D
  * [[VUID-VkImageCreateInfo-imageCreateFormatFeatures-02260]]
    If pname:format is a _multi-planar_ format, and if
    pname:imageCreateFormatFeatures (as defined in
    <<resources-image-creation-limits,Image Creation Limits>>) does not
    contain ename:VK_FORMAT_FEATURE_DISJOINT_BIT, then pname:flags must: not
    contain ename:VK_IMAGE_CREATE_DISJOINT_BIT
  * [[VUID-VkImageCreateInfo-format-01577]]
    If pname:format is not a _multi-planar_ format, and pname:flags does not
    include ename:VK_IMAGE_CREATE_ALIAS_BIT, pname:flags must: not contain
    ename:VK_IMAGE_CREATE_DISJOINT_BIT
  * [[VUID-VkImageCreateInfo-format-04712]]
    If pname:format has a code:_422 or code:_420 suffix, pname:extent.width
    must: be a multiple of 2
  * [[VUID-VkImageCreateInfo-format-04713]]
    If pname:format has a code:_420 suffix, pname:extent.height must: be a
    multiple of 2
ifdef::VK_IMG_format_pvrtc[]
  * [[VUID-VkImageCreateInfo-format-09583]]
    If pname:format is one of the etext:VK_FORMAT_PVTRC1_*_IMG formats,
    pname:extent.width must: be a power of 2
  * [[VUID-VkImageCreateInfo-format-09584]]
    If pname:format is one of the etext:VK_FORMAT_PVTRC1_*_IMG formats,
    pname:extent.height must: be a power of 2
endif::VK_IMG_format_pvrtc[]
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-VkImageCreateInfo-tiling-02261]]
    If pname:tiling is ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then
    the pname:pNext chain must: include exactly one of
    slink:VkImageDrmFormatModifierListCreateInfoEXT or
    slink:VkImageDrmFormatModifierExplicitCreateInfoEXT structures
  * [[VUID-VkImageCreateInfo-pNext-02262]]
    If the pname:pNext chain includes a
    slink:VkImageDrmFormatModifierListCreateInfoEXT or
    slink:VkImageDrmFormatModifierExplicitCreateInfoEXT structure, then
    pname:tiling must: be ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT
  * [[VUID-VkImageCreateInfo-tiling-02353]]
    If pname:tiling is ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT and
    pname:flags contains ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, then the
    pname:pNext chain must: include a slink:VkImageFormatListCreateInfo
    structure with non-zero pname:viewFormatCount
endif::VK_EXT_image_drm_format_modifier[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-VkImageCreateInfo-flags-01533]]
    If pname:flags contains
    ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT
    pname:format must: be a depth or depth/stencil format
endif::VK_EXT_sample_locations[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
  * [[VUID-VkImageCreateInfo-pNext-02393]]
    If the pname:pNext chain includes a
    slink:VkExternalMemoryImageCreateInfo structure whose pname:handleTypes
    member includes
    ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,
    pname:imageType must: be ename:VK_IMAGE_TYPE_2D
  * [[VUID-VkImageCreateInfo-pNext-02394]]
    If the pname:pNext chain includes a
    slink:VkExternalMemoryImageCreateInfo structure whose pname:handleTypes
    member includes
    ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,
    pname:mipLevels must: either be `1` or equal to the number of levels in
    the complete mipmap chain based on [eq]#pname:extent.width#,
    [eq]#pname:extent.height#, and [eq]#pname:extent.depth#
  * [[VUID-VkImageCreateInfo-pNext-02396]]
    If the pname:pNext chain includes a slink:VkExternalFormatANDROID
    structure whose pname:externalFormat member is not `0`, pname:flags
    must: not include ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT
  * [[VUID-VkImageCreateInfo-pNext-02397]]
    If the pname:pNext chain includes a slink:VkExternalFormatANDROID
    structure whose pname:externalFormat member is not `0`, pname:usage
    must: not include any usages except
ifdef::VK_ANDROID_external_format_resolve[]
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
    ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, or
endif::VK_ANDROID_external_format_resolve[]
    ename:VK_IMAGE_USAGE_SAMPLED_BIT
ifdef::VK_ANDROID_external_format_resolve[]
  * [[VUID-VkImageCreateInfo-pNext-09457]]
    If the pname:pNext chain includes a slink:VkExternalFormatANDROID
    structure whose pname:externalFormat member is not `0`, and
    <<features-externalFormatResolve, pname:externalFormatResolve>> feature
    is not enabled, pname:usage must: not include
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT or
    ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
endif::VK_ANDROID_external_format_resolve[]
  * [[VUID-VkImageCreateInfo-pNext-02398]]
    If the pname:pNext chain includes a slink:VkExternalFormatANDROID
    structure whose pname:externalFormat member is not `0`, pname:tiling
    must: be ename:VK_IMAGE_TILING_OPTIMAL
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
  * [[VUID-VkImageCreateInfo-pNext-08951]]
    If the pname:pNext chain includes a
    slink:VkExternalMemoryImageCreateInfo structure whose pname:handleTypes
    member includes
    ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX,
    pname:imageType must: be ename:VK_IMAGE_TYPE_2D
  * [[VUID-VkImageCreateInfo-pNext-08952]]
    If the pname:pNext chain includes a
    slink:VkExternalMemoryImageCreateInfo structure whose pname:handleTypes
    member includes
    ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX,
    pname:mipLevels must: either be `1` or equal to the number of levels in
    the complete mipmap chain based on [eq]#pname:extent.width#,
    [eq]#pname:extent.height#, and [eq]#pname:extent.depth#
  * [[VUID-VkImageCreateInfo-pNext-08953]]
    If the pname:pNext chain includes a slink:VkExternalFormatQNX structure
    whose pname:externalFormat member is not `0`, pname:flags must: not
    include ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT
  * [[VUID-VkImageCreateInfo-pNext-08954]]
    If the pname:pNext chain includes a slink:VkExternalFormatQNX structure
    whose pname:externalFormat member is not `0`, pname:usage must: not
    include any usages except ename:VK_IMAGE_USAGE_SAMPLED_BIT
  * [[VUID-VkImageCreateInfo-pNext-08955]]
    If the pname:pNext chain includes a slink:VkExternalFormatQNX structure
    whose pname:externalFormat member is not `0`, pname:tiling must: be
    ename:VK_IMAGE_TILING_OPTIMAL
endif::VK_QNX_external_memory_screen_buffer[]
ifdef::VK_VERSION_1_2,VK_EXT_separate_stencil_usage[]
  * [[VUID-VkImageCreateInfo-format-02795]]
    If pname:format is a depth-stencil format, pname:usage includes
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and the pname:pNext
    chain includes a slink:VkImageStencilUsageCreateInfo structure, then its
    slink:VkImageStencilUsageCreateInfo::pname:stencilUsage member must:
    also include ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
  * [[VUID-VkImageCreateInfo-format-02796]]
    If pname:format is a depth-stencil format, pname:usage does not include
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and the pname:pNext
    chain includes a slink:VkImageStencilUsageCreateInfo structure, then its
    slink:VkImageStencilUsageCreateInfo::pname:stencilUsage member must:
    also not include ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
  * [[VUID-VkImageCreateInfo-format-02797]]
    If pname:format is a depth-stencil format, pname:usage includes
    ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, and the pname:pNext chain
    includes a slink:VkImageStencilUsageCreateInfo structure, then its
    slink:VkImageStencilUsageCreateInfo::pname:stencilUsage member must:
    also include ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT
  * [[VUID-VkImageCreateInfo-format-02798]]
    If pname:format is a depth-stencil format, pname:usage does not include
    ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, and the pname:pNext chain
    includes a slink:VkImageStencilUsageCreateInfo structure, then its
    slink:VkImageStencilUsageCreateInfo::pname:stencilUsage member must:
    also not include ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT
  * [[VUID-VkImageCreateInfo-Format-02536]]
    If pname:Format is a depth-stencil format and the pname:pNext chain
    includes a slink:VkImageStencilUsageCreateInfo structure with its
    pname:stencilUsage member including
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, pname:extent.width must: be
    less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxFramebufferWidth
  * [[VUID-VkImageCreateInfo-format-02537]]
    If pname:format is a depth-stencil format and the pname:pNext chain
    includes a slink:VkImageStencilUsageCreateInfo structure with its
    pname:stencilUsage member including
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, pname:extent.height must: be
    less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxFramebufferHeight
  * [[VUID-VkImageCreateInfo-format-02538]]
    If the <<features-shaderStorageImageMultisample,
    pname:shaderStorageImageMultisample>> feature is not enabled,
    pname:format is a depth-stencil format and the pname:pNext chain
    includes a slink:VkImageStencilUsageCreateInfo structure with its
    pname:stencilUsage including ename:VK_IMAGE_USAGE_STORAGE_BIT,
    pname:samples must: be ename:VK_SAMPLE_COUNT_1_BIT
endif::VK_VERSION_1_2,VK_EXT_separate_stencil_usage[]
ifdef::VK_NV_corner_sampled_image[]
  * [[VUID-VkImageCreateInfo-flags-02050]]
    If pname:flags contains ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV,
    pname:imageType must: be ename:VK_IMAGE_TYPE_2D or
    ename:VK_IMAGE_TYPE_3D
  * [[VUID-VkImageCreateInfo-flags-02051]]
    If pname:flags contains ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, it
    must: not contain ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT and the
    pname:format must: not be a depth/stencil format
  * [[VUID-VkImageCreateInfo-flags-02052]]
    If pname:flags contains ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and
    pname:imageType is ename:VK_IMAGE_TYPE_2D, pname:extent.width and
    pname:extent.height must: be greater than `1`
  * [[VUID-VkImageCreateInfo-flags-02053]]
    If pname:flags contains ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and
    pname:imageType is ename:VK_IMAGE_TYPE_3D, pname:extent.width,
    pname:extent.height, and pname:extent.depth must: be greater than `1`
endif::VK_NV_corner_sampled_image[]
ifdef::VK_KHR_fragment_shading_rate,VK_NV_shading_rate_image[]
  * [[VUID-VkImageCreateInfo-imageType-02082]]
    If pname:usage includes
    ename:VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
    pname:imageType must: be ename:VK_IMAGE_TYPE_2D
  * [[VUID-VkImageCreateInfo-samples-02083]]
    If pname:usage includes
    ename:VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
    pname:samples must: be ename:VK_SAMPLE_COUNT_1_BIT
endif::VK_KHR_fragment_shading_rate,VK_NV_shading_rate_image[]
ifdef::VK_NV_shading_rate_image[]
  * [[VUID-VkImageCreateInfo-shadingRateImage-07727]]
    If the <<features-shadingRateImage, pname:shadingRateImage>> feature is
    enabled and pname:usage includes
    ename:VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, pname:tiling must: be
    ename:VK_IMAGE_TILING_OPTIMAL
endif::VK_NV_shading_rate_image[]
ifdef::VK_EXT_fragment_density_map[]
  * [[VUID-VkImageCreateInfo-flags-02565]]
    If pname:flags contains ename:VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT,
    pname:tiling must: be ename:VK_IMAGE_TILING_OPTIMAL
  * [[VUID-VkImageCreateInfo-flags-02566]]
    If pname:flags contains ename:VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT,
    pname:imageType must: be ename:VK_IMAGE_TYPE_2D
  * [[VUID-VkImageCreateInfo-flags-02567]]
    If pname:flags contains ename:VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT,
    pname:flags must: not contain ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT
  * [[VUID-VkImageCreateInfo-flags-02568]]
    If pname:flags contains ename:VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT,
    pname:mipLevels must: be `1`
endif::VK_EXT_fragment_density_map[]
ifdef::VK_HUAWEI_invocation_mask[]
  * [[VUID-VkImageCreateInfo-usage-04992]]
    If pname:usage includes ename:VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI,
    pname:tiling must: be ename:VK_IMAGE_TILING_LINEAR
endif::VK_HUAWEI_invocation_mask[]
ifdef::VK_KHR_portability_subset[]
  * [[VUID-VkImageCreateInfo-imageView2DOn3DImage-04459]]
    If the `apiext:VK_KHR_portability_subset` extension is enabled, and
    slink:VkPhysicalDevicePortabilitySubsetFeaturesKHR::pname:imageView2DOn3DImage
    is ename:VK_FALSE, pname:flags must: not contain
    ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT
  * [[VUID-VkImageCreateInfo-multisampleArrayImage-04460]]
    If the `apiext:VK_KHR_portability_subset` extension is enabled, and
    slink:VkPhysicalDevicePortabilitySubsetFeaturesKHR::pname:multisampleArrayImage
    is ename:VK_FALSE, and pname:samples is not ename:VK_SAMPLE_COUNT_1_BIT,
    then pname:arrayLayers must: be `1`
endif::VK_KHR_portability_subset[]
ifdef::VK_VERSION_1_2,VK_KHR_image_format_list[]
  * [[VUID-VkImageCreateInfo-pNext-06722]]
    If a slink:VkImageFormatListCreateInfo structure was included in the
    pname:pNext chain and pname:format is not a
    <<formats-requiring-sampler-ycbcr-conversion,multi-planar>> format and
    slink:VkImageFormatListCreateInfo::pname:viewFormatCount is not zero,
    then each format in
    slink:VkImageFormatListCreateInfo::pname:pViewFormats must: either be
    compatible with the pname:format as described in the
    <<formats-compatibility,compatibility table>> or, if pname:flags
    contains ename:VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, be an
    uncompressed format that is size-compatible with pname:format
  * [[VUID-VkImageCreateInfo-pNext-10062]]
    If a slink:VkImageFormatListCreateInfo structure was included in the
    pname:pNext chain and pname:format is a
    <<formats-requiring-sampler-ycbcr-conversion,multi-planar>> format and
    pname:flags contains ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT and
    slink:VkImageFormatListCreateInfo::pname:viewFormatCount is not zero,
    then each format in
    slink:VkImageFormatListCreateInfo::pname:pViewFormats must: be
    compatible with the ename:VkFormat for the plane of the image format
  * [[VUID-VkImageCreateInfo-flags-04738]]
    If pname:flags does not contain ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT
    and the pname:pNext chain includes a slink:VkImageFormatListCreateInfo
    structure, then slink:VkImageFormatListCreateInfo::pname:viewFormatCount
    must: be `0` or `1`
endif::VK_VERSION_1_2,VK_KHR_image_format_list[]
ifdef::VK_KHR_video_decode_queue[]
  * [[VUID-VkImageCreateInfo-usage-04815]]
    If pname:usage includes ename:VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR,
    ename:VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR, or
    ename:VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR,
ifdef::VK_KHR_video_maintenance1[]
    and pname:flags does not include
    ename:VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR,
endif::VK_KHR_video_maintenance1[]
    then the pname:pNext chain must: include a
    slink:VkVideoProfileListInfoKHR structure with pname:profileCount
    greater than `0` and pname:pProfiles including at least one
    slink:VkVideoProfileInfoKHR structure with a pname:videoCodecOperation
    member specifying a decode operation
endif::VK_KHR_video_decode_queue[]
ifdef::VK_KHR_video_encode_queue[]
  * [[VUID-VkImageCreateInfo-usage-04816]]
    If pname:usage includes ename:VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR,
    ename:VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR, or
    ename:VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR,
ifdef::VK_KHR_video_maintenance1[]
    and pname:flags does not include
    ename:VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR,
endif::VK_KHR_video_maintenance1[]
    then the pname:pNext chain must: include a
    slink:VkVideoProfileListInfoKHR structure with pname:profileCount
    greater than `0` and pname:pProfiles including at least one
    slink:VkVideoProfileInfoKHR structure with a pname:videoCodecOperation
    member specifying an encode operation
endif::VK_KHR_video_encode_queue[]
ifdef::VK_KHR_video_maintenance1[]
  * [[VUID-VkImageCreateInfo-flags-08328]]
    If pname:flags includes
    ename:VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR, then
    <<features-videoMaintenance1,pname:videoMaintenance1>> must: be enabled
ifdef::VK_KHR_video_decode_queue[]
  * [[VUID-VkImageCreateInfo-flags-08329]]
    If pname:flags includes
    ename:VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR and pname:usage
    does not include ename:VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR, then
    pname:usage must: not include
    ename:VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR
endif::VK_KHR_video_decode_queue[]
ifdef::VK_KHR_video_encode_queue[]
  * [[VUID-VkImageCreateInfo-flags-08331]]
    If pname:flags includes
    ename:VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR, then
    pname:usage must: not include
    ename:VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR
endif::VK_KHR_video_encode_queue[]
endif::VK_KHR_video_maintenance1[]
ifdef::VK_KHR_video_queue[]
  * [[VUID-VkImageCreateInfo-pNext-06811]]
    If the pname:pNext chain includes a slink:VkVideoProfileListInfoKHR
    structure with pname:profileCount greater than `0`, then
    pname:supportedVideoFormat must: be ename:VK_TRUE
endif::VK_KHR_video_queue[]
ifdef::VK_FUCHSIA_buffer_collection[]
  * [[VUID-VkImageCreateInfo-pNext-06390]]
    If the slink:VkImage is to be used to import memory from a
    slink:VkBufferCollectionFUCHSIA, a
    slink:VkBufferCollectionImageCreateInfoFUCHSIA structure must: be
    chained to pname:pNext
endif::VK_FUCHSIA_buffer_collection[]
ifdef::VK_EXT_multisampled_render_to_single_sampled[]
  * [[VUID-VkImageCreateInfo-multisampledRenderToSingleSampled-06882]]
    If the <<features-multisampledRenderToSingleSampled,
    pname:multisampledRenderToSingleSampled>> feature is not enabled,
    pname:flags must: not contain
    ename:VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT
  * [[VUID-VkImageCreateInfo-flags-06883]]
    If pname:flags contains
    ename:VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT,
    pname:samples must: be ename:VK_SAMPLE_COUNT_1_BIT
endif::VK_EXT_multisampled_render_to_single_sampled[]
ifdef::VK_EXT_image_compression_control[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkImageCreateInfo-pNext-06743]]
    If the pname:pNext chain includes a slink:VkImageCompressionControlEXT
    structure, pname:format is a
    <<formats-requiring-sampler-ycbcr-conversion,multi-planar>> format, and
    slink:VkImageCompressionControlEXT::pname:flags includes
    ename:VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, then
    slink:VkImageCompressionControlEXT::pname:compressionControlPlaneCount
    must: be equal to the number of planes in pname:format
  * [[VUID-VkImageCreateInfo-pNext-06744]]
    If the pname:pNext chain includes a slink:VkImageCompressionControlEXT
    structure, pname:format is not a
    <<formats-requiring-sampler-ycbcr-conversion,multi-planar>> format, and
    slink:VkImageCompressionControlEXT::pname:flags includes
    ename:VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, then
    slink:VkImageCompressionControlEXT::pname:compressionControlPlaneCount
    must: be 1
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifndef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkImageCreateInfo-pNext-06745]]
    If the pname:pNext chain includes a slink:VkImageCompressionControlEXT
    structure, and slink:VkImageCompressionControlEXT::pname:flags includes
    ename:VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, then
    slink:VkImageCompressionControlEXT::pname:compressionControlPlaneCount
    must: be 1
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-VkImageCreateInfo-pNext-06746]]
    If the pname:pNext chain includes a slink:VkImageCompressionControlEXT
    structure, it must: not contain a
    slink:VkImageDrmFormatModifierExplicitCreateInfoEXT structure
endif::VK_EXT_image_drm_format_modifier[]
endif::VK_EXT_image_compression_control[]
ifdef::VK_EXT_descriptor_buffer[]
  * [[VUID-VkImageCreateInfo-flags-08104]]
    If pname:flags includes
    ename:VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, the
    <<features-descriptorBufferCaptureReplay,
    pname:descriptorBufferCaptureReplay>> feature must: be enabled
  * [[VUID-VkImageCreateInfo-pNext-08105]]
    If the pname:pNext chain includes a
    slink:VkOpaqueCaptureDescriptorDataCreateInfoEXT structure, pname:flags
    must: contain
    ename:VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
endif::VK_EXT_descriptor_buffer[]
ifdef::VK_EXT_metal_objects[]
  * [[VUID-VkImageCreateInfo-pNext-06783]]
    If the pname:pNext chain includes a
    slink:VkExportMetalObjectCreateInfoEXT structure, its
    pname:exportObjectType member must: be either
    ename:VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT or
    ename:VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT
  * [[VUID-VkImageCreateInfo-pNext-06784]]
    If the pname:pNext chain includes a slink:VkImportMetalTextureInfoEXT
    structure its pname:plane member must: be
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT, ename:VK_IMAGE_ASPECT_PLANE_1_BIT, or
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT
  * [[VUID-VkImageCreateInfo-pNext-06785]]
    If the pname:pNext chain includes a slink:VkImportMetalTextureInfoEXT
    structure and the image does not have a multi-planar format, then
    slink:VkImportMetalTextureInfoEXT::pname:plane must: be
    ename:VK_IMAGE_ASPECT_PLANE_0_BIT
  * [[VUID-VkImageCreateInfo-pNext-06786]]
    If the pname:pNext chain includes a slink:VkImportMetalTextureInfoEXT
    structure and the image has a multi-planar format with only two planes,
    then slink:VkImportMetalTextureInfoEXT::pname:plane must: not be
    ename:VK_IMAGE_ASPECT_PLANE_2_BIT
endif::VK_EXT_metal_objects[]
ifdef::VK_EXT_host_image_copy[]
  * [[VUID-VkImageCreateInfo-imageCreateFormatFeatures-09048]]
    If pname:imageCreateFormatFeatures (as defined in
    <<resources-image-creation-limits,Image Creation Limits>>) does not
    contain ename:VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT, then
    pname:usage must: not contain ename:VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT
endif::VK_EXT_host_image_copy[]
ifdef::VK_MESA_image_alignment_control[]
  * [[VUID-VkImageCreateInfo-pNext-09653]]
    If the pname:pNext chain contains a
    slink:VkImageAlignmentControlCreateInfoMESA structure, pname:tiling
    must: be ename:VK_IMAGE_TILING_OPTIMAL
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
  * [[VUID-VkImageCreateInfo-pNext-09654]]
    If the pname:pNext chain contains a
    slink:VkImageAlignmentControlCreateInfoMESA structure, it must: not
    contain a slink:VkExternalMemoryImageCreateInfo structure
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
endif::VK_MESA_image_alignment_control[]
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkImageCreateInfo::pname:flags must: not contain any of the
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT, or
    ename:VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT flags <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/structs/VkImageCreateInfo.adoc[]
--

ifdef::VK_FUCHSIA_buffer_collection[]
[open,refpage='VkBufferCollectionImageCreateInfoFUCHSIA',desc='Create a VkBufferCollectionFUCHSIA-compatible VkImage',type='structs']
--
The sname:VkBufferCollectionImageCreateInfoFUCHSIA structure is defined as:

include::{generated}/api/structs/VkBufferCollectionImageCreateInfoFUCHSIA.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure
  * pname:collection is the slink:VkBufferCollectionFUCHSIA handle
  * pname:index is the index of the buffer in the buffer collection from
    which the memory will be imported

.Valid Usage
****
  * [[VUID-VkBufferCollectionImageCreateInfoFUCHSIA-index-06391]]
    pname:index must: be less than
    slink:VkBufferCollectionPropertiesFUCHSIA::pname:bufferCount
****

include::{generated}/validity/structs/VkBufferCollectionImageCreateInfoFUCHSIA.adoc[]
--
endif::VK_FUCHSIA_buffer_collection[]

ifdef::VK_VERSION_1_2,VK_EXT_separate_stencil_usage[]
[open,refpage='VkImageStencilUsageCreateInfo',desc='Specify separate usage flags for the stencil aspect of a depth-stencil image',type='structs',alias='VkImageStencilUsageCreateInfoEXT']
--
The sname:VkImageStencilUsageCreateInfo structure is defined as:

include::{generated}/api/structs/VkImageStencilUsageCreateInfo.adoc[]

ifdef::VK_EXT_separate_stencil_usage[]
or the equivalent

include::{generated}/api/structs/VkImageStencilUsageCreateInfoEXT.adoc[]
endif::VK_EXT_separate_stencil_usage[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:stencilUsage is a bitmask of elink:VkImageUsageFlagBits describing
    the intended usage of the stencil aspect of the image.

If the pname:pNext chain of slink:VkImageCreateInfo includes a
sname:VkImageStencilUsageCreateInfo structure, then that structure includes
the usage flags specific to the stencil aspect of the image for an image
with a depth-stencil format.

This structure specifies image usages which only apply to the stencil aspect
of a depth/stencil format image.
When this structure is included in the pname:pNext chain of
slink:VkImageCreateInfo, the stencil aspect of the image must: only be used
as specified by pname:stencilUsage.
When this structure is not included in the pname:pNext chain of
slink:VkImageCreateInfo, the stencil aspect of an image must: only be used
as specified by slink:VkImageCreateInfo::pname:usage.
Use of other aspects of an image are unaffected by this structure.

This structure can: also be included in the pname:pNext chain of
slink:VkPhysicalDeviceImageFormatInfo2 to query additional capabilities
specific to image creation parameter combinations including a separate set
of usage flags for the stencil aspect of the image using
flink:vkGetPhysicalDeviceImageFormatProperties2.
When this structure is not included in the pname:pNext chain of
sname:VkPhysicalDeviceImageFormatInfo2 then the implicit value of
pname:stencilUsage matches that of
sname:VkPhysicalDeviceImageFormatInfo2::pname:usage.

.Valid Usage
****
  * [[VUID-VkImageStencilUsageCreateInfo-stencilUsage-02539]]
    If pname:stencilUsage includes
    ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, it must: not include bits
    other than ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT or
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
****

include::{generated}/validity/structs/VkImageStencilUsageCreateInfo.adoc[]
--
endif::VK_VERSION_1_2,VK_EXT_separate_stencil_usage[]

ifdef::VK_NV_dedicated_allocation[]
[open,refpage='VkDedicatedAllocationImageCreateInfoNV',desc='Specify that an image is bound to a dedicated memory resource',type='structs']
--
If the pname:pNext chain includes a
sname:VkDedicatedAllocationImageCreateInfoNV structure, then that structure
includes an enable controlling whether the image will have a dedicated
memory allocation bound to it.

The sname:VkDedicatedAllocationImageCreateInfoNV structure is defined as:

include::{generated}/api/structs/VkDedicatedAllocationImageCreateInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:dedicatedAllocation specifies whether the image will have a
    dedicated allocation bound to it.

[NOTE]
====
Using a dedicated allocation for color and depth/stencil attachments or
other large images may: improve performance on some devices.
====

.Valid Usage
****
  * [[VUID-VkDedicatedAllocationImageCreateInfoNV-dedicatedAllocation-00994]]
    If pname:dedicatedAllocation is ename:VK_TRUE,
    slink:VkImageCreateInfo::pname:flags must: not include
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT
****

include::{generated}/validity/structs/VkDedicatedAllocationImageCreateInfoNV.adoc[]
--
endif::VK_NV_dedicated_allocation[]

ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
[open,refpage='VkExternalMemoryImageCreateInfo',desc='Specify that an image may be backed by external memory',type='structs']
--
To define a set of external memory handle types that may: be used as backing
store for an image, add a slink:VkExternalMemoryImageCreateInfo structure to
the pname:pNext chain of the slink:VkImageCreateInfo structure.
The sname:VkExternalMemoryImageCreateInfo structure is defined as:

include::{generated}/api/structs/VkExternalMemoryImageCreateInfo.adoc[]

ifdef::VK_KHR_external_memory[]
or the equivalent

include::{generated}/api/structs/VkExternalMemoryImageCreateInfoKHR.adoc[]
endif::VK_KHR_external_memory[]

[NOTE]
====
A sname:VkExternalMemoryImageCreateInfo structure with a non-zero
pname:handleTypes field must be included in the creation parameters for an
image that will be bound to memory that is either exported or imported.
====

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:handleTypes is zero or a bitmask of
    elink:VkExternalMemoryHandleTypeFlagBits specifying one or more external
    memory handle types.

include::{generated}/validity/structs/VkExternalMemoryImageCreateInfo.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_external_memory[]

ifdef::VK_NV_external_memory[]
[open,refpage='VkExternalMemoryImageCreateInfoNV',desc='Specify that an image may be backed by external memory',type='structs']
--
If the pname:pNext chain includes a sname:VkExternalMemoryImageCreateInfoNV
structure, then that structure defines a set of external memory handle types
that may: be used as backing store for the image.

The sname:VkExternalMemoryImageCreateInfoNV structure is defined as:

include::{generated}/api/structs/VkExternalMemoryImageCreateInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:handleTypes is zero or a bitmask of
    elink:VkExternalMemoryHandleTypeFlagBitsNV specifying one or more
    external memory handle types.

include::{generated}/validity/structs/VkExternalMemoryImageCreateInfoNV.adoc[]
--
endif::VK_NV_external_memory[]

ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
[open,refpage='VkExternalFormatANDROID',desc='Structure containing an Android hardware buffer external format',type='structs']
--
sname:VkExternalFormatANDROID is defined as:

include::{generated}/api/structs/VkExternalFormatANDROID.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:externalFormat is an implementation-defined identifier for the
    external format

When included in the pname:pNext chain of another structure, it indicates
<<memory-external-android-hardware-buffer-external-formats, additional
format information>> beyond what is provided by ename:VkFormat values for an
Android hardware buffer.
If pname:externalFormat is zero, it indicates that no external format is
used, and implementations should rely only on other format information.
If this structure is not present, it is equivalent to setting
pname:externalFormat to zero.

.Valid Usage
****
  * [[VUID-VkExternalFormatANDROID-externalFormat-01894]]
    pname:externalFormat must: be `0` or a value returned in the
    pname:externalFormat member of
    slink:VkAndroidHardwareBufferFormatPropertiesANDROID by an earlier call
    to flink:vkGetAndroidHardwareBufferPropertiesANDROID
****

include::{generated}/validity/structs/VkExternalFormatANDROID.adoc[]
--
endif::VK_ANDROID_external_memory_android_hardware_buffer[]

ifdef::VK_QNX_external_memory_screen_buffer[]
[open,refpage='VkExternalFormatQNX',desc='Structure containing a QNX Screen buffer external format',type='structs']
--
To create an image with an
<<memory-external-screen-buffer-external-formats,QNX Screen external
format>>, add a sname:VkExternalFormatQNX structure in the pname:pNext chain
of slink:VkImageCreateInfo.
sname:VkExternalFormatQNX is defined as:

include::{generated}/api/structs/VkExternalFormatQNX.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:externalFormat is an implementation-defined identifier for the
    external format

If pname:externalFormat is zero, the effect is as if the
sname:VkExternalFormatQNX structure was not present.
Otherwise, the pname:image will have the specified external format.

.Valid Usage
****
  * [[VUID-VkExternalFormatQNX-externalFormat-08956]]
    pname:externalFormat must: be `0` or a value returned in the
    pname:externalFormat member of slink:VkScreenBufferFormatPropertiesQNX
    by an earlier call to flink:vkGetScreenBufferPropertiesQNX
****

include::{generated}/validity/structs/VkExternalFormatQNX.adoc[]
--
endif::VK_QNX_external_memory_screen_buffer[]

ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_KHR_swapchain[]
[open,refpage='VkImageSwapchainCreateInfoKHR',desc='Specify that an image will be bound to swapchain memory',type='structs']
--
If the pname:pNext chain of slink:VkImageCreateInfo includes a
sname:VkImageSwapchainCreateInfoKHR structure, then that structure includes
a swapchain handle indicating that the image will be bound to memory from
that swapchain.

The sname:VkImageSwapchainCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkImageSwapchainCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:swapchain is dlink:VK_NULL_HANDLE or a handle of a swapchain that
    the image will be bound to.

.Valid Usage
****
  * [[VUID-VkImageSwapchainCreateInfoKHR-swapchain-00995]]
    If pname:swapchain is not dlink:VK_NULL_HANDLE, the fields of
    slink:VkImageCreateInfo must: match the
    <<swapchain-wsi-image-create-info, implied image creation parameters>>
    of the swapchain
****

include::{generated}/validity/structs/VkImageSwapchainCreateInfoKHR.adoc[]
--
endif::VK_KHR_swapchain[]
endif::VK_VERSION_1_1,VK_KHR_device_group[]

ifdef::VK_VERSION_1_2,VK_KHR_image_format_list[]
[open,refpage='VkImageFormatListCreateInfo',desc='Specify that an image can: be used with a particular set of formats',type='structs',alias='VkImageFormatListCreateInfoKHR']
--
If the pname:pNext chain of slink:VkImageCreateInfo includes a
sname:VkImageFormatListCreateInfo structure, then that structure contains a
list of all formats that can: be used when creating views of this image.

The sname:VkImageFormatListCreateInfo structure is defined as:

include::{generated}/api/structs/VkImageFormatListCreateInfo.adoc[]

ifdef::VK_KHR_image_format_list[]
or the equivalent

include::{generated}/api/structs/VkImageFormatListCreateInfoKHR.adoc[]
endif::VK_KHR_image_format_list[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:viewFormatCount is the number of entries in the pname:pViewFormats
    array.
  * pname:pViewFormats is a pointer to an array of elink:VkFormat values
    specifying all formats which can: be used when creating views of this
    image.

If pname:viewFormatCount is zero, pname:pViewFormats is ignored and the
image is created as if the sname:VkImageFormatListCreateInfo structure were
not included in the pname:pNext chain of slink:VkImageCreateInfo.

.Valid Usage
****
  * [[VUID-VkImageFormatListCreateInfo-viewFormatCount-09540]]
    If pname:viewFormatCount is not 0, each element of pname:pViewFormats
    must: not be ename:VK_FORMAT_UNDEFINED
****

include::{generated}/validity/structs/VkImageFormatListCreateInfo.adoc[]
--
endif::VK_VERSION_1_2,VK_KHR_image_format_list[]

ifdef::VK_EXT_image_drm_format_modifier[]
[open,refpage='VkImageDrmFormatModifierListCreateInfoEXT',desc='Specify that an image must be created with a DRM format modifier from the provided list',type='structs']
--
If the pname:pNext chain of slink:VkImageCreateInfo includes a
slink:VkImageDrmFormatModifierListCreateInfoEXT structure, then the image
will be created with one of the <<glossary-drm-format-modifier,Linux DRM
format modifiers>> listed in the structure.
The choice of modifier is implementation-dependent.

The slink:VkImageDrmFormatModifierListCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkImageDrmFormatModifierListCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:drmFormatModifierCount is the length of the
    pname:pDrmFormatModifiers array.
  * pname:pDrmFormatModifiers is a pointer to an array of _Linux DRM format
    modifiers_.

.Valid Usage
****
  * [[VUID-VkImageDrmFormatModifierListCreateInfoEXT-pDrmFormatModifiers-02263]]
    Each _modifier_ in pname:pDrmFormatModifiers must: be compatible with
    the parameters in slink:VkImageCreateInfo and its pname:pNext chain, as
    determined by querying slink:VkPhysicalDeviceImageFormatInfo2 extended
    with slink:VkPhysicalDeviceImageDrmFormatModifierInfoEXT
****

include::{generated}/validity/structs/VkImageDrmFormatModifierListCreateInfoEXT.adoc[]
--

[open,refpage='VkImageDrmFormatModifierExplicitCreateInfoEXT',desc='Specify that an image be created with the provided DRM format modifier and explicit memory layout',type='structs']
--
If the pname:pNext chain of slink:VkImageCreateInfo includes a
slink:VkImageDrmFormatModifierExplicitCreateInfoEXT structure, then the
image will be created with the <<glossary-drm-format-modifier,Linux DRM
format modifier>> and memory layout defined by the structure.

The slink:VkImageDrmFormatModifierExplicitCreateInfoEXT structure is defined
as:

include::{generated}/api/structs/VkImageDrmFormatModifierExplicitCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:drmFormatModifier is the _Linux DRM format modifier_ with which
    the image will be created.
  * pname:drmFormatModifierPlaneCount is the number of _memory planes_ in
    the image (as reported by slink:VkDrmFormatModifierPropertiesEXT) as
    well as the length of the pname:pPlaneLayouts array.
  * pname:pPlaneLayouts is a pointer to an array of
    slink:VkSubresourceLayout structures describing the image's _memory
    planes_.

The etext:i^th^ member of pname:pPlaneLayouts describes the layout of the
image's etext:i^th^ _memory plane_ (that is,
`VK_IMAGE_ASPECT_MEMORY_PLANE__{ibit}__BIT_EXT`).
In each element of pname:pPlaneLayouts, the implementation must: ignore
pname:size.
The implementation calculates the size of each plane, which the application
can: query with flink:vkGetImageSubresourceLayout.

When creating an image with
slink:VkImageDrmFormatModifierExplicitCreateInfoEXT, it is the application's
responsibility to satisfy all valid usage requirements.
However, the implementation must: validate that the provided
pname:pPlaneLayouts, when combined with the provided pname:drmFormatModifier
and other creation parameters in slink:VkImageCreateInfo and its pname:pNext
chain, produce a valid image.
(This validation is necessarily implementation-dependent and outside the
scope of Vulkan, and therefore not described by valid usage requirements).
If this validation fails, then flink:vkCreateImage returns
ename:VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT.

.Valid Usage
****
  * [[VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-drmFormatModifier-02264]]
    pname:drmFormatModifier must: be compatible with the parameters in
    slink:VkImageCreateInfo and its pname:pNext chain, as determined by
    querying slink:VkPhysicalDeviceImageFormatInfo2 extended with
    slink:VkPhysicalDeviceImageDrmFormatModifierInfoEXT
  * [[VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-drmFormatModifierPlaneCount-02265]]
    pname:drmFormatModifierPlaneCount must: be equal to the
    slink:VkDrmFormatModifierPropertiesEXT::pname:drmFormatModifierPlaneCount
    associated with slink:VkImageCreateInfo::pname:format and
    pname:drmFormatModifier, as found by querying
    slink:VkDrmFormatModifierPropertiesListEXT
  * [[VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-size-02267]]
    For each element of pname:pPlaneLayouts, pname:size must: be 0
  * [[VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-arrayPitch-02268]]
    For each element of pname:pPlaneLayouts, pname:arrayPitch must: be 0 if
    slink:VkImageCreateInfo::pname:arrayLayers is 1
  * [[VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-depthPitch-02269]]
    For each element of pname:pPlaneLayouts, pname:depthPitch must: be 0 if
    slink:VkImageCreateInfo::pname:extent.depth is 1
****

include::{generated}/validity/structs/VkImageDrmFormatModifierExplicitCreateInfoEXT.adoc[]
--
endif::VK_EXT_image_drm_format_modifier[]

ifdef::VK_EXT_image_compression_control[]
[open,refpage='VkImageCompressionControlEXT',desc='Specify image compression properties',type='structs']
--
If the pname:pNext list of slink:VkImageCreateInfo includes a
sname:VkImageCompressionControlEXT structure, then that structure describes
compression controls for this image.

The sname:VkImageCompressionControlEXT structure is defined as:

include::{generated}/api/structs/VkImageCompressionControlEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkImageCompressionFlagBitsEXT
    describing compression controls for the image.
  * pname:compressionControlPlaneCount is the number of entries in the
    pname:pFixedRateFlags array.
  * pname:pFixedRateFlags is `NULL` or a pointer to an array of
    tlink:VkImageCompressionFixedRateFlagsEXT bitfields describing allowed
    fixed-rate compression rates of each image plane.
    It is ignored if pname:flags does not include
    ename:VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT.

If enabled, fixed-rate compression is done in an implementation-defined
manner and may: be applied at block granularity.
In that case, a write to an individual texel may: modify the value of other
texels in the same block.

.Valid Usage
****
  * [[VUID-VkImageCompressionControlEXT-flags-06747]]
    pname:flags must: be one of ename:VK_IMAGE_COMPRESSION_DEFAULT_EXT,
    ename:VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT,
    ename:VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, or
    ename:VK_IMAGE_COMPRESSION_DISABLED_EXT
  * [[VUID-VkImageCompressionControlEXT-flags-06748]]
    If pname:flags includes
    ename:VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT,
    pname:pFixedRateFlags must: not be `NULL`
****

include::{generated}/validity/structs/VkImageCompressionControlEXT.adoc[]

[NOTE]
====
Some combinations of compression properties may not be supported.
For example, some implementations may not support different fixed-rate
compression rates per plane of a multi-planar format and will not be able to
enable fixed-rate compression for any plane if the requested rates differ.
====
--

[open,refpage='VkImageCompressionFlagBitsEXT',desc='Bitmask specifying image compression controls',type='enums']
--
Possible values of slink:VkImageCompressionControlEXT::pname:flags,
specifying compression controls for an image, are:

include::{generated}/api/enums/VkImageCompressionFlagBitsEXT.adoc[]

  * ename:VK_IMAGE_COMPRESSION_DEFAULT_EXT specifies that the default image
    compression setting is used.
    Implementations must: not apply fixed-rate compression.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT specifies that the
    implementation may: choose any supported fixed-rate compression setting
    in an implementation-defined manner based on the properties of the
    image.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT specifies that
    fixed-rate compression may: be used and that the allowed compression
    rates are specified by
    slink:VkImageCompressionControlEXT::pname:pFixedRateFlags.
  * ename:VK_IMAGE_COMPRESSION_DISABLED_EXT specifies that all lossless and
    fixed-rate compression should: be disabled.

If slink:VkImageCompressionControlEXT::pname:flags is
ename:VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, then the etext:i^th^
member of the pname:pFixedRateFlags array specifies the allowed compression
rates for the image's etext:i^th^ plane.

[NOTE]
====
If ename:VK_IMAGE_COMPRESSION_DISABLED_EXT is included in
slink:VkImageCompressionControlEXT::pname:flags, both lossless and
fixed-rate compression will be disabled.
This is likely to have a negative impact on performance and is only intended
to be used for debugging purposes.
====
--

[open,refpage='VkImageCompressionFlagsEXT',desc='Bitmask of VkImageCompressionFlagBitsEXT', type='flags']
--
include::{generated}/api/flags/VkImageCompressionFlagsEXT.adoc[]

tname:VkImageCompressionFlagsEXT is a bitmask type for setting a mask of
zero or more elink:VkImageCompressionFlagBitsEXT.
--

[open,refpage='VkImageCompressionFixedRateFlagsEXT',desc='Bitmask of VkImageCompressionFixedRateFlagBitsEXT',type='flags']
--
include::{generated}/api/flags/VkImageCompressionFixedRateFlagsEXT.adoc[]

tname:VkImageCompressionFixedRateFlagsEXT is a bitmask type for setting a
mask of zero or more elink:VkImageCompressionFixedRateFlagBitsEXT.
--

[open,refpage='VkImageCompressionFixedRateFlagBitsEXT',desc='Bitmask specifying fixed rate image compression rates',type='enums']
--
Bits which can: be set in
slink:VkImageCompressionControlEXT::pname:pFixedRateFlags, specifying
allowed compression rates for an image plane, are:

include::{generated}/api/enums/VkImageCompressionFixedRateFlagBitsEXT.adoc[]

  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT specifies that fixed-rate
    compression must: not be used.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT specifies that
    fixed-rate compression with a bitrate of [eq]#[1,2)# bits per component
    may: be used.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT specifies that
    fixed-rate compression with a bitrate of [eq]#[2,3)# bits per component
    may: be used.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT specifies that
    fixed-rate compression with a bitrate of [eq]#[3,4)# bits per component
    may: be used.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT specifies that
    fixed-rate compression with a bitrate of [eq]#[4,5)# bits per component
    may: be used.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT specifies that
    fixed-rate compression with a bitrate of [eq]#[5,6)# bits per component
    may: be used.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT specifies that
    fixed-rate compression with a bitrate of [eq]#[6,7)# bits per component
    may: be used.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT specifies that
    fixed-rate compression with a bitrate of [eq]#[7,8)# bits per component
    may: be used.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT specifies that
    fixed-rate compression with a bitrate of [eq]#[8,9)# bits per component
    may: be used.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT specifies that
    fixed-rate compression with a bitrate of [eq]#[9,10)# bits per component
    may: be used.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT specifies that
    fixed-rate compression with a bitrate of [eq]#[10,11)# bits per
    component may: be used.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT specifies that
    fixed-rate compression with a bitrate of [eq]#[11,12)# bits per
    component may: be used.
  * ename:VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT specifies that
    fixed-rate compression with a bitrate of at least 12 bits per component
    may: be used.

If the format has a different bit rate for different components,
slink:VkImageCompressionControlEXT::pname:pFixedRateFlags describes the rate
of the component with the largest number of bits assigned to it, scaled pro
rata.
For example, to request that a ename:VK_FORMAT_A2R10G10B10_UNORM_PACK32
format be stored at a rate of 8 bits per pixel, use
ename:VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT (10 bits for the largest
component, stored at quarter the original size, 2.5 bits, rounded down).

If pname:flags includes ename:VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT,
and multiple bits are set in
slink:VkImageCompressionControlEXT::pname:pFixedRateFlags for a plane,
implementations should: apply the lowest allowed bitrate that is supported.

[NOTE]
====
The choice of "`bits per component`" terminology was chosen so that the same
compression rate describes the same degree of compression applied to formats
that differ only in the number of components.
For example, ename:VK_FORMAT_R8G8_UNORM compressed to half its original size
is a rate of 4 bits per component, 8 bits per pixel.
ename:VK_FORMAT_R8G8B8A8_UNORM compressed to half _its_ original size is 4
bits per component, 16 bits per pixel.
Both of these cases can be requested with
ename:VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT.
====
--

[open,refpage='VkImageCompressionPropertiesEXT',desc='Compression properties of an image',type='structs']
--
To query the compression properties of an image, add a
slink:VkImageCompressionPropertiesEXT structure to the pname:pNext chain of
the slink:VkSubresourceLayout2EXT structure in a call to
ifdef::VK_KHR_maintenance5[flink:vkGetImageSubresourceLayout2KHR or]
flink:vkGetImageSubresourceLayout2EXT.

To determine the compression rates that are supported for a given image
format, add a slink:VkImageCompressionPropertiesEXT structure to the
pname:pNext chain of the slink:VkImageFormatProperties2 structure in a call
to flink:vkGetPhysicalDeviceImageFormatProperties2.

[NOTE]
====
Since fixed-rate compression is disabled by default, the
slink:VkImageCompressionPropertiesEXT structure passed to
flink:vkGetPhysicalDeviceImageFormatProperties2 will not indicate any
fixed-rate compression support unless a slink:VkImageCompressionControlEXT
structure is also included in the pname:pNext chain of the
slink:VkPhysicalDeviceImageFormatInfo2 structure passed to the same command.
====

The sname:VkImageCompressionPropertiesEXT structure is defined as:

include::{generated}/api/structs/VkImageCompressionPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:imageCompressionFlags returns a value describing the compression
    controls that apply to the image.
    The value will be either ename:VK_IMAGE_COMPRESSION_DEFAULT_EXT to
    indicate no fixed-rate compression,
    ename:VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT to indicate
    fixed-rate compression, or ename:VK_IMAGE_COMPRESSION_DISABLED_EXT to
    indicate no compression.
  * pname:imageCompressionFixedRateFlags returns a
    tlink:VkImageCompressionFixedRateFlagsEXT value describing the
    compression rates that apply to the specified aspect of the image.

include::{generated}/validity/structs/VkImageCompressionPropertiesEXT.adoc[]
--
endif::VK_EXT_image_compression_control[]

ifdef::VK_MESA_image_alignment_control[]
[open,refpage='VkImageAlignmentControlCreateInfoMESA',desc='Specify image alignment',type='structs']
--
If the pname:pNext list of slink:VkImageCreateInfo includes a
sname:VkImageAlignmentControlCreateInfoMESA structure, then that structure
describes desired alignment for this image.

The sname:VkImageAlignmentControlCreateInfoMESA structure is defined as:

include::{generated}/api/structs/VkImageAlignmentControlCreateInfoMESA.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:maximumRequestedAlignment specifies the maximum alignment for the
    image.

If pname:maximumRequestedAlignment is not 0, the implementation should:
choose an image memory layout that requires an alignment no larger than
pname:maximumRequestedAlignment as reported in
slink:VkMemoryRequirements::pname:alignment.
If such a layout does not exist for the given image creation parameters, the
implementation should: return the smallest alignment which is supported in
slink:VkMemoryRequirements.

If an implementation needs to disable image compression for
pname:maximumRequestedAlignment to be honored -
where a larger alignment would enable image compression -
the implementation should: not use pname:maximumRequestedAlignment, and
should: return the smallest alignment which does not compromise compression.
ifdef::VK_EXT_image_compression_control[]
If <<features-imageCompressionControl,pname:imageCompressionControl>> is
enabled, the application can: chain a slink:VkImageCompressionControlEXT
with ename:VK_IMAGE_COMPRESSION_DISABLED_EXT.
In this case, image compression considerations should: not apply when
implementation decides alignment.
endif::VK_EXT_image_compression_control[]

.Valid Usage
****
  * [[VUID-VkImageAlignmentControlCreateInfoMESA-maximumRequestedAlignment-09655]]
    If pname:maximumRequestedAlignment is not 0,
    pname:maximumRequestedAlignment must: be a power of two
  * [[VUID-VkImageAlignmentControlCreateInfoMESA-maximumRequestedAlignment-09656]]
    If pname:maximumRequestedAlignment is not 0, the bitwise-and of
    pname:maximumRequestedAlignment and
    <<limits-supportedImageAlignmentMask,pname:supportedImageAlignmentMask>>
    must: be non-zero
  * [[VUID-VkImageAlignmentControlCreateInfoMESA-imageAlignmentControl-09657]]
    <<features-imageAlignmentControl,pname:imageAlignmentControl>> must: be
    enabled on the device
****

include::{generated}/validity/structs/VkImageAlignmentControlCreateInfoMESA.adoc[]

--
endif::VK_MESA_image_alignment_control[]

[open,refpage='VkImageUsageFlagBits',desc='Bitmask specifying intended usage of an image',type='enums']
--
Bits which can: be set in

ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
  * slink:VkImageViewUsageCreateInfo::pname:usage
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
ifdef::VK_VERSION_1_2,VK_EXT_separate_stencil_usage[]
  * slink:VkImageStencilUsageCreateInfo::pname:stencilUsage
endif::VK_VERSION_1_2,VK_EXT_separate_stencil_usage[]
  * slink:VkImageCreateInfo::pname:usage

specify intended usage of an image, and are:

include::{generated}/api/enums/VkImageUsageFlagBits.adoc[]

  * ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT specifies that the image can: be
    used as the source of a transfer command.
  * ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT specifies that the image can: be
    used as the destination of a transfer command.
  * ename:VK_IMAGE_USAGE_SAMPLED_BIT specifies that the image can: be used
    to create a sname:VkImageView suitable for occupying a
    sname:VkDescriptorSet slot either of type
    ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and be sampled by a
    shader.
  * ename:VK_IMAGE_USAGE_STORAGE_BIT specifies that the image can: be used
    to create a sname:VkImageView suitable for occupying a
    sname:VkDescriptorSet slot of type
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.
  * ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT specifies that the image can:
    be used to create a sname:VkImageView suitable for use as a color or
    resolve attachment in a sname:VkFramebuffer.
  * ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT specifies that the
    image can: be used to create a sname:VkImageView suitable for use as a
    depth/stencil
ifdef::VK_VERSION_1_2,VK_KHR_depth_stencil_resolve[]
    or depth/stencil resolve
endif::VK_VERSION_1_2,VK_KHR_depth_stencil_resolve[]
    attachment in a sname:VkFramebuffer.
  * ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT specifies that
    implementations may: support using <<memory, memory allocations>> with
    the ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT to back an image with
    this usage.
    This bit can: be set for any image that can: be used to create a
    sname:VkImageView suitable for use as a color, resolve, depth/stencil,
    or input attachment.
  * ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT specifies that the image can:
    be used to create a sname:VkImageView suitable for occupying
    sname:VkDescriptorSet slot of type
    ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT; be read from a shader as an
    input attachment; and be used as an input attachment in a framebuffer.
ifdef::VK_EXT_fragment_density_map[]
  * ename:VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT specifies that the
    image can: be used to create a sname:VkImageView suitable for use as a
    <<fragmentdensitymapops, fragment density map image>>.
endif::VK_EXT_fragment_density_map[]
ifdef::VK_KHR_fragment_shading_rate,VK_NV_shading_rate_image[]
  * ename:VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR specifies
    that the image can: be used to create a sname:VkImageView suitable for
    use as a
ifdef::VK_KHR_fragment_shading_rate[]
    <<primsrast-fragment-shading-rate-attachment, fragment shading rate
    attachment>>
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_KHR_fragment_shading_rate+VK_NV_shading_rate_image[or]
ifdef::VK_NV_shading_rate_image[]
    <<primsrast-shading-rate-image, shading rate image>>
endif::VK_NV_shading_rate_image[]
endif::VK_KHR_fragment_shading_rate,VK_NV_shading_rate_image[]
ifdef::VK_KHR_video_decode_queue[]
  * ename:VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR specifies that the image
    can: be used as a <<decode-output-picture,decode output picture>> in a
    <<video-decode-operations,video decode operation>>.
  * ename:VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR is reserved for future
    use.
  * ename:VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR specifies that the image
    can: be used as an output <<reconstructed-picture,reconstructed
    picture>> or an input <<reference-picture,reference picture>> in a
    <<video-decode-operations,video decode operation>>.
endif::VK_KHR_video_decode_queue[]
ifdef::VK_KHR_video_encode_queue[]
  * ename:VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR is reserved for future
    use.
  * ename:VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR specifies that the image
    can: be used as an <<encode-input-picture,encode input picture>> in a
    <<video-encode-operations,video encode operation>>.
  * ename:VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR specifies that the image
    can: be used as an output <<reconstructed-picture,reconstructed
    picture>> or an input <<reference-picture,reference picture>> in a
    <<video-encode-operations,video encode operation>>.
endif::VK_KHR_video_encode_queue[]
ifdef::VK_EXT_attachment_feedback_loop_layout[]
  * ename:VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT specifies that the
    image can: be transitioned to the
    ename:VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT layout to be
    used as a color or depth/stencil attachment in a sname:VkFramebuffer
    and/or as a read-only input resource in a shader (sampled image,
    combined image sampler or input attachment) in the same render pass.
endif::VK_EXT_attachment_feedback_loop_layout[]
ifdef::VK_EXT_host_image_copy[]
  * ename:VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT specifies that the image can:
    be used with host copy commands and host layout transitions.
endif::VK_EXT_host_image_copy[]
--

[open,refpage='VkImageUsageFlags',desc='Bitmask of VkImageUsageFlagBits',type='flags']
--
include::{generated}/api/flags/VkImageUsageFlags.adoc[]

tname:VkImageUsageFlags is a bitmask type for setting a mask of zero or more
elink:VkImageUsageFlagBits.

[[valid-imageview-imageusage]]
When creating a sname:VkImageView one of the following
elink:VkImageUsageFlagBits must: be set:

  * ename:VK_IMAGE_USAGE_SAMPLED_BIT
  * ename:VK_IMAGE_USAGE_STORAGE_BIT
  * ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
  * ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
  * ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
  * ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT
ifdef::VK_NV_shading_rate_image,VK_KHR_fragment_shading_rate[]
  * ename:VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
endif::VK_NV_shading_rate_image,VK_KHR_fragment_shading_rate[]
ifdef::VK_EXT_fragment_density_map[]
  * ename:VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT
endif::VK_EXT_fragment_density_map[]
ifdef::VK_KHR_video_decode_queue[]
  * ename:VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR
  * ename:VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR
endif::VK_KHR_video_decode_queue[]
ifdef::VK_KHR_video_encode_queue[]
  * ename:VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR
  * ename:VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR
endif::VK_KHR_video_encode_queue[]
ifdef::VK_QCOM_image_processing[]
  * ename:VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM
  * ename:VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM
endif::VK_QCOM_image_processing[]
--

[open,refpage='VkImageCreateFlagBits',desc='Bitmask specifying additional parameters of an image',type='enums']
--
Bits which can: be set in slink:VkImageCreateInfo::pname:flags, specifying
additional parameters of an image, are:

include::{generated}/api/enums/VkImageCreateFlagBits.adoc[]

  * ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT specifies that the image will
    be backed using sparse memory binding.
ifdef::VKSC_VERSION_1_0[]
    This flag is not supported in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]
  * ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT specifies that the image can:
    be partially backed using sparse memory binding.
    Images created with this flag must: also be created with the
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag.
ifdef::VKSC_VERSION_1_0[]
    This flag is not supported in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]
  * ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT specifies that the image will
    be backed using sparse memory binding with memory ranges that might also
    simultaneously be backing another image (or another portion of the same
    image).
    Images created with this flag must: also be created with the
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag.
ifdef::VKSC_VERSION_1_0[]
    This flag is not supported in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]
  * ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT specifies that the image can:
    be used to create a sname:VkImageView with a different format from the
    image.
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
    For <<formats-requiring-sampler-ycbcr-conversion,multi-planar>> formats,
    ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT specifies that a
    sname:VkImageView can be created of a _plane_ of the image.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT specifies that the image can:
    be used to create a sname:VkImageView of type
    ename:VK_IMAGE_VIEW_TYPE_CUBE or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY.
ifdef::VK_VERSION_1_1,VK_KHR_maintenance1[]
  * ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT specifies that the image
    can: be used to create a sname:VkImageView of type
    ename:VK_IMAGE_VIEW_TYPE_2D or ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY.
endif::VK_VERSION_1_1,VK_KHR_maintenance1[]
ifdef::VK_EXT_image_2d_view_of_3d[]
  * ename:VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT specifies that the
    image can: be used to create a sname:VkImageView of type
    ename:VK_IMAGE_VIEW_TYPE_2D.
endif::VK_EXT_image_2d_view_of_3d[]
ifdef::VK_VERSION_1_1[]
  * ename:VK_IMAGE_CREATE_PROTECTED_BIT specifies that the image is a
    protected image.
endif::VK_VERSION_1_1[]
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
  * ename:VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT specifies that the
    image can: be used with a non-zero value of the
    pname:splitInstanceBindRegionCount member of a
    slink:VkBindImageMemoryDeviceGroupInfo structure passed into
    flink:vkBindImageMemory2.
    This flag also has the effect of making the image use the standard
    sparse image block dimensions.
ifdef::VKSC_VERSION_1_0[]
    This flag is not supported in Vulkan SC <<SCID-8>>.
endif::VKSC_VERSION_1_0[]
endif::VK_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
  * ename:VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT specifies that the
    image having a compressed format can: be used to create a
    sname:VkImageView with an uncompressed format where each texel in the
    image view corresponds to a compressed texel block of the image.
  * ename:VK_IMAGE_CREATE_EXTENDED_USAGE_BIT specifies that the image can:
    be created with usage flags that are not supported for the format the
    image is created with but are supported for at least one format a
    sname:VkImageView created from the image can: have.
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * ename:VK_IMAGE_CREATE_DISJOINT_BIT specifies that an image with a
    <<formats-requiring-sampler-ycbcr-conversion,multi-planar format>> must:
    have each plane separately bound to memory, rather than having a single
    memory binding for the whole image; the presence of this bit
    distinguishes a _disjoint image_ from an image without this bit set.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_VERSION_1_1,VK_KHR_bind_memory2[]
  * ename:VK_IMAGE_CREATE_ALIAS_BIT specifies that two images created with
    the same creation parameters and aliased to the same memory can:
    interpret the contents of the memory consistently with each other,
    subject to the rules described in the <<resources-memory-aliasing,Memory
    Aliasing>> section.
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
    This flag further specifies that each plane of a _disjoint_ image can:
    share an in-memory non-linear representation with single-plane images,
    and that a single-plane image can: share an in-memory non-linear
    representation with a plane of a multi-planar disjoint image, according
    to the rules in <<formats-compatible-planes>>.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_VERSION_1_1,VK_KHR_external_memory,VK_NV_external_memory[]
    If the pname:pNext chain includes a
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[slink:VkExternalMemoryImageCreateInfo]
// Jon: logic needs to incorporate VK_VERSION_1_1
ifdef::VK_KHR_external_memory+VK_NV_external_memory[or]
ifdef::VK_NV_external_memory[slink:VkExternalMemoryImageCreateInfoNV]
    structure whose pname:handleTypes member is not `0`, it is as if
    ename:VK_IMAGE_CREATE_ALIAS_BIT is set.
endif::VK_VERSION_1_1,VK_KHR_external_memory,VK_NV_external_memory[]
endif::VK_VERSION_1_1,VK_KHR_bind_memory2[]
ifdef::VK_EXT_sample_locations[]
  * ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT
    specifies that an image with a depth or depth/stencil format can: be
    used with custom sample locations when used as a depth/stencil
    attachment.
endif::VK_EXT_sample_locations[]
ifdef::VK_NV_corner_sampled_image[]
  * ename:VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV specifies that the image is
    a <<resources-images-corner-sampled,corner-sampled image>>.
endif::VK_NV_corner_sampled_image[]
ifdef::VK_EXT_fragment_density_map[]
  * ename:VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT specifies that an image can: be
    in a subsampled format which may: be more optimal when written as an
    attachment by a render pass that has a fragment density map attachment.
    Accessing a subsampled image has additional considerations:
  ** Image data read as an image sampler will have undefined: values if the
     sampler was not created with pname:flags containing
     ename:VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT or was not sampled through
     the use of a combined image sampler with an immutable sampler in
     sname:VkDescriptorSetLayoutBinding.
  ** Image data read with an input attachment will have undefined: values if
     the contents were not written as an attachment in an earlier subpass of
     the same render pass.
ifdef::VK_EXT_fragment_density_map2[]
  ** Image data read as an image sampler in the fragment shader will be
     additionally be read by the device during
     ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT if
     <<limits-subsampledCoarseReconstructionEarlyAccess,
     sname:VkPhysicalDeviceFragmentDensityMap2PropertiesEXT::pname:subsampledCoarseReconstructionEarlyAccess>>
     is ename:VK_TRUE and the sampler was created with pname:flags
     containing
     ename:VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT.
  ** Image data read with load operations are resampled to the fragment
     density of the render pass if <<limits-subsampledLoads,
     sname:VkPhysicalDeviceFragmentDensityMap2PropertiesEXT::pname:subsampledLoads>>
     is ename:VK_TRUE.
     Otherwise, values of image data are undefined:.
endif::VK_EXT_fragment_density_map2[]
ifndef::VK_EXT_fragment_density_map2[]
  ** Image data read with load operations may: be resampled to the fragment
     density of the render pass.
endif::VK_EXT_fragment_density_map2[]
  ** Image contents outside of the render area take on undefined: values if
     the image is stored as a render pass attachment.
ifdef::VK_QCOM_fragment_density_map_offset[]
  * ename:VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM specifies
    that an image can: be used in a render pass with non-zero
    <<renderpass-fragmentdensitymapoffsets,fragment density map offsets>>.
    In a render pass with non-zero offsets, fragment density map
    attachments, input attachments, color attachments, depth/stencil
    attachment, resolve attachments, and preserve attachments must: be
    created with ename:VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM.
endif::VK_QCOM_fragment_density_map_offset[]
endif::VK_EXT_fragment_density_map[]
ifdef::VK_EXT_descriptor_buffer[]
  * ename:VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT specifies
    that the image can: be used with descriptor buffers when capturing and
    replaying (e.g. for trace capture and replay), see
    slink:VkOpaqueCaptureDescriptorDataCreateInfoEXT for more detail.
endif::VK_EXT_descriptor_buffer[]
ifdef::VK_EXT_multisampled_render_to_single_sampled[]
  * ename:VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT
    specifies that an image can: be used with
    <<multisampled-render-to-single-sampled,multisampled rendering as a
    single-sampled framebuffer attachment>>
endif::VK_EXT_multisampled_render_to_single_sampled[]
ifdef::VK_KHR_video_maintenance1[]
  * ename:VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR specifies that
    the image can: be used in <<video-coding,video coding operations>>
    without having to specify at image creation time the set of video
    profiles the image will be used with, except for images used only as
    <<dpb,DPB>> pictures, as long as the image is otherwise
    <<video-profile-compatibility,compatible>> with the video profile in
    question.
+
[NOTE]
====
This enables exchanging video picture data without additional copies or
conversions when used as:

ifdef::VK_KHR_video_decode_queue[]
  * <<decode-output-picture,Decode output pictures>>, indifferent of the
    video profile used to produce them.
endif::VK_KHR_video_decode_queue[]
ifdef::VK_KHR_video_encode_queue[]
  * <<encode-input-picture,Encode input pictures>>, indifferent of the video
    profile used to consume them.
endif::VK_KHR_video_encode_queue[]

ifdef::VK_KHR_video_decode_queue[]
This includes images created with both
ename:VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR and
ename:VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR, which is necessary to use the
same video picture as the <<reconstructed-picture,reconstructed picture>>
and <<decode-output-picture,decode output picture>> in a video decode
operation on implementations supporting
ename:VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR.
endif::VK_KHR_video_decode_queue[]

However, images with only DPB usage remain tied to the video profiles the
image was created with, as the data layout of such DPB-only images may: be
implementation- and codec-dependent.

If an application would like to share or reuse the device memory backing
such images (e.g. for the purposes of temporal aliasing), then it should:
create separate image objects for each video profile and bind them to the
same underlying device memory range, similar to how memory resources can: be
shared across separate video sessions or any other memory-backed resource.
====
endif::VK_KHR_video_maintenance1[]

See <<sparsememory-sparseresourcefeatures,Sparse Resource Features>> and
<<sparsememory-physicalfeatures,Sparse Physical Device Features>> for more
details.
--

[open,refpage='VkImageCreateFlags',desc='Bitmask of VkImageCreateFlagBits',type='flags']
--
include::{generated}/api/flags/VkImageCreateFlags.adoc[]

tname:VkImageCreateFlags is a bitmask type for setting a mask of zero or
more elink:VkImageCreateFlagBits.
--

[open,refpage='VkImageType',desc='Specifies the type of an image object',type='enums']
--
Possible values of slink:VkImageCreateInfo::pname:imageType, specifying the
basic dimensionality of an image, are:

include::{generated}/api/enums/VkImageType.adoc[]

  * ename:VK_IMAGE_TYPE_1D specifies a one-dimensional image.
  * ename:VK_IMAGE_TYPE_2D specifies a two-dimensional image.
  * ename:VK_IMAGE_TYPE_3D specifies a three-dimensional image.
--

[open,refpage='VkImageTiling',desc='Specifies the tiling arrangement of data in an image',type='enums']
--
Possible values of slink:VkImageCreateInfo::pname:tiling, specifying the
tiling arrangement of texel blocks in an image, are:

include::{generated}/api/enums/VkImageTiling.adoc[]

  * ename:VK_IMAGE_TILING_OPTIMAL specifies optimal tiling (texels are laid
    out in an implementation-dependent arrangement, for more efficient
    memory access).
  * ename:VK_IMAGE_TILING_LINEAR specifies linear tiling (texels are laid
    out in memory in row-major order, possibly with some padding on each
    row).
ifdef::VK_EXT_image_drm_format_modifier[]
  * ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT indicates that the image's
    tiling is defined by a <<glossary-drm-format-modifier,Linux DRM format
    modifier>>.
    The modifier is specified at image creation with
    slink:VkImageDrmFormatModifierListCreateInfoEXT or
    slink:VkImageDrmFormatModifierExplicitCreateInfoEXT, and can: be queried
    with flink:vkGetImageDrmFormatModifierPropertiesEXT.
endif::VK_EXT_image_drm_format_modifier[]
--

[open,refpage='vkGetImageSubresourceLayout',desc='Retrieve information about an image subresource',type='protos']
--
:refpage: vkGetImageSubresourceLayout

To query the memory layout of an image subresource, call:

include::{generated}/api/protos/vkGetImageSubresourceLayout.adoc[]

  * pname:device is the logical device that owns the image.
  * pname:image is the image whose layout is being queried.
  * pname:pSubresource is a pointer to a slink:VkImageSubresource structure
    selecting a specific image subresource from the image.
  * pname:pLayout is a pointer to a slink:VkSubresourceLayout structure in
    which the layout is returned.

ifndef::VK_EXT_image_drm_format_modifier[]
The image must: be <<glossary-linear-resource,linear>>.
The
endif::VK_EXT_image_drm_format_modifier[]
ifdef::VK_EXT_image_drm_format_modifier[]
If the image is <<glossary-linear-resource,linear>>, then the
endif::VK_EXT_image_drm_format_modifier[]
returned layout is valid for <<memory-device-hostaccess, host access>>.

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
If the image's
ifdef::VK_EXT_image_drm_format_modifier[]
tiling is ename:VK_IMAGE_TILING_LINEAR and its
endif::VK_EXT_image_drm_format_modifier[]
format is a <<formats-requiring-sampler-ycbcr-conversion,multi-planar
format>>, then fname:vkGetImageSubresourceLayout describes one
ifdef::VK_EXT_image_drm_format_modifier[_format plane_]
ifndef::VK_EXT_image_drm_format_modifier[plane]
of the image.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_EXT_image_drm_format_modifier[]
If the image's tiling is ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then
fname:vkGetImageSubresourceLayout describes one _memory plane_ of the image.
If the image's tiling is ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT and
the image is <<glossary-linear-resource,non-linear>>, then the returned
layout has an implementation-dependent meaning; the vendor of the image's
<<glossary-drm-format-modifier,DRM format modifier>> may: provide
documentation that explains how to interpret the returned layout.
endif::VK_EXT_image_drm_format_modifier[]

fname:vkGetImageSubresourceLayout is invariant for the lifetime of a single
image.
ifdef::VK_ANDROID_external_memory_android_hardware_buffer,VK_QNX_external_memory_screen_buffer[]
However, the subresource layout of images in Android hardware buffer or QNX
Screen buffer external memory is not known until the image has been bound to
memory, so applications must: not call flink:vkGetImageSubresourceLayout for
such an image before it has been bound.
endif::VK_ANDROID_external_memory_android_hardware_buffer,VK_QNX_external_memory_screen_buffer[]

:imageparam: image

.Valid Usage
****
ifndef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-vkGetImageSubresourceLayout-image-07789]]
    pname:image must: have been created with pname:tiling equal to
    ename:VK_IMAGE_TILING_LINEAR
endif::VK_EXT_image_drm_format_modifier[]
ifdef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-vkGetImageSubresourceLayout-image-07790]]
    pname:image must: have been created with pname:tiling equal to
    ename:VK_IMAGE_TILING_LINEAR or
    ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT
endif::VK_EXT_image_drm_format_modifier[]
include::{chapters}/commonvalidity/get_image_subresource_layout_common.adoc[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
  * [[VUID-vkGetImageSubresourceLayout-image-09432]]
    If pname:image was created with the
    ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID
    external memory handle type, then pname:image must: be bound to memory
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-vkGetImageSubresourceLayout-tiling-09433]]
    If the pname:tiling of the pname:image is
    ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the pname:aspectMask
    member of pname:pSubresource must: be
    `VK_IMAGE_ASPECT_MEMORY_PLANE__{ibit}__BIT_EXT` and the index _i_ must:
    be less than the
    slink:VkDrmFormatModifierPropertiesEXT::pname:drmFormatModifierPlaneCount
    associated with the image's pname:format and
    slink:VkImageDrmFormatModifierPropertiesEXT::pname:drmFormatModifier
endif::VK_EXT_image_drm_format_modifier[]
****

include::{generated}/validity/protos/vkGetImageSubresourceLayout.adoc[]
--

[open,refpage='VkImageSubresource',desc='Structure specifying an image subresource',type='structs']
--
The sname:VkImageSubresource structure is defined as:

include::{generated}/api/structs/VkImageSubresource.adoc[]

  * pname:aspectMask is a tlink:VkImageAspectFlags value selecting the image
    _aspect_.
  * pname:mipLevel selects the mipmap level.
  * pname:arrayLayer selects the array layer.

include::{generated}/validity/structs/VkImageSubresource.adoc[]
--

[open,refpage='VkSubresourceLayout',desc='Structure specifying subresource layout',type='structs']
--
Information about the layout of the image subresource is returned in a
sname:VkSubresourceLayout structure:

include::{generated}/api/structs/VkSubresourceLayout.adoc[]

  * pname:offset is the byte offset from the start of the image
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
    or the plane
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
    where the image subresource begins.
  * pname:size is the size in bytes of the image subresource.
    pname:size includes any extra memory that is required based on
    pname:rowPitch.
  * pname:rowPitch describes the number of bytes between each row of texels
    in an image.
  * pname:arrayPitch describes the number of bytes between each array layer
    of an image.
  * pname:depthPitch describes the number of bytes between each slice of 3D
    image.

If the image is <<glossary-linear-resource,linear>>, then pname:rowPitch,
pname:arrayPitch and pname:depthPitch describe the layout of the image
subresource in linear memory.
For uncompressed formats, pname:rowPitch is the number of bytes between
texels with the same x coordinate in adjacent rows (y coordinates differ by
one).
pname:arrayPitch is the number of bytes between texels with the same x and y
coordinate in adjacent array layers of the image (array layer values differ
by one).
pname:depthPitch is the number of bytes between texels with the same x and y
coordinate in adjacent slices of a 3D image (z coordinates differ by one).
Expressed as an addressing formula, the starting byte of a texel in the
image subresource has address:

[source,c]
----
// (x,y,z,layer) are in texel coordinates
address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*elementSize + offset
----

For compressed formats, the pname:rowPitch is the number of bytes between
compressed texel blocks in adjacent rows.
pname:arrayPitch is the number of bytes between compressed texel blocks in
adjacent array layers.
pname:depthPitch is the number of bytes between compressed texel blocks in
adjacent slices of a 3D image.

[source,c]
----
// (x,y,z,layer) are in compressed texel block coordinates
address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*compressedTexelBlockByteSize + offset;
----

The value of pname:arrayPitch is undefined: for images that were not created
as arrays.
pname:depthPitch is defined only for 3D images.

If the image has a
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
_single-plane_
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
color format
ifdef::VK_EXT_image_drm_format_modifier[]
and its tiling is ename:VK_IMAGE_TILING_LINEAR
endif::VK_EXT_image_drm_format_modifier[]
, then the pname:aspectMask member of sname:VkImageSubresource must: be
ename:VK_IMAGE_ASPECT_COLOR_BIT.

If the image has a depth/stencil format
ifdef::VK_EXT_image_drm_format_modifier[]
and its tiling is ename:VK_IMAGE_TILING_LINEAR
endif::VK_EXT_image_drm_format_modifier[]
, then pname:aspectMask must: be either ename:VK_IMAGE_ASPECT_DEPTH_BIT or
ename:VK_IMAGE_ASPECT_STENCIL_BIT.
On implementations that store depth and stencil aspects separately, querying
each of these image subresource layouts will return a different pname:offset
and pname:size representing the region of memory used for that aspect.
On implementations that store depth and stencil aspects interleaved, the
same pname:offset and pname:size are returned and represent the interleaved
memory allocation.

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
If the image has a <<formats-requiring-sampler-ycbcr-conversion,multi-planar
format>>
ifdef::VK_EXT_image_drm_format_modifier[]
and its tiling is ename:VK_IMAGE_TILING_LINEAR
endif::VK_EXT_image_drm_format_modifier[]
, then the pname:aspectMask member of sname:VkImageSubresource must: be
ename:VK_IMAGE_ASPECT_PLANE_0_BIT, ename:VK_IMAGE_ASPECT_PLANE_1_BIT, or
(for 3-plane formats only) ename:VK_IMAGE_ASPECT_PLANE_2_BIT.
Querying each of these image subresource layouts will return a different
pname:offset and pname:size representing the region of memory used for that
plane.
If the image is _disjoint_, then the pname:offset is relative to the base
address of the plane.
If the image is _non-disjoint_, then the pname:offset is relative to the
base address of the image.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

ifdef::VK_EXT_image_drm_format_modifier[]
If the image's tiling is ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then
the pname:aspectMask member of sname:VkImageSubresource must: be one of
`VK_IMAGE_ASPECT_MEMORY_PLANE__{ibit}__BIT_EXT`, where the maximum allowed
plane index _i_ is defined by the
slink:VkDrmFormatModifierPropertiesEXT::pname:drmFormatModifierPlaneCount
associated with the image's slink:VkImageCreateInfo::pname:format and
<<glossary-drm-format-modifier,modifier>>.
The memory range used by the subresource is described by pname:offset and
pname:size.
If the image is _disjoint_, then the pname:offset is relative to the base
address of the _memory plane_.
If the image is _non-disjoint_, then the pname:offset is relative to the
base address of the image.
If the image is <<glossary-linear-resource,non-linear>>, then
pname:rowPitch, pname:arrayPitch, and pname:depthPitch have an
implementation-dependent meaning.
endif::VK_EXT_image_drm_format_modifier[]

include::{generated}/validity/structs/VkSubresourceLayout.adoc[]
--

ifdef::VK_KHR_maintenance5,VK_EXT_image_compression_control,VK_EXT_host_image_copy[]
[open,refpage='vkGetImageSubresourceLayout2KHR',desc='Retrieve information about an image subresource',type='protos']
--
:refpage: vkGetImageSubresourceLayout2KHR

To query the memory layout of an image subresource, call:

ifdef::VK_KHR_maintenance5[]
include::{generated}/api/protos/vkGetImageSubresourceLayout2KHR.adoc[]
endif::VK_KHR_maintenance5[]

ifdef::VK_KHR_maintenance5[]
ifdef::VK_EXT_image_compression_control,VK_EXT_host_image_copy[or the equivalent command]
endif::VK_KHR_maintenance5[]

ifdef::VK_EXT_image_compression_control,VK_EXT_host_image_copy[]
include::{generated}/api/protos/vkGetImageSubresourceLayout2EXT.adoc[]
endif::VK_EXT_image_compression_control,VK_EXT_host_image_copy[]

  * pname:device is the logical device that owns the image.
  * pname:image is the image whose layout is being queried.
  * pname:pSubresource is a pointer to a slink:VkImageSubresource2KHR
    structure selecting a specific image for the image subresource.
  * pname:pLayout is a pointer to a slink:VkSubresourceLayout2KHR structure
    in which the layout is returned.

fname:vkGetImageSubresourceLayout2KHR behaves similarly to
flink:vkGetImageSubresourceLayout, with the ability to specify extended
inputs via chained input structures, and to return extended information via
chained output structures.

It is legal to call fname:vkGetImageSubresourceLayout2KHR with an
pname:image created with pname:tiling equal to
ename:VK_IMAGE_TILING_OPTIMAL, but the members of
slink:VkSubresourceLayout2KHR::pname:subresourceLayout will have undefined:
values in this case.

[NOTE]
====
Structures chained from slink:VkImageSubresource2KHR::pname:pNext will also
be updated when pname:tiling is equal to ename:VK_IMAGE_TILING_OPTIMAL.
====

:imageparam: image

.Valid Usage
****
include::{chapters}/commonvalidity/get_image_subresource_layout_common.adoc[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
  * [[VUID-vkGetImageSubresourceLayout2KHR-image-09434]]
    If pname:image was created with the
    ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID
    external memory handle type, then pname:image must: be bound to memory
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-vkGetImageSubresourceLayout2KHR-tiling-09435]]
    If the pname:tiling of the pname:image is
    ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the pname:aspectMask
    member of pname:pSubresource must: be
    `VK_IMAGE_ASPECT_MEMORY_PLANE__{ibit}__BIT_EXT` and the index _i_ must:
    be less than the
    slink:VkDrmFormatModifierPropertiesEXT::pname:drmFormatModifierPlaneCount
    associated with the image's pname:format and
    slink:VkImageDrmFormatModifierPropertiesEXT::pname:drmFormatModifier
endif::VK_EXT_image_drm_format_modifier[]
****

include::{generated}/validity/protos/vkGetImageSubresourceLayout2KHR.adoc[]
--

[open,refpage='VkImageSubresource2KHR',desc='Structure specifying an image subresource',type='structs',alias='VkImageSubresource2EXT']
--
The sname:VkImageSubresource2KHR structure is defined as:

include::{generated}/api/structs/VkImageSubresource2KHR.adoc[]

ifdef::VK_KHR_maintenance5[]
ifdef::VK_EXT_image_compression_control,VK_EXT_host_image_copy[or the equivalent]
endif::VK_KHR_maintenance5[]

ifdef::VK_EXT_image_compression_control,VK_EXT_host_image_copy[]
include::{generated}/api/structs/VkImageSubresource2EXT.adoc[]
endif::VK_EXT_image_compression_control,VK_EXT_host_image_copy[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:imageSubresource is a slink:VkImageSubresource structure.

include::{generated}/validity/structs/VkImageSubresource2KHR.adoc[]
--

[open,refpage='VkSubresourceLayout2KHR',desc='Structure specifying subresource layout',type='structs',alias='VkSubresourceLayout2EXT']
--
Information about the layout of the image subresource is returned in a
sname:VkSubresourceLayout2KHR structure:

ifdef::VK_KHR_maintenance5[]
include::{generated}/api/structs/VkSubresourceLayout2KHR.adoc[]
endif::VK_KHR_maintenance5[]

ifdef::VK_KHR_maintenance5[]
ifdef::VK_EXT_image_compression_control,VK_EXT_host_image_copy[or the equivalent]
endif::VK_KHR_maintenance5[]

ifdef::VK_EXT_image_compression_control,VK_EXT_host_image_copy[]

ifndef::VK_KHR_maintenance5[]
Information about the layout of the image subresource is returned in a
sname:VkSubresourceLayout2EXT structure:
endif::VK_KHR_maintenance5[]

include::{generated}/api/structs/VkSubresourceLayout2EXT.adoc[]
endif::VK_EXT_image_compression_control,VK_EXT_host_image_copy[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:subresourceLayout is a slink:VkSubresourceLayout structure.

include::{generated}/validity/structs/VkSubresourceLayout2KHR.adoc[]
--

ifdef::VK_EXT_host_image_copy[]
[open,refpage='VkSubresourceHostMemcpySizeEXT',desc='Memory size needed to copy to or from an image on the host with VK_HOST_IMAGE_COPY_MEMCPY_EXT',type='structs']
--
To query the memory size needed to copy to or from an image using
flink:vkCopyMemoryToImageEXT or flink:vkCopyImageToMemoryEXT when the
ename:VK_HOST_IMAGE_COPY_MEMCPY_EXT flag is specified, add a
slink:VkSubresourceHostMemcpySizeEXT structure to the pname:pNext chain of
the slink:VkSubresourceLayout2EXT structure in a call to
flink:vkGetImageSubresourceLayout2EXT.

The sname:VkSubresourceHostMemcpySizeEXT structure is defined as:

include::{generated}/api/structs/VkSubresourceHostMemcpySizeEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:size is the size in bytes of the image subresource.

include::{generated}/validity/structs/VkSubresourceHostMemcpySizeEXT.adoc[]
--
endif::VK_EXT_host_image_copy[]
endif::VK_KHR_maintenance5,VK_EXT_image_compression_control,VK_EXT_host_image_copy[]

ifdef::VK_KHR_maintenance5[]
[open,refpage='vkGetDeviceImageSubresourceLayoutKHR',desc='Retrieve information about an image subresource without an image object',type='protos']
--
To query the memory layout of an image subresource, without an image object,
call:

include::{generated}/api/protos/vkGetDeviceImageSubresourceLayoutKHR.adoc[]

  * pname:device is the logical device that owns the image.
  * pname:pInfo is a pointer to a slink:VkDeviceImageSubresourceInfoKHR
    structure containing parameters required for the subresource layout
    query.
  * pname:pLayout is a pointer to a slink:VkSubresourceLayout2KHR structure
    in which the layout is returned.

fname:vkGetDeviceImageSubresourceLayoutKHR behaves similarly to
flink:vkGetImageSubresourceLayout2KHR, but uses a slink:VkImageCreateInfo
structure to specify the image rather than a slink:VkImage object.

include::{generated}/validity/protos/vkGetDeviceImageSubresourceLayoutKHR.adoc[]
--

[open,refpage='VkDeviceImageSubresourceInfoKHR',desc='Image creation information for querying subresource layout',type='structs']
--
:refpage: VkDeviceImageSubresourceInfoKHR

The sname:VkDeviceImageSubresourceInfoKHR structure is defined as:

include::{generated}/api/structs/VkDeviceImageSubresourceInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pCreateInfo is a pointer to a slink:VkImageCreateInfo structure
    containing parameters affecting creation of the image to query.
  * pname:pSubresource pSubresource is a pointer to a
    slink:VkImageSubresource2KHR structure selecting a specific image
    subresource for the query.

:imageparam: pCreateInfo

.Valid Usage
****
include::{chapters}/commonvalidity/get_image_subresource_layout_common.adoc[]
****

include::{generated}/validity/structs/VkDeviceImageSubresourceInfoKHR.adoc[]
--
endif::VK_KHR_maintenance5[]

ifdef::VK_EXT_image_drm_format_modifier[]
[open,refpage='vkGetImageDrmFormatModifierPropertiesEXT',desc='Returns an image\'s DRM format modifier',type='protos']
--
:refpage: vkGetImageDrmFormatModifierPropertiesEXT

If an image was created with ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,
then the image has a <<glossary-drm-format-modifier,Linux DRM format
modifier>>.
To query the _modifier_, call:

include::{generated}/api/protos/vkGetImageDrmFormatModifierPropertiesEXT.adoc[]

  * pname:device is the logical device that owns the image.
  * pname:image is the queried image.
  * pname:pProperties is a pointer to a
    slink:VkImageDrmFormatModifierPropertiesEXT structure in which
    properties of the image's _DRM format modifier_ are returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkGetImageDrmFormatModifierPropertiesEXT-image-02272]]
    pname:image must: have been created with <<VkImageCreateInfo,
    pname:tiling>> equal to ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT
****

include::{generated}/validity/protos/vkGetImageDrmFormatModifierPropertiesEXT.adoc[]
--

[open,refpage='VkImageDrmFormatModifierPropertiesEXT',desc='Properties of an image\'s Linux DRM format modifier',type='structs']
--
The slink:VkImageDrmFormatModifierPropertiesEXT structure is defined as:

include::{generated}/api/structs/VkImageDrmFormatModifierPropertiesEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:drmFormatModifier returns the image's
    <<glossary-drm-format-modifier,Linux DRM format modifier>>.

If the pname:image was created with
slink:VkImageDrmFormatModifierListCreateInfoEXT, then the returned
pname:drmFormatModifier must: belong to the list of modifiers provided at
time of image creation in
slink:VkImageDrmFormatModifierListCreateInfoEXT::pname:pDrmFormatModifiers.
If the pname:image was created with
slink:VkImageDrmFormatModifierExplicitCreateInfoEXT, then the returned
pname:drmFormatModifier must: be the modifier provided at time of image
creation in
slink:VkImageDrmFormatModifierExplicitCreateInfoEXT::pname:drmFormatModifier.

include::{generated}/validity/structs/VkImageDrmFormatModifierPropertiesEXT.adoc[]
--
endif::VK_EXT_image_drm_format_modifier[]

[open,refpage='vkDestroyImage',desc='Destroy an image object',type='protos']
--
To destroy an image, call:

include::{generated}/api/protos/vkDestroyImage.adoc[]

  * pname:device is the logical device that destroys the image.
  * pname:image is the image to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyImage-image-01000]]
    All submitted commands that refer to pname:image, either directly or via
    a sname:VkImageView, must: have completed execution
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkDestroyImage-image-01001]]
    If sname:VkAllocationCallbacks were provided when pname:image was
    created, a compatible set of callbacks must: be provided here
  * [[VUID-vkDestroyImage-image-01002]]
    If no sname:VkAllocationCallbacks were provided when pname:image was
    created, pname:pAllocator must: be `NULL`
endif::VKSC_VERSION_1_0[]
ifdef::VK_KHR_swapchain[]
  * [[VUID-vkDestroyImage-image-04882]]
    pname:image must: not have been acquired from
    flink:vkGetSwapchainImagesKHR
endif::VK_KHR_swapchain[]
****

include::{generated}/validity/protos/vkDestroyImage.adoc[]
--


[[resources-image-format-features]]
=== Image Format Features

Valid uses of a slink:VkImage may: depend on the image's _format features_,
defined below.
Such constraints are documented in the affected valid usage statement.

  * If the image was created with ename:VK_IMAGE_TILING_LINEAR, then its set
    of _format features_ is the value of
    slink:VkFormatProperties::pname:linearTilingFeatures found by calling
    flink:vkGetPhysicalDeviceFormatProperties on the same pname:format as
    slink:VkImageCreateInfo::pname:format.
  * If the image was created with ename:VK_IMAGE_TILING_OPTIMAL,
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
    but without an
    <<memory-external-android-hardware-buffer-external-formats,Android
    hardware buffer external format>>,
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
ifndef::VK_ANDROID_external_memory_android_hardware_buffer[]
    but without a
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
    or a
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
    <<memory-external-screen-buffer-external-formats,QNX Screen Buffer
    external format>>
endif::VK_QNX_external_memory_screen_buffer[]
ifdef::VK_FUCHSIA_buffer_collection[]
ifndef::VK_ANDROID_external_memory_android_hardware_buffer[]
    but without an
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
    or an
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
    slink:VkBufferCollectionImageCreateInfoFUCHSIA,
endif::VK_FUCHSIA_buffer_collection[]
    then its set of _format features_ is the value of
    slink:VkFormatProperties::pname:optimalTilingFeatures found by calling
    flink:vkGetPhysicalDeviceFormatProperties on the same pname:format as
    slink:VkImageCreateInfo::pname:format.
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
  * If the image was created with an
    <<memory-external-android-hardware-buffer-external-formats,Android
    hardware buffer external format>>, then its set of _format features_ is
    the value of
    slink:VkAndroidHardwareBufferFormatPropertiesANDROID::pname:formatFeatures
    found by calling flink:vkGetAndroidHardwareBufferPropertiesANDROID on
    the Android hardware buffer that was imported to the
    slink:VkDeviceMemory to which the image is bound.
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
  * If the image was created with an
    <<memory-external-screen-buffer-external-formats,QNX Screen buffer
    external format>>, then its set of _format features_ is the value of
    slink:VkScreenBufferFormatPropertiesQNX::pname:formatFeatures found by
    calling flink:vkGetScreenBufferPropertiesQNX on the QNX Screen buffer
    that was imported to the slink:VkDeviceMemory to which the image is
    bound.
endif::VK_QNX_external_memory_screen_buffer[]
ifdef::VK_EXT_image_drm_format_modifier[]
  * If the image was created with
    ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then:
  ** The image's DRM format modifier is the value of
     slink:VkImageDrmFormatModifierPropertiesEXT::pname:drmFormatModifier
     found by calling flink:vkGetImageDrmFormatModifierPropertiesEXT.
  ** Let
     slink:VkDrmFormatModifierPropertiesListEXT::pname:pDrmFormatModifierProperties
     be the array found by calling
     flink:vkGetPhysicalDeviceFormatProperties2 on the same pname:format as
     slink:VkImageCreateInfo::pname:format.
  ** Let `VkDrmFormatModifierPropertiesEXT prop` be the array element whose
     pname:drmFormatModifier member is the value of the image's DRM format
     modifier.
  ** Then the image's set of _format features_ is the value of
     `prop`::pname:drmFormatModifierTilingFeatures.
endif::VK_EXT_image_drm_format_modifier[]


ifdef::VK_NV_corner_sampled_image[]
[[resources-images-corner-sampled]]
=== Corner-Sampled Images

A _corner-sampled image_ is an image where unnormalized texel coordinates
are centered on integer values rather than half-integer values.

A corner-sampled image has a number of differences compared to conventional
texture image:

  * Texels are centered on integer coordinates.
    See <<textures-unnormalized-to-integer, Unnormalized Texel Coordinate
    Operations>>
  * Normalized coordinates are scaled using [eq]#coord {times} (dim - 1)#
    rather than [eq]#coord {times} dim#, where dim is the size of one
    dimension of the image.
    See <<textures-normalized-to-unnormalized, normalized texel coordinate
    transform>>.
  * Partial derivatives are scaled using [eq]#coord {times} (dim - 1)#
    rather than [eq]#coord {times} dim#.
    See <<textures-scale-factor,Scale Factor Operation>>.
  * Calculation of the next higher LOD size goes according to
    [eq]#{lceil}dim / 2{rceil}# rather than [eq]#{lfloor}dim / 2{rfloor}#.
    See <<resources-image-mip-level-sizing,Image Mip Level Sizing>>.
  * The minimum level size is 2x2 for 2D images and 2x2x2 for 3D images.
    See <<resources-image-mip-level-sizing,Image Mip Level Sizing>>.

Corner-sampling is only supported for 2D and 3D images.
When sampling a corner-sampled image, the sampler addressing mode must: be
ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
Corner-sampled images are not supported as cube maps or depth/stencil
images.
endif::VK_NV_corner_sampled_image[]


[[resources-image-mip-level-sizing]]
=== Image Mip Level Sizing

A _complete mipmap chain_ is the full set of mip levels, from the largest
mip level provided, down to the _minimum mip level size_.


==== Conventional Images

For conventional images, the dimensions of each successive mip level,
[eq]#n+1#, are:

  {empty}:: [eq]#pname:width~n+1~ = max({lfloor}pname:width~n~/2{rfloor},
            1)#
  {empty}:: [eq]#pname:height~n+1~ = max({lfloor}pname:height~n~/2{rfloor},
            1)#
  {empty}:: [eq]#pname:depth~n+1~ = max({lfloor}pname:depth~n~/2{rfloor},
            1)#

where [eq]#pname:width~n~#, [eq]#pname:height~n~#, and [eq]#pname:depth~n~#
are the dimensions of the next larger mip level, [eq]#n#.

The minimum mip level size is:

  * 1 for one-dimensional images,
  * 1x1 for two-dimensional images, and
  * 1x1x1 for three-dimensional images.

The number of levels in a complete mipmap chain is:

  {empty}:: [eq]#{lfloor}log~2~(max(pname:width~0~, pname:height~0~,
            pname:depth~0~)){rfloor} {plus} 1#

where [eq]#pname:width~0~#, [eq]#pname:height~0~#, and [eq]#pname:depth~0~#
are the dimensions of the largest (most detailed) mip level, `0`.


ifdef::VK_NV_corner_sampled_image[]
==== Corner-Sampled Images

For corner-sampled images, the dimensions of each successive mip level,
[eq]#n+1#, are:

  {empty}:: [eq]#pname:width~n+1~ = max({lceil}pname:width~n~/2{rceil}, 2)#
  {empty}:: [eq]#pname:height~n+1~ = max({lceil}pname:height~n~/2{rceil},
            2)#
  {empty}:: [eq]#pname:depth~n+1~ = max({lceil}pname:depth~n~/2{rceil}, 2)#

where [eq]#pname:width~n~#, [eq]#pname:height~n~#, and [eq]#pname:depth~n~#
are the dimensions of the next larger mip level, [eq]#n#.

The minimum mip level size is:

  * 2x2 for two-dimensional images, and
  * 2x2x2 for three-dimensional images.

The number of levels in a complete mipmap chain is:

  {empty}:: [eq]#{lceil}log~2~(max(pname:width~0~, pname:height~0~,
            pname:depth~0~)){rceil}#

where [eq]#pname:width~0~#, [eq]#pname:height~0~#, and [eq]#pname:depth~0~#
are the dimensions of the largest (most detailed) mip level, `0`.
endif::VK_NV_corner_sampled_image[]


[[resources-image-layouts]]
== Image Layouts

Images are stored in implementation-dependent opaque layouts in memory.
Each layout has limitations on what kinds of operations are supported for
image subresources using the layout.
At any given time, the data representing an image subresource in memory
exists in a particular layout which is determined by the most recent layout
transition that was performed on that image subresource.
Applications have control over which layout each image subresource uses, and
can: transition an image subresource from one layout to another.
Transitions can: happen with an image memory barrier, included as part of a
flink:vkCmdPipelineBarrier or a flink:vkCmdWaitEvents command buffer command
(see <<synchronization-image-memory-barriers>>), or as part of a subpass
dependency within a render pass (see sname:VkSubpassDependency).

Image layout is per-image subresource.
Separate image subresources of the same image can: be in different layouts
at the same time, with the exception that depth and stencil aspects of a
given image subresource can: only be in different layouts if the
<<features-separateDepthStencilLayouts, pname:separateDepthStencilLayouts>>
feature is enabled.

[NOTE]
====
Each layout may: offer optimal performance for a specific usage of image
memory.
For example, an image with a layout of
ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL may: provide optimal
performance for use as a color attachment, but be unsupported for use in
transfer commands.
Applications can: transition an image subresource from one layout to another
in order to achieve optimal performance when the image subresource is used
for multiple kinds of operations.
After initialization, applications need not use any layout other than the
general layout, though this may: produce suboptimal performance on some
implementations.
====

Upon creation, all image subresources of an image are initially in the same
layout, where that layout is selected by the
sname:VkImageCreateInfo::pname:initialLayout member.
The pname:initialLayout must: be either ename:VK_IMAGE_LAYOUT_UNDEFINED or
ename:VK_IMAGE_LAYOUT_PREINITIALIZED.
If it is ename:VK_IMAGE_LAYOUT_PREINITIALIZED, then the image data can: be
preinitialized by the host while using this layout, and the transition away
from this layout will preserve that data.
If it is ename:VK_IMAGE_LAYOUT_UNDEFINED, then the contents of the data are
considered to be undefined:, and the transition away from this layout is not
guaranteed to preserve that data.
For either of these initial layouts, any image subresources must: be
transitioned to another layout before they are accessed by the device.

Host access to image memory is only well-defined for
<<glossary-linear-resource,linear>> images and for image subresources of
those images which are currently in either the
ename:VK_IMAGE_LAYOUT_PREINITIALIZED or ename:VK_IMAGE_LAYOUT_GENERAL
layout.
Calling flink:vkGetImageSubresourceLayout for a linear image returns a
subresource layout mapping that is valid for either of those image layouts.

[open,refpage='VkImageLayout',desc='Layout of image and image subresources',type='enums']
--
The set of image layouts consists of:

include::{generated}/api/enums/VkImageLayout.adoc[]

The type(s) of device access supported by each layout are:

  * ename:VK_IMAGE_LAYOUT_UNDEFINED specifies that the layout is unknown.
    Image memory cannot: be transitioned into this layout.
    This layout can: be used as the pname:initialLayout member of
    slink:VkImageCreateInfo.
    This layout can: be used in place of the current image layout in a
    layout transition, but doing so will cause the contents of the image's
    memory to be undefined:.
  * ename:VK_IMAGE_LAYOUT_PREINITIALIZED specifies that an image's memory is
    in a defined layout and can: be populated by data, but that it has not
    yet been initialized by the driver.
    Image memory cannot: be transitioned into this layout.
    This layout can: be used as the pname:initialLayout member of
    slink:VkImageCreateInfo.
    This layout is intended to be used as the initial layout for an image
    whose contents are written by the host, and hence the data can: be
    written to memory immediately, without first executing a layout
    transition.
    Currently, ename:VK_IMAGE_LAYOUT_PREINITIALIZED is only useful with
    <<glossary-linear-resource,linear>> images because there is not a
    standard layout defined for ename:VK_IMAGE_TILING_OPTIMAL images.
  * ename:VK_IMAGE_LAYOUT_GENERAL supports all types of device access.
ifdef::VK_VERSION_1_3,VK_KHR_synchronization2[]
  * ename:VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL specifies a layout that must:
    only be used with attachment accesses in the graphics pipeline.
  * ename:VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL specifies a layout allowing read
    only access as an attachment, or in shaders as a sampled image, combined
    image/sampler, or input attachment.
endif::VK_VERSION_1_3,VK_KHR_synchronization2[]
  * ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL must: only be used as a
    color or resolve attachment in a sname:VkFramebuffer.
    This layout is valid only for image subresources of images created with
    the ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT usage bit enabled.
  * ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL specifies a
    layout for both the depth and stencil aspects of a depth/stencil format
    image allowing read and write access as a depth/stencil attachment.
ifdef::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
    It is equivalent to ename:VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL and
    ename:VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL.
endif::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
  * ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL specifies a layout
    for both the depth and stencil aspects of a depth/stencil format image
    allowing read only access as a depth/stencil attachment or in shaders as
    a sampled image, combined image/sampler, or input attachment.
ifdef::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
    It is equivalent to ename:VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL and
    ename:VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL.
endif::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
  * ename:VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL
    specifies a layout for depth/stencil format images allowing read and
    write access to the stencil aspect as a stencil attachment, and read
    only access to the depth aspect as a depth attachment or in shaders as a
    sampled image, combined image/sampler, or input attachment.
ifdef::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
    It is equivalent to ename:VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL and
    ename:VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL.
endif::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
  * ename:VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL
    specifies a layout for depth/stencil format images allowing read and
    write access to the depth aspect as a depth attachment, and read only
    access to the stencil aspect as a stencil attachment or in shaders as a
    sampled image, combined image/sampler, or input attachment.
ifdef::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
    It is equivalent to ename:VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL and
    ename:VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL.
endif::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
ifdef::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
  * ename:VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL specifies a layout for
    the depth aspect of a depth/stencil format image allowing read and write
    access as a depth attachment.
  * ename:VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL specifies a layout for the
    depth aspect of a depth/stencil format image allowing read-only access
    as a depth attachment or in shaders as a sampled image, combined
    image/sampler, or input attachment.
  * ename:VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL specifies a layout for
    the stencil aspect of a depth/stencil format image allowing read and
    write access as a stencil attachment.
  * ename:VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL specifies a layout for
    the stencil aspect of a depth/stencil format image allowing read-only
    access as a stencil attachment or in shaders as a sampled image,
    combined image/sampler, or input attachment.
endif::VK_VERSION_1_2,VK_KHR_separate_depth_stencil_layouts[]
  * ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL specifies a layout
    allowing read-only access in a shader as a sampled image, combined
    image/sampler, or input attachment.
    This layout is valid only for image subresources of images created with
    the ename:VK_IMAGE_USAGE_SAMPLED_BIT or
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT usage bits enabled.
  * ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL must: only be used as a
    source image of a transfer command (see the definition of
    <<synchronization-pipeline-stages-transfer,
    ename:VK_PIPELINE_STAGE_TRANSFER_BIT>>).
    This layout is valid only for image subresources of images created with
    the ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage bit enabled.
  * ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL must: only be used as a
    destination image of a transfer command.
    This layout is valid only for image subresources of images created with
    the ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT usage bit enabled.
ifdef::VK_KHR_swapchain[]
  * ename:VK_IMAGE_LAYOUT_PRESENT_SRC_KHR must: only be used for presenting
    a presentable image for display.
ifdef::VK_KHR_shared_presentable_image[]
  * ename:VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR is valid only for shared
    presentable images, and must: be used for any usage the image supports.
endif::VK_KHR_shared_presentable_image[]
endif::VK_KHR_swapchain[]
ifdef::VK_KHR_fragment_shading_rate,VK_NV_shading_rate_image[]
  * ename:VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR must:
    only be used as a
ifdef::VK_KHR_fragment_shading_rate[]
    <<primsrast-fragment-shading-rate-attachment, fragment shading rate
    attachment>>
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_KHR_fragment_shading_rate,VK_NV_shading_rate_image[or]
ifdef::VK_NV_shading_rate_image[]
    <<primsrast-shading-rate-image, shading rate image>>.
endif::VK_NV_shading_rate_image[]
    This layout is valid only for image subresources of images created with
    the ename:VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR usage
    bit enabled.
endif::VK_KHR_fragment_shading_rate,VK_NV_shading_rate_image[]
ifdef::VK_EXT_fragment_density_map[]
  * ename:VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT must: only be
    used as a fragment density map attachment in a sname:VkRenderPass.
    This layout is valid only for image subresources of images created with
    the ename:VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT usage bit enabled.
endif::VK_EXT_fragment_density_map[]
ifdef::VK_KHR_video_decode_queue[]
  * ename:VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR must: only be used as a
    <<decode-output-picture,decode output picture>> in a
    <<video-decode-operations,video decode operation>>.
    This layout is valid only for image subresources of images created with
    the ename:VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR usage bit enabled.
  * ename:VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR is reserved for future use.
  * ename:VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR must: only be used as an
    output <<reconstructed-picture,reconstructed picture>> or an input
    <<reference-picture,reference picture>> in a <<video-decode-operations,
    video decode operation>>.
    This layout is valid only for image subresources of images created with
    the ename:VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR usage bit enabled.
endif::VK_KHR_video_decode_queue[]
ifdef::VK_KHR_video_encode_queue[]
  * ename:VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR is reserved for future use.
  * ename:VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR must: only be used as an
    <<encode-input-picture,encode input picture>> in a
    <<video-encode-operations,video encode operation>>.
    This layout is valid only for image subresources of images created with
    the ename:VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR usage bit enabled.
  * ename:VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR must: only be used as an
    output <<reconstructed-picture,reconstructed picture>> or an input
    <<reference-picture,reference picture>> in a <<video-encode-operations,
    video encode operation>>.
    This layout is valid only for image subresources of images created with
    the ename:VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR usage bit enabled.
endif::VK_KHR_video_encode_queue[]
ifdef::VK_EXT_attachment_feedback_loop_layout[]
  * ename:VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT must: only be
    used as either a color attachment or depth/stencil attachment in a
    sname:VkFramebuffer and/or read-only access in a shader as a sampled
    image, combined image/sampler, or input attachment.
    This layout is valid only for image subresources of images created with
    the ename:VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT usage bit
    enabled and either the ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT or
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT and either the
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT or
    ename:VK_IMAGE_USAGE_SAMPLED_BIT usage bits enabled.
endif::VK_EXT_attachment_feedback_loop_layout[]
ifdef::VK_KHR_dynamic_rendering_local_read[]
  * ename:VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR must: only be used as
    either a storage image, or a color or depth/stencil attachment and an
    input attachment.
    This layout is valid only for image subresources of images created with
    either ename:VK_IMAGE_USAGE_STORAGE_BIT, or both
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT and either of
    ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT or
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT.
endif::VK_KHR_dynamic_rendering_local_read[]

The layout of each image subresource is not a state of the image subresource
itself, but is rather a property of how the data in memory is organized, and
thus for each mechanism of accessing an image in the API the application
must: specify a parameter or structure member that indicates which image
layout the image subresource(s) are considered to be in when the image will
be accessed.
For transfer commands, this is a parameter to the command (see <<clears>>
and <<copies>>).
For use as a framebuffer attachment, this is a member in the substructures
of the slink:VkRenderPassCreateInfo (see <<renderpass,Render Pass>>).
For use in a descriptor set, this is a member in the
sname:VkDescriptorImageInfo structure (see <<descriptorsets-updates>>).
--


[[resources-image-layouts-matching-rule]]
=== Image Layout Matching Rules

At the time that any command buffer command accessing an image executes on
any queue, the layouts of the image subresources that are accessed must: all
match exactly the layout specified via the API controlling those
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[accesses,]
ifndef::VK_VERSION_1_1,VK_KHR_maintenance2[accesses.]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
except in case of accesses to an image with a depth/stencil format performed
through descriptors referring to only a single aspect of the image, where
the following relaxed matching rules apply:

  * Descriptors referring just to the depth aspect of a depth/stencil image
    only need to match in the image layout of the depth aspect, thus
    ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL and
    ename:VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL are
    considered to match.
  * Descriptors referring just to the stencil aspect of a depth/stencil
    image only need to match in the image layout of the stencil aspect, thus
    ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL and
    ename:VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL are
    considered to match.
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]

When performing a layout transition on an image subresource, the old layout
value must: either equal the current layout of the image subresource (at the
time the transition executes), or else be ename:VK_IMAGE_LAYOUT_UNDEFINED
(implying that the contents of the image subresource need not be preserved).
The new layout used in a transition must: not be
ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED.

ifdef::VK_EXT_sample_locations[]

The image layout of each image subresource of a depth/stencil image created
with ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT is
dependent on the last sample locations used to render to the image
subresource as a depth/stencil attachment, thus applications must: provide
the same sample locations that were last used to render to the given image
subresource whenever a layout transition of the image subresource happens,
otherwise the contents of the depth aspect of the image subresource become
undefined:.

In addition, depth reads from a depth/stencil attachment referring to an
image subresource range of a depth/stencil image created with
ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT using
different sample locations than what have been last used to perform depth
writes to the image subresources of the same image subresource range return
undefined: values.

Similarly, depth writes to a depth/stencil attachment referring to an image
subresource range of a depth/stencil image created with
ename:VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT using
different sample locations than what have been last used to perform depth
writes to the image subresources of the same image subresource range make
the contents of the depth aspect of those image subresources undefined:.

endif::VK_EXT_sample_locations[]


[[resources-image-views]]
== Image Views

[open,refpage='VkImageView',desc='Opaque handle to an image view object',type='handles']
--
Image objects are not directly accessed by pipeline shaders for reading or
writing image data.
Instead, _image views_ representing contiguous ranges of the image
subresources and containing additional metadata are used for that purpose.
Views must: be created on images of compatible types, and must: represent a
valid subset of image subresources.

Image views are represented by sname:VkImageView handles:

include::{generated}/api/handles/VkImageView.adoc[]
--

[open,refpage='VK_REMAINING_ARRAY_LAYERS',desc='Sentinel for all remaining array layers',type='consts']
--
ename:VK_REMAINING_ARRAY_LAYERS is a special constant value used for image
views to indicate that all remaining array layers in an image after the base
layer should be included in the view.

include::{generated}/api/enums/VK_REMAINING_ARRAY_LAYERS.adoc[]
--

[open,refpage='VK_REMAINING_MIP_LEVELS',desc='Sentinel for all remaining mipmap levels',type='consts']
--
ename:VK_REMAINING_MIP_LEVELS is a special constant value used for image
views to indicate that all remaining mipmap levels in an image after the
base level should be included in the view.

include::{generated}/api/enums/VK_REMAINING_MIP_LEVELS.adoc[]
--

[open,refpage='VkImageViewType',desc='Image view types',type='enums']
--
The types of image views that can: be created are:

include::{generated}/api/enums/VkImageViewType.adoc[]
--

[open,refpage='vkCreateImageView',desc='Create an image view from an existing image',type='protos']
--
:refpage: vkCreateImageView
:objectnameplural: image views
:objectnamecamelcase: imageView
:objectnamestruct: VkDeviceObjectReservationCreateInfo
:objectcount: 1

To create an image view, call:

include::{generated}/api/protos/vkCreateImageView.adoc[]

  * pname:device is the logical device that creates the image view.
  * pname:pCreateInfo is a pointer to a sname:VkImageViewCreateInfo
    structure containing parameters to be used to create the image view.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pView is a pointer to a slink:VkImageView handle in which the
    resulting image view object is returned.

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
  * [[VUID-vkCreateImageView-device-09667]]
    pname:device must: support at least one queue family with one of the
ifdef::VK_KHR_video_encode_queue[]
    ename:VK_QUEUE_VIDEO_ENCODE_BIT_KHR,
endif::VK_KHR_video_encode_queue[]
ifdef::VK_KHR_video_decode_queue[]
    ename:VK_QUEUE_VIDEO_DECODE_BIT_KHR,
endif::VK_KHR_video_decode_queue[]
    ename:VK_QUEUE_COMPUTE_BIT, or ename:VK_QUEUE_GRAPHICS_BIT capabilities
  * [[VUID-vkCreateImageView-image-09179]]
    slink:VkImageViewCreateInfo::pname:image must: have been created from
    pname:device
ifdef::VKSC_VERSION_1_0[]
include::{chapters}/commonvalidity/memory_reservation_request_count_common.adoc[]
  * [[VUID-vkCreateImageView-subresourceRange-05063]]
    If slink:VkImageViewCreateInfo::pname:subresourceRange.layerCount is not
    ename:VK_REMAINING_ARRAY_LAYERS and is greater than `1`, or if
    slink:VkImageViewCreateInfo::pname:subresourceRange.layerCount is
    ename:VK_REMAINING_ARRAY_LAYERS and the remaining number of layers in
    slink:VkImageViewCreateInfo::pname:image is greater than `1`, the number
    of image views with more than one array layer currently allocated from
    pname:device plus `1` must: be less than or equal to the total number of
    image views requested via
    slink:VkDeviceObjectReservationCreateInfo::pname:layeredImageViewRequestCount
    specified when pname:device was created
endif::VKSC_VERSION_1_0[]
****

include::{generated}/validity/protos/vkCreateImageView.adoc[]
--

[open,refpage='VkImageViewCreateInfo',desc='Structure specifying parameters of a newly created image view',type='structs']
--
The sname:VkImageViewCreateInfo structure is defined as:

include::{generated}/api/structs/VkImageViewCreateInfo.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkImageViewCreateFlagBits specifying
    additional parameters of the image view.
  * pname:image is a slink:VkImage on which the view will be created.
  * pname:viewType is a elink:VkImageViewType value specifying the type of
    the image view.
  * pname:format is a elink:VkFormat specifying the format and type used to
    interpret texel blocks of the image.
  * pname:components is a slink:VkComponentMapping structure specifying a
    remapping of color components (or of depth or stencil components after
    they have been converted into color components).
  * pname:subresourceRange is a slink:VkImageSubresourceRange structure
    selecting the set of mipmap levels and array layers to be accessible to
    the view.

[[resources-image-inherited-usage]]
Some of the pname:image creation parameters are inherited by the view.
In particular, image view creation inherits the implicit parameter
pname:usage specifying the allowed usages of the image view that, by
default, takes the value of the corresponding pname:usage parameter
specified in slink:VkImageCreateInfo at image creation time.
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
The implicit pname:usage can: be overridden by adding a
slink:VkImageViewUsageCreateInfo structure to the pname:pNext chain, but the
view usage must: be a subset of the image usage.
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
ifdef::VK_VERSION_1_2,VK_EXT_separate_stencil_usage[]
If pname:image has a depth-stencil format and was created with a
slink:VkImageStencilUsageCreateInfo structure included in the pname:pNext
chain of slink:VkImageCreateInfo, the usage is calculated based on the
pname:subresource.aspectMask provided:

  * If pname:aspectMask includes only ename:VK_IMAGE_ASPECT_STENCIL_BIT, the
    implicit pname:usage is equal to
    slink:VkImageStencilUsageCreateInfo::pname:stencilUsage.
  * If pname:aspectMask includes only ename:VK_IMAGE_ASPECT_DEPTH_BIT, the
    implicit pname:usage is equal to slink:VkImageCreateInfo::pname:usage.
  * If both aspects are included in pname:aspectMask, the implicit
    pname:usage is equal to the intersection of
    slink:VkImageCreateInfo::pname:usage and
    slink:VkImageStencilUsageCreateInfo::pname:stencilUsage.
endif::VK_VERSION_1_2,VK_EXT_separate_stencil_usage[]

ifdef::VK_EXT_image_sliced_view_of_3d[]
If pname:image is a 3D image, its Z range can: be restricted to a subset by
adding a slink:VkImageViewSlicedCreateInfoEXT to the pname:pNext chain.
endif::VK_EXT_image_sliced_view_of_3d[]

If pname:image was created with the ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT
flag,
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
and if the pname:format of the image is not
<<formats-requiring-sampler-ycbcr-conversion,multi-planar>>,
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
pname:format can: be different from the image's format, but if
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
pname:image was created without the
ename:VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag and
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
they are not equal they must: be _compatible_.
Image format compatibility is defined in the
<<formats-compatibility-classes,Format Compatibility Classes>> section.
Views of compatible formats will have the same mapping between texel
coordinates and memory locations irrespective of the pname:format, with only
the interpretation of the bit pattern changing.

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
[[image-views-plane-promotion]]
If pname:image was created with a
<<formats-requiring-sampler-ycbcr-conversion,multi-planar>> format, and the
image view's pname:aspectMask is one of ename:VK_IMAGE_ASPECT_PLANE_0_BIT,
ename:VK_IMAGE_ASPECT_PLANE_1_BIT or ename:VK_IMAGE_ASPECT_PLANE_2_BIT, the
view's aspect mask is considered to be equivalent to
ename:VK_IMAGE_ASPECT_COLOR_BIT when used as a framebuffer attachment.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

[NOTE]
====
Values intended to be used with one view format may: not be exactly
preserved when written or read through a different format.
For example, an integer value that happens to have the bit pattern of a
floating-point denorm or NaN may: be flushed or canonicalized when written
or read through a view with a floating-point format.
Similarly, a value written through a signed normalized format that has a bit
pattern exactly equal to [eq]#-2^b^# may: be changed to [eq]#-2^b^ {plus} 1#
as described in <<fundamentals-fixedfpconv,Conversion from Normalized
Fixed-Point to Floating-Point>>.
====

ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
If pname:image was created with the
ename:VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, pname:format
must: be _compatible_ with the image's format as described above; or must:
be an uncompressed format, in which case it must: be
<<formats-size-compatibility, _size-compatible_>> with the image's format.
In this case, the resulting image view's texel dimensions equal the
dimensions of the selected mip level divided by the compressed texel block
size and rounded up.
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]

The slink:VkComponentMapping pname:components member describes a remapping
from components of the image to components of the vector returned by shader
image instructions.
This remapping must: be the identity swizzle for storage image descriptors,
input attachment descriptors,
ifndef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
and framebuffer attachments.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
framebuffer attachments, and any sname:VkImageView used with a combined
image sampler that enables <<samplers-YCbCr-conversion,sampler {YCbCr}
conversion>>.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
If the image view is to be used with a sampler which supports
<<samplers-YCbCr-conversion,sampler {YCbCr} conversion>>, an _identically
defined object_ of type slink:VkSamplerYcbcrConversion to that used to
create the sampler must: be passed to flink:vkCreateImageView in a
slink:VkSamplerYcbcrConversionInfo included in the pname:pNext chain of
slink:VkImageViewCreateInfo.
Conversely, if a slink:VkSamplerYcbcrConversion object is passed to
flink:vkCreateImageView, an identically defined
slink:VkSamplerYcbcrConversion object must: be used when sampling the image.

[[image-views-requiring-sampler-ycbcr-conversion]]
If the image has a
<<formats-requiring-sampler-ycbcr-conversion,multi-planar>> pname:format,
pname:subresourceRange.aspectMask is ename:VK_IMAGE_ASPECT_COLOR_BIT, and
pname:usage includes ename:VK_IMAGE_USAGE_SAMPLED_BIT, then the pname:format
must: be identical to the image pname:format and the sampler to be used with
the image view must: enable <<samplers-YCbCr-conversion,sampler {YCbCr}
conversion>>.

ifdef::VK_KHR_video_queue[]
When such an image is used in a <<video-coding,video coding>> operation, the
<<samplers-YCbCr-conversion,sampler {YCbCr} conversion>> has no effect.
endif::VK_KHR_video_queue[]

If pname:image was created with the ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT
and the image has a
<<formats-requiring-sampler-ycbcr-conversion,multi-planar>> pname:format,
and if pname:subresourceRange.aspectMask is
ename:VK_IMAGE_ASPECT_PLANE_0_BIT, ename:VK_IMAGE_ASPECT_PLANE_1_BIT, or
ename:VK_IMAGE_ASPECT_PLANE_2_BIT, pname:format must: be
<<formats-compatible-planes,compatible>> with the corresponding plane of the
image, and the sampler to be used with the image view must: not enable
<<samplers-YCbCr-conversion,sampler {YCbCr} conversion>>.
The pname:width and pname:height of the single-plane image view must: be
derived from the multi-planar image's dimensions in the manner listed for
<<formats-compatible-planes,plane compatibility>> for the plane.

Any view of an image plane will have the same mapping between texel
coordinates and memory locations as used by the components of the color
aspect, subject to the formulae relating texel coordinates to
lower-resolution planes as described in <<textures-chroma-reconstruction,
Chroma Reconstruction>>.
That is, if an R or B plane has a reduced resolution relative to the G plane
of the multi-planar image, the image view operates using the (_u~plane~_,
_v~plane~_) unnormalized coordinates of the reduced-resolution plane, and
these coordinates access the same memory locations as the (_u~color~_,
_v~color~_) unnormalized coordinates of the color aspect for which chroma
reconstruction operations operate on the same (_u~plane~_, _v~plane~_) or
(_i~plane~_, _j~plane~_) coordinates.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

[[resources-image-views-compatibility]]
.Image type and image view type compatibility requirements
[cols="35%,50%",options="header"]
|====
| Image View Type | Compatible Image Types
| ename:VK_IMAGE_VIEW_TYPE_1D         | ename:VK_IMAGE_TYPE_1D
| ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY   | ename:VK_IMAGE_TYPE_1D
| ename:VK_IMAGE_VIEW_TYPE_2D         | ename:VK_IMAGE_TYPE_2D
ifdef::VK_VERSION_1_1,VK_KHR_maintenance1[, ename:VK_IMAGE_TYPE_3D]
| ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY   | ename:VK_IMAGE_TYPE_2D
ifdef::VK_VERSION_1_1,VK_KHR_maintenance1[, ename:VK_IMAGE_TYPE_3D]
| ename:VK_IMAGE_VIEW_TYPE_CUBE       | ename:VK_IMAGE_TYPE_2D
| ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY | ename:VK_IMAGE_TYPE_2D
| ename:VK_IMAGE_VIEW_TYPE_3D         | ename:VK_IMAGE_TYPE_3D
|====

.Valid Usage
****
  * [[VUID-VkImageViewCreateInfo-image-01003]]
    If pname:image was not created with
    ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT then pname:viewType must: not
    be ename:VK_IMAGE_VIEW_TYPE_CUBE or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
  * [[VUID-VkImageViewCreateInfo-viewType-01004]]
    If the <<features-imageCubeArray, pname:imageCubeArray>> feature is not
    enabled, pname:viewType must: not be ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
ifdef::VK_VERSION_1_1,VK_KHR_maintenance1[]
  * [[VUID-VkImageViewCreateInfo-image-06723]]
    If pname:image was created with ename:VK_IMAGE_TYPE_3D but without
    ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set then pname:viewType
    must: not be ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY
ifndef::VK_EXT_image_2d_view_of_3d[]
  * [[VUID-VkImageViewCreateInfo-image-06727]]
    If pname:image was created with ename:VK_IMAGE_TYPE_3D but without
    ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set then pname:viewType
    must: not be ename:VK_IMAGE_VIEW_TYPE_2D
endif::VK_EXT_image_2d_view_of_3d[]
ifdef::VK_EXT_image_2d_view_of_3d[]
  * [[VUID-VkImageViewCreateInfo-image-06728]]
    If pname:image was created with ename:VK_IMAGE_TYPE_3D but without
    ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT or
    ename:VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT set, then
    pname:viewType must: not be ename:VK_IMAGE_VIEW_TYPE_2D
endif::VK_EXT_image_2d_view_of_3d[]
  * [[VUID-VkImageViewCreateInfo-image-04970]]
    If pname:image was created with ename:VK_IMAGE_TYPE_3D and
    pname:viewType is ename:VK_IMAGE_VIEW_TYPE_2D or
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY then pname:subresourceRange.levelCount
    must: be 1
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkImageViewCreateInfo-image-04971]]
    If pname:image was created with ename:VK_IMAGE_TYPE_3D and
    pname:viewType is ename:VK_IMAGE_VIEW_TYPE_2D or
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY then
    slink:VkImageCreateInfo::pname:flags must: not contain any of
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, and
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT
endif::VKSC_VERSION_1_0[]
  * [[VUID-VkImageViewCreateInfo-image-04972]]
    If pname:image was created with a pname:samples value not equal to
    ename:VK_SAMPLE_COUNT_1_BIT then pname:viewType must: be either
    ename:VK_IMAGE_VIEW_TYPE_2D or ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY
endif::VK_VERSION_1_1,VK_KHR_maintenance1[]
  * [[VUID-VkImageViewCreateInfo-image-04441]]
    pname:image must: have been created with a pname:usage value containing
    at least one of the usages defined in the <<valid-imageview-imageusage,
    valid image usage>> list for image views
  * [[VUID-VkImageViewCreateInfo-None-02273]]
    The <<resources-image-view-format-features,format features>> of the
    resultant image view must: contain at least one bit
  * [[VUID-VkImageViewCreateInfo-usage-02274]]
    If pname:usage contains ename:VK_IMAGE_USAGE_SAMPLED_BIT, then the
    <<resources-image-view-format-features,format features>> of the
    resultant image view must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
  * [[VUID-VkImageViewCreateInfo-usage-02275]]
    If pname:usage contains ename:VK_IMAGE_USAGE_STORAGE_BIT, then the image
    view's <<resources-image-view-format-features,format features>> must:
    contain ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT
ifndef::VK_NV_linear_color_attachment[]
  * [[VUID-VkImageViewCreateInfo-usage-02276]]
    If pname:usage contains ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, then
    the image view's <<resources-image-view-format-features,format
    features>> must: contain ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT
endif::VK_NV_linear_color_attachment[]
ifdef::VK_NV_linear_color_attachment[]
  * [[VUID-VkImageViewCreateInfo-usage-08931]]
    If pname:usage contains ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, then
    the image view's <<resources-image-view-format-features,format
    features>> must: contain ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or
    ename:VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV
endif::VK_NV_linear_color_attachment[]
  * [[VUID-VkImageViewCreateInfo-usage-02277]]
    If pname:usage contains
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, then the image view's
    <<resources-image-view-format-features,format features>> must: contain
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
ifdef::VK_KHR_video_maintenance1[]
ifdef::VK_KHR_video_decode_queue[]
  * [[VUID-VkImageViewCreateInfo-image-08333]]
    If pname:image was created with
    ename:VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR and pname:usage
    contains ename:VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR, then the image
    view's <<resources-image-view-format-features,format features>> must:
    contain ename:VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR
  * [[VUID-VkImageViewCreateInfo-image-08334]]
    If pname:image was created with
    ename:VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR and pname:usage
    contains ename:VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR, then the image
    view's <<resources-image-view-format-features,format features>> must:
    contain ename:VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR
  * [[VUID-VkImageViewCreateInfo-image-08335]]
    If pname:image was created with
    ename:VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR, then
    pname:usage must: not include
    ename:VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR
endif::VK_KHR_video_decode_queue[]
ifdef::VK_KHR_video_encode_queue[]
  * [[VUID-VkImageViewCreateInfo-image-08336]]
    If pname:image was created with
    ename:VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR and pname:usage
    contains ename:VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR, then the image
    view's <<resources-image-view-format-features,format features>> must:
    contain ename:VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR
  * [[VUID-VkImageViewCreateInfo-image-08337]]
    If pname:image was created with
    ename:VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR and pname:usage
    contains ename:VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR, then the image
    view's <<resources-image-view-format-features,format features>> must:
    contain ename:VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR
  * [[VUID-VkImageViewCreateInfo-image-08338]]
    If pname:image was created with
    ename:VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR, then
    pname:usage must: not include
    ename:VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR
endif::VK_KHR_video_encode_queue[]
endif::VK_KHR_video_maintenance1[]
  * [[VUID-VkImageViewCreateInfo-usage-08932]]
    If pname:usage contains ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
ifdef::VK_ANDROID_external_format_resolve[]
    and any of the following is true:
  ** the <<features-externalFormatResolve, pname:externalFormatResolve>>
     feature is not enabled
  ** the <<limits-nullColorAttachmentWithExternalFormatResolve,
     pname:nullColorAttachmentWithExternalFormatResolve>> property is
     ename:VK_FALSE
  ** pname:image was created with an
     slink:VkExternalFormatANDROID::pname:externalFormat value of 0
endif::VK_ANDROID_external_format_resolve[]

+
then the image view's <<resources-image-view-format-features,format
features>> must: contain at least one of
ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or
ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
ifdef::VK_NV_linear_color_attachment[]
    or ename:VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV
endif::VK_NV_linear_color_attachment[]
  * [[VUID-VkImageViewCreateInfo-subresourceRange-01478]]
    pname:subresourceRange.baseMipLevel must: be less than the
    pname:mipLevels specified in slink:VkImageCreateInfo when pname:image
    was created
  * [[VUID-VkImageViewCreateInfo-subresourceRange-01718]]
    If pname:subresourceRange.levelCount is not
    ename:VK_REMAINING_MIP_LEVELS, [eq]#pname:subresourceRange.baseMipLevel
    {plus} pname:subresourceRange.levelCount# must: be less than or equal to
    the pname:mipLevels specified in slink:VkImageCreateInfo when
    pname:image was created
ifdef::VK_EXT_fragment_density_map[]
  * [[VUID-VkImageViewCreateInfo-image-02571]]
    If pname:image was created with pname:usage containing
    ename:VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,
    pname:subresourceRange.levelCount must: be `1`
endif::VK_EXT_fragment_density_map[]
ifndef::VK_VERSION_1_1,VK_KHR_maintenance1[]
  * [[VUID-VkImageViewCreateInfo-subresourceRange-01480]]
    pname:subresourceRange.baseArrayLayer must: be less than the
    pname:arrayLayers specified in slink:VkImageCreateInfo when pname:image
    was created
  * [[VUID-VkImageViewCreateInfo-subresourceRange-01719]]
    If pname:subresourceRange.layerCount is not
    ename:VK_REMAINING_ARRAY_LAYERS,
    [eq]#pname:subresourceRange.baseArrayLayer {plus}
    pname:subresourceRange.layerCount# must: be less than or equal to the
    pname:arrayLayers specified in slink:VkImageCreateInfo when pname:image
    was created
endif::VK_VERSION_1_1,VK_KHR_maintenance1[]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance1[]
ifndef::VK_EXT_image_2d_view_of_3d[]
  * [[VUID-VkImageViewCreateInfo-image-01482]]
    If pname:image is not a 3D image created with
    ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, or pname:viewType is
    not ename:VK_IMAGE_VIEW_TYPE_2D or ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY,
    pname:subresourceRange.baseArrayLayer must: be less than the
    pname:arrayLayers specified in slink:VkImageCreateInfo when pname:image
    was created
  * [[VUID-VkImageViewCreateInfo-subresourceRange-01483]]
    If pname:subresourceRange.layerCount is not
    ename:VK_REMAINING_ARRAY_LAYERS, pname:image is not a 3D image created
    with ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, or
    pname:viewType is not ename:VK_IMAGE_VIEW_TYPE_2D or
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY, pname:subresourceRange.layerCount
    must: be non-zero and [eq]#pname:subresourceRange.baseArrayLayer {plus}
    pname:subresourceRange.layerCount# must: be less than or equal to the
    pname:arrayLayers specified in slink:VkImageCreateInfo when pname:image
    was created
endif::VK_EXT_image_2d_view_of_3d[]
ifdef::VK_EXT_image_2d_view_of_3d[]
  * [[VUID-VkImageViewCreateInfo-image-06724]]
    If pname:image is not a 3D image created with
    ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT or
    ename:VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT set, or pname:viewType
    is not ename:VK_IMAGE_VIEW_TYPE_2D or ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY,
    pname:subresourceRange.baseArrayLayer must: be less than the
    pname:arrayLayers specified in slink:VkImageCreateInfo when pname:image
    was created
  * [[VUID-VkImageViewCreateInfo-subresourceRange-06725]]
    If pname:subresourceRange.layerCount is not
    ename:VK_REMAINING_ARRAY_LAYERS, pname:image is not a 3D image created
    with ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT or
    ename:VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT set, or pname:viewType
    is not ename:VK_IMAGE_VIEW_TYPE_2D or ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY,
    pname:subresourceRange.layerCount must: be non-zero and
    [eq]#pname:subresourceRange.baseArrayLayer {plus}
    pname:subresourceRange.layerCount# must: be less than or equal to the
    pname:arrayLayers specified in slink:VkImageCreateInfo when pname:image
    was created
endif::VK_EXT_image_2d_view_of_3d[]
  * [[VUID-VkImageViewCreateInfo-image-02724]]
    If pname:image is a 3D image created with
    ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, and pname:viewType is
    ename:VK_IMAGE_VIEW_TYPE_2D or ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY,
    pname:subresourceRange.baseArrayLayer must: be less than the depth
    computed from pname:baseMipLevel and pname:extent.depth specified in
    slink:VkImageCreateInfo when pname:image was created, according to the
    formula defined in <<resources-image-mip-level-sizing,Image Mip Level
    Sizing>>
  * [[VUID-VkImageViewCreateInfo-subresourceRange-02725]]
    If pname:subresourceRange.layerCount is not
    ename:VK_REMAINING_ARRAY_LAYERS, pname:image is a 3D image created with
    ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, and pname:viewType is
    ename:VK_IMAGE_VIEW_TYPE_2D or ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY,
    pname:subresourceRange.layerCount must: be non-zero and
    [eq]#pname:subresourceRange.baseArrayLayer {plus}
    pname:subresourceRange.layerCount# must: be less than or equal to the
    depth computed from pname:baseMipLevel and pname:extent.depth specified
    in slink:VkImageCreateInfo when pname:image was created, according to
    the formula defined in <<resources-image-mip-level-sizing,Image Mip
    Level Sizing>>
endif::VK_VERSION_1_1,VK_KHR_maintenance1[]
// The VU below comes in 4 alternate versions
// both disabled, both enabled, maintenance2 only, ycbcr only
ifndef::VK_VERSION_1_1,VK_KHR_maintenance2[]
ifndef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkImageViewCreateInfo-image-01018]]
    If pname:image was created with the
    ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, pname:format must: be
    compatible with the pname:format used to create pname:image, as defined
    in <<formats-compatibility-classes,Format Compatibility Classes>>
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
// The nested ifdefs are there in anticipation of the hoped-for day when the
// VU extractor and validation layers can handle VU with imbedded
// conditionals. They are commented out until then.
//
// If VK_VERSION_1_1,VK_KHR_maintenance2 and NOT VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
ifndef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkImageViewCreateInfo-image-01759]]
    If pname:image was created with the
    ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, but without the
    ename:VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, pname:format
    must: be compatible with the pname:format used to create pname:image, as
    defined in <<formats-compatibility-classes,Format Compatibility
    Classes>>
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
// If NOT VK_VERSION_1_1,VK_KHR_maintenance2 and VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion
ifndef::VK_VERSION_1_1,VK_KHR_maintenance2[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkImageViewCreateInfo-image-01760]]
    If pname:image was created with the
    ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, and if the pname:format
    of the pname:image is not a
    <<formats-requiring-sampler-ycbcr-conversion,multi-planar>> format,
    pname:format must: be compatible with the pname:format used to create
    pname:image, as defined in <<formats-compatibility-classes,Format
    Compatibility Classes>>
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
// If VK_VERSION_1_1,VK_KHR_maintenance2 and VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkImageViewCreateInfo-image-01761]]
    If pname:image was created with the
    ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag,
// ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
    but without the ename:VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT
    flag,
// endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
// ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
    and if the pname:format of the pname:image is not a
    <<formats-requiring-sampler-ycbcr-conversion,multi-planar>> format,
// endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
    pname:format must: be compatible with the pname:format used to create
    pname:image, as defined in <<formats-compatibility-classes,Format
    Compatibility Classes>>
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
  * [[VUID-VkImageViewCreateInfo-image-01583]]
    If pname:image was created with the
    ename:VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, pname:format
    must: be compatible with, or must: be an uncompressed format that is
    size-compatible with, the pname:format used to create pname:image
  * [[VUID-VkImageViewCreateInfo-image-07072]]
    If pname:image was created with the
    ename:VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag and
    pname:format is a non-compressed format, the pname:levelCount member of
    pname:subresourceRange must: be `1`
  * [[VUID-VkImageViewCreateInfo-image-09487]]
    If pname:image was created with the
    ename:VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag,
ifdef::VK_KHR_maintenance6[]
    the
    sname:VkPhysicalDeviceMaintenance6PropertiesKHR::pname:blockTexelViewCompatibleMultipleLayers
    property is not set to ename:VK_TRUE,
endif::VK_KHR_maintenance6[]
    and pname:format is a non-compressed format, then the pname:layerCount
    member of pname:subresourceRange must: be `1`
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
ifdef::VK_VERSION_1_2,VK_KHR_image_format_list[]
  * [[VUID-VkImageViewCreateInfo-pNext-01585]]
    If a slink:VkImageFormatListCreateInfo structure was included in the
    pname:pNext chain of the slink:VkImageCreateInfo structure used when
    creating pname:image and
    slink:VkImageFormatListCreateInfo::pname:viewFormatCount is not zero
    then pname:format must: be one of the formats in
    slink:VkImageFormatListCreateInfo::pname:pViewFormats
endif::VK_VERSION_1_2,VK_KHR_image_format_list[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkImageViewCreateInfo-image-01586]]
    If pname:image was created with the
    ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, if the pname:format of
    the pname:image is a
    <<formats-requiring-sampler-ycbcr-conversion,multi-planar>> format, and
    if pname:subresourceRange.aspectMask is one of the
    <<formats-planes-image-aspect,multi-planar aspect mask>> bits, then
    pname:format must: be compatible with the elink:VkFormat for the plane
    of the pname:image pname:format indicated by
    pname:subresourceRange.aspectMask, as defined in
    <<formats-compatible-planes>>
  * [[VUID-VkImageViewCreateInfo-subresourceRange-07818]]
    pname:subresourceRange.aspectMask must: only have at most 1 valid
    <<formats-planes-image-aspect,multi-planar aspect mask>> bit
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifndef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
// The VU below comes in an alternate version when the extension is
// enabled.
  * [[VUID-VkImageViewCreateInfo-image-01019]]
    If pname:image was not created with the
    ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, pname:format must: be
    identical to the pname:format used to create pname:image
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
// The nested ifdefs are there in anticipation of the hoped-for day when the
// VU extractor and validation layers can handle VU with imbedded
// conditionals. They are commented out until then.
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkImageViewCreateInfo-image-01762]]
    If pname:image was not created with the
    ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag,
// ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
    or if the pname:format of the pname:image is a
    <<formats-requiring-sampler-ycbcr-conversion,multi-planar>> format and
    if pname:subresourceRange.aspectMask is ename:VK_IMAGE_ASPECT_COLOR_BIT,
// endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
    pname:format must: be identical to the pname:format used to create
    pname:image
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkImageViewCreateInfo-format-06415]]
    If the image view <<image-views-requiring-sampler-ycbcr-conversion,
    requires a sampler {YCbCr} conversion>> and pname:usage contains
    ename:VK_IMAGE_USAGE_SAMPLED_BIT, then the pname:pNext chain must:
    include a slink:VkSamplerYcbcrConversionInfo structure with a conversion
    value other than dlink:VK_NULL_HANDLE
  * [[VUID-VkImageViewCreateInfo-format-04714]]
    If pname:format has a code:_422 or code:_420 suffix then pname:image
    must: have been created with a width that is a multiple of 2
  * [[VUID-VkImageViewCreateInfo-format-04715]]
    If pname:format has a code:_420 suffix then pname:image must: have been
    created with a height that is a multiple of 2
  * [[VUID-VkImageViewCreateInfo-pNext-01970]]
    If the pname:pNext chain includes a slink:VkSamplerYcbcrConversionInfo
    structure with a pname:conversion value other than dlink:VK_NULL_HANDLE,
    all members of pname:components must: have the
    <<resources-image-views-identity-mappings,identity swizzle>>
  * [[VUID-VkImageViewCreateInfo-pNext-06658]]
    If the pname:pNext chain includes a slink:VkSamplerYcbcrConversionInfo
    structure with a pname:conversion value other than dlink:VK_NULL_HANDLE,
    pname:format must: be the same used in
    slink:VkSamplerYcbcrConversionCreateInfo::pname:format
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkImageViewCreateInfo-image-01020]]
    If pname:image is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
  * [[VUID-VkImageViewCreateInfo-subResourceRange-01021]]
    pname:viewType must: be compatible with the type of pname:image as shown
    in the <<resources-image-views-compatibility,view type compatibility
    table>>
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
  * [[VUID-VkImageViewCreateInfo-image-02399]]
    If pname:image has an
    <<memory-external-android-hardware-buffer-external-formats,Android
    external format>>, pname:format must: be ename:VK_FORMAT_UNDEFINED
  * [[VUID-VkImageViewCreateInfo-image-02400]]
    If pname:image has an
    <<memory-external-android-hardware-buffer-external-formats,Android
    external format>>, the pname:pNext chain must: include a
    slink:VkSamplerYcbcrConversionInfo structure with a pname:conversion
    object created with the same external format as pname:image
  * [[VUID-VkImageViewCreateInfo-image-02401]]
    If pname:image has an
    <<memory-external-android-hardware-buffer-external-formats,Android
    external format>>, all members of pname:components must: be the
    <<resources-image-views-identity-mappings,identity swizzle>>
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
  * [[VUID-VkImageViewCreateInfo-image-08957]]
    If pname:image has an
    <<memory-external-screen-buffer-external-formats,QNX Screen external
    format>>, pname:format must: be ename:VK_FORMAT_UNDEFINED
  * [[VUID-VkImageViewCreateInfo-image-08958]]
    If pname:image has an
    <<memory-external-screen-buffer-external-formats,QNX Screen external
    format>>, the pname:pNext chain must: include a
    slink:VkSamplerYcbcrConversionInfo structure with a pname:conversion
    object created with the same external format as pname:image
  * [[VUID-VkImageViewCreateInfo-image-08959]]
    If pname:image has an
    <<memory-external-screen-buffer-external-formats,QNX Screen external
    format>>, all members of pname:components must: be the
    <<resources-image-views-identity-mappings,identity swizzle>>
endif::VK_QNX_external_memory_screen_buffer[]
ifdef::VK_KHR_fragment_shading_rate,VK_NV_shading_rate_image[]
  * [[VUID-VkImageViewCreateInfo-image-02086]]
    If pname:image was created with pname:usage containing
    ename:VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
    pname:viewType must: be ename:VK_IMAGE_VIEW_TYPE_2D or
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY
endif::VK_KHR_fragment_shading_rate,VK_NV_shading_rate_image[]
ifdef::VK_NV_shading_rate_image[]
  * [[VUID-VkImageViewCreateInfo-image-02087]]
    If the <<features-shadingRateImage, pname:shadingRateImage>> feature is
    enabled, and If pname:image was created with pname:usage containing
    ename:VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, pname:format must: be
    ename:VK_FORMAT_R8_UINT
endif::VK_NV_shading_rate_image[]
ifdef::VK_KHR_fragment_shading_rate[]
  * [[VUID-VkImageViewCreateInfo-usage-04550]]
    If the <<features-attachmentFragmentShadingRate,
    pname:attachmentFragmentShadingRate>> feature is enabled, and the
    pname:usage for the image view includes
    ename:VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, then the
    image view's <<resources-image-view-format-features,format features>>
    must: contain
    ename:VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
  * [[VUID-VkImageViewCreateInfo-usage-04551]]
    If the <<features-attachmentFragmentShadingRate,
    pname:attachmentFragmentShadingRate>> feature is enabled, the
    pname:usage for the image view includes
    ename:VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, and
    <<limits-layeredShadingRateAttachments,
    pname:layeredShadingRateAttachments>> is ename:VK_FALSE,
    pname:subresourceRange.layerCount must: be `1`
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_EXT_fragment_density_map[]
  * [[VUID-VkImageViewCreateInfo-flags-02572]]
    If the <<features-fragmentDensityMapDynamic,
    pname:fragmentDensityMapDynamic>> feature is not enabled, pname:flags
    must: not contain
    ename:VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT
ifdef::VK_EXT_fragment_density_map2[]
  * [[VUID-VkImageViewCreateInfo-flags-03567]]
    If the <<features-fragmentDensityMapDeferred,
    pname:fragmentDensityMapDeferred>> feature is not enabled, pname:flags
    must: not contain
    ename:VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT
  * [[VUID-VkImageViewCreateInfo-flags-03568]]
    If pname:flags contains
    ename:VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT,
    pname:flags must: not contain
    ename:VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT
  * [[VUID-VkImageViewCreateInfo-image-03569]]
    If pname:image was created with pname:flags containing
    ename:VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT and pname:usage containing
    ename:VK_IMAGE_USAGE_SAMPLED_BIT, pname:subresourceRange.layerCount
    must: be less than or equal to <<limits-maxSubsampledArrayLayers,
    sname:VkPhysicalDeviceFragmentDensityMap2PropertiesEXT::pname:maxSubsampledArrayLayers>>
endif::VK_EXT_fragment_density_map2[]
ifdef::VK_HUAWEI_invocation_mask[]
  * [[VUID-VkImageViewCreateInfo-invocationMask-04993]]
    If the <<features-invocationMask, pname:invocationMask>> feature is
    enabled, and if pname:image was created with pname:usage containing
    ename:VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI, pname:format must: be
    ename:VK_FORMAT_R8_UINT
endif::VK_HUAWEI_invocation_mask[]
  * [[VUID-VkImageViewCreateInfo-flags-04116]]
    If pname:flags does not contain
    ename:VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT and
    pname:image was created with pname:usage containing
    ename:VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, its pname:flags must:
    not contain any of ename:VK_IMAGE_CREATE_PROTECTED_BIT,
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or
    ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT
endif::VK_EXT_fragment_density_map[]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
ifndef::VK_VERSION_1_2,VK_EXT_separate_stencil_usage[]
  * [[VUID-VkImageViewCreateInfo-pNext-02661]]
    If the pname:pNext chain includes a slink:VkImageViewUsageCreateInfo
    structure, its pname:usage member must: not include any bits that were
    not set in the pname:usage member of the slink:VkImageCreateInfo
    structure used to create pname:image
endif::VK_VERSION_1_2,VK_EXT_separate_stencil_usage[]
ifdef::VK_VERSION_1_2,VK_EXT_separate_stencil_usage[]
  * [[VUID-VkImageViewCreateInfo-pNext-02662]]
    If the pname:pNext chain includes a slink:VkImageViewUsageCreateInfo
    structure, and pname:image was not created with a
    slink:VkImageStencilUsageCreateInfo structure included in the
    pname:pNext chain of slink:VkImageCreateInfo, its pname:usage member
    must: not include any bits that were not set in the pname:usage member
    of the slink:VkImageCreateInfo structure used to create pname:image
  * [[VUID-VkImageViewCreateInfo-pNext-02663]]
    If the pname:pNext chain includes a slink:VkImageViewUsageCreateInfo
    structure, pname:image was created with a
    slink:VkImageStencilUsageCreateInfo structure included in the
    pname:pNext chain of slink:VkImageCreateInfo, and
    pname:subresourceRange.aspectMask includes
    ename:VK_IMAGE_ASPECT_STENCIL_BIT, the pname:usage member of the
    slink:VkImageViewUsageCreateInfo structure must: not include any bits
    that were not set in the pname:usage member of the
    slink:VkImageStencilUsageCreateInfo structure used to create pname:image
  * [[VUID-VkImageViewCreateInfo-pNext-02664]]
    If the pname:pNext chain includes a slink:VkImageViewUsageCreateInfo
    structure, pname:image was created with a
    slink:VkImageStencilUsageCreateInfo structure included in the
    pname:pNext chain of slink:VkImageCreateInfo, and
    pname:subresourceRange.aspectMask includes bits other than
    ename:VK_IMAGE_ASPECT_STENCIL_BIT, the pname:usage member of the
    slink:VkImageViewUsageCreateInfo structure must: not include any bits
    that were not set in the pname:usage member of the
    slink:VkImageCreateInfo structure used to create pname:image
endif::VK_VERSION_1_2,VK_EXT_separate_stencil_usage[]
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]
  * [[VUID-VkImageViewCreateInfo-imageViewType-04973]]
    If pname:viewType is ename:VK_IMAGE_VIEW_TYPE_1D,
    ename:VK_IMAGE_VIEW_TYPE_2D, or ename:VK_IMAGE_VIEW_TYPE_3D; and
    pname:subresourceRange.layerCount is not
    ename:VK_REMAINING_ARRAY_LAYERS, then pname:subresourceRange.layerCount
    must: be 1
  * [[VUID-VkImageViewCreateInfo-imageViewType-04974]]
    If pname:viewType is ename:VK_IMAGE_VIEW_TYPE_1D,
    ename:VK_IMAGE_VIEW_TYPE_2D, or ename:VK_IMAGE_VIEW_TYPE_3D; and
    pname:subresourceRange.layerCount is ename:VK_REMAINING_ARRAY_LAYERS,
    then the remaining number of layers must: be 1
  * [[VUID-VkImageViewCreateInfo-viewType-02960]]
    If pname:viewType is ename:VK_IMAGE_VIEW_TYPE_CUBE and
    pname:subresourceRange.layerCount is not
    ename:VK_REMAINING_ARRAY_LAYERS, pname:subresourceRange.layerCount must:
    be `6`
  * [[VUID-VkImageViewCreateInfo-viewType-02961]]
    If pname:viewType is ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY and
    pname:subresourceRange.layerCount is not
    ename:VK_REMAINING_ARRAY_LAYERS, pname:subresourceRange.layerCount must:
    be a multiple of `6`
  * [[VUID-VkImageViewCreateInfo-viewType-02962]]
    If pname:viewType is ename:VK_IMAGE_VIEW_TYPE_CUBE and
    pname:subresourceRange.layerCount is ename:VK_REMAINING_ARRAY_LAYERS,
    the remaining number of layers must: be `6`
  * [[VUID-VkImageViewCreateInfo-viewType-02963]]
    If pname:viewType is ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY and
    pname:subresourceRange.layerCount is ename:VK_REMAINING_ARRAY_LAYERS,
    the remaining number of layers must: be a multiple of `6`
ifdef::VK_KHR_portability_subset[]
  * [[VUID-VkImageViewCreateInfo-imageViewFormatSwizzle-04465]]
    If the `apiext:VK_KHR_portability_subset` extension is enabled, and
    slink:VkPhysicalDevicePortabilitySubsetFeaturesKHR::pname:imageViewFormatSwizzle
    is ename:VK_FALSE, all elements of pname:components must: have the
    <<resources-image-views-identity-mappings,identity swizzle>>
  * [[VUID-VkImageViewCreateInfo-imageViewFormatReinterpretation-04466]]
    If the `apiext:VK_KHR_portability_subset` extension is enabled, and
    slink:VkPhysicalDevicePortabilitySubsetFeaturesKHR::pname:imageViewFormatReinterpretation
    is ename:VK_FALSE, the elink:VkFormat in pname:format must: not contain
    a different number of components, or a different number of bits in each
    component, than the format of the sname:VkImage in pname:image
endif::VK_KHR_portability_subset[]
ifdef::VKSC_VERSION_1_0[]
  * [[VUID-VkImageViewCreateInfo-subresourceRange-05064]]
    If pname:subresourceRange.levelCount is not
    ename:VK_REMAINING_MIP_LEVELS, pname:subresourceRange.levelCount must:
    be less than or equal to
    slink:VkDeviceObjectReservationCreateInfo::pname:maxImageViewMipLevels
  * [[VUID-VkImageViewCreateInfo-subresourceRange-05200]]
    If pname:subresourceRange.levelCount is ename:VK_REMAINING_MIP_LEVELS,
    the remaining number of mip levels must: be less than or equal to
    slink:VkDeviceObjectReservationCreateInfo::pname:maxImageViewMipLevels
  * [[VUID-VkImageViewCreateInfo-subresourceRange-05065]]
    If pname:subresourceRange.layerCount is not
    ename:VK_REMAINING_ARRAY_LAYERS, pname:subresourceRange.layerCount must:
    be less than or equal to
    slink:VkDeviceObjectReservationCreateInfo::pname:maxImageViewArrayLayers
  * [[VUID-VkImageViewCreateInfo-subresourceRange-05201]]
    If pname:subresourceRange.layerCount is ename:VK_REMAINING_ARRAY_LAYERS,
    the remaining number of layers must: be less than or equal to
    slink:VkDeviceObjectReservationCreateInfo::pname:maxImageViewMipLevels
  * [[VUID-VkImageViewCreateInfo-subresourceRange-05066]]
    If pname:subresourceRange.layerCount is not
    ename:VK_REMAINING_ARRAY_LAYERS and is greater than `1`, or if
    pname:subresourceRange.layerCount is ename:VK_REMAINING_ARRAY_LAYERS and
    the remaining number of layers is greater than `1`, then if
    pname:subresourceRange.levelCount is not ename:VK_REMAINING_MIP_LEVELS,
    pname:subresourceRange.levelCount must: be less than or equal to
    slink:VkDeviceObjectReservationCreateInfo::pname:maxLayeredImageViewMipLevels
  * [[VUID-VkImageViewCreateInfo-subresourceRange-05202]]
    If pname:subresourceRange.layerCount is not
    ename:VK_REMAINING_ARRAY_LAYERS and is greater than `1`, or if
    pname:subresourceRange.layerCount is ename:VK_REMAINING_ARRAY_LAYERS and
    the remaining number of layers is greater than `1`, then if
    pname:subresourceRange.levelCount is ename:VK_REMAINING_MIP_LEVELS, the
    remaining number of mip levels must: be less than or equal to
    slink:VkDeviceObjectReservationCreateInfo::pname:maxLayeredImageViewMipLevels
endif::VKSC_VERSION_1_0[]
ifdef::VK_KHR_video_decode_queue[]
  * [[VUID-VkImageViewCreateInfo-image-04817]]
    If pname:image was created with pname:usage containing
    ename:VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR,
    ename:VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR, or
    ename:VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR, then the pname:viewType
    must: be ename:VK_IMAGE_VIEW_TYPE_2D or
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY
endif::VK_KHR_video_decode_queue[]
ifdef::VK_KHR_video_encode_queue[]
  * [[VUID-VkImageViewCreateInfo-image-04818]]
    If pname:image was created with pname:usage containing
    ename:VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR,
    ename:VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR, or
    ename:VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR, then the pname:viewType
    must: be ename:VK_IMAGE_VIEW_TYPE_2D or
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY
endif::VK_KHR_video_encode_queue[]
ifdef::VK_EXT_descriptor_buffer[]
  * [[VUID-VkImageViewCreateInfo-flags-08106]]
    If pname:flags includes
    ename:VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, the
    <<features-descriptorBufferCaptureReplay,
    pname:descriptorBufferCaptureReplay>> feature must: be enabled
  * [[VUID-VkImageViewCreateInfo-pNext-08107]]
    If the pname:pNext chain includes a
    slink:VkOpaqueCaptureDescriptorDataCreateInfoEXT structure, pname:flags
    must: contain
    ename:VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
endif::VK_EXT_descriptor_buffer[]
ifdef::VK_EXT_metal_objects[]
  * [[VUID-VkImageViewCreateInfo-pNext-06787]]
    If the pname:pNext chain includes a
    slink:VkExportMetalObjectCreateInfoEXT structure, its
    pname:exportObjectType member must: be
    ename:VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT
endif::VK_EXT_metal_objects[]
ifdef::VK_QCOM_image_processing[]
  * [[VUID-VkImageViewCreateInfo-pNext-06944]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure, then
    <<features-textureSampleWeighted, pname:textureSampleWeighted>> feature
    must: be enabled
  * [[VUID-VkImageViewCreateInfo-pNext-06945]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure, then pname:image
    must: have been created with pname:usage containing
    ename:VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM
  * [[VUID-VkImageViewCreateInfo-pNext-06946]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure, then
    pname:components must: be ename:VK_COMPONENT_SWIZZLE_IDENTITY for all
    components
  * [[VUID-VkImageViewCreateInfo-pNext-06947]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure, then
    pname:subresourceRange.aspectMask must: be
    ename:VK_IMAGE_ASPECT_COLOR_BIT
  * [[VUID-VkImageViewCreateInfo-pNext-06948]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure, then
    pname:subresourceRange.levelCount must: be `1`
  * [[VUID-VkImageViewCreateInfo-pNext-06949]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure, then
    pname:viewType must: be ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY or
    ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY
  * [[VUID-VkImageViewCreateInfo-pNext-06950]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure and if
    pname:viewType is ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, then pname:image
    must: have been created with pname:imageType ename:VK_IMAGE_TYPE_1D
  * [[VUID-VkImageViewCreateInfo-pNext-06951]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure and pname:viewType
    is ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, then
    pname:subresourceRange.layerCount must: be equal to `2`
  * [[VUID-VkImageViewCreateInfo-pNext-06952]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure and pname:viewType
    is ename:VK_IMAGE_VIEW_TYPE_1D_ARRAY, then pname:image must: have been
    created with pname:width equal to or greater than latexmath:[(numPhases
    \times \mathbin{max}\left(
    \mathbin{align}\left(filterSize.width,4\right),
    filterSize.height\right))]
  * [[VUID-VkImageViewCreateInfo-pNext-06953]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure and if
    pname:viewType is ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY, then pname:image
    must: have been created with pname:imageType ename:VK_IMAGE_TYPE_2D
  * [[VUID-VkImageViewCreateInfo-pNext-06954]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure and pname:viewType
    is ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY, then
    pname:subresourceRange.layerCount must: be equal or greater than
    [eq]#numPhases#
  * [[VUID-VkImageViewCreateInfo-pNext-06955]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure and pname:viewType
    is ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY, then pname:image must: have been
    created with pname:width equal to or greater than pname:filterSize.width
  * [[VUID-VkImageViewCreateInfo-pNext-06956]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure and pname:viewType
    is ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY, then pname:image must: have been
    created with pname:height equal to or greater than
    pname:filterSize.height
  * [[VUID-VkImageViewCreateInfo-pNext-06957]]
    If the pname:pNext chain includes
    slink:VkImageViewSampleWeightCreateInfoQCOM structure then
    slink:VkImageViewSampleWeightCreateInfoQCOM::pname:filterSize.height
    must: be less than or equal to <<limits-weightfilter-maxdimension,
    sname:VkPhysicalDeviceImageProcessingPropertiesQCOM::pname:maxWeightFilterDimension.height>>
endif::VK_QCOM_image_processing[]
  * [[VUID-VkImageViewCreateInfo-subresourceRange-09594]]
    pname:subresourceRange.aspectMask must: be valid for the pname:format
    the pname:image was created with
****

include::{generated}/validity/structs/VkImageViewCreateInfo.adoc[]
--

[open,refpage='VkImageViewCreateFlagBits',desc='Bitmask specifying additional parameters of an image view',type='enums']
--
Bits which can: be set in slink:VkImageViewCreateInfo::pname:flags,
specifying additional parameters of an image view, are:

include::{generated}/api/enums/VkImageViewCreateFlagBits.adoc[]

ifdef::VK_EXT_fragment_density_map[]
  * ename:VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT
    specifies that the fragment density map will be read by device during
    ename:VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT
ifdef::VK_EXT_fragment_density_map2[]
  * ename:VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT
    specifies that the fragment density map will be read by the host during
    flink:vkEndCommandBuffer for the primary command buffer that the render
    pass is recorded into
endif::VK_EXT_fragment_density_map2[]
endif::VK_EXT_fragment_density_map[]
ifdef::VK_EXT_descriptor_buffer[]
  * ename:VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
    specifies that the image view can: be used with descriptor buffers when
    capturing and replaying (e.g. for trace capture and replay), see
    slink:VkOpaqueCaptureDescriptorDataCreateInfoEXT for more detail.
endif::VK_EXT_descriptor_buffer[]
--

[open,refpage='VkImageViewCreateFlags',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkImageViewCreateFlags.adoc[]

tname:VkImageViewCreateFlags is a bitmask type for setting a mask of zero or
more elink:VkImageViewCreateFlagBits.
--

ifdef::VK_VERSION_1_1,VK_KHR_maintenance2[]
[open,refpage='VkImageViewUsageCreateInfo',desc='Specify the intended usage of an image view',type='structs']
--
The set of usages for the created image view can: be restricted compared to
the parent image's pname:usage flags by adding a
sname:VkImageViewUsageCreateInfo structure to the pname:pNext chain of
slink:VkImageViewCreateInfo.

The sname:VkImageViewUsageCreateInfo structure is defined as:

include::{generated}/api/structs/VkImageViewUsageCreateInfo.adoc[]

ifdef::VK_KHR_maintenance2[]
or the equivalent

include::{generated}/api/structs/VkImageViewUsageCreateInfoKHR.adoc[]
endif::VK_KHR_maintenance2[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:usage is a bitmask of elink:VkImageUsageFlagBits specifying
    allowed usages of the image view.

When this structure is chained to slink:VkImageViewCreateInfo the
pname:usage field overrides the implicit pname:usage parameter inherited
from image creation time and its value is used instead for the purposes of
determining the valid usage conditions of slink:VkImageViewCreateInfo.

include::{generated}/validity/structs/VkImageViewUsageCreateInfo.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_maintenance2[]

ifdef::VK_EXT_image_sliced_view_of_3d[]
[open,refpage='VkImageViewSlicedCreateInfoEXT',desc='Specify the subset of 3D slices of an image view',type='structs']
--
The range of 3D slices for the created image view can: be restricted to a
subset of the parent image's Z range by adding a
sname:VkImageViewSlicedCreateInfoEXT structure to the pname:pNext chain of
slink:VkImageViewCreateInfo.

The sname:VkImageViewSlicedCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkImageViewSlicedCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:sliceOffset is the Z-offset for the first 3D slice accessible to
    the image view.
  * pname:sliceCount is the number of 3D slices accessible to the image
    view.

When this structure is chained to slink:VkImageViewCreateInfo the
pname:sliceOffset field is treated as a Z-offset for the sliced view and
pname:sliceCount specifies the range.
Shader accesses using a Z coordinate of 0 will access the depth slice
corresponding to pname:sliceOffset in the image, and in a shader, the
maximum in-bounds Z coordinate for the view is [eq]#pname:sliceCount - 1#.

A sliced 3D view must: only be used with a single mip level.
The slice coordinates are integer coordinates within the
pname:subresourceRange.baseMipLevel used to create the image view.

The effective view depth is equal to pname:extent.depth used to create the
pname:image for this view adjusted by pname:subresourceRange.baseMipLevel as
specified in <<resources-image-mip-level-sizing,Image Mip Level Sizing>>.

Shader access to this image view is only affected by
sname:VkImageViewSlicedCreateInfoEXT if it uses a descriptor of type
ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.
For access using any other descriptor type, the contents of
sname:VkImageViewSlicedCreateInfoEXT are ignored; instead, pname:sliceOffset
is treated as being equal to 0, and pname:sliceCount is treated as being
equal to ename:VK_REMAINING_3D_SLICES_EXT.

.Valid Usage
****
  * [[VUID-VkImageViewSlicedCreateInfoEXT-sliceOffset-07867]]
    pname:sliceOffset must: be less than the effective view depth as
    specified in <<resources-image-mip-level-sizing,Image Mip Level Sizing>>
  * [[VUID-VkImageViewSlicedCreateInfoEXT-sliceCount-07868]]
    If pname:sliceCount is not ename:VK_REMAINING_3D_SLICES_EXT, it must: be
    non-zero and [eq]#pname:sliceOffset {plus} pname:sliceCount# must: be
    less than or equal to the effective view depth as specified in
    <<resources-image-mip-level-sizing,Image Mip Level Sizing>>
  * [[VUID-VkImageViewSlicedCreateInfoEXT-image-07869]]
    pname:image must: have been created with pname:imageType equal to
    ename:VK_IMAGE_TYPE_3D
  * [[VUID-VkImageViewSlicedCreateInfoEXT-viewType-07909]]
    pname:viewType must: be ename:VK_IMAGE_VIEW_TYPE_3D
  * [[VUID-VkImageViewSlicedCreateInfoEXT-None-07870]]
    The image view must: reference exactly 1 mip level
  * [[VUID-VkImageViewSlicedCreateInfoEXT-None-07871]]
    The <<features-imageSlicedViewOf3D,imageSlicedViewOf3D>> feature must:
    be enabled on the device
****

include::{generated}/validity/structs/VkImageViewSlicedCreateInfoEXT.adoc[]
--

[open,refpage='VK_REMAINING_3D_SLICES_EXT',desc='Sentinel for all remaining 3D slices',type='consts']
--
ename:VK_REMAINING_3D_SLICES_EXT is a special constant value used for
slink:VkImageViewSlicedCreateInfoEXT::pname:sliceCount to indicate that all
remaining 3D slices in an image after the first slice offset specified
should be included in the view.

include::{generated}/api/enums/VK_REMAINING_3D_SLICES_EXT.adoc[]
--
endif::VK_EXT_image_sliced_view_of_3d[]

[open,refpage='VkImageSubresourceRange',desc='Structure specifying an image subresource range',type='structs']
--
The sname:VkImageSubresourceRange structure is defined as:

include::{generated}/api/structs/VkImageSubresourceRange.adoc[]

  * pname:aspectMask is a bitmask of elink:VkImageAspectFlagBits specifying
    which aspect(s) of the image are included in the view.
  * pname:baseMipLevel is the first mipmap level accessible to the view.
  * pname:levelCount is the number of mipmap levels (starting from
    pname:baseMipLevel) accessible to the view.
  * pname:baseArrayLayer is the first array layer accessible to the view.
  * pname:layerCount is the number of array layers (starting from
    pname:baseArrayLayer) accessible to the view.

The number of mipmap levels and array layers must: be a subset of the image
subresources in the image.
If an application wants to use all mip levels or layers in an image after
the pname:baseMipLevel or pname:baseArrayLayer, it can: set pname:levelCount
and pname:layerCount to the special values ename:VK_REMAINING_MIP_LEVELS and
ename:VK_REMAINING_ARRAY_LAYERS without knowing the exact number of mip
levels or layers.

For cube and cube array image views, the layers of the image view starting
at pname:baseArrayLayer correspond to faces in the order +X, -X, +Y, -Y, +Z,
-Z.
For cube arrays, each set of six sequential layers is a single cube, so the
number of cube maps in a cube map array view is _pname:layerCount / 6_, and
image array layer [eq]#(pname:baseArrayLayer {plus} i)# is face index
[eq]#(i mod 6)# of cube _i / 6_.
If the number of layers in the view, whether set explicitly in
pname:layerCount or implied by ename:VK_REMAINING_ARRAY_LAYERS, is not a
multiple of 6, the last cube map in the array must: not be accessed.

pname:aspectMask must: be only ename:VK_IMAGE_ASPECT_COLOR_BIT,
ename:VK_IMAGE_ASPECT_DEPTH_BIT or ename:VK_IMAGE_ASPECT_STENCIL_BIT if
pname:format is a color, depth-only or stencil-only format,
ifndef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
respectively.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
respectively, except if pname:format is a
<<formats-requiring-sampler-ycbcr-conversion,multi-planar format>>.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
If using a depth/stencil format with both depth and stencil components,
pname:aspectMask must: include at least one of
ename:VK_IMAGE_ASPECT_DEPTH_BIT and ename:VK_IMAGE_ASPECT_STENCIL_BIT, and
can: include both.

ifdef::VK_VERSION_1_1,VK_KHR_maintenance1[]
When the sname:VkImageSubresourceRange structure is used to select a subset
of the slices of a 3D image's mip level in order to create a 2D or 2D array
image view of a 3D image created with
ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT, pname:baseArrayLayer and
pname:layerCount specify the first slice index and the number of slices to
include in the created image view.
Such an image view can: be used as a framebuffer attachment that refers only
to the specified range of slices of the selected mip level.
However, any layout transitions performed on such an attachment view during
a render pass instance still apply to the entire subresource referenced
which includes all the slices of the selected mip level.
endif::VK_VERSION_1_1,VK_KHR_maintenance1[]

When using an image view of a depth/stencil image to populate a descriptor
set (e.g. for sampling in the shader, or for use as an input attachment),
the pname:aspectMask must: only include one bit, which selects whether the
image view is used for depth reads (i.e. using a floating-point sampler or
input attachment in the shader) or stencil reads (i.e. using an unsigned
integer sampler or input attachment in the shader).
When an image view of a depth/stencil image is used as a depth/stencil
framebuffer attachment, the pname:aspectMask is ignored and both depth and
stencil image subresources are used.

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
When creating a sname:VkImageView, if <<samplers-YCbCr-conversion,sampler
{YCbCr} conversion>> is enabled in the sampler, the pname:aspectMask of a
pname:subresourceRange used by the sname:VkImageView must: be
ename:VK_IMAGE_ASPECT_COLOR_BIT.

When creating a sname:VkImageView, if sampler {YCbCr} conversion is not
enabled in the sampler and the image pname:format is
<<formats-requiring-sampler-ycbcr-conversion,multi-planar>>, the image must:
have been created with ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, and the
pname:aspectMask of the sname:VkImageView's pname:subresourceRange must: be
ename:VK_IMAGE_ASPECT_PLANE_0_BIT, ename:VK_IMAGE_ASPECT_PLANE_1_BIT or
ename:VK_IMAGE_ASPECT_PLANE_2_BIT.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

.Valid Usage
****
  * [[VUID-VkImageSubresourceRange-levelCount-01720]]
    If pname:levelCount is not ename:VK_REMAINING_MIP_LEVELS, it must: be
    greater than `0`
  * [[VUID-VkImageSubresourceRange-layerCount-01721]]
    If pname:layerCount is not ename:VK_REMAINING_ARRAY_LAYERS, it must: be
    greater than `0`
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkImageSubresourceRange-aspectMask-01670]]
    If pname:aspectMask includes ename:VK_IMAGE_ASPECT_COLOR_BIT, then it
    must: not include any of ename:VK_IMAGE_ASPECT_PLANE_0_BIT,
    ename:VK_IMAGE_ASPECT_PLANE_1_BIT, or ename:VK_IMAGE_ASPECT_PLANE_2_BIT
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-VkImageSubresourceRange-aspectMask-02278]]
    pname:aspectMask must: not include
    `VK_IMAGE_ASPECT_MEMORY_PLANE__{ibit}__BIT_EXT` for any index _i_
endif::VK_EXT_image_drm_format_modifier[]
****

include::{generated}/validity/structs/VkImageSubresourceRange.adoc[]
--

[open,refpage='VkImageAspectFlagBits',desc='Bitmask specifying which aspects of an image are included in a view',type='enums']
--
Bits which can: be set in an aspect mask to specify aspects of an image for
purposes such as identifying a subresource, are:

include::{generated}/api/enums/VkImageAspectFlagBits.adoc[]

ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
  * ename:VK_IMAGE_ASPECT_NONE specifies no image aspect, or the image
    aspect is not applicable.
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]
  * ename:VK_IMAGE_ASPECT_COLOR_BIT specifies the color aspect.
  * ename:VK_IMAGE_ASPECT_DEPTH_BIT specifies the depth aspect.
  * ename:VK_IMAGE_ASPECT_STENCIL_BIT specifies the stencil aspect.
  * ename:VK_IMAGE_ASPECT_METADATA_BIT specifies the metadata aspect used
    for <<sparsememory, sparse resource>> operations.
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * ename:VK_IMAGE_ASPECT_PLANE_0_BIT specifies plane 0 of a _multi-planar_
    image format.
  * ename:VK_IMAGE_ASPECT_PLANE_1_BIT specifies plane 1 of a _multi-planar_
    image format.
  * ename:VK_IMAGE_ASPECT_PLANE_2_BIT specifies plane 2 of a _multi-planar_
    image format.
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_EXT_image_drm_format_modifier[]
  * ename:VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT specifies _memory plane_ 0.
  * ename:VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT specifies _memory plane_ 1.
  * ename:VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT specifies _memory plane_ 2.
  * ename:VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT specifies _memory plane_ 3.
endif::VK_EXT_image_drm_format_modifier[]
--

[open,refpage='VkImageAspectFlags',desc='Bitmask of VkImageAspectFlagBits',type='flags']
--
include::{generated}/api/flags/VkImageAspectFlags.adoc[]

tname:VkImageAspectFlags is a bitmask type for setting a mask of zero or
more elink:VkImageAspectFlagBits.
--

[open,refpage='VkComponentMapping',desc='Structure specifying a color component mapping',type='structs']
--
The sname:VkComponentMapping structure is defined as:

include::{generated}/api/structs/VkComponentMapping.adoc[]

  * pname:r is a elink:VkComponentSwizzle specifying the component value
    placed in the R component of the output vector.
  * pname:g is a elink:VkComponentSwizzle specifying the component value
    placed in the G component of the output vector.
  * pname:b is a elink:VkComponentSwizzle specifying the component value
    placed in the B component of the output vector.
  * pname:a is a elink:VkComponentSwizzle specifying the component value
    placed in the A component of the output vector.

include::{generated}/validity/structs/VkComponentMapping.adoc[]
--

[open,refpage='VkComponentSwizzle',desc='Specify how a component is swizzled',type='enums']
--
Possible values of the members of slink:VkComponentMapping, specifying the
component values placed in each component of the output vector, are:

include::{generated}/api/enums/VkComponentSwizzle.adoc[]

  * ename:VK_COMPONENT_SWIZZLE_IDENTITY specifies that the component is set
    to the identity swizzle.
  * ename:VK_COMPONENT_SWIZZLE_ZERO specifies that the component is set to
    zero.
  * ename:VK_COMPONENT_SWIZZLE_ONE specifies that the component is set to
    either 1 or 1.0, depending on whether the type of the image view format
    is integer or floating-point respectively, as determined by the
    <<formats-definition,Format Definition>> section for each
    elink:VkFormat.
  * ename:VK_COMPONENT_SWIZZLE_R specifies that the component is set to the
    value of the R component of the image.
  * ename:VK_COMPONENT_SWIZZLE_G specifies that the component is set to the
    value of the G component of the image.
  * ename:VK_COMPONENT_SWIZZLE_B specifies that the component is set to the
    value of the B component of the image.
  * ename:VK_COMPONENT_SWIZZLE_A specifies that the component is set to the
    value of the A component of the image.

[[resources-image-views-identity-mappings]]
Setting the identity swizzle on a component is equivalent to setting the
identity mapping on that component.
That is:

.Component Mappings Equivalent To ename:VK_COMPONENT_SWIZZLE_IDENTITY
[options="header"]
|====
| Component          | Identity Mapping
| pname:components.r | ename:VK_COMPONENT_SWIZZLE_R
| pname:components.g | ename:VK_COMPONENT_SWIZZLE_G
| pname:components.b | ename:VK_COMPONENT_SWIZZLE_B
| pname:components.a | ename:VK_COMPONENT_SWIZZLE_A
|====
--

ifdef::VK_EXT_astc_decode_mode[]
[open,refpage='VkImageViewASTCDecodeModeEXT',desc='Structure describing the ASTC decode mode for an image view',type='structs']
--
If the pname:pNext chain includes a sname:VkImageViewASTCDecodeModeEXT
structure, then that structure includes a parameter specifying the decode
mode for image views using ASTC compressed formats.

The sname:VkImageViewASTCDecodeModeEXT structure is defined as:

include::{generated}/api/structs/VkImageViewASTCDecodeModeEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:decodeMode is the intermediate format used to decode ASTC
    compressed formats.

.Valid Usage
****
  * [[VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02230]]
    pname:decodeMode must: be one of ename:VK_FORMAT_R16G16B16A16_SFLOAT,
    ename:VK_FORMAT_R8G8B8A8_UNORM, or
    ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32
  * [[VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02231]]
    If the <<features-astc-decodeModeSharedExponent,
    pname:decodeModeSharedExponent>> feature is not enabled,
    pname:decodeMode must: not be ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32
  * [[VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02232]]
    If pname:decodeMode is ename:VK_FORMAT_R8G8B8A8_UNORM the image view
    must: not include blocks using any of the ASTC HDR modes
  * [[VUID-VkImageViewASTCDecodeModeEXT-format-04084]]
    pname:format of the image view must: be one of the
    <<appendix-compressedtex-astc, ASTC Compressed Image Formats>>
****

If pname:format uses sRGB encoding then the pname:decodeMode has no effect.

include::{generated}/validity/structs/VkImageViewASTCDecodeModeEXT.adoc[]
--
endif::VK_EXT_astc_decode_mode[]

ifdef::VK_QCOM_image_processing[]
[open,refpage='VkImageViewSampleWeightCreateInfoQCOM',desc='Structure describing weight sampling parameters for image view',type='structs']
--
If the pname:pNext chain includes a
sname:VkImageViewSampleWeightCreateInfoQCOM structure, then that structure
includes a parameter specifying the parameters for weight image views used
in <<textures-weightimage,weight image sampling>>.

The sname:VkImageViewSampleWeightCreateInfoQCOM structure is defined as:

include::{generated}/api/structs/VkImageViewSampleWeightCreateInfoQCOM.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:filterCenter is a slink:VkOffset2D describing the location of the
    weight filter origin.
  * pname:filterSize is a slink:VkExtent2D specifying weight filter
    dimensions.
  * pname:numPhases is number of sub-pixel filter phases.


The pname:filterCenter specifies the origin or center of the filter kernel,
as described in <<textures-weightimage-filteroperation, Weight Sampling
Operation>>.
The pname:numPhases describes the number of sub-pixel filter phases as
described in <<textures-weightimage-filterphases,Weight Sampling Phases>>.

.Valid Usage
****
  * [[VUID-VkImageViewSampleWeightCreateInfoQCOM-filterSize-06958]]
    pname:filterSize.width must: be less than or equal to
    <<limits-weightfilter-maxdimension,
    sname:VkPhysicalDeviceImageProcessingPropertiesQCOM::pname:maxWeightFilterDimension.width>>
  * [[VUID-VkImageViewSampleWeightCreateInfoQCOM-filterSize-06959]]
    pname:filterSize.height must: be less than or equal to
    <<limits-weightfilter-maxdimension,
    sname:VkPhysicalDeviceImageProcessingPropertiesQCOM::pname:maxWeightFilterDimension.height>>
  * [[VUID-VkImageViewSampleWeightCreateInfoQCOM-filterCenter-06960]]
    pname:filterCenter.x must: be less than or equal to
    [eq]#(filterSize.width - 1)#
  * [[VUID-VkImageViewSampleWeightCreateInfoQCOM-filterCenter-06961]]
    pname:filterCenter.y must: be less than or equal to
    [eq]#(filterSize.height - 1)#
  * [[VUID-VkImageViewSampleWeightCreateInfoQCOM-numPhases-06962]]
    pname:numPhases must: be a power of two squared value (i.e., 1, 4, 16,
    64, 256, etc.)
  * [[VUID-VkImageViewSampleWeightCreateInfoQCOM-numPhases-06963]]
    pname:numPhases must: be less than or equal to
    <<limits-weightfilter-phases,
    sname:VkPhysicalDeviceImageProcessingPropertiesQCOM::pname:maxWeightFilterPhases>>
****


include::{generated}/validity/structs/VkImageViewSampleWeightCreateInfoQCOM.adoc[]
--
endif::VK_QCOM_image_processing[]


[open,refpage='vkDestroyImageView',desc='Destroy an image view object',type='protos']
--
To destroy an image view, call:

include::{generated}/api/protos/vkDestroyImageView.adoc[]

  * pname:device is the logical device that destroys the image view.
  * pname:imageView is the image view to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyImageView-imageView-01026]]
    All submitted commands that refer to pname:imageView must: have
    completed execution
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkDestroyImageView-imageView-01027]]
    If sname:VkAllocationCallbacks were provided when pname:imageView was
    created, a compatible set of callbacks must: be provided here
  * [[VUID-vkDestroyImageView-imageView-01028]]
    If no sname:VkAllocationCallbacks were provided when pname:imageView was
    created, pname:pAllocator must: be `NULL`
endif::VKSC_VERSION_1_0[]
****

include::{generated}/validity/protos/vkDestroyImageView.adoc[]
--

ifdef::VK_NVX_image_view_handle[]
[open,refpage='vkGetImageViewHandleNVX',desc='Get the handle for an image view for a specific descriptor type',type='protos']
--
To get the handle for an image view, call:

include::{generated}/api/protos/vkGetImageViewHandleNVX.adoc[]

  * pname:device is the logical device that owns the image view.
  * pname:pInfo describes the image view to query and type of handle.

include::{generated}/validity/protos/vkGetImageViewHandleNVX.adoc[]
--

[open,refpage='VkImageViewHandleInfoNVX',desc='Structure specifying the image view for handle queries',type='structs']
--
The sname:VkImageViewHandleInfoNVX structure is defined as:

include::{generated}/api/structs/VkImageViewHandleInfoNVX.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:imageView is the image view to query.
  * pname:descriptorType is the type of descriptor for which to query a
    handle.
  * pname:sampler is the sampler to combine with the image view when
    generating the handle.

.Valid Usage
****
  * [[VUID-VkImageViewHandleInfoNVX-descriptorType-02654]]
    pname:descriptorType must: be ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
  * [[VUID-VkImageViewHandleInfoNVX-sampler-02655]]
    pname:sampler must: be a valid slink:VkSampler if pname:descriptorType
    is ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
  * [[VUID-VkImageViewHandleInfoNVX-imageView-02656]]
    If descriptorType is ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or
    ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the image that
    pname:imageView was created from must: have been created with the
    ename:VK_IMAGE_USAGE_SAMPLED_BIT usage bit set
  * [[VUID-VkImageViewHandleInfoNVX-imageView-02657]]
    If descriptorType is ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, the image
    that pname:imageView was created from must: have been created with the
    ename:VK_IMAGE_USAGE_STORAGE_BIT usage bit set
****

include::{generated}/validity/structs/VkImageViewHandleInfoNVX.adoc[]
--

[open,refpage='vkGetImageViewAddressNVX',desc='Get the device address of an image view',type='protos']
--
To get the device address for an image view, call:

include::{generated}/api/protos/vkGetImageViewAddressNVX.adoc[]

  * pname:device is the logical device that owns the image view.
  * pname:imageView is a handle to the image view.
  * pname:pProperties contains the device address and size when the call
    returns.

include::{generated}/validity/protos/vkGetImageViewAddressNVX.adoc[]
--

[open,refpage='VkImageViewAddressPropertiesNVX',desc='Structure specifying the image view for handle queries',type='structs']
--
The sname:VkImageViewAddressPropertiesNVX structure is defined as:

include::{generated}/api/structs/VkImageViewAddressPropertiesNVX.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:deviceAddress is the device address of the image view.
  * pname:size is the size in bytes of the image view device memory.


include::{generated}/validity/structs/VkImageViewAddressPropertiesNVX.adoc[]
--
endif::VK_NVX_image_view_handle[]


[[resources-image-view-format-features]]
=== Image View Format Features

Valid uses of a slink:VkImageView may: depend on the image view's _format
features_, defined below.
Such constraints are documented in the affected valid usage statement.

ifndef::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
  * If slink:VkImageViewCreateInfo::pname:image was created with
    ename:VK_IMAGE_TILING_LINEAR, then the image view's set of _format
    features_ is the value of
    slink:VkFormatProperties::pname:linearTilingFeatures found by calling
    flink:vkGetPhysicalDeviceFormatProperties on the same pname:format as
    slink:VkImageViewCreateInfo::pname:format.
endif::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
ifdef::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
  * If Vulkan 1.3 is supported or the `apiext:VK_KHR_format_feature_flags2`
    extension is supported, and slink:VkImageViewCreateInfo::pname:image was
    created with ename:VK_IMAGE_TILING_LINEAR, then the image view's set of
    _format features_ is the value of
    slink:VkFormatProperties3::pname:linearTilingFeatures found by calling
    flink:vkGetPhysicalDeviceFormatProperties2 on the same pname:format as
    slink:VkImageViewCreateInfo::pname:format.
  * If Vulkan 1.3 is not supported and the
    `apiext:VK_KHR_format_feature_flags2` extension is not supported, and
    slink:VkImageViewCreateInfo::pname:image was created with
    ename:VK_IMAGE_TILING_LINEAR, then the image view's set of _format
    features_ is the union of the value of
    slink:VkFormatProperties::pname:linearTilingFeatures found by calling
    flink:vkGetPhysicalDeviceFormatProperties on the same pname:format as
    slink:VkImageViewCreateInfo::pname:format, with:
  ** ename:VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT if the
     format is a depth/stencil format and the image view features also
     contain ename:VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT.
  ** ename:VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT if the format
     is one of the <<formats-without-shader-storage-format,extended storage
     formats>> and pname:shaderStorageImageReadWithoutFormat is enabled on
     the device.
  ** ename:VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT if the
     format is one of the <<formats-without-shader-storage-format,extended
     storage formats>> and pname:shaderStorageImageWriteWithoutFormat is
     enabled on the device.
endif::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
ifndef::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
  * If slink:VkImageViewCreateInfo::pname:image was created with
    ename:VK_IMAGE_TILING_OPTIMAL,
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
    but without an
    <<memory-external-android-hardware-buffer-external-formats,Android
    hardware buffer external format>>,
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
    or a <<memory-external-screen-buffer-external-formats,QNX Screen buffer
    external format>>,
endif::VK_QNX_external_memory_screen_buffer[]
    then the image view's set of _format features_ is the value of
    slink:VkFormatProperties::pname:optimalTilingFeatures found by calling
    flink:vkGetPhysicalDeviceFormatProperties on the same pname:format as
    slink:VkImageViewCreateInfo::pname:format.
endif::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
ifdef::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
  * If Vulkan 1.3 is supported or the `apiext:VK_KHR_format_feature_flags2`
    extension is supported, and slink:VkImageViewCreateInfo::pname:image was
    created with ename:VK_IMAGE_TILING_OPTIMAL,
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
    but without an
    <<memory-external-android-hardware-buffer-external-formats,Android
    hardware buffer external format>>,
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
    or a <<memory-external-screen-buffer-external-formats,QNX Screen buffer
    external format>>,
endif::VK_QNX_external_memory_screen_buffer[]
    then the image view's set of _format features_ is the value of
    slink:VkFormatProperties::pname:optimalTilingFeatures or
    slink:VkFormatProperties3::pname:optimalTilingFeatures found by calling
    flink:vkGetPhysicalDeviceFormatProperties or
    flink:vkGetPhysicalDeviceImageFormatProperties2 on the same pname:format
    as slink:VkImageViewCreateInfo::pname:format.
  * If Vulkan 1.3 is not supported and the
    `apiext:VK_KHR_format_feature_flags2` extension is not supported, and
    slink:VkImageViewCreateInfo::pname:image was created with
    ename:VK_IMAGE_TILING_OPTIMAL,
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
    but without an
    <<memory-external-android-hardware-buffer-external-formats,Android
    hardware buffer external format>>,
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
    or a <<memory-external-screen-buffer-external-formats,QNX Screen buffer
    external format>>,
endif::VK_QNX_external_memory_screen_buffer[]
    then the image view's set of _format features_ is the union of the value
    of slink:VkFormatProperties::pname:optimalTilingFeatures found by
    calling flink:vkGetPhysicalDeviceFormatProperties on the same
    pname:format as slink:VkImageViewCreateInfo::pname:format, with:
  ** ename:VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT if the
     format is a depth/stencil format and the image view features also
     contain ename:VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT.
  ** ename:VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT if the format
     is one of the <<formats-without-shader-storage-format,extended storage
     formats>> and pname:shaderStorageImageReadWithoutFormat is enabled on
     the device.
  ** ename:VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT if the
     format is one of the <<formats-without-shader-storage-format,extended
     storage formats>> and pname:shaderStorageImageWriteWithoutFormat is
     enabled on the device.
endif::VK_VERSION_1_3,VK_KHR_format_feature_flags2[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
  * If slink:VkImageViewCreateInfo::pname:image was created with an
    <<memory-external-android-hardware-buffer-external-formats,Android
    hardware buffer external format>>, then the image views's set of _format
    features_ is the value of
    slink:VkAndroidHardwareBufferFormatPropertiesANDROID::pname:formatFeatures
    found by calling flink:vkGetAndroidHardwareBufferPropertiesANDROID on
    the Android hardware buffer that was imported to the
    slink:VkDeviceMemory to which the
    slink:VkImageViewCreateInfo::pname:image is bound.
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
  * If slink:VkImageViewCreateInfo::pname:image was created with a
    <<memory-external-screen-buffer-external-formats,QNX Screen buffer
    external format>>, then the image views's set of _format features_ is
    the value of
    slink:VkScreenBufferFormatPropertiesQNX::pname:formatFeatures found by
    calling flink:vkGetScreenBufferPropertiesQNX on the QNX Screen buffer
    that was imported to the slink:VkDeviceMemory to which the
    slink:VkImageViewCreateInfo::pname:image is bound.
endif::VK_QNX_external_memory_screen_buffer[]
ifdef::VK_FUCHSIA_buffer_collection[]
  * If slink:VkImageViewCreateInfo::pname:image was created with a chained
    slink:VkBufferCollectionImageCreateInfoFUCHSIA, then the image view's
    set of _format features_ is the value of
    slink:VkBufferCollectionPropertiesFUCHSIA::pname:formatFeatures found by
    calling flink:vkGetBufferCollectionPropertiesFUCHSIA on the buffer
    collection passed as
    slink:VkBufferCollectionImageCreateInfoFUCHSIA::pname:collection when
    the image was created.
endif::VK_FUCHSIA_buffer_collection[]
ifdef::VK_EXT_image_drm_format_modifier[]
  * If slink:VkImageViewCreateInfo::pname:image was created with
    ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then:
  ** The image's DRM format modifier is the value of
     slink:VkImageDrmFormatModifierPropertiesEXT::pname:drmFormatModifier
     found by calling flink:vkGetImageDrmFormatModifierPropertiesEXT.
  ** Let
     slink:VkDrmFormatModifierPropertiesListEXT::pname:pDrmFormatModifierProperties
     be the array found by calling
     flink:vkGetPhysicalDeviceFormatProperties2 on the same pname:format as
     slink:VkImageViewCreateInfo::pname:format.
  ** Let `VkDrmFormatModifierPropertiesEXT prop` be the array element whose
     pname:drmFormatModifier member is the value of the image's DRM format
     modifier.
  ** Then the image view's set of _format features_ is
     `prop`::pname:drmFormatModifierTilingFeatures.
endif::VK_EXT_image_drm_format_modifier[]

ifdef::VK_EXT_image_view_min_lod[]
[open,refpage='VkImageViewMinLodCreateInfoEXT',desc='Structure describing the minimum LOD of an image view',type='structs']
--
The sname:VkImageViewMinLodCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkImageViewMinLodCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:minLod is the value to clamp the minimum LOD accessible by this
    slink:VkImageView.

If the pname:pNext chain includes a sname:VkImageViewMinLodCreateInfoEXT
structure, then that structure includes a parameter specifying a value to
clamp the minimum LOD value during <<textures-image-level-selection,Image
Level(s) Selection>>, <<textures-gather,Texel Gathering>> and
<<textures-integer-coordinate-operations,Integer Texel Coordinate
Operations>>.

If the image view contains sname:VkImageViewMinLodCreateInfoEXT and it is
used as part of a sampling operation:

[eq]#minLodFloat~imageView~ = pname:minLod#

otherwise:

[eq]#minLodFloat~imageView~ = 0.0#

An integer variant of this parameter is also defined for sampling operations
which access integer mipmap levels:

[eq]#minLodInteger~imageView~ = {lfloor}minLodFloat~imageView~{rfloor}#

.Valid Usage
****
  * [[VUID-VkImageViewMinLodCreateInfoEXT-minLod-06455]]
    If the <<features-minLod, pname:minLod>> feature is not enabled,
    pname:minLod must: be `0.0`
  * [[VUID-VkImageViewMinLodCreateInfoEXT-minLod-06456]]
    pname:minLod must: be less or equal to the index of the last mipmap
    level accessible to the view
****

include::{generated}/validity/structs/VkImageViewMinLodCreateInfoEXT.adoc[]
--
endif::VK_EXT_image_view_min_lod[]


ifdef::VK_NV_ray_tracing,VK_KHR_acceleration_structure[]
[[resources-acceleration-structures]]
== Acceleration Structures

[open,refpage='VkAccelerationStructureKHR',desc='Opaque handle to an acceleration structure object',type='handles']
--
:refpage: VkAccelerationStructureKHR

Acceleration structures are opaque data structures that are built by the
implementation to more efficiently perform spatial queries on the provided
geometric data.
For this extension, an acceleration structure is either a top-level
acceleration structure containing a set of bottom-level acceleration
structures or a bottom-level acceleration structure containing either a set
of axis-aligned bounding boxes for custom geometry or a set of triangles.

Each instance in the top-level acceleration structure contains a reference
to a bottom-level acceleration structure as well as an instance transform
plus information required to index into the shader bindings.
The top-level acceleration structure is what is bound to the acceleration
descriptor, for example to trace inside the shader in the ray tracing
pipeline.

Acceleration structures are represented by sname:VkAccelerationStructureKHR
handles:

include::{generated}/api/handles/VkAccelerationStructureKHR.adoc[]
--

ifdef::VK_NV_ray_tracing[]
[open,refpage='VkAccelerationStructureNV',desc='Opaque handle to an acceleration structure object',type='handles']
--
:refpage: VkAccelerationStructureNV

Acceleration structures for the `apiext:VK_NV_ray_tracing extension` are
represented by the similar sname:VkAccelerationStructureNV handles:

include::{generated}/api/handles/VkAccelerationStructureNV.adoc[]
--

[open,refpage='vkCreateAccelerationStructureNV',desc='Create a new acceleration structure object',type='protos']
--
:refpage: vkCreateAccelerationStructureNV

To create acceleration structures, call:

include::{generated}/api/protos/vkCreateAccelerationStructureNV.adoc[]

  * pname:device is the logical device that creates the buffer object.
  * pname:pCreateInfo is a pointer to a
    slink:VkAccelerationStructureCreateInfoNV structure containing
    parameters affecting creation of the acceleration structure.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pAccelerationStructure is a pointer to a
    slink:VkAccelerationStructureNV handle in which the resulting
    acceleration structure object is returned.

Similarly to other objects in Vulkan, the acceleration structure creation
merely creates an object with a specific "`shape`" as specified by the
information in slink:VkAccelerationStructureInfoNV and pname:compactedSize
in pname:pCreateInfo.

Once memory has been bound to the acceleration structure using
flink:vkBindAccelerationStructureMemoryNV, that memory is populated by calls
to flink:vkCmdBuildAccelerationStructureNV and
flink:vkCmdCopyAccelerationStructureNV.

Acceleration structure creation uses the count and type information from the
geometries, but does not use the data references in the structures.

include::{generated}/validity/protos/vkCreateAccelerationStructureNV.adoc[]
--

[open,refpage='VkAccelerationStructureCreateInfoNV',desc='Structure specifying the parameters of a newly created acceleration structure object',type='structs']
--
:refpage: VkAccelerationStructureCreateInfoNV

The sname:VkAccelerationStructureCreateInfoNV structure is defined as:

include::{generated}/api/structs/VkAccelerationStructureCreateInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:compactedSize is the size from the result of
    flink:vkCmdWriteAccelerationStructuresPropertiesNV if this acceleration
    structure is going to be the target of a compacting copy.
  * pname:info is the slink:VkAccelerationStructureInfoNV structure
    specifying further parameters of the created acceleration structure.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureCreateInfoNV-compactedSize-02421]]
    If pname:compactedSize is not `0` then both pname:info.geometryCount and
    pname:info.instanceCount must: be `0`
****

include::{generated}/validity/structs/VkAccelerationStructureCreateInfoNV.adoc[]
--

[open,refpage='VkAccelerationStructureInfoNV',desc='Structure specifying the parameters of acceleration structure object',type='structs']
--
:refpage: VkAccelerationStructureInfoNV

The sname:VkAccelerationStructureInfoNV structure is defined as:

include::{generated}/api/structs/VkAccelerationStructureInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:type is a elink:VkAccelerationStructureTypeNV value specifying the
    type of acceleration structure that will be created.
  * pname:flags is a bitmask of elink:VkBuildAccelerationStructureFlagBitsNV
    specifying additional parameters of the acceleration structure.
  * pname:instanceCount specifies the number of instances that will be in
    the new acceleration structure.
  * pname:geometryCount specifies the number of geometries that will be in
    the new acceleration structure.
  * pname:pGeometries is a pointer to an array of pname:geometryCount
    slink:VkGeometryNV structures containing the scene data being passed
    into the acceleration structure.

sname:VkAccelerationStructureInfoNV contains information that is used both
for acceleration structure creation with
flink:vkCreateAccelerationStructureNV and in combination with the actual
geometric data to build the acceleration structure with
flink:vkCmdBuildAccelerationStructureNV.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureInfoNV-geometryCount-02422]]
    pname:geometryCount must: be less than or equal to
    slink:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxGeometryCount
  * [[VUID-VkAccelerationStructureInfoNV-instanceCount-02423]]
    pname:instanceCount must: be less than or equal to
    slink:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxInstanceCount
  * [[VUID-VkAccelerationStructureInfoNV-maxTriangleCount-02424]]
    The total number of triangles in all geometries must: be less than or
    equal to
    slink:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxTriangleCount
  * [[VUID-VkAccelerationStructureInfoNV-type-02425]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV then
    pname:geometryCount must: be `0`
  * [[VUID-VkAccelerationStructureInfoNV-type-02426]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV
    then pname:instanceCount must: be `0`
  * [[VUID-VkAccelerationStructureInfoNV-type-02786]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV
    then the pname:geometryType member of each geometry in pname:pGeometries
    must: be the same
ifdef::VK_KHR_acceleration_structure[]
  * [[VUID-VkAccelerationStructureInfoNV-type-04623]]
    pname:type must: not be ename:VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR
endif::VK_KHR_acceleration_structure[]
  * [[VUID-VkAccelerationStructureInfoNV-flags-02592]]
    If pname:flags has the
    ename:VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV bit set,
    then it must: not have the
    ename:VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV bit set
  * [[VUID-VkAccelerationStructureInfoNV-scratch-02781]]
    pname:scratch must: have been created with
    ename:VK_BUFFER_USAGE_RAY_TRACING_BIT_NV usage flag
  * [[VUID-VkAccelerationStructureInfoNV-instanceData-02782]]
    If pname:instanceData is not dlink:VK_NULL_HANDLE, pname:instanceData
    must: have been created with ename:VK_BUFFER_USAGE_RAY_TRACING_BIT_NV
    usage flag
****

include::{generated}/validity/structs/VkAccelerationStructureInfoNV.adoc[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='vkCreateAccelerationStructureKHR',desc='Create a new acceleration structure object',type='protos']
--
:refpage: vkCreateAccelerationStructureKHR

To create an acceleration structure, call:

include::{generated}/api/protos/vkCreateAccelerationStructureKHR.adoc[]

  * pname:device is the logical device that creates the acceleration
    structure object.
  * pname:pCreateInfo is a pointer to a
    slink:VkAccelerationStructureCreateInfoKHR structure containing
    parameters affecting creation of the acceleration structure.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pAccelerationStructure is a pointer to a
    sname:VkAccelerationStructureKHR handle in which the resulting
    acceleration structure object is returned.

Similar to other objects in Vulkan, the acceleration structure creation
merely creates an object with a specific "`shape`".
The type and quantity of geometry that can be built into an acceleration
structure is determined by the parameters of
slink:VkAccelerationStructureCreateInfoKHR.

The acceleration structure data is stored in the object referred to by
sname:VkAccelerationStructureCreateInfoKHR::pname:buffer.
Once memory has been bound to that buffer, it must: be populated by
acceleration structure build or acceleration structure copy commands such as
flink:vkCmdBuildAccelerationStructuresKHR,
flink:vkBuildAccelerationStructuresKHR,
flink:vkCmdCopyAccelerationStructureKHR, and
flink:vkCopyAccelerationStructureKHR.

[NOTE]
====
The expected usage for a trace capture/replay tool is that it will serialize
and later deserialize the acceleration structure data using acceleration
structure copy commands.
During capture the tool will use
flink:vkCopyAccelerationStructureToMemoryKHR or
flink:vkCmdCopyAccelerationStructureToMemoryKHR with a pname:mode of
ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR, and
flink:vkCopyMemoryToAccelerationStructureKHR or
flink:vkCmdCopyMemoryToAccelerationStructureKHR with a pname:mode of
ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR during replay.
====

[NOTE]
====
Memory does not need to be bound to the underlying buffer when
flink:vkCreateAccelerationStructureKHR is called.
====

The input buffers passed to acceleration structure build commands will be
referenced by the implementation for the duration of the command.
After the command completes, the acceleration structure may: hold a
reference to any acceleration structure specified by an active instance
contained therein.
Apart from this referencing, acceleration structures must: be fully
self-contained.
The application can: reuse or free any memory which was used by the command
as an input or as scratch without affecting the results of ray traversal.

.Valid Usage
****
  * [[VUID-vkCreateAccelerationStructureKHR-accelerationStructure-03611]]
    The <<features-accelerationStructure,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructure>>
    feature must: be enabled
  * [[VUID-vkCreateAccelerationStructureKHR-deviceAddress-03488]]
    If slink:VkAccelerationStructureCreateInfoKHR::pname:deviceAddress is
    not zero, the <<features-accelerationStructureCaptureReplay,
    pname:accelerationStructureCaptureReplay>> feature must: be enabled
  * [[VUID-vkCreateAccelerationStructureKHR-device-03489]]
    If pname:device was created with multiple physical devices, then the
    <<features-bufferDeviceAddressMultiDevice,
    pname:bufferDeviceAddressMultiDevice>> feature must: be enabled
****

include::{generated}/validity/protos/vkCreateAccelerationStructureKHR.adoc[]
--

[open,refpage='VkAccelerationStructureCreateInfoKHR',desc='Structure specifying the parameters of a newly created acceleration structure object',type='structs']
--
:refpage: VkAccelerationStructureCreateInfoKHR

The sname:VkAccelerationStructureCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkAccelerationStructureCreateInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:createFlags is a bitmask of
    elink:VkAccelerationStructureCreateFlagBitsKHR specifying additional
    creation parameters of the acceleration structure.
  * pname:buffer is the buffer on which the acceleration structure will be
    stored.
  * pname:offset is an offset in bytes from the base address of the buffer
    at which the acceleration structure will be stored, and must: be a
    multiple of `256`.
  * pname:size is the size required for the acceleration structure.
  * pname:type is a elink:VkAccelerationStructureTypeKHR value specifying
    the type of acceleration structure that will be created.
  * pname:deviceAddress is the device address requested for the acceleration
    structure if the <<features-accelerationStructureCaptureReplay,
    pname:accelerationStructureCaptureReplay>> feature is being used.
    If pname:deviceAddress is zero, no specific address is requested.

Applications should: avoid creating acceleration structures with
application-provided addresses and implementation-provided addresses in the
same process, to reduce the likelihood of
ename:VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR errors.

[NOTE]
====
The expected usage for this is that a trace capture/replay tool will add the
ename:VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT flag to all buffers
that use ename:VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, and will add
ename:VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT to all buffers used as
storage for an acceleration structure where pname:deviceAddress is not zero.
This also means that the tool will need to add
ename:VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT to memory allocations to allow
the flag to be set where the application may not have otherwise required it.
During capture the tool will save the queried opaque device addresses in the
trace.
During replay, the buffers will be created specifying the original address
so any address values stored in the trace data will remain valid.

Implementations are expected to separate such buffers in the GPU address
space so normal allocations will avoid using these addresses.
Apps/tools should avoid mixing app-provided and implementation-provided
addresses for buffers created with
ename:VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT, to avoid address
space allocation conflicts.
====


Applications should: create an acceleration structure with a specific
elink:VkAccelerationStructureTypeKHR other than
ename:VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR.

[NOTE]
====
ename:VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR is intended to be used by
API translation layers.
This can be used at acceleration structure creation time in cases where the
actual acceleration structure type (top or bottom) is not yet known.
The actual acceleration structure type must be specified as
ename:VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR or
ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR when the build is
performed.
====

If the acceleration structure will be the target of a build operation, the
required size for an acceleration structure can: be queried with
flink:vkGetAccelerationStructureBuildSizesKHR.
If the acceleration structure is going to be the target of a compacting
copy, flink:vkCmdWriteAccelerationStructuresPropertiesKHR or
flink:vkWriteAccelerationStructuresPropertiesKHR can: be used to obtain the
compacted size required.

ifdef::VK_NV_ray_tracing_motion_blur[]
If the acceleration structure will be the target of a build operation with
ename:VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV it must: include
ename:VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV in pname:createFlags
and include slink:VkAccelerationStructureMotionInfoNV as an extension
structure in pname:pNext with the number of instances as metadata for the
object.
endif::VK_NV_ray_tracing_motion_blur[]

.Valid Usage
****
  * [[VUID-VkAccelerationStructureCreateInfoKHR-deviceAddress-03612]]
    If pname:deviceAddress is not zero, pname:createFlags must: include
    ename:VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
  * [[VUID-VkAccelerationStructureCreateInfoKHR-deviceAddress-09488]]
    If pname:deviceAddress is not zero, it must: have been retrieved from an
    identically created acceleration structure, except for pname:buffer and
    pname:deviceAddress
  * [[VUID-VkAccelerationStructureCreateInfoKHR-deviceAddress-09489]]
    If pname:deviceAddress is not zero, pname:buffer must: have been created
    identically to the pname:buffer used to create the acceleration
    structure from which pname:deviceAddress was retrieved, except for
    slink:VkBufferOpaqueCaptureAddressCreateInfo::pname:opaqueCaptureAddress
  * [[VUID-VkAccelerationStructureCreateInfoKHR-deviceAddress-09490]]
    If pname:deviceAddress is not zero, pname:buffer must: have been created
    with a
    slink:VkBufferOpaqueCaptureAddressCreateInfo::pname:opaqueCaptureAddress
    that was retrieved from flink:vkGetBufferOpaqueCaptureAddress for the
    pname:buffer that was used to create the acceleration structure from
    which pname:deviceAddress was retrieved
  * [[VUID-VkAccelerationStructureCreateInfoKHR-createFlags-03613]]
    If pname:createFlags includes
    ename:VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
    slink:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructureCaptureReplay
    must: be ename:VK_TRUE
  * [[VUID-VkAccelerationStructureCreateInfoKHR-buffer-03614]]
    pname:buffer must: have been created with a pname:usage value containing
    ename:VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR
  * [[VUID-VkAccelerationStructureCreateInfoKHR-buffer-03615]]
    pname:buffer must: not have been created with
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT
  * [[VUID-VkAccelerationStructureCreateInfoKHR-offset-03616]]
    The sum of pname:offset and pname:size must: be less than the size of
    pname:buffer
  * [[VUID-VkAccelerationStructureCreateInfoKHR-offset-03734]]
    pname:offset must: be a multiple of `256` bytes
ifdef::VK_NV_ray_tracing_motion_blur[]
  * [[VUID-VkAccelerationStructureCreateInfoKHR-createFlags-04954]]
    If ename:VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV is set in
    pname:createFlags and pname:type is
    ename:VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, one member of the
    pname:pNext chain must: be a pointer to a valid instance of
    slink:VkAccelerationStructureMotionInfoNV
  * [[VUID-VkAccelerationStructureCreateInfoKHR-createFlags-04955]]
    If any geometry includes
    sname:VkAccelerationStructureGeometryMotionTrianglesDataNV then
    pname:createFlags must: contain
    ename:VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_EXT_descriptor_buffer[]
  * [[VUID-VkAccelerationStructureCreateInfoKHR-createFlags-08108]]
    If pname:createFlags includes
    ename:VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
    the <<features-descriptorBufferCaptureReplay,
    pname:descriptorBufferCaptureReplay>> feature must: be enabled
  * [[VUID-VkAccelerationStructureCreateInfoKHR-pNext-08109]]
    If the pname:pNext chain includes a
    slink:VkOpaqueCaptureDescriptorDataCreateInfoEXT structure,
    pname:createFlags must: contain
    ename:VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
endif::VK_EXT_descriptor_buffer[]
****

include::{generated}/validity/structs/VkAccelerationStructureCreateInfoKHR.adoc[]
--

ifdef::VK_NV_ray_tracing_motion_blur[]
[open,refpage='VkAccelerationStructureMotionInfoNV',desc='Structure specifying the parameters of a newly created acceleration structure object',type='structs']
--
:refpage: VkAccelerationStructureMotionInfoNV

The sname:VkAccelerationStructureMotionInfoNV structure is defined as:

include::{generated}/api/structs/VkAccelerationStructureMotionInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:maxInstances is the maximum number of instances that may: be used
    in the motion top-level acceleration structure.
  * pname:flags is 0 and reserved for future use.

include::{generated}/validity/structs/VkAccelerationStructureMotionInfoNV.adoc[]
--

[open,refpage='VkAccelerationStructureMotionInfoFlagsNV',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkAccelerationStructureMotionInfoFlagsNV.adoc[]

tname:VkAccelerationStructureMotionInfoFlagsNV is a bitmask type for setting
a mask, but is currently reserved for future use.
--
endif::VK_NV_ray_tracing_motion_blur[]

[open,refpage='vkGetAccelerationStructureBuildSizesKHR',desc='Retrieve the required size for an acceleration structure',type='protos']
--
:refpage: vkGetAccelerationStructureBuildSizesKHR

To get the build sizes for an acceleration structure, call:

include::{generated}/api/protos/vkGetAccelerationStructureBuildSizesKHR.adoc[]

  * pname:device is the logical device that will be used for creating the
    acceleration structure.
  * pname:buildType defines whether host or device operations (or both) are
    being queried for.
  * pname:pBuildInfo is a pointer to a
    slink:VkAccelerationStructureBuildGeometryInfoKHR structure describing
    parameters of a build operation.
  * pname:pMaxPrimitiveCounts is a pointer to an array of
    pname:pBuildInfo->geometryCount code:uint32_t values defining the number
    of primitives built into each geometry.
  * pname:pSizeInfo is a pointer to a
    slink:VkAccelerationStructureBuildSizesInfoKHR structure which returns
    the size required for an acceleration structure and the sizes required
    for the scratch buffers, given the build parameters.

The pname:srcAccelerationStructure, pname:dstAccelerationStructure, and
pname:mode members of pname:pBuildInfo are ignored.
Any slink:VkDeviceOrHostAddressKHR or slink:VkDeviceOrHostAddressConstKHR
members of pname:pBuildInfo are ignored by this command, except that the
pname:hostAddress member of
slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:transformData
will be examined to check if it is `NULL`.

An acceleration structure created with the pname:accelerationStructureSize
returned by this command supports any build or update with a
slink:VkAccelerationStructureBuildGeometryInfoKHR structure and array of
slink:VkAccelerationStructureBuildRangeInfoKHR structures subject to the
following properties:

  * The build command is a host build command, and pname:buildType is
    ename:VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR or
    ename:VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR
  * The build command is a device build command, and pname:buildType is
    ename:VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR or
    ename:VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR
  * For slink:VkAccelerationStructureBuildGeometryInfoKHR:
  ** Its pname:type, and pname:flags members are equal to
     pname:pBuildInfo->type and pname:pBuildInfo->flags, respectively.
  ** pname:geometryCount is less than or equal to
     pname:pBuildInfo->geometryCount.
  ** For each element of either pname:pGeometries or pname:ppGeometries at a
     given index, its pname:geometryType member is equal to
     pname:pBuildInfo->geometryType.
  ** For each element of either pname:pGeometries or pname:ppGeometries at a
     given index, its pname:flags member is equal to the corresponding
     member of the same element in pname:pBuildInfo.
  ** For each element of either pname:pGeometries or pname:ppGeometries at a
     given index, with a pname:geometryType member equal to
     ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, the pname:vertexFormat and
     pname:indexType members of pname:geometry.triangles are equal to the
     corresponding members of the same element in pname:pBuildInfo.
  ** For each element of either pname:pGeometries or pname:ppGeometries at a
     given index, with a pname:geometryType member equal to
     ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, the pname:maxVertex member of
     pname:geometry.triangles is less than or equal to the corresponding
     member of the same element in pname:pBuildInfo.
  ** For each element of either pname:pGeometries or pname:ppGeometries at a
     given index, with a pname:geometryType member equal to
     ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if the applicable address in the
     pname:transformData member of pname:geometry.triangles is not `NULL`,
     the corresponding pname:transformData.hostAddress parameter in
     pname:pBuildInfo is not `NULL`.
  * For each slink:VkAccelerationStructureBuildRangeInfoKHR corresponding to
    the slink:VkAccelerationStructureBuildGeometryInfoKHR:
  ** Its pname:primitiveCount member is less than or equal to the
     corresponding element of pname:pMaxPrimitiveCounts.
ifdef::VK_EXT_opacity_micromap[]
  ** For each element of either pname:pGeometries or pname:ppGeometries at a
     given index, with a pname:geometryType member equal to
     ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if the pname:pNext chain contains
     slink:VkAccelerationStructureTrianglesOpacityMicromapEXT the
     corresponding member of pname:pBuildInfo also contains
     slink:VkAccelerationStructureTrianglesOpacityMicromapEXT and with an
     equivalent pname:micromap.
endif::VK_EXT_opacity_micromap[]
ifdef::VK_NV_displacement_micromap[]
  ** For each element of either pname:pGeometries or pname:ppGeometries at a
     given index, with a pname:geometryType member equal to
     ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if the pname:pNext chain contains
     slink:VkAccelerationStructureTrianglesDisplacementMicromapNV the
     corresponding member of pname:pBuildInfo also contains
     slink:VkAccelerationStructureTrianglesDisplacementMicromapNV and with
     an equivalent pname:micromap.
endif::VK_NV_displacement_micromap[]

Similarly, the pname:updateScratchSize value will support any build command
specifying the ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR
pname:mode under the above conditions, and the pname:buildScratchSize value
will support any build command specifying the
ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR pname:mode under the
above conditions.

.Valid Usage
****
  * [[VUID-vkGetAccelerationStructureBuildSizesKHR-accelerationStructure-08933]]
    The <<features-accelerationStructure,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructure>>
    feature must: be enabled
  * [[VUID-vkGetAccelerationStructureBuildSizesKHR-device-03618]]
    If pname:device was created with multiple physical devices, then the
    <<features-bufferDeviceAddressMultiDevice,
    pname:bufferDeviceAddressMultiDevice>> feature must: be enabled
  * [[VUID-vkGetAccelerationStructureBuildSizesKHR-pBuildInfo-03619]]
    If pname:pBuildInfo->geometryCount is not `0`, pname:pMaxPrimitiveCounts
    must: be a valid pointer to an array of pname:pBuildInfo->geometryCount
    code:uint32_t values
  * [[VUID-vkGetAccelerationStructureBuildSizesKHR-pBuildInfo-03785]]
    If pname:pBuildInfo->pGeometries or pname:pBuildInfo->ppGeometries has a
    pname:geometryType of ename:VK_GEOMETRY_TYPE_INSTANCES_KHR, each
    pname:pMaxPrimitiveCounts[i] must: be less than or equal to
    slink:VkPhysicalDeviceAccelerationStructurePropertiesKHR::pname:maxInstanceCount
****

include::{generated}/validity/protos/vkGetAccelerationStructureBuildSizesKHR.adoc[]
--

[open,refpage='VkAccelerationStructureBuildSizesInfoKHR',desc='Structure specifying build sizes for an acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureBuildSizesInfoKHR

The sname:VkAccelerationStructureBuildSizesInfoKHR structure describes the
required build sizes for an acceleration structure and scratch buffers and
is defined as:

include::{generated}/api/structs/VkAccelerationStructureBuildSizesInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:accelerationStructureSize is the size in bytes required in a
    slink:VkAccelerationStructureKHR for a build or update operation.
  * pname:updateScratchSize is the size in bytes required in a scratch
    buffer for an update operation.
  * pname:buildScratchSize is the size in bytes required in a scratch buffer
    for a build operation.

include::{generated}/validity/structs/VkAccelerationStructureBuildSizesInfoKHR.adoc[]
--
endif::VK_KHR_acceleration_structure[]

[open,refpage='VkAccelerationStructureTypeKHR',desc='Type of acceleration structure',type='enums',alias='VkAccelerationStructureTypeNV']
--
:refpage: VkAccelerationStructureTypeKHR

Values which can: be set in
ifdef::VK_KHR_acceleration_structure[]
slink:VkAccelerationStructureCreateInfoKHR::pname:type
endif::VK_KHR_acceleration_structure[]
ifdef::VK_KHR_acceleration_structure+VK_NV_ray_tracing[or]
ifdef::VK_NV_ray_tracing[]
slink:VkAccelerationStructureInfoNV::pname:type
endif::VK_NV_ray_tracing[]
specifying the type of acceleration structure, are:

include::{generated}/api/enums/VkAccelerationStructureTypeKHR.adoc[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/enums/VkAccelerationStructureTypeNV.adoc[]
endif::VK_NV_ray_tracing[]

  * ename:VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR is a top-level
    acceleration structure containing instance data referring to
    bottom-level acceleration structures.
  * ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR is a bottom-level
    acceleration structure containing the AABBs or geometry to be
    intersected.
  * ename:VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR is an acceleration
    structure whose type is determined at build time used for special
    circumstances.
    In these cases, the acceleration structure type is not known at creation
    time, but must: be specified at build time as either top or bottom.
--

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='VkAccelerationStructureCreateFlagBitsKHR',desc='Bitmask specifying additional creation parameters for acceleration structure',type='enums']
--
Bits which can: be set in
slink:VkAccelerationStructureCreateInfoKHR::pname:createFlags, specifying
additional creation parameters for acceleration structures, are:

include::{generated}/api/enums/VkAccelerationStructureCreateFlagBitsKHR.adoc[]

  * ename:VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
    specifies that the acceleration structure's address can: be saved and
    reused on a subsequent run.
ifdef::VK_EXT_descriptor_buffer[]
  * ename:VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
    specifies that the acceleration structure can: be used with descriptor
    buffers when capturing and replaying (e.g. for trace capture and
    replay), see slink:VkOpaqueCaptureDescriptorDataCreateInfoEXT for more
    detail.
endif::VK_EXT_descriptor_buffer[]
--

[open,refpage='VkAccelerationStructureCreateFlagsKHR',desc='Bitmask of VkAccelerationStructureCreateFlagBitsKHR',type='flags']
--
include::{generated}/api/flags/VkAccelerationStructureCreateFlagsKHR.adoc[]

tname:VkAccelerationStructureCreateFlagsKHR is a bitmask type for setting a
mask of zero or more elink:VkAccelerationStructureCreateFlagBitsKHR.
--
endif::VK_KHR_acceleration_structure[]

[open,refpage='VkBuildAccelerationStructureFlagBitsKHR',desc='Bitmask specifying additional parameters for acceleration structure builds',type='enums',alias='VkBuildAccelerationStructureFlagBitsNV']
--
:refpage: VkBuildAccelerationStructureFlagBitsKHR

Bits which can: be set in
ifdef::VK_KHR_acceleration_structure[]
slink:VkAccelerationStructureBuildGeometryInfoKHR::pname:flags
endif::VK_KHR_acceleration_structure[]
ifdef::VK_KHR_acceleration_structure+VK_NV_ray_tracing[or]
ifdef::VK_NV_ray_tracing[]
slink:VkAccelerationStructureInfoNV::pname:flags
endif::VK_NV_ray_tracing[]
specifying additional parameters for acceleration structure builds, are:

include::{generated}/api/enums/VkBuildAccelerationStructureFlagBitsKHR.adoc[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/enums/VkBuildAccelerationStructureFlagBitsNV.adoc[]
endif::VK_NV_ray_tracing[]

  * ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR indicates
    that the specified acceleration structure can: be updated with
ifdef::VK_KHR_acceleration_structure[]
    a pname:mode of ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR in
    slink:VkAccelerationStructureBuildGeometryInfoKHR
endif::VK_KHR_acceleration_structure[]
ifdef::VK_KHR_acceleration_structure+VK_NV_ray_tracing[or]
ifdef::VK_NV_ray_tracing[]
    an pname:update of ename:VK_TRUE in
    flink:vkCmdBuildAccelerationStructureNV
endif::VK_NV_ray_tracing[]
    .
  * ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR indicates
    that the specified acceleration structure can: act as the source for a
    copy acceleration structure command with pname:mode of
    ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR to produce a
    compacted acceleration structure.
  * ename:VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR
    indicates that the given acceleration structure build should: prioritize
    trace performance over build time.
  * ename:VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR
    indicates that the given acceleration structure build should: prioritize
    build time over trace performance.
  * ename:VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR indicates that
    this acceleration structure should: minimize the size of the scratch
    memory and the final result acceleration structure, potentially at the
    expense of build time or trace performance.
ifdef::VK_EXT_opacity_micromap[]
  * ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT
    indicates that the opacity micromaps associated with the specified
    acceleration structure may: change with an acceleration structure
    update.
  * ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT
    indicates that the data of the opacity micromaps associated with the
    specified acceleration structure may: change with an acceleration
    structure update.
  * ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT
    indicates that the specified acceleration structure may: be referenced
    in an instance with
    ename:VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT set.
endif::VK_EXT_opacity_micromap[]
ifdef::VK_KHR_ray_tracing_position_fetch[]
  * ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR indicates
    that the specified acceleration structure can: be used when fetching the
    vertex positions of a hit triangle.
endif::VK_KHR_ray_tracing_position_fetch[]
ifdef::VK_NV_displacement_micromap[]
  * ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV
    indicates that the displacement micromaps associated with the specified
    acceleration structure may: change with an acceleration structure
    update.
endif::VK_NV_displacement_micromap[]

[NOTE]
====
ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR and
ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR may: take
more time and memory than a normal build, and so should: only be used when
those features are needed.
====

[NOTE]
====
ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR and
ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR are allowed
to be used together.
In that case, the result of the compaction copy is used as the source of a
build with pname:mode of
ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR to perform the
compacted update.
====
--

[open,refpage='VkBuildAccelerationStructureFlagsKHR',desc='Bitmask of VkBuildAccelerationStructureFlagBitsKHR',type='flags',alias='VkBuildAccelerationStructureFlagsNV']
--
:refpage: VkBuildAccelerationStructureFlagsKHR

include::{generated}/api/flags/VkBuildAccelerationStructureFlagsKHR.adoc[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/flags/VkBuildAccelerationStructureFlagsNV.adoc[]
endif::VK_NV_ray_tracing[]

tname:VkBuildAccelerationStructureFlagsKHR is a bitmask type for setting a
mask of zero or more elink:VkBuildAccelerationStructureFlagBitsKHR.
--

ifdef::VK_NV_ray_tracing[]
[open,refpage='VkGeometryNV',desc='Structure specifying a geometry in a bottom-level acceleration structure',type='structs']
--
:refpage: VkGeometryNV

The sname:VkGeometryNV structure describes geometry in a bottom-level
acceleration structure and is defined as:

include::{generated}/api/structs/VkGeometryNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:geometryType specifies the elink:VkGeometryTypeKHR which this
    geometry refers to.
  * pname:geometry contains the geometry data as described in
    slink:VkGeometryDataNV.
  * pname:flags has elink:VkGeometryFlagBitsKHR describing options for this
    geometry.

.Valid Usage
****
  * [[VUID-VkGeometryNV-geometryType-03503]]
    pname:geometryType must: be ename:VK_GEOMETRY_TYPE_TRIANGLES_NV or
    ename:VK_GEOMETRY_TYPE_AABBS_NV
****

include::{generated}/validity/structs/VkGeometryNV.adoc[]
--
endif::VK_NV_ray_tracing[]

[open,refpage='VkGeometryTypeKHR',desc='Enum specifying which type of geometry is provided',type='enums',alias='VkGeometryTypeNV']
--
:refpage: VkGeometryTypeKHR

Geometry types are specified by elink:VkGeometryTypeKHR, which takes values:

include::{generated}/api/enums/VkGeometryTypeKHR.adoc[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/enums/VkGeometryTypeNV.adoc[]
endif::VK_NV_ray_tracing[]

  * ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR specifies a geometry type
    consisting of triangles.
  * ename:VK_GEOMETRY_TYPE_AABBS_KHR specifies a geometry type consisting of
    axis-aligned bounding boxes.
ifdef::VK_KHR_acceleration_structure[]
  * ename:VK_GEOMETRY_TYPE_INSTANCES_KHR specifies a geometry type
    consisting of acceleration structure instances.
endif::VK_KHR_acceleration_structure[]
--

[open,refpage='VkGeometryFlagBitsKHR',desc='Bitmask specifying additional parameters for a geometry',type='enums',alias='VkGeometryFlagBitsNV']
--
:refpage: VkGeometryFlagBitsKHR

Bits specifying additional parameters for geometries in acceleration
structure builds, are:

include::{generated}/api/enums/VkGeometryFlagBitsKHR.adoc[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/enums/VkGeometryFlagBitsNV.adoc[]
endif::VK_NV_ray_tracing[]

  * ename:VK_GEOMETRY_OPAQUE_BIT_KHR indicates that this geometry does not
    invoke the any-hit shaders even if present in a hit group.
  * ename:VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR indicates that
    the implementation must: only call the any-hit shader a single time for
    each primitive in this geometry.
    If this bit is absent an implementation may: invoke the any-hit shader
    more than once for this geometry.
--

[open,refpage='VkGeometryFlagsKHR',desc='Bitmask of VkGeometryFlagBitsKHR',type='flags',alias='VkGeometryFlagsNV']
--
:refpage: VkGeometryFlagsKHR

include::{generated}/api/flags/VkGeometryFlagsKHR.adoc[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/flags/VkGeometryFlagsNV.adoc[]
endif::VK_NV_ray_tracing[]

tname:VkGeometryFlagsKHR is a bitmask type for setting a mask of zero or
more elink:VkGeometryFlagBitsKHR.
--

ifdef::VK_NV_ray_tracing[]
[open,refpage='VkGeometryDataNV',desc='Structure specifying geometry in a bottom-level acceleration structure',type='structs']
--
:refpage: VkGeometryDataNV

The sname:VkGeometryDataNV structure specifies geometry in a bottom-level
acceleration structure and is defined as:

include::{generated}/api/structs/VkGeometryDataNV.adoc[]

  * pname:triangles contains triangle data if
    slink:VkGeometryNV::pname:geometryType is
    ename:VK_GEOMETRY_TYPE_TRIANGLES_NV.
  * pname:aabbs contains axis-aligned bounding box data if
    slink:VkGeometryNV::pname:geometryType is
    ename:VK_GEOMETRY_TYPE_AABBS_NV.

include::{generated}/validity/structs/VkGeometryDataNV.adoc[]
--

[open,refpage='VkGeometryTrianglesNV',desc='Structure specifying a triangle geometry in a bottom-level acceleration structure',type='structs']
--
:refpage: VkGeometryTrianglesNV

The sname:VkGeometryTrianglesNV structure specifies triangle geometry in a
bottom-level acceleration structure and is defined as:

include::{generated}/api/structs/VkGeometryTrianglesNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:vertexData is the buffer containing vertex data for this geometry.
  * pname:vertexOffset is the offset in bytes within pname:vertexData
    containing vertex data for this geometry.
  * pname:vertexCount is the number of valid vertices.
  * pname:vertexStride is the stride in bytes between each vertex.
  * pname:vertexFormat is a elink:VkFormat describing the format of each
    vertex element.
  * pname:indexData is the buffer containing index data for this geometry.
  * pname:indexOffset is the offset in bytes within pname:indexData
    containing index data for this geometry.
  * pname:indexCount is the number of indices to include in this geometry.
  * pname:indexType is a elink:VkIndexType describing the format of each
    index.
  * pname:transformData is an optional buffer containing an
    slink:VkTransformMatrixNV structure defining a transformation to be
    applied to this geometry.
  * pname:transformOffset is the offset in bytes in pname:transformData of
    the transform information described above.

If pname:indexType is ename:VK_INDEX_TYPE_NONE_NV, then this structure
describes a set of triangles determined by pname:vertexCount.
Otherwise, this structure describes a set of indexed triangles determined by
pname:indexCount.

.Valid Usage
****
  * [[VUID-VkGeometryTrianglesNV-vertexOffset-02428]]
    pname:vertexOffset must: be less than the size of pname:vertexData
  * [[VUID-VkGeometryTrianglesNV-vertexOffset-02429]]
    pname:vertexOffset must: be a multiple of the component size of
    pname:vertexFormat
  * [[VUID-VkGeometryTrianglesNV-vertexFormat-02430]]
    pname:vertexFormat must: be one of ename:VK_FORMAT_R32G32B32_SFLOAT,
    ename:VK_FORMAT_R32G32_SFLOAT, ename:VK_FORMAT_R16G16B16_SFLOAT,
    ename:VK_FORMAT_R16G16_SFLOAT, ename:VK_FORMAT_R16G16_SNORM, or
    ename:VK_FORMAT_R16G16B16_SNORM
  * [[VUID-VkGeometryTrianglesNV-vertexStride-03818]]
    pname:vertexStride must: be less than or equal to [eq]#2^32^-1#
  * [[VUID-VkGeometryTrianglesNV-indexOffset-02431]]
    pname:indexOffset must: be less than the size of pname:indexData
  * [[VUID-VkGeometryTrianglesNV-indexOffset-02432]]
    pname:indexOffset must: be a multiple of the element size of
    pname:indexType
  * [[VUID-VkGeometryTrianglesNV-indexType-02433]]
    pname:indexType must: be ename:VK_INDEX_TYPE_UINT16,
    ename:VK_INDEX_TYPE_UINT32, or ename:VK_INDEX_TYPE_NONE_NV
  * [[VUID-VkGeometryTrianglesNV-indexData-02434]]
    pname:indexData must: be dlink:VK_NULL_HANDLE if pname:indexType is
    ename:VK_INDEX_TYPE_NONE_NV
  * [[VUID-VkGeometryTrianglesNV-indexData-02435]]
    pname:indexData must: be a valid sname:VkBuffer handle if
    pname:indexType is not ename:VK_INDEX_TYPE_NONE_NV
  * [[VUID-VkGeometryTrianglesNV-indexCount-02436]]
    pname:indexCount must: be `0` if pname:indexType is
    ename:VK_INDEX_TYPE_NONE_NV
  * [[VUID-VkGeometryTrianglesNV-transformOffset-02437]]
    pname:transformOffset must: be less than the size of pname:transformData
  * [[VUID-VkGeometryTrianglesNV-transformOffset-02438]]
    pname:transformOffset must: be a multiple of `16`
****

include::{generated}/validity/structs/VkGeometryTrianglesNV.adoc[]
--

[open,refpage='VkGeometryAABBNV',desc='Structure specifying axis-aligned bounding box geometry in a bottom-level acceleration structure',type='structs']
--
:refpage: VkGeometryAABBNV

The sname:VkGeometryAABBNV structure specifies axis-aligned bounding box
geometry in a bottom-level acceleration structure, and is defined as:

include::{generated}/api/structs/VkGeometryAABBNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:aabbData is the buffer containing axis-aligned bounding box data.
  * pname:numAABBs is the number of AABBs in this geometry.
  * pname:stride is the stride in bytes between AABBs in pname:aabbData.
  * pname:offset is the offset in bytes of the first AABB in pname:aabbData.

The AABB data in memory is six 32-bit floats consisting of the minimum x, y,
and z values followed by the maximum x, y, and z values.

.Valid Usage
****
  * [[VUID-VkGeometryAABBNV-offset-02439]]
    pname:offset must: be less than the size of pname:aabbData
  * [[VUID-VkGeometryAABBNV-offset-02440]]
    pname:offset must: be a multiple of `8`
  * [[VUID-VkGeometryAABBNV-stride-02441]]
    pname:stride must: be a multiple of `8`
****

include::{generated}/validity/structs/VkGeometryAABBNV.adoc[]
--
endif::VK_NV_ray_tracing[]

[open,refpage='vkDestroyAccelerationStructureKHR',desc='Destroy an acceleration structure object',type='protos']
--
:refpage: vkDestroyAccelerationStructureKHR

To destroy an acceleration structure, call:

ifdef::VK_KHR_acceleration_structure[]
include::{generated}/api/protos/vkDestroyAccelerationStructureKHR.adoc[]
endif::VK_KHR_acceleration_structure[]

  * pname:device is the logical device that destroys the acceleration
    structure.
  * pname:accelerationStructure is the acceleration structure to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyAccelerationStructureKHR-accelerationStructure-08934]]
    The <<features-accelerationStructure,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructure>>
    feature must: be enabled
  * [[VUID-vkDestroyAccelerationStructureKHR-accelerationStructure-02442]]
    All submitted commands that refer to pname:accelerationStructure must:
    have completed execution
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkDestroyAccelerationStructureKHR-accelerationStructure-02443]]
    If sname:VkAllocationCallbacks were provided when
    pname:accelerationStructure was created, a compatible set of callbacks
    must: be provided here
  * [[VUID-vkDestroyAccelerationStructureKHR-accelerationStructure-02444]]
    If no sname:VkAllocationCallbacks were provided when
    pname:accelerationStructure was created, pname:pAllocator must: be
    `NULL`
endif::VKSC_VERSION_1_0[]
****

include::{generated}/validity/protos/vkDestroyAccelerationStructureKHR.adoc[]
--

ifdef::VK_NV_ray_tracing[]
[open,refpage='vkDestroyAccelerationStructureNV',desc='Destroy an acceleration structure object',type='protos']
--
:refpage: vkDestroyAccelerationStructureNV

To destroy an acceleration structure, call:

include::{generated}/api/protos/vkDestroyAccelerationStructureNV.adoc[]

  * pname:device is the logical device that destroys the buffer.
  * pname:accelerationStructure is the acceleration structure to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyAccelerationStructureNV-accelerationStructure-03752]]
    All submitted commands that refer to pname:accelerationStructure must:
    have completed execution
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkDestroyAccelerationStructureNV-accelerationStructure-03753]]
    If sname:VkAllocationCallbacks were provided when
    pname:accelerationStructure was created, a compatible set of callbacks
    must: be provided here
  * [[VUID-vkDestroyAccelerationStructureNV-accelerationStructure-03754]]
    If no sname:VkAllocationCallbacks were provided when
    pname:accelerationStructure was created, pname:pAllocator must: be
    `NULL`
endif::VKSC_VERSION_1_0[]
****

include::{generated}/validity/protos/vkDestroyAccelerationStructureNV.adoc[]
--

[open,refpage='vkGetAccelerationStructureMemoryRequirementsNV',desc='Get acceleration structure memory requirements',type='protos']
--
:refpage: vkGetAccelerationStructureMemoryRequirementsNV

An acceleration structure has memory requirements for the structure object
itself, scratch space for the build, and scratch space for the update.

Scratch space is allocated as a sname:VkBuffer, so for
ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV
and
ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV
the pname:pMemoryRequirements->alignment and
pname:pMemoryRequirements->memoryTypeBits values returned by this call must:
be filled with zero, and should: be ignored by the application.

To query the memory requirements, call:

include::{generated}/api/protos/vkGetAccelerationStructureMemoryRequirementsNV.adoc[]

  * pname:device is the logical device on which the acceleration structure
    was created.
  * pname:pInfo is a pointer to a
    slink:VkAccelerationStructureMemoryRequirementsInfoNV structure
    specifying the acceleration structure to get memory requirements for.
  * pname:pMemoryRequirements is a pointer to a
    slink:VkMemoryRequirements2KHR structure in which the requested
    acceleration structure memory requirements are returned.

include::{generated}/validity/protos/vkGetAccelerationStructureMemoryRequirementsNV.adoc[]
--

[open,refpage='VkAccelerationStructureMemoryRequirementsInfoNV',desc='Structure specifying acceleration to query for memory requirements',type='structs']
--
:refpage: VkAccelerationStructureMemoryRequirementsInfoNV

The sname:VkAccelerationStructureMemoryRequirementsInfoNV structure is
defined as:

include::{generated}/api/structs/VkAccelerationStructureMemoryRequirementsInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:type selects the type of memory requirement being queried.
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV
    returns the memory requirements for the object itself.
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV
    returns the memory requirements for the scratch memory when doing a
    build.
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV
    returns the memory requirements for the scratch memory when doing an
    update.
  * pname:accelerationStructure is the acceleration structure to be queried
    for memory requirements.

include::{generated}/validity/structs/VkAccelerationStructureMemoryRequirementsInfoNV.adoc[]
--

[open,refpage='VkAccelerationStructureMemoryRequirementsTypeNV',desc='Acceleration structure memory requirement type',type='enums']
--
:refpage: VkAccelerationStructureMemoryRequirementsTypeNV

Possible values of pname:type in
sname:VkAccelerationStructureMemoryRequirementsInfoNV are:,

include::{generated}/api/enums/VkAccelerationStructureMemoryRequirementsTypeNV.adoc[]

  * ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV
    requests the memory requirement for the sname:VkAccelerationStructureNV
    backing store.
  * ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV
    requests the memory requirement for scratch space during the initial
    build.
  * ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV
    requests the memory requirement for scratch space during an update.
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='VkAccelerationStructureBuildTypeKHR',desc='Acceleration structure build type',type='enums']
--
:refpage: VkAccelerationStructureBuildTypeKHR

Possible values of pname:buildType in
flink:vkGetAccelerationStructureBuildSizesKHR are:

include::{generated}/api/enums/VkAccelerationStructureBuildTypeKHR.adoc[]

  * ename:VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR requests the memory
    requirement for operations performed by the host.
  * ename:VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR requests the
    memory requirement for operations performed by the device.
  * ename:VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR requests
    the memory requirement for operations performed by either the host, or
    the device.
--
endif::VK_KHR_acceleration_structure[]

ifdef::VK_NV_ray_tracing[]
[open,refpage='vkBindAccelerationStructureMemoryNV',desc='Bind acceleration structure memory',type='protos']
--
:refpage: vkBindAccelerationStructureMemoryNV

To attach memory to one or more acceleration structures at a time, call:

include::{generated}/api/protos/vkBindAccelerationStructureMemoryNV.adoc[]

  * pname:device is the logical device that owns the acceleration structures
    and memory.
  * pname:bindInfoCount is the number of elements in pname:pBindInfos.
  * pname:pBindInfos is a pointer to an array of
    slink:VkBindAccelerationStructureMemoryInfoNV structures describing
    acceleration structures and memory to bind.

include::{generated}/validity/protos/vkBindAccelerationStructureMemoryNV.adoc[]
--

[open,refpage='VkBindAccelerationStructureMemoryInfoNV',desc='Structure specifying acceleration structure memory binding',type='structs']
--
:refpage: VkBindAccelerationStructureMemoryInfoNV

The sname:VkBindAccelerationStructureMemoryInfoNV structure is defined as:

include::{generated}/api/structs/VkBindAccelerationStructureMemoryInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:accelerationStructure is the acceleration structure to be attached
    to memory.
  * pname:memory is a sname:VkDeviceMemory object describing the device
    memory to attach.
  * pname:memoryOffset is the start offset of the region of memory that is
    to be bound to the acceleration structure.
    The number of bytes returned in the
    slink:VkMemoryRequirements::pname:size member in pname:memory, starting
    from pname:memoryOffset bytes, will be bound to the specified
    acceleration structure.
  * pname:deviceIndexCount is the number of elements in
    pname:pDeviceIndices.
  * pname:pDeviceIndices is a pointer to an array of device indices.

.Valid Usage
****
  * [[VUID-VkBindAccelerationStructureMemoryInfoNV-accelerationStructure-03620]]
    pname:accelerationStructure must: not already be backed by a memory
    object
  * [[VUID-VkBindAccelerationStructureMemoryInfoNV-memoryOffset-03621]]
    pname:memoryOffset must: be less than the size of pname:memory
  * [[VUID-VkBindAccelerationStructureMemoryInfoNV-memory-03622]]
    pname:memory must: have been allocated using one of the memory types
    allowed in the pname:memoryTypeBits member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetAccelerationStructureMemoryRequirementsNV with
    pname:accelerationStructure and pname:type of
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV
  * [[VUID-VkBindAccelerationStructureMemoryInfoNV-memoryOffset-03623]]
    pname:memoryOffset must: be an integer multiple of the pname:alignment
    member of the slink:VkMemoryRequirements structure returned from a call
    to flink:vkGetAccelerationStructureMemoryRequirementsNV with
    pname:accelerationStructure and pname:type of
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV
  * [[VUID-VkBindAccelerationStructureMemoryInfoNV-size-03624]]
    The pname:size member of the sname:VkMemoryRequirements structure
    returned from a call to
    flink:vkGetAccelerationStructureMemoryRequirementsNV with
    pname:accelerationStructure and pname:type of
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV must:
    be less than or equal to the size of pname:memory minus
    pname:memoryOffset
****

include::{generated}/validity/structs/VkBindAccelerationStructureMemoryInfoNV.adoc[]
--

[open,refpage='vkGetAccelerationStructureHandleNV',desc='Get opaque acceleration structure handle',type='protos']
--
:refpage: vkGetAccelerationStructureHandleNV

To allow constructing geometry instances with device code if desired, we
need to be able to query an opaque handle for an acceleration structure.
This handle is a value of 8 bytes.
To get this handle, call:

include::{generated}/api/protos/vkGetAccelerationStructureHandleNV.adoc[]

  * pname:device is the logical device that owns the acceleration
    structures.
  * pname:accelerationStructure is the acceleration structure.
  * pname:dataSize is the size in bytes of the buffer pointed to by
    pname:pData.
  * pname:pData is a pointer to an application-allocated buffer where the
    results will be written.

.Valid Usage
****
  * [[VUID-vkGetAccelerationStructureHandleNV-dataSize-02240]]
    pname:dataSize must: be large enough to contain the result of the query,
    as described above
  * [[VUID-vkGetAccelerationStructureHandleNV-accelerationStructure-02787]]
    pname:accelerationStructure must: be bound completely and contiguously
    to a single sname:VkDeviceMemory object via
    flink:vkBindAccelerationStructureMemoryNV
****

include::{generated}/validity/protos/vkGetAccelerationStructureHandleNV.adoc[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='vkGetAccelerationStructureDeviceAddressKHR',desc='Query an address of an acceleration structure',type='protos']
--
:refpage: vkGetAccelerationStructureDeviceAddressKHR

To query the 64-bit device address for an acceleration structure, call:

include::{generated}/api/protos/vkGetAccelerationStructureDeviceAddressKHR.adoc[]

  * pname:device is the logical device that the acceleration structure was
    created on.
  * pname:pInfo is a pointer to a
    slink:VkAccelerationStructureDeviceAddressInfoKHR structure specifying
    the acceleration structure to retrieve an address for.

The 64-bit return value is an address of the acceleration structure, which
can be used for device and shader operations that involve acceleration
structures, such as
ifdef::VK_KHR_ray_tracing_pipeline,VK_KHR_ray_query[]
ray traversal and
endif::VK_KHR_ray_tracing_pipeline,VK_KHR_ray_query[]
acceleration structure building.

If the acceleration structure was created with a non-zero value of
slink:VkAccelerationStructureCreateInfoKHR::pname:deviceAddress, the return
value will be the same address.

If the acceleration structure was created with a pname:type of
ename:VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR, the returned address must:
be consistent with the relative offset to other acceleration structures with
pname:type ename:VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR allocated with
the same slink:VkBuffer.
That is, the difference in returned addresses between the two must: be the
same as the difference in offsets provided at acceleration structure
creation.

The returned address must: be aligned to 256 bytes.

[NOTE]
====
The acceleration structure device address may: be different from the buffer
device address corresponding to the acceleration structure's start offset in
its storage buffer for acceleration structure types other than
ename:VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR.
====

.Valid Usage
****
  * [[VUID-vkGetAccelerationStructureDeviceAddressKHR-accelerationStructure-08935]]
    The <<features-accelerationStructure,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructure>>
    feature must: be enabled
  * [[VUID-vkGetAccelerationStructureDeviceAddressKHR-device-03504]]
    If pname:device was created with multiple physical devices, then the
    <<features-bufferDeviceAddressMultiDevice,
    pname:bufferDeviceAddressMultiDevice>> feature must: be enabled
  * [[VUID-vkGetAccelerationStructureDeviceAddressKHR-pInfo-09541]]
    If the buffer on which pname:pInfo->accelerationStructure was placed is
    non-sparse then it must: be bound completely and contiguously to a
    single sname:VkDeviceMemory object
  * [[VUID-vkGetAccelerationStructureDeviceAddressKHR-pInfo-09542]]
    The buffer on which pname:pInfo->accelerationStructure was placed must:
    have been created with the
    ename:VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT usage flag
****

include::{generated}/validity/protos/vkGetAccelerationStructureDeviceAddressKHR.adoc[]
--

[open,refpage='VkAccelerationStructureDeviceAddressInfoKHR',desc='Structure specifying the acceleration structure to query an address for',type='structs']
--
:refpage: VkAccelerationStructureDeviceAddressInfoKHR

The sname:VkAccelerationStructureDeviceAddressInfoKHR structure is defined
as:

include::{generated}/api/structs/VkAccelerationStructureDeviceAddressInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:accelerationStructure specifies the acceleration structure whose
    address is being queried.

include::{generated}/validity/structs/VkAccelerationStructureDeviceAddressInfoKHR.adoc[]
--
endif::VK_KHR_acceleration_structure[]
endif::VK_NV_ray_tracing,VK_KHR_acceleration_structure[]


ifdef::VK_EXT_opacity_micromap[]
[[resources-micromaps]]
== Micromaps

[open,refpage='VkMicromapEXT',desc='Opaque handle to a micromap object',type='handles']
--
:refpage: VkMicromapEXT

Micromaps are opaque data structures that are built by the implementation to
encode sub-triangle data to be included in an acceleration structure.

Micromaps are represented by sname:VkMicromapEXT handles:

include::{generated}/api/handles/VkMicromapEXT.adoc[]
--


[open,refpage='vkCreateMicromapEXT',desc='Create a new micromap object',type='protos']
--
:refpage: vkCreateMicromapEXT

To create a micromap, call:

include::{generated}/api/protos/vkCreateMicromapEXT.adoc[]

  * pname:device is the logical device that creates the acceleration
    structure object.
  * pname:pCreateInfo is a pointer to a slink:VkMicromapCreateInfoEXT
    structure containing parameters affecting creation of the micromap.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pMicromap is a pointer to a sname:VkMicromapEXT handle in which
    the resulting micromap object is returned.

Similar to other objects in Vulkan, the micromap creation merely creates an
object with a specific "`shape`".
The type and quantity of geometry that can be built into a micromap is
determined by the parameters of slink:VkMicromapCreateInfoEXT.

The micromap data is stored in the object referred to by
sname:VkMicromapCreateInfoEXT::pname:buffer.
Once memory has been bound to that buffer, it must: be populated by micromap
build or micromap copy commands such as flink:vkCmdBuildMicromapsEXT,
flink:vkBuildMicromapsEXT, flink:vkCmdCopyMicromapEXT, and
flink:vkCopyMicromapEXT.

[NOTE]
====
The expected usage for a trace capture/replay tool is that it will serialize
and later deserialize the micromap data using micromap copy commands.
During capture the tool will use flink:vkCopyMicromapToMemoryEXT or
flink:vkCmdCopyMicromapToMemoryEXT with a pname:mode of
ename:VK_COPY_MICROMAP_MODE_SERIALIZE_EXT, and
flink:vkCopyMemoryToMicromapEXT or flink:vkCmdCopyMemoryToMicromapEXT with a
pname:mode of ename:VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT during replay.
====

The input buffers passed to micromap build commands will be referenced by
the implementation for the duration of the command.
Micromaps must: be fully self-contained.
The application can: reuse or free any memory which was used by the command
as an input or as scratch without affecting the results of a subsequent
acceleration structure build using the micromap or traversal of that
acceleration structure.

.Valid Usage
****
  * [[VUID-vkCreateMicromapEXT-micromap-07430]]
    The <<features-micromap, pname:micromap>> feature must: be enabled
  * [[VUID-vkCreateMicromapEXT-deviceAddress-07431]]
    If slink:VkMicromapCreateInfoEXT::pname:deviceAddress is not zero, the
    <<features-micromapCaptureReplay, pname:micromapCaptureReplay>> feature
    must: be enabled
  * [[VUID-vkCreateMicromapEXT-device-07432]]
    If pname:device was created with multiple physical devices, then the
    <<features-bufferDeviceAddressMultiDevice,
    pname:bufferDeviceAddressMultiDevice>> feature must: be enabled
****

include::{generated}/validity/protos/vkCreateMicromapEXT.adoc[]
--

[open,refpage='VkMicromapCreateInfoEXT',desc='Structure specifying the parameters of a newly created micromap object',type='structs']
--
:refpage: VkMicromapCreateInfoEXT

The sname:VkMicromapCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkMicromapCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:createFlags is a bitmask of elink:VkMicromapCreateFlagBitsEXT
    specifying additional creation parameters of the micromap.
  * pname:buffer is the buffer on which the micromap will be stored.
  * pname:offset is an offset in bytes from the base address of the buffer
    at which the micromap will be stored, and must: be a multiple of `256`.
  * pname:size is the size required for the micromap.
  * pname:type is a elink:VkMicromapTypeEXT value specifying the type of
    micromap that will be created.
  * pname:deviceAddress is the device address requested for the micromap if
    the <<features-micromapCaptureReplay, pname:micromapCaptureReplay>>
    feature is being used.

If pname:deviceAddress is zero, no specific address is requested.

If pname:deviceAddress is not zero, pname:deviceAddress must: be an address
retrieved from an identically created micromap on the same implementation.
The micromap must: also be placed on an identically created pname:buffer and
at the same pname:offset.

Applications should: avoid creating micromaps with application-provided
addresses and implementation-provided addresses in the same process, to
reduce the likelihood of ename:VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR
errors.

[NOTE]
====
The expected usage for this is that a trace capture/replay tool will add the
ename:VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT flag to all buffers
that use ename:VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, and will add
ename:VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT to all buffers used as
storage for a micromap where pname:deviceAddress is not zero.
This also means that the tool will need to add
ename:VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT to memory allocations to allow
the flag to be set where the application may not have otherwise required it.
During capture the tool will save the queried opaque device addresses in the
trace.
During replay, the buffers will be created specifying the original address
so any address values stored in the trace data will remain valid.

Implementations are expected to separate such buffers in the GPU address
space so normal allocations will avoid using these addresses.
Apps/tools should avoid mixing app-provided and implementation-provided
addresses for buffers created with
ename:VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT, to avoid address
space allocation conflicts.
====


If the micromap will be the target of a build operation, the required size
for a micromap can: be queried with flink:vkGetMicromapBuildSizesEXT.

.Valid Usage
****
  * [[VUID-VkMicromapCreateInfoEXT-deviceAddress-07433]]
    If pname:deviceAddress is not zero, pname:createFlags must: include
    ename:VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT
  * [[VUID-VkMicromapCreateInfoEXT-createFlags-07434]]
    If pname:createFlags includes
    ename:VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT,
    slink:VkPhysicalDeviceOpacityMicromapFeaturesEXT::pname:micromapCaptureReplay
    must: be ename:VK_TRUE
  * [[VUID-VkMicromapCreateInfoEXT-buffer-07435]]
    pname:buffer must: have been created with a pname:usage value containing
    ename:VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT
  * [[VUID-VkMicromapCreateInfoEXT-buffer-07436]]
    pname:buffer must: not have been created with
    ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT
  * [[VUID-VkMicromapCreateInfoEXT-offset-07437]]
    The sum of pname:offset and pname:size must: be less than the size of
    pname:buffer
  * [[VUID-VkMicromapCreateInfoEXT-offset-07438]]
    pname:offset must: be a multiple of `256` bytes
****

include::{generated}/validity/structs/VkMicromapCreateInfoEXT.adoc[]
--

[open,refpage='vkGetMicromapBuildSizesEXT',desc='Retrieve the required size for a micromap',type='protos']
--
:refpage: vkGetMicromapBuildSizesEXT

To get the build sizes for a micromap, call:

include::{generated}/api/protos/vkGetMicromapBuildSizesEXT.adoc[]

  * pname:device is the logical device that will be used for creating the
    micromap.
  * pname:buildType defines whether host or device operations (or both) are
    being queried for.
  * pname:pBuildInfo is a pointer to a slink:VkMicromapBuildInfoEXT
    structure describing parameters of a build operation.
  * pname:pSizeInfo is a pointer to a slink:VkMicromapBuildSizesInfoEXT
    structure which returns the size required for a micromap and the sizes
    required for the scratch buffers, given the build parameters.

The pname:dstMicromap and pname:mode members of pname:pBuildInfo are
ignored.
Any slink:VkDeviceOrHostAddressKHR members of pname:pBuildInfo are ignored
by this command.

A micromap created with the pname:micromapSize returned by this command
supports any build with a slink:VkMicromapBuildInfoEXT structure subject to
the following properties:

  * The build command is a host build command, and pname:buildType is
    ename:VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR or
    ename:VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR
  * The build command is a device build command, and pname:buildType is
    ename:VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR or
    ename:VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR
  * For slink:VkMicromapBuildInfoEXT:
  ** Its pname:type, and pname:flags members are equal to
     pname:pBuildInfo->type and pname:pBuildInfo->flags, respectively.
  ** The sum of usage information in either pname:pUsageCounts or
     pname:ppUsageCounts is equal to the sum of usage information in either
     pname:pBuildInfo->pUsageCounts or pname:pBuildInfo->ppUsageCounts.

Similarly, the pname:buildScratchSize value will support any build command
specifying the ename:VK_BUILD_MICROMAP_MODE_BUILD_EXT pname:mode under the
above conditions.

.Valid Usage
****
  * [[VUID-vkGetMicromapBuildSizesEXT-dstMicromap-09180]]
    slink:VkMicromapBuildInfoEXT::pname:dstMicromap must: have been created
    from pname:device
  * [[VUID-vkGetMicromapBuildSizesEXT-micromap-07439]]
    The <<features-micromap, pname:micromap>> feature must: be enabled
  * [[VUID-vkGetMicromapBuildSizesEXT-device-07440]]
    If pname:device was created with multiple physical devices, then the
    <<features-bufferDeviceAddressMultiDevice,
    pname:bufferDeviceAddressMultiDevice>> feature must: be enabled
****

include::{generated}/validity/protos/vkGetMicromapBuildSizesEXT.adoc[]
--

[open,refpage='VkMicromapBuildSizesInfoEXT',desc='Structure specifying build sizes for a micromap',type='structs']
--
:refpage: VkMicromapBuildSizesInfoEXT

The sname:VkMicromapBuildSizesInfoEXT structure describes the required build
sizes for a micromap and scratch buffers and is defined as:

include::{generated}/api/structs/VkMicromapBuildSizesInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:micromapSize is the size in bytes required in a
    slink:VkMicromapEXT for a build or update operation.
  * pname:buildScratchSize is the size in bytes required in a scratch buffer
    for a build operation.
  * pname:discardable indicates whether or not the micromap object may be
    destroyed after an acceleration structure build or update.
    A false value means that acceleration structures built with this
    micromap may: contain references to the data contained therein, and the
    application must: not destroy the micromap until ray traversal has
    concluded.
    A true value means that the information in the micromap will be copied
    by value into the acceleration structure, and the micromap may: be
    destroyed after the acceleration structure build concludes.

include::{generated}/validity/structs/VkMicromapBuildSizesInfoEXT.adoc[]
--

[open,refpage='VkMicromapTypeEXT',desc='Type of micromap',type='enums']
--
:refpage: VkMicromapTypeEXT

Values which can: be set in slink:VkMicromapCreateInfoEXT::pname:type
specifying the type of micromap, are:

include::{generated}/api/enums/VkMicromapTypeEXT.adoc[]

  * ename:VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT is a micromap containing
    data to control the opacity of a triangle.
ifdef::VK_NV_displacement_micromap[]
  * ename:VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV is a micromap containing
    data to control the displacement of subtriangles within a triangle.
endif::VK_NV_displacement_micromap[]

--

[open,refpage='VkMicromapCreateFlagBitsEXT',desc='Bitmask specifying additional creation parameters for micromap',type='enums']
--
Bits which can: be set in slink:VkMicromapCreateInfoEXT::pname:createFlags,
specifying additional creation parameters for micromaps, are:

include::{generated}/api/enums/VkMicromapCreateFlagBitsEXT.adoc[]

  * ename:VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT specifies
    that the micromap's address can: be saved and reused on a subsequent
    run.
--

[open,refpage='VkMicromapCreateFlagsEXT',desc='Bitmask of VkMicromapCreateFlagBitsEXT',type='flags']
--
include::{generated}/api/flags/VkMicromapCreateFlagsEXT.adoc[]

tname:VkMicromapCreateFlagsEXT is a bitmask type for setting a mask of zero
or more elink:VkMicromapCreateFlagBitsEXT.
--

[open,refpage='VkBuildMicromapFlagBitsEXT',desc='Bitmask specifying additional parameters for micromap builds',type='enums',alias='VkBuildMicromapFlagBitsNV']
--
:refpage: VkBuildMicromapFlagBitsEXT

Bits which can: be set in slink:VkMicromapBuildInfoEXT::pname:flags
specifying additional parameters for micromap builds, are:

include::{generated}/api/enums/VkBuildMicromapFlagBitsEXT.adoc[]

  * ename:VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT indicates that the
    given micromap build should: prioritize trace performance over build
    time.
  * ename:VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT indicates that the
    given micromap build should: prioritize build time over trace
    performance.
--

[open,refpage='VkBuildMicromapFlagsEXT',desc='Bitmask of VkBuildMicromapFlagBitsEXT',type='flags',alias='VkBuildMicromapFlagsNV']
--
:refpage: VkBuildMicromapFlagsEXT

include::{generated}/api/flags/VkBuildMicromapFlagsEXT.adoc[]

tname:VkBuildMicromapFlagsEXT is a bitmask type for setting a mask of zero
or more elink:VkBuildMicromapFlagBitsEXT.
--

[open,refpage='vkDestroyMicromapEXT',desc='Destroy a micromap object',type='protos']
--
:refpage: vkDestroyMicromapEXT

To destroy a micromap, call:

include::{generated}/api/protos/vkDestroyMicromapEXT.adoc[]

  * pname:device is the logical device that destroys the micromap.
  * pname:micromap is the micromap to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyMicromapEXT-micromap-07441]]
    All submitted commands that refer to pname:micromap must: have completed
    execution
  * [[VUID-vkDestroyMicromapEXT-micromap-07442]]
    If sname:VkAllocationCallbacks were provided when pname:micromap was
    created, a compatible set of callbacks must: be provided here
  * [[VUID-vkDestroyMicromapEXT-micromap-07443]]
    If no sname:VkAllocationCallbacks were provided when pname:micromap was
    created, pname:pAllocator must: be `NULL`
****

include::{generated}/validity/protos/vkDestroyMicromapEXT.adoc[]
--

endif::VK_EXT_opacity_micromap[]


[[resources-association]]
== Resource Memory Association

Resources are initially created as _virtual allocations_ with no backing
memory.
Device memory is allocated separately (see <<memory-device>>) and then
associated with the resource.
This association is done differently for sparse and non-sparse resources.

Resources created with any of the sparse creation flags are considered
sparse resources.
Resources created without these flags are non-sparse.
The details on resource memory association for sparse resources is described
in <<sparsememory>>.

Non-sparse resources must: be bound completely and contiguously to a single
sname:VkDeviceMemory object before the resource is passed as a parameter to
any of the following operations:

  * creating image or buffer views
  * updating descriptor sets
  * recording commands in a command buffer

Once bound, the memory binding is immutable for the lifetime of the
resource.

ifdef::VK_VERSION_1_1,VK_KHR_device_group[]

In a logical device representing more than one physical device, buffer and
image resources exist on all physical devices but can: be bound to memory
differently on each.
Each such replicated resource is an _instance_ of the resource.
For sparse resources, each instance can: be bound to memory arbitrarily
differently.
For non-sparse resources, each instance can: either be bound to the local or
a peer instance of the memory, or for images can: be bound to rectangular
regions from the local and/or peer instances.
When a resource is used in a descriptor set, each physical device interprets
the descriptor according to its own instance's binding to memory.

[NOTE]
====
There are no new copy commands to transfer data between physical devices.
Instead, an application can: create a resource with a peer mapping and use
it as the source or destination of a transfer command executed by a single
physical device to copy the data from one physical device to another.
====

endif::VK_VERSION_1_1,VK_KHR_device_group[]

[open,refpage='vkGetBufferMemoryRequirements',desc='Returns the memory requirements for specified Vulkan object',type='protos']
--
To determine the memory requirements for a buffer resource, call:

include::{generated}/api/protos/vkGetBufferMemoryRequirements.adoc[]

  * pname:device is the logical device that owns the buffer.
  * pname:buffer is the buffer to query.
  * pname:pMemoryRequirements is a pointer to a slink:VkMemoryRequirements
    structure in which the memory requirements of the buffer object are
    returned.

include::{generated}/validity/protos/vkGetBufferMemoryRequirements.adoc[]
--

[open,refpage='vkGetImageMemoryRequirements',desc='Returns the memory requirements for specified Vulkan object',type='protos']
--
ifndef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
To determine the memory requirements for an image resource, call:
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
To determine the memory requirements for an image resource which is not
created with the ename:VK_IMAGE_CREATE_DISJOINT_BIT flag set, call:
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

include::{generated}/api/protos/vkGetImageMemoryRequirements.adoc[]

  * pname:device is the logical device that owns the image.
  * pname:image is the image to query.
  * pname:pMemoryRequirements is a pointer to a slink:VkMemoryRequirements
    structure in which the memory requirements of the image object are
    returned.

.Valid Usage
****
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-vkGetImageMemoryRequirements-image-01588]]
    pname:image must: not have been created with the
    ename:VK_IMAGE_CREATE_DISJOINT_BIT flag set
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
  * [[VUID-vkGetImageMemoryRequirements-image-04004]]
    If pname:image was created with the
    ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID
    external memory handle type, then pname:image must: be bound to memory
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
  * [[VUID-vkGetImageMemoryRequirements-image-08960]]
    If pname:image was created with the
    ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX external
    memory handle type, then pname:image must: be bound to memory
endif::VK_QNX_external_memory_screen_buffer[]
****

include::{generated}/validity/protos/vkGetImageMemoryRequirements.adoc[]
--

[open,refpage='VkMemoryRequirements',desc='Structure specifying memory requirements',type='structs']
--
The sname:VkMemoryRequirements structure is defined as:

include::{generated}/api/structs/VkMemoryRequirements.adoc[]

  * pname:size is the size, in bytes, of the memory allocation required: for
    the resource.
  * pname:alignment is the alignment, in bytes, of the offset within the
    allocation required: for the resource.
  * pname:memoryTypeBits is a bitmask and contains one bit set for every
    supported memory type for the resource.
    Bit `i` is set if and only if the memory type `i` in the
    sname:VkPhysicalDeviceMemoryProperties structure for the physical device
    is supported for the resource.

include::{generated}/validity/structs/VkMemoryRequirements.adoc[]
--

ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
The precise size of images that will be bound to external Android hardware
buffer memory is unknown until the memory has been imported or allocated, so
applications must: not call flink:vkGetImageMemoryRequirements or
flink:vkGetImageMemoryRequirements2 with such a slink:VkImage before it has
been bound to memory.
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
For this reason, applications also must: not call
flink:vkGetDeviceImageMemoryRequirements with a slink:VkImageCreateInfo
describing an external Android hardware buffer.
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]
When importing Android hardware buffer memory, the pname:allocationSize can:
be determined by calling flink:vkGetAndroidHardwareBufferPropertiesANDROID.
When allocating new memory for a slink:VkImage that can: be exported to an
Android hardware buffer, the memory's pname:allocationSize must: be zero;
the actual size will be determined by the dedicated image's parameters.
After the memory has been allocated, the amount of space allocated from the
memory's heap can: be obtained by getting the image's memory requirements or
by calling flink:vkGetAndroidHardwareBufferPropertiesANDROID with the
Android hardware buffer exported from the memory.

When allocating new memory for a slink:VkBuffer that can: be exported to an
Android hardware buffer an application may: still call
flink:vkGetBufferMemoryRequirements or flink:vkGetBufferMemoryRequirements2
with slink:VkBuffer before it has been bound to memory.
endif::VK_ANDROID_external_memory_android_hardware_buffer[]

ifdef::VK_KHR_external_memory_win32[]
If the resource being queried was created with the
ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, or
ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT external memory
handle type, the value of pname:size has no meaning and should: be ignored.
endif::VK_KHR_external_memory_win32[]

The implementation guarantees certain properties about the memory
requirements returned by
ifdef::VK_KHR_get_memory_requirements2[]
flink:vkGetBufferMemoryRequirements2, flink:vkGetImageMemoryRequirements2,
endif::VK_KHR_get_memory_requirements2[]
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
flink:vkGetDeviceBufferMemoryRequirements,
flink:vkGetDeviceImageMemoryRequirements,
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]
flink:vkGetBufferMemoryRequirements and flink:vkGetImageMemoryRequirements:

  * The pname:memoryTypeBits member always contains at least one bit set.
  * If pname:buffer is a sname:VkBuffer not created with the
    ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT or
    ename:VK_BUFFER_CREATE_PROTECTED_BIT bits set, or if pname:image is a
    <<glossary-linear-resource,linear>> image that was not created with the
    ename:VK_IMAGE_CREATE_PROTECTED_BIT bit set, then the
    pname:memoryTypeBits member always contains at least one bit set
    corresponding to a sname:VkMemoryType with a pname:propertyFlags that
    has both the ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT bit and the
    ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT bit set.
    In other words, mappable coherent memory can: always be attached to
    these objects.
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
  * If pname:buffer was created with
    slink:VkExternalMemoryBufferCreateInfo::pname:handleTypes set to `0` or
    pname:image was created with
    slink:VkExternalMemoryImageCreateInfo::pname:handleTypes set to `0`, the
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
ifndef::VK_VERSION_1_1,VK_KHR_external_memory[]
  * The
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
    pname:memoryTypeBits member always contains at least one bit set
    corresponding to a sname:VkMemoryType with a pname:propertyFlags that
    has the ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT bit set.
  * The pname:memoryTypeBits member is identical for all sname:VkBuffer
    objects created with the same value for the pname:flags and pname:usage
    members in the slink:VkBufferCreateInfo structure
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
    and the pname:handleTypes member of the
    slink:VkExternalMemoryBufferCreateInfo structure
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
    passed to flink:vkCreateBuffer.
    Further, if code:usage1 and code:usage2 of type tlink:VkBufferUsageFlags
    are such that the bits set in code:usage2 are a subset of the bits set
    in code:usage1, and they have the same
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
    pname:flags and
    slink:VkExternalMemoryBufferCreateInfo::pname:handleTypes,
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
ifndef::VK_VERSION_1_1,VK_KHR_external_memory[]
    pname:flags,
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
    then the bits set in pname:memoryTypeBits returned for code:usage1 must:
    be a subset of the bits set in pname:memoryTypeBits returned for
    code:usage2, for all values of pname:flags.
  * The pname:alignment member is a power of two.
  * The pname:alignment member is identical for all sname:VkBuffer objects
    created with the same combination of values for the pname:usage and
    pname:flags members in the slink:VkBufferCreateInfo structure passed to
    flink:vkCreateBuffer.
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
  * If the <<features-maintenance4, pname:maintenance4>> feature is enabled,
    then the pname:alignment member is identical for all sname:VkImage
    objects created with the same combination of values for the pname:flags,
    pname:imageType, pname:format, pname:extent, pname:mipLevels,
    pname:arrayLayers, pname:samples, pname:tiling and pname:usage members
    in the slink:VkImageCreateInfo structure passed to flink:vkCreateImage.
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]
  * The pname:alignment member satisfies the buffer descriptor offset
    alignment requirements associated with the sname:VkBuffer's pname:usage:
  ** If pname:usage included ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT
     or ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, pname:alignment
     must: be an integer multiple of
     sname:VkPhysicalDeviceLimits::pname:minTexelBufferOffsetAlignment.
  ** If pname:usage included ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
     pname:alignment must: be an integer multiple of
     sname:VkPhysicalDeviceLimits::pname:minUniformBufferOffsetAlignment.
  ** If pname:usage included ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
     pname:alignment must: be an integer multiple of
     sname:VkPhysicalDeviceLimits::pname:minStorageBufferOffsetAlignment.
  * For images created with a color format, the pname:memoryTypeBits member
    is identical for all sname:VkImage objects created with the same
    combination of values for the pname:tiling member, the
    ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT bit
ifdef::VK_VERSION_1_1[]
    and ename:VK_IMAGE_CREATE_PROTECTED_BIT bit
endif::VK_VERSION_1_1[]
    of the pname:flags member,
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
    the ename:VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT bit of the
    pname:flags member,
endif::VK_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_EXT_host_image_copy[]
    the ename:VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT bit of the pname:usage
    member if the
    slink:VkPhysicalDeviceHostImageCopyPropertiesEXT::pname:identicalMemoryTypeRequirements
    property is ename:VK_FALSE,
endif::VK_EXT_host_image_copy[]
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
    pname:handleTypes member of slink:VkExternalMemoryImageCreateInfo,
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
    and the ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT of the pname:usage
    member in the slink:VkImageCreateInfo structure passed to
    flink:vkCreateImage.
  * For images created with a depth/stencil format, the pname:memoryTypeBits
    member is identical for all sname:VkImage objects created with the same
    combination of values for the pname:format member, the pname:tiling
    member, the ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT bit
ifdef::VK_VERSION_1_1[]
    and ename:VK_IMAGE_CREATE_PROTECTED_BIT bit
endif::VK_VERSION_1_1[]
    of the pname:flags member,
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
    the ename:VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT bit of the
    pname:flags member,
endif::VK_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_EXT_host_image_copy[]
    the ename:VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT bit of the pname:usage
    member if the
    slink:VkPhysicalDeviceHostImageCopyPropertiesEXT::pname:identicalMemoryTypeRequirements
    property is ename:VK_FALSE,
endif::VK_EXT_host_image_copy[]
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
    pname:handleTypes member of slink:VkExternalMemoryImageCreateInfo,
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
    and the ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT of the pname:usage
    member in the slink:VkImageCreateInfo structure passed to
    flink:vkCreateImage.
  * If the memory requirements are for a sname:VkImage, the
    pname:memoryTypeBits member must: not refer to a sname:VkMemoryType with
    a pname:propertyFlags that has the
    ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set if the pname:image
    did not have ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT bit set in
    the pname:usage member of the slink:VkImageCreateInfo structure passed
    to flink:vkCreateImage.
  * If the memory requirements are for a sname:VkBuffer, the
    pname:memoryTypeBits member must: not refer to a sname:VkMemoryType with
    a pname:propertyFlags that has the
    ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set.
+
[NOTE]
====
The implication of this requirement is that lazily allocated memory is
disallowed for buffers in all cases.
====
  * The pname:size member is identical for all sname:VkBuffer objects
    created with the same combination of creation parameters specified in
    slink:VkBufferCreateInfo and its pname:pNext chain.
  * The pname:size member is identical for all sname:VkImage objects created
    with the same combination of creation parameters specified in
    slink:VkImageCreateInfo and its pname:pNext chain.
+
[NOTE]
====
This, however, does not imply that they interpret the contents of the bound
memory identically with each other.
ifdef::VK_VERSION_1_1,VK_KHR_bind_memory2[]
That additional guarantee, however, can: be explicitly requested using
ename:VK_IMAGE_CREATE_ALIAS_BIT.
endif::VK_VERSION_1_1,VK_KHR_bind_memory2[]
====
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
  * If the <<features-maintenance4, pname:maintenance4>> feature is enabled,
    these additional guarantees apply:
  ** For a sname:VkBuffer, the pname:size memory requirement is never
     greater than that of another sname:VkBuffer created with a greater or
     equal pname:size specified in slink:VkBufferCreateInfo, all other
     creation parameters being identical.
  ** For a sname:VkBuffer, the pname:size memory requirement is never
     greater than the result of aligning
     slink:VkBufferCreateInfo::pname:size with the pname:alignment memory
     requirement.
  ** For a slink:VkImage, the pname:size memory requirement is never greater
     than that of another slink:VkImage created with a greater or equal
     value in each of pname:extent.width, pname:extent.height, and
     pname:extent.depth; all other creation parameters being identical.
  ** The memory requirements returned by
     flink:vkGetDeviceBufferMemoryRequirements are identical to those that
     would be returned by flink:vkGetBufferMemoryRequirements2 if it were
     called with a sname:VkBuffer created with the same
     slink:VkBufferCreateInfo values.
  ** The memory requirements returned by
     flink:vkGetDeviceImageMemoryRequirements are identical to those that
     would be returned by flink:vkGetImageMemoryRequirements2 if it were
     called with a sname:VkImage created with the same
     slink:VkImageCreateInfo values.
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]

ifdef::VK_VERSION_1_1,VK_KHR_get_memory_requirements2[]
[open,refpage='vkGetBufferMemoryRequirements2',desc='Returns the memory requirements for specified Vulkan object',type='protos']
--
To determine the memory requirements for a buffer resource, call:

ifdef::VK_VERSION_1_1[]
include::{generated}/api/protos/vkGetBufferMemoryRequirements2.adoc[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_get_memory_requirements2[or the equivalent command]

ifdef::VK_KHR_get_memory_requirements2[]
include::{generated}/api/protos/vkGetBufferMemoryRequirements2KHR.adoc[]
endif::VK_KHR_get_memory_requirements2[]

  * pname:device is the logical device that owns the buffer.
  * pname:pInfo is a pointer to a slink:VkBufferMemoryRequirementsInfo2
    structure containing parameters required for the memory requirements
    query.
  * pname:pMemoryRequirements is a pointer to a slink:VkMemoryRequirements2
    structure in which the memory requirements of the buffer object are
    returned.

include::{generated}/validity/protos/vkGetBufferMemoryRequirements2.adoc[]
--

ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
[open,refpage='vkGetDeviceBufferMemoryRequirements',desc='Returns the memory requirements for specified Vulkan object',type='protos',alias='vkGetDeviceBufferMemoryRequirementsKHR']
--
To determine the memory requirements for a buffer resource without creating
an object, call:

ifdef::VK_VERSION_1_3[]
include::{generated}/api/protos/vkGetDeviceBufferMemoryRequirements.adoc[]
endif::VK_VERSION_1_3[]

ifdef::VK_VERSION_1_3+VK_KHR_maintenance4[or the equivalent command]

ifdef::VK_KHR_maintenance4[]
include::{generated}/api/protos/vkGetDeviceBufferMemoryRequirementsKHR.adoc[]
endif::VK_KHR_maintenance4[]

  * pname:device is the logical device intended to own the buffer.
  * pname:pInfo is a pointer to a slink:VkDeviceBufferMemoryRequirements
    structure containing parameters required for the memory requirements
    query.
  * pname:pMemoryRequirements is a pointer to a slink:VkMemoryRequirements2
    structure in which the memory requirements of the buffer object are
    returned.

include::{generated}/validity/protos/vkGetDeviceBufferMemoryRequirements.adoc[]
--
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]

[open,refpage='VkBufferMemoryRequirementsInfo2',desc='(None)',type='structs']
--
The sname:VkBufferMemoryRequirementsInfo2 structure is defined as:

include::{generated}/api/structs/VkBufferMemoryRequirementsInfo2.adoc[]

ifdef::VK_KHR_get_memory_requirements2[]
or the equivalent

include::{generated}/api/structs/VkBufferMemoryRequirementsInfo2KHR.adoc[]
endif::VK_KHR_get_memory_requirements2[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:buffer is the buffer to query.

include::{generated}/validity/structs/VkBufferMemoryRequirementsInfo2.adoc[]
--

ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
[open,refpage='VkDeviceBufferMemoryRequirements',desc='(None)',type='structs',alias='VkDeviceBufferMemoryRequirementsKHR']
--
The sname:VkDeviceBufferMemoryRequirements structure is defined as:

include::{generated}/api/structs/VkDeviceBufferMemoryRequirements.adoc[]

ifdef::VK_KHR_maintenance4[]
or the equivalent

include::{generated}/api/structs/VkDeviceBufferMemoryRequirementsKHR.adoc[]
endif::VK_KHR_maintenance4[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pCreateInfo is a pointer to a slink:VkBufferCreateInfo structure
    containing parameters affecting creation of the buffer to query.

include::{generated}/validity/structs/VkDeviceBufferMemoryRequirements.adoc[]
--
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]

[open,refpage='vkGetImageMemoryRequirements2',desc='Returns the memory requirements for specified Vulkan object',type='protos']
--
To determine the memory requirements for an image resource, call:

ifdef::VK_VERSION_1_1[]
include::{generated}/api/protos/vkGetImageMemoryRequirements2.adoc[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_get_memory_requirements2[or the equivalent command]

ifdef::VK_KHR_get_memory_requirements2[]
include::{generated}/api/protos/vkGetImageMemoryRequirements2KHR.adoc[]
endif::VK_KHR_get_memory_requirements2[]

  * pname:device is the logical device that owns the image.
  * pname:pInfo is a pointer to a slink:VkImageMemoryRequirementsInfo2
    structure containing parameters required for the memory requirements
    query.
  * pname:pMemoryRequirements is a pointer to a slink:VkMemoryRequirements2
    structure in which the memory requirements of the image object are
    returned.

include::{generated}/validity/protos/vkGetImageMemoryRequirements2.adoc[]
--

ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
[open,refpage='vkGetDeviceImageMemoryRequirements',desc='Returns the memory requirements for specified Vulkan object',type='protos',alias='vkGetDeviceImageMemoryRequirementsKHR']
--
To determine the memory requirements for an image resource without creating
an object, call:

ifdef::VK_VERSION_1_3[]
include::{generated}/api/protos/vkGetDeviceImageMemoryRequirements.adoc[]
endif::VK_VERSION_1_3[]

ifdef::VK_VERSION_1_3+VK_KHR_maintenance4[or the equivalent command]

ifdef::VK_KHR_maintenance4[]
include::{generated}/api/protos/vkGetDeviceImageMemoryRequirementsKHR.adoc[]
endif::VK_KHR_maintenance4[]

  * pname:device is the logical device intended to own the image.
  * pname:pInfo is a pointer to a slink:VkDeviceImageMemoryRequirements
    structure containing parameters required for the memory requirements
    query.
  * pname:pMemoryRequirements is a pointer to a slink:VkMemoryRequirements2
    structure in which the memory requirements of the image object are
    returned.

include::{generated}/validity/protos/vkGetDeviceImageMemoryRequirements.adoc[]
--
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]

[open,refpage='VkImageMemoryRequirementsInfo2',desc='(None)',type='structs']
--
The sname:VkImageMemoryRequirementsInfo2 structure is defined as:

include::{generated}/api/structs/VkImageMemoryRequirementsInfo2.adoc[]

ifdef::VK_KHR_get_memory_requirements2[]
or the equivalent

include::{generated}/api/structs/VkImageMemoryRequirementsInfo2KHR.adoc[]
endif::VK_KHR_get_memory_requirements2[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:image is the image to query.

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

.Valid Usage
****
  * [[VUID-VkImageMemoryRequirementsInfo2-image-01589]]
    If pname:image was created with a _multi-planar_ format and the
    ename:VK_IMAGE_CREATE_DISJOINT_BIT flag, there must: be a
    slink:VkImagePlaneMemoryRequirementsInfo included in the pname:pNext
    chain of the slink:VkImageMemoryRequirementsInfo2 structure
ifdef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-VkImageMemoryRequirementsInfo2-image-02279]]
    If pname:image was created with ename:VK_IMAGE_CREATE_DISJOINT_BIT and
    with ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then there must: be
    a slink:VkImagePlaneMemoryRequirementsInfo included in the pname:pNext
    chain of the slink:VkImageMemoryRequirementsInfo2 structure
endif::VK_EXT_image_drm_format_modifier[]
  * [[VUID-VkImageMemoryRequirementsInfo2-image-01590]]
    If pname:image was not created with the
    ename:VK_IMAGE_CREATE_DISJOINT_BIT flag, there must: not be a
    slink:VkImagePlaneMemoryRequirementsInfo included in the pname:pNext
    chain of the slink:VkImageMemoryRequirementsInfo2 structure
ifndef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-VkImageMemoryRequirementsInfo2-image-01591]]
    If pname:image was created with a single-plane format, there must: not
    be a slink:VkImagePlaneMemoryRequirementsInfo included in the
    pname:pNext chain of the slink:VkImageMemoryRequirementsInfo2 structure
endif::VK_EXT_image_drm_format_modifier[]
ifdef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-VkImageMemoryRequirementsInfo2-image-02280]]
    If pname:image was created with a single-plane format and with any
    pname:tiling other than ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,
    then there must: not be a slink:VkImagePlaneMemoryRequirementsInfo
    included in the pname:pNext chain of the
    slink:VkImageMemoryRequirementsInfo2 structure
endif::VK_EXT_image_drm_format_modifier[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
  * [[VUID-VkImageMemoryRequirementsInfo2-image-01897]]
    If pname:image was created with the
    ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID
    external memory handle type, then pname:image must: be bound to memory
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
  * [[VUID-VkImageMemoryRequirementsInfo2-image-08961]]
    If pname:image was created with the
    ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX external
    memory handle type, then pname:image must: be bound to memory
endif::VK_QNX_external_memory_screen_buffer[]
****

endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

include::{generated}/validity/structs/VkImageMemoryRequirementsInfo2.adoc[]
--

ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
[open,refpage='VkDeviceImageMemoryRequirements',desc='(None)',type='structs',alias='VkDeviceImageMemoryRequirementsKHR']
--
The sname:VkDeviceImageMemoryRequirements structure is defined as:

include::{generated}/api/structs/VkDeviceImageMemoryRequirements.adoc[]

ifdef::VK_KHR_maintenance4[]
or the equivalent

include::{generated}/api/structs/VkDeviceImageMemoryRequirementsKHR.adoc[]
endif::VK_KHR_maintenance4[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pCreateInfo is a pointer to a slink:VkImageCreateInfo structure
    containing parameters affecting creation of the image to query.
  * pname:planeAspect is a elink:VkImageAspectFlagBits value specifying the
    aspect corresponding to the image plane to query.
    This parameter is ignored unless
ifdef::VK_EXT_image_drm_format_modifier[]
    pname:pCreateInfo->tiling is
    ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, or
endif::VK_EXT_image_drm_format_modifier[]
    pname:pCreateInfo->flags has ename:VK_IMAGE_CREATE_DISJOINT_BIT set.

.Valid Usage
****
  * [[VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06416]]
    The pname:pCreateInfo->pNext chain must: not contain a
    slink:VkImageSwapchainCreateInfoKHR structure
ifdef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06776]]
    The pname:pCreateInfo->pNext chain must: not contain a
    slink:VkImageDrmFormatModifierExplicitCreateInfoEXT structure
endif::VK_EXT_image_drm_format_modifier[]
ifdef::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
  * [[VUID-VkDeviceImageMemoryRequirements-pNext-06996]]
    Applications also must: not call
    flink:vkGetDeviceImageMemoryRequirements with a slink:VkImageCreateInfo
    whose pname:pNext chain includes a slink:VkExternalFormatANDROID
    structure with non-zero pname:externalFormat
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]
endif::VK_ANDROID_external_memory_android_hardware_buffer[]
ifdef::VK_QNX_external_memory_screen_buffer[]
ifdef::VK_VERSION_1_3,VK_KHR_maintenance4[]
  * [[VUID-VkDeviceImageMemoryRequirements-pNext-08962]]
    Applications also must: not call
    flink:vkGetDeviceImageMemoryRequirements with a slink:VkImageCreateInfo
    whose pname:pNext chain includes a slink:VkExternalFormatQNX structure
    with non-zero pname:externalFormat
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]
endif::VK_QNX_external_memory_screen_buffer[]
  * [[VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06417]]
    If pname:pCreateInfo->format specifies a _multi-planar_ format and
    pname:pCreateInfo->flags has ename:VK_IMAGE_CREATE_DISJOINT_BIT set then
    pname:planeAspect must: not be ename:VK_IMAGE_ASPECT_NONE_KHR
  * [[VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06419]]
    If pname:pCreateInfo->flags has ename:VK_IMAGE_CREATE_DISJOINT_BIT set
    and if the pname:pCreateInfo->tiling is ename:VK_IMAGE_TILING_LINEAR or
    ename:VK_IMAGE_TILING_OPTIMAL, then pname:planeAspect must: be a single
    valid <<formats-planes-image-aspect,multi-planar aspect mask>> bit
ifdef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06420]]
    If pname:pCreateInfo->tiling is
    ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then pname:planeAspect
    must: be a single valid _memory plane_ for the image (that is,
    pname:aspectMask must: specify a plane index that is less than the
    slink:VkDrmFormatModifierPropertiesEXT::pname:drmFormatModifierPlaneCount
    associated with the image's pname:format and
    slink:VkImageDrmFormatModifierPropertiesEXT::pname:drmFormatModifier)
endif::VK_EXT_image_drm_format_modifier[]
****

include::{generated}/validity/structs/VkDeviceImageMemoryRequirements.adoc[]
--
endif::VK_VERSION_1_3,VK_KHR_maintenance4[]

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
[open,refpage='VkImagePlaneMemoryRequirementsInfo',desc='Structure specifying image plane for memory requirements',type='structs']
--
To determine the memory requirements for a plane of a disjoint image, add a
sname:VkImagePlaneMemoryRequirementsInfo structure to the pname:pNext chain
of the sname:VkImageMemoryRequirementsInfo2 structure.

The sname:VkImagePlaneMemoryRequirementsInfo structure is defined as:

include::{generated}/api/structs/VkImagePlaneMemoryRequirementsInfo.adoc[]

ifdef::VK_KHR_sampler_ycbcr_conversion[]
or the equivalent

include::{generated}/api/structs/VkImagePlaneMemoryRequirementsInfoKHR.adoc[]
endif::VK_KHR_sampler_ycbcr_conversion[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:planeAspect is a elink:VkImageAspectFlagBits value specifying the
    aspect corresponding to the image plane to query.

.Valid Usage
****
  * [[VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-02281]]
    If the image's pname:tiling is ename:VK_IMAGE_TILING_LINEAR or
    ename:VK_IMAGE_TILING_OPTIMAL, then pname:planeAspect must: be a single
    valid <<formats-planes-image-aspect,multi-planar aspect mask>> bit
ifdef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-02282]]
    If the image's pname:tiling is
    ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then pname:planeAspect
    must: be a single valid _memory plane_ for the image (that is,
    pname:aspectMask must: specify a plane index that is less than the
    slink:VkDrmFormatModifierPropertiesEXT::pname:drmFormatModifierPlaneCount
    associated with the image's pname:format and
    slink:VkImageDrmFormatModifierPropertiesEXT::pname:drmFormatModifier)
endif::VK_EXT_image_drm_format_modifier[]
****

include::{generated}/validity/structs/VkImagePlaneMemoryRequirementsInfo.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

[open,refpage='VkMemoryRequirements2',desc='Structure specifying memory requirements',type='structs']
--
The sname:VkMemoryRequirements2 structure is defined as:

include::{generated}/api/structs/VkMemoryRequirements2.adoc[]

ifdef::VK_KHR_get_memory_requirements2[]
or the equivalent

include::{generated}/api/structs/VkMemoryRequirements2KHR.adoc[]
endif::VK_KHR_get_memory_requirements2[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:memoryRequirements is a slink:VkMemoryRequirements structure
    describing the memory requirements of the resource.

include::{generated}/validity/structs/VkMemoryRequirements2.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_get_memory_requirements2[]

ifdef::VK_VERSION_1_1,VK_KHR_dedicated_allocation[]
[open,refpage='VkMemoryDedicatedRequirements',desc='Structure describing dedicated allocation requirements of buffer and image resources',type='structs']
--
The sname:VkMemoryDedicatedRequirements structure is defined as:

include::{generated}/api/structs/VkMemoryDedicatedRequirements.adoc[]

ifdef::VK_KHR_dedicated_allocation[]
or the equivalent

include::{generated}/api/structs/VkMemoryDedicatedRequirementsKHR.adoc[]
endif::VK_KHR_dedicated_allocation[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:prefersDedicatedAllocation specifies that the implementation would
    prefer a dedicated allocation for this resource.
    The application is still free to suballocate the resource but it may:
    get better performance if a dedicated allocation is used.
  * pname:requiresDedicatedAllocation specifies that a dedicated allocation
    is required for this resource.

To determine the dedicated allocation requirements of a buffer or image
resource, add a slink:VkMemoryDedicatedRequirements structure to the
pname:pNext chain of the slink:VkMemoryRequirements2 structure passed as the
pname:pMemoryRequirements parameter of flink:vkGetBufferMemoryRequirements2
or flink:vkGetImageMemoryRequirements2, respectively.

Constraints on the values returned for buffer resources are:

ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
  * pname:requiresDedicatedAllocation may: be ename:VK_TRUE if the
    pname:pNext chain of slink:VkBufferCreateInfo for the call to
    fname:vkCreateBuffer used to create the buffer being queried included a
    slink:VkExternalMemoryBufferCreateInfo structure, and any of the handle
    types specified in
    slink:VkExternalMemoryBufferCreateInfo::pname:handleTypes requires
    dedicated allocation, as reported by
    flink:vkGetPhysicalDeviceExternalBufferProperties in
    sname:VkExternalBufferProperties::pname:externalMemoryProperties.externalMemoryFeatures.
    Otherwise, pname:requiresDedicatedAllocation will be ename:VK_FALSE.

endif::VK_VERSION_1_1,VK_KHR_external_memory[]
ifndef::VK_VERSION_1_1,VK_KHR_external_memory[]
  * pname:requiresDedicatedAllocation will be ename:VK_FALSE
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
  * When the implementation sets pname:requiresDedicatedAllocation to
    ename:VK_TRUE, it must: also set pname:prefersDedicatedAllocation to
    ename:VK_TRUE.
  * If ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT was set in
    slink:VkBufferCreateInfo::pname:flags when pname:buffer was created,
    then both pname:prefersDedicatedAllocation and
    pname:requiresDedicatedAllocation will be ename:VK_FALSE.

Constraints on the values returned for image resources are:

ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
  * pname:requiresDedicatedAllocation may: be ename:VK_TRUE if the
    pname:pNext chain of slink:VkImageCreateInfo for the call to
    flink:vkCreateImage used to create the image being queried included a
    slink:VkExternalMemoryImageCreateInfo structure, and any of the handle
    types specified in
    slink:VkExternalMemoryImageCreateInfo::pname:handleTypes requires
    dedicated allocation, as reported by
    flink:vkGetPhysicalDeviceImageFormatProperties2 in
    sname:VkExternalImageFormatProperties::pname:externalMemoryProperties.externalMemoryFeatures.
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
ifdef::VK_EXT_image_drm_format_modifier[]
  * pname:requiresDedicatedAllocation may: be ename:VK_TRUE if the image's
    tiling is ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT.
endif::VK_EXT_image_drm_format_modifier[]
  * pname:requiresDedicatedAllocation will
ifdef::VK_VERSION_1_1,VK_KHR_external_memory,VK_EXT_image_drm_format_modifier[]
    otherwise
endif::VK_VERSION_1_1,VK_KHR_external_memory,VK_EXT_image_drm_format_modifier[]
    be ename:VK_FALSE
  * If ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT was set in
    slink:VkImageCreateInfo::pname:flags when pname:image was created, then
    both pname:prefersDedicatedAllocation and
    pname:requiresDedicatedAllocation will be ename:VK_FALSE.

include::{generated}/validity/structs/VkMemoryDedicatedRequirements.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_dedicated_allocation[]

[open,refpage='vkBindBufferMemory',desc='Bind device memory to a buffer object',type='protos']
--
:refpage: vkBindBufferMemory

To attach memory to a buffer object, call:

include::{generated}/api/protos/vkBindBufferMemory.adoc[]

  * pname:device is the logical device that owns the buffer and memory.
  * pname:buffer is the buffer to be attached to memory.
  * pname:memory is a slink:VkDeviceMemory object describing the device
    memory to attach.
  * pname:memoryOffset is the start offset of the region of pname:memory
    which is to be bound to the buffer.
    The number of bytes returned in the
    sname:VkMemoryRequirements::pname:size member in pname:memory, starting
    from pname:memoryOffset bytes, will be bound to the specified buffer.

ifdef::VK_VERSION_1_1,VK_KHR_bind_memory2[]
fname:vkBindBufferMemory is equivalent to passing the same parameters
through slink:VkBindBufferMemoryInfo to flink:vkBindBufferMemory2.
endif::VK_VERSION_1_1,VK_KHR_bind_memory2[]

ifdef::VK_NV_external_memory_sci_buf[]
If the pname:memory was obtained by a memory import operation with
slink:VkExternalMemoryBufferCreateInfo::pname:handleTypes assigned to
ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV, the properties of
pname:buffer and the pname:memoryoffset must: be compatible with the
attributes used to create stext:NvSciBufObj, otherwise the implementation
will return ename:VK_ERROR_VALIDATION_FAILED.
endif::VK_NV_external_memory_sci_buf[]

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
include::{chapters}/commonvalidity/bind_buffer_common.adoc[]
****

include::{generated}/validity/protos/vkBindBufferMemory.adoc[]
--

ifdef::VK_VERSION_1_1,VK_KHR_bind_memory2[]
[open,refpage='vkBindBufferMemory2',desc='Bind device memory to buffer objects',type='protos']
--
:refpage: vkBindBufferMemory2

To attach memory to buffer objects for one or more buffers at a time, call:

ifdef::VK_VERSION_1_1[]
include::{generated}/api/protos/vkBindBufferMemory2.adoc[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_bind_memory2[or the equivalent command]

ifdef::VK_KHR_bind_memory2[]
include::{generated}/api/protos/vkBindBufferMemory2KHR.adoc[]
endif::VK_KHR_bind_memory2[]

  * pname:device is the logical device that owns the buffers and memory.
  * pname:bindInfoCount is the number of elements in pname:pBindInfos.
  * pname:pBindInfos is a pointer to an array of pname:bindInfoCount
    slink:VkBindBufferMemoryInfo structures describing buffers and memory to
    bind.

On some implementations, it may: be more efficient to batch memory bindings
into a single command.

ifdef::VK_KHR_maintenance6[]
If the <<features-maintenance6, pname:maintenance6>> feature is enabled,
this command must: attempt to perform all of the memory binding operations
described by pname:pBindInfos, and must: not early exit on the first
failure.
endif::VK_KHR_maintenance6[]

If any of the memory binding operations described by pname:pBindInfos fail,
the elink:VkResult returned by this command must: be the return value of any
one of the memory binding operations which did not return ename:VK_SUCCESS.

[NOTE]
====
If the fname:vkBindBufferMemory2 command failed,
ifdef::VK_KHR_maintenance6[]
slink:VkBindMemoryStatusKHR structures were not included in the pname:pNext
chains of each element of pname:pBindInfos,
endif::VK_KHR_maintenance6[]
and pname:bindInfoCount was greater than one, then the buffers referenced by
pname:pBindInfos will be in an indeterminate state, and must not be used.

Applications should destroy these buffers.
====

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

include::{generated}/validity/protos/vkBindBufferMemory2.adoc[]
--

[open,refpage='VkBindBufferMemoryInfo',desc='Structure specifying how to bind a buffer to memory',type='structs']
--
:refpage: VkBindBufferMemoryInfo

sname:VkBindBufferMemoryInfo contains members corresponding to the
parameters of flink:vkBindBufferMemory.

The sname:VkBindBufferMemoryInfo structure is defined as:

include::{generated}/api/structs/VkBindBufferMemoryInfo.adoc[]

ifdef::VK_KHR_bind_memory2[]
or the equivalent

include::{generated}/api/structs/VkBindBufferMemoryInfoKHR.adoc[]
endif::VK_KHR_bind_memory2[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:buffer is the buffer to be attached to memory.
  * pname:memory is a slink:VkDeviceMemory object describing the device
    memory to attach.
  * pname:memoryOffset is the start offset of the region of pname:memory
    which is to be bound to the buffer.
    The number of bytes returned in the
    sname:VkMemoryRequirements::pname:size member in pname:memory, starting
    from pname:memoryOffset bytes, will be bound to the specified buffer.

.Valid Usage
****
include::{chapters}/commonvalidity/bind_buffer_common.adoc[]
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
  * [[VUID-VkBindBufferMemoryInfo-pNext-01605]]
    If the pname:pNext chain includes a
    slink:VkBindBufferMemoryDeviceGroupInfo structure, all instances of
    pname:memory specified by
    slink:VkBindBufferMemoryDeviceGroupInfo::pname:pDeviceIndices must: have
    been allocated
endif::VK_VERSION_1_1,VK_KHR_device_group[]
****

include::{generated}/validity/structs/VkBindBufferMemoryInfo.adoc[]
--

ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
[open,refpage='VkBindBufferMemoryDeviceGroupInfo',desc='Structure specifying device within a group to bind to',type='structs']
--
The sname:VkBindBufferMemoryDeviceGroupInfo structure is defined as:

include::{generated}/api/structs/VkBindBufferMemoryDeviceGroupInfo.adoc[]

ifdef::VK_KHR_device_group[]
ifdef::VK_VERSION_1_1,VK_KHR_bind_memory2[]
or the equivalent

include::{generated}/api/structs/VkBindBufferMemoryDeviceGroupInfoKHR.adoc[]
endif::VK_VERSION_1_1,VK_KHR_bind_memory2[]
endif::VK_KHR_device_group[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:deviceIndexCount is the number of elements in
    pname:pDeviceIndices.
  * pname:pDeviceIndices is a pointer to an array of device indices.

If the pname:pNext chain of slink:VkBindBufferMemoryInfo includes a
sname:VkBindBufferMemoryDeviceGroupInfo structure, then that structure
determines how memory is bound to buffers across multiple devices in a
device group.

If pname:deviceIndexCount is greater than zero, then on device index [eq]#i#
the buffer is attached to the instance of pname:memory on the physical
device with device index [eq]#pname:pDeviceIndices[i]#.

If pname:deviceIndexCount is zero and pname:memory comes from a memory heap
with the ename:VK_MEMORY_HEAP_MULTI_INSTANCE_BIT bit set, then it is as if
pname:pDeviceIndices contains consecutive indices from zero to the number of
physical devices in the logical device, minus one.
In other words, by default each physical device attaches to its own instance
of pname:memory.

If pname:deviceIndexCount is zero and pname:memory comes from a memory heap
without the ename:VK_MEMORY_HEAP_MULTI_INSTANCE_BIT bit set, then it is as
if pname:pDeviceIndices contains an array of zeros.
In other words, by default each physical device attaches to instance zero.

.Valid Usage
****
  * [[VUID-VkBindBufferMemoryDeviceGroupInfo-deviceIndexCount-01606]]
    pname:deviceIndexCount must: either be zero or equal to the number of
    physical devices in the logical device
  * [[VUID-VkBindBufferMemoryDeviceGroupInfo-pDeviceIndices-01607]]
    All elements of pname:pDeviceIndices must: be valid device indices
****

include::{generated}/validity/structs/VkBindBufferMemoryDeviceGroupInfo.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_device_group[]

ifdef::VK_KHR_maintenance6[]
[open,refpage='VkBindMemoryStatusKHR',desc='Structure specifying where to return memory binding status',type='structs']
--
The sname:VkBindMemoryStatusKHR structure is defined as:

include::{generated}/api/structs/VkBindMemoryStatusKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pResult is a pointer to a ename:VkResult value.

If the pname:pNext chain of slink:VkBindBufferMemoryInfo or
slink:VkBindImageMemoryInfo includes a sname:VkBindMemoryStatusKHR
structure, then the sname:VkBindMemoryStatusKHR::pname:pResult will be
populated with a value describing the result of the corresponding memory
binding operation.

include::{generated}/validity/structs/VkBindMemoryStatusKHR.adoc[]
--
endif::VK_KHR_maintenance6[]
endif::VK_VERSION_1_1,VK_KHR_bind_memory2[]

[open,refpage='vkBindImageMemory',desc='Bind device memory to an image object',type='protos']
--
:refpage: vkBindImageMemory

ifndef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
To attach memory to an image object, call:
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
To attach memory to a sname:VkImage object created without the
ename:VK_IMAGE_CREATE_DISJOINT_BIT set, call:
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]

include::{generated}/api/protos/vkBindImageMemory.adoc[]

  * pname:device is the logical device that owns the image and memory.
  * pname:image is the image.
  * pname:memory is the slink:VkDeviceMemory object describing the device
    memory to attach.
  * pname:memoryOffset is the start offset of the region of pname:memory
    which is to be bound to the image.
    The number of bytes returned in the
    sname:VkMemoryRequirements::pname:size member in pname:memory, starting
    from pname:memoryOffset bytes, will be bound to the specified image.

ifdef::VK_VERSION_1_1,VK_KHR_bind_memory2[]
fname:vkBindImageMemory is equivalent to passing the same parameters through
slink:VkBindImageMemoryInfo to flink:vkBindImageMemory2.
endif::VK_VERSION_1_1,VK_KHR_bind_memory2[]

ifdef::VK_NV_external_memory_sci_buf[]
If the pname:memory is allocated by a memory import operation with
slink:VkExternalMemoryBufferCreateInfo::pname:handleTypes assigned to
ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV, the properties of
pname:image and the pname:memoryoffset must: be compatible with the
attributes used to create stext:NvSciBufObj, otherwise the implementation
will return ename:VK_ERROR_VALIDATION_FAILED.
endif::VK_NV_external_memory_sci_buf[]

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
include::{chapters}/commonvalidity/bind_image_common.adoc[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-vkBindImageMemory-image-01608]]
    pname:image must: not have been created with the
    ename:VK_IMAGE_CREATE_DISJOINT_BIT set
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-vkBindImageMemory-memory-01047]]
    pname:memory must: have been allocated using one of the memory types
    allowed in the pname:memoryTypeBits member of the
    sname:VkMemoryRequirements structure returned from a call to
    flink:vkGetImageMemoryRequirements with pname:image
  * [[VUID-vkBindImageMemory-memoryOffset-01048]]
    pname:memoryOffset must: be an integer multiple of the pname:alignment
    member of the sname:VkMemoryRequirements structure returned from a call
    to flink:vkGetImageMemoryRequirements with pname:image
  * [[VUID-vkBindImageMemory-size-01049]]
    The difference of the size of pname:memory and pname:memoryOffset must:
    be greater than or equal to the pname:size member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetImageMemoryRequirements with the same pname:image
ifdef::VK_FUCHSIA_buffer_collection[]
  * [[VUID-vkBindImageMemory-image-06392]]
    If pname:image was created with
    slink:VkBufferCollectionImageCreateInfoFUCHSIA chained to
    slink:VkImageCreateInfo::pname:pNext, pname:memory must: be allocated
    with a slink:VkImportMemoryBufferCollectionFUCHSIA chained to
    slink:VkMemoryAllocateInfo::pname:pNext
endif::VK_FUCHSIA_buffer_collection[]
****

include::{generated}/validity/protos/vkBindImageMemory.adoc[]
--

ifdef::VK_VERSION_1_1,VK_KHR_bind_memory2[]
[open,refpage='vkBindImageMemory2',desc='Bind device memory to image objects',type='protos']
--
:refpage: vkBindImageMemory2

To attach memory to image objects for one or more images at a time, call:

ifdef::VK_VERSION_1_1[]
include::{generated}/api/protos/vkBindImageMemory2.adoc[]
endif::VK_VERSION_1_1[]

ifdef::VK_VERSION_1_1+VK_KHR_bind_memory2[or the equivalent command]

ifdef::VK_KHR_bind_memory2[]
include::{generated}/api/protos/vkBindImageMemory2KHR.adoc[]
endif::VK_KHR_bind_memory2[]

  * pname:device is the logical device that owns the images and memory.
  * pname:bindInfoCount is the number of elements in pname:pBindInfos.
  * pname:pBindInfos is a pointer to an array of slink:VkBindImageMemoryInfo
    structures, describing images and memory to bind.

On some implementations, it may: be more efficient to batch memory bindings
into a single command.

ifdef::VK_KHR_maintenance6[]
If the <<features-maintenance6, pname:maintenance6>> feature is enabled,
this command must: attempt to perform all of the memory binding operations
described by pname:pBindInfos, and must: not early exit on the first
failure.
endif::VK_KHR_maintenance6[]

If any of the memory binding operations described by pname:pBindInfos fail,
the elink:VkResult returned by this command must: be the return value of any
one of the memory binding operations which did not return ename:VK_SUCCESS.

[NOTE]
====
If the fname:vkBindImageMemory2 command failed,
ifdef::VK_KHR_maintenance6[]
slink:VkBindMemoryStatusKHR structures were not included in the pname:pNext
chains of each element of pname:pBindInfos,
endif::VK_KHR_maintenance6[]
and pname:bindInfoCount was greater than one, then the images referenced by
pname:pBindInfos will be in an indeterminate state, and must not be used.

Applications should destroy these images.
====

include::{chapters}/commonvalidity/no_dynamic_allocations_common.adoc[]

.Valid Usage
****
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-vkBindImageMemory2-pBindInfos-02858]]
    If any slink:VkBindImageMemoryInfo::pname:image was created with
    ename:VK_IMAGE_CREATE_DISJOINT_BIT then all planes of
    slink:VkBindImageMemoryInfo::pname:image must: be bound individually in
    separate pname:pBindInfos
  * [[VUID-vkBindImageMemory2-pBindInfos-04006]]
    pname:pBindInfos must: not refer to the same image subresource more than
    once
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
****

include::{generated}/validity/protos/vkBindImageMemory2.adoc[]
--

[open,refpage='VkBindImageMemoryInfo',desc='Structure specifying how to bind an image to memory',type='structs']
--
:refpage: VkBindImageMemoryInfo

sname:VkBindImageMemoryInfo contains members corresponding to the parameters
of flink:vkBindImageMemory.

The sname:VkBindImageMemoryInfo structure is defined as:

include::{generated}/api/structs/VkBindImageMemoryInfo.adoc[]

ifdef::VK_KHR_bind_memory2[]
or the equivalent

include::{generated}/api/structs/VkBindImageMemoryInfoKHR.adoc[]
endif::VK_KHR_bind_memory2[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:image is the image to be attached to memory.
  * pname:memory is a slink:VkDeviceMemory object describing the device
    memory to attach.
  * pname:memoryOffset is the start offset of the region of pname:memory
    which is to be bound to the image.
    The number of bytes returned in the
    sname:VkMemoryRequirements::pname:size member in pname:memory, starting
    from pname:memoryOffset bytes, will be bound to the specified image.

.Valid Usage
****
include::{chapters}/commonvalidity/bind_image_common.adoc[]
ifndef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkBindImageMemoryInfo-memory-01612]]
    pname:memory must: have been allocated using one of the memory types
    allowed in the pname:memoryTypeBits member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetImageMemoryRequirements with pname:image
  * [[VUID-VkBindImageMemoryInfo-memoryOffset-01613]]
    pname:memoryOffset must: be an integer multiple of the pname:alignment
    member of the slink:VkMemoryRequirements structure returned from a call
    to flink:vkGetImageMemoryRequirements with pname:image
  * [[VUID-VkBindImageMemoryInfo-memory-01614]]
    The difference of the size of pname:memory and pname:memoryOffset must:
    be greater than or equal to the pname:size member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetImageMemoryRequirements with the same pname:image
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
  * [[VUID-VkBindImageMemoryInfo-pNext-01615]]
    If the pname:pNext chain does not include a
    slink:VkBindImagePlaneMemoryInfo structure, pname:memory must: have been
    allocated using one of the memory types allowed in the
    pname:memoryTypeBits member of the slink:VkMemoryRequirements structure
    returned from a call to flink:vkGetImageMemoryRequirements2 with
    pname:image
  * [[VUID-VkBindImageMemoryInfo-pNext-01616]]
    If the pname:pNext chain does not include a
    slink:VkBindImagePlaneMemoryInfo structure, pname:memoryOffset must: be
    an integer multiple of the pname:alignment member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetImageMemoryRequirements2 with pname:image
  * [[VUID-VkBindImageMemoryInfo-pNext-01617]]
    If the pname:pNext chain does not include a
    slink:VkBindImagePlaneMemoryInfo structure, the difference of the size
    of pname:memory and pname:memoryOffset must: be greater than or equal to
    the pname:size member of the slink:VkMemoryRequirements structure
    returned from a call to flink:vkGetImageMemoryRequirements2 with the
    same pname:image
  * [[VUID-VkBindImageMemoryInfo-pNext-01618]]
    If the pname:pNext chain includes a slink:VkBindImagePlaneMemoryInfo
    structure, pname:image must: have been created with the
    ename:VK_IMAGE_CREATE_DISJOINT_BIT bit set
  * [[VUID-VkBindImageMemoryInfo-image-07736]]
    If pname:image was created with the ename:VK_IMAGE_CREATE_DISJOINT_BIT
    bit set, then the pname:pNext chain must: include a
    slink:VkBindImagePlaneMemoryInfo structure
  * [[VUID-VkBindImageMemoryInfo-pNext-01619]]
    If the pname:pNext chain includes a slink:VkBindImagePlaneMemoryInfo
    structure, pname:memory must: have been allocated using one of the
    memory types allowed in the pname:memoryTypeBits member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetImageMemoryRequirements2 with pname:image and where
    slink:VkBindImagePlaneMemoryInfo::pname:planeAspect corresponds to the
    slink:VkImagePlaneMemoryRequirementsInfo::pname:planeAspect in the
    slink:VkImageMemoryRequirementsInfo2 structure's pname:pNext chain
  * [[VUID-VkBindImageMemoryInfo-pNext-01620]]
    If the pname:pNext chain includes a slink:VkBindImagePlaneMemoryInfo
    structure, pname:memoryOffset must: be an integer multiple of the
    pname:alignment member of the slink:VkMemoryRequirements structure
    returned from a call to flink:vkGetImageMemoryRequirements2 with
    pname:image and where
    slink:VkBindImagePlaneMemoryInfo::pname:planeAspect corresponds to the
    slink:VkImagePlaneMemoryRequirementsInfo::pname:planeAspect in the
    slink:VkImageMemoryRequirementsInfo2 structure's pname:pNext chain
  * [[VUID-VkBindImageMemoryInfo-pNext-01621]]
    If the pname:pNext chain includes a slink:VkBindImagePlaneMemoryInfo
    structure, the difference of the size of pname:memory and
    pname:memoryOffset must: be greater than or equal to the pname:size
    member of the slink:VkMemoryRequirements structure returned from a call
    to flink:vkGetImageMemoryRequirements2 with the same pname:image and
    where slink:VkBindImagePlaneMemoryInfo::pname:planeAspect corresponds to
    the slink:VkImagePlaneMemoryRequirementsInfo::pname:planeAspect in the
    slink:VkImageMemoryRequirementsInfo2 structure's pname:pNext chain
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
ifndef::VK_VERSION_1_1+VK_KHR_swapchain[]
ifndef::VK_KHR_device_group+VK_KHR_swapchain[]
  * [[VUID-VkBindImageMemoryInfo-memory-01625]]
    pname:memory must: be a valid slink:VkDeviceMemory handle
endif::VK_KHR_device_group+VK_KHR_swapchain[]
endif::VK_VERSION_1_1+VK_KHR_swapchain[]
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
  * [[VUID-VkBindImageMemoryInfo-pNext-01626]]
    If the pname:pNext chain includes a
    slink:VkBindImageMemoryDeviceGroupInfo structure, all instances of
    pname:memory specified by
    slink:VkBindImageMemoryDeviceGroupInfo::pname:pDeviceIndices must: have
    been allocated
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkBindImageMemoryInfo-pNext-01627]]
    If the pname:pNext chain includes a
    slink:VkBindImageMemoryDeviceGroupInfo structure, and
    slink:VkBindImageMemoryDeviceGroupInfo::pname:splitInstanceBindRegionCount
    is not zero, then pname:image must: have been created with the
    ename:VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT bit set
  * [[VUID-VkBindImageMemoryInfo-pNext-01628]]
    If the pname:pNext chain includes a
    slink:VkBindImageMemoryDeviceGroupInfo structure, all elements of
    slink:VkBindImageMemoryDeviceGroupInfo::pname:pSplitInstanceBindRegions
    must: be valid rectangles contained within the dimensions of pname:image
  * [[VUID-VkBindImageMemoryInfo-pNext-01629]]
    If the pname:pNext chain includes a
    slink:VkBindImageMemoryDeviceGroupInfo structure, the union of the areas
    of all elements of
    slink:VkBindImageMemoryDeviceGroupInfo::pname:pSplitInstanceBindRegions
    that correspond to the same instance of pname:image must: cover the
    entire image
endif::VKSC_VERSION_1_0[]
ifdef::VK_KHR_swapchain[]
  * [[VUID-VkBindImageMemoryInfo-image-01630]]
    If pname:image was created with a valid swapchain handle in
    slink:VkImageSwapchainCreateInfoKHR::pname:swapchain, then the
    pname:pNext chain must: include a
    slink:VkBindImageMemorySwapchainInfoKHR structure containing the same
    swapchain handle
  * [[VUID-VkBindImageMemoryInfo-pNext-01631]]
    If the pname:pNext chain includes a
    slink:VkBindImageMemorySwapchainInfoKHR structure, pname:memory must: be
    dlink:VK_NULL_HANDLE
  * [[VUID-VkBindImageMemoryInfo-pNext-01632]]
    If the pname:pNext chain does not include a
    slink:VkBindImageMemorySwapchainInfoKHR structure, pname:memory must: be
    a valid slink:VkDeviceMemory handle
endif::VK_KHR_swapchain[]
endif::VK_VERSION_1_1,VK_KHR_device_group[]
****

include::{generated}/validity/structs/VkBindImageMemoryInfo.adoc[]
--

ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
[open,refpage='VkBindImageMemoryDeviceGroupInfo',desc='Structure specifying device within a group to bind to',type='structs']
--
The sname:VkBindImageMemoryDeviceGroupInfo structure is defined as:

include::{generated}/api/structs/VkBindImageMemoryDeviceGroupInfo.adoc[]

ifdef::VK_KHR_device_group[]
ifdef::VK_VERSION_1_1,VK_KHR_bind_memory2[]
or the equivalent

include::{generated}/api/structs/VkBindImageMemoryDeviceGroupInfoKHR.adoc[]
endif::VK_VERSION_1_1,VK_KHR_bind_memory2[]
endif::VK_KHR_device_group[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:deviceIndexCount is the number of elements in
    pname:pDeviceIndices.
  * pname:pDeviceIndices is a pointer to an array of device indices.
  * pname:splitInstanceBindRegionCount is the number of elements in
    pname:pSplitInstanceBindRegions.
  * pname:pSplitInstanceBindRegions is a pointer to an array of
    slink:VkRect2D structures describing which regions of the image are
    attached to each instance of memory.

If the pname:pNext chain of slink:VkBindImageMemoryInfo includes a
sname:VkBindImageMemoryDeviceGroupInfo structure, then that structure
determines how memory is bound to images across multiple devices in a device
group.

If pname:deviceIndexCount is greater than zero, then on device index [eq]#i#
pname:image is attached to the instance of the memory on the physical device
with device index [eq]#pname:pDeviceIndices[i]#.

ifndef::VKSC_VERSION_1_0[]
Let [eq]#N# be the number of physical devices in the logical device.
If pname:splitInstanceBindRegionCount is greater than zero, then
pname:pSplitInstanceBindRegions is a pointer to an array of [eq]#N^2^#
rectangles, where the image region specified by the rectangle at element
[eq]#i*N+j# in resource instance [eq]#i# is bound to the memory instance
[eq]#j#.
The blocks of the memory that are bound to each sparse image block region
use an offset in memory, relative to pname:memoryOffset, computed as if the
whole image was being bound to a contiguous range of memory.
In other words, horizontally adjacent image blocks use consecutive blocks of
memory, vertically adjacent image blocks are separated by the number of
bytes per block multiplied by the width in blocks of pname:image, and the
block at [eq]#(0,0)# corresponds to memory starting at pname:memoryOffset.
endif::VKSC_VERSION_1_0[]
ifdef::VKSC_VERSION_1_0[]
In Vulkan SC, pname:splitInstanceBindRegionCount must: be zero because
sparse allocations are not supported <<SCID-8>>.
endif::VKSC_VERSION_1_0[]

If pname:splitInstanceBindRegionCount and pname:deviceIndexCount are zero
and the memory comes from a memory heap with the
ename:VK_MEMORY_HEAP_MULTI_INSTANCE_BIT bit set, then it is as if
pname:pDeviceIndices contains consecutive indices from zero to the number of
physical devices in the logical device, minus one.
In other words, by default each physical device attaches to its own instance
of the memory.

If pname:splitInstanceBindRegionCount and pname:deviceIndexCount are zero
and the memory comes from a memory heap without the
ename:VK_MEMORY_HEAP_MULTI_INSTANCE_BIT bit set, then it is as if
pname:pDeviceIndices contains an array of zeros.
In other words, by default each physical device attaches to instance zero.

.Valid Usage
****
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkBindImageMemoryDeviceGroupInfo-deviceIndexCount-01633]]
    At least one of pname:deviceIndexCount and
    pname:splitInstanceBindRegionCount must: be zero
endif::VKSC_VERSION_1_0[]
  * [[VUID-VkBindImageMemoryDeviceGroupInfo-deviceIndexCount-01634]]
    pname:deviceIndexCount must: either be zero or equal to the number of
    physical devices in the logical device
  * [[VUID-VkBindImageMemoryDeviceGroupInfo-pDeviceIndices-01635]]
    All elements of pname:pDeviceIndices must: be valid device indices
ifdef::VKSC_VERSION_1_0[]
  * [[VUID-VkBindImageMemoryDeviceGroupInfo-splitInstanceBindRegionCount-05067]]
    pname:splitInstanceBindRegionCount must: be zero
endif::VKSC_VERSION_1_0[]
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-VkBindImageMemoryDeviceGroupInfo-splitInstanceBindRegionCount-01636]]
    pname:splitInstanceBindRegionCount must: either be zero or equal to the
    number of physical devices in the logical device squared
  * [[VUID-VkBindImageMemoryDeviceGroupInfo-pSplitInstanceBindRegions-01637]]
    Elements of pname:pSplitInstanceBindRegions that correspond to the same
    instance of an image must: not overlap
  * [[VUID-VkBindImageMemoryDeviceGroupInfo-offset-01638]]
    The pname:offset.x member of any element of
    pname:pSplitInstanceBindRegions must: be a multiple of the sparse image
    block width
    (sname:VkSparseImageFormatProperties::pname:imageGranularity.width) of
    all non-metadata aspects of the image
  * [[VUID-VkBindImageMemoryDeviceGroupInfo-offset-01639]]
    The pname:offset.y member of any element of
    pname:pSplitInstanceBindRegions must: be a multiple of the sparse image
    block height
    (sname:VkSparseImageFormatProperties::pname:imageGranularity.height) of
    all non-metadata aspects of the image
  * [[VUID-VkBindImageMemoryDeviceGroupInfo-extent-01640]]
    The pname:extent.width member of any element of
    pname:pSplitInstanceBindRegions must: either be a multiple of the sparse
    image block width of all non-metadata aspects of the image, or else
    pname:extent.width {plus} pname:offset.x must: equal the width of the
    image subresource
  * [[VUID-VkBindImageMemoryDeviceGroupInfo-extent-01641]]
    The pname:extent.height member of any element of
    pname:pSplitInstanceBindRegions must: either be a multiple of the sparse
    image block height of all non-metadata aspects of the image, or else
    pname:extent.height {plus} pname:offset.y must: equal the height of the
    image subresource
endif::VKSC_VERSION_1_0[]
****
ifdef::VKSC_VERSION_1_0[]
ifdef::hidden[]
// tag::scdeviation[]
  * slink:VkBindImageMemoryDeviceGroupInfo::pname:splitInstanceBindRegionCount
    must: be zero <<SCID-8>>.
// end::scdeviation[]
endif::hidden[]
endif::VKSC_VERSION_1_0[]

include::{generated}/validity/structs/VkBindImageMemoryDeviceGroupInfo.adoc[]
--

ifdef::VK_KHR_swapchain[]
[open,refpage='VkBindImageMemorySwapchainInfoKHR',desc='Structure specifying swapchain image memory to bind to',type='structs']
--
If the pname:pNext chain of slink:VkBindImageMemoryInfo includes a
sname:VkBindImageMemorySwapchainInfoKHR structure, then that structure
includes a swapchain handle and image index indicating that the image will
be bound to memory from that swapchain.

The sname:VkBindImageMemorySwapchainInfoKHR structure is defined as:

include::{generated}/api/structs/VkBindImageMemorySwapchainInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:swapchain is dlink:VK_NULL_HANDLE or a swapchain handle.
  * pname:imageIndex is an image index within pname:swapchain.

If pname:swapchain is not `NULL`, the pname:swapchain and pname:imageIndex
are used to determine the memory that the image is bound to, instead of
pname:memory and pname:memoryOffset.

Memory can: be bound to a swapchain and use the pname:pDeviceIndices or
pname:pSplitInstanceBindRegions members of
slink:VkBindImageMemoryDeviceGroupInfo.

.Valid Usage
****
  * [[VUID-VkBindImageMemorySwapchainInfoKHR-imageIndex-01644]]
    pname:imageIndex must: be less than the number of images in
    pname:swapchain
ifdef::VK_EXT_swapchain_maintenance1[]
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
  * [[VUID-VkBindImageMemorySwapchainInfoKHR-swapchain-07756]]
    If the pname:swapchain has been created with
    ename:VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT,
    pname:imageIndex must: be one that has previously been returned by
    flink:vkAcquireNextImageKHR or flink:vkAcquireNextImage2KHR
endif::VK_VERSION_1_1,VK_KHR_device_group[]
ifndef::VK_VERSION_1_1,VK_KHR_device_group[]
  * [[VUID-VkBindImageMemorySwapchainInfoKHR-swapchain-07910]]
    If the pname:swapchain has been created with
    ename:VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT,
    pname:imageIndex must: be one that has previously been returned by
    flink:vkAcquireNextImageKHR
endif::VK_VERSION_1_1,VK_KHR_device_group[]
endif::VK_EXT_swapchain_maintenance1[]
****

include::{generated}/validity/structs/VkBindImageMemorySwapchainInfoKHR.adoc[]
--
endif::VK_KHR_swapchain[]
endif::VK_VERSION_1_1,VK_KHR_device_group[]

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
[open,refpage='VkBindImagePlaneMemoryInfo',desc='Structure specifying how to bind an image plane to memory',type='structs']
--
In order to bind _planes_ of a _disjoint image_, add a
sname:VkBindImagePlaneMemoryInfo structure to the pname:pNext chain of
slink:VkBindImageMemoryInfo.

The sname:VkBindImagePlaneMemoryInfo structure is defined as:

include::{generated}/api/structs/VkBindImagePlaneMemoryInfo.adoc[]

ifdef::VK_KHR_sampler_ycbcr_conversion[]
or the equivalent

include::{generated}/api/structs/VkBindImagePlaneMemoryInfoKHR.adoc[]
endif::VK_KHR_sampler_ycbcr_conversion[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:planeAspect is a ename:VkImageAspectFlagBits value specifying the
    aspect of the disjoint image plane to bind.

.Valid Usage
****
  * [[VUID-VkBindImagePlaneMemoryInfo-planeAspect-02283]]
    If the image's pname:tiling is ename:VK_IMAGE_TILING_LINEAR or
    ename:VK_IMAGE_TILING_OPTIMAL, then pname:planeAspect must: be a single
    valid <<formats-planes-image-aspect,multi-planar aspect mask>> bit
ifdef::VK_EXT_image_drm_format_modifier[]
  * [[VUID-VkBindImagePlaneMemoryInfo-planeAspect-02284]]
    If the image's pname:tiling is
    ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then pname:planeAspect
    must: be a single valid _memory plane_ for the image (that is,
    pname:aspectMask must: specify a plane index that is less than the
    slink:VkDrmFormatModifierPropertiesEXT::pname:drmFormatModifierPlaneCount
    associated with the image's pname:format and
    slink:VkImageDrmFormatModifierPropertiesEXT::pname:drmFormatModifier)
endif::VK_EXT_image_drm_format_modifier[]
****

include::{generated}/validity/structs/VkBindImagePlaneMemoryInfo.adoc[]
--
endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
endif::VK_VERSION_1_1,VK_KHR_bind_memory2[]


[[resources-bufferimagegranularity,Buffer-Image Granularity]]
.Buffer-Image Granularity
The implementation-dependent limit <<limits-bufferImageGranularity,
pname:bufferImageGranularity>> specifies a page-like granularity at which
linear and non-linear resources must: be placed in adjacent memory locations
to avoid aliasing.
Two resources which do not satisfy this granularity requirement are said to
<<resources-memory-aliasing,alias>>.
pname:bufferImageGranularity is specified in bytes, and must: be a power of
two.
Implementations which do not impose a granularity restriction may: report a
pname:bufferImageGranularity value of one.

[NOTE]
====
Despite its name, pname:bufferImageGranularity is really a granularity
between "`linear`" and "`non-linear`" resources.
====

Given resourceA at the lower memory offset and resourceB at the higher
memory offset in the same sname:VkDeviceMemory object, where one resource is
linear and the other is non-linear (as defined in the
<<glossary-linear-resource,Glossary>>), and the following:

[source,c]
----
resourceA.end       = resourceA.memoryOffset + resourceA.size - 1
resourceA.endPage   = resourceA.end & ~(bufferImageGranularity-1)
resourceB.start     = resourceB.memoryOffset
resourceB.startPage = resourceB.start & ~(bufferImageGranularity-1)
----

The following property must: hold:

[source,c]
----
resourceA.endPage < resourceB.startPage
----

That is, the end of the first resource (A) and the beginning of the second
resource (B) must: be on separate "`pages`" of size
pname:bufferImageGranularity.
pname:bufferImageGranularity may: be different than the physical page size
of the memory heap.
This restriction is only needed when a linear resource and a non-linear
resource are adjacent in memory and will be used simultaneously.
The memory ranges of adjacent resources can: be closer than
pname:bufferImageGranularity, provided they meet the pname:alignment
requirement for the objects in question.

Sparse block size in bytes and sparse image and buffer memory alignments
must: all be multiples of the pname:bufferImageGranularity.
Therefore, memory bound to sparse resources naturally satisfies the
pname:bufferImageGranularity.


[[resources-sharing]]
== Resource Sharing Mode

[open,refpage='VkSharingMode',desc='Buffer and image sharing modes',type='enums']
--
Buffer and image objects are created with a _sharing mode_ controlling how
they can: be accessed from queues.
The supported sharing modes are:

include::{generated}/api/enums/VkSharingMode.adoc[]

  * ename:VK_SHARING_MODE_EXCLUSIVE specifies that access to any range or
    image subresource of the object will be exclusive to a single queue
    family at a time.
  * ename:VK_SHARING_MODE_CONCURRENT specifies that concurrent access to any
    range or image subresource of the object from multiple queue families is
    supported.

[NOTE]
====
ename:VK_SHARING_MODE_CONCURRENT may: result in lower performance access to
the buffer or image than ename:VK_SHARING_MODE_EXCLUSIVE.
====

Ranges of buffers and image subresources of image objects created using
ename:VK_SHARING_MODE_EXCLUSIVE must: only be accessed by queues in the
queue family that has _ownership_ of the resource.
Upon creation, such resources are not owned by any queue family; ownership
is implicitly acquired upon first use within a queue.
Once a resource using ename:VK_SHARING_MODE_EXCLUSIVE is owned by some queue
family, the application must: perform a
<<synchronization-queue-transfers,queue family ownership transfer>> to make
the memory contents of a range or image subresource accessible to a
different queue family.

[NOTE]
====
Images still require a <<resources-image-layouts, layout transition>> from
ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED
before being used on the first queue.
====

A queue family can: take ownership of an image subresource or buffer range
of a resource created with ename:VK_SHARING_MODE_EXCLUSIVE, without an
ownership transfer, in the same way as for a resource that was just created;
however, taking ownership in this way has the effect that the contents of
the image subresource or buffer range are undefined:.

Ranges of buffers and image subresources of image objects created using
ename:VK_SHARING_MODE_CONCURRENT must: only be accessed by queues from the
queue families specified through the pname:queueFamilyIndexCount and
pname:pQueueFamilyIndices members of the corresponding create info
structures.
--


ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
[[resources-external-sharing]]
=== External Resource Sharing

Resources should: only be accessed in the Vulkan instance that has exclusive
ownership of their underlying memory.
Only one Vulkan instance has exclusive ownership of a resource's underlying
memory at a given time, regardless of whether the resource was created using
ename:VK_SHARING_MODE_EXCLUSIVE or ename:VK_SHARING_MODE_CONCURRENT.
Applications can transfer ownership of a resource's underlying memory only
if the memory has been imported from or exported to another instance or
external API using external memory handles.
The semantics for transferring ownership outside of the instance are similar
to those used for transferring ownership of ename:VK_SHARING_MODE_EXCLUSIVE
resources between queues, and is also accomplished using
slink:VkBufferMemoryBarrier or slink:VkImageMemoryBarrier operations.
To make the contents of the underlying memory accessible in the destination
instance or API, applications must:

  . Release exclusive ownership from the source instance or API.
  . Ensure the release operation has completed using semaphores or fences.
  . Acquire exclusive ownership in the destination instance or API

Unlike queue family ownership transfers, the destination instance or API is
not specified explicitly when releasing ownership, nor is the source
instance or API specified when acquiring ownership.
Instead, the image or memory barrier's pname:dstQueueFamilyIndex or
pname:srcQueueFamilyIndex parameters are set to the reserved queue family
index ename:VK_QUEUE_FAMILY_EXTERNAL
ifdef::VK_EXT_queue_family_foreign[]
or ename:VK_QUEUE_FAMILY_FOREIGN_EXT
endif::VK_EXT_queue_family_foreign[]
to represent the external destination or source respectively.

Binding a resource to a memory object shared between multiple Vulkan
instances or other APIs does not change the ownership of the underlying
memory.
The first entity to access the resource implicitly acquires ownership.
An entity can: also implicitly take ownership from another entity in the
same way without an explicit ownership transfer.
However, taking ownership in this way has the effect that the contents of
the underlying memory are undefined:.

Accessing a resource backed by memory that is owned by a particular instance
or API has the same semantics as accessing a ename:VK_SHARING_MODE_EXCLUSIVE
resource, with one exception: Implementations must: ensure layout
transitions performed on one member of a set of identical subresources of
identical images that alias the same range of an underlying memory object
affect the layout of all the subresources in the set.

As a corollary, writes to any image subresources in such a set must: not
make the contents of memory used by other subresources in the set
undefined:.
An application can: define the content of a subresource of one image by
performing device writes to an identical subresource of another image
provided both images are bound to the same region of external memory.
Applications may: also add resources to such a set after the content of the
existing set members has been defined without making the content undefined:
by creating a new image with the initial layout
ename:VK_IMAGE_LAYOUT_UNDEFINED and binding it to the same region of
external memory as the existing images.

[NOTE]
====
Because layout transitions apply to all identical images aliasing the same
region of external memory, the actual layout of the memory backing a new
image as well as an existing image with defined content will not be
undefined:.
Such an image is not usable until it acquires ownership of its memory from
the existing owner.
Therefore, the layout specified as part of this transition will be the true
initial layout of the image.
The undefined: layout specified when creating it is a placeholder to
simplify valid usage requirements.
====
endif::VK_VERSION_1_1,VK_KHR_external_memory[]


[[resources-memory-aliasing]]
== Memory Aliasing

A range of a sname:VkDeviceMemory allocation is _aliased_ if it is bound to
multiple resources simultaneously, as described below, via
flink:vkBindImageMemory, flink:vkBindBufferMemory,
ifdef::VK_NV_ray_tracing[]
flink:vkBindAccelerationStructureMemoryNV,
endif::VK_NV_ray_tracing[]
ifndef::VK_VERSION_1_1,VK_KHR_external_memory[]
or via <<sparsememory-resource-binding,sparse memory bindings>>.
endif::VK_VERSION_1_1,VK_KHR_external_memory[]
ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
ifndef::VKSC_VERSION_1_0[via <<sparsememory-resource-binding,sparse memory bindings>>,]
or by binding the memory to resources in multiple Vulkan instances or
external APIs using external memory handle export and import mechanisms.
endif::VK_VERSION_1_1,VK_KHR_external_memory[]

Consider two resources, resource~A~ and resource~B~, bound respectively to
memory range~A~ and range~B~.
Let paddedRange~A~ and paddedRange~B~ be, respectively, range~A~ and
range~B~ aligned to pname:bufferImageGranularity.
If the resources are both linear or both non-linear (as defined in the
<<glossary-linear-resource,Glossary>>), then the resources _alias_ the
memory in the intersection of range~A~ and range~B~.
If one resource is linear and the other is non-linear, then the resources
_alias_ the memory in the intersection of paddedRange~A~ and paddedRange~B~.

Applications can: alias memory, but use of multiple aliases is subject to
several constraints.

[NOTE]
====
Memory aliasing can: be useful to reduce the total device memory footprint
of an application, if some large resources are used for disjoint periods of
time.
====

When a <<glossary-linear-resource,non-linear>>,
non-ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT image is bound to an aliased
range, all image subresources of the image _overlap_ the range.
When a linear image is bound to an aliased range, the image subresources
that (according to the image's advertised layout) include bytes from the
aliased range overlap the range.
When a ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT image has sparse image
blocks bound to an aliased range, only image subresources including those
sparse image blocks overlap the range, and when the memory bound to the
image's mip tail overlaps an aliased range all image subresources in the mip
tail overlap the range.

Buffers, and linear image subresources in either the
ename:VK_IMAGE_LAYOUT_PREINITIALIZED or ename:VK_IMAGE_LAYOUT_GENERAL
layouts, are _host-accessible subresources_.
That is, the host has a well-defined addressing scheme to interpret the
contents, and thus the layout of the data in memory can: be consistently
interpreted across aliases if each of those aliases is a host-accessible
subresource.
Non-linear images, and linear image subresources in other layouts, are not
host-accessible.

If two aliases are both host-accessible, then they interpret the contents of
the memory in consistent ways, and data written to one alias can: be read by
the other alias.

ifdef::VK_VERSION_1_1,VK_KHR_bind_memory2[]
[[resources-memory-aliasing-consistency]]
If two aliases are both images that were created with identical creation
parameters, both were created with the ename:VK_IMAGE_CREATE_ALIAS_BIT flag
set, and both are bound identically to memory
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
except for slink:VkBindImageMemoryDeviceGroupInfo::pname:pDeviceIndices and
slink:VkBindImageMemoryDeviceGroupInfo::pname:pSplitInstanceBindRegions,
endif::VK_VERSION_1_1,VK_KHR_device_group[]
then they interpret the contents of the memory in consistent ways, and data
written to one alias can: be read by the other alias.

ifdef::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
[[resources-memory-aliasing-consistency-planes]]
Additionally, if an individual plane of a multi-planar image and a
single-plane image alias the same memory, then they also interpret the
contents of the memory in consistent ways under the same conditions, but
with the following modifications:

  * Both must: have been created with the ename:VK_IMAGE_CREATE_DISJOINT_BIT
    flag.
  * The single-plane image must: have a elink:VkFormat that is
    <<formats-compatible-planes,equivalent>> to that of the multi-planar
    image's individual plane.
  * The single-plane image and the individual plane of the multi-planar
    image must: be bound identically to memory
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
    except for slink:VkBindImageMemoryDeviceGroupInfo::pname:pDeviceIndices
    and
    slink:VkBindImageMemoryDeviceGroupInfo::pname:pSplitInstanceBindRegions.
endif::VK_VERSION_1_1,VK_KHR_device_group[]
  * The pname:width and pname:height of the single-plane image are derived
    from the multi-planar image's dimensions in the manner listed for
    <<formats-compatible-planes,plane compatibility>> for the aliased plane.
ifdef::VK_EXT_image_drm_format_modifier[]
  * If either image's pname:tiling is
    ename:VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then both images must: be
    <<glossary-linear-resource,linear>>.
endif::VK_EXT_image_drm_format_modifier[]
  * All other creation parameters must: be identical

endif::VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion[]
endif::VK_VERSION_1_1,VK_KHR_bind_memory2[]

ifdef::VK_VERSION_1_1,VK_KHR_external_memory[]
Aliases created by binding the same memory to resources in multiple Vulkan
instances or external APIs using external memory handle export and import
mechanisms interpret the contents of the memory in consistent ways, and data
written to one alias can: be read by the other alias.
endif::VK_VERSION_1_1,VK_KHR_external_memory[]

Otherwise, the aliases interpret the contents of the memory differently, and
writes via one alias make the contents of memory partially or completely
undefined: to the other alias.
If the first alias is a host-accessible subresource, then the bytes affected
are those written by the memory operations according to its addressing
scheme.
If the first alias is not host-accessible, then the bytes affected are those
overlapped by the image subresources that were written.
If the second alias is a host-accessible subresource, the affected bytes
become undefined:.
If the second alias is not host-accessible, all sparse image blocks (for
sparse partially-resident images) or all image subresources (for non-sparse
image and fully resident sparse images) that overlap the affected bytes
become undefined:.

If any image subresources are made undefined: due to writes to an alias,
then each of those image subresources must: have its layout transitioned
from ename:VK_IMAGE_LAYOUT_UNDEFINED to a valid layout before it is used, or
from ename:VK_IMAGE_LAYOUT_PREINITIALIZED if the memory has been written by
the host.
If any sparse blocks of a sparse image have been made undefined:, then only
the image subresources containing them must: be transitioned.

Use of an overlapping range by two aliases must: be separated by a memory
dependency using the appropriate <<synchronization-access-types, access
types>> if at least one of those uses performs writes, whether the aliases
interpret memory consistently or not.
If buffer or image memory barriers are used, the scope of the barrier must:
contain the entire range and/or set of image subresources that overlap.

If two aliasing image views are used in the same framebuffer, then the
render pass must: declare the attachments using the
<<renderpass-aliasing,ename:VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT>>, and
follow the other rules listed in that section.

[NOTE]
====
Memory recycled via an application suballocator (i.e. without freeing and
reallocating the memory objects) is not substantially different from memory
aliasing.
However, a suballocator usually waits on a fence before recycling a region
of memory, and signaling a fence involves sufficient implicit dependencies
to satisfy all the above requirements.
====


[[resources-memory-overlap]]
=== Resource Memory Overlap

Applications can: safely access a resource concurrently as long as the
memory locations do not overlap as defined in
<<memory-model-memory-location,Memory Location>>.
This includes aliased resources if such aliasing is well-defined.
It also includes access from different queues and/or queue families if such
concurrent access is supported by the resource.
Transfer commands only access memory locations specified by the range of the
transfer command.

[NOTE]
====
The intent is that buffers (or linear images) can be accessed concurrently,
even when they share cache lines, but otherwise do not access the same
memory range.
The concept of a device cache line size is not exposed in the memory model.
====


ifdef::VK_FUCHSIA_buffer_collection[]
[[resources-buffer-collection-fuchsia]]
== Buffer Collections

[open,refpage='VkBufferCollectionFUCHSIA',desc='Opaque handle to a buffer collection object',type='handles']
--
Fuchsia's FIDL-based Sysmem service interoperates with Vulkan via the
`apiext:VK_FUCHSIA_buffer_collection` extension.

A buffer collection is a set of one or more buffers which were allocated
together as a group and which all have the same properties.
These properties describe the buffers' internal representation, such as its
dimensions and memory layout.
This ensures that all of the buffers can be used interchangeably by tasks
that require swapping among multiple buffers, such as double-buffered
graphics rendering.

On Fuchsia, the Sysmem service uses buffer collections as a core construct
in its design.

Buffer collections are represented by sname:VkBufferCollectionFUCHSIA
handles:

include::{generated}/api/handles/VkBufferCollectionFUCHSIA.adoc[]
--


=== Definitions

  * FIDL - Fuchsia Interface Definition Language.
    The declarative language used to define FIDL interprocess communication
    interfaces on Fuchsia.
    FIDL files use the `fidl` extension.
    FIDL is also used to refer to the services defined by interfaces
    declared in the FIDL language
  * Sysmem - The FIDL service that facilitates optimal buffer sharing and
    reuse on Fuchsia
  * client - Any participant of the buffer collection e.g. the Vulkan
    application
  * token - A code:zx_handle_t Zircon channel object that allows
    participation in the buffer collection


=== Platform Initialization for Buffer Collections

To initialize a buffer collection on Fuchsia:

  * Connect to the Sysmem service to initialize a Sysmem allocator
  * Create an initial buffer collection token using the Sysmem allocator
  * Duplicate the token for each participant beyond the initiator
  * See the Sysmem Overview and fuchsia.sysmem FIDL documentation on
    fuchsia.dev for more detailed information


=== Create the Buffer Collection

[open,refpage='vkCreateBufferCollectionFUCHSIA',desc='Create a new buffer collection',type='protos']
--
To create a slink:VkBufferCollectionFUCHSIA for Vulkan to participate in the
buffer collection:

include::{generated}/api/protos/vkCreateBufferCollectionFUCHSIA.adoc[]

  * pname:device is the logical device that creates the
    sname:VkBufferCollectionFUCHSIA
  * pname:pCreateInfo is a pointer to a
    slink:VkBufferCollectionCreateInfoFUCHSIA structure containing
    parameters affecting creation of the buffer collection
  * pname:pAllocator is a pointer to a slink:VkAllocationCallbacks structure
    controlling host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter
  * pname:pBufferCollection is a pointer to a
    slink:VkBufferCollectionFUCHSIA handle in which the resulting buffer
    collection object is returned

include::{generated}/validity/protos/vkCreateBufferCollectionFUCHSIA.adoc[]

.Host Access
****
All functions referencing a slink:VkBufferCollectionFUCHSIA must: be
externally synchronized with the exception of
fname:vkCreateBufferCollectionFUCHSIA.
****
--


[open,refpage='VkBufferCollectionCreateInfoFUCHSIA',desc='Structure specifying desired parameters to create the buffer collection',type='structs']
--
The sname:VkBufferCollectionCreateInfoFUCHSIA structure is defined as:

include::{generated}/api/structs/VkBufferCollectionCreateInfoFUCHSIA.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure
  * pname:collectionToken is a fname:zx_handle_t containing the Sysmem
    client's buffer collection token

.Valid Usage
****
  * [[VUID-VkBufferCollectionCreateInfoFUCHSIA-collectionToken-06393]]
    pname:collectionToken must: be a valid code:zx_handle_t to a Zircon
    channel allocated from Sysmem
    (code:fuchsia.sysmem.Allocator/AllocateSharedCollection) with
    code:ZX_DEFAULT_CHANNEL_RIGHTS rights
****

include::{generated}/validity/structs/VkBufferCollectionCreateInfoFUCHSIA.adoc[]
--


=== Set the Constraints
Buffer collections can be established for slink:VkImage allocations or
slink:VkBuffer allocations.


==== Set Image-Based Buffer Collection Constraints

[open,refpage='vkSetBufferCollectionImageConstraintsFUCHSIA',desc='Set image-based constraints for a buffer collection',type='protos']
--
Setting the constraints on the buffer collection initiates the format
negotiation and allocation of the buffer collection.
To set the constraints on a slink:VkImage buffer collection, call:

include::{generated}/api/protos/vkSetBufferCollectionImageConstraintsFUCHSIA.adoc[]

  * pname:device is the logical device
  * pname:collection is the slink:VkBufferCollectionFUCHSIA handle
  * pname:pImageConstraintsInfo is a pointer to a
    slink:VkImageConstraintsInfoFUCHSIA structure

fname:vkSetBufferCollectionImageConstraintsFUCHSIA may: fail if
pname:pImageConstraintsInfo->formatConstraintsCount is larger than the
implementation-defined limit.
If that occurs, flink:vkSetBufferCollectionImageConstraintsFUCHSIA will
return ename:VK_ERROR_INITIALIZATION_FAILED.

fname:vkSetBufferCollectionImageConstraintsFUCHSIA may: fail if the
implementation does not support any of the formats described by the
pname:pImageConstraintsInfo structure.
If that occurs, flink:vkSetBufferCollectionImageConstraintsFUCHSIA will
return ename:VK_ERROR_FORMAT_NOT_SUPPORTED.

.Valid Usage
****
  * [[VUID-vkSetBufferCollectionImageConstraintsFUCHSIA-collection-06394]]
    fname:vkSetBufferCollectionImageConstraintsFUCHSIA or
    fname:vkSetBufferCollectionBufferConstraintsFUCHSIA must: not have
    already been called on pname:collection
****

include::{generated}/validity/protos/vkSetBufferCollectionImageConstraintsFUCHSIA.adoc[]
--

[open,refpage='VkImageConstraintsInfoFUCHSIA',desc='Structure of image-based buffer collection constraints',type='structs']
--
The sname:VkImageConstraintsInfoFUCHSIA structure is defined as:

include::{generated}/api/structs/VkImageConstraintsInfoFUCHSIA.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:formatConstraintsCount is the number of elements in
    pname:pFormatConstraints.
  * pname:pFormatConstraints is a pointer to an array of
    slink:VkImageFormatConstraintsInfoFUCHSIA structures of size
    pname:formatConstraintsCount that is used to further constrain buffer
    collection format selection for image-based buffer collections.
  * pname:bufferCollectionConstraints is a
    slink:VkBufferCollectionConstraintsInfoFUCHSIA structure used to supply
    parameters for the negotiation and allocation for buffer-based buffer
    collections.
  * pname:flags is a elink:VkImageConstraintsInfoFlagBitsFUCHSIA value
    specifying hints about the type of memory Sysmem should allocate for the
    buffer collection.

.Valid Usage
****
  * [[VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-06395]]
    All elements of pname:pFormatConstraints must: have at least one bit set
    in its
    slink:VkImageFormatConstraintsInfoFUCHSIA::pname:requiredFormatFeatures
  * [[VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-06396]]
    If pname:pFormatConstraints->imageCreateInfo->usage contains
    ename:VK_IMAGE_USAGE_SAMPLED_BIT, then
    pname:pFormatConstraints->requiredFormatFeatures must: contain
    ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
  * [[VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-06397]]
    If pname:pFormatConstraints->imageCreateInfo->usage contains
    ename:VK_IMAGE_USAGE_STORAGE_BIT, then
    pname:pFormatConstraints->requiredFormatFeatures must: contain
    ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT
  * [[VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-06398]]
    If pname:pFormatConstraints->imageCreateInfo->usage contains
    ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, then
    pname:pFormatConstraints->requiredFormatFeatures must: contain
    ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT
  * [[VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-06399]]
    If pname:pFormatConstraints->imageCreateInfo->usage contains
    ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, then
    pname:pFormatConstraints->requiredFormatFeatures must: contain
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
  * [[VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-06400]]
    If pname:pFormatConstraints->imageCreateInfo->usage contains
    ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, then
    pname:pFormatConstraints->requiredFormatFeatures must: contain at least
    one of ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
ifdef::VK_KHR_fragment_shading_rate[]
  * [[VUID-VkImageConstraintsInfoFUCHSIA-attachmentFragmentShadingRate-06401]]
    If the <<features-attachmentFragmentShadingRate,
    pname:attachmentFragmentShadingRate>> feature is enabled, and
    pname:pFormatConstraints->imageCreateInfo->usage contains
    ename:VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, then
    pname:pFormatConstraints->requiredFormatFeatures must: contain
    ename:VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
endif::VK_KHR_fragment_shading_rate[]
****

include::{generated}/validity/structs/VkImageConstraintsInfoFUCHSIA.adoc[]
--

[open,refpage='VkImageConstraintsInfoFlagsFUCHSIA',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkImageConstraintsInfoFlagsFUCHSIA.adoc[]

tname:VkImageConstraintsInfoFlagsFUCHSIA is a bitmask type for setting a
mask of zero or more elink:VkImageConstraintsInfoFlagBitsFUCHSIA bits.
--

[open,refpage='VkImageConstraintsInfoFlagBitsFUCHSIA',desc='Bitmask specifying image constraints flags',type='enums']
--
Bits which can: be set in
elink:VkImageConstraintsInfoFlagBitsFUCHSIA::pname:flags include:

include::{generated}/api/enums/VkImageConstraintsInfoFlagBitsFUCHSIA.adoc[]

General hints about the type of memory that should be allocated by Sysmem
based on the expected usage of the images in the buffer collection include:

  * ename:VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA
  * ename:VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA
  * ename:VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA
  * ename:VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA

For protected memory:

  * ename:VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA specifies
    that protected memory is optional for the buffer collection.

Note that if all participants in the buffer collection (Vulkan or otherwise)
specify that protected memory is optional, Sysmem will not allocate
protected memory.
--

[open,refpage='VkImageFormatConstraintsInfoFUCHSIA',desc='Structure image-based buffer collection constraints',type='structs']
--
The sname:VkImageFormatConstraintsInfoFUCHSIA structure is defined as:

include::{generated}/api/structs/VkImageFormatConstraintsInfoFUCHSIA.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure
  * pname:imageCreateInfo is the slink:VkImageCreateInfo used to create a
    slink:VkImage that is to use memory from the
    slink:VkBufferCollectionFUCHSIA
  * pname:requiredFormatFeatures is a bitmask of
    ename:VkFormatFeatureFlagBits specifying required features of the
    buffers in the buffer collection
  * pname:flags is reserved for future use
  * pname:sysmemPixelFormat is a code:PixelFormatType value from the
    `fuchsia.sysmem/image_formats.fidl` FIDL interface
  * pname:colorSpaceCount the element count of pname:pColorSpaces
  * pname:pColorSpaces is a pointer to an array of
    slink:VkSysmemColorSpaceFUCHSIA structs of size pname:colorSpaceCount

include::{generated}/validity/structs/VkImageFormatConstraintsInfoFUCHSIA.adoc[]
--

[open,refpage='VkImageFormatConstraintsFlagsFUCHSIA',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkImageFormatConstraintsFlagsFUCHSIA.adoc[]

tname:VkImageFormatConstraintsFlagsFUCHSIA is a bitmask type for setting a
mask, but is currently reserved for future use.
--

[open,refpage='VkBufferCollectionConstraintsInfoFUCHSIA',desc='Structure of general buffer collection constraints',type='structs']
--
The sname:VkBufferCollectionConstraintsInfoFUCHSIA structure is defined as:

include::{generated}/api/structs/VkBufferCollectionConstraintsInfoFUCHSIA.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure
  * pname:minBufferCount is the minimum number of buffers available in the
    collection
  * pname:maxBufferCount is the maximum number of buffers allowed in the
    collection
  * pname:minBufferCountForCamping is the per-participant minimum buffers
    for camping
  * pname:minBufferCountForDedicatedSlack is the per-participant minimum
    buffers for dedicated slack
  * pname:minBufferCountForSharedSlack is the per-participant minimum
    buffers for shared slack

Sysmem uses all buffer count parameters in combination to determine the
number of buffers it will allocate.
Sysmem defines buffer count constraints in
`fuchsia.sysmem/constraints.fidl`.

_Camping_ as referred to by pname:minBufferCountForCamping, is the number of
buffers that should be available for the participant that are not for
transient use.
This number of buffers is required for the participant to logically operate.

_Slack_ as referred to by pname:minBufferCountForDedicatedSlack and
pname:minBufferCountForSharedSlack, refers to the number of buffers desired
by participants for optimal performance.
pname:minBufferCountForDedicatedSlack refers to the current participant.
pname:minBufferCountForSharedSlack refers to buffer slack for all
participants in the collection.

include::{generated}/validity/structs/VkBufferCollectionConstraintsInfoFUCHSIA.adoc[]
--

[open,refpage='VkSysmemColorSpaceFUCHSIA',desc='Structure describing the buffer collections color space',type='structs']
--
The sname:VkSysmemColorSpaceFUCHSIA structure is defined as:

include::{generated}/api/structs/VkSysmemColorSpaceFUCHSIA.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure
  * pname:colorSpace value of the Sysmem code:ColorSpaceType

.Valid Usage
****
  * [[VUID-VkSysmemColorSpaceFUCHSIA-colorSpace-06402]]
    pname:colorSpace must: be a code:ColorSpaceType as defined in
    `fuchsia.sysmem/image_formats.fidl`
****

include::{generated}/validity/structs/VkSysmemColorSpaceFUCHSIA.adoc[]
--


==== Set Buffer-Based Buffer Collection Constraints

[open,refpage='vkSetBufferCollectionBufferConstraintsFUCHSIA',desc='Set buffer-based constraints for a buffer collection',type='protos']
--
To set the constraints on a slink:VkBuffer buffer collection, call:

include::{generated}/api/protos/vkSetBufferCollectionBufferConstraintsFUCHSIA.adoc[]

  * pname:device is the logical device
  * pname:collection is the slink:VkBufferCollectionFUCHSIA handle
  * pname:pBufferConstraintsInfo is a pointer to a
    slink:VkBufferConstraintsInfoFUCHSIA structure

fname:vkSetBufferCollectionBufferConstraintsFUCHSIA may: fail if the
implementation does not support the constraints specified in the
pname:bufferCollectionConstraints structure.
If that occurs, flink:vkSetBufferCollectionBufferConstraintsFUCHSIA will
return ename:VK_ERROR_FORMAT_NOT_SUPPORTED.

.Valid Usage
****
  * [[VUID-vkSetBufferCollectionBufferConstraintsFUCHSIA-collection-06403]]
    fname:vkSetBufferCollectionImageConstraintsFUCHSIA or
    fname:vkSetBufferCollectionBufferConstraintsFUCHSIA must: not have
    already been called on pname:collection
****

include::{generated}/validity/protos/vkSetBufferCollectionBufferConstraintsFUCHSIA.adoc[]
--

[open,refpage='VkBufferConstraintsInfoFUCHSIA',desc='Structure buffer-based buffer collection constraints',type='structs']
--
The sname:VkBufferConstraintsInfoFUCHSIA structure is defined as:

include::{generated}/api/structs/VkBufferConstraintsInfoFUCHSIA.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure
  * pname:pBufferCreateInfo a pointer to a slink:VkBufferCreateInfo struct
    describing the buffer attributes for the buffer collection
  * pname:requiredFormatFeatures bitmask of ename:VkFormatFeatureFlagBits
    required features of the buffers in the buffer collection
  * pname:bufferCollectionConstraints is used to supply parameters for the
    negotiation and allocation of the buffer collection

.Valid Usage
****
  * [[VUID-VkBufferConstraintsInfoFUCHSIA-requiredFormatFeatures-06404]]
    The pname:requiredFormatFeatures bitmask of
    ename:VkFormatFeatureFlagBits must: be chosen from among the buffer
    compatible format features listed in
    <<buffer-compatible-format-features,buffer compatible format features>>
****

include::{generated}/validity/structs/VkBufferConstraintsInfoFUCHSIA.adoc[]
--


=== Retrieve Buffer Collection Properties

[open,refpage='vkGetBufferCollectionPropertiesFUCHSIA',desc='Retrieve properties from a buffer collection',type='protos']
--
After constraints have been set on the buffer collection by calling
flink:vkSetBufferCollectionImageConstraintsFUCHSIA or
flink:vkSetBufferCollectionBufferConstraintsFUCHSIA, call
fname:vkGetBufferCollectionPropertiesFUCHSIA to retrieve the negotiated and
finalized properties of the buffer collection.

The call to fname:vkGetBufferCollectionPropertiesFUCHSIA is synchronous.
It waits for the Sysmem format negotiation and buffer collection allocation
to complete before returning.

include::{generated}/api/protos/vkGetBufferCollectionPropertiesFUCHSIA.adoc[]

  * pname:device is the logical device handle
  * pname:collection is the slink:VkBufferCollectionFUCHSIA handle
  * pname:pProperties is a pointer to the retrieved
    slink:VkBufferCollectionPropertiesFUCHSIA struct

[[sysmem-chosen-create-infos]]
For image-based buffer collections, upon calling
fname:vkGetBufferCollectionPropertiesFUCHSIA, Sysmem will choose an element
of the slink:VkImageConstraintsInfoFUCHSIA::pname:pImageCreateInfos
established by the preceding call to
flink:vkSetBufferCollectionImageConstraintsFUCHSIA.
The index of the element chosen is stored in and can be retrieved from
slink:VkBufferCollectionPropertiesFUCHSIA::pname:createInfoIndex.

For buffer-based buffer collections, a single slink:VkBufferCreateInfo is
specified as slink:VkBufferConstraintsInfoFUCHSIA::pname:createInfo.
slink:VkBufferCollectionPropertiesFUCHSIA::pname:createInfoIndex will
therefore always be zero.

fname:vkGetBufferCollectionPropertiesFUCHSIA may: fail if Sysmem is unable
to resolve the constraints of all of the participants in the buffer
collection.
If that occurs, fname:vkGetBufferCollectionPropertiesFUCHSIA will return
ename:VK_ERROR_INITIALIZATION_FAILED.

.Valid Usage
****
  * [[VUID-vkGetBufferCollectionPropertiesFUCHSIA-None-06405]]
    Prior to calling flink:vkGetBufferCollectionPropertiesFUCHSIA, the
    constraints on the buffer collection must: have been set by either
    flink:vkSetBufferCollectionImageConstraintsFUCHSIA or
    flink:vkSetBufferCollectionBufferConstraintsFUCHSIA
****

include::{generated}/validity/protos/vkGetBufferCollectionPropertiesFUCHSIA.adoc[]
--

[open,refpage='VkBufferCollectionPropertiesFUCHSIA',desc='Structure specifying the negotiated format chosen by Sysmem',type='structs']
--
The sname:VkBufferCollectionPropertiesFUCHSIA structure is defined as:

include::{generated}/api/structs/VkBufferCollectionPropertiesFUCHSIA.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure
  * pname:memoryTypeBits is a bitmask containing one bit set for every
    memory type which the buffer collection can be imported as buffer
    collection
  * pname:bufferCount is the number of buffers in the collection
  * pname:createInfoIndex as described in <<sysmem-chosen-create-infos,
    Sysmem chosen create infos>>
  * pname:sysmemPixelFormat is the Sysmem code:PixelFormatType as defined in
    `fuchsia.sysmem/image_formats.fidl`
  * pname:formatFeatures is a bitmask of elink:VkFormatFeatureFlagBits
    shared by the buffer collection
  * pname:sysmemColorSpaceIndex is a slink:VkSysmemColorSpaceFUCHSIA struct
    specifying the color space
  * pname:samplerYcbcrConversionComponents is a slink:VkComponentMapping
    struct specifying the component mapping
  * pname:suggestedYcbcrModel is a elink:VkSamplerYcbcrModelConversion value
    specifying the suggested {YCbCr} model
  * pname:suggestedYcbcrRange is a elink:VkSamplerYcbcrRange value
    specifying the suggested {YCbCr} range
  * pname:suggestedXChromaOffset is a elink:VkChromaLocation value
    specifying the suggested X chroma offset
  * pname:suggestedYChromaOffset is a elink:VkChromaLocation value
    specifying the suggested Y chroma offset

pname:sysmemColorSpace is only set for image-based buffer collections where
the constraints were specified using slink:VkImageConstraintsInfoFUCHSIA in
a call to flink:vkSetBufferCollectionImageConstraintsFUCHSIA.

For image-based buffer collections, pname:createInfoIndex will identify both
the slink:VkImageConstraintsInfoFUCHSIA::pname:pImageCreateInfos element and
the slink:VkImageConstraintsInfoFUCHSIA::pname:pFormatConstraints element
chosen by Sysmem when flink:vkSetBufferCollectionImageConstraintsFUCHSIA was
called.
The value of pname:sysmemColorSpaceIndex will be an index to one of the
color spaces provided in the
slink:VkImageFormatConstraintsInfoFUCHSIA::pname:pColorSpaces array.

The implementation must: have pname:formatFeatures with all bits set that
were set in
slink:VkImageFormatConstraintsInfoFUCHSIA::pname:requiredFormatFeatures, by
the call to flink:vkSetBufferCollectionImageConstraintsFUCHSIA, at
pname:createInfoIndex (other bits could be set as well).

include::{generated}/validity/structs/VkBufferCollectionPropertiesFUCHSIA.adoc[]
--


=== Memory Allocation

To import memory from a buffer collection into a slink:VkImage or a
slink:VkBuffer, chain a slink:VkImportMemoryBufferCollectionFUCHSIA
structure to the pname:pNext member of the slink:VkMemoryAllocateInfo in the
call to flink:vkAllocateMemory.

[open,refpage='VkImportMemoryBufferCollectionFUCHSIA',desc='Structure to specify the Sysmem buffer to import',type='structs']
--
The sname:VkImportMemoryBufferCollectionFUCHSIA structure is defined as:

include::{generated}/api/structs/VkImportMemoryBufferCollectionFUCHSIA.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure
  * pname:collection is the slink:VkBufferCollectionFUCHSIA handle
  * pname:index the index of the buffer to import from pname:collection

.Valid Usage
****
  * [[VUID-VkImportMemoryBufferCollectionFUCHSIA-index-06406]]
    pname:index must: be less than the value retrieved as
    slink:VkBufferCollectionPropertiesFUCHSIA:bufferCount
****

include::{generated}/validity/structs/VkImportMemoryBufferCollectionFUCHSIA.adoc[]
--

[open,refpage='vkDestroyBufferCollectionFUCHSIA',desc='Destroy a buffer collection',type='protos']
--
To release a slink:VkBufferCollectionFUCHSIA:

include::{generated}/api/protos/vkDestroyBufferCollectionFUCHSIA.adoc[]

  * pname:device is the logical device that creates the
    sname:VkBufferCollectionFUCHSIA
  * pname:collection is the slink:VkBufferCollectionFUCHSIA handle
  * pname:pAllocator is a pointer to a slink:VkAllocationCallbacks structure
    controlling host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter

.Valid Usage
****
  * [[VUID-vkDestroyBufferCollectionFUCHSIA-collection-06407]]
    slink:VkImage and slink:VkBuffer objects that referenced
    pname:collection upon creation by inclusion of a
    slink:VkBufferCollectionImageCreateInfoFUCHSIA or
    slink:VkBufferCollectionBufferCreateInfoFUCHSIA chained to their
    slink:VkImageCreateInfo or slink:VkBufferCreateInfo structures
    respectively, may: outlive pname:collection
****

include::{generated}/validity/protos/vkDestroyBufferCollectionFUCHSIA.adoc[]
--
endif::VK_FUCHSIA_buffer_collection[]
