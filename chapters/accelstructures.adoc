// Copyright 2020-2025 The Khronos Group Inc.
// Copyright (c) 2019-2025 NVIDIA Corporation
// SPDX-License-Identifier: CC-BY-4.0

[[acceleration-structure]]
= Acceleration Structures


[[acceleration-structure-def]]
== Acceleration Structures

_Acceleration structures_ are data structures used by the implementation to
efficiently manage scene geometry as it is <<ray-traversal, traversed during
a ray tracing query>>.
The application is responsible for managing acceleration structure objects
(see <<resources-acceleration-structures,Acceleration Structures>>),
including allocation, destruction, executing builds or updates, and
synchronizing resources used during ray tracing queries.

There are two types of acceleration structures, _top level acceleration
structures_ and _bottom level acceleration structures_.

An acceleration structure is considered to be constructed if an
<<acceleration-structure-building,acceleration structure build command>> or
<<acceleration-structure-copying,copy command>> has been executed with the
given acceleration structure as the destination.

[[fig-accelstruct]]
image::{images}/accelstruct.svg[align="center",title="Acceleration Structure",opts="{imageopts}"]

.Caption
****
The diagram shows the relationship between top and bottom level acceleration
structures.
****


[[acceleration-structure-geometry]]
=== Geometry

_Geometries_ refer to a triangle,
ifdef::VK_NV_ray_tracing_linear_swept_spheres[]
sphere, linear swept sphere (LSS),
endif::VK_NV_ray_tracing_linear_swept_spheres[]
or axis-aligned bounding box.

[[ray-tracing-triangle-primitive]]
A triangle is a fundamental geometric primitive defined by three vertices in
3D space, forming a flat, planar surface.

[[aabb-primitive]]
An axis-aligned bounding box (AABB) is a rectangular box defined by two
points (minimum and maximum corners) that encloses a 3D object or scene.
Its faces are aligned with the coordinate axes, making intersection tests
efficient for spatial partitioning and acceleration structures.

ifdef::VK_NV_ray_tracing_linear_swept_spheres[]

[[sphere-primitive]]
A sphere primitive is defined by a position and a radius.

[[linear-swept-sphere-primitive]]
The linear swept sphere (LSS) primitive is comprised of two sphere endcaps
and a truncated cone midsection.
The midsection is constructed so that it tangentially intersects with the
endcaps.
Two points, [eq]#P~0~# and [eq]#P~1~#, and two radii, [eq]#r~0~# and
[eq]#r~1~#, fully describe the primitive.

The following figure shows an example of the LSS primitive composed of two
sphere endcaps connected by a midsection.
The solid non-dotted outline indicates the intersectable portion of the
primitive.

image::{images}/lss_primitive.svg[align="center",title="LSS primitive",opts="{imageopts}"]

Endcaps on LSS primitives are optional and are controlled by
slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV::pname:endCapsMode.
The following figure shows an example of the LSS primitive without the
endcaps with only the midsection present.

image::{images}/lss_primitive_no_endcaps.svg[align="center",title="LSS primitive with no endcaps",opts="{imageopts}"]

A LSS geometry can be defined in multiple ways.
If only the vertex and radius data are specified in
slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV without
specifying the index data, LSS primitives are drawn in pairs of vertices.
Each primitive [eq]#i# is defined by entries [eq]#(i {times} 2, i {times} 2
{plus} 1)# in the vertex and radius buffers.
For example, if a vertex buffer contains vertices [eq]#A, B, C, D, E, F and
G#, (assuming each character represents a position vector) with
corresponding radii as [eq]#rA, rB, rC, rD, rE, rF and rG# respectively, the
LSS primitives drawn will be as shown below with [eq]#G# skipped because it
does not have a corresponding vertex pair.

image::{images}/lssWithVertexBuffers.svg[align="center",title="Lss primitives drawn with only vertex data",opts="{imageopts}"]

LSS primitives can: be chained together by specifying an index buffer and
indexing mode in the
slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV structure.

If the elink:VkRayTracingLssIndexingModeNV::pname:indexingMode is set to
ename:VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV, then the consecutive pair of
indices in the index buffer select the vertices that define the LSS chain.
For example, assuming the same vertex buffer as before, if the index buffer
contains indices [eq]#[6, 5, 5, 4, 4, 3, 2, 1]#, the LSS primitives will be
chained as shown:

image::{images}/lssWithListIndexingMode.svg[align="center",title="Lss primitives drawn with VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV indexing mode",opts="{imageopts}"]

Note that due to the lack of a [eq]#[3, 2]# pair, there is a break in the
chain and [eq]#D# is not connected to [eq]#C#.

If the elink:VkRayTracingLssIndexingModeNV::pname:indexingMode is set to
ename:VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV, then each LSS
primitive is defined by two successive positions and radii, [eq]#(k, k +
1)#, where [eq]#k# is a single index in the index buffer.
For example, if the index buffer contains indices [eq]#[0, 1, 2, 4]#, the
LSS primitives will be chained as shown below.
Note that due to the absence of index 3 in the index buffer, there is a
break in the chain and D is not connected to E.

image::{images}/lssWithSuccessiveIndexingMode.svg[align="center",title="Lss primitives drawn with VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV indexing mode",opts="{imageopts}"]

endif::VK_NV_ray_tracing_linear_swept_spheres[]

[[acceleration-structure-top-level]]
=== Top Level Acceleration Structures

Opaque acceleration structure for an array of instances.
The descriptor or device address referencing this is the starting point for
traversal.

The top level acceleration structure takes a reference to any bottom level
acceleration structure referenced by its instances.
Those bottom level acceleration structure objects must: be valid when the
top level acceleration structure is accessed.


[[acceleration-structure-bottom-level]]
=== Bottom Level Acceleration Structures

Opaque acceleration structure for an array of geometries.


[[acceleration-structure-update]]
=== Acceleration Structure Update Rules

The API defines two types of operations to produce acceleration structures
from geometry:

  * A _build_ operation is used to construct an acceleration structure.
  * An _update_ operation is used to modify an existing acceleration
    structure.

An update operation imposes certain constraints on the input, in exchange
for considerably faster execution.
When performing an update, the application is required to provide a full
description of the acceleration structure, but is prohibited from changing
anything other than instance definitions, transform matrices, and vertex or
AABB positions.
All other aspects of the description must: exactly match the one from the
original build.

More precisely, the application must: not use an update operation to do any
of the following:

  * Change primitives or instances from _active_ to _inactive_, or vice
    versa (as defined in <<acceleration-structure-inactive-prims>>).
  * Change the index or vertex formats of triangle geometry.
  * Change triangle geometry transform pointers from null to non-null or
    vice versa.
  * Change the number of geometries or instances in the structure.
  * Change the geometry flags for any geometry in the structure.
  * Change the number of vertices or primitives for any geometry in the
    structure.

ifdef::VK_EXT_opacity_micromap[]

If the original acceleration structure was built using opacity micromaps and
ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT
was set in pname:flags, the application must: provide a micromap matching
the original micromap in structure with only opacity values updated.
The application is prohibited from changing anything other than the specific
opacity values assigned to the triangles.

More precisely, the application must: not use an update operation to do any
of the following:

  * Remove micromaps or elink:VkOpacityMicromapSpecialIndexEXT values from a
    geometry which previously had them, or vice versa.
  * Change between use of elink:VkOpacityMicromapSpecialIndexEXT values and
    explicit micro-map triangles.
  * Change the subdivision level or format of the micromap triangle
    associated with any acceleration-structure triangle.

If the original acceleration structure was built using opacity micromaps and
ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT
was set in pname:flags, the application must: provide a micromap to the
update operation.

If slink:VkMicromapBuildSizesInfoEXT::pname:discardable is ename:VK_FALSE, a
ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT
or
ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT
operation transfers the reference in the acceleration structure to the new
micromap.

If the original acceleration structure was built using opacity micromaps and
neither opacity micromap update flag is set, the application must: provide
the original micromap to the update operation.

endif::VK_EXT_opacity_micromap[]

ifdef::VK_NV_displacement_micromap[]
If the original acceleration structure was built using displacement
micromaps and
ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV
was set in pname:flags, the application must: provide a displacement
micromap to the update operation.

If the original acceleration structure was built using displacement
micromaps and the displacement micromap update flag is not set the
application must: provide the original micromap to the update operation.
endif::VK_NV_displacement_micromap[]


[[acceleration-structure-inactive-prims]]
=== Inactive Primitives and Instances

Acceleration structures allow the use of particular input values to signal
_inactive_ primitives or instances.

An _inactive_ triangle is one for which the first (X) component of any
vertex is NaN.
If any other vertex component is NaN, and the first is not, the behavior is
undefined:.
If the vertex format does not have a NaN representation, then all triangles
are considered active.

An _inactive_ instance is one whose acceleration structure reference is `0`.

An _inactive_ AABB is one for which the minimum X coordinate is NaN.
If any other component is NaN, and the first is not, the behavior is
undefined:.

ifdef::VK_NV_ray_tracing_linear_swept_spheres[]
An _inactive_ LSS or sphere is one where any of the radius or position
component is NaN.
endif::VK_NV_ray_tracing_linear_swept_spheres[]

In the above definitions, "`NaN`" refers to any type of NaN.
Signaling, non-signaling, quiet, loud, or otherwise.

An inactive object is considered invisible to all rays, and should: not be
represented in the acceleration structure.
Implementations should: ensure that the presence of inactive objects does
not seriously degrade traversal performance.

Inactive objects are counted in the auto-generated index sequences which are
provided to shaders via code:InstanceId and code:PrimitiveId SPIR-V
decorations.
This allows objects in the scene to change freely between the active and
inactive states, without affecting the layout of any arrays which are being
indexed using the ID values.

Any transition between the active and inactive states requires a full
acceleration structure rebuild.
Applications must: not perform an acceleration structure update where an
object is active in the source acceleration structure but would be inactive
in the destination, or vice versa.

ifdef::VK_NV_ray_tracing_linear_swept_spheres[]
The active/inactive state of primitives must: not be changed with
acceleration structure updates.
For chained LSS, using the
ename:VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV mode, entire
chains must: be either active or inactive.
If any chain contains both active and inactive primitives, the behavior is
undefined:.
endif::VK_NV_ray_tracing_linear_swept_spheres[]


[[acceleration-structure-degenerate-prims]]
=== Degenerate Primitives and Instances

_Degenerate_ primitives and instances behave differently to
<<acceleration-structure-inactive-prims,inactive primitives and instances>>,
and are defined as:

  * triangles that have one or more vertices whose respective (X), (Y), (Z)
    components are identical, or have three vertices that have at least two
    of the (X), (Y), or (Z) components identical, therefore forming a line
    or point.
    Degenerate triangles do not generate any intersections.
  * AABBs whose pname:minX=pname:maxX, pname:minY=pname:maxY, and
    pname:minZ=pname:maxZ.
    Degenerate AABBs may: invoke the intersection shader.
ifdef::VK_NV_ray_tracing_linear_swept_spheres[]
  * LSS primitives where both the radii are set to `0`.
  * sphere primitives whose radius is set to `0`.
endif::VK_NV_ray_tracing_linear_swept_spheres[]
  * instances that reference bottom level acceleration structures that
    contain no active primitives.
    When building an acceleration structure, implementations should: treat
    degenerate instances as though they are a point at the instance origin,
    specified by slink:VkAccelerationStructureInstanceKHR::pname:transform.

Unlike _inactive_ primitives and instances, _degenerate_ primitives and
instances may: transition from the degenerate to the non-degenerate state,
or vice versa, when performing an acceleration structure update.

If an acceleration structure is built without
ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR set in
ifdef::VK_NV_ray_tracing[slink:VkAccelerationStructureInfoNV::pname:flags]
ifdef::VK_NV_ray_tracing+VK_KHR_acceleration_structure[or]
ifdef::VK_KHR_acceleration_structure[slink:VkAccelerationStructureBuildGeometryInfoKHR::pname:flags]
, degenerate primitives may: be discarded.
Primitives that are defined with the same index value for more than one
vertex can: always be discarded.


[[acceleration-structure-building]]
=== Building Acceleration Structures

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='vkCmdBuildAccelerationStructuresKHR',desc='Build an acceleration structure',type='protos']
--
:refpage: vkCmdBuildAccelerationStructuresKHR

To build acceleration structures call:

include::{generated}/api/protos/vkCmdBuildAccelerationStructuresKHR.adoc[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:infoCount is the number of acceleration structures to build.
    It specifies the number of the pname:pInfos structures and
    pname:ppBuildRangeInfos pointers that must: be provided.
  * pname:pInfos is a pointer to an array of pname:infoCount
    slink:VkAccelerationStructureBuildGeometryInfoKHR structures defining
    the geometry used to build each acceleration structure.
  * pname:ppBuildRangeInfos is a pointer to an array of pname:infoCount
    pointers to arrays of slink:VkAccelerationStructureBuildRangeInfoKHR
    structures.
    Each pname:ppBuildRangeInfos[i] is a pointer to an array of
    pname:pInfos[i].pname:geometryCount
    slink:VkAccelerationStructureBuildRangeInfoKHR structures defining
    dynamic offsets to the addresses where geometry data is stored, as
    defined by pname:pInfos[i].

The fname:vkCmdBuildAccelerationStructuresKHR command provides the ability
to initiate multiple acceleration structures builds, however there is no
ordering or synchronization implied between any of the individual
acceleration structure builds.

[NOTE]
====
This means that an application cannot: build a top-level acceleration
structure in the same flink:vkCmdBuildAccelerationStructuresKHR call as the
associated bottom-level or instance acceleration structures are being built.
There also cannot: be any memory aliasing between any acceleration structure
memories or scratch memories being used by any of the builds.
====

ifdef::VK_AMDX_dense_geometry_format[]
[NOTE]
====
A slink:VkAccelerationStructureBuildRangeInfoKHR structure is not used when
building an acceleration structure with a geometry type of
ename:VK_GEOMETRY_TYPE_DENSE_GEOMETRY_FORMAT_TRIANGLES_AMDX.
====
endif::VK_AMDX_dense_geometry_format[]

[NOTE]
====
The required alignment of the device addresses passed in to parameters below
might not be provided by the base address of a slink:VkBuffer created with
the correct usage flags and must still be manually aligned by the
application code.
====

[[acceleration-structure-scratch]]
Accesses to the acceleration structure scratch buffers as identified by the
slink:VkAccelerationStructureBuildGeometryInfoKHR::pname:scratchData buffer
device addresses must: be <<synchronization-dependencies,synchronized>> with
the ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
(ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR |
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR).
Accesses to each
slink:VkAccelerationStructureBuildGeometryInfoKHR::pname:srcAccelerationStructure
and
slink:VkAccelerationStructureBuildGeometryInfoKHR::pname:dstAccelerationStructure
must: be <<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR or
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR, as appropriate.

Accesses to other input buffers as identified by any used values of
ifdef::VK_NV_ray_tracing_motion_blur[]
slink:VkAccelerationStructureGeometryMotionTrianglesDataNV::pname:vertexData,
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_AMDX_dense_geometry_format[]
slink:VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX::pname:compressedData,
endif::VK_AMDX_dense_geometry_format[]
slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexData,
slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:indexData,
slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:transformData,
slink:VkAccelerationStructureGeometryAabbsDataKHR::pname:data, and
slink:VkAccelerationStructureGeometryInstancesDataKHR::pname:data must: be
<<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_SHADER_READ_BIT.


.Valid Usage
****
  * [[VUID-vkCmdBuildAccelerationStructuresKHR-accelerationStructure-08923]]
    The <<features-accelerationStructure,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructure>>
    feature must: be enabled

:maxinstancecheck: pname:ppBuildRangeInfos[i][j].pname:primitiveCount
include::{chapters}/commonvalidity/build_acceleration_structure_common.adoc[]
include::{chapters}/commonvalidity/build_acceleration_structure_device_common.adoc[]
include::{chapters}/commonvalidity/build_acceleration_structure_nonindirect_common.adoc[]
****

include::{generated}/validity/protos/vkCmdBuildAccelerationStructuresKHR.adoc[]
--

[open,refpage='vkCmdBuildAccelerationStructuresIndirectKHR',desc='Build an acceleration structure with some parameters provided on the device',type='protos']
--
:refpage: vkCmdBuildAccelerationStructuresIndirectKHR

To build acceleration structures with some parameters sourced on the device
call:

include::{generated}/api/protos/vkCmdBuildAccelerationStructuresIndirectKHR.adoc[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:infoCount is the number of acceleration structures to build.
  * pname:pInfos is a pointer to an array of pname:infoCount
    slink:VkAccelerationStructureBuildGeometryInfoKHR structures defining
    the geometry used to build each acceleration structure.
  * pname:pIndirectDeviceAddresses is a pointer to an array of
    pname:infoCount buffer device addresses which point to
    pname:pInfos[i].pname:geometryCount
    slink:VkAccelerationStructureBuildRangeInfoKHR structures defining
    dynamic offsets to the addresses where geometry data is stored, as
    defined by pname:pInfos[i].
  * pname:pIndirectStrides is a pointer to an array of pname:infoCount byte
    strides between elements of pname:pIndirectDeviceAddresses.
  * pname:ppMaxPrimitiveCounts is a pointer to an array of pname:infoCount
    pointers to arrays of pname:pInfos[i].pname:geometryCount values
    indicating the maximum number of primitives that will be built by this
    command for each geometry.

Accesses to acceleration structures, scratch buffers, vertex buffers, index
buffers, and instance buffers must: be synchronized as with
<<acceleration-structure-scratch,vkCmdBuildAccelerationStructuresKHR>>.

Accesses to any element of pname:pIndirectDeviceAddresses must: be
<<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT.


.Valid Usage
****
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-accelerationStructureIndirectBuild-03650]]
    The <<features-accelerationStructureIndirectBuild,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructureIndirectBuild>>
    feature must: be enabled

:maxinstancecheck: pname:ppMaxPrimitiveCounts[i][j]
include::{chapters}/commonvalidity/build_acceleration_structure_common.adoc[]
include::{chapters}/commonvalidity/build_acceleration_structure_device_common.adoc[]
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03646]]
    For each element of pname:pIndirectDeviceAddresses[i], all device
    addresses between pname:pIndirectDeviceAddresses[i] and
    [eq]#pname:pIndirectDeviceAddresses[i] {plus}
    (pname:pInfos[i].pname:geometryCount {times} pname:pIndirectStrides[i]) -
    1# must: be in the buffer device address range of the same buffer
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03647]]
    For each element of pname:pIndirectDeviceAddresses, the buffer from
    which it was queried must: have been created with the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT usage flag set
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03648]]
    Each element of pname:pIndirectDeviceAddresses must: be a multiple of
    `4`
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectStrides-03787]]
    Each element of pname:pIndirectStrides must: be a multiple of `4`
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03651]]
    Each slink:VkAccelerationStructureBuildRangeInfoKHR structure referenced
    by any element of pname:pIndirectDeviceAddresses must: be a valid
    slink:VkAccelerationStructureBuildRangeInfoKHR structure
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03652]]
    pname:pInfos[i].pname:dstAccelerationStructure must: have been created
    with a value of slink:VkAccelerationStructureCreateInfoKHR::pname:size
    greater than or equal to the memory size required by the build
    operation, as returned by flink:vkGetAccelerationStructureBuildSizesKHR
    with [eq]#pname:pBuildInfo = pname:pInfos[i]# and
    [eq]#pname:pMaxPrimitiveCounts = pname:ppMaxPrimitiveCounts[i]#
  * [[VUID-vkCmdBuildAccelerationStructuresIndirectKHR-ppMaxPrimitiveCounts-03653]]
    Each pname:ppMaxPrimitiveCounts[i][j] must: be greater than or equal to
    the pname:primitiveCount value specified by the
    slink:VkAccelerationStructureBuildRangeInfoKHR structure located at
    [eq]#pname:pIndirectDeviceAddresses[i] {plus} (code:j {times}
    pname:pIndirectStrides[i])#
****

include::{generated}/validity/protos/vkCmdBuildAccelerationStructuresIndirectKHR.adoc[]
--


[open,refpage='VkAccelerationStructureBuildGeometryInfoKHR',desc='Structure specifying the geometry data used to build an acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureBuildGeometryInfoKHR

The sname:VkAccelerationStructureBuildGeometryInfoKHR structure is defined
as:

include::{generated}/api/structs/VkAccelerationStructureBuildGeometryInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:type is a elink:VkAccelerationStructureTypeKHR value specifying
    the type of acceleration structure being built.
  * pname:flags is a bitmask of
    elink:VkBuildAccelerationStructureFlagBitsKHR specifying additional
    parameters of the acceleration structure.
  * pname:mode is a elink:VkBuildAccelerationStructureModeKHR value
    specifying the type of operation to perform.
  * pname:srcAccelerationStructure is a pointer to an existing acceleration
    structure that is to be used to update the
    pname:dstAccelerationStructure acceleration structure when pname:mode is
    ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR.
  * pname:dstAccelerationStructure is a pointer to the target acceleration
    structure for the build.
  * pname:geometryCount specifies the number of geometries that will be
    built into pname:dstAccelerationStructure.
  * pname:pGeometries is a pointer to an array of
    slink:VkAccelerationStructureGeometryKHR structures.
  * pname:ppGeometries is a pointer to an array of pointers to
    slink:VkAccelerationStructureGeometryKHR structures.
  * pname:scratchData is the device or host address of memory that will be
    used as scratch memory for the build.

Only one of pname:pGeometries or pname:ppGeometries can: be a valid pointer,
the other must: be `NULL`.
Each element of the non-`NULL` array describes the data used to build each
acceleration structure geometry.

ifdef::VK_KHR_ray_tracing_pipeline,VK_KHR_ray_query[]
[[acceleration-structure-geometry-index]]
The index of each element of the pname:pGeometries or pname:ppGeometries
members of slink:VkAccelerationStructureBuildGeometryInfoKHR is used as the
_geometry index_ during ray traversal.
ifdef::VK_KHR_ray_tracing_pipeline[]
The geometry index is available in ray shaders via the
<<interfaces-builtin-variables-raygeometryindex,code:RayGeometryIndexKHR
built-in>>, and is <<shader-binding-table-hit-shader-indexing, used to
determine hit and intersection shaders executed during traversal>>.
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_KHR_ray_query[]
The geometry index is available to ray queries via the
code:OpRayQueryGetIntersectionGeometryIndexKHR instruction.
endif::VK_KHR_ray_query[]
endif::VK_KHR_ray_tracing_pipeline,VK_KHR_ray_query[]

ifdef::VK_NV_ray_tracing_motion_blur[]
[[acceleration-structure-motion-instances]]
Setting ename:VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV in pname:flags
indicates that this build is a motion top level acceleration structure.
A motion top level uses instances of format
slink:VkAccelerationStructureMotionInstanceNV if
slink:VkAccelerationStructureGeometryInstancesDataKHR::pname:arrayOfPointers
is ename:VK_FALSE.

If
slink:VkAccelerationStructureGeometryInstancesDataKHR::pname:arrayOfPointers
is ename:VK_TRUE, the pointer for each element of the array of instance
pointers consists of 4 bits of
ename:VkAccelerationStructureMotionInstanceTypeNV in the low 4 bits of the
pointer identifying the type of structure at the pointer.
The device address accessed is the value in the array with the low 4 bits
set to zero.
The structure at the pointer is one of
slink:VkAccelerationStructureInstanceKHR,
slink:VkAccelerationStructureMatrixMotionInstanceNV or
slink:VkAccelerationStructureSRTMotionInstanceNV, depending on the type
value encoded in the low 4 bits.

A top level acceleration structure with either motion instances or vertex
motion in its instances must: set
ename:VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV in pname:flags.
endif::VK_NV_ray_tracing_motion_blur[]

Members pname:srcAccelerationStructure and pname:dstAccelerationStructure
may: be the same or different for an update operation (when pname:mode is
ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR).
If they are the same, the update happens in-place.
Otherwise, the target acceleration structure is updated and the source is
not modified.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03654]]
    pname:type must: not be ename:VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-03788]]
    If pname:geometryCount is not `0`, exactly one of pname:pGeometries or
    pname:ppGeometries must: be a valid pointer, the other must: be `NULL`
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03789]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, the
    pname:geometryType member of elements of either pname:pGeometries or
    pname:ppGeometries must: be ename:VK_GEOMETRY_TYPE_INSTANCES_KHR
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03790]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
    pname:geometryCount must: be `1`
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03791]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
    the pname:geometryType member of elements of either pname:pGeometries or
    pname:ppGeometries must: not be ename:VK_GEOMETRY_TYPE_INSTANCES_KHR
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03792]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
    then the pname:geometryType member of each geometry in either
    pname:pGeometries or pname:ppGeometries must: be the same
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03793]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
    then pname:geometryCount must: be less than or equal to
    slink:VkPhysicalDeviceAccelerationStructurePropertiesKHR::pname:maxGeometryCount
ifdef::VK_AMDX_dense_geometry_format[]
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-10884]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
    and the pname:geometryType member of either pname:pGeometries or
    pname:ppGeometries is
    ename:VK_GEOMETRY_TYPE_DENSE_GEOMETRY_FORMAT_TRIANGLES_AMDX, then
    pname:geometryCount must: be `1`
endif::VK_AMDX_dense_geometry_format[]
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03794]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
    and the pname:geometryType member of either pname:pGeometries or
    pname:ppGeometries is ename:VK_GEOMETRY_TYPE_AABBS_KHR, the total number
    of AABBs in all geometries must: be less than or equal to
    slink:VkPhysicalDeviceAccelerationStructurePropertiesKHR::pname:maxPrimitiveCount
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03795]]
    If pname:type is ename:VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
    and the pname:geometryType member of either pname:pGeometries or
    pname:ppGeometries is ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, the total
    number of triangles in all geometries must: be less than or equal to
    slink:VkPhysicalDeviceAccelerationStructurePropertiesKHR::pname:maxPrimitiveCount
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-03796]]
    If pname:flags has the
    ename:VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR bit set,
    then it must: not have the
    ename:VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR bit set
ifdef::VK_NV_ray_tracing_motion_blur[]
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-dstAccelerationStructure-04927]]
    If pname:dstAccelerationStructure was created with
    ename:VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV set in
    slink:VkAccelerationStructureCreateInfoKHR::pname:createFlags,
    ename:VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV must: be set in
    pname:flags
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-04928]]
    If ename:VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV is set in
    pname:flags, pname:dstAccelerationStructure must: have been created with
    ename:VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV set in
    slink:VkAccelerationStructureCreateInfoKHR::pname:createFlags
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-04929]]
    If ename:VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV is set in
    pname:flags, pname:type must: not be
    ename:VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_EXT_opacity_micromap[]
  * [[VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-07334]]
    If pname:flags has the
    ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT
    bit set then it must: not have the
    ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT
    bit set
endif::VK_EXT_opacity_micromap[]
****
include::{generated}/validity/structs/VkAccelerationStructureBuildGeometryInfoKHR.adoc[]
--

[open,refpage='VkBuildAccelerationStructureModeKHR',desc='Enum specifying the type of build operation to perform',type='enums']
--
:refpage: VkBuildAccelerationStructureModeKHR

The ename:VkBuildAccelerationStructureModeKHR enumeration is defined as:

include::{generated}/api/enums/VkBuildAccelerationStructureModeKHR.adoc[]

  * ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR specifies that the
    destination acceleration structure will be built using the specified
    geometries.
  * ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR specifies that the
    destination acceleration structure will be built using data in a source
    acceleration structure, updated by the specified geometries.
--

[open,refpage='VkDeviceOrHostAddressKHR',desc='Union specifying a device or host address',type='structs']
--
:refpage: VkDeviceOrHostAddressKHR

The sname:VkDeviceOrHostAddressKHR union is defined as:

include::{generated}/api/structs/VkDeviceOrHostAddressKHR.adoc[]

  * pname:deviceAddress is a buffer device address as returned by the
    flink:vkGetBufferDeviceAddressKHR command.
  * pname:hostAddress is a host memory address.

include::{generated}/validity/structs/VkDeviceOrHostAddressKHR.adoc[]
--

[open,refpage='VkDeviceOrHostAddressConstKHR',desc='Union specifying a const device or host address',type='structs']
--
:refpage: VkDeviceOrHostAddressConstKHR

The sname:VkDeviceOrHostAddressConstKHR union is defined as:

include::{generated}/api/structs/VkDeviceOrHostAddressConstKHR.adoc[]

  * pname:deviceAddress is a buffer device address as returned by the
    flink:vkGetBufferDeviceAddressKHR command.
  * pname:hostAddress is a const host memory address.

include::{generated}/validity/structs/VkDeviceOrHostAddressConstKHR.adoc[]
--

[open,refpage='VkAccelerationStructureGeometryKHR',desc='Structure specifying geometries to be built into an acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureGeometryKHR

The sname:VkAccelerationStructureGeometryKHR structure is defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:geometryType describes which type of geometry this
    sname:VkAccelerationStructureGeometryKHR refers to.
  * pname:geometry is a slink:VkAccelerationStructureGeometryDataKHR union
    describing the geometry data for the relevant geometry type.
  * pname:flags is a bitmask of elink:VkGeometryFlagBitsKHR values
    describing additional properties of how the geometry should be built.

include::{generated}/validity/structs/VkAccelerationStructureGeometryKHR.adoc[]
--

[open,refpage='VkAccelerationStructureGeometryDataKHR',desc='Union specifying acceleration structure geometry data',type='structs']
--
:refpage: VkAccelerationStructureGeometryDataKHR

The sname:VkAccelerationStructureGeometryDataKHR union is defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryDataKHR.adoc[]

  * pname:triangles is a
    slink:VkAccelerationStructureGeometryTrianglesDataKHR structure.
  * pname:aabbs is a slink:VkAccelerationStructureGeometryAabbsDataKHR
    structure.
  * pname:instances is a
    slink:VkAccelerationStructureGeometryInstancesDataKHR structure.

include::{generated}/validity/structs/VkAccelerationStructureGeometryDataKHR.adoc[]
--

[open,refpage='VkAccelerationStructureGeometryTrianglesDataKHR',desc='Structure specifying a triangle geometry in a bottom-level acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureGeometryTrianglesDataKHR

The sname:VkAccelerationStructureGeometryTrianglesDataKHR structure is
defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryTrianglesDataKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:vertexFormat is the elink:VkFormat of each vertex element.
  * pname:vertexData is a device or host address of memory containing vertex
    data for this geometry.
  * pname:vertexStride is the stride in bytes between each vertex.
  * pname:maxVertex is the number of vertices in pname:vertexData minus one.
  * pname:indexType is the elink:VkIndexType of each index element.
  * pname:indexData is a device or host address of memory containing index
    data for this geometry.
    When pname:indexType is ename:VK_INDEX_TYPE_NONE_KHR it must: be `NULL`.
  * pname:transformData is a device or host address to memory containing an
    optional reference to a slink:VkTransformMatrixKHR structure describing
    a transformation from the space in which the vertices in this geometry
    are described to the space in which the acceleration structure is
    defined.

[NOTE]
====
Unlike the stride for vertex buffers in
slink:VkVertexInputBindingDescription for graphics pipelines which must not
exceed pname:maxVertexInputBindingStride, pname:vertexStride for
acceleration structure geometry is instead restricted to being a 32-bit
value.
====

.Valid Usage
****
  * [[VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexStride-03735]]
    pname:vertexStride must: be a multiple of the size in bytes of the
    smallest component of pname:vertexFormat
  * [[VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexStride-03819]]
    pname:vertexStride must: be less than or equal to [eq]#2^32^-1#
  * [[VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexFormat-03797]]
    The <<resources-buffer-view-format-features,format features>> of
    pname:vertexFormat must: contain
    ename:VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR
  * [[VUID-VkAccelerationStructureGeometryTrianglesDataKHR-indexType-03798]]
    pname:indexType must: be ename:VK_INDEX_TYPE_UINT16,
    ename:VK_INDEX_TYPE_UINT32, or ename:VK_INDEX_TYPE_NONE_KHR
****

include::{generated}/validity/structs/VkAccelerationStructureGeometryTrianglesDataKHR.adoc[]
--

ifdef::VK_NV_ray_tracing_motion_blur[]
[open,refpage='VkAccelerationStructureGeometryMotionTrianglesDataNV',desc='Structure specifying vertex motion in a bottom-level acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureGeometryMotionTrianglesDataNV

The sname:VkAccelerationStructureGeometryMotionTrianglesDataNV structure is
defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryMotionTrianglesDataNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:vertexData is a pointer to vertex data for this geometry at time
    1.0

If sname:VkAccelerationStructureGeometryMotionTrianglesDataNV is included in
the pname:pNext chain of a
slink:VkAccelerationStructureGeometryTrianglesDataKHR structure, the basic
vertex positions are used for the position of the triangles in the geometry
at time 0.0 and the pname:vertexData in
sname:VkAccelerationStructureGeometryMotionTrianglesDataNV is used for the
vertex positions at time 1.0, with positions linearly interpolated at
intermediate times.

Indexing for sname:VkAccelerationStructureGeometryMotionTrianglesDataNV
pname:vertexData is equivalent to the basic vertex position data.

include::{generated}/validity/structs/VkAccelerationStructureGeometryMotionTrianglesDataNV.adoc[]
--
endif::VK_NV_ray_tracing_motion_blur[]

ifdef::VK_EXT_opacity_micromap[]
[open,refpage='VkAccelerationStructureTrianglesOpacityMicromapEXT',desc='Structure specifying an opacity micromap in a bottom-level acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureTrianglesOpacityMicromapEXT

The sname:VkAccelerationStructureTrianglesOpacityMicromapEXT structure is
defined as:

include::{generated}/api/structs/VkAccelerationStructureTrianglesOpacityMicromapEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:indexType is the type of triangle indices used when indexing this
    micromap.
  * pname:indexBuffer is a device or host address of memory containing the
    triangle indices.
    When pname:indexType is ename:VK_INDEX_TYPE_NONE_KHR it must: be `NULL`.
  * pname:indexStride is the byte stride between triangle indices.
  * pname:baseTriangle is the base value added to the non-negative triangle
    indices.
  * pname:usageCountsCount specifies the number of usage counts structures
    that will be used to determine the size of this micromap.
  * pname:pUsageCounts is a pointer to an array of slink:VkMicromapUsageEXT
    structures.
  * pname:ppUsageCounts is a pointer to an array of pointers to
    slink:VkMicromapUsageEXT structures.
  * pname:micromap is the handle to the micromap object to include in this
    geometry.

If sname:VkAccelerationStructureTrianglesOpacityMicromapEXT is included in
the pname:pNext chain of a
ifdef::VK_AMDX_dense_geometry_format[]
slink:VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX or
endif::VK_AMDX_dense_geometry_format[]
slink:VkAccelerationStructureGeometryTrianglesDataKHR structure, that
geometry will reference that micromap.

For each triangle in the geometry, the acceleration structure build fetches
an index from pname:indexBuffer using pname:indexType and pname:indexStride
if present.
If pname:indexBuffer is `NULL` then the index used is the index of the
triangle in the geometry.

If that value is the unsigned cast of one of the values from
elink:VkOpacityMicromapSpecialIndexEXT then that triangle behaves as
described for that special value in <<ray-opacity-micromap,Ray Opacity
Micromap>>.

Otherwise that triangle uses the opacity micromap information from
pname:micromap at that index plus pname:baseTriangle.


Only one of pname:pUsageCounts or pname:ppUsageCounts can: be a valid
pointer, the other must: be `NULL`.
The elements of the non-`NULL` array describe the total count used to build
this geometry.
For a given pname:format and pname:subdivisionLevel the number of triangles
in this geometry matching those values after indirection and special index
handling must: be equal to the sum of matching pname:count provided.

If pname:micromap is dlink:VK_NULL_HANDLE, then every value read from
pname:indexBuffer must: be one of the values in
ename:VkOpacityMicromapSpecialIndexEXT.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-pUsageCounts-07335]]
    Only one of pname:pUsageCounts or pname:ppUsageCounts can: be a valid
    pointer, the other must: be `NULL`
  * [[VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-indexType-10719]]
    pname:indexType must: be ename:VK_INDEX_TYPE_UINT16,
    ename:VK_INDEX_TYPE_UINT32, or ename:VK_INDEX_TYPE_NONE_KHR
  * [[VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-indexType-10722]]
    If pname:indexType is not ename:VK_INDEX_TYPE_NONE_KHR, then
    pname:indexStride must: be a multiple of the size in bytes of
    pname:indexType
  * [[VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-indexType-10723]]
    If pname:indexType is not ename:VK_INDEX_TYPE_NONE_KHR, then
    pname:indexStride must: be less than or equal to [eq]#2^32^-1#
****

include::{generated}/validity/structs/VkAccelerationStructureTrianglesOpacityMicromapEXT.adoc[]
--

[open,refpage='VkOpacityMicromapSpecialIndexEXT',desc='Enum for special indices in the opacity micromap',type='enums']
--
:refpage: VkOpacityMicromapSpecialIndexEXT

The ename:VkOpacityMicromapSpecialIndexEXT enumeration is defined as:

include::{generated}/api/enums/VkOpacityMicromapSpecialIndexEXT.adoc[]

  * ename:VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT specifies
    that the entire triangle is fully transparent.
  * ename:VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT specifies that
    the entire triangle is fully opaque.
  * ename:VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT
    specifies that the entire triangle is unknown-transparent.
  * ename:VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT
    specifies that the entire triangle is unknown-opaque.
ifdef::VK_NV_cluster_acceleration_structure[]
  * ename:VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV
    specifies that <<ray-opacity-micromap, Opacity Micromap>> will be
    disabled for this triangle and opacity value will be picked from
    slink:VkClusterAccelerationStructureBuildTriangleClusterInfoNV::pname:baseGeometryIndexAndGeometryFlags
    instead.
    Note that this special index is only valid for <<cluster-geometry,
    Cluster Geometry>>.
endif::VK_NV_cluster_acceleration_structure[]
--

endif::VK_EXT_opacity_micromap[]

ifdef::VK_NV_displacement_micromap[]
[open,refpage='VkAccelerationStructureTrianglesDisplacementMicromapNV',desc='Structure specifying a displacement micromap in a bottom-level acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureTrianglesDisplacementMicromapNV

The sname:VkAccelerationStructureTrianglesDisplacementMicromapNV structure
is defined as:

include::{generated}/api/structs/VkAccelerationStructureTrianglesDisplacementMicromapNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:displacementBiasAndScaleFormat is the format of displacement bias
    and scale used in this displacement micromap reference.
  * pname:displacementVectorFormat is the format of displacement vector used
    in this displacement micromap reference.
  * pname:displacementBiasAndScaleBuffer is the address containing the bias
    and scale.
  * pname:displacementBiasAndScaleStride is the byte stride between bias and
    scale values.
  * pname:displacementVectorBuffer is the address containing the
    displacement vector values.
  * pname:displacementVectorStride is the byte stride between displacement
    vector values.
  * pname:displacedMicromapPrimitiveFlags is the address containing the
    primitive flags.
  * pname:displacedMicromapPrimitiveFlagsStride is the byte stride between
    primitive flag values.
  * pname:indexType is the type of triangle indices used when indexing this
    micromap.
  * pname:indexBuffer is a device or host address of memory containing the
    triangle indices.
    When pname:indexType is ename:VK_INDEX_TYPE_NONE_KHR it must: be `NULL`.
  * pname:indexStride is the byte stride between triangle indices.
  * pname:baseTriangle is the base value added to the non-negative triangle
    indices.
  * pname:usageCountsCount specifies the number of usage counts structures
    that will be used to determine the size of this micromap.
  * pname:pUsageCounts is a pointer to an array of slink:VkMicromapUsageEXT
    structures.
  * pname:ppUsageCounts is a pointer to an array of pointers to
    slink:VkMicromapUsageEXT structures.
  * pname:micromap is the handle to the micromap object to include in this
    geometry.

If sname:VkAccelerationStructureTrianglesDisplacementMicromapNV is included
in the pname:pNext chain of a
slink:VkAccelerationStructureGeometryTrianglesDataKHR structure, that
geometry will reference that micromap.

For each triangle in the geometry, the acceleration structure build fetches
an index from pname:indexBuffer using pname:indexType and pname:indexStride.
That triangle uses the displacement micromap information from pname:micromap
at that index plus pname:baseTriangle.

Only one of pname:pUsageCounts or pname:ppUsageCounts can: be a valid
pointer, the other must: be `NULL`.
The elements of the non-`NULL` array describe the total count used to build
this geometry.
For a given pname:format and pname:subdivisionLevel the number of triangles
in this geometry matching those values after indirection must: be equal to
the sum of matching pname:count provided.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-displacementBiasAndScaleFormat-09501]]
    pname:displacementBiasAndScaleFormat must: not be
    ename:VK_FORMAT_UNDEFINED
  * [[VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-displacementVectorFormat-09502]]
    pname:displacementVectorFormat must: not be ename:VK_FORMAT_UNDEFINED
  * [[VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-pUsageCounts-07992]]
    Only one of pname:pUsageCounts or pname:ppUsageCounts can: be a valid
    pointer, the other must: be `NULL`
****

include::{generated}/validity/structs/VkAccelerationStructureTrianglesDisplacementMicromapNV.adoc[]
--
endif::VK_NV_displacement_micromap[]
endif::VK_KHR_acceleration_structure[]


ifdef::VK_NV_ray_tracing[]
[open,refpage='vkCmdBuildAccelerationStructureNV',desc='Build an acceleration structure',type='protos']
--
:refpage: vkCmdBuildAccelerationStructureNV

To build an acceleration structure for the `apiext:VK_NV_ray_tracing`
extension call:

include::{generated}/api/protos/vkCmdBuildAccelerationStructureNV.adoc[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pInfo contains the shared information for the acceleration
    structure's structure.
  * pname:instanceData is the buffer containing an array of
    slink:VkAccelerationStructureInstanceKHR structures defining
    acceleration structures.
    This parameter must: be `NULL` for bottom level acceleration structures.
  * pname:instanceOffset is the offset in bytes (relative to the start of
    pname:instanceData) at which the instance data is located.
  * pname:update specifies whether to update the pname:dst acceleration
    structure with the data in pname:src.
  * pname:dst is a pointer to the target acceleration structure for the
    build.
  * pname:src is a pointer to an existing acceleration structure that is to
    be used to update the pname:dst acceleration structure.
  * pname:scratch is the slink:VkBuffer that will be used as scratch memory
    for the build.
  * pname:scratchOffset is the offset in bytes relative to the start of
    pname:scratch that will be used as a scratch memory.

Accesses to pname:dst, pname:src, and pname:scratch must: be
<<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR or
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR.

.Valid Usage
****
  * [[VUID-vkCmdBuildAccelerationStructureNV-geometryCount-02241]]
    pname:geometryCount must: be less than or equal to
    slink:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxGeometryCount
  * [[VUID-vkCmdBuildAccelerationStructureNV-dst-02488]]
    pname:dst must: have been created with compatible
    slink:VkAccelerationStructureInfoNV where
    slink:VkAccelerationStructureInfoNV::pname:type and
    slink:VkAccelerationStructureInfoNV::pname:flags are identical,
    slink:VkAccelerationStructureInfoNV::pname:instanceCount and
    slink:VkAccelerationStructureInfoNV::pname:geometryCount for pname:dst
    are greater than or equal to the build size and each geometry in
    slink:VkAccelerationStructureInfoNV::pname:pGeometries for pname:dst has
    greater than or equal to the number of vertices, indices, and AABBs
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-02489]]
    If pname:update is ename:VK_TRUE, pname:src must: not be
    dlink:VK_NULL_HANDLE
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-02490]]
    If pname:update is ename:VK_TRUE, pname:src must: have previously been
    constructed with
    ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV set in
    slink:VkAccelerationStructureInfoNV::pname:flags in the original build
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-02491]]
    If pname:update is ename:VK_FALSE, the pname:size member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetAccelerationStructureMemoryRequirementsNV with
    slink:VkAccelerationStructureMemoryRequirementsInfoNV::pname:accelerationStructure
    set to pname:dst and
    slink:VkAccelerationStructureMemoryRequirementsInfoNV::pname:type set to
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV
    must: be less than or equal to the size of pname:scratch minus
    pname:scratchOffset
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-02492]]
    If pname:update is ename:VK_TRUE, the pname:size member of the
    slink:VkMemoryRequirements structure returned from a call to
    flink:vkGetAccelerationStructureMemoryRequirementsNV with
    slink:VkAccelerationStructureMemoryRequirementsInfoNV::pname:accelerationStructure
    set to pname:dst and
    slink:VkAccelerationStructureMemoryRequirementsInfoNV::pname:type set to
    ename:VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV
    must: be less than or equal to the size of pname:scratch minus
    pname:scratchOffset
  * [[VUID-vkCmdBuildAccelerationStructureNV-scratch-03522]]
    pname:scratch must: have been created with the
    ename:VK_BUFFER_USAGE_RAY_TRACING_BIT_NV usage flag set
  * [[VUID-vkCmdBuildAccelerationStructureNV-instanceData-03523]]
    If pname:instanceData is not dlink:VK_NULL_HANDLE, pname:instanceData
    must: have been created with the
    ename:VK_BUFFER_USAGE_RAY_TRACING_BIT_NV usage flag set
  * [[VUID-vkCmdBuildAccelerationStructureNV-accelerationStructureReference-12264]]
    Each
    slink:VkAccelerationStructureInstanceKHR::pname:accelerationStructureReference
    value in pname:instanceData must: be a value obtained from
    flink:vkGetAccelerationStructureHandleNV for a bottom level acceleration
    structure
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-03524]]
    If pname:update is ename:VK_TRUE, then objects that were previously
    active must: not be made inactive as per
    <<acceleration-structure-inactive-prims>>
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-03525]]
    If pname:update is ename:VK_TRUE, then objects that were previously
    inactive must: not be made active as per
    <<acceleration-structure-inactive-prims>>
  * [[VUID-vkCmdBuildAccelerationStructureNV-update-03526]]
    If pname:update is ename:VK_TRUE, the pname:src and pname:dst objects
    must: either be the same object or not have any
    <<resources-memory-aliasing, memory aliasing>>
  * [[VUID-vkCmdBuildAccelerationStructureNV-dst-07787]]
    pname:dst must: be bound completely and contiguously to a single
    sname:VkDeviceMemory object via
    flink:vkBindAccelerationStructureMemoryNV

****

include::{generated}/validity/protos/vkCmdBuildAccelerationStructureNV.adoc[]
--
endif::VK_NV_ray_tracing[]

[open,refpage='VkTransformMatrixKHR',desc='Structure specifying a 3x4 affine transformation matrix',type='structs']
--
:refpage: VkTransformMatrixKHR

The sname:VkTransformMatrixKHR structure is defined as:

include::{generated}/api/structs/VkTransformMatrixKHR.adoc[]

ifdef::VK_NV_ray_tracing[]
include::{generated}/api/structs/VkTransformMatrixNV.adoc[]
endif::VK_NV_ray_tracing[]

  * pname:matrix is a 3x4 row-major affine transformation matrix.

include::{generated}/validity/structs/VkTransformMatrixKHR.adoc[]

.Valid Usage
****
  * [[VUID-VkTransformMatrixKHR-matrix-03799]]
    The first three columns of pname:matrix must: define an invertible 3x3
    matrix
****
--

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='VkAccelerationStructureGeometryAabbsDataKHR',desc='Structure specifying axis-aligned bounding box geometry in a bottom-level acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureGeometryAabbsDataKHR

The sname:VkAccelerationStructureGeometryAabbsDataKHR structure is defined
as:

include::{generated}/api/structs/VkAccelerationStructureGeometryAabbsDataKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:data is a device or host address of memory containing
    slink:VkAabbPositionsKHR structures containing position data for each
    axis-aligned bounding box in the geometry.
  * pname:stride is the stride in bytes between each entry in pname:data.
    The stride must: be a multiple of `8`.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureGeometryAabbsDataKHR-stride-03545]]
    pname:stride must: be a multiple of `8`
  * [[VUID-VkAccelerationStructureGeometryAabbsDataKHR-stride-03820]]
    pname:stride must: be less than or equal to [eq]#2^32^-1#
****

include::{generated}/validity/structs/VkAccelerationStructureGeometryAabbsDataKHR.adoc[]
--
endif::VK_KHR_acceleration_structure[]

[open,refpage='VkAabbPositionsKHR',desc='Structure specifying two opposing corners of an axis-aligned bounding box',type='structs']
--
:refpage: VkAabbPositionsKHR

The sname:VkAabbPositionsKHR structure is defined as:

include::{generated}/api/structs/VkAabbPositionsKHR.adoc[]

ifdef::VK_NV_ray_tracing[]
include::{generated}/api/structs/VkAabbPositionsNV.adoc[]
endif::VK_NV_ray_tracing[]

  * pname:minX is the x position of one opposing corner of a bounding box.
  * pname:minY is the y position of one opposing corner of a bounding box.
  * pname:minZ is the z position of one opposing corner of a bounding box.
  * pname:maxX is the x position of the other opposing corner of a bounding
    box.
  * pname:maxY is the y position of the other opposing corner of a bounding
    box.
  * pname:maxZ is the z position of the other opposing corner of a bounding
    box.

.Valid Usage
****
  * [[VUID-VkAabbPositionsKHR-minX-03546]]
    pname:minX must: be less than or equal to pname:maxX
  * [[VUID-VkAabbPositionsKHR-minY-03547]]
    pname:minY must: be less than or equal to pname:maxY
  * [[VUID-VkAabbPositionsKHR-minZ-03548]]
    pname:minZ must: be less than or equal to pname:maxZ
****

include::{generated}/validity/structs/VkAabbPositionsKHR.adoc[]
--

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='VkAccelerationStructureGeometryInstancesDataKHR',desc='Structure specifying a geometry consisting of instances of other acceleration structures',type='structs']
--
:refpage: VkAccelerationStructureGeometryInstancesDataKHR

The sname:VkAccelerationStructureGeometryInstancesDataKHR structure is
defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryInstancesDataKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:arrayOfPointers specifies whether pname:data is used as an array
    of addresses or just an array.
  * pname:data is either the address of an array of device or host addresses
    referencing individual slink:VkAccelerationStructureInstanceKHR
    structures
ifdef::VK_NV_ray_tracing_motion_blur[]
    or packed motion instance information as described in
    <<acceleration-structure-motion-instances, motion instances>>
endif::VK_NV_ray_tracing_motion_blur[]
    if pname:arrayOfPointers is ename:VK_TRUE, or the address of an array of
    slink:VkAccelerationStructureInstanceKHR
ifdef::VK_NV_ray_tracing_motion_blur[]
    or slink:VkAccelerationStructureMotionInstanceNV
endif::VK_NV_ray_tracing_motion_blur[]
    structures.
    Addresses and slink:VkAccelerationStructureInstanceKHR structures are
    tightly packed.
ifdef::VK_NV_ray_tracing_motion_blur[]
    slink:VkAccelerationStructureMotionInstanceNV structures have a stride
    of 160 bytes.
endif::VK_NV_ray_tracing_motion_blur[]

include::{generated}/validity/structs/VkAccelerationStructureGeometryInstancesDataKHR.adoc[]
--
endif::VK_KHR_acceleration_structure[]

[open,refpage='VkAccelerationStructureInstanceKHR',desc='Structure specifying a single acceleration structure instance for building into an acceleration structure geometry',type='structs']
--
:refpage: VkAccelerationStructureInstanceKHR

_Acceleration structure instances_ can: be built into top-level acceleration
structures.
Each acceleration structure instance is a separate entry in the top-level
acceleration structure which includes all the geometry of a bottom-level
acceleration structure at a transformed location.
Multiple instances can: point to the same bottom level acceleration
structure.

An acceleration structure instance is defined by the structure:

include::{generated}/api/structs/VkAccelerationStructureInstanceKHR.adoc[]

ifdef::VK_NV_ray_tracing[]
include::{generated}/api/structs/VkAccelerationStructureInstanceNV.adoc[]
endif::VK_NV_ray_tracing[]

  * pname:transform is a slink:VkTransformMatrixKHR structure describing a
    transformation to be applied to the acceleration structure.
  * pname:instanceCustomIndex is a 24-bit application-specified index value
    accessible to ray shaders in the code:InstanceCustomIndexKHR built-in.
  * pname:mask is an 8-bit visibility mask for the geometry.
    The instance may: only be hit if `Cull Mask & instance.mask != 0`
  * pname:instanceShaderBindingTableRecordOffset is a 24-bit offset used in
    calculating the hit shader binding table index.
  * pname:flags is an 8-bit mask of elink:VkGeometryInstanceFlagBitsKHR
    values to apply to this instance.
  * pname:accelerationStructureReference is
ifdef::VK_KHR_acceleration_structure[either]
    :
  ** a device address containing the value obtained from
ifdef::VK_KHR_acceleration_structure[flink:vkGetAccelerationStructureDeviceAddressKHR]
ifdef::VK_KHR_acceleration_structure+VK_NV_ray_tracing[or]
ifdef::VK_NV_ray_tracing[flink:vkGetAccelerationStructureHandleNV]
     for a bottom level acceleration structure (used by device operations
     which reference acceleration structures)
ifdef::VK_KHR_acceleration_structure+VK_NV_ray_tracing[or,]
ifdef::VK_NV_cluster_acceleration_structure[]
  ** a device address containing a bottom level cluster acceleration
     structure built using
     flink:vkCmdBuildClusterAccelerationStructureIndirectNV
endif::VK_NV_cluster_acceleration_structure[]
ifdef::VK_KHR_acceleration_structure[]
  ** a slink:VkAccelerationStructureKHR object (used by host operations
     which reference acceleration structures).
endif::VK_KHR_acceleration_structure[]

The C language specification does not define the ordering of bit-fields, but
in practice, this structure produces the correct layout with existing
compilers.
The intended bit pattern is for the following:

  * pname:instanceCustomIndex and pname:mask occupy the same memory as if a
    single code:uint32_t was specified in their place
  ** pname:instanceCustomIndex occupies the 24 least significant bits of
     that memory
  ** pname:mask occupies the 8 most significant bits of that memory
  * pname:instanceShaderBindingTableRecordOffset and pname:flags occupy the
    same memory as if a single code:uint32_t was specified in their place
  ** pname:instanceShaderBindingTableRecordOffset occupies the 24 least
     significant bits of that memory
  ** pname:flags occupies the 8 most significant bits of that memory

If a compiler produces code that diverges from that pattern, applications
must: employ another method to set values according to the correct bit
pattern.

include::{generated}/validity/structs/VkAccelerationStructureInstanceKHR.adoc[]
--

[open,refpage='VkGeometryInstanceFlagBitsKHR',desc='Instance flag bits',type='enums']
--
:refpage: VkGeometryInstanceFlagBitsKHR

Possible values of pname:flags in the instance modifying the behavior of
that instance are:

include::{generated}/api/enums/VkGeometryInstanceFlagBitsKHR.adoc[]

ifdef::VK_NV_ray_tracing[]
include::{generated}/api/enums/VkGeometryInstanceFlagBitsNV.adoc[]
endif::VK_NV_ray_tracing[]

  * ename:VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR disables
    face culling for this instance.
  * ename:VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR specifies that
    the <<ray-traversal-culling-face, facing determination>> for geometry in
    this instance is inverted.
    Because the facing is determined in object space, an instance transform
    does not change the winding, but a geometry transform does.
  * ename:VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR causes this instance to
    act as though ename:VK_GEOMETRY_OPAQUE_BIT_KHR were specified on all
    geometries referenced by this instance.
    This behavior can: be overridden by the SPIR-V code:NoOpaqueKHR ray
    flag.
  * ename:VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR causes this instance
    to act as though ename:VK_GEOMETRY_OPAQUE_BIT_KHR were not specified on
    all geometries referenced by this instance.
    This behavior can: be overridden by the SPIR-V code:OpaqueKHR ray flag.

ename:VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR and
ename:VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR must: not be used in the
same flag.
--

[open,refpage='VkGeometryInstanceFlagsKHR',desc='Bitmask of VkGeometryInstanceFlagBitsKHR',type='flags']
--
:refpage: VkGeometryInstanceFlagsKHR

include::{generated}/api/flags/VkGeometryInstanceFlagsKHR.adoc[]

ifdef::VK_NV_ray_tracing[]
include::{generated}/api/flags/VkGeometryInstanceFlagsNV.adoc[]
endif::VK_NV_ray_tracing[]

tname:VkGeometryInstanceFlagsKHR is a bitmask type for setting a mask of
zero or more elink:VkGeometryInstanceFlagBitsKHR.
--

ifdef::VK_NV_ray_tracing_motion_blur[]
[open,refpage='VkAccelerationStructureMotionInstanceNV',desc='Structure specifying a single acceleration structure motion instance for building into an acceleration structure geometry',type='structs']
--
:refpage: VkAccelerationStructureMotionInstanceNV

_Acceleration structure motion instances_ can: be built into top-level
acceleration structures.
Each acceleration structure instance is a separate entry in the top-level
acceleration structure which includes all the geometry of a bottom-level
acceleration structure at a transformed location including a type of motion
and parameters to determine the motion of the instance over time.

An acceleration structure motion instance is defined by the structure:

include::{generated}/api/structs/VkAccelerationStructureMotionInstanceNV.adoc[]

  * pname:type is a elink:VkAccelerationStructureMotionInstanceTypeNV
    enumerant identifying which type of motion instance this is and which
    type of the union is valid.
  * pname:flags is currently unused, but is required to keep natural
    alignment of pname:data.
  * pname:data is a slink:VkAccelerationStructureMotionInstanceDataNV
    containing motion instance data for this instance.

[NOTE]
====
If writing this other than with a standard C compiler, note that the final
structure should be 152 bytes in size.
====

include::{generated}/validity/structs/VkAccelerationStructureMotionInstanceNV.adoc[]
--

[open,refpage='VkAccelerationStructureMotionInstanceDataNV',desc='Union specifying an acceleration structure motion instance data for building into an acceleration structure geometry',type='structs']
--
:refpage: VkAccelerationStructureMotionInstanceDataNV

Acceleration structure motion instance is defined by the union:

include::{generated}/api/structs/VkAccelerationStructureMotionInstanceDataNV.adoc[]

  * pname:staticInstance is a slink:VkAccelerationStructureInstanceKHR
    structure containing data for a static instance.
  * pname:matrixMotionInstance is a
    slink:VkAccelerationStructureMatrixMotionInstanceNV structure containing
    data for a matrix motion instance.
  * pname:srtMotionInstance is a
    slink:VkAccelerationStructureSRTMotionInstanceNV structure containing
    data for an SRT motion instance.

include::{generated}/validity/structs/VkAccelerationStructureMotionInstanceDataNV.adoc[]
--

[open,refpage='VkAccelerationStructureMotionInstanceFlagsNV',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkAccelerationStructureMotionInstanceFlagsNV.adoc[]

tname:VkAccelerationStructureMotionInstanceFlagsNV is a bitmask type for
setting a mask, but is currently reserved for future use.
--

[open,refpage='VkAccelerationStructureMotionInstanceTypeNV',desc='Enum specifying a type of acceleration structure motion instance data for building into an acceleration structure geometry',type='enums']
--
:refpage: VkAccelerationStructureMotionInstanceTypeNV

The ename:VkAccelerationStructureMotionInstanceTypeNV enumeration is defined
as:

include::{generated}/api/enums/VkAccelerationStructureMotionInstanceTypeNV.adoc[]

  * ename:VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV specifies
    that the instance is a static instance with no instance motion.
  * ename:VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV
    specifies that the instance is a motion instance with motion specified
    by interpolation between two matrices.
  * ename:VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV
    specifies that the instance is a motion instance with motion specified
    by interpolation in the SRT decomposition.
--

[open,refpage='VkAccelerationStructureMatrixMotionInstanceNV',desc='Structure specifying a single acceleration structure matrix motion instance for building into an acceleration structure geometry',type='structs']
--
:refpage: VkAccelerationStructureMatrixMotionInstanceNV

An acceleration structure matrix motion instance is defined by the
structure:

include::{generated}/api/structs/VkAccelerationStructureMatrixMotionInstanceNV.adoc[]

  * pname:transformT0 is a slink:VkTransformMatrixKHR structure describing a
    transformation to be applied to the acceleration structure at time 0.
  * pname:transformT1 is a slink:VkTransformMatrixKHR structure describing a
    transformation to be applied to the acceleration structure at time 1.
  * pname:instanceCustomIndex is a 24-bit application-specified index value
    accessible to ray shaders in the code:InstanceCustomIndexKHR built-in.
  * pname:mask is an 8-bit visibility mask for the geometry.
    The instance may: only be hit if `Cull Mask & instance.mask != 0`
  * pname:instanceShaderBindingTableRecordOffset is a 24-bit offset used in
    calculating the hit shader binding table index.
  * pname:flags is an 8-bit mask of elink:VkGeometryInstanceFlagBitsKHR
    values to apply to this instance.
  * pname:accelerationStructureReference is either:
  ** a device address containing the value obtained from
ifdef::VK_KHR_acceleration_structure[flink:vkGetAccelerationStructureDeviceAddressKHR]
ifdef::VK_KHR_acceleration_structure+VK_NV_ray_tracing[or]
ifdef::VK_NV_ray_tracing[flink:vkGetAccelerationStructureHandleNV]
     (used by device operations which reference acceleration structures) or,
  ** a slink:VkAccelerationStructureKHR object (used by host operations
     which reference acceleration structures).

The C language specification does not define the ordering of bit-fields, but
in practice, this structure produces the correct layout with existing
compilers.
The intended bit pattern is for the following:

  * pname:instanceCustomIndex and pname:mask occupy the same memory as if a
    single code:uint32_t was specified in their place
  ** pname:instanceCustomIndex occupies the 24 least significant bits of
     that memory
  ** pname:mask occupies the 8 most significant bits of that memory
  * pname:instanceShaderBindingTableRecordOffset and pname:flags occupy the
    same memory as if a single code:uint32_t was specified in their place
  ** pname:instanceShaderBindingTableRecordOffset occupies the 24 least
     significant bits of that memory
  ** pname:flags occupies the 8 most significant bits of that memory

If a compiler produces code that diverges from that pattern, applications
must: employ another method to set values according to the correct bit
pattern.

The transform for a matrix motion instance at a point in time is derived by
component-wise linear interpolation of the two transforms.
That is, for a code:time in [0,1] the resulting transform is

  {empty}:: [eq]#pname:transformT0 {times} (1 - code:time) {plus}
            pname:transformT1 {times} code:time#

include::{generated}/validity/structs/VkAccelerationStructureMatrixMotionInstanceNV.adoc[]
--

[open,refpage='VkAccelerationStructureSRTMotionInstanceNV',desc='Structure specifying a single acceleration structure SRT motion instance for building into an acceleration structure geometry',type='structs']
--
:refpage: VkAccelerationStructureSRTMotionInstanceNV

An acceleration structure SRT motion instance is defined by the structure:

include::{generated}/api/structs/VkAccelerationStructureSRTMotionInstanceNV.adoc[]

  * pname:transformT0 is a slink:VkSRTDataNV structure describing a
    transformation to be applied to the acceleration structure at time 0.
  * pname:transformT1 is a slink:VkSRTDataNV structure describing a
    transformation to be applied to the acceleration structure at time 1.
  * pname:instanceCustomIndex is a 24-bit application-specified index value
    accessible to ray shaders in the code:InstanceCustomIndexKHR built-in.
  * pname:mask is an 8-bit visibility mask for the geometry.
    The instance may: only be hit if `Cull Mask & instance.mask != 0`
  * pname:instanceShaderBindingTableRecordOffset is a 24-bit offset used in
    calculating the hit shader binding table index.
  * pname:flags is an 8-bit mask of elink:VkGeometryInstanceFlagBitsKHR
    values to apply to this instance.
  * pname:accelerationStructureReference is either:
  ** a device address containing the value obtained from
ifdef::VK_KHR_acceleration_structure[flink:vkGetAccelerationStructureDeviceAddressKHR]
ifdef::VK_KHR_acceleration_structure+VK_NV_ray_tracing[or]
ifdef::VK_NV_ray_tracing[flink:vkGetAccelerationStructureHandleNV]
     (used by device operations which reference acceleration structures) or,
  ** a slink:VkAccelerationStructureKHR object (used by host operations
     which reference acceleration structures).

The C language specification does not define the ordering of bit-fields, but
in practice, this structure produces the correct layout with existing
compilers.
The intended bit pattern is for the following:

  * pname:instanceCustomIndex and pname:mask occupy the same memory as if a
    single code:uint32_t was specified in their place
  ** pname:instanceCustomIndex occupies the 24 least significant bits of
     that memory
  ** pname:mask occupies the 8 most significant bits of that memory
  * pname:instanceShaderBindingTableRecordOffset and pname:flags occupy the
    same memory as if a single code:uint32_t was specified in their place
  ** pname:instanceShaderBindingTableRecordOffset occupies the 24 least
     significant bits of that memory
  ** pname:flags occupies the 8 most significant bits of that memory

If a compiler produces code that diverges from that pattern, applications
must: employ another method to set values according to the correct bit
pattern.

The transform for a SRT motion instance at a point in time is derived from
component-wise linear interpolation of the two SRT transforms.
That is, for a code:time in [0,1] the resulting transform is

  {empty}:: [eq]#pname:transformT0 {times} (1 - code:time) {plus}
            pname:transformT1 {times} code:time#

include::{generated}/validity/structs/VkAccelerationStructureSRTMotionInstanceNV.adoc[]
--

[open,refpage='VkSRTDataNV',desc='Structure specifying a transform in SRT decomposition',type='structs']
--
:refpage: VkSRTDataNV

An acceleration structure SRT transform is defined by the structure:

include::{generated}/api/structs/VkSRTDataNV.adoc[]

  * pname:sx is the x component of the scale of the transform
  * pname:a is one component of the shear for the transform
  * pname:b is one component of the shear for the transform
  * pname:pvx is the x component of the pivot point of the transform
  * pname:sy is the y component of the scale of the transform
  * pname:c is one component of the shear for the transform
  * pname:pvy is the y component of the pivot point of the transform
  * pname:sz is the z component of the scale of the transform
  * pname:pvz is the z component of the pivot point of the transform
  * pname:qx is the x component of the rotation quaternion
  * pname:qy is the y component of the rotation quaternion
  * pname:qz is the z component of the rotation quaternion
  * pname:qw is the w component of the rotation quaternion
  * pname:tx is the x component of the post-rotation translation
  * pname:ty is the y component of the post-rotation translation
  * pname:tz is the z component of the post-rotation translation

This transform decomposition consists of three elements.
The first is a matrix S, consisting of a scale, shear, and translation,
usually used to define the pivot point of the following rotation.
This matrix is constructed from the parameters above by:

[latexmath]
++++
S =
\left(
    \begin{matrix}
        sx & a  & b  & pvx \\
        0  & sy & c  & pvy \\
        0  & 0  & sz & pvz
    \end{matrix}
\right)
++++

The rotation quaternion is defined as:

  {empty}:: [eq]#code:R = [ pname:qx, pname:qy, pname:qz, pname:qw ]#

This is a rotation around a conceptual normalized axis [eq]#[ ax, ay, az ]#
of amount code:theta such that:

  {empty}:: [eq]#[ pname:qx, pname:qy, pname:qz ] = sin(code:theta/2)
            {times} [ code:ax, code:ay, code:az ]#

and

  {empty}:: [eq]#pname:qw = cos(code:theta/2)#

Finally, the transform has a translation T constructed from the parameters
above by:

[latexmath]
++++
T =
\left(
    \begin{matrix}
        1 & 0 & 0 & tx \\
        0 & 1 & 0 & ty \\
        0 & 0 & 1 & tz
    \end{matrix}
\right)
++++

The effective derived transform is then given by

  {empty}:: [eq]#code:T {times} code:R {times} code:S#

include::{generated}/validity/structs/VkSRTDataNV.adoc[]
--
endif::VK_NV_ray_tracing_motion_blur[]

ifdef::VK_KHR_acceleration_structure[]
ifdef::VK_AMDX_dense_geometry_format[]
[open,refpage='VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX',desc='Structure specifying acceleration structure DGF compressed triangle data',type='structs']
--
:refpage: VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX

If a sname:VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX
structure is included in the pname:pNext chain of a
slink:VkAccelerationStructureGeometryKHR structure whose pname:geometryType
member is ename:VK_GEOMETRY_TYPE_DENSE_GEOMETRY_FORMAT_TRIANGLES_AMDX, then
that structure defines triangle geometry using compressed data.

The sname:VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX
structure is defined as:

include::{generated}/api/structs/VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:compressedData specifies the base address of the compressed data.
  * pname:dataSize specifies the size of the compressed data.
  * pname:numTriangles specifies the total number of triangles encoded in
    the compressed data.
  * pname:numVertices specifies the number of vertices in the compressed
    data.
  * pname:maxPrimitiveIndex specifies the maximum primitive index encoded in
    the compressed data.
  * pname:maxGeometryIndex specifies the maximum geometry index encoded in
    the compressed data.
  * pname:format specifies the elink:VkCompressedTriangleFormatAMDX format
    of the compressed data.

If pname:format is ename:VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_AMDX,
pname:numVertices specifies the sum of vertex counts across all blocks.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX-compressedData-10885]]
    The buffer from which pname:compressedData.deviceAddress is queried
    must: have been created with the
    ename:VK_BUFFER_USAGE_2_COMPRESSED_DATA_DGF1_BIT_AMDX usage flag set
  * [[VUID-VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX-denseGeometryFormat-10886]]
    The <<features-denseGeometryFormat,
    sname:VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX::pname:denseGeometryFormat>>
    feature must: be enabled
  * [[VUID-VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX-format-10887]]
    If pname:format is VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_AMDX, then
    pname:compressedData must: be aligned to
    ename:VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_ALIGNMENT_AMDX (128) bytes
  * [[VUID-VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX-format-10888]]
    If pname:format is VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_AMDX, then
    pname:dataSize must: be a multiple of
    ename:VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_STRIDE_AMDX (128) bytes
ifndef::VK_EXT_opacity_micromap[]
  * [[VUID-VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX-pNext-10889]]
    pname:pNext must: be `NULL`
endif::VK_EXT_opacity_micromap[]
ifdef::VK_EXT_opacity_micromap[]
  * [[VUID-VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX-pNext-10890]]
    pname:pNext must: be `NULL` or a pointer to a valid
    slink:VkAccelerationStructureTrianglesOpacityMicromapEXT structure
  * [[VUID-VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX-pNext-10891]]
    If pname:pNext is a pointer to a valid
    slink:VkAccelerationStructureTrianglesOpacityMicromapEXT structure, the
    <<features-micromap, pname:micromap>> feature must: be enabled
endif::VK_EXT_opacity_micromap[]
****

include::{generated}/validity/structs/VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX.adoc[]
--

[open,refpage='VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_ALIGNMENT_AMDX',desc='Alignment requirement for DGF1 compressed data',type='consts']
--
ename:VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_ALIGNMENT_AMDX is the
alignment requirement in bytes for compressed triangle data as specified in
slink:VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX::pname:compressedData.

include::{generated}/api/enums/VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_ALIGNMENT_AMDX.adoc[]
--

[open,refpage='VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_STRIDE_AMDX',desc='Alignment requirement for DGF1 compressed data',type='consts']
--
ename:VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_STRIDE_AMDX is the stride
requirement in bytes for compressed triangle data as specified in
slink:VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX::pname:dataSize.

include::{generated}/api/enums/VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_STRIDE_AMDX.adoc[]
--

[open,refpage='VkCompressedTriangleFormatAMDX',desc='Available compressed triangle formats',type='enums']
--
:refpage: VkCompressedTriangleFormatAMDX

The ename:VkCompressedTriangleFormatAMDX enumeration is defined as:

include::{generated}/api/enums/VkCompressedTriangleFormatAMDX.adoc[]

  * ename:VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_AMDX specifies that the
    compressed triangle data is in <<dense-geometry-format, Dense Geometry
    Format>>, version 1, consisting of an array of 128B DGF blocks.
--
endif::VK_AMDX_dense_geometry_format[]

[open,refpage='VkAccelerationStructureBuildRangeInfoKHR',desc='Structure specifying build offsets and counts for acceleration structure builds',type='structs']
--
:refpage: VkAccelerationStructureBuildRangeInfoKHR

sname:VkAccelerationStructureBuildRangeInfoKHR is defined as:

include::{generated}/api/structs/VkAccelerationStructureBuildRangeInfoKHR.adoc[]

  * pname:primitiveCount defines the number of primitives for a
    corresponding acceleration structure geometry.
  * pname:primitiveOffset defines an offset in bytes into the memory where
    primitive data is defined.
  * pname:firstVertex is the index of the first vertex to build from for
    triangle geometry.
  * pname:transformOffset defines an offset in bytes into the memory where a
    transform matrix is defined.

The primitive count and primitive offset are interpreted differently
depending on the elink:VkGeometryTypeKHR used:

  * For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR,
    pname:primitiveCount is the number of triangles to be built, where each
    triangle is treated as 3 vertices.
  ** If the geometry uses indices, [eq]#pname:primitiveCount {times} 3#
     indices are consumed from
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:indexData,
     starting at an offset of pname:primitiveOffset.
     The value of pname:firstVertex is added to the index values before
     fetching vertices.
  ** If the geometry does not use indices, [eq]#pname:primitiveCount {times}
     3# vertices are consumed from
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexData,
     starting at an offset of [eq]#pname:primitiveOffset {plus}
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexStride
     {times} pname:firstVertex#.
  ** If
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:transformData
     is not `NULL`, a single slink:VkTransformMatrixKHR structure is
     consumed from
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:transformData,
     at an offset of pname:transformOffset.
     This matrix describes a transformation from the space in which the
     vertices for all triangles in this geometry are described to the space
     in which the acceleration structure is defined.
  * For geometries of type ename:VK_GEOMETRY_TYPE_AABBS_KHR,
    pname:primitiveCount is the number of axis-aligned bounding boxes.
    pname:primitiveCount slink:VkAabbPositionsKHR structures are consumed
    from slink:VkAccelerationStructureGeometryAabbsDataKHR::pname:data,
    starting at an offset of pname:primitiveOffset.
ifdef::VK_NV_ray_tracing_linear_swept_spheres[]
  * For geometries of type ename:VK_GEOMETRY_TYPE_SPHERES_NV,
    pname:primitiveCount is the number of spheres to be built, where each
    sphere is treated as 1 vertex.
  ** If the geometry uses indices, pname:primitiveCount indices are consumed
     from
     slink:VkAccelerationStructureGeometrySpheresDataNV::pname:indexData,
     starting at an offset of pname:primitiveOffset.
     The value of pname:firstVertex is added to the index values before
     fetching vertices and radii.
  ** If the geometry does not use indices, pname:primitiveCount vertices and
     radii are consumed from
     slink:VkAccelerationStructureGeometrySpheresDataNV::pname:vertexData,
     starting at an offset of [eq]#pname:primitiveOffset {plus}
     slink:VkAccelerationStructureGeometrySpheresDataNV::pname:vertexStride
     {times} pname:firstVertex# and
     slink:VkAccelerationStructureGeometrySpheresDataNV::pname:radiusData,
     starting at an offset of [eq]#pname:primitiveOffset {plus}
     slink:VkAccelerationStructureGeometrySpheresDataNV::pname:radiusStride
     {times} pname:firstVertex# respectively.
  * For geometries of type ename:VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV,
    pname:primitiveCount is the number of LSS primitives to be built, where
    each LSS primitive is treated as 2 vertices.
  ** If the geometry uses indices, [eq]#pname:primitiveCount {times} 2#
     indices are consumed from
     slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV::pname:indexData,
     starting at an offset of pname:primitiveOffset.
     The value of pname:firstVertex is added to the index values before
     fetching vertices and radii.
  ** If the geometry does not use indices, [eq]#pname:primitiveCount {times}
     2# vertices and radii are consumed from
     slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV::pname:vertexData,
     starting at an offset of [eq]#pname:primitiveOffset {plus}
     slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV::pname:vertexStride
     {times} pname:firstVertex# and
     slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV::pname:radiusData,
     starting at an offset of [eq]#pname:primitiveOffset {plus}
     slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV::pname:radiusStride
     {times} pname:firstVertex# respectively.
endif::VK_NV_ray_tracing_linear_swept_spheres[]
  * For geometries of type ename:VK_GEOMETRY_TYPE_INSTANCES_KHR,
    pname:primitiveCount is the number of acceleration structures.
    pname:primitiveCount slink:VkAccelerationStructureInstanceKHR
ifdef::VK_NV_ray_tracing_motion_blur[]
    or slink:VkAccelerationStructureMotionInstanceNV
endif::VK_NV_ray_tracing_motion_blur[]
    structures are consumed from
    slink:VkAccelerationStructureGeometryInstancesDataKHR::pname:data,
    starting at an offset of pname:primitiveOffset.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureBuildRangeInfoKHR-vertexData-10418]]
    The number of vertices consumed from
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexData
    must: be less than or equal to
    [eq]#slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:maxVertex
    + 1#
  * [[VUID-VkAccelerationStructureBuildRangeInfoKHR-primitiveOffset-03656]]
    For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if the
    geometry uses indices, the offset pname:primitiveOffset from
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:indexData
    must: be a multiple of the element size of
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:indexType
  * [[VUID-VkAccelerationStructureBuildRangeInfoKHR-primitiveOffset-03657]]
    For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if the
    geometry does not use indices, the offset pname:primitiveOffset from
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexData
    must: be a multiple of:
  ** the <<formats, size of the format>> specified in
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexFormat,
     if that format is a <<formats-packed,packed format>>
  ** the <<formats, component size>> of the
     slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:vertexFormat,
     if that format is not a <<formats-packed,packed format>>
  * [[VUID-VkAccelerationStructureBuildRangeInfoKHR-maxVertex-10774]]
    For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if the
    geometry uses indices, then
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:maxVertex
    must: be greater than or equal to pname:firstVertex plus the maximum
    index value found in the
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:indexData
    in the range [eq]#[pname:primitiveOffset, pname:primitiveOffset +
    pname:primitiveCount x 3]#
  * [[VUID-VkAccelerationStructureBuildRangeInfoKHR-None-10775]]
    For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if the
    geometry does not use indices, then
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::maxVertex must:
    be greater than or equal to [eq]#firstVertex + primitiveCount x 3 - 1#
  * [[VUID-VkAccelerationStructureBuildRangeInfoKHR-transformOffset-03658]]
    For geometries of type ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, the offset
    pname:transformOffset from
    slink:VkAccelerationStructureGeometryTrianglesDataKHR::pname:transformData
    must: be a multiple of 16
  * [[VUID-VkAccelerationStructureBuildRangeInfoKHR-primitiveOffset-03659]]
    For geometries of type ename:VK_GEOMETRY_TYPE_AABBS_KHR, the offset
    pname:primitiveOffset from
    slink:VkAccelerationStructureGeometryAabbsDataKHR::pname:data must: be a
    multiple of 8
  * [[VUID-VkAccelerationStructureBuildRangeInfoKHR-primitiveOffset-03660]]
    For geometries of type ename:VK_GEOMETRY_TYPE_INSTANCES_KHR, the offset
    pname:primitiveOffset from
    slink:VkAccelerationStructureGeometryInstancesDataKHR::pname:data must:
    be a multiple of 16
****

include::{generated}/validity/structs/VkAccelerationStructureBuildRangeInfoKHR.adoc[]
--
endif::VK_KHR_acceleration_structure[]

ifdef::VK_NV_ray_tracing_linear_swept_spheres[]

[open,refpage='VkAccelerationStructureGeometryLinearSweptSpheresDataNV',desc='Structure specifying a LSS geometry in a bottom-level acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureGeometryLinearSweptSpheresDataNV

If sname:VkAccelerationStructureGeometryLinearSweptSpheresDataNV is included
in the pname:pNext chain of a slink:VkAccelerationStructureGeometryKHR
structure, then that structures defines the linear swept sphere's (LSS)
geometry data.

The sname:VkAccelerationStructureGeometryLinearSweptSpheresDataNV structure
is defined as:

include::{generated}/api/structs/VkAccelerationStructureGeometryLinearSweptSpheresDataNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:vertexFormat is the elink:VkFormat of each LSS vertex element.
  * pname:vertexData is a device or host address of memory containing vertex
    data for this geometry.
  * pname:vertexStride is the stride in bytes between each vertex element.
  * pname:radiusFormat is the elink:VkFormat of each LSS radius.
  * pname:radiusData is a device or host address of memory containing LSS
    radius data value.
  * pname:radiusStride is the stride in bytes between each radius value.
  * pname:indexType is the elink:VkIndexType of each index element.
  * pname:indexData is a device or host address of memory containing index
    data for vertex and radius buffers for this geometry.
    When pname:indexType is ename:VK_INDEX_TYPE_NONE_KHR it must: be `NULL`.
  * pname:indexStride is the stride in bytes between each index element.
  * pname:indexingMode is a elink:VkRayTracingLssIndexingModeNV value
    specifying the mode of indexing.
  * pname:endCapsMode is a elink:VkRayTracingLssPrimitiveEndCapsModeNV value
    specifying the endcaps mode for LSS primitives.

If an index buffer is not specified in pname:indexData, LSS primitives are
rendered individually using subsequent pairs of vertices similar to
ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-None-10419]]
    The <<features-linearSweptSpheres, linearSweptSpheres>> feature must: be
    enabled
  * [[VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-vertexStride-10421]]
    pname:vertexStride must: be a multiple of:
  ** the <<formats, size of the format>> specified in pname:vertexFormat if
     that format is a <<formats-packed,packed format>>
  ** the <<formats, component size>> specified in pname:vertexFormat if that
     format is not a <<formats-packed,packed format>>
  * [[VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-vertexStride-10422]]
    pname:vertexStride and pname:radiusStride must: be less than or equal to
    [eq]#2^32^-1#
  * [[VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-vertexFormat-10423]]
    The <<resources-buffer-view-format-features,format features>> of
    pname:vertexFormat must: contain
    ename:VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR
  * [[VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-radiusFormat-10424]]
    The <<resources-buffer-view-format-features,format features>> of
    pname:radiusFormat must: contain
    ename:VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV
  * [[VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-radiusData-10426]]
    All values referenced in pname:radiusData must: be greater than or equal
    to `0`
  * [[VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-indexingMode-10427]]
    If pname:indexingMode is
    ename:VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV, pname:indexData
    must: not be `NULL`
  * [[VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-indexData-10428]]
    pname:indexType must: be ename:VK_INDEX_TYPE_UINT16,
    ename:VK_INDEX_TYPE_UINT32, or ename:VK_INDEX_TYPE_NONE_KHR
****

include::{generated}/validity/structs/VkAccelerationStructureGeometryLinearSweptSpheresDataNV.adoc[]
--

[open,refpage='VkRayTracingLssIndexingModeNV',desc='LSS indexing mode',type='enums']
--
Chaining LSS primitives can: be achieved by specifying an index buffer in
slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV::pname:indexData
and setting
slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV::pname:indexingMode
to one of ename:VkRayTracingLssIndexingModeNV values:

include::{generated}/api/enums/VkRayTracingLssIndexingModeNV.adoc[]

  * ename:VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV specifies that a list of
    indices is provided where each consecutive pair of indices define a LSS
    primitive.
  * ename:VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV specifies a
    successive implicit indexing format, in which each LSS primitive is
    defined by two successive positions and radii, [eq]#(k, k + 1)#, where
    [eq]#k# is a single index provided in the index buffer.
    In this indexing scheme, there is a 1:1 mapping between the index buffer
    and primitive index within the geometry.
--

[open,refpage='VkRayTracingLssPrimitiveEndCapsModeNV',desc='LSS endcaps mode',type='enums']
--

The default behavior with endcaps in a LSS chain is that both endcaps will
be enabled for all beginning and end points.
To change the LSS chain's endcaps mode use
slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV::pname:endCapsMode.
The possible values for pname:endCapsMode are:

include::{generated}/api/enums/VkRayTracingLssPrimitiveEndCapsModeNV.adoc[]

  * ename:VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV disables all
    endcaps and the chain boundaries have no influence.
  * ename:VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV specifies
    that when ename:VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV is used
    as indexing mode for the LSS primitive, the first primitive in each
    chain will have both endcaps enabled, and every following primitive in
    the chain only has endcaps at the trailing position enabled.
--

In addition to LSS primitives, simple sphere geometry is also supported.
Spheres do not have an endcap mode.
If an index buffer is present, each entry represents a single position and
radius describing one sphere primitive.
If no index buffer is provided, the vertex position and radius values are
sequentially read from the corresponding buffers.

[open,refpage='VkAccelerationStructureGeometrySpheresDataNV',desc='Structure specifying a sphere geometry in a bottom-level acceleration structure',type='structs']
--
:refpage: VkAccelerationStructureGeometrySpheresDataNV

If sname:VkAccelerationStructureGeometrySpheresDataNV is included in the
pname:pNext chain of a slink:VkAccelerationStructureGeometryKHR structure,
then that structures defines the sphere's geometry data.

The sname:VkAccelerationStructureGeometrySpheresDataNV structure is defined
as:

include::{generated}/api/structs/VkAccelerationStructureGeometrySpheresDataNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:vertexFormat is the elink:VkFormat of each sphere's vertex
    element.
  * pname:vertexData is a device or host address of memory containing vertex
    data in form of pairs of centers of spheres that define all sphere
    geometry.
  * pname:vertexStride is the stride in bytes between each vertex element.
  * pname:radiusFormat is the elink:VkFormat of each sphere's radius.
  * pname:radiusData is a device or host address of memory containing
    sphere's radius data value.
  * pname:radiusStride is the stride in bytes between each radius value.
  * pname:indexType is the elink:VkIndexType of each index element.
  * pname:indexData is a device or host address of memory containing index
    data for vertex and radius buffers for this geometry.
    When pname:indexType is ename:VK_INDEX_TYPE_NONE_KHR it must: be `NULL`.
  * pname:indexStride is the stride in bytes between each index element.

.Valid Usage
****
  * [[VUID-VkAccelerationStructureGeometrySpheresDataNV-None-10429]]
    The <<features-spheres, spheres>> feature must: be enabled
  * [[VUID-VkAccelerationStructureGeometrySpheresDataNV-vertexStride-10431]]
    pname:vertexStride must: be a multiple of:
  ** the <<formats, size of the format>> specified in pname:vertexFormat if
     that format is a <<formats-packed,packed format>>
  ** the smallest <<formats, component size>> specified in
     pname:vertexFormat if that format is not a <<formats-packed,packed
     format>>
  * [[VUID-VkAccelerationStructureGeometrySpheresDataNV-vertexStride-10432]]
    pname:vertexStride and pname:radiusStride must: be less than or equal to
    [eq]#2^32^-1#
  * [[VUID-VkAccelerationStructureGeometrySpheresDataNV-vertexFormat-10434]]
    The <<resources-buffer-view-format-features,format features>> of
    pname:vertexFormat must: contain
    ename:VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR
  * [[VUID-VkAccelerationStructureGeometrySpheresDataNV-radiusFormat-10435]]
    The <<resources-buffer-view-format-features,format features>> of
    pname:radiusFormat must: contain
    ename:VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV
  * [[VUID-VkAccelerationStructureGeometrySpheresDataNV-radiusData-10436]]
    All values referenced in pname:radiusData must: be greater than or equal
    to `0`
  * [[VUID-VkAccelerationStructureGeometrySpheresDataNV-indexData-10437]]
    pname:indexType must: be ename:VK_INDEX_TYPE_UINT16,
    ename:VK_INDEX_TYPE_UINT32, ename:VK_INDEX_TYPE_NONE_KHR
****

include::{generated}/validity/structs/VkAccelerationStructureGeometrySpheresDataNV.adoc[]
--

endif::VK_NV_ray_tracing_linear_swept_spheres[]

[[acceleration-structure-copying]]
=== Copying Acceleration Structures

An additional command exists for copying acceleration structures without
updating their contents.
The acceleration structure object can: be compacted in order to improve
performance.
Before copying, an application must: query the size of the resulting
acceleration structure.

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='vkCmdWriteAccelerationStructuresPropertiesKHR',desc='Write acceleration structure result parameters to query results.',type='protos']
--
:refpage: vkCmdWriteAccelerationStructuresPropertiesKHR

To query acceleration structure size parameters call:

include::{generated}/api/protos/vkCmdWriteAccelerationStructuresPropertiesKHR.adoc[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:accelerationStructureCount is the count of acceleration structures
    for which to query the property.
  * pname:pAccelerationStructures is a pointer to an array of existing
    previously built acceleration structures.
  * pname:queryType is a elink:VkQueryType value specifying the type of
    queries managed by the pool.
  * pname:queryPool is the query pool that will manage the results of the
    query.
  * pname:firstQuery is the first query index within the query pool that
    will contain the pname:accelerationStructureCount number of results.

Accesses to any of the acceleration structures listed in
pname:pAccelerationStructures must: be <<synchronization-dependencies,
synchronized>> with the
ifdef::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> or the
endif::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>>, and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR.

  * If pname:queryType is
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR, then the
    value written out is the number of bytes required by a compacted
    acceleration structure.
  * If pname:queryType is
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR, then
    the value written out is the number of bytes required by a serialized
    acceleration structure.

.Valid Usage
****
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-accelerationStructure-08924]]
    The <<features-accelerationStructure,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructure>>
    feature must: be enabled
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryPool-02493]]
    pname:queryPool must: have been created with a pname:queryType matching
    pname:queryType
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryPool-02494]]
    The queries identified by pname:queryPool and pname:firstQuery must: be
    _unavailable_
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-buffer-03736]]
    The pname:buffer used to create each acceleration structure in
    pname:pAccelerationStructures must: be bound to device memory
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-query-04880]]
    The sum of pname:firstQuery plus pname:accelerationStructureCount must:
    be less than or equal to the number of queries in pname:queryPool
include::{chapters}/commonvalidity/write_acceleration_structure_properties_common.adoc[]
****

include::{generated}/validity/protos/vkCmdWriteAccelerationStructuresPropertiesKHR.adoc[]
--
endif::VK_KHR_acceleration_structure[]

ifdef::VK_NV_ray_tracing[]
[open,refpage='vkCmdWriteAccelerationStructuresPropertiesNV',desc='Write acceleration structure result parameters to query results.',type='protos']
--
:refpage: vkCmdWriteAccelerationStructuresPropertiesNV

To query acceleration structure size parameters for the
`apiext:VK_NV_ray_tracing` extension call:

include::{generated}/api/protos/vkCmdWriteAccelerationStructuresPropertiesNV.adoc[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:accelerationStructureCount is the count of acceleration structures
    for which to query the property.
  * pname:pAccelerationStructures is a pointer to an array of existing
    previously built acceleration structures.
  * pname:queryType is a elink:VkQueryType value specifying the type of
    queries managed by the pool.
  * pname:queryPool is the query pool that will manage the results of the
    query.
  * pname:firstQuery is the first query index within the query pool that
    will contain the pname:accelerationStructureCount number of results.

Accesses to any of the acceleration structures listed in
pname:pAccelerationStructures must: be <<synchronization-dependencies,
synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR.

.Valid Usage
****
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryPool-03755]]
    pname:queryPool must: have been created with a pname:queryType matching
    pname:queryType
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryPool-03756]]
    The queries identified by pname:queryPool and pname:firstQuery must: be
    _unavailable_
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesNV-accelerationStructure-03757]]
    pname:accelerationStructure must: be bound completely and contiguously
    to a single sname:VkDeviceMemory object via
    flink:vkBindAccelerationStructureMemoryNV
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesNV-pAccelerationStructures-04958]]
    All acceleration structures in pname:pAccelerationStructures must: have
    been built prior to the execution of this command
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesNV-pAccelerationStructures-06215]]
    All acceleration structures in pname:pAccelerationStructures must: have
    been built with
    ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR if
    pname:queryType is
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV
  * [[VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryType-06216]]
    pname:queryType must: be
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV
****

include::{generated}/validity/protos/vkCmdWriteAccelerationStructuresPropertiesNV.adoc[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='vkCmdCopyAccelerationStructureKHR',desc='Copy an acceleration structure',type='protos']
--
:refpage: vkCmdCopyAccelerationStructureKHR

To copy an acceleration structure call:

include::{generated}/api/protos/vkCmdCopyAccelerationStructureKHR.adoc[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pInfo is a pointer to a slink:VkCopyAccelerationStructureInfoKHR
    structure defining the copy operation.

This command copies the pname:pInfo->src acceleration structure to the
pname:pInfo->dst acceleration structure in the manner specified by
pname:pInfo->mode.

Accesses to pname:pInfo->src and pname:pInfo->dst must: be
<<synchronization-dependencies, synchronized>> with the
ifdef::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> or the
endif::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>>, and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR or
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR as appropriate.

.Valid Usage
****
  * [[VUID-vkCmdCopyAccelerationStructureKHR-accelerationStructure-08925]]
    The <<features-accelerationStructure,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructure>>
    feature must: be enabled
  * [[VUID-vkCmdCopyAccelerationStructureKHR-buffer-03737]]
    The pname:buffer used to create pname:pInfo->src must: be bound to
    device memory
  * [[VUID-vkCmdCopyAccelerationStructureKHR-buffer-03738]]
    The pname:buffer used to create pname:pInfo->dst must: be bound to
    device memory
****

include::{generated}/validity/protos/vkCmdCopyAccelerationStructureKHR.adoc[]
--

[open,refpage='VkCopyAccelerationStructureInfoKHR',desc='Parameters for copying an acceleration structure',type='structs']
--
:refpage: VkCopyAccelerationStructureInfoKHR

The sname:VkCopyAccelerationStructureInfoKHR structure is defined as:

include::{generated}/api/structs/VkCopyAccelerationStructureInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:src is the source acceleration structure for the copy.
  * pname:dst is the target acceleration structure for the copy.
  * pname:mode is a elink:VkCopyAccelerationStructureModeKHR value
    specifying additional operations to perform during the copy.

.Valid Usage
****
include::{chapters}/commonvalidity/copy_acceleration_structure_common.adoc[]
****

include::{generated}/validity/structs/VkCopyAccelerationStructureInfoKHR.adoc[]
--
endif::VK_KHR_acceleration_structure[]

ifdef::VK_NV_ray_tracing[]
[open,refpage='vkCmdCopyAccelerationStructureNV',desc='Copy an acceleration structure',type='protos']
--
:refpage: vkCmdCopyAccelerationStructureNV

To copy an acceleration structure for the `apiext:VK_NV_ray_tracing`
extension call:

include::{generated}/api/protos/vkCmdCopyAccelerationStructureNV.adoc[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:dst is the target acceleration structure for the copy.
  * pname:src is the source acceleration structure for the copy.
  * pname:mode is a elink:VkCopyAccelerationStructureModeKHR value
    specifying additional operations to perform during the copy.

Accesses to pname:src and pname:dst must: be <<synchronization-dependencies,
synchronized>> with the
ifdef::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> or the
endif::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>>, and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR or
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR as appropriate.

.Valid Usage
****
include::{chapters}/commonvalidity/copy_acceleration_structure_common.adoc[]
  * [[VUID-vkCmdCopyAccelerationStructureNV-dst-07792]]
    pname:dst must: be bound completely and contiguously to a single
    sname:VkDeviceMemory object via
    flink:vkBindAccelerationStructureMemoryNV
****

include::{generated}/validity/protos/vkCmdCopyAccelerationStructureNV.adoc[]
--
endif::VK_NV_ray_tracing[]

[open,refpage='VkCopyAccelerationStructureModeKHR',desc='Acceleration structure copy mode',type='enums']
--
:refpage: VkCopyAccelerationStructureModeKHR

Possible values of pname:mode specifying additional operations to perform
during the copy, are:

include::{generated}/api/enums/VkCopyAccelerationStructureModeKHR.adoc[]

ifdef::VK_NV_ray_tracing[]
include::{generated}/api/enums/VkCopyAccelerationStructureModeNV.adoc[]
endif::VK_NV_ray_tracing[]

  * ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR creates a direct
    copy of the acceleration structure specified in pname:src into the one
    specified by pname:dst.
    The pname:dst acceleration structure must: have been created with the
    same parameters as pname:src.
    If pname:src contains references to other acceleration structures,
    pname:dst will reference the same acceleration structures.
  * ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR creates a more
    compact version of an acceleration structure pname:src into pname:dst.
    The acceleration structure pname:dst must: have been created with a size
    at least as large as that returned by
ifdef::VK_NV_ray_tracing[flink:vkCmdWriteAccelerationStructuresPropertiesNV]
ifdef::VK_NV_ray_tracing+VK_KHR_acceleration_structure[,]
ifdef::VK_KHR_acceleration_structure[]
    flink:vkCmdWriteAccelerationStructuresPropertiesKHR, or
    flink:vkWriteAccelerationStructuresPropertiesKHR
endif::VK_KHR_acceleration_structure[]
    after the build of the acceleration structure specified by pname:src.
    If pname:src contains references to other acceleration structures,
    pname:dst will reference the same acceleration structures.
ifdef::VK_KHR_acceleration_structure[]
  * ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR serializes the
    acceleration structure to a semi-opaque format which can be reloaded on
    a compatible implementation.
  * ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR deserializes
    the semi-opaque serialization format in the buffer to the acceleration
    structure.
endif::VK_KHR_acceleration_structure[]
--

ifdef::VK_KHR_acceleration_structure[]
[open,refpage='vkCmdCopyAccelerationStructureToMemoryKHR',desc='Copy an acceleration structure to device memory',type='protos']
--
:refpage: vkCmdCopyAccelerationStructureToMemoryKHR

To copy an acceleration structure to device memory call:

include::{generated}/api/protos/vkCmdCopyAccelerationStructureToMemoryKHR.adoc[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pInfo is a pointer to a
    slink:VkCopyAccelerationStructureToMemoryInfoKHR structure defining the
    copy operation.

Accesses to pname:pInfo->src must: be <<synchronization-dependencies,
synchronized>> with the
ifdef::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> or the
endif::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>>, and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR.
Accesses to the buffer indicated by pname:pInfo->dst.deviceAddress must: be
synchronized with the
ifdef::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> or the
endif::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>>, and an access type of
ename:VK_ACCESS_TRANSFER_WRITE_BIT.

This command produces the same results as
flink:vkCopyAccelerationStructureToMemoryKHR, but writes its result to a
device address, and is executed on the device rather than the host.
The output may: not necessarily be bit-for-bit identical, but it can be
equally used by either flink:vkCmdCopyMemoryToAccelerationStructureKHR or
flink:vkCopyMemoryToAccelerationStructureKHR.

[[serialized-as-header]]
The defined header structure for the serialized data consists of:

  * ename:VK_UUID_SIZE bytes of data matching
    sname:VkPhysicalDeviceIDProperties::pname:driverUUID
  * ename:VK_UUID_SIZE bytes of data identifying the compatibility for
    comparison using flink:vkGetDeviceAccelerationStructureCompatibilityKHR
  * A 64-bit integer of the total size matching the value queried using
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR
  * A 64-bit integer of the deserialized size to be passed in to
    sname:VkAccelerationStructureCreateInfoKHR::pname:size
  * A 64-bit integer of the count of the number of acceleration structure
    handles following.
ifdef::VK_KHR_ray_tracing_maintenance1[]
    This value matches the value queried using
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR.
endif::VK_KHR_ray_tracing_maintenance1[]
    This will be zero for a bottom-level acceleration structure.
    For top-level acceleration structures this number is
    implementation-dependent; the number of and ordering of the handles may
    not match the instance descriptions which were used to build the
    acceleration structure.

The corresponding handles matching the values returned by
ifdef::VK_KHR_acceleration_structure[flink:vkGetAccelerationStructureDeviceAddressKHR]
ifdef::VK_KHR_acceleration_structure+VK_NV_ray_tracing[or]
ifdef::VK_NV_ray_tracing[flink:vkGetAccelerationStructureHandleNV]
are tightly packed in the buffer following the count.
The application is expected to store a mapping between those handles and the
original application-generated bottom-level acceleration structures to
provide when deserializing.
The serialized data is written to the buffer (or read from the buffer)
according to the host endianness.

.Valid Usage
****
  * [[VUID-vkCmdCopyAccelerationStructureToMemoryKHR-accelerationStructure-08926]]
    The <<features-accelerationStructure,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructure>>
    feature must: be enabled
  * [[VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-03739]]
    pname:pInfo->dst.deviceAddress must: be a valid basetype:VkDeviceAddress
  * [[VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-03740]]
    pname:pInfo->dst.deviceAddress must: be aligned to `256` bytes
  * [[VUID-vkCmdCopyAccelerationStructureToMemoryKHR-None-03559]]
    The pname:buffer used to create pname:pInfo->src must: be bound to
    device memory
****

include::{generated}/validity/protos/vkCmdCopyAccelerationStructureToMemoryKHR.adoc[]
--

[open,refpage='VkCopyAccelerationStructureToMemoryInfoKHR',desc='Parameters for serializing an acceleration structure',type='structs']
--
:refpage: VkCopyAccelerationStructureToMemoryInfoKHR

include::{generated}/api/structs/VkCopyAccelerationStructureToMemoryInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:src is the source acceleration structure for the copy.
  * pname:dst is the device or host address of memory which is the target
    for the copy.
  * pname:mode is a elink:VkCopyAccelerationStructureModeKHR value
    specifying additional operations to perform during the copy.

.Valid Usage
****
  * [[VUID-VkCopyAccelerationStructureToMemoryInfoKHR-src-04959]]
    The source acceleration structure pname:src must: have been constructed
    prior to the execution of this command
  * [[VUID-VkCopyAccelerationStructureToMemoryInfoKHR-dst-03561]]
    The memory pointed to by pname:dst must: be at least as large as the
    serialization size of pname:src, as reported by
    flink:vkWriteAccelerationStructuresPropertiesKHR or
    flink:vkCmdWriteAccelerationStructuresPropertiesKHR with a query type of
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR
  * [[VUID-VkCopyAccelerationStructureToMemoryInfoKHR-mode-03412]]
    pname:mode must: be
    ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR
****

include::{generated}/validity/structs/VkCopyAccelerationStructureToMemoryInfoKHR.adoc[]
--

[open,refpage='vkCmdCopyMemoryToAccelerationStructureKHR',desc='Copy device memory to an acceleration structure',type='protos']
--
:refpage: vkCmdCopyMemoryToAccelerationStructureKHR

To copy device memory to an acceleration structure call:

include::{generated}/api/protos/vkCmdCopyMemoryToAccelerationStructureKHR.adoc[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pInfo is a pointer to a
    slink:VkCopyMemoryToAccelerationStructureInfoKHR structure defining the
    copy operation.

Accesses to pname:pInfo->dst must: be <<synchronization-dependencies,
synchronized>> with the
ifdef::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> or the
endif::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>>, and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR.
Accesses to the buffer indicated by pname:pInfo->src.deviceAddress must: be
synchronized with the
ifdef::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> or the
endif::VK_BASE_VERSION_1_3,VK_KHR_synchronization2[]
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>>, and an access type of
ename:VK_ACCESS_TRANSFER_READ_BIT.

This command can accept acceleration structures produced by either
flink:vkCmdCopyAccelerationStructureToMemoryKHR or
flink:vkCopyAccelerationStructureToMemoryKHR.

The structure provided as input to deserialize is as described in
flink:vkCmdCopyAccelerationStructureToMemoryKHR, with any acceleration
structure handles filled in with the newly-queried handles to bottom level
acceleration structures created before deserialization.
These do not need to be built at deserialize time, but must: be created.

.Valid Usage
****
  * [[VUID-vkCmdCopyMemoryToAccelerationStructureKHR-accelerationStructure-08927]]
    The <<features-accelerationStructure,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructure>>
    feature must: be enabled
  * [[VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-03742]]
    pname:pInfo->src.deviceAddress must: be a valid basetype:VkDeviceAddress
  * [[VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-03743]]
    pname:pInfo->src.deviceAddress must: be aligned to `256` bytes
  * [[VUID-vkCmdCopyMemoryToAccelerationStructureKHR-buffer-03745]]
    The pname:buffer used to create pname:pInfo->dst must: be bound to
    device memory
****

include::{generated}/validity/protos/vkCmdCopyMemoryToAccelerationStructureKHR.adoc[]
--

[open,refpage='VkCopyMemoryToAccelerationStructureInfoKHR',desc='Parameters for deserializing an acceleration structure',type='structs']
--
:refpage: VkCopyMemoryToAccelerationStructureInfoKHR

The sname:VkCopyMemoryToAccelerationStructureInfoKHR structure is defined
as:

include::{generated}/api/structs/VkCopyMemoryToAccelerationStructureInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:src is the device or host address of memory containing the source
    data for the copy.
  * pname:dst is the target acceleration structure for the copy.
  * pname:mode is a elink:VkCopyAccelerationStructureModeKHR value
    specifying additional operations to perform during the copy.

.Valid Usage
****
  * [[VUID-VkCopyMemoryToAccelerationStructureInfoKHR-src-04960]]
    The source memory pointed to by pname:src must: contain data previously
    serialized using flink:vkCmdCopyAccelerationStructureToMemoryKHR,
    potentially modified to relocate acceleration structure references as
    described in that command
  * [[VUID-VkCopyMemoryToAccelerationStructureInfoKHR-mode-03413]]
    pname:mode must: be
    ename:VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR
  * [[VUID-VkCopyMemoryToAccelerationStructureInfoKHR-pInfo-03414]]
    The data in pname:src must: have a format compatible with the
    destination physical device as returned by
    flink:vkGetDeviceAccelerationStructureCompatibilityKHR
  * [[VUID-VkCopyMemoryToAccelerationStructureInfoKHR-dst-03746]]
    pname:dst must: have been created with a pname:size greater than or
    equal to that used to serialize the data in pname:src
****

include::{generated}/validity/structs/VkCopyMemoryToAccelerationStructureInfoKHR.adoc[]
--

[open,refpage='vkGetDeviceAccelerationStructureCompatibilityKHR',desc='Check if a serialized acceleration structure is compatible with the current device',type='protos']
--
:refpage: vkGetDeviceAccelerationStructureCompatibilityKHR

To check if a serialized acceleration structure is compatible with the
current device call:

include::{generated}/api/protos/vkGetDeviceAccelerationStructureCompatibilityKHR.adoc[]

  * pname:device is the device to check the version against.
  * pname:pVersionInfo is a pointer to a
    slink:VkAccelerationStructureVersionInfoKHR structure specifying version
    information to check against the device.
  * pname:pCompatibility is a pointer to a
    elink:VkAccelerationStructureCompatibilityKHR value in which
    compatibility information is returned.

.Valid Usage
****
  * [[VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-accelerationStructure-08928]]
    The <<features-accelerationStructure,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructure>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkGetDeviceAccelerationStructureCompatibilityKHR.adoc[]
--

[open,refpage='VkAccelerationStructureVersionInfoKHR',desc='Acceleration structure version information',type='structs']
--
:refpage: VkAccelerationStructureVersionKHR

The sname:VkAccelerationStructureVersionInfoKHR structure is defined as:

include::{generated}/api/structs/VkAccelerationStructureVersionInfoKHR.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pVersionData is a pointer to the version header of an acceleration
    structure as defined in flink:vkCmdCopyAccelerationStructureToMemoryKHR

[NOTE]
====
pname:pVersionData is a _pointer_ to an array of 2{times}ename:VK_UUID_SIZE
code:uint8_t values instead of two ename:VK_UUID_SIZE arrays as the expected
use case for this member is to be pointed at the header of a previously
serialized acceleration structure (via
flink:vkCmdCopyAccelerationStructureToMemoryKHR or
flink:vkCopyAccelerationStructureToMemoryKHR) that is loaded in memory.
Using arrays would necessitate extra memory copies of the UUIDs.
====

include::{generated}/validity/structs/VkAccelerationStructureVersionInfoKHR.adoc[]
--

[open,refpage='VkAccelerationStructureCompatibilityKHR',desc='Acceleration structure compatibility',type='enums']
--
Possible values of pname:pCompatibility returned by
flink:vkGetDeviceAccelerationStructureCompatibilityKHR are:

include::{generated}/api/enums/VkAccelerationStructureCompatibilityKHR.adoc[]

  * ename:VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR if the
    pname:pVersionData version acceleration structure is compatible with
    pname:device.
  * ename:VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR if the
    pname:pVersionData version acceleration structure is not compatible with
    pname:device.
--
endif::VK_KHR_acceleration_structure[]


ifdef::VK_NV_cluster_acceleration_structure[]
[[cluster-geometry]]
== Cluster Level Acceleration Structures

Acceleration structure build times in ray tracing applications with
extensive geometry can: be reduced by introducing alternative acceleration
structure types that facilitate bottom-level acceleration structure
construction using pre-generated primitive clusters, improving geometry
reuse.
This can: be achieved by incorporating additional acceleration structure
types:

  . <<acceleration-structure-clas-geometry, Cluster Level Acceleration
    Structure>>
  . <<acceleration-structure-clas-template, Cluster Template Acceleration
    Structure>>
  . <<acceleration-structure-bottom-level-clas, Cluster Level Bottom Level
    Acceleration Structure>>

[[acceleration-structure-clas-geometry]]
Cluster Level Acceleration Structure (CLAS) is an intermediate acceleration
structure constructed from triangles, which serves as a building block for
<<acceleration-structure-bottom-level-clas, Cluster Level Bottom Level
Acceleration Structure>>.
A CLAS shares similarities with a traditional
<<acceleration-structure-bottom-level, bottom level acceleration structure>>
but has several key distinctions.
A CLAS can: only contain a limited number of <<cluster-geometry-limits,
triangles and vertices>>.
CLAS objects cannot be directly referenced in a top level acceleration
structure, instead, they must: be part of a
<<acceleration-structure-bottom-level-clas, Cluster Level Bottom Level
Acceleration Structure>>.
The <<cluster-geometry-index-flags, geometry indices>> within a CLAS are
local to it, potentially non-consecutive, and customizable per primitive.
Each CLAS can: also have a user-defined 32-bit
<<interfaces-builtin-variables-clusteridnv, ClusterID>>, which is accessible
in the hit shaders.
The vertex positions within a CLAS can: be quantized by
<<cluster-vertex-position-truncate, zeroing>> specific floating-point
mantissa bits to optimize storage.

[[acceleration-structure-clas-template]]
Cluster Template Acceleration Structure is a partially constructed
<<acceleration-structure-clas-geometry, CLAS>> designed for efficient
instantiation into multiple <<acceleration-structure-clas-geometry, CLAS>>
objects.
During a cluster template build, some pre-computation is performed
independent of vertex positions, allowing reuse across multiple CLAS objects
with different vertex data.
A cluster template itself does not require vertex positions but it retains
non-positional properties similar to a CLAS, which are then inherited during
instantiation.
A cluster template must: be instantiated into a CLAS object to be usable.

[[acceleration-structure-bottom-level-clas]]
Cluster Level Bottom Level Acceleration Structure is a new alternative to
the existing <<acceleration-structure-bottom-level, bottom level
acceleration structures>>, which is constructed using references to already
built <<acceleration-structure-clas-geometry, CLAS>> objects and is the only
cluster acceleration structure that can: be referenced in a top level
acceleration structure.

[open,refpage='vkGetClusterAccelerationStructureBuildSizesNV',desc='Retrieve the buffer allocation requirements for cluster geometry command',type='protos']
--
These cluster acceleration structures can: be built or moved by a single
versatile multi-indirect function
flink:vkCmdBuildClusterAccelerationStructureIndirectNV.
To determine the memory requirements for executing this function, call:

include::{generated}/api/protos/vkGetClusterAccelerationStructureBuildSizesNV.adoc[]

  * pname:device is the logical device that owns the acceleration structure.
  * pname:pInfo is a pointer to a
    slink:VkClusterAccelerationStructureInputInfoNV structure containing
    parameters required for the memory requirements query.
  * pname:pSizeInfo is a pointer to a
    slink:VkAccelerationStructureBuildSizesInfoKHR structure which returns
    the size required for an acceleration structure and scratch buffer,
    given the build parameters.
    The size requirements for a scratch buffer may: be zero.

If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV,
acceleration structure and scratch memory sizes are returned for all
slink:VkClusterAccelerationStructureInputInfoNV::pname:maxAccelerationStructureCount
acceleration structures.
If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
scratch memory size for all
slink:VkClusterAccelerationStructureInputInfoNV::pname:maxAccelerationStructureCount
acceleration structures and the acceleration structure memory size for a
single acceleration structure is returned.
If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV, only
scratch memory size is returned for the requested acceleration structures.

.Valid Usage
****
  * [[VUID-vkGetClusterAccelerationStructureBuildSizesNV-clusterAccelerationStructure-10438]]
    The <<features-clusterAccelerationStructure,
    sname:VkPhysicalDeviceClusterAccelerationStructureFeaturesNV::pname:clusterAccelerationStructure>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkGetClusterAccelerationStructureBuildSizesNV.adoc[]
--

[open,refpage='VkClusterAccelerationStructureInputInfoNV',desc='Structure describing a cluster acceleration structure',type='structs']
--
:refpage: VkClusterAccelerationStructureInputInfoNV

The slink:VkClusterAccelerationStructureInputInfoNV structure is defined as:

include::{generated}/api/structs/VkClusterAccelerationStructureInputInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:maxAccelerationStructureCount is the maximum number of
    acceleration structures that will be provided to the multi indirect
    operation.
  * pname:flags is a bitmask of tlink:VkBuildAccelerationStructureFlagsKHR
    specifying flags for the multi indirect operation.
  * pname:opType is a elink:VkClusterAccelerationStructureOpTypeNV value
    specifying the type of operation to perform.
  * pname:opMode is a elink:VkClusterAccelerationStructureOpModeNV value
    specifying the mode of operation.
  * pname:opInput is a slink:VkClusterAccelerationStructureOpInputNV value
    specifying the descriptions of the operation.

include::{generated}/validity/structs/VkClusterAccelerationStructureInputInfoNV.adoc[]
--

[open,refpage='VkClusterAccelerationStructureOpTypeNV',desc='Enum providing the type of operation',type='enums']
--
Values which can: be set in ename:VkClusterAccelerationStructureOpTypeNV
are:

include::{generated}/api/enums/VkClusterAccelerationStructureOpTypeNV.adoc[]

  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV
    specifies that a cluster acceleration structure, cluster acceleration
    structure template or a bottom level acceleration structure built from
    cluster acceleration structures will be moved.
    If a cluster acceleration structure is moved, the bottom level cluster
    acceleration structures containing it will have to be re-built.
    If used with
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV, it
    returns the size of existing cluster acceleration structures.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV
    specifies that bottom level cluster acceleration structures will be
    built.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV
    specifies that cluster acceleration structures will be built.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV
    specifies that a template for cluster acceleration structure will be
    built.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV
    specifies that a template for a cluster acceleration structure will be
    instantiated, resulting in a built cluster acceleration structure.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV
    specifies that the vertex indices of the cluster template acceleration
    structure will be fetched.
--

[open,refpage='VkClusterAccelerationStructureOpModeNV',desc='Enum providing the mode of operation',type='enums']
--
Values which can: be set in ename:VkClusterAccelerationStructureOpModeNV
are:

include::{generated}/api/enums/VkClusterAccelerationStructureOpModeNV.adoc[]

  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV
    specifies that the build or move operation will implicitly distribute
    built or compacted cluster acceleration structures starting at the
    address provided in
    slink:VkClusterAccelerationStructureCommandsInfoNV::pname:dstImplicitData.
    If a move operation is being performed, the acceleration structures will
    be tightly compacted.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV
    specifies that the build or move operation will explicitly write built
    or compacted cluster acceleration structures in the array of addresses
    provided in
    slink:VkClusterAccelerationStructureCommandsInfoNV::pname:dstAddressesArray.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV
    specifies that computed cluster acceleration structure sizes will be
    written to
    slink:VkClusterAccelerationStructureCommandsInfoNV::pname:dstSizesArray.

--

[open,refpage='VkClusterAccelerationStructureOpInputNV',desc='Union specifying cluster acceleration structure description',type='structs']
--
:refpage: VkClusterAccelerationStructureOpInputNV

The sname:VkClusterAccelerationStructureOpInputNV union is defined as:

include::{generated}/api/structs/VkClusterAccelerationStructureOpInputNV.adoc[]

  * pname:pClustersBottomLevel is a
    slink:VkClusterAccelerationStructureClustersBottomLevelInputNV structure
    specifying an upper threshold on parameters to build multiple bottom
    level acceleration structures from multiple cluster level acceleration
    structures.
  * pname:pTriangleClusters is a
    slink:VkClusterAccelerationStructureTriangleClusterInputNV structure
    specifying an upper threshold on parameters to build a regular or
    templated cluster acceleration structure.
  * pname:pMoveObjects is a
    slink:VkClusterAccelerationStructureMoveObjectsInputNV structure
    specifying an upper threshold on the number of bytes moved and the type
    of acceleration structure being moved.

include::{generated}/validity/structs/VkClusterAccelerationStructureOpInputNV.adoc[]
--


[open,refpage='VkClusterAccelerationStructureClustersBottomLevelInputNV',desc='Parameters describing bottom level acceleration structure',type='structs']
--
:refpage: VkClusterAccelerationStructureClustersBottomLevelInputNV

The slink:VkClusterAccelerationStructureClustersBottomLevelInputNV structure
is defined as:

include::{generated}/api/structs/VkClusterAccelerationStructureClustersBottomLevelInputNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:maxTotalClusterCount is the total number of clusters acceleration
    structures that will be built or moved across all input arguments.
  * pname:maxClusterCountPerAccelerationStructure is the maximum number of
    clusters acceleration structures that will be built or moved per input
    argument.

include::{generated}/validity/structs/VkClusterAccelerationStructureClustersBottomLevelInputNV.adoc[]
--

[open,refpage='VkClusterAccelerationStructureTriangleClusterInputNV',desc='Parameters describing a cluster acceleration structure',type='structs']
--
:refpage: VkClusterAccelerationStructureTriangleClusterInputNV

The slink:VkClusterAccelerationStructureTriangleClusterInputNV structure is
defined as:

include::{generated}/api/structs/VkClusterAccelerationStructureTriangleClusterInputNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:vertexFormat is the elink:VkFormat of each vertex element.
  * pname:maxGeometryIndexValue is the maximum geometry index value for any
    constructed geometry.
  * pname:maxClusterUniqueGeometryCount is the maximum number of unique
    values of the geometry index for each cluster or cluster template.
  * [[cluster-geometry-limits]] pname:maxClusterTriangleCount is the maximum
    number of triangles in a cluster or cluster template.
  * pname:maxClusterVertexCount is the maximum number of unique vertices in
    the cluster's index buffer.
  * pname:maxTotalTriangleCount is the sum of all triangles across all
    clusters or cluster templates.
  * pname:maxTotalVertexCount is the maximum number of vertices across all
    clusters or cluster templates.
  * [[cluster-vertex-position-truncate]] pname:minPositionTruncateBitCount
    is the least value specified in cluster build in
    slink:VkClusterAccelerationStructureBuildTriangleClusterInfoNV::pname:positionTruncateBitCount
    or cluster template build in
    slink:VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV::pname:positionTruncateBitCount.


.Valid Usage
****
  * [[VUID-VkClusterAccelerationStructureTriangleClusterInputNV-vertexFormat-10439]]
    The <<resources-buffer-view-format-features,format features>> of
    pname:vertexFormat must: contain
    ename:VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR
  * [[VUID-VkClusterAccelerationStructureTriangleClusterInputNV-maxClusterTriangleCount-10440]]
    pname:maxClusterTriangleCount must: be less than or equal to
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:maxTrianglesPerCluster
  * [[VUID-VkClusterAccelerationStructureTriangleClusterInputNV-maxClusterVertexCount-10441]]
    pname:maxClusterVertexCount must: be less than or equal to
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:maxVerticesPerCluster
  * [[VUID-VkClusterAccelerationStructureTriangleClusterInputNV-minPositionTruncateBitCount-10442]]
    pname:minPositionTruncateBitCount must: be less than or equal to `32`
****

include::{generated}/validity/structs/VkClusterAccelerationStructureTriangleClusterInputNV.adoc[]
--

[open,refpage='VkClusterAccelerationStructureMoveObjectsInputNV',desc='Parameters describing move information for an acceleration structure',type='structs']
--
:refpage: VkClusterAccelerationStructureMoveObjectsInputNV

The slink:VkClusterAccelerationStructureMoveObjectsInputNV structure is
defined as:

include::{generated}/api/structs/VkClusterAccelerationStructureMoveObjectsInputNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:type is a elink:VkClusterAccelerationStructureTypeNV value
    identifying the type of cluster acceleration structure.
  * pname:noMoveOverlap specifies if the source and destination cluster
    acceleration structures overlap in memory for the move operation.
    If set to ename:VK_TRUE, the source cluster acceleration structure
    remains valid after the move and move operation acts like a copy.
  * pname:maxMovedBytes is the maximum number of bytes that may: be moved in
    this operation.

include::{generated}/validity/structs/VkClusterAccelerationStructureMoveObjectsInputNV.adoc[]
--

[open,refpage='VkClusterAccelerationStructureTypeNV',desc='Enum providing the type of cluster acceleration structure',type='enums']
--
Values which can: be set in ename:VkClusterAccelerationStructureTypeNV are:

include::{generated}/api/enums/VkClusterAccelerationStructureTypeNV.adoc[]

  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV
    specifies a bottom level cluster acceleration structure.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV
    specifies a cluster acceleration structure.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV
    specifies a template cluster acceleration structure.
--

[open,refpage='vkCmdBuildClusterAccelerationStructureIndirectNV',desc='Build or move cluster acceleration structures',type='protos']
--
To build or move a cluster acceleration structure or a cluster acceleration
structure template call:

include::{generated}/api/protos/vkCmdBuildClusterAccelerationStructureIndirectNV.adoc[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:pCommandInfos is a pointer to a
    slink:VkClusterAccelerationStructureCommandsInfoNV structure containing
    parameters required for building or moving the cluster acceleration
    structure.

Similar to flink:vkCmdBuildAccelerationStructuresKHR, this command may:
initiate multiple acceleration structures builds and there is no ordering or
synchronization implied between any of the individual acceleration structure
builds.
Accesses to the acceleration structure scratch memory as identified by the
slink:VkClusterAccelerationStructureCommandsInfoNV::pname:scratchData must:
be <<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
(ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR |
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR).

Accesses to each
slink:VkClusterAccelerationStructureCommandsInfoNV::pname:dstImplicitData,
slink:VkClusterAccelerationStructureCommandsInfoNV::pname:dstAddressesArray
and slink:VkClusterAccelerationStructureCommandsInfoNV::pname:dstSizesArray
must: be <<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR.

Accesses to memory with input data as identified by any used values of
slink:VkClusterAccelerationStructureCommandsInfoNV::pname:srcInfosArray and
slink:VkClusterAccelerationStructureCommandsInfoNV::pname:srcInfosCount
must: be <<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT.

.Valid Usage
****
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-clusterAccelerationStructure-10443]]
    The <<features-clusterAccelerationStructure,
    sname:VkPhysicalDeviceClusterAccelerationStructureFeaturesNV::pname:clusterAccelerationStructure>>
    feature must: be enabled
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pNext-10444]]
    The pname:pNext chain of the bound ray tracing pipeline must: include a
    slink:VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV
    structure
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-10445]]
    pname:pCommandInfos->input.maxAccelerationStructureCount must: be less
    than or equal to the value used in
    pname:pInfo->maxAccelerationStructureCount in
    flink:vkGetClusterAccelerationStructureBuildSizesNV to determine the
    memory requirements for the build operation
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-scratchData-10446]]
    The scratch memory of the cluster acceleration structure specified in
    slink:VkClusterAccelerationStructureCommandsInfoNV::pname:scratchData
    must: be larger than or equal to the scratch size queried with
    flink:vkGetClusterAccelerationStructureBuildSizesNV
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-scratchData-10447]]
    The scratch address of the cluster acceleration structure specified in
    slink:VkClusterAccelerationStructureCommandsInfoNV::pname:scratchData
    must: be aligned based on the cluster acceleration structure type and
    its alignment properties as queried with
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-10448]]
    If pname:pCommandInfos->input.opType is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV,
    pname:pCommandInfos->srcInfosArray must: be an array of
    slink:VkClusterAccelerationStructureMoveObjectsInfoNV structures
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-10449]]
    If pname:pCommandInfos->input.opType is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV,
    pname:pCommandInfos->srcInfosArray must: be an array of
    slink:VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV
    structures
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-10450]]
    If pname:pCommandInfos->input.opType is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV,
    pname:pCommandInfos->srcInfosArray must: be an array of
    slink:VkClusterAccelerationStructureBuildTriangleClusterInfoNV
    structures
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-10451]]
    If pname:pCommandInfos->input.opType is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV,
    pname:pCommandInfos->srcInfosArray must: be an array of
    slink:VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV
    structures
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-10452]]
    If pname:pCommandInfos->input.opType is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV,
    pname:pCommandInfos->srcInfosArray must: be an array of
    slink:VkClusterAccelerationStructureInstantiateClusterInfoNV structures
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-10832]]
    If pname:pCommandInfos->input.opType is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV,
    pname:pCommandInfos->srcInfosArray must: be an array of
    slink:VkClusterAccelerationStructureGetTemplateIndicesInfoNV structures
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-10453]]
    The value in pname:pCommandInfos->srcInfosCount must: be less than or
    equal to pname:pCommandInfos->input.maxAccelerationStructureCount
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-10454]]
    The number of inputs specified in pname:pCommandInfos->srcInfosArray
    must: be greater than or equal to pname:pCommandInfos->srcInfosCount
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-dstAddressesArray-10455]]
    The memory regions specified in
    slink:VkClusterAccelerationStructureCommandsInfoNV::pname:dstAddressesArray
    must: not overlap with each other or with
    pname:pCommandInfos->scratchData
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-dstImplicitData-10456]]
    The memory region specified in
    slink:VkClusterAccelerationStructureCommandsInfoNV::pname:dstImplicitData
    for multiple acceleration structure builds must: not overlap with
    pname:pCommandInfos->scratchData
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-10457]]
    pname:pCommandInfos->scratchData must: be a device address allocated to
    the application from a buffer created with the
    ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT usage flag set
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-10458]]
    pname:pCommandInfos->srcInfosArray must: be a device address range
    allocated to application from a buffer created with the
    ename:VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR
    usage flag set
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-12246]]
    pname:pCommandInfos->srcInfosCount must: be a device address allocated
    to application from a buffer created with the
    ename:VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR
    usage flag set
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-10459]]
    pname:pCommandInfos->dstAddressesArray must: be a device address range
    allocated to the application from a buffer created with the
    ename:VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR usage flag
    set
  * [[VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-12247]]
    pname:pCommandInfos->dstImplicitData must: be a device address allocated
    to the application from a buffer created with the
    ename:VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR usage flag
    set
****

include::{generated}/validity/protos/vkCmdBuildClusterAccelerationStructureIndirectNV.adoc[]
--

[open,refpage='VkClusterAccelerationStructureCommandsInfoNV',desc='Structure describing parameters for building for moving an acceleration structure',type='structs']
--
:refpage: VkClusterAccelerationStructureCommandsInfoNV

The slink:VkClusterAccelerationStructureCommandsInfoNV structure is defined
as:

include::{generated}/api/structs/VkClusterAccelerationStructureCommandsInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:input is slink:VkClusterAccelerationStructureInputInfoNV structure
    describing the build or move parameters for the cluster acceleration
    structure.
  * pname:dstImplicitData is the device address for memory where the
    implicit build of cluster acceleration structure will be saved.
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV
    or ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV,
    this value is ignored.
  * pname:scratchData is the device address of scratch memory that will be
    used during cluster acceleration structure move or build.
  * pname:dstAddressesArray is a slink:VkStridedDeviceAddressRegionKHR that
    specifies addresses and stride for moved or built cluster acceleration
    structures, depending on the value of
    slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode.
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV
    and slink:VkStridedDeviceAddressRegionKHR::pname:deviceAddress is not
    `0`, then the implementation writes the cluster addresses to the
    specified region.
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
    the implementation reads the cluster addresses from the specified
    region.
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV, this
    member is ignored.
  * pname:dstSizesArray is a slink:VkStridedDeviceAddressRegionKHR
    containing sizes of moved or built cluster acceleration structures.
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV
    or ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV,
    then the sizes are saved.
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
    then the sizes are read from.
  * pname:srcInfosArray is a slink:VkStridedDeviceAddressRegionKHR where
    input data for the build or move operation is read from.
    If the stride is `0`, the structures are assumed to be packed tightly.
    Its format is dependent on
    slink:VkClusterAccelerationStructureInputInfoNV::pname:opType as per the
    table below.
[options="header"]
|====
| pname:input.opType | Format of pname:srcInfosArray
| ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV |slink:VkClusterAccelerationStructureMoveObjectsInfoNV
| ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV |slink:VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV
| ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV |slink:VkClusterAccelerationStructureBuildTriangleClusterInfoNV
| ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV |slink:VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV
| ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV |slink:VkClusterAccelerationStructureInstantiateClusterInfoNV
| ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV |slink:VkClusterAccelerationStructureGetTemplateIndicesInfoNV
|====
  * pname:srcInfosCount is the device address of memory containing the count
    of number of build or move operations to perform.
    The actual value is the minimum of this value and the value specified in
    pname:input.maxAccelerationStructureCount.
    If this value is `0`, the count is determined by
    pname:input.maxAccelerationStructureCount alone.
  * pname:addressResolutionFlags is a bitmask of
    elink:VkClusterAccelerationStructureAddressResolutionFlagBitsNV values
    specifying how an implementation will interpret the device addresses in
    this structure.

.Valid Usage
****
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-opMode-10466]]
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV,
    pname:dstImplicitData must: be a valid address
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-opMode-10467]]
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV
    and pname:input.opType is not
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV, the
    memory in pname:dstImplicitData must: be equal to or larger than the
    slink:VkAccelerationStructureBuildSizesInfoKHR::pname:accelerationStructureSize
    value returned from flink:vkGetClusterAccelerationStructureBuildSizesNV
    with same input parameters
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-opMode-10468]]
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV
    and pname:input.opType is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV, the
    memory in pname:dstImplicitData must: be equal to or larger than the sum
    of all the built acceleration structures that are being moved
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-input-10469]]
    If pname:input.opType is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV, the
    total memory moved must: not be larger than the size provided in
    slink:VkClusterAccelerationStructureMoveObjectsInputNV::pname:maxMovedBytes
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-opMode-10470]]
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV,
    pname:dstSizesArray must: be a valid address
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-opMode-10471]]
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
    the address in pname:dstAddressesArray must: be a valid address
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-opMode-12209]]
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
    the addresses in pname:dstAddressesArray must: be large enough to
    accommodate built or moved clusters
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-opMode-10472]]
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
    the buffers in pname:dstAddressesArray must: not overlap
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-opMode-10473]]
    If slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
    the addresses in pname:dstAddressesArray must: be aligned based on the
    cluster acceleration structure type and its alignment properties as
    described in
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-dstAddressesArray-10474]]
    The stride in pname:dstAddressesArray must: be greater than or equal to
    8
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-dstSizesArray-10475]]
    The stride in pname:dstSizesArray must: be greater than or equal to 4
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-srcInfosArray-10476]]
    The stride in pname:srcInfosArray must: be greater than the type of
    structure the address is describing
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-input-10477]]
    If pname:input.opType is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV,
    then depending on the
    slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode,
    pname:dstImplicitData or addresses specified in pname:dstAddressesArray
    must: be aligned to
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:clusterByteAlignment
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-input-10478]]
    If pname:input.opType is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV,
    then depending on the
    slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode,
    pname:dstImplicitData or addresses specified in pname:dstAddressesArray
    must: be aligned to
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:clusterTemplateByteAlignment
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-input-10479]]
    If pname:input.opType is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV,
    then depending on the
    slink:VkClusterAccelerationStructureInputInfoNV::pname:opMode,
    pname:dstImplicitData or addresses specified in pname:dstAddressesArray
    must: be aligned to
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:clusterByteAlignment
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-scratchData-10480]]
    pname:scratchData must: be aligned to
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:clusterScratchByteAlignment
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-buildScratchSize-12248]]
    If the pname:buildScratchSize member of the
    slink:VkAccelerationStructureBuildSizesInfoKHR structure returned from a
    call to flink:vkGetClusterAccelerationStructureBuildSizesNV is not `0`,
    then pname:scratchData must: be a valid device address
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-srcInfosCount-10481]]
    pname:srcInfosCount must: be 4-byte aligned
  * [[VUID-VkClusterAccelerationStructureCommandsInfoNV-input-10482]]
    If pname:input.opType is
    ename:VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV,
    the total and per argument number of cluster acceleration structures
    referenced in pname:srcInfosArray must: be equal or less than the
    maximum values with which memory requirements were queried in
    flink:vkGetClusterAccelerationStructureBuildSizesNV with
    slink:VkClusterAccelerationStructureOpInputNV::pname:pClustersBottomLevel
****

include::{generated}/validity/structs/VkClusterAccelerationStructureCommandsInfoNV.adoc[]
--

[open,refpage='VkClusterAccelerationStructureAddressResolutionFlagBitsNV',desc='Bitmask specifying address resolution flags in cluster acceleration structure',type='enums']
--
Bits which can: be set in
slink:VkClusterAccelerationStructureCommandsInfoNV::pname:addressResolutionFlags,
specifying how the device address in
slink:VkClusterAccelerationStructureCommandsInfoNV are interpreted, are:

include::{generated}/api/enums/VkClusterAccelerationStructureAddressResolutionFlagBitsNV.adoc[]

  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV
    specifies that no address resolution flags are provided.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV
    specifies another level of indirection when reading
    slink:VkClusterAccelerationStructureCommandsInfoNV::pname:dstImplicitData.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV
    specifies another level of indirection when reading
    slink:VkClusterAccelerationStructureCommandsInfoNV::pname:scratchData.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV
    specifies another level of indirection when reading
    slink:VkClusterAccelerationStructureCommandsInfoNV::pname:dstAddressesArray.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV
    specifies another level of indirection when reading
    slink:VkClusterAccelerationStructureCommandsInfoNV::pname:dstSizesArray.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV
    specifies another level of indirection when reading
    slink:VkClusterAccelerationStructureCommandsInfoNV::pname:srcInfosArray.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV
    specifies another level of indirection when reading
    slink:VkClusterAccelerationStructureCommandsInfoNV::pname:srcInfosCount.
--

[open,refpage='VkClusterAccelerationStructureAddressResolutionFlagsNV',desc='Bitmask of VkClusterAccelerationStructureAddressResolutionFlagBitsNV',type='flags']
--
include::{generated}/api/flags/VkClusterAccelerationStructureAddressResolutionFlagsNV.adoc[]

tname:VkClusterAccelerationStructureAddressResolutionFlagsNV is a bitmask
type for setting a mask of zero or more
elink:VkClusterAccelerationStructureAddressResolutionFlagBitsNV.
--

[open,refpage='VkClusterAccelerationStructureMoveObjectsInfoNV',desc='Parameters describing move operation for a cluster acceleration structure',type='structs']
--
:refpage: VkClusterAccelerationStructureMoveObjectsInfoNV

The slink:VkClusterAccelerationStructureMoveObjectsInfoNV structure is
defined as:

include::{generated}/api/structs/VkClusterAccelerationStructureMoveObjectsInfoNV.adoc[]

  * pname:srcAccelerationStructure is the device address of the source
    cluster acceleration structure that will be moved.

.Valid Usage
****
  * [[VUID-VkClusterAccelerationStructureMoveObjectsInfoNV-srcAccelerationStructure-10483]]
    pname:srcAccelerationStructure must: be a type of <<cluster-geometry,
    cluster acceleration structure>>
****

include::{generated}/validity/structs/VkClusterAccelerationStructureMoveObjectsInfoNV.adoc[]
--

[open,refpage='VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV',desc='Parameters describing build operation for a bottom level cluster acceleration structure',type='structs']
--
:refpage: VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV

The slink:VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV
structure is defined as:

include::{generated}/api/structs/VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV.adoc[]

  * pname:clusterReferencesCount is the number of clusters this bottom level
    acceleration structure will be built from.
  * pname:clusterReferencesStride is the stride in pname:clusterReferences.
  * pname:clusterReferences is the device memory containing the address of
    the clusters.

.Valid Usage
****
  * [[VUID-VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV-clusterReferences-10484]]
    All cluster references in pname:clusterReferences must: be unique
  * [[VUID-VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV-clusterReferences-10485]]
    pname:clusterReferences must: have at least pname:clusterReferencesCount
    values
  * [[VUID-VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV-clusterReferencesStride-10486]]
    pname:clusterReferencesStride must: be greater than or equal to 8
****

include::{generated}/validity/structs/VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV.adoc[]
--

[open,refpage='VkClusterAccelerationStructureGeometryFlagBitsNV',desc='Bitmask specifying geometry flags for cluster acceleration structure',type='enums']
--
Bits which can: be set in
slink:VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV::pname:geometryFlags,
specifying geometry flags for cluster acceleration structure, are:

include::{generated}/api/enums/VkClusterAccelerationStructureGeometryFlagBitsNV.adoc[]

  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV
    disables face culling for this geometry.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV
    specifies that the implementation must: only call the any-hit shader a
    single time for each primitive in this geometry.
    If this bit is absent an implementation may: invoke the any-hit shader
    more than once for this geometry.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV specifies
    that this geometry does not invoke the any-hit shaders even if present
    in a hit group.
--

[open,refpage='VkClusterAccelerationStructureGeometryFlagsNV',desc='Bitmask of VkClusterAccelerationStructureGeometryFlagBitsNV',type='flags']
--
include::{generated}/api/flags/VkClusterAccelerationStructureGeometryFlagsNV.adoc[]

tname:VkClusterAccelerationStructureGeometryFlagsNV is a bitmask type for
setting a mask of zero or more
elink:VkClusterAccelerationStructureGeometryFlagBitsNV.
--

[open,refpage='VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV',desc='Parameters describing geometry index and flags values for cluster acceleration structure',type='structs']
--
:refpage: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV

The slink:VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV
structure is defined as:

include::{generated}/api/structs/VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV.adoc[]

  * pname:geometryIndex specifies the geometry index for all triangles in
    the cluster acceleration structure.
  * pname:reserved is reserved for future use.
  * pname:geometryFlags is a bitmask of
    elink:VkClusterAccelerationStructureGeometryFlagBitsNV values describing
    geometry flags for the cluster acceleration structure.

The C language specification does not define the ordering of bit-fields, but
in practice, this structure produces the correct layout with existing
compilers.
The intended bit pattern is the following:

  * pname:geometryIndex, pname:reserved and pname:mask occupy the same
    memory as if a single code:uint32_t was specified in their place
  ** pname:geometryIndex occupies the 24 least significant bits of that
     memory
  ** pname:geometryFlags occupies the 3 most significant bits of that memory

If a compiler produces code that diverges from that pattern, applications
must: employ another method to set values according to the correct bit
pattern.

.Valid Usage
****
  * [[VUID-VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV-reserved-10487]]
    pname:reserved must: be `0`
****

include::{generated}/validity/structs/VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV.adoc[]
--

[open,refpage='VkClusterAccelerationStructureClusterFlagBitsNV',desc='Bitmask specifying cluster acceleration structure flags',type='enums']
--
Bits which can: be set in
slink:VkClusterAccelerationStructureBuildTriangleClusterInfoNV::pname:clusterFlags,
specifying flags for clusters in an acceleration structure, are:

include::{generated}/api/enums/VkClusterAccelerationStructureClusterFlagBitsNV.adoc[]

  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV
    specifies that the specified cluster acceleration structure may: be
    referenced in an instance with
    ename:VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT set.
--

[open,refpage='VkClusterAccelerationStructureClusterFlagsNV',desc='Bitmask of VkClusterAccelerationStructureClusterFlagBitsNV',type='flags']
--
include::{generated}/api/flags/VkClusterAccelerationStructureClusterFlagsNV.adoc[]

tname:VkClusterAccelerationStructureClusterFlagsNV is a bitmask type for
setting a mask of zero or more
elink:VkClusterAccelerationStructureClusterFlagBitsNV.
--

[open,refpage='VkClusterAccelerationStructureBuildTriangleClusterInfoNV',desc='Parameters describing build operation for a cluster acceleration structure',type='structs']
--
:refpage: VkClusterAccelerationStructureBuildTriangleClusterInfoNV

The slink:VkClusterAccelerationStructureBuildTriangleClusterInfoNV structure
is defined as:

include::{generated}/api/structs/VkClusterAccelerationStructureBuildTriangleClusterInfoNV.adoc[]

  * pname:clusterID is a user specified identifier assigned to this cluster.
  * pname:clusterFlags is a bitmask of
    elink:VkClusterAccelerationStructureClusterFlagBitsNV values describing
    flags how the cluster should be built.
  * pname:triangleCount is the number of triangles in this cluster.
  * pname:vertexCount is the number of unique vertices in this cluster.
  * pname:positionTruncateBitCount is the number of bits starting at the
    lowest bit (i.e. the LSBs of the mantissa), of each vertex position that
    will be truncated to zero to improve floating-point compression.
  * pname:indexType is a single
    elink:VkClusterAccelerationStructureIndexFormatFlagBitsNV value
    specifying the index type in pname:indexBuffer.
  * pname:opacityMicromapIndexType is a single
    elink:VkClusterAccelerationStructureIndexFormatFlagBitsNV value
    specifying the index type in pname:opacityMicromapIndexBuffer.
  * pname:baseGeometryIndexAndGeometryFlags is a
    slink:VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV
    value specifying the base geometry index and flags for all triangles in
    the cluster.
  * pname:indexBufferStride is the stride in bytes in pname:indexBuffer with
    `0` meaning the values are tightly-packed.
  * pname:vertexBufferStride is the stride in bytes in pname:vertexBuffer
    with `0` meaning the values are tightly-packed.
  * pname:geometryIndexAndFlagsBufferStride is the stride in bytes in
    pname:geometryIndexAndFlagsBuffer with `0` meaning the values are
    tightly-packed.
  * pname:opacityMicromapIndexBufferStride is the stride in bytes in
    pname:opacityMicromapIndexBuffer with `0` meaning the values are
    tightly-packed.
  * pname:indexBuffer is a device address containing the indices of the
    vertices in the cluster and are of type pname:indexType.
  * pname:vertexBuffer is a device address containing the vertex data of the
    triangles in the cluster with format specified in
    slink:VkClusterAccelerationStructureTriangleClusterInputNV::pname:vertexFormat.
  * [[cluster-geometry-index-flags]] pname:geometryIndexAndFlagsBuffer is
    either `0` or an address containing strided
    slink:VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV
    values specifying the geometry index and flag for every triangle in the
    cluster.
  * pname:opacityMicromapArray is either `0` or specifies the address of a
    valid opacity micromap array to reference from the cluster acceleration
    structure.
    If it is `0`, then opacity micromaps will be disabled for this cluster
    acceleration structure.
  * pname:opacityMicromapIndexBuffer is either `0` or specifies the address
    of a strided array with size equal to the number of triangles or indices
    into the opacity micromap array.
    If pname:opacityMicromapIndexBuffer is `0` then the index used is the
    index of the triangle in the geometry.

The C language specification does not define the ordering of bit-fields, but
in practice, this structure produces the correct layout with existing
compilers.
The intended bit pattern is the following:

  * pname:triangleCount, pname:vertexCount, pname:positionTruncateBitCount,
    pname:indexType and pname:opacityMicromapIndexType occupy the same
    memory as if a single code:uint32_t was specified in their place
  ** pname:triangleCount occupies the 9 least significant bits of that
     memory
  ** pname:vertexCount occupies the next 9 least significant bits of that
     memory
  ** pname:positionTruncateBitCount occupies the next 6 least significant
     bits of that memory
  ** pname:indexType occupies the next 4 least significant bits of that
     memory
  ** pname:opacityMicromapIndexType occupies the 4 most significant bits of
     that memory

If a compiler produces code that diverges from that pattern, applications
must: employ another method to set values according to the correct bit
pattern.

.Valid Usage
****
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterInfoNV-clusterID-10488]]
    pname:clusterID must: not be 0xFFFFFFFF
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterInfoNV-triangleCount-10489]]
    pname:triangleCount must: be less than or equal to
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:maxTrianglesPerCluster
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterInfoNV-vertexCount-10490]]
    pname:vertexCount must: be less than or equal to
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:maxVerticesPerCluster
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterInfoNV-indexType-10491]]
    pname:indexType must: only have a single bit set
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterInfoNV-opacityMicromapIndexType-10492]]
    pname:opacityMicromapIndexType must: only have a single bit set
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterInfoNV-positionTruncateBitCount-10493]]
    pname:positionTruncateBitCount must: be greater than or equal to
    slink:VkClusterAccelerationStructureTriangleClusterInputNV::pname:minPositionTruncateBitCount
    and less than or equal to `32`
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterInfoNV-indexBufferStride-10494]]
    pname:indexBufferStride must: be `0` or a multiple of pname:indexType
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterInfoNV-vertexBufferStride-10495]]
    pname:vertexBufferStride must: be `0` or a multiple of value specified
    in
    slink:VkClusterAccelerationStructureTriangleClusterInputNV::pname:vertexFormat
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterInfoNV-baseGeometryIndex-10496]]
    The maximum geometry index after using the values in
    pname:baseGeometryIndex and pname:geometryIndexBuffer must: be less than
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:maxClusterGeometryIndex
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterInfoNV-opacityMicromapArray-10881]]
    If pname:opacityMicromapArray is not `0`, then the cluster acceleration
    structure must: have been built with
    ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_CLUSTER_OPACITY_MICROMAPS_BIT_NV
    flag set in slink:VkClusterAccelerationStructureInputInfoNV::pname:flags
****

include::{generated}/validity/structs/VkClusterAccelerationStructureBuildTriangleClusterInfoNV.adoc[]
--

[open,refpage='VkClusterAccelerationStructureIndexFormatFlagBitsNV',desc='Bits specifying the index type in the index buffer',type='enums']
--
Bits that can: be set in
slink:VkClusterAccelerationStructureBuildTriangleClusterInfoNV::pname:indexType,
slink:VkClusterAccelerationStructureBuildTriangleClusterInfoNV::pname:opacityMicromapIndexType,
slink:VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV::pname:indexType
and
slink:VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV::pname:opacityMicromapIndexType
specifying the index type is one of:

include::{generated}/api/enums/VkClusterAccelerationStructureIndexFormatFlagBitsNV.adoc[]

  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV specifies
    that 8-bit indices will be used.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV specifies
    that 16-bit indices will be used.
  * ename:VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV specifies
    that 32-bit indices will be used.
--

[open,refpage='VkClusterAccelerationStructureIndexFormatFlagsNV',desc='Bitmask of VkClusterAccelerationStructureIndexFormatFlagBitsNV',type='flags']
--
include::{generated}/api/flags/VkClusterAccelerationStructureIndexFormatFlagsNV.adoc[]

tname:VkClusterAccelerationStructureIndexFormatFlagsNV is a bitmask type for
setting a single elink:VkClusterAccelerationStructureIndexFormatFlagBitsNV.
--

[open,refpage='VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV',desc='Parameters describing build operation for a template cluster acceleration structure',type='structs']
--
:refpage: VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV

The slink:VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV
structure is defined as:

include::{generated}/api/structs/VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV.adoc[]

  * pname:clusterID is a user specified identifier assigned to this cluster
    template.
  * pname:clusterFlags is a bitmask of
    elink:VkClusterAccelerationStructureClusterFlagBitsNV values describing
    flags how the cluster template should be built.
  * pname:triangleCount is the number of triangles in this cluster.
  * pname:vertexCount is the number of unique vertices in this cluster.
  * pname:positionTruncateBitCount is the number of bits starting at the
    lowest bit (i.e. the LSBs of the mantissa), of each vertex position that
    will be truncated to zero to improve floating-point compression.
  * pname:indexType is a single
    elink:VkClusterAccelerationStructureIndexFormatFlagBitsNV value
    specifying the index type in pname:indexBuffer.
  * pname:opacityMicromapIndexType is a single
    elink:VkClusterAccelerationStructureIndexFormatFlagBitsNV value
    specifying the index type in pname:opacityMicromapIndexBuffer.
  * pname:baseGeometryIndexAndGeometryFlags is a
    slink:VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV
    value specifying the base geometry index and flags for all triangles in
    the cluster template.
  * pname:indexBufferStride is the stride in bytes in pname:indexBuffer.
  * pname:vertexBufferStride is the stride in bytes in pname:vertexBuffer.
  * pname:geometryIndexAndFlagsBufferStride is the stride in bytes in
    pname:geometryIndexAndFlagsBuffer.
  * pname:opacityMicromapIndexBufferStride is the stride in bytes in
    pname:opacityMicromapIndexBuffer.
  * pname:indexBuffer contains the indices of vertices in the cluster and is
    of type pname:indexType.
  * pname:vertexBuffer is either `0` or specifies the vertex data of the
    triangles in the cluster template with format specified in
    slink:VkClusterAccelerationStructureTriangleClusterInputNV::pname:vertexFormat.
  * pname:geometryIndexAndFlagsBuffer is either `0` or an address containing
    strided
    slink:VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV
    values specifying the geometry index and flag for every triangle in the
    cluster.
  * pname:opacityMicromapArray is either `0` or specifies the address of a
    valid opacity micromap array to reference from the cluster acceleration
    structure.
    If it is `0`, then opacity micromaps will be disabled for this cluster
    acceleration structure.
  * pname:opacityMicromapIndexBuffer is either `0` or specifies the address
    of a strided array with size equal to the number of triangles or indices
    into the opacity micromap array.
    If pname:opacityMicromapIndexBuffer is `0` then the index used is the
    index of the triangle in the geometry.
  * pname:instantiationBoundingBoxLimit is either `0` or specifies the
    address of a bounding box within which all instantiated clusters must:
    lie.
    The bounding box is specified by six 32-bit floating-point values in the
    order MinX, MinY, MinZ, MaxX, MaxY, MaxZ.

The C language specification does not define the ordering of bit-fields, but
in practice, this structure produces the correct layout with existing
compilers.
The intended bit pattern is the following:

  * pname:triangleCount, pname:vertexCount, pname:positionTruncateBitCount,
    pname:indexType and pname:opacityMicromapIndexType occupy the same
    memory as if a single code:uint32_t was specified in their place
  ** pname:triangleCount occupies the 9 least significant bits of that
     memory
  ** pname:vertexCount occupies the next 9 least significant bits of that
     memory
  ** pname:positionTruncateBitCount occupies the next 6 least significant
     bits of that memory
  ** pname:indexType occupies the next 4 least significant bits of that
     memory
  ** pname:opacityMicromapIndexType occupies the 4 most significant bits of
     that memory

If a compiler produces code that diverges from that pattern, applications
must: employ another method to set values according to the correct bit
pattern.

Cluster templates cannot be directly used to build bottom level acceleration
structures, instead, they must: be instantiated into
<<acceleration-structure-clas-geometry, CLAS objects>>.

.Valid Usage
****
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV-clusterID-10497]]
    pname:clusterID must: not be 0xFFFFFFFF
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV-triangleCount-10498]]
    pname:triangleCount must: be less than or equal to
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:maxTrianglesPerCluster
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV-vertexCount-10499]]
    pname:vertexCount must: be less than or equal to
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:maxVerticesPerCluster
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV-indexType-10500]]
    pname:indexType must: only have a single bit set
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV-opacityMicromapIndexType-10501]]
    pname:opacityMicromapIndexType must: only have a single bit set
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV-positionTruncateBitCount-10502]]
    pname:positionTruncateBitCount must: be greater than or equal to
    slink:VkClusterAccelerationStructureTriangleClusterInputNV::pname:minPositionTruncateBitCount
    and less than or equal to `32`
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV-indexBufferStride-10503]]
    pname:indexBufferStride must: be `0` or a multiple of pname:indexType
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV-vertexBufferStride-10504]]
    pname:vertexBufferStride must: be `0` or a multiple of value specified
    in
    slink:VkClusterAccelerationStructureTriangleClusterInputNV::pname:vertexFormat
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV-instantiationBoundingBoxLimit-10505]]
    pname:instantiationBoundingBoxLimit must: be aligned to
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:clusterTemplateBoundsByteAlignment
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV-baseGeometryIndex-10506]]
    The maximum geometry index after using the values in
    pname:baseGeometryIndex and pname:geometryIndexBuffer must: be less than
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:maxClusterGeometryIndex
  * [[VUID-VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV-opacityMicromapArray-10882]]
    If pname:opacityMicromapArray is not `0`, then the template cluster
    acceleration structure must: have been built with
    ename:VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_CLUSTER_OPACITY_MICROMAPS_BIT_NV
    flag set in slink:VkClusterAccelerationStructureInputInfoNV::pname:flags
****

include::{generated}/validity/structs/VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV.adoc[]
--

[open,refpage='VkClusterAccelerationStructureInstantiateClusterInfoNV',desc='Parameters describing instantiate operation for a template cluster acceleration structure',type='structs']
--
:refpage: VkClusterAccelerationStructureInstantiateClusterInfoNV

The slink:VkClusterAccelerationStructureInstantiateClusterInfoNV structure
is defined as:

include::{generated}/api/structs/VkClusterAccelerationStructureInstantiateClusterInfoNV.adoc[]

  * pname:clusterIdOffset is an unsigned offset applied to the
    pname:clusterID value stored in the cluster template.
  * pname:geometryIndexOffset is a signed offset applied to the geometry
    index of each triangle.
  * pname:reserved is reserved for future use.
  * pname:clusterTemplateAddress is the address of a previously built
    cluster template.
  * pname:vertexBuffer is a slink:VkStridedDeviceAddressNV structure
    containing the vertex data for the indexed triangles stored in the
    cluster template.
    If the address in slink:VkStridedDeviceAddressNV is `0` the vertex data
    is sourced from the cluster template.

.Valid Usage
****
  * [[VUID-VkClusterAccelerationStructureInstantiateClusterInfoNV-vertexBuffer-10507]]
    pname:vertexBuffer must: not be `0` if the template was built without
    vertex data
  * [[VUID-VkClusterAccelerationStructureInstantiateClusterInfoNV-vertexBuffer-10508]]
    The format in pname:vertexBuffer must: match the original format
    specified in slink:VkClusterAccelerationStructureTriangleClusterInputNV
  * [[VUID-VkClusterAccelerationStructureInstantiateClusterInfoNV-reserved-10509]]
    pname:reserved must: be `0`
  * [[VUID-VkClusterAccelerationStructureInstantiateClusterInfoNV-geometryIndexOffset-10510]]
    The maximum geometry index after using the value in
    pname:geometryIndexOffset must: be less than
    slink:VkPhysicalDeviceClusterAccelerationStructurePropertiesNV::pname:maxClusterGeometryIndex
****

include::{generated}/validity/structs/VkClusterAccelerationStructureInstantiateClusterInfoNV.adoc[]
--

[open,refpage='VkClusterAccelerationStructureGetTemplateIndicesInfoNV',desc='Parameters describing addresses of cluster template acceleration structure whose index data is requested',type='structs']
--
:refpage: VkClusterAccelerationStructureGetTemplateIndicesInfoNV

The slink:VkClusterAccelerationStructureGetTemplateIndicesInfoNV structure
is defined as:

include::{generated}/api/structs/VkClusterAccelerationStructureGetTemplateIndicesInfoNV.adoc[]

  * pname:clusterTemplateAddress is the device address of the cluster
    template acceleration structure whose index data is being fetched.

.Valid Usage
****
  * [[VUID-VkClusterAccelerationStructureGetTemplateIndicesInfoNV-clusterTemplateAddress-10833]]
    pname:clusterTemplateAddress must: be a
    <<acceleration-structure-clas-template, template cluster acceleration
    structure>>
****

include::{generated}/validity/structs/VkClusterAccelerationStructureGetTemplateIndicesInfoNV.adoc[]
--

[open,refpage='VkStridedDeviceAddressNV',desc='Structure specifying a device addresses with a stride',type='structs']
--
:refpage: VkStridedDeviceAddressNV

The slink:VkStridedDeviceAddressNV structure is defined as:

include::{generated}/api/structs/VkStridedDeviceAddressNV.adoc[]

  * pname:startAddress is the device address (as returned by the
    flink:vkGetBufferDeviceAddress command) at which the region starts, or
    zero if the region is unused.
  * pname:strideInBytes is the byte stride between consecutive elements.
    Only the bottom 32 bits are used.
    The field is 64 bits to ensure consistent alignment across all
    containing structures.

include::{generated}/validity/structs/VkStridedDeviceAddressNV.adoc[]
--
endif::VK_NV_cluster_acceleration_structure[]


ifdef::VK_NV_partitioned_acceleration_structure[]
[[partitioned-tlas]]
== Partitioned Top Level Acceleration Structures

Partitioned Top Level Acceleration Structures (PTLAS) allow efficient reuse
of previously constructed sections of the top level acceleration structure
by eliminating a full rebuild when only a few instances are modified.
This reduces build times and supports handling a higher number of instances,
making it more suitable for large and complex scenes.

PTLAS organizes instances into partitions, enabling a two-stage build
process: first, it constructs an acceleration structure for each partition
by grouping the instances within it, and second, it combines these partition
structures into a single acceleration structure, similar to the current
top-level acceleration structure.

To maintain compatibility, PTLAS behaves identically to the current
top-level acceleration structure from the perspective of ray tracing shaders
and pipelines.

[[ptlas-global-partition]]
PTLAS includes a unique global partition that operates independently of
other partitions.
Instances can: be assigned to this global partition just like they would to
regular partitions.
The global partition is well-suited for frequently updated instances, such
as animated characters.
During the build process, instances in the global partition are treated as
if they belong to individual partitions, without increasing the maximum
partition count.
However, instances in the global partition may still impact build
performance.
Once these instances become stable, they should be moved to a spatially
optimized, non-global partition to lower build costs and minimize trace
performance issues.

[[ptlas-partition-translation]]
To handle large worlds requiring more precision than 32-bit floating-point
numbers offer, PTLAS offers efficient partition translation.
Typically, applications maintain precision by placing the world center near
the camera.
Partition translation allows an additional translation of instances during
construction without changing their stored transforms.
This method stores instance transforms relative to partitions, applying a
translation to achieve accurate world positions.
Higher precision is maintained using smaller floating-point numbers until
the structure is built.
World space coordinates can: also be updated efficiently without rebuilding
the entire PTLAS.
Partition translation requires extra memory for untranslated instance
transforms and must: be explicitly enabled with
slink:VkPartitionedAccelerationStructureFlagsNV::pname:enablePartitionTranslation
flag.

[open,refpage='vkGetPartitionedAccelerationStructuresBuildSizesNV',desc='Retrieve the buffer allocation requirements for partitioned acceleration structure command',type='protos']
--
To determine the memory requirements for a PTAS, call:

include::{generated}/api/protos/vkGetPartitionedAccelerationStructuresBuildSizesNV.adoc[]

  * pname:device is the logical device that owns the acceleration structure.
  * pname:pInfo is a pointer to a
    slink:VkPartitionedAccelerationStructureInstancesInputNV structure
    containing parameters required for the memory requirements query.
  * pname:pSizeInfo is a pointer to a
    slink:VkAccelerationStructureBuildSizesInfoKHR structure which returns
    the size required for an acceleration structure and the sizes required
    for the scratch buffers, given the build parameters.
    The size requirements for a scratch buffer may: be zero.


.Valid Usage
****
  * [[VUID-vkGetPartitionedAccelerationStructuresBuildSizesNV-partitionedAccelerationStructure-10534]]
    The <<features-partitionedAccelerationStructure,
    sname:VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV::pname:partitionedAccelerationStructure>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkGetPartitionedAccelerationStructuresBuildSizesNV.adoc[]
--

[open,refpage='VkPartitionedAccelerationStructureInstancesInputNV',desc='Parameters describing a PTLAS structure',type='structs']
--
:refpage: VkPartitionedAccelerationStructureInstancesInputNV

The slink:VkPartitionedAccelerationStructureInstancesInputNV structure is
defined as:

include::{generated}/api/structs/VkPartitionedAccelerationStructureInstancesInputNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of tlink:VkBuildAccelerationStructureFlagsKHR
    specifying flags for the PTLAS build operation.
  * pname:instanceCount is the number of instances in this PTLAS.
  * pname:maxInstancePerPartitionCount is the maximum number of instances
    per partition in the PTLAS.
  * pname:partitionCount is the number of partitions in the PTLAS.
  * pname:maxInstanceInGlobalPartitionCount is maximum number of instances
    in the <<ptlas-global-partition, global partition>>.

If the pname:pNext chain includes a
slink:VkPartitionedAccelerationStructureFlagsNV structure, then that
structure specifies additional flags for the PTLAS.

.Valid Usage
****
  * [[VUID-VkPartitionedAccelerationStructureInstancesInputNV-partitionCount-10535]]
    The sum of pname:partitionCount and
    pname:maxInstanceInGlobalPartitionCount must: be less than or equal to
    slink:VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV::pname:maxPartitionCount
****

include::{generated}/validity/structs/VkPartitionedAccelerationStructureInstancesInputNV.adoc[]
--

[open,refpage='VkPartitionedAccelerationStructureFlagsNV',desc='Structure describing additional flags for PTLAS',type='structs']
--
:refpage: VkPartitionedAccelerationStructureFlagsNV

The slink:VkPartitionedAccelerationStructureFlagsNV structure is defined as:

include::{generated}/api/structs/VkPartitionedAccelerationStructureFlagsNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:enablePartitionTranslation specifies if a
    <<ptlas-partition-translation, partition translation>> may: be applied
    with
    slink:VkPartitionedAccelerationStructureWritePartitionTranslationDataNV.

include::{generated}/validity/structs/VkPartitionedAccelerationStructureFlagsNV.adoc[]
--

[open,refpage='vkCmdBuildPartitionedAccelerationStructuresNV',desc='Command for building a PTLAS',type='protos']
--
To build a partitioned top level acceleration structure, call:

include::{generated}/api/protos/vkCmdBuildPartitionedAccelerationStructuresNV.adoc[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:pBuildInfo is a pointer to a
    slink:VkBuildPartitionedAccelerationStructureInfoNV structure containing
    parameters required for building a PTLAS.

Accesses to the acceleration structure scratch memory as identified by the
slink:VkBuildPartitionedAccelerationStructureInfoNV::pname:scratchData must:
be <<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
(ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR |
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR).

Accesses to each
slink:VkBuildPartitionedAccelerationStructureInfoNV::pname:srcAccelerationStructureData
and
slink:VkBuildPartitionedAccelerationStructureInfoNV::pname:dstAccelerationStructureData
must: be <<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR or
ename:VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR, as appropriate.

Accesses to memory with input data as identified by any used values of
slink:VkBuildPartitionedAccelerationStructureInfoNV::pname:srcInfos and
slink:VkBuildPartitionedAccelerationStructureInfoNV::pname:srcInfosCount
must: be <<synchronization-dependencies,synchronized>> with the
ename:VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
<<synchronization-pipeline-stages, pipeline stage>> and an
<<synchronization-access-types, access type>> of
ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT.

.Valid Usage
****
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-partitionedAccelerationStructure-10536]]
    The <<features-partitionedAccelerationStructure,
    sname:VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV::pname:partitionedAccelerationStructure>>
    feature must: be enabled
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10537]]
    The count specified in pname:pBuildInfo->input.instanceCount for the
    build operation must: not exceed the value provided in
    pname:pInfo->instanceCount when calling
    flink:vkGetPartitionedAccelerationStructuresBuildSizesNV to determine
    the memory size
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10538]]
    The count specified in
    pname:pBuildInfo->input.maxInstancePerPartitionCount for the build
    operation must: not exceed the value provided in
    pname:pInfo->maxInstancePerPartitionCount when calling
    flink:vkGetPartitionedAccelerationStructuresBuildSizesNV to determine
    the memory size
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10539]]
    The count specified in pname:pBuildInfo->input.partitionCount for the
    build operation must: not exceed the value provided in
    pname:pInfo->partitionCount when calling
    flink:vkGetPartitionedAccelerationStructuresBuildSizesNV to determine
    the memory size
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10540]]
    The count specified in
    pname:pBuildInfo->input.maxInstanceInGlobalPartitionCount for the build
    operation must: not exceed the value provided in
    pname:pInfo->maxInstanceInGlobalPartitionCount when calling
    flink:vkGetPartitionedAccelerationStructuresBuildSizesNV to determine
    the memory size
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10541]]
    The scratch memory for the partitioned acceleration structure build
    specified in pname:pBuildInfo->scratchData must: be larger than or equal
    to the scratch size queried with
    flink:vkGetPartitionedAccelerationStructuresBuildSizesNV
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10542]]
    pname:pBuildInfo->scratchData must: be aligned to `256` bytes
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10543]]
    The destination memory of the partitioned acceleration structure build
    specified in pname:pBuildInfo->dstAccelerationStructureData must: be
    larger than or equal to the size queried with
    flink:vkGetPartitionedAccelerationStructuresBuildSizesNV
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10544]]
    pname:pBuildInfo->srcAccelerationStructureData must: be aligned to `256`
    bytes
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10545]]
    pname:pBuildInfo->dstAccelerationStructureData must: be aligned to `256`
    bytes
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10546]]
    The number of inputs specified in pname:pBuildInfo->srcInfos must: be
    greater than or equal to pname:pBuildInfo->srcInfosCount
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10547]]
    The memory region containing the acceleration structure at address
    pname:pBuildInfo->srcAccelerationStructureData must: not overlap with
    scratch memory region at address pname:pBuildInfo->scratchData
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10548]]
    The memory region containing the acceleration structure at address
    pname:pBuildInfo->dstAccelerationStructureData must: not overlap with
    scratch memory region at address pname:pBuildInfo->scratchData
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10549]]
    The memory regions containing the acceleration structures at addresses
    pname:pBuildInfo->srcAccelerationStructureData and
    pname:pBuildInfo->dstAccelerationStructureData must: not overlap with
    each other
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10550]]
    pname:pBuildInfo->scratchData must: be a device address allocated to the
    application from a buffer created with the
    ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT usage flag set
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10551]]
    pname:pBuildInfo->srcInfos and pname:pBuildInfo->srcInfosCount must: be
    device addresses allocated to the application from buffers created with
    the
    ename:VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR
    usage flag set
  * [[VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-10552]]
    pname:pBuildInfo->srcAccelerationStructureData and
    pname:pBuildInfo->dstAccelerationStructureData must: be a device
    addresses allocated to the application from buffers created with the
    ename:VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR usage flag
    set
****

include::{generated}/validity/protos/vkCmdBuildPartitionedAccelerationStructuresNV.adoc[]
--

[open,refpage='VkBuildPartitionedAccelerationStructureInfoNV',desc='Structure describing build parameters for a PTLAS',type='structs']
--
:refpage: VkBuildPartitionedAccelerationStructureInfoNV

The slink:VkBuildPartitionedAccelerationStructureInfoNV structure is defined
as:

include::{generated}/api/structs/VkBuildPartitionedAccelerationStructureInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:input is a
    slink:VkPartitionedAccelerationStructureInstancesInputNV structure
    describing the instance and partition count information in the PTLAS.
  * pname:srcAccelerationStructureData is `NULL` or an address of a
    previously built PTLAS.
    If non-`NULL`, the PTLAS stored at this address is used as a basis to
    create new PTLAS.
  * pname:dstAccelerationStructureData is the address to store the built
    PTLAS.
  * pname:scratchData is the device address of scratch memory that will be
    used during PTLAS build.
  * pname:srcInfos is the device address of an array of
    slink:VkBuildPartitionedAccelerationStructureIndirectCommandNV
    structures describing the type of operation to perform.
  * pname:srcInfosCount is a device address containing the size of
    pname:srcInfos array.

Members pname:srcAccelerationStructureData and
pname:dstAccelerationStructureData may: be the same or different.
If they are the same, the update happens in-place.
Otherwise, the destination acceleration structure is updated and the source
is not modified.

.Valid Usage
****
  * [[VUID-VkBuildPartitionedAccelerationStructureInfoNV-scratchData-10558]]
    If the pname:buildScratchSize member of the
    slink:VkAccelerationStructureBuildSizesInfoKHR structure returned from a
    call to flink:vkGetPartitionedAccelerationStructuresBuildSizesNV is not
    `0`, then pname:scratchData must: be a valid device address
  * [[VUID-VkBuildPartitionedAccelerationStructureInfoNV-scratchData-10559]]
    Memory at pname:scratchData must: be equal or larger than the
    slink:VkAccelerationStructureBuildSizesInfoKHR::pname:buildScratchSize
    value returned from
    flink:vkGetPartitionedAccelerationStructuresBuildSizesNV with the same
    build parameters
  * [[VUID-VkBuildPartitionedAccelerationStructureInfoNV-srcAccelerationStructureData-10560]]
    If pname:srcAccelerationStructureData is not `NULL`, it must: have
    previously been built as a PTLAS
  * [[VUID-VkBuildPartitionedAccelerationStructureInfoNV-dstAccelerationStructureData-10561]]
    pname:dstAccelerationStructureData must: not be `NULL`
  * [[VUID-VkBuildPartitionedAccelerationStructureInfoNV-dstAccelerationStructureData-10562]]
    Memory at pname:dstAccelerationStructureData must: be equal or larger
    than the
    slink:VkAccelerationStructureBuildSizesInfoKHR::pname:accelerationStructureSize
    value returned from
    flink:vkGetPartitionedAccelerationStructuresBuildSizesNV with the same
    build parameters
  * [[VUID-VkBuildPartitionedAccelerationStructureInfoNV-srcInfosCount-10563]]
    pname:srcInfosCount must: be 4-byte aligned
  * [[VUID-VkBuildPartitionedAccelerationStructureInfoNV-srcInfos-10564]]
    Each element of pname:srcInfos array must: have a unique
    slink:VkBuildPartitionedAccelerationStructureIndirectCommandNV::pname:opType
****

include::{generated}/validity/structs/VkBuildPartitionedAccelerationStructureInfoNV.adoc[]
--

[open,refpage='VkBuildPartitionedAccelerationStructureIndirectCommandNV',desc='Structure describing PTLAS operation to perform',type='structs']
--
:refpage: VkBuildPartitionedAccelerationStructureIndirectCommandNV

The slink:VkBuildPartitionedAccelerationStructureIndirectCommandNV structure
is defined as:

include::{generated}/api/structs/VkBuildPartitionedAccelerationStructureIndirectCommandNV.adoc[]

  * pname:opType is a elink:VkPartitionedAccelerationStructureOpTypeNV
    describing the type of operation.
  * pname:argCount the number of structures in pname:argData array.
  * pname:argData is an array of slink:VkStridedDeviceAddressNV structures
    containing the write or update data for instances and partitions in the
    PTLAS.
    The structure is dependent on pname:opType as shown in the table below.
[options="header"]
|====
| pname:opType | Format of pname:argData
| ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV |slink:VkPartitionedAccelerationStructureWriteInstanceDataNV
| ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV |slink:VkPartitionedAccelerationStructureUpdateInstanceDataNV
| ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV |slink:VkPartitionedAccelerationStructureWritePartitionTranslationDataNV
|====

.Valid Usage
****
  * [[VUID-VkBuildPartitionedAccelerationStructureIndirectCommandNV-argData-10565]]
    An instance index must: not be referenced by more than one structure in
    pname:argData
****

include::{generated}/validity/structs/VkBuildPartitionedAccelerationStructureIndirectCommandNV.adoc[]
--

[open,refpage='VkPartitionedAccelerationStructureOpTypeNV',desc='Enum providing the type of PTLAS operation to perform',type='enums']
--
Values which can: be set in elink:VkPartitionedAccelerationStructureOpTypeNV
are:

include::{generated}/api/enums/VkPartitionedAccelerationStructureOpTypeNV.adoc[]

  * ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV is
    used to assign a transformed bottom level acceleration structure to an
    instance and partition.
    This is similar to slink:VkAccelerationStructureInstanceKHR that defines
    the properties and transformations for a single instance in
    non-partitioned TLAS.
    Any partition that contains at least one of the affected instances will
    have their internal acceleration structure rebuilt.
  * ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV
    specifies that an instance will be updated with a new bottom level
    acceleration structure.
  * ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV
    specifies that a partition will be assigned a
    <<ptlas-partition-translation, translation vector>>.
--

[open,refpage='VkPartitionedAccelerationStructureWriteInstanceDataNV',desc='Structure describing instance data to write in PTLAS',type='structs']
--
:refpage: VkPartitionedAccelerationStructureWriteInstanceDataNV

The slink:VkPartitionedAccelerationStructureWriteInstanceDataNV structure is
defined as:

include::{generated}/api/structs/VkPartitionedAccelerationStructureWriteInstanceDataNV.adoc[]

  * pname:transform is a slink:VkTransformMatrixKHR structure describing the
    transformation to be applied to the instance in PTLAS.
  * pname:explicitAABB specifies an axis aligned bounding box representing
    the maximum extent of any vertex within the used acceleration structure
    after applying the instance-to-world transformation.
    The <<ptlas-partition-translation, partition translation>> is not
    applied to the bounding box.
  * pname:instanceID is a user specified constant assigned to an instance in
    the PTLAS.
  * pname:instanceMask is a 8-bit mask assigned to the instance that may: be
    used to include or reject group of instances.
  * pname:instanceContributionToHitGroupIndex is a 24-bit per application
    specified instance value added in the indexing into the shader binding
    table to fetch the hit group to use.
  * pname:instanceFlags is a bitmask of
    tlink:VkPartitionedAccelerationStructureInstanceFlagsNV specifying flags
    an instance in the PTLAS.
  * pname:instanceIndex is the index of the instance within the PTLAS.
  * pname:partitionIndex is the index of the partition to which this
    instance belongs.
    <<ptlas-global-partition, Global partitions>> are referred to by
    ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV.
  * pname:accelerationStructure is the device address of the bottom level
    acceleration structure or a clustered bottom level acceleration
    structure that is being instanced.
    This instance is disabled if the device address is `0`.

.Valid Usage
****
  * [[VUID-VkPartitionedAccelerationStructureWriteInstanceDataNV-instanceMask-10566]]
    The most significant 24 bits of pname:instanceMask must: be `0`
  * [[VUID-VkPartitionedAccelerationStructureWriteInstanceDataNV-instanceContributionToHitGroupIndex-10567]]
    The most significant 8 bits of pname:instanceContributionToHitGroupIndex
    must: be `0`
  * [[VUID-VkPartitionedAccelerationStructureWriteInstanceDataNV-instanceIndex-10568]]
    pname:instanceIndex must: be less than
    slink:VkBuildPartitionedAccelerationStructureInfoNV::pname:input.instanceCount
  * [[VUID-VkPartitionedAccelerationStructureWriteInstanceDataNV-partitionIndex-10569]]
    pname:partitionIndex must: be less than
    slink:VkBuildPartitionedAccelerationStructureInfoNV::pname:input.partitionCount
  * [[VUID-VkPartitionedAccelerationStructureWriteInstanceDataNV-explicitAABB-10570]]
    pname:explicitAABB must: be a valid bounding box if instance was created
    with flag
    ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV
    set

****

include::{generated}/validity/structs/VkPartitionedAccelerationStructureWriteInstanceDataNV.adoc[]
--

[open,refpage='VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV',desc='Sentinel for global acceleration structure partitions',type='consts']
--
ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV is a
special constant value used for partitioned acceleration structures to
specify global partitions.

include::{generated}/api/enums/VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV.adoc[]
--

[open,refpage='VkPartitionedAccelerationStructureUpdateInstanceDataNV',desc='Structure describing instance data to update in PTLAS',type='structs']
--
:refpage: VkPartitionedAccelerationStructureUpdateInstanceDataNV

The slink:VkPartitionedAccelerationStructureUpdateInstanceDataNV structure
is defined as:

include::{generated}/api/structs/VkPartitionedAccelerationStructureUpdateInstanceDataNV.adoc[]

  * pname:instanceIndex is the index of the instance being updated.
  * pname:instanceContributionToHitGroupIndex is a 24-bit per instance value
    added in the indexing into the shader binding table to fetch the hit
    group to use.
  * pname:accelerationStructure is the device address of the bottom level
    acceleration structure or a clustered bottom level acceleration
    structure whose instance is being updated.
    The instance is disabled if the device address is `0`.

If the instance was originally disabled by specifying a `0` in
slink:VkPartitionedAccelerationStructureWriteInstanceDataNV::pname:accelerationStructure,
it can not be updated to a new acceleration structure as the instance may:
have been permanently disabled by the implementation.

To avoid a refit, the new acceleration structure must: be within the
bounding box specified by
slink:VkPartitionedAccelerationStructureWriteInstanceDataNV::pname:explicitAABB
when the instance was first created.

.Valid Usage
****
  * [[VUID-VkPartitionedAccelerationStructureUpdateInstanceDataNV-instanceContributionToHitGroupIndex-10571]]
    The most significant 8 bits of pname:instanceContributionToHitGroupIndex
    must: be `0`
  * [[VUID-VkPartitionedAccelerationStructureUpdateInstanceDataNV-None-10572]]
    The instance must: have either been created with flag
    ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV
    or did not have an acceleration structure assigned with
    slink:VkPartitionedAccelerationStructureWriteInstanceDataNV
  * [[VUID-VkPartitionedAccelerationStructureUpdateInstanceDataNV-instanceIndex-10573]]
    pname:instanceIndex must: be less than
    slink:VkBuildPartitionedAccelerationStructureInfoNV::pname:input.instanceCount
****

include::{generated}/validity/structs/VkPartitionedAccelerationStructureUpdateInstanceDataNV.adoc[]
--

[open,refpage='VkPartitionedAccelerationStructureInstanceFlagBitsNV',desc='Bitmask specifying flags for PTLAS instances',type='enums']
--
Bits which can: be set in
slink:VkPartitionedAccelerationStructureWriteInstanceDataNV::pname:instanceFlags,
specifying flags for instances, are:

include::{generated}/api/enums/VkPartitionedAccelerationStructureInstanceFlagBitsNV.adoc[]

  * ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV
    disables face culling for this instance.
  * ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV
    specifies that the <<ray-traversal-culling-face, facing determination>>
    for geometry in this instance is inverted.
  * ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV
    causes this instance to act as though ename:VK_GEOMETRY_OPAQUE_BIT_KHR
    were specified on all geometries referenced by this instance.
  * ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV
    causes this instance to act as though ename:VK_GEOMETRY_OPAQUE_BIT_KHR
    were not specified on all geometries referenced by this instance.
  * ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV
    enables use of an explicit bounding box for this instance.
--

[open,refpage='VkPartitionedAccelerationStructureInstanceFlagsNV',desc='Bitmask of VkPartitionedAccelerationStructureInstanceFlagBitsNV',type='flags']
--
include::{generated}/api/flags/VkPartitionedAccelerationStructureInstanceFlagsNV.adoc[]

tname:VkPartitionedAccelerationStructureInstanceFlagsNV is a bitmask type
for setting a mask of zero or more
elink:VkPartitionedAccelerationStructureInstanceFlagBitsNV.
--

[open,refpage='VkPartitionedAccelerationStructureWritePartitionTranslationDataNV',desc='Structure describing partition translation data to write in PTLAS',type='structs']
--
:refpage: VkPartitionedAccelerationStructureWritePartitionTranslationDataNV

The slink:VkPartitionedAccelerationStructureWritePartitionTranslationDataNV
structure is defined as:

include::{generated}/api/structs/VkPartitionedAccelerationStructureWritePartitionTranslationDataNV.adoc[]

  * pname:partitionIndex is the index of partition to write.
    <<ptlas-global-partition, Global partition>> is referred to by
    ename:VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV.
  * pname:partitionTranslation sets the <<ptlas-partition-translation,
    translation vector>> for this partition.
    When tracing this partition, the contained instances will behave as if
    the partition translation was added to the translation component of the
    instance transform.
    This translation vector is also added to the instances in the partition
    that had their bounding box specified.

.Valid Usage
****
  * [[VUID-VkPartitionedAccelerationStructureWritePartitionTranslationDataNV-partitionIndex-10574]]
    pname:partitionIndex must: be less than
    slink:VkBuildPartitionedAccelerationStructureInfoNV::pname:input.partitionCount
  * [[VUID-VkPartitionedAccelerationStructureWritePartitionTranslationDataNV-enablePartitionTranslation-10575]]
    The partitioned acceleration structure must: have the
    slink:VkPartitionedAccelerationStructureFlagsNV::pname:enablePartitionTranslation
    flag set
****

include::{generated}/validity/structs/VkPartitionedAccelerationStructureWritePartitionTranslationDataNV.adoc[]
--
endif::VK_NV_partitioned_acceleration_structure[]


ifdef::VK_KHR_acceleration_structure[]
[[host-acceleration-structure]]
== Host Acceleration Structure Operations

Implementations are also required to provide host implementations of the
acceleration structure operations if the
<<features-accelerationStructureHostCommands,
pname:accelerationStructureHostCommands>> feature is enabled:

  * flink:vkBuildAccelerationStructuresKHR corresponding to
    flink:vkCmdBuildAccelerationStructuresKHR
  * flink:vkCopyAccelerationStructureKHR corresponding to
    flink:vkCmdCopyAccelerationStructureKHR
  * flink:vkCopyAccelerationStructureToMemoryKHR corresponding to
    flink:vkCmdCopyAccelerationStructureToMemoryKHR
  * flink:vkCopyMemoryToAccelerationStructureKHR corresponding to
    flink:vkCmdCopyMemoryToAccelerationStructureKHR
  * flink:vkWriteAccelerationStructuresPropertiesKHR corresponding to
    flink:vkCmdWriteAccelerationStructuresPropertiesKHR

These commands are functionally equivalent to their device counterparts,
except that they are executed on the host timeline, rather than being
enqueued into command buffers.

All acceleration structures used by the host commands must: be bound to
host-visible memory, and all input data for acceleration structure builds
must: be referenced using host addresses instead of device addresses.
Applications are not required to map acceleration structure memory when
using the host commands.


[NOTE]
====
The flink:vkBuildAccelerationStructuresKHR and
flink:vkCmdBuildAccelerationStructuresKHR may: use different algorithms, and
thus are not required to produce identical structures.
The structures produced by these two commands may: exhibit different memory
footprints or traversal performance, but should strive to be similar where
possible.

Apart from these details, the host and device operations are
interchangeable.
For example, an application can: use flink:vkBuildAccelerationStructuresKHR
to build a structure, compact it on the device using
flink:vkCmdCopyAccelerationStructureKHR, and serialize the result using
flink:vkCopyAccelerationStructureToMemoryKHR.
====

[NOTE]
====
For efficient execution, acceleration structures manipulated using these
commands should always be bound to host cached memory, as the implementation
may need to repeatedly read and write this memory during the execution of
the command.
====

[open,refpage='vkBuildAccelerationStructuresKHR',desc='Build an acceleration structure on the host',type='protos']
--
:refpage: vkBuildAccelerationStructuresKHR

To build acceleration structures on the host, call:

include::{generated}/api/protos/vkBuildAccelerationStructuresKHR.adoc[]

  * pname:device is the sname:VkDevice for which the acceleration structures
    are being built.
  * pname:deferredOperation is an optional slink:VkDeferredOperationKHR to
    <<deferred-host-operations-requesting, request deferral>> for this
    command.
  * pname:infoCount is the number of acceleration structures to build.
    It specifies the number of the pname:pInfos structures and
    pname:ppBuildRangeInfos pointers that must: be provided.
  * pname:pInfos is a pointer to an array of pname:infoCount
    slink:VkAccelerationStructureBuildGeometryInfoKHR structures defining
    the geometry used to build each acceleration structure.
  * pname:ppBuildRangeInfos is a pointer to an array of pname:infoCount
    pointers to arrays of slink:VkAccelerationStructureBuildRangeInfoKHR
    structures.
    Each pname:ppBuildRangeInfos[i] is a pointer to an array of
    pname:pInfos[i].pname:geometryCount
    slink:VkAccelerationStructureBuildRangeInfoKHR structures defining
    dynamic offsets to the addresses where geometry data is stored, as
    defined by pname:pInfos[i].

This command fulfills the same task as
flink:vkCmdBuildAccelerationStructuresKHR but is executed by the host.

The fname:vkBuildAccelerationStructuresKHR command provides the ability to
initiate multiple acceleration structures builds, however there is no
ordering or synchronization implied between any of the individual
acceleration structure builds.

[NOTE]
====
This means that an application cannot: build a top-level acceleration
structure in the same flink:vkBuildAccelerationStructuresKHR call as the
associated bottom-level or instance acceleration structures are being built.
There also cannot: be any memory aliasing between any acceleration structure
memories or scratch memories being used by any of the builds.
====

.Valid Usage
****
  * [[VUID-vkBuildAccelerationStructuresKHR-accelerationStructureHostCommands-03581]]
    The <<features-accelerationStructureHostCommands,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructureHostCommands>>
    feature must: be enabled

:maxinstancecheck: pname:ppBuildRangeInfos[i][j].pname:primitiveCount
include::{chapters}/commonvalidity/build_acceleration_structure_common.adoc[]
include::{chapters}/commonvalidity/build_acceleration_structure_nonindirect_common.adoc[]
include::{chapters}/commonvalidity/deferred_operations_common.adoc[]
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-03722]]
    For each element of pname:pInfos, the pname:buffer used to create its
    pname:dstAccelerationStructure member must: be bound to host-visible
    device memory
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-03723]]
    For each element of pname:pInfos, if its pname:mode member is
    ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR the pname:buffer
    used to create its pname:srcAccelerationStructure member must: be bound
    to host-visible device memory
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-03724]]
    For each element of pname:pInfos, the pname:buffer used to create each
    acceleration structure referenced by the pname:geometry.instances.data
    member of any element of pname:pGeometries or pname:ppGeometries with a
    pname:geometryType of ename:VK_GEOMETRY_TYPE_INSTANCES_KHR must: be
    bound to host-visible device memory
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-12244]]
    If pname:pInfos[i].pname:mode is
    ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR, and N is not `0`,
    all addresses between pname:pInfos[i].pname:scratchData.hostAddress and
    pname:pInfos[i].pname:scratchData.hostAddress [eq]#{plus} N - 1# must:
    be valid host memory, where N is given by the pname:buildScratchSize
    member of the slink:VkAccelerationStructureBuildSizesInfoKHR structure
    returned from a call to flink:vkGetAccelerationStructureBuildSizesKHR
    with an identical slink:VkAccelerationStructureBuildGeometryInfoKHR
    structure and primitive count
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-12245]]
    If pname:pInfos[i].pname:mode is
    ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, and N is not `0`,
    all addresses between pname:pInfos[i].pname:scratchData.hostAddress and
    pname:pInfos[i].pname:scratchData.hostAddress [eq]#{plus} N - 1# must:
    be valid host memory, where N is given by the pname:updateScratchSize
    member of the slink:VkAccelerationStructureBuildSizesInfoKHR structure
    returned from a call to flink:vkGetAccelerationStructureBuildSizesKHR
    with an identical slink:VkAccelerationStructureBuildGeometryInfoKHR
    structure and primitive count
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-03771]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR,
    pname:geometry.triangles.vertexData.hostAddress must: be a valid host
    address
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-03772]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if
    pname:geometry.triangles.indexType is not ename:VK_INDEX_TYPE_NONE_KHR,
    pname:geometry.triangles.indexData.hostAddress must: be a valid host
    address
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-03773]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if
    pname:geometry.triangles.transformData.hostAddress is not `0`, it must:
    be a valid host address
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-03774]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_AABBS_KHR, pname:geometry.aabbs.data.hostAddress
    must: be a valid host address
ifdef::VK_KHR_device_group,VK_BASE_VERSION_1_1[]
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-03775]]
    For each element of pname:pInfos, the pname:buffer used to create its
    pname:dstAccelerationStructure member must: be bound to memory that was
    not allocated with multiple instances
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-03776]]
    For each element of pname:pInfos, if its pname:mode member is
    ename:VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR the pname:buffer
    used to create its pname:srcAccelerationStructure member must: be bound
    to memory that was not allocated with multiple instances
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-03777]]
    For each element of pname:pInfos, the pname:buffer used to create each
    acceleration structure referenced by the pname:geometry.instances.data
    member of any element of pname:pGeometries or pname:ppGeometries with a
    pname:geometryType of ename:VK_GEOMETRY_TYPE_INSTANCES_KHR must: be
    bound to memory that was not allocated with multiple instances
endif::VK_KHR_device_group,VK_BASE_VERSION_1_1[]
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-03778]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_INSTANCES_KHR,
    pname:geometry.instances.data.hostAddress must: be a valid host address
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-03779]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_INSTANCES_KHR, each
    slink:VkAccelerationStructureInstanceKHR::pname:accelerationStructureReference
    value in pname:geometry.instances.data.hostAddress must: be a valid
    slink:VkAccelerationStructureKHR object
ifdef::VK_NV_ray_tracing_motion_blur[]
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-04930]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_INSTANCES_KHR with
    ename:VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV set, each
    pname:accelerationStructureReference in any structure in
    slink:VkAccelerationStructureMotionInstanceNV value in
    pname:geometry.instances.data.hostAddress must: be a valid
    slink:VkAccelerationStructureKHR object
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-11820]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if there is an instance of
    slink:VkAccelerationStructureGeometryMotionTrianglesDataNV in the
    pname:geometry.triangles.pNext chain, then its
    pname:vertexData.hostAddress must: not be 0
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_EXT_opacity_micromap[]
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-10892]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if there is an instance of
    slink:VkAccelerationStructureTrianglesOpacityMicromapEXT in the
    pname:geometry.triangles.pNext chain, and its pname:indexType is
    ename:VK_INDEX_TYPE_NONE_KHR, then its pname:indexBuffer.hostAddress
    must: be 0
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-11821]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_TRIANGLES_KHR, if there is an instance of
    slink:VkAccelerationStructureTrianglesOpacityMicromapEXT in the
    pname:geometry.triangles.pNext chain, and its pname:indexType is not
    ename:VK_INDEX_TYPE_NONE_KHR, then its pname:indexBuffer.hostAddress
    must: not be 0
endif::VK_EXT_opacity_micromap[]
ifdef::VK_NV_ray_tracing_linear_swept_spheres[]
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-11822]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_SPHERES_NV,
    slink:VkAccelerationStructureGeometrySpheresDataNV::pname:indexType is
    ename:VK_INDEX_TYPE_NONE_KHR, then its pname:indexData.hostAddress must:
    be 0
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-11823]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_SPHERES_NV,
    slink:VkAccelerationStructureGeometrySpheresDataNV::pname:indexType is
    not ename:VK_INDEX_TYPE_NONE_KHR, then its pname:indexData.hostAddress
    must: not be 0
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-11824]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_SPHERES_NV,
    slink:VkAccelerationStructureGeometrySpheresDataNV::pname:vertexData.hostAddress
    must: not be 0
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-11825]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_SPHERES_NV,
    slink:VkAccelerationStructureGeometrySpheresDataNV::pname:radiusData.hostAddress
    must: not be 0
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-11826]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV,
    slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV::pname:indexType
    is ename:VK_INDEX_TYPE_NONE_KHR, then its pname:indexData.hostAddress
    must: be 0
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-11827]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV,
    slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV::pname:indexType
    is not ename:VK_INDEX_TYPE_NONE_KHR, then its
    pname:indexData.hostAddress must: not be 0
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-11828]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV,
    slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV::pname:vertexData.hostAddress
    must: not be 0
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-11829]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries with a pname:geometryType of
    ename:VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV,
    slink:VkAccelerationStructureGeometryLinearSweptSpheresDataNV::pname:radiusData.hostAddress
    must: not be 0
endif::VK_NV_ray_tracing_linear_swept_spheres[]
ifdef::VK_AMDX_dense_geometry_format[]
  * [[VUID-vkBuildAccelerationStructuresKHR-pInfos-10893]]
    For each element of pname:pInfos[i].pname:pGeometries or
    pname:pInfos[i].pname:ppGeometries, pname:geometryType must: not be
    ename:VK_GEOMETRY_TYPE_DENSE_GEOMETRY_FORMAT_TRIANGLES_AMDX
endif::VK_AMDX_dense_geometry_format[]
****

include::{generated}/validity/protos/vkBuildAccelerationStructuresKHR.adoc[]
--

[open,refpage='vkCopyAccelerationStructureKHR',desc='Copy an acceleration structure on the host',type='protos']
--
:refpage: vkCopyAccelerationStructureKHR

To copy or compact an acceleration structure on the host, call:

include::{generated}/api/protos/vkCopyAccelerationStructureKHR.adoc[]

  * pname:device is the device which owns the acceleration structures.
  * pname:deferredOperation is an optional slink:VkDeferredOperationKHR to
    <<deferred-host-operations-requesting, request deferral>> for this
    command.
  * pname:pInfo is a pointer to a slink:VkCopyAccelerationStructureInfoKHR
    structure defining the copy operation.

This command fulfills the same task as
flink:vkCmdCopyAccelerationStructureKHR but is executed by the host.

.Valid Usage
****
  * [[VUID-vkCopyAccelerationStructureKHR-accelerationStructureHostCommands-03582]]
    The <<features-accelerationStructureHostCommands,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructureHostCommands>>
    feature must: be enabled
include::{chapters}/commonvalidity/deferred_operations_common.adoc[]
  * [[VUID-vkCopyAccelerationStructureKHR-buffer-03727]]
    The pname:buffer used to create pname:pInfo->src must: be bound to
    host-visible device memory
  * [[VUID-vkCopyAccelerationStructureKHR-buffer-03728]]
    The pname:buffer used to create pname:pInfo->dst must: be bound to
    host-visible device memory
ifdef::VK_KHR_device_group,VK_BASE_VERSION_1_1[]
  * [[VUID-vkCopyAccelerationStructureKHR-buffer-03780]]
    The pname:buffer used to create pname:pInfo->src must: be bound to
    memory that was not allocated with multiple instances
  * [[VUID-vkCopyAccelerationStructureKHR-buffer-03781]]
    The pname:buffer used to create pname:pInfo->dst must: be bound to
    memory that was not allocated with multiple instances
endif::VK_KHR_device_group,VK_BASE_VERSION_1_1[]
****

include::{generated}/validity/protos/vkCopyAccelerationStructureKHR.adoc[]
--

[open,refpage='vkCopyMemoryToAccelerationStructureKHR',desc='Deserialize an acceleration structure on the host',type='protos']
--
:refpage: vkCopyMemoryToAccelerationStructureKHR

To copy host accessible memory to an acceleration structure, call:

include::{generated}/api/protos/vkCopyMemoryToAccelerationStructureKHR.adoc[]

  * pname:device is the device which owns pname:pInfo->dst.
  * pname:deferredOperation is an optional slink:VkDeferredOperationKHR to
    <<deferred-host-operations-requesting, request deferral>> for this
    command.
  * pname:pInfo is a pointer to a
    slink:VkCopyMemoryToAccelerationStructureInfoKHR structure defining the
    copy operation.

This command fulfills the same task as
flink:vkCmdCopyMemoryToAccelerationStructureKHR but is executed by the host.

This command can accept acceleration structures produced by either
flink:vkCmdCopyAccelerationStructureToMemoryKHR or
flink:vkCopyAccelerationStructureToMemoryKHR.

.Valid Usage
****
  * [[VUID-vkCopyMemoryToAccelerationStructureKHR-accelerationStructureHostCommands-03583]]
    The <<features-accelerationStructureHostCommands,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructureHostCommands>>
    feature must: be enabled
include::{chapters}/commonvalidity/deferred_operations_common.adoc[]
  * [[VUID-vkCopyMemoryToAccelerationStructureKHR-pInfo-03729]]
    pname:pInfo->src.hostAddress must: be a valid host pointer
  * [[VUID-vkCopyMemoryToAccelerationStructureKHR-pInfo-03750]]
    pname:pInfo->src.hostAddress must: be aligned to 16 bytes
  * [[VUID-vkCopyMemoryToAccelerationStructureKHR-buffer-03730]]
    The pname:buffer used to create pname:pInfo->dst must: be bound to
    host-visible device memory
ifdef::VK_KHR_device_group,VK_BASE_VERSION_1_1[]
  * [[VUID-vkCopyMemoryToAccelerationStructureKHR-buffer-03782]]
    The pname:buffer used to create pname:pInfo->dst must: be bound to
    memory that was not allocated with multiple instances
endif::VK_KHR_device_group,VK_BASE_VERSION_1_1[]
****

include::{generated}/validity/protos/vkCopyMemoryToAccelerationStructureKHR.adoc[]
--

[open,refpage='vkCopyAccelerationStructureToMemoryKHR',desc='Serialize an acceleration structure on the host',type='protos']
--
:refpage: vkCopyAccelerationStructureToMemoryKHR

To copy an acceleration structure to host accessible memory, call:

include::{generated}/api/protos/vkCopyAccelerationStructureToMemoryKHR.adoc[]

  * pname:device is the device which owns pname:pInfo->src.
  * pname:deferredOperation is an optional slink:VkDeferredOperationKHR to
    <<deferred-host-operations-requesting, request deferral>> for this
    command.
  * pname:pInfo is a pointer to a
    slink:VkCopyAccelerationStructureToMemoryInfoKHR structure defining the
    copy operation.

This command fulfills the same task as
flink:vkCmdCopyAccelerationStructureToMemoryKHR but is executed by the host.

This command produces the same results as
flink:vkCmdCopyAccelerationStructureToMemoryKHR, but writes its result
directly to a host pointer, and is executed on the host rather than the
device.
The output may: not necessarily be bit-for-bit identical, but it can be
equally used by either flink:vkCmdCopyMemoryToAccelerationStructureKHR or
flink:vkCopyMemoryToAccelerationStructureKHR.

.Valid Usage
****
  * [[VUID-vkCopyAccelerationStructureToMemoryKHR-accelerationStructureHostCommands-03584]]
    The <<features-accelerationStructureHostCommands,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructureHostCommands>>
    feature must: be enabled
include::{chapters}/commonvalidity/deferred_operations_common.adoc[]
  * [[VUID-vkCopyAccelerationStructureToMemoryKHR-buffer-03731]]
    The pname:buffer used to create pname:pInfo->src must: be bound to
    host-visible device memory
  * [[VUID-vkCopyAccelerationStructureToMemoryKHR-pInfo-03732]]
    pname:pInfo->dst.hostAddress must: be a valid host pointer
  * [[VUID-vkCopyAccelerationStructureToMemoryKHR-pInfo-03751]]
    pname:pInfo->dst.hostAddress must: be aligned to 16 bytes
ifdef::VK_KHR_device_group,VK_BASE_VERSION_1_1[]
  * [[VUID-vkCopyAccelerationStructureToMemoryKHR-buffer-03783]]
    The pname:buffer used to create pname:pInfo->src must: be bound to
    memory that was not allocated with multiple instances
endif::VK_KHR_device_group,VK_BASE_VERSION_1_1[]
****

include::{generated}/validity/protos/vkCopyAccelerationStructureToMemoryKHR.adoc[]
--

[open,refpage='vkWriteAccelerationStructuresPropertiesKHR',desc='Query acceleration structure meta-data on the host',type='protos']
--
:refpage: vkWriteAccelerationStructuresPropertiesKHR

To query acceleration structure size parameters on the host, call:

include::{generated}/api/protos/vkWriteAccelerationStructuresPropertiesKHR.adoc[]

  * pname:device is the device which owns the acceleration structures in
    pname:pAccelerationStructures.
  * pname:accelerationStructureCount is the count of acceleration structures
    for which to query the property.
  * pname:pAccelerationStructures is a pointer to an array of existing
    previously built acceleration structures.
  * pname:queryType is a elink:VkQueryType value specifying the property to
    be queried.
  * pname:dataSize is the size in bytes of the buffer pointed to by
    pname:pData.
  * pname:pData is a pointer to an application-allocated buffer where the
    results will be written.
  * pname:stride is the stride in bytes between results for individual
    queries within pname:pData.

This command fulfills the same task as
flink:vkCmdWriteAccelerationStructuresPropertiesKHR but is executed by the
host.

.Valid Usage
****
  * [[VUID-vkWriteAccelerationStructuresPropertiesKHR-accelerationStructureHostCommands-03585]]
    The <<features-accelerationStructureHostCommands,
    sname:VkPhysicalDeviceAccelerationStructureFeaturesKHR::pname:accelerationStructureHostCommands>>
    feature must: be enabled
include::{chapters}/commonvalidity/write_acceleration_structure_properties_common.adoc[]
  * [[VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03448]]
    If pname:queryType is
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR, then
    pname:stride must: be a multiple of the size of basetype:VkDeviceSize
  * [[VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03449]]
    If pname:queryType is
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR, then
    pname:pData must: point to a basetype:VkDeviceSize
  * [[VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03450]]
    If pname:queryType is
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR, then
    pname:stride must: be a multiple of the size of basetype:VkDeviceSize
  * [[VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03451]]
    If pname:queryType is
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR, then
    pname:pData must: point to a basetype:VkDeviceSize
ifdef::VK_KHR_ray_tracing_maintenance1[]
  * [[VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06731]]
    If pname:queryType is
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR, then pname:stride
    must: be a multiple of the size of basetype:VkDeviceSize
  * [[VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06732]]
    If pname:queryType is
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR, then pname:pData
    must: point to a basetype:VkDeviceSize
  * [[VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06733]]
    If pname:queryType is
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR,
    then pname:stride must: be a multiple of the size of
    basetype:VkDeviceSize
  * [[VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06734]]
    If pname:queryType is
    ename:VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR,
    then pname:pData must: point to a basetype:VkDeviceSize
endif::VK_KHR_ray_tracing_maintenance1[]
  * [[VUID-vkWriteAccelerationStructuresPropertiesKHR-dataSize-03452]]
    pname:dataSize must: be greater than or equal to
    [eq]#pname:accelerationStructureCount*pname:stride#
  * [[VUID-vkWriteAccelerationStructuresPropertiesKHR-buffer-03733]]
    The pname:buffer used to create each acceleration structure in
    pname:pAccelerationStructures must: be bound to host-visible device
    memory
ifdef::VK_KHR_device_group,VK_BASE_VERSION_1_1[]
  * [[VUID-vkWriteAccelerationStructuresPropertiesKHR-buffer-03784]]
    The pname:buffer used to create each acceleration structure in
    pname:pAccelerationStructures must: be bound to memory that was not
    allocated with multiple instances
endif::VK_KHR_device_group,VK_BASE_VERSION_1_1[]
****

include::{generated}/validity/protos/vkWriteAccelerationStructuresPropertiesKHR.adoc[]
--
endif::VK_KHR_acceleration_structure[]
