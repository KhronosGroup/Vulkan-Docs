// Copyright 2015-2022 The Khronos Group Inc.
//
// SPDX-License-Identifier: CC-BY-4.0

[[pipelines]]
= Pipelines

The following <<pipelines-block-diagram,figure>> shows a block diagram of
the Vulkan pipelines.
Some Vulkan commands specify geometric objects to be drawn or computational
work to be performed, while others specify state controlling how objects are
handled by the various pipeline stages, or control data transfer between
memory organized as images and buffers.
Commands are effectively sent through a processing pipeline, either a
_graphics pipeline_,
ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
a _ray tracing pipeline_,
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
or a _compute pipeline_.

ifdef::VK_NV_mesh_shader[]
The graphics pipeline can be operated in two modes, as either _primitive
shading_ or _mesh shading_ pipeline.

*Primitive Shading*

endif::VK_NV_mesh_shader[]

The first stage of the <<pipelines-graphics,graphics pipeline>>
(<<drawing,Input Assembler>>) assembles vertices to form geometric
primitives such as points, lines, and triangles, based on a requested
primitive topology.
In the next stage (<<shaders-vertex,Vertex Shader>>) vertices can: be
transformed, computing positions and attributes for each vertex.
If <<tessellation,tessellation>> and/or <<geometry,geometry>> shaders are
supported, they can: then generate multiple primitives from a single input
primitive, possibly changing the primitive topology or generating additional
attribute data in the process.

ifdef::VK_NV_mesh_shader[]
*Mesh Shading*

When using the <<mesh,_mesh shading_>> pipeline input primitives are not
assembled implicitly, but explicitly through the (<<shaders-mesh,Mesh
Shader>>).
The work on the mesh pipeline is initiated by the application
<<drawing-mesh-shading,drawing>> a set of mesh tasks.

If an optional (<<shaders-task,Task Shader>>) is active, each task triggers
the execution of a task shader workgroup that will generate a new set of
tasks upon completion.
Each of these spawned tasks, or each of the original dispatched tasks if no
task shader is present, triggers the execution of a mesh shader workgroup
that produces an output mesh with a variable-sized number of primitives
assembled from vertices stored in the output mesh.

*Common*
endif::VK_NV_mesh_shader[]

The final resulting primitives are <<vertexpostproc-clipping,clipped>> to a
clip volume in preparation for the next stage, <<primsrast,Rasterization>>.
The rasterizer produces a series of _fragments_ associated with a region of
the framebuffer, from a two-dimensional description of a point, line
segment, or triangle.
These fragments are processed by <<fragops,fragment operations>> to
determine whether generated values will be written to the framebuffer.
<<fragops-shader, Fragment shading>> determines the values to be written to
the framebuffer attachments.
Framebuffer operations then read and write the color and depth/stencil
attachments of the framebuffer for a given subpass of a <<renderpass,render
pass instance>>.
The attachments can: be used as input attachments in the fragment shader in
a later subpass of the same render pass.

The <<pipelines-compute,compute pipeline>> is a separate pipeline from the
graphics pipeline, which operates on one-, two-, or three-dimensional
workgroups which can: read from and write to buffer and image memory.

This ordering is meant only as a tool for describing Vulkan, not as a strict
rule of how Vulkan is implemented, and we present it only as a means to
organize the various operations of the pipelines.
Actual ordering guarantees between pipeline stages are explained in detail
in the <<synchronization-pipeline-stages-order, synchronization chapter>>.

[[pipelines-block-diagram]]
ifndef::VK_NV_mesh_shader[]
image::{images}/pipeline.svg[title="Block diagram of the Vulkan pipeline",align="center",opts="{imageopts}"]
endif::VK_NV_mesh_shader[]
ifdef::VK_NV_mesh_shader[]
image::{images}/pipelinemesh.svg[title="Block diagram of the Vulkan pipeline",align="center",opts="{imageopts}"]
endif::VK_NV_mesh_shader[]

Each pipeline is controlled by a monolithic object created from a
description of all of the shader stages and any relevant fixed-function
stages.
<<interfaces,Linking>> the whole pipeline together allows the optimization
of shaders based on their input/outputs and eliminates expensive draw time
state validation.

A pipeline object is bound to the current state using
flink:vkCmdBindPipeline.
Any pipeline object state that is specified as <<pipelines-dynamic-state,
dynamic>> is not applied to the current state when the pipeline object is
bound, but is instead set by dynamic state setting commands.

No state, including dynamic state, is inherited from one command buffer to
another.


[open,refpage='VkPipeline',desc='Opaque handle to a pipeline object',type='handles']
--
Compute,
ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
ray tracing,
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
and graphics pipelines are each represented by sname:VkPipeline handles:

include::{generated}/api/handles/VkPipeline.txt[]
--


[[pipelines-compute]]
== Compute Pipelines

Compute pipelines consist of a single static compute shader stage and the
pipeline layout.

The compute pipeline represents a compute shader and is created by calling
fname:vkCreateComputePipelines with pname:module and pname:pName selecting
an entry point from a shader module, where that entry point defines a valid
compute shader, in the slink:VkPipelineShaderStageCreateInfo structure
contained within the slink:VkComputePipelineCreateInfo structure.

[open,refpage='vkCreateComputePipelines',desc='Creates a new compute pipeline object',type='protos']
--
To create compute pipelines, call:

include::{generated}/api/protos/vkCreateComputePipelines.txt[]

  * pname:device is the logical device that creates the compute pipelines.
  * pname:pipelineCache is either dlink:VK_NULL_HANDLE, indicating that
    pipeline caching is disabled; or the handle of a valid
    <<pipelines-cache,pipeline cache>> object, in which case use of that
    cache is enabled for the duration of the command.
  * pname:createInfoCount is the length of the pname:pCreateInfos and
    pname:pPipelines arrays.
  * pname:pCreateInfos is a pointer to an array of
    slink:VkComputePipelineCreateInfo structures.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pPipelines is a pointer to an array of slink:VkPipeline handles in
    which the resulting compute pipeline objects are returned.
ifdef::editing-notes[]
+
[NOTE]
.editing-note
====
TODO (Jon) - Should we say something like "`the i'th element of the
pname:pPipelines array is created based on the corresponding element of the
pname:pCreateInfos array`"? Also for flink:vkCreateGraphicsPipelines below.
====
endif::editing-notes[]

.Valid Usage
****
  * [[VUID-vkCreateComputePipelines-flags-00695]]
    If the pname:flags member of any element of pname:pCreateInfos contains
    the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the
    pname:basePipelineIndex member of that same element is not `-1`,
    pname:basePipelineIndex must: be less than the index into
    pname:pCreateInfos that corresponds to that element
  * [[VUID-vkCreateComputePipelines-flags-00696]]
    If the pname:flags member of any element of pname:pCreateInfos contains
    the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline
    must: have been created with the
    ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * [[VUID-vkCreateComputePipelines-pipelineCache-02873]]
    If pname:pipelineCache was created with
    ename:VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT, host access
    to pname:pipelineCache must: be
    <<fundamentals-threadingbehavior,externally synchronized>>
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
****

include::{generated}/validity/protos/vkCreateComputePipelines.txt[]
--

[open,refpage='VkComputePipelineCreateInfo',desc='Structure specifying parameters of a newly created compute pipeline',type='structs']
--
The sname:VkComputePipelineCreateInfo structure is defined as:

include::{generated}/api/structs/VkComputePipelineCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkPipelineCreateFlagBits specifying
    how the pipeline will be generated.
  * pname:stage is a slink:VkPipelineShaderStageCreateInfo structure
    describing the compute shader.
  * pname:layout is the description of binding locations used by both the
    pipeline and descriptor sets used with the pipeline.
  * pname:basePipelineHandle is a pipeline to derive from
  * pname:basePipelineIndex is an index into the pname:pCreateInfos
    parameter to use as a pipeline to derive from

The parameters pname:basePipelineHandle and pname:basePipelineIndex are
described in more detail in <<pipelines-pipeline-derivatives,Pipeline
Derivatives>>.

.Valid Usage
****
  * [[VUID-VkComputePipelineCreateInfo-flags-00697]]
    If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineIndex is -1, pname:basePipelineHandle must:
    be a valid handle to a compute sname:VkPipeline
  * [[VUID-VkComputePipelineCreateInfo-flags-00698]]
    If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineHandle is dlink:VK_NULL_HANDLE,
    pname:basePipelineIndex must: be a valid index into the calling
    command's pname:pCreateInfos parameter
  * [[VUID-VkComputePipelineCreateInfo-flags-00699]]
    If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineIndex is not -1, pname:basePipelineHandle
    must: be dlink:VK_NULL_HANDLE
  * [[VUID-VkComputePipelineCreateInfo-flags-00700]]
    If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineHandle is not dlink:VK_NULL_HANDLE,
    pname:basePipelineIndex must: be -1
  * [[VUID-VkComputePipelineCreateInfo-stage-00701]]
    The pname:stage member of pname:stage must: be
    ename:VK_SHADER_STAGE_COMPUTE_BIT
  * [[VUID-VkComputePipelineCreateInfo-stage-00702]]
    The shader code for the entry point identified by pname:stage and the
    rest of the state identified by this structure must: adhere to the
    pipeline linking rules described in the <<interfaces,Shader Interfaces>>
    chapter
  * [[VUID-VkComputePipelineCreateInfo-layout-00703]]
    pname:layout must: be
    <<descriptorsets-pipelinelayout-consistency,consistent>> with the layout
    of the compute shader specified in pname:stage
  * [[VUID-VkComputePipelineCreateInfo-layout-01687]]
    The number of resources in pname:layout accessible to the compute shader
    stage must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxPerStageResources
ifdef::VK_KHR_pipeline_library[]
  * [[VUID-VkComputePipelineCreateInfo-flags-03364]]
    pname:flags must: not include ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
endif::VK_KHR_pipeline_library[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * [[VUID-VkComputePipelineCreateInfo-flags-03365]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR
  * [[VUID-VkComputePipelineCreateInfo-flags-03366]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
  * [[VUID-VkComputePipelineCreateInfo-flags-03367]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
  * [[VUID-VkComputePipelineCreateInfo-flags-03368]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
  * [[VUID-VkComputePipelineCreateInfo-flags-03369]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
  * [[VUID-VkComputePipelineCreateInfo-flags-03370]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR
  * [[VUID-VkComputePipelineCreateInfo-flags-03576]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_ray_tracing_motion_blur[]
  * [[VUID-VkComputePipelineCreateInfo-flags-04945]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_NV_device_generated_commands[]
  * [[VUID-VkComputePipelineCreateInfo-flags-02874]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV
endif::VK_NV_device_generated_commands[]
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * [[VUID-VkComputePipelineCreateInfo-pipelineCreationCacheControl-02875]]
    If the <<features-pipelineCreationCacheControl,
    pname:pipelineCreationCacheControl>> feature is not enabled, pname:flags
    must: not include
    ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT or
    ename:VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifdef::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
  * [[VUID-VkComputePipelineCreateInfo-pipelineStageCreationFeedbackCount-06566]]
    If
    slink:VkPipelineCreationFeedbackCreateInfo::pname:pipelineStageCreationFeedbackCount
    is not `0`, it must: be `1`
endif::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
****

include::{generated}/validity/structs/VkComputePipelineCreateInfo.txt[]
--

[open,refpage='VkPipelineShaderStageCreateInfo',desc='Structure specifying parameters of a newly created pipeline shader stage',type='structs']
--
The sname:VkPipelineShaderStageCreateInfo structure is defined as:

include::{generated}/api/structs/VkPipelineShaderStageCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkPipelineShaderStageCreateFlagBits
    specifying how the pipeline shader stage will be generated.
  * pname:stage is a elink:VkShaderStageFlagBits value specifying a single
    pipeline stage.
ifdef::VK_EXT_graphics_pipeline_library,VK_EXT_shader_module_identifier[]
  * pname:module is optionally a slink:VkShaderModule object containing the
    shader code for this stage.
endif::VK_EXT_graphics_pipeline_library,VK_EXT_shader_module_identifier[]
ifndef::VK_EXT_graphics_pipeline_library,VK_EXT_shader_module_identifier[]
  * pname:module is a slink:VkShaderModule object containing the shader code
    for this stage.
endif::VK_EXT_graphics_pipeline_library,VK_EXT_shader_module_identifier[]
  * pname:pName is a pointer to a null-terminated UTF-8 string specifying
    the entry point name of the shader for this stage.
  * pname:pSpecializationInfo is a pointer to a slink:VkSpecializationInfo
    structure, as described in
    <<pipelines-specialization-constants,Specialization Constants>>, or
    `NULL`.

ifdef::VK_EXT_graphics_pipeline_library[]
If the <<features-graphicsPipelineLibrary, pname:graphicsPipelineLibrary>>
feature is enabled and an instance of slink:VkShaderModuleCreateInfo is
included in the pname:pNext chain, pname:module can: be
dlink:VK_NULL_HANDLE.
If pname:module is not dlink:VK_NULL_HANDLE, the shader code used by the
pipeline is defined by pname:module.
If pname:module is dlink:VK_NULL_HANDLE, the shader code is defined by the
chained slink:VkShaderModuleCreateInfo if present.
endif::VK_EXT_graphics_pipeline_library[]
ifndef::VK_EXT_graphics_pipeline_library[]
The shader code used by the pipeline is defined by pname:module.
endif::VK_EXT_graphics_pipeline_library[]

ifdef::VK_EXT_shader_module_identifier[]
If the <<features-shaderModuleIdentifier, pname:shaderModuleIdentifier>>
feature is enabled, applications can: omit shader code for pname:stage and
instead provide a module identifier.
This is done by including a
slink:VkPipelineShaderStageModuleIdentifierCreateInfoEXT struct with
pname:identifierSize not equal to 0 in the pname:pNext chain.
A shader stage created in this way is equivalent to one created using a
shader module with the same identifier.
The identifier allows an implementation to look up a pipeline without
consuming a valid SPIR-V module.
If a pipeline is not found, pipeline compilation is not possible and the
implementation must: fail as specified by
ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT.

When an identifier is used in lieu of a shader module, implementations may:
fail pipeline compilation with ename:VK_PIPELINE_COMPILE_REQUIRED for any
reason.

[NOTE]
.Note
====
The rationale for the relaxed requirement on implementations to return a
pipeline with slink:VkPipelineShaderStageModuleIdentifierCreateInfoEXT is
that layers or tools may intercept pipeline creation calls and require the
full SPIR-V context to operate correctly.
ICDs are not expected to fail pipeline compilation if the pipeline exists in
a cache somewhere.
====

ifdef::VK_KHR_pipeline_library[]
Applications can: use identifiers when creating pipelines with
ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR.
When creating such pipelines, ename:VK_SUCCESS may: be returned, but
subsequently fail when referencing the pipeline in a
slink:VkPipelineLibraryCreateInfoKHR struct.
Applications must: allow pipeline compilation to fail during link steps with
ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT as it may:
not be possible to determine if a pipeline can: be created from identifiers
until the link step.
endif::VK_KHR_pipeline_library[]
endif::VK_EXT_shader_module_identifier[]

.Valid Usage
****
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00704]]
    If the <<features-geometryShader, pname:geometryShader>> feature is not
    enabled, pname:stage must: not be ename:VK_SHADER_STAGE_GEOMETRY_BIT
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00705]]
    If the <<features-tessellationShader, pname:tessellationShader>> feature
    is not enabled, pname:stage must: not be
    ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
ifdef::VK_NV_mesh_shader[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-02091]]
    If the <<features-meshShader, pname:meshShader>> feature is not enabled,
    pname:stage must: not be ename:VK_SHADER_STAGE_MESH_BIT_NV
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-02092]]
    If the <<features-taskShader, pname:taskShader>> feature is not enabled,
    pname:stage must: not be ename:VK_SHADER_STAGE_TASK_BIT_NV
endif::VK_NV_mesh_shader[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00706]]
    pname:stage must: not be ename:VK_SHADER_STAGE_ALL_GRAPHICS, or
    ename:VK_SHADER_STAGE_ALL
  * [[VUID-VkPipelineShaderStageCreateInfo-pName-00707]]
    pname:pName must: be the name of an code:OpEntryPoint in pname:module
    with an execution model that matches pname:stage
  * [[VUID-VkPipelineShaderStageCreateInfo-maxClipDistances-00708]]
    If the identified entry point includes any variable in its interface
    that is declared with the code:ClipDistance code:BuiltIn decoration,
    that variable must: not have an array size greater than
    sname:VkPhysicalDeviceLimits::pname:maxClipDistances
  * [[VUID-VkPipelineShaderStageCreateInfo-maxCullDistances-00709]]
    If the identified entry point includes any variable in its interface
    that is declared with the code:CullDistance code:BuiltIn decoration,
    that variable must: not have an array size greater than
    sname:VkPhysicalDeviceLimits::pname:maxCullDistances
  * [[VUID-VkPipelineShaderStageCreateInfo-maxCombinedClipAndCullDistances-00710]]
    If the identified entry point includes any variables in its interface
    that are declared with the code:ClipDistance or code:CullDistance
    code:BuiltIn decoration, those variables must: not have array sizes
    which sum to more than
    sname:VkPhysicalDeviceLimits::pname:maxCombinedClipAndCullDistances
  * [[VUID-VkPipelineShaderStageCreateInfo-maxSampleMaskWords-00711]]
    If the identified entry point includes any variable in its interface
    that is declared with the code:SampleMask code:BuiltIn decoration, that
    variable must: not have an array size greater than
    sname:VkPhysicalDeviceLimits::pname:maxSampleMaskWords
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00712]]
    If pname:stage is ename:VK_SHADER_STAGE_VERTEX_BIT, the identified entry
    point must: not include any input variable in its interface that is
    decorated with code:CullDistance
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00713]]
    If pname:stage is ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, and the identified
    entry point has an code:OpExecutionMode instruction specifying a patch
    size with code:OutputVertices, the patch size must: be greater than `0`
    and less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxTessellationPatchSize
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00714]]
    If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, the identified
    entry point must: have an code:OpExecutionMode instruction specifying a
    maximum output vertex count that is greater than `0` and less than or
    equal to sname:VkPhysicalDeviceLimits::pname:maxGeometryOutputVertices
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00715]]
    If pname:stage is ename:VK_SHADER_STAGE_GEOMETRY_BIT, the identified
    entry point must: have an code:OpExecutionMode instruction specifying an
    invocation count that is greater than `0` and less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxGeometryShaderInvocations
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-02596]]
    If pname:stage is a
    <<pipeline-graphics-subsets-pre-rasterization,pre-rasterization shader
    stage>>, and the identified entry point writes to code:Layer for any
    primitive, it must: write the same value to code:Layer for all vertices
    of a given primitive
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-02597]]
    If pname:stage is a
    <<pipeline-graphics-subsets-pre-rasterization,pre-rasterization shader
    stage>>, and the identified entry point writes to code:ViewportIndex for
    any primitive, it must: write the same value to code:ViewportIndex for
    all vertices of a given primitive
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-00718]]
    If pname:stage is ename:VK_SHADER_STAGE_FRAGMENT_BIT, the identified
    entry point must: not include any output variables in its interface
    decorated with code:CullDistance
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-06685]]
    If pname:stage is ename:VK_SHADER_STAGE_FRAGMENT_BIT, and the identified
    entry point writes to code:FragDepth in any execution path, all
    execution paths that are not exclusive to helper invocations must:
    either discard the fragment, or write or initialize the value of
    code:FragDepth
ifdef::VK_EXT_shader_stencil_export[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-06686]]
    If pname:stage is ename:VK_SHADER_STAGE_FRAGMENT_BIT, and the identified
    entry point writes to code:FragStencilRefEXT in any execution path, all
    execution paths that are not exclusive to helper invocations must:
    either discard the fragment, or write or initialize the value of
    code:FragStencilRefEXT
endif::VK_EXT_shader_stencil_export[]
ifdef::VK_NV_mesh_shader[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-02093]]
    If pname:stage is ename:VK_SHADER_STAGE_MESH_BIT_NV, the identified
    entry point must: have an code:OpExecutionMode instruction specifying a
    maximum output vertex count, code:OutputVertices, that is greater than
    `0` and less than or equal to
    sname:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshOutputVertices
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-02094]]
    If pname:stage is ename:VK_SHADER_STAGE_MESH_BIT_NV, the identified
    entry point must: have an code:OpExecutionMode instruction specifying a
    maximum output primitive count, code:OutputPrimitivesNV, that is greater
    than `0` and less than or equal to
    sname:VkPhysicalDeviceMeshShaderPropertiesNV::pname:maxMeshOutputPrimitives
endif::VK_NV_mesh_shader[]
ifdef::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
  * [[VUID-VkPipelineShaderStageCreateInfo-flags-02784]]
    If pname:flags has the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT
    flag set, the <<features-subgroupSizeControl,
    pname:subgroupSizeControl>> feature must: be enabled
  * [[VUID-VkPipelineShaderStageCreateInfo-flags-02785]]
    If pname:flags has the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT flag
    set, the <<features-computeFullSubgroups, pname:computeFullSubgroups>>
    feature must: be enabled
  * [[VUID-VkPipelineShaderStageCreateInfo-pNext-02754]]
    If a slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure
    is included in the pname:pNext chain, pname:flags must: not have the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT
    flag set
  * [[VUID-VkPipelineShaderStageCreateInfo-pNext-02755]]
    If a slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure
    is included in the pname:pNext chain, the
    <<features-subgroupSizeControl, pname:subgroupSizeControl>> feature
    must: be enabled, and pname:stage must: be a valid bit specified in
    <<limits-requiredSubgroupSizeStages, pname:requiredSubgroupSizeStages>>
  * [[VUID-VkPipelineShaderStageCreateInfo-pNext-02756]]
    If a slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure
    is included in the pname:pNext chain and pname:stage is
    ename:VK_SHADER_STAGE_COMPUTE_BIT, the local workgroup size of the
    shader must: be less than or equal to the product of
    slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo::pname:requiredSubgroupSize
    and <<limits-maxComputeWorkgroupSubgroups,
    pname:maxComputeWorkgroupSubgroups>>
  * [[VUID-VkPipelineShaderStageCreateInfo-pNext-02757]]
    If a slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure
    is included in the pname:pNext chain, and pname:flags has the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT flag
    set, the local workgroup size in the X dimension of the pipeline must:
    be a multiple of
    slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo::pname:requiredSubgroupSize
  * [[VUID-VkPipelineShaderStageCreateInfo-flags-02758]]
    If pname:flags has both the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT and
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT
    flags set, the local workgroup size in the X dimension of the pipeline
    must: be a multiple of <<limits-maxSubgroupSize, pname:maxSubgroupSize>>
  * [[VUID-VkPipelineShaderStageCreateInfo-flags-02759]]
    If pname:flags has the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT flag
    set and pname:flags does not have the
    ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT
    flag set and no
    slink:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is
    included in the pname:pNext chain, the local workgroup size in the X
    dimension of the pipeline must: be a multiple of <<limits-subgroup-size,
    pname:subgroupSize>>
endif::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
ifndef::VK_EXT_graphics_pipeline_library+VK_EXT_shader_module_identifier[]
  * [[VUID-VkPipelineShaderStageCreateInfo-module-06716]]
    pname:module must: be a valid slink:VkShaderModule
endif::VK_EXT_graphics_pipeline_library+VK_EXT_shader_module_identifier[]
ifdef::VK_EXT_shader_module_identifier[]
ifdef::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-06844]]
    If a shader module identifier is specified for this pname:stage, a
    slink:VkShaderModuleCreateInfo structure must: not be present in the
    pname:pNext chain
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-06845]]
    If a shader module identifier is not specified for this pname:stage,
    pname:module must: be a valid slink:VkShaderModule or there must: be a
    valid slink:VkShaderModuleCreateInfo structure in the pname:pNext chain
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-06846]]
    If a shader module identifier is not specified for this pname:stage, and
    the <<features-graphicsPipelineLibrary, pname:graphicsPipelineLibrary>>
    feature is not enabled, pname:module must: be a valid
    slink:VkShaderModule
endif::VK_EXT_graphics_pipeline_library[]
ifndef::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-06847]]
    If a shader identifier is not specified for this pname:stage,
    pname:module must: be a valid slink:VkShaderModule
endif::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkPipelineShaderStageCreateInfo-stage-06848]]
    If a shader module identifier is specified for this pname:stage,
    pname:module must: be dlink:VK_NULL_HANDLE
  * [[VUID-VkPipelineShaderStageCreateInfo-pSpecializationInfo-06849]]
    If a shader module identifier is not specified, the shader code used by
    the pipeline must: be valid as described by the <<spirv-spec,Khronos
    SPIR-V Specification>> after applying the specializations provided in
    pname:pSpecializationInfo, if any, and then converting all
    specialization constants into fixed constants
endif::VK_EXT_shader_module_identifier[]
ifndef::VK_EXT_shader_module_identifier[]
ifdef::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkPipelineShaderStageCreateInfo-graphicsPipelineLibrary-06717]]
    If the <<features-graphicsPipelineLibrary,
    pname:graphicsPipelineLibrary>> feature is not enabled, pname:module
    must: be a valid slink:VkShaderModule
  * [[VUID-VkPipelineShaderStageCreateInfo-module-06718]]
    If pname:module is dlink:VK_NULL_HANDLE, there must: be a valid
    slink:VkShaderModuleCreateInfo structure in the pname:pNext chain
endif::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkPipelineShaderStageCreateInfo-pSpecializationInfo-06719]]
    The shader code used by the pipeline must: be valid as described by the
    <<spirv-spec,Khronos SPIR-V Specification>> after applying the
    specializations provided in pname:pSpecializationInfo, if any, and then
    converting all specialization constants into fixed constants
endif::VK_EXT_shader_module_identifier[]
****

include::{generated}/validity/structs/VkPipelineShaderStageCreateInfo.txt[]
--

[open,refpage='VkPipelineShaderStageCreateFlags',desc='Bitmask of VkPipelineShaderStageCreateFlagBits',type='flags']
--
include::{generated}/api/flags/VkPipelineShaderStageCreateFlags.txt[]

tname:VkPipelineShaderStageCreateFlags is a bitmask type for setting a mask
of zero or more elink:VkPipelineShaderStageCreateFlagBits.
--

[open,refpage='VkPipelineShaderStageCreateFlagBits',desc='Bitmask controlling how a pipeline shader stage is created',type='enums']
--
Possible values of the pname:flags member of
slink:VkPipelineShaderStageCreateInfo specifying how a pipeline shader stage
is created, are:

include::{generated}/api/enums/VkPipelineShaderStageCreateFlagBits.txt[]

ifdef::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
  * ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT
    specifies that the
    <<interfaces-builtin-variables-sgs,code:SubgroupSize>> may: vary in the
    shader stage.
  * ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT
    specifies that the subgroup sizes must: be launched with all invocations
    active in the compute stage.

[NOTE]
.Note
====
If ename:VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT
and ename:VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT are
specified and <<limits-minSubgroupSize, pname:minSubgroupSize>> does not
equal <<limits-maxSubgroupSize, pname:maxSubgroupSize>> and no
<<pipelines-required-subgroup-size, required subgroup size>> is specified,
then the only way to guarantee that the 'X' dimension of the local workgroup
size is a multiple of <<interfaces-builtin-variables-sgs,
code:SubgroupSize>> is to make it a multiple of pname:maxSubgroupSize.
Under these conditions, you are guaranteed full subgroups but not any
particular subgroup size.
====

endif::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
--

[open,refpage='VkShaderStageFlagBits',desc='Bitmask specifying a pipeline stage',type='enums']
--
Bits which can: be set by commands and structures, specifying one or more
shader stages, are:

include::{generated}/api/enums/VkShaderStageFlagBits.txt[]

  * ename:VK_SHADER_STAGE_VERTEX_BIT specifies the vertex stage.
  * ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT specifies the
    tessellation control stage.
  * ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT specifies the
    tessellation evaluation stage.
  * ename:VK_SHADER_STAGE_GEOMETRY_BIT specifies the geometry stage.
  * ename:VK_SHADER_STAGE_FRAGMENT_BIT specifies the fragment stage.
  * ename:VK_SHADER_STAGE_COMPUTE_BIT specifies the compute stage.
  * ename:VK_SHADER_STAGE_ALL_GRAPHICS is a combination of bits used as
    shorthand to specify all graphics stages defined above (excluding the
    compute stage).
  * ename:VK_SHADER_STAGE_ALL is a combination of bits used as shorthand to
    specify all shader stages supported by the device, including all
    additional stages which are introduced by extensions.
ifdef::VK_NV_mesh_shader[]
  * ename:VK_SHADER_STAGE_TASK_BIT_NV specifies the task stage.
  * ename:VK_SHADER_STAGE_MESH_BIT_NV specifies the mesh stage.
endif::VK_NV_mesh_shader[]
ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
  * ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR specifies the ray generation stage.
  * ename:VK_SHADER_STAGE_ANY_HIT_BIT_KHR specifies the any-hit stage.
  * ename:VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR specifies the closest hit
    stage.
  * ename:VK_SHADER_STAGE_MISS_BIT_KHR specifies the miss stage.
  * ename:VK_SHADER_STAGE_INTERSECTION_BIT_KHR specifies the intersection
    stage.
  * ename:VK_SHADER_STAGE_CALLABLE_BIT_KHR specifies the callable stage.
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]

[NOTE]
.Note
====
ename:VK_SHADER_STAGE_ALL_GRAPHICS only includes the original five graphics
stages included in Vulkan 1.0, and not any stages added by extensions.
Thus, it may not have the desired effect in all cases.
====
--

[open,refpage='VkShaderStageFlags',desc='Bitmask of VkShaderStageFlagBits',type='flags']
--
include::{generated}/api/flags/VkShaderStageFlags.txt[]

tname:VkShaderStageFlags is a bitmask type for setting a mask of zero or
more elink:VkShaderStageFlagBits.
--

ifdef::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]
[open,refpage='VkPipelineShaderStageRequiredSubgroupSizeCreateInfo',desc='Structure specifying the required subgroup size of a newly created pipeline shader stage',type='structs',alias='VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT']
--
The sname:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is
defined as:

include::{generated}/api/structs/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.txt[]

ifdef::VK_EXT_subgroup_size_control[]
or the equivalent

include::{generated}/api/structs/VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT.txt[]
endif::VK_EXT_subgroup_size_control[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * [[pipelines-required-subgroup-size]] pname:requiredSubgroupSize is an
    unsigned integer value specifying the required subgroup size for the
    newly created pipeline shader stage.

If a sname:VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is
included in the pname:pNext chain of slink:VkPipelineShaderStageCreateInfo,
it specifies that the pipeline shader stage being compiled has a required
subgroup size.

.Valid Usage
****
  * [[VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-requiredSubgroupSize-02760]]
    pname:requiredSubgroupSize must: be a power-of-two integer
  * [[VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-requiredSubgroupSize-02761]]
    pname:requiredSubgroupSize must: be greater or equal to
    <<limits-minSubgroupSize, pname:minSubgroupSize>>
  * [[VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-requiredSubgroupSize-02762]]
    pname:requiredSubgroupSize must: be less than or equal to
    <<limits-maxSubgroupSize, pname:maxSubgroupSize>>
****

include::{generated}/validity/structs/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.txt[]
--
endif::VK_VERSION_1_3,VK_EXT_subgroup_size_control[]

ifdef::VK_HUAWEI_subpass_shading[]
[open,refpage='VkSubpassShadingPipelineCreateInfoHUAWEI',desc='Structure specifying parameters of a newly created subpass shading pipeline',type='structs']
--
A subpass shading pipeline is a compute pipeline which must: be called only
in a subpass of a render pass with work dimensions specified by render area
size.
The subpass shading pipeline shader is a compute shader allowed to access
input attachments specified in the calling subpass.
To create a subpass shading pipeline, call flink:vkCreateComputePipelines
with slink:VkSubpassShadingPipelineCreateInfoHUAWEI in the pname:pNext chain
of slink:VkComputePipelineCreateInfo.

The sname:VkSubpassShadingPipelineCreateInfoHUAWEI structure is defined as:

include::{generated}/api/structs/VkSubpassShadingPipelineCreateInfoHUAWEI.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:renderPass is a handle to a render pass object describing the
    environment in which the pipeline will be used.
    The pipeline must: only be used with a render pass instance compatible
    with the one provided.
    See <<renderpass-compatibility,Render Pass Compatibility>> for more
    information.
  * pname:subpass is the index of the subpass in the render pass where this
    pipeline will be used.

.Valid Usage
****
  * [[VUID-VkSubpassShadingPipelineCreateInfoHUAWEI-subpass-04946]]
    pname:subpass must: be created with
    ename:VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI bind point
****

include::{generated}/validity/structs/VkSubpassShadingPipelineCreateInfoHUAWEI.txt[]
--

[open,refpage='vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI',desc='Query maximum supported subpass shading workgroup size for a give render pass',type='protos']
--
A subpass shading pipeline's workgroup size is a 2D vector with number of
power-of-two in width and height.
The maximum number of width and height is implementation dependent, and may:
vary for different formats and sample counts of attachments in a render
pass.

To query the maximum workgroup size, call:

include::{generated}/api/protos/vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.txt[]

  * pname:device is a handle to a local device object that was used to
    create the given render pass.
  * pname:renderPass is a handle to a render pass object describing the
    environment in which the pipeline will be used.
    The pipeline must: only be used with a render pass instance compatible
    with the one provided.
    See <<renderpass-compatibility,Render Pass Compatibility>> for more
    information.
  * pname:pMaxWorkgroupSize is a pointer to a slink:VkExtent2D structure.

include::{generated}/validity/protos/vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.txt[]
--
endif::VK_HUAWEI_subpass_shading[]

ifdef::VK_EXT_pipeline_robustness[]
[open,refpage='VkPipelineRobustnessCreateInfoEXT',desc='Structure controlling the robustness of a newly created pipeline shader stage',type='structs']
--
The sname:VkPipelineRobustnessCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkPipelineRobustnessCreateInfoEXT.txt[]
  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:storageBuffers sets the behaviour of out of bounds accesses made
    to resources bound as:
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC
  * pname:uniformBuffers describes the behaviour of out of bounds accesses
    made to resources bound as:
  ** ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
  ** ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC
ifdef::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]
  ** ename:VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK
endif::VK_VERSION_1_3,VK_EXT_inline_uniform_block[]
  * pname:vertexInputs describes the behaviour of out of bounds accesses
    made to vertex input attributes
  * pname:images describes the behaviour of out of bounds accesses made to
    resources bound as:
  ** ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
  ** ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE

ifdef::VK_VALVE_mutable_descriptor_type[]
Resources bound as ename:VK_DESCRIPTOR_TYPE_MUTABLE_VALVE will have the
robustness behavior that covers its active descriptor type.
endif::VK_VALVE_mutable_descriptor_type[]

The scope of the effect of sname:VkPipelineRobustnessCreateInfoEXT depends
on which structure's pname:pNext chain it is included in.

ifdef::VK_KHR_ray_tracing_pipeline[]
  * sname:VkGraphicsPipelineCreateInfo, sname:VkComputePipelineCreateInfo,
    sname:VkRayTracingPipelineCreateInfoKHR +
endif::VK_KHR_ray_tracing_pipeline[]
ifndef::VK_KHR_ray_tracing_pipeline[]
  * sname:VkGraphicsPipelineCreateInfo, sname:VkComputePipelineCreateInfo +
endif::VK_KHR_ray_tracing_pipeline[]
    The robustness behavior described by
    sname:VkPipelineRobustnessCreateInfoEXT applies to all accesses through
    this pipeline
  * sname:VkPipelineShaderStageCreateInfo +
    The robustness behavior described by
    sname:VkPipelineRobustnessCreateInfoEXT applies to all accesses
    emanating from the shader code of this shader stage

If sname:VkPipelineRobustnessCreateInfoEXT is specified for both a pipeline
and a pipeline stage, the sname:VkPipelineRobustnessCreateInfoEXT specified
for the pipeline stage will take precedence.

.Valid Usage
****
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06926]]
    If the <<features-pipelineRobustness, pname:pipelineRobustness>> feature
    is not enabled, pname:storageBuffers must: be
    ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06927]]
    If the <<features-pipelineRobustness, pname:pipelineRobustness>> feature
    is not enabled, pname:uniformBuffers must: be
    ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06928]]
    If the <<features-pipelineRobustness, pname:pipelineRobustness>> feature
    is not enabled, pname:vertexInputs must: be
    ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06929]]
    If the <<features-pipelineRobustness, pname:pipelineRobustness>> feature
    is not enabled, pname:images must: be
    ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-robustImageAccess-06930]]
    If the <<features-robustImageAccess, pname:robustImageAccess>> feature
    is not supported, pname:images must: not be
    ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-robustBufferAccess2-06931]]
    If the <<features-robustBufferAccess2, pname:robustBufferAccess2>>
    feature is not supported, pname:storageBuffers must: not be
    ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-robustBufferAccess2-06932]]
    If the <<features-robustBufferAccess2, pname:robustBufferAccess2>>
    feature is not supported, pname:uniformBuffers must: not be
    ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-robustBufferAccess2-06933]]
    If the <<features-robustBufferAccess2, pname:robustBufferAccess2>>
    feature is not supported, pname:vertexInputs must: not be
    ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT
  * [[VUID-VkPipelineRobustnessCreateInfoEXT-robustImageAccess2-06934]]
    If the <<features-robustImageAccess2, pname:robustImageAccess2>> feature
    is not supported, pname:images must: not be
    ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT
****

include::{generated}/validity/structs/VkPipelineRobustnessCreateInfoEXT.txt[]
--

[open,refpage='VkPipelineRobustnessBufferBehaviorEXT',desc='Enum controlling the robustness of buffer accesses in a pipeline stage',type='enums']
--
Possible values of the pname:storageBuffers, pname:uniformBuffers, and
pname:vertexInputs members of slink:VkPipelineRobustnessCreateInfoEXT are:

include::{generated}/api/enums/VkPipelineRobustnessBufferBehaviorEXT.txt[]

  * ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT
    specifies that this pipeline stage follows the robustness behavior of
    the logical device that created this pipeline
  * ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT specifies that
    buffer accesses by this pipeline stage to the relevant resource types
    must: not be out of bounds
  * ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT
    specifies that out of bounds accesses by this pipeline stage to the
    relevant resource types behave as if the <<features-robustBufferAccess,
    pname:robustBufferAccess>> feature is enabled
  * ename:VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT
    specifies that out of bounds accesses by this pipeline stage to the
    relevant resource types behave as if the <<features-robustBufferAccess2,
    pname:robustBufferAccess2>> feature is enabled
--

[open,refpage='VkPipelineRobustnessImageBehaviorEXT',desc='Enum controlling the robustness of image accesses in a pipeline stage',type='enums']
--
Possible values of the pname:images member of
slink:VkPipelineRobustnessCreateInfoEXT are:

include::{generated}/api/enums/VkPipelineRobustnessImageBehaviorEXT.txt[]

  * ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT specifies
    that this pipeline stage follows the robustness behavior of the logical
    device that created this pipeline
  * ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT specifies that
    image accesses by this pipeline stage to the relevant resource types
    must: not be out of bounds
  * ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT
    specifies that out of bounds accesses by this pipeline stage to images
    behave as if the <<features-robustImageAccess, pname:robustImageAccess>>
    feature is enabled
  * ename:VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT
    specifies that out of bounds accesses by this pipeline stage to images
    behave as if the <<features-robustImageAccess2,
    pname:robustImageAccess2>> feature is enabled
--
endif::VK_EXT_pipeline_robustness[]

ifdef::VK_EXT_shader_module_identifier[]
[open,refpage='VkPipelineShaderStageModuleIdentifierCreateInfoEXT',desc='Structure specifying an identifier for a shader module',type='structs']
--
An identifier can: be provided instead of shader code in an attempt to
compile pipelines without providing complete SPIR-V to the implementation.

The sname:VkPipelineShaderStageModuleIdentifierCreateInfoEXT structure is
defined as:

include::{generated}/api/structs/VkPipelineShaderStageModuleIdentifierCreateInfoEXT.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:identifierSize is the size, in bytes, of the buffer pointed to by
    pname:pIdentifier.
  * pname:pIdentifier points to a buffer of opaque data specifying an
    identifier.

Any identifier can: be used.
If the pipeline being created with identifier requires compilation to
complete the pipeline creation call, pipeline compilation must: fail as
defined by ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT.

pname:pIdentifier and pname:identifierSize can: be obtained from an
slink:VkShaderModuleIdentifierEXT queried earlier.

.Valid Usage
****
  * [[VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-pNext-06850]]
    If this structure is included in a pname:pNext chain and
    pname:identifierSize is not equal to 0, the
    <<features-shaderModuleIdentifier, pname:shaderModuleIdentifier>>
    feature must: be enabled
  * [[VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-pNext-06851]]
    If this struct is included in a pname:pNext chain of
    slink:VkPipelineShaderStageCreateInfo and pname:identifierSize is not
    equal to 0, the pipeline must: be created with the
    ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT flag set
  * [[VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-identifierSize-06852]]
    pname:identifierSize must: be less-or-equal to
    ename:VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT
****

include::{generated}/validity/structs/VkPipelineShaderStageModuleIdentifierCreateInfoEXT.txt[]
--

endif::VK_EXT_shader_module_identifier[]

[[pipelines-graphics]]
== Graphics Pipelines

Graphics pipelines consist of multiple shader stages, multiple
fixed-function pipeline stages, and a pipeline layout.

[open,refpage='vkCreateGraphicsPipelines',desc='Create graphics pipelines',type='protos']
--
To create graphics pipelines, call:

include::{generated}/api/protos/vkCreateGraphicsPipelines.txt[]

  * pname:device is the logical device that creates the graphics pipelines.
  * pname:pipelineCache is either dlink:VK_NULL_HANDLE, indicating that
    pipeline caching is disabled; or the handle of a valid
    <<pipelines-cache,pipeline cache>> object, in which case use of that
    cache is enabled for the duration of the command.
  * pname:createInfoCount is the length of the pname:pCreateInfos and
    pname:pPipelines arrays.
  * pname:pCreateInfos is a pointer to an array of
    slink:VkGraphicsPipelineCreateInfo structures.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pPipelines is a pointer to an array of slink:VkPipeline handles in
    which the resulting graphics pipeline objects are returned.

The slink:VkGraphicsPipelineCreateInfo structure includes an array of
slink:VkPipelineShaderStageCreateInfo structures for each of the desired
active shader stages, as well as creation information for all relevant
fixed-function stages, and a pipeline layout.

.Valid Usage
****
  * [[VUID-vkCreateGraphicsPipelines-flags-00720]]
    If the pname:flags member of any element of pname:pCreateInfos contains
    the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the
    pname:basePipelineIndex member of that same element is not `-1`,
    pname:basePipelineIndex must: be less than the index into
    pname:pCreateInfos that corresponds to that element
  * [[VUID-vkCreateGraphicsPipelines-flags-00721]]
    If the pname:flags member of any element of pname:pCreateInfos contains
    the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline
    must: have been created with the
    ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * [[VUID-vkCreateGraphicsPipelines-pipelineCache-02876]]
    If pname:pipelineCache was created with
    ename:VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT, host access
    to pname:pipelineCache must: be
    <<fundamentals-threadingbehavior,externally synchronized>>
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
****

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
[NOTE]
.Note
====
An implicit cache may be provided by the implementation or a layer.
For this reason, it is still valid to set
ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT on
pname:flags for any element of pname:pCreateInfos while passing
dlink:VK_NULL_HANDLE for pname:pipelineCache.
====
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]

include::{generated}/validity/protos/vkCreateGraphicsPipelines.txt[]
--

[open,refpage='VkGraphicsPipelineCreateInfo',desc='Structure specifying parameters of a newly created graphics pipeline',type='structs']
--
The sname:VkGraphicsPipelineCreateInfo structure is defined as:

include::{generated}/api/structs/VkGraphicsPipelineCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkPipelineCreateFlagBits specifying
    how the pipeline will be generated.
  * pname:stageCount is the number of entries in the pname:pStages array.
  * pname:pStages is a pointer to an array of pname:stageCount
    slink:VkPipelineShaderStageCreateInfo structures describing the set of
    the shader stages to be included in the graphics pipeline.
  * pname:pVertexInputState is a pointer to a
    slink:VkPipelineVertexInputStateCreateInfo structure defining vertex
    input state for use with vertex shading.
  * pname:pInputAssemblyState is a pointer to a
    slink:VkPipelineInputAssemblyStateCreateInfo structure which determines
    input assembly behavior for vertex shading, as described in <<drawing,
    Drawing Commands>>.
  * pname:pTessellationState is a pointer to a
    slink:VkPipelineTessellationStateCreateInfo structure defining
    tessellation state used by tessellation shaders.
  * pname:pViewportState is a pointer to a
    slink:VkPipelineViewportStateCreateInfo structure defining viewport
    state used when rasterization is enabled.
  * pname:pRasterizationState is a pointer to a
    slink:VkPipelineRasterizationStateCreateInfo structure defining
    rasterization state.
  * pname:pMultisampleState is a pointer to a
    slink:VkPipelineMultisampleStateCreateInfo structure defining
    multisample state used when rasterization is enabled.
  * pname:pDepthStencilState is a pointer to a
    slink:VkPipelineDepthStencilStateCreateInfo structure defining
    depth/stencil state used when rasterization is enabled for depth or
    stencil attachments accessed during rendering.
  * pname:pColorBlendState is a pointer to a
    slink:VkPipelineColorBlendStateCreateInfo structure defining color blend
    state used when rasterization is enabled for any color attachments
    accessed during rendering.
  * pname:pDynamicState is a pointer to a
    slink:VkPipelineDynamicStateCreateInfo structure defining which
    properties of the pipeline state object are dynamic and can: be changed
    independently of the pipeline state.
    This can: be `NULL`, which means no state in the pipeline is considered
    dynamic.
  * pname:layout is the description of binding locations used by both the
    pipeline and descriptor sets used with the pipeline.
  * pname:renderPass is a handle to a render pass object describing the
    environment in which the pipeline will be used.
    The pipeline must: only be used with a render pass instance compatible
    with the one provided.
    See <<renderpass-compatibility,Render Pass Compatibility>> for more
    information.
  * pname:subpass is the index of the subpass in the render pass where this
    pipeline will be used.
  * pname:basePipelineHandle is a pipeline to derive from.
  * pname:basePipelineIndex is an index into the pname:pCreateInfos
    parameter to use as a pipeline to derive from.

The parameters pname:basePipelineHandle and pname:basePipelineIndex are
described in more detail in <<pipelines-pipeline-derivatives,Pipeline
Derivatives>>.

ifdef::VK_NV_glsl_shader[]
If any shader stage fails to compile,
ifdef::VK_EXT_debug_report[]
the compile log will be reported back to the application, and
endif::VK_EXT_debug_report[]
ename:VK_ERROR_INVALID_SHADER_NV will be generated.
endif::VK_NV_glsl_shader[]

[[pipeline-graphics-subsets]]
The state required for a graphics pipeline is divided into
<<pipeline-graphics-subsets-vertex-input, vertex input state>>,
<<pipeline-graphics-subsets-pre-rasterization,pre-rasterization shader
state>>, <<pipeline-graphics-subsets-fragment-shader,fragment shader
state>>, and <<pipeline-graphics-subsets-fragment-output,fragment output
state>>.

[[pipeline-graphics-subsets-vertex-input]]
Vertex input state is defined by:

  * slink:VkPipelineVertexInputStateCreateInfo
  * slink:VkPipelineInputAssemblyStateCreateInfo

[[pipeline-graphics-subsets-pre-rasterization]]
Pre-rasterization shader state is defined by:

  * slink:VkPipelineShaderStageCreateInfo entries for:
  ** Vertex shaders
  ** Tessellation control shaders
  ** Tessellation evaluation shaders
  ** Geometry shaders
ifdef::VK_NV_mesh_shader[]
  ** Task shaders
  ** Mesh shaders
endif::VK_NV_mesh_shader[]
  * Within the slink:VkPipelineLayout, all descriptor sets with
    pre-rasterization shader bindings if
    `VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT` was specified.
  ** If `VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT` was not
     specified, the full pipeline layout must be specified.
  * slink:VkPipelineViewportStateCreateInfo
  * slink:VkPipelineRasterizationStateCreateInfo
  * slink:VkPipelineTessellationStateCreateInfo
  * slink:VkRenderPass and pname:subpass parameter
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * The pname:viewMask parameter of slink:VkPipelineRenderingCreateInfo
    (formats are ignored)
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_EXT_discard_rectangles[]
  * slink:VkPipelineDiscardRectangleStateCreateInfoEXT
endif::VK_EXT_discard_rectangles[]
ifdef::VK_KHR_fragment_shading_rate[]
  * slink:VkPipelineFragmentShadingRateStateCreateInfoKHR
endif::VK_KHR_fragment_shading_rate[]

[[pipeline-graphics-subsets-fragment-shader]]
Fragment shader state is defined by:

  * A slink:VkPipelineShaderStageCreateInfo entry for the fragment shader
  * Within the slink:VkPipelineLayout, all descriptor sets with fragment
    shader bindings if `VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT`
    was specified.
  ** If `VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT` was not
     specified, the full pipeline layout must be specified.
  * slink:VkPipelineMultisampleStateCreateInfo
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
    if <<primsrast-sampleshading, sample shading>> is enabled or
    pname:renderpass is not dlink:VK_NULL_HANDLE
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * slink:VkPipelineDepthStencilStateCreateInfo
  * slink:VkRenderPass and pname:subpass parameter
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * The pname:viewMask parameter of slink:VkPipelineRenderingCreateInfo
    (formats are ignored)
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_KHR_fragment_shading_rate[]
  * slink:VkPipelineFragmentShadingRateStateCreateInfoKHR
ifdef::VK_NV_fragment_shading_rate_enums[]
  * slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV
endif::VK_NV_fragment_shading_rate_enums[]
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_NV_representative_fragment_test[]
  * slink:VkPipelineRepresentativeFragmentTestStateCreateInfoNV
endif::VK_NV_representative_fragment_test[]
ifdef::VK_KHR_fragment_shading_rate[]
  * Inclusion/omission of the
    ename:VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
    flag
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_EXT_fragment_density_map[]
  * Inclusion/omission of the
    ename:VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
    flag
endif::VK_EXT_fragment_density_map[]

[[pipeline-graphics-subsets-fragment-output]]
Fragment output state is defined by:

  * slink:VkPipelineColorBlendStateCreateInfo
  * slink:VkRenderPass and pname:subpass parameter
  * slink:VkPipelineMultisampleStateCreateInfo
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * slink:VkPipelineRenderingCreateInfo
ifdef::VK_AMD_mixed_attachment_samples[]
  * slink:VkAttachmentSampleCountInfoAMD
endif::VK_AMD_mixed_attachment_samples[]
ifdef::VK_NV_framebuffer_mixed_samples[]
  * slink:VkAttachmentSampleCountInfoNV
endif::VK_NV_framebuffer_mixed_samples[]
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_EXT_attachment_feedback_loop_layout[]
  * Inclusion/omission of the
    ename:VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT and
    ename:VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
    flags
endif::VK_EXT_attachment_feedback_loop_layout[]


[[pipeline-graphics-subsets-complete]]
A complete graphics pipeline always includes
<<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
state>>, with other subsets included depending on that state.
If the <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization
shader state>> includes a vertex shader, then
<<pipeline-graphics-subsets-vertex-input, vertex input state>> is included
in a complete graphics pipeline.
If the value of
slink:VkPipelineRasterizationStateCreateInfo::pname:rasterizerDiscardEnable
in the <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization
shader state>> is ename:VK_FALSE
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
or the ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state is
enabled
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
<<pipeline-graphics-subsets-fragment-shader, fragment shader state>> and
<<pipeline-graphics-subsets-fragment-output, fragment output interface
state>> is included in a complete graphics pipeline.

ifndef::VK_EXT_graphics_pipeline_library[]
Pipelines must: be created with a complete set of pipeline state.
endif::VK_EXT_graphics_pipeline_library[]

ifdef::VK_EXT_graphics_pipeline_library[]
If different subsets are linked together with pipeline layouts created with
ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, the final
effective pipeline layout is effectively the union of the linked pipeline
layouts.
When binding descriptor sets for this pipeline, the pipeline layout used
must: be compatible with this union.
This pipeline layout can: be overridden when linking with
ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT by providing a
slink:VkPipelineLayout that is <<descriptorsets-compatibility,compatible>>
with this union other than
ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, or when linking
without ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT by providing
a slink:VkPipelineLayout that is fully
<<descriptorsets-compatibility,compatible>> with this union.
endif::VK_EXT_graphics_pipeline_library[]

.Valid Usage
****
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-00722]]
    If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineIndex is -1, pname:basePipelineHandle must:
    be a valid handle to a graphics sname:VkPipeline
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-00723]]
    If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineHandle is dlink:VK_NULL_HANDLE,
    pname:basePipelineIndex must: be a valid index into the calling
    command's pname:pCreateInfos parameter
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-00724]]
    If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineIndex is not -1, pname:basePipelineHandle
    must: be dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-00725]]
    If pname:flags contains the ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT
    flag, and pname:basePipelineHandle is not dlink:VK_NULL_HANDLE,
    pname:basePipelineIndex must: be -1
ifndef::VK_NV_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-stage-00727]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> the pname:stage member of one element of pname:pStages must: be
    ename:VK_SHADER_STAGE_VERTEX_BIT
endif::VK_NV_mesh_shader[]
ifdef::VK_NV_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-02095]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> the geometric shader stages provided in pname:pStages must: be
    either from the mesh shading pipeline (pname:stage is
    ename:VK_SHADER_STAGE_TASK_BIT_NV or ename:VK_SHADER_STAGE_MESH_BIT_NV)
    or from the primitive shading pipeline (pname:stage is
    ename:VK_SHADER_STAGE_VERTEX_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, or
    ename:VK_SHADER_STAGE_GEOMETRY_BIT)
  * [[VUID-VkGraphicsPipelineCreateInfo-stage-02096]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> the pname:stage member of one element of pname:pStages must: be
    either ename:VK_SHADER_STAGE_VERTEX_BIT or
    ename:VK_SHADER_STAGE_MESH_BIT_NV
endif::VK_NV_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00729]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and pname:pStages includes a tessellation control shader stage,
    it must: include a tessellation evaluation shader stage
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00730]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and pname:pStages includes a tessellation evaluation shader
    stage, it must: include a tessellation control shader stage
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00731]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and pname:pStages includes a tessellation control shader stage
    and a tessellation evaluation shader stage, pname:pTessellationState
    must: be a valid pointer to a valid
    slink:VkPipelineTessellationStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00732]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and pname:pStages includes tessellation shader stages, the
    shader code of at least one stage must: contain an code:OpExecutionMode
    instruction specifying the type of subdivision in the pipeline
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00733]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and pname:pStages includes tessellation shader stages, and the
    shader code of both stages contain an code:OpExecutionMode instruction
    specifying the type of subdivision in the pipeline, they must: both
    specify the same subdivision mode
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00734]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and pname:pStages includes tessellation shader stages, the
    shader code of at least one stage must: contain an code:OpExecutionMode
    instruction specifying the output patch size in the pipeline
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00735]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and pname:pStages includes tessellation shader stages, and the
    shader code of both contain an code:OpExecutionMode instruction
    specifying the out patch size in the pipeline, they must: both specify
    the same patch size
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00736]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and pname:pStages includes tessellation shader stages, the
    pname:topology member of pname:pInputAssembly must: be
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST
  * [[VUID-VkGraphicsPipelineCreateInfo-topology-00737]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and the pname:topology member of pname:pInputAssembly is
    ename:VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, pname:pStages must: include
    tessellation shader stages
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00738]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and pname:pStages includes a geometry shader stage, and does not
    include any tessellation shader stages, its shader code must: contain an
    code:OpExecutionMode instruction specifying an input primitive type that
    is <<shaders-geometry-execution, compatible>> with the primitive
    topology specified in pname:pInputAssembly
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00739]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and pname:pStages includes a geometry shader stage, and also
    includes tessellation shader stages, its shader code must: contain an
    code:OpExecutionMode instruction specifying an input primitive type that
    is <<shaders-geometry-execution, compatible>> with the primitive
    topology that is output by the tessellation stages
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00740]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>>, it includes both a fragment shader and a geometry shader, and
    the fragment shader code reads from an input variable that is decorated
    with code:PrimitiveId, then the geometry shader code must: write to a
    matching output variable, decorated with code:PrimitiveId, in all
    execution paths
ifdef::VK_NV_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-PrimitiveId-06264]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, it includes a mesh shader and the fragment shader code reads
    from an input variable that is decorated with code:PrimitiveId, then the
    mesh shader code must: write to a matching output variable, decorated
    with code:PrimitiveId, in all execution paths
endif::VK_NV_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06038]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE and the pipeline is
    being created with <<pipeline-graphics-subsets-fragment-shader, fragment
    shader state>> the fragment shader must: not read from any input
    attachment that is defined as ename:VK_ATTACHMENT_UNUSED in
    pname:subpass
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-00742]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and multiple pre-rasterization shader stages are included in
    pname:pStages, the shader code for the entry points identified by those
    pname:pStages and the rest of the state identified by this structure
    must: adhere to the pipeline linking rules described in the
    <<interfaces,Shader Interfaces>> chapter
  * [[VUID-VkGraphicsPipelineCreateInfo-None-04889]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>>, the fragment shader and last
    <<pipeline-graphics-subsets-pre-rasterization,pre-rasterization shader
    stage>> and any relevant state must: adhere to the pipeline linking
    rules described in the <<interfaces,Shader Interfaces>> chapter
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06041]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, and the pipeline is
    being created with <<pipeline-graphics-subsets-fragment-output, fragment
    output interface state>>, then for each color attachment in the subpass,
    if the <<potential-format-features,potential format features>> of the
    format of the corresponding attachment description do not contain
    ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the
    pname:blendEnable member of the corresponding element of the
    pname:pAttachments member of pname:pColorBlendState must: be
    ename:VK_FALSE
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06042]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, and the pipeline is
    being created with <<pipeline-graphics-subsets-fragment-output, fragment
    output interface state>>, and the subpass uses color attachments, the
    pname:attachmentCount member of pname:pColorBlendState must: be equal to
    the pname:colorAttachmentCount used to create pname:subpass
ifndef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00747]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and no element of the pname:pDynamicStates member of
    pname:pDynamicState is ename:VK_DYNAMIC_STATE_VIEWPORT, the
    pname:pViewports member of pname:pViewportState must: be a valid pointer
    to an array of pname:pViewportState->viewportCount valid
    sname:VkViewport structures
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00748]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and no element of the pname:pDynamicStates member of
    pname:pDynamicState is ename:VK_DYNAMIC_STATE_SCISSOR, the
    pname:pScissors member of pname:pViewportState must: be a valid pointer
    to an array of pname:pViewportState->scissorCount sname:VkRect2D
    structures
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04130]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and no element of the pname:pDynamicStates member of
    pname:pDynamicState is ename:VK_DYNAMIC_STATE_VIEWPORT or
    ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT, the pname:pViewports member
    of pname:pViewportState must: be a valid pointer to an array of
    pname:pViewportState->viewportCount valid sname:VkViewport structures
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04131]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and no element of the pname:pDynamicStates member of
    pname:pDynamicState is ename:VK_DYNAMIC_STATE_SCISSOR or
    ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT, the pname:pScissors member of
    pname:pViewportState must: be a valid pointer to an array of
    pname:pViewportState->scissorCount sname:VkRect2D structures
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00749]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and the <<features-wideLines, pname:wideLines>> feature is not
    enabled, and no element of the pname:pDynamicStates member of
    pname:pDynamicState is ename:VK_DYNAMIC_STATE_LINE_WIDTH, the
    pname:lineWidth member of pname:pRasterizationState must: be `1.0`
  * [[VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00750]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and the pname:rasterizerDiscardEnable member of
    pname:pRasterizationState is ename:VK_FALSE, pname:pViewportState must:
    be a valid pointer to a valid slink:VkPipelineViewportStateCreateInfo
    structure
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pViewportState-04892]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and the graphics pipeline state was created with the
    ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled,
    pname:pViewportState must: be a valid pointer to a valid
    slink:VkPipelineViewportStateCreateInfo structure
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
  * [[VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00751]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:pMultisampleState must: be a valid pointer to a valid
    slink:VkPipelineMultisampleStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06043]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipeline-graphics-subsets-fragment-shader, fragment
    shader state>>, and pname:subpass uses a depth/stencil attachment,
    pname:pDepthStencilState must: be a valid pointer to a valid
    slink:VkPipelineDepthStencilStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06044]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipeline-graphics-subsets-fragment-output, fragment
    output interface state>>, and pname:subpass uses color attachments,
    pname:pColorBlendState must: be a valid pointer to a valid
    slink:VkPipelineColorBlendStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00754]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, the <<features-depthBiasClamp, pname:depthBiasClamp>> feature
    is not enabled, no element of the pname:pDynamicStates member of
    pname:pDynamicState is ename:VK_DYNAMIC_STATE_DEPTH_BIAS, and the
    pname:depthBiasEnable member of pname:pRasterizationState is
    ename:VK_TRUE, the pname:depthBiasClamp member of
    pname:pRasterizationState must: be `0.0`
ifndef::VK_EXT_depth_range_unrestricted[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00755]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>,
    and no element of the pname:pDynamicStates member of pname:pDynamicState
    is ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the
    pname:depthBoundsTestEnable member of pname:pDepthStencilState is
    ename:VK_TRUE, the pname:minDepthBounds and pname:maxDepthBounds members
    of pname:pDepthStencilState must: be between `0.0` and `1.0`, inclusive
endif::VK_EXT_depth_range_unrestricted[]
ifdef::VK_EXT_depth_range_unrestricted[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-02510]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>,
    and the `apiext:VK_EXT_depth_range_unrestricted` extension is not
    enabled and no element of the pname:pDynamicStates member of
    pname:pDynamicState is ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the
    pname:depthBoundsTestEnable member of pname:pDepthStencilState is
    ename:VK_TRUE, the pname:minDepthBounds and pname:maxDepthBounds members
    of pname:pDepthStencilState must: be between `0.0` and `1.0`, inclusive
endif::VK_EXT_depth_range_unrestricted[]
ifdef::VK_EXT_sample_locations[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01521]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> or
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, and no element of the pname:pDynamicStates member of
    pname:pDynamicState is ename:VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and
    the pname:sampleLocationsEnable member of a
    slink:VkPipelineSampleLocationsStateCreateInfoEXT structure included in
    the pname:pNext chain of pname:pMultisampleState is ename:VK_TRUE,
    pname:sampleLocationsInfo.sampleLocationGridSize.width must: evenly
    divide
    slink:VkMultisamplePropertiesEXT::pname:sampleLocationGridSize.width as
    returned by flink:vkGetPhysicalDeviceMultisamplePropertiesEXT with a
    pname:samples parameter equaling pname:rasterizationSamples
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01522]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> or
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, and no element of the pname:pDynamicStates member of
    pname:pDynamicState is ename:VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and
    the pname:sampleLocationsEnable member of a
    slink:VkPipelineSampleLocationsStateCreateInfoEXT structure included in
    the pname:pNext chain of pname:pMultisampleState is ename:VK_TRUE,
    pname:sampleLocationsInfo.sampleLocationGridSize.height must: evenly
    divide
    slink:VkMultisamplePropertiesEXT::pname:sampleLocationGridSize.height as
    returned by flink:vkGetPhysicalDeviceMultisamplePropertiesEXT with a
    pname:samples parameter equaling pname:rasterizationSamples
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01523]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> or
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, and no element of the pname:pDynamicStates member of
    pname:pDynamicState is ename:VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and
    the pname:sampleLocationsEnable member of a
    slink:VkPipelineSampleLocationsStateCreateInfoEXT structure included in
    the pname:pNext chain of pname:pMultisampleState is ename:VK_TRUE,
    pname:sampleLocationsInfo.sampleLocationsPerPixel must: equal
    pname:rasterizationSamples
  * [[VUID-VkGraphicsPipelineCreateInfo-sampleLocationsEnable-01524]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>,
    and the pname:sampleLocationsEnable member of a
    slink:VkPipelineSampleLocationsStateCreateInfoEXT structure included in
    the pname:pNext chain of pname:pMultisampleState is ename:VK_TRUE, the
    fragment shader code must: not statically use the extended instruction
    code:InterpolateAtSample
endif::VK_EXT_sample_locations[]
  * [[VUID-VkGraphicsPipelineCreateInfo-layout-00756]]
    pname:layout must: be
    <<descriptorsets-pipelinelayout-consistency,consistent>> with all
    shaders specified in pname:pStages
  * [[VUID-VkGraphicsPipelineCreateInfo-multisampledRenderToSingleSampled-06853]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, and none of the `apiext:VK_AMD_mixed_attachment_samples`
    extension, the `apiext:VK_NV_framebuffer_mixed_samples` extension, or
    the <<features-multisampledRenderToSingleSampled,
    pname:multisampledRenderToSingleSampled>> feature are enabled, and if
    pname:subpass uses color and/or depth/stencil attachments, then the
    pname:rasterizationSamples member of pname:pMultisampleState must: be
    the same as the sample count for those subpass attachments
ifdef::VK_AMD_mixed_attachment_samples[]
  * [[VUID-VkGraphicsPipelineCreateInfo-subpass-01505]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, and the `apiext:VK_AMD_mixed_attachment_samples` extension is
    enabled, and if pname:subpass uses color and/or depth/stencil
    attachments, then the pname:rasterizationSamples member of
    pname:pMultisampleState must: equal the maximum of the sample counts of
    those subpass attachments
endif::VK_AMD_mixed_attachment_samples[]
ifdef::VK_EXT_multisampled_render_to_single_sampled[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06854]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, the
    `apiext:VK_EXT_multisampled_render_to_single_sampled` extension is
    enabled, and pname:subpass has a
    slink:VkMultisampledRenderToSingleSampledInfoEXT structure included in
    the slink:VkSubpassDescription2::pname:pNext chain with
    pname:multisampledRenderToSingleSampledEnable equal to ename:VK_TRUE,
    then the pname:rasterizationSamples member of pname:pMultisampleState
    must: be equal to
    slink:VkMultisampledRenderToSingleSampledInfoEXT::pname:rasterizationSamples.
endif::VK_EXT_multisampled_render_to_single_sampled[]
ifdef::VK_NV_framebuffer_mixed_samples[]
  * [[VUID-VkGraphicsPipelineCreateInfo-subpass-01411]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, and the `apiext:VK_NV_framebuffer_mixed_samples` extension is
    enabled, and if pname:subpass has a depth/stencil attachment and depth
    test, stencil test, or depth bounds test are enabled, then the
    pname:rasterizationSamples member of pname:pMultisampleState must: be
    the same as the sample count of the depth/stencil attachment
  * [[VUID-VkGraphicsPipelineCreateInfo-subpass-01412]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, and the `apiext:VK_NV_framebuffer_mixed_samples` extension is
    enabled, and if pname:subpass has any color attachments, then the
    pname:rasterizationSamples member of pname:pMultisampleState must: be
    greater than or equal to the sample count for those subpass attachments
endif::VK_NV_framebuffer_mixed_samples[]
ifdef::VK_NV_coverage_reduction_mode[]
  * [[VUID-VkGraphicsPipelineCreateInfo-coverageReductionMode-02722]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, and the `apiext:VK_NV_coverage_reduction_mode` extension is
    enabled, the coverage reduction mode specified by
    slink:VkPipelineCoverageReductionStateCreateInfoNV::pname:coverageReductionMode,
    the pname:rasterizationSamples member of pname:pMultisampleState and the
    sample counts for the color and depth/stencil attachments (if the
    subpass has them) must: be a valid combination returned by
    fname:vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV
endif::VK_NV_coverage_reduction_mode[]
  * [[VUID-VkGraphicsPipelineCreateInfo-subpass-00758]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, and pname:subpass does not use any color and/or depth/stencil
    attachments, then the pname:rasterizationSamples member of
    pname:pMultisampleState must: follow the rules for a
    <<renderpass-noattachments, zero-attachment subpass>>
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06046]]
    If pname:renderPass is a valid renderPass, pname:subpass must: be a
    valid subpass within pname:renderPass
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06047]]
    If pname:renderPass is a valid renderPass, the pipeline is being created
    with <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization
    shader state>>, and the pname:renderPass has multiview enabled and
    pname:subpass has more than one bit set in the view mask and
    pname:multiviewTessellationShader is not enabled, then pname:pStages
    must: not include tessellation shaders
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06048]]
    If pname:renderPass is a valid renderPass, the pipeline is being created
    with <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization
    shader state>>, and the pname:renderPass has multiview enabled and
    pname:subpass has more than one bit set in the view mask and
    pname:multiviewGeometryShader is not enabled, then pname:pStages must:
    not include a geometry shader
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06049]]
    If pname:renderPass is a valid renderPass, the pipeline is being created
    with <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization
    shader state>>, and the pname:renderPass has multiview enabled and
    pname:subpass has more than one bit set in the view mask, shaders in the
    pipeline must: not write to the code:Layer built-in output
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06050]]
    If pname:renderPass is a valid renderPass and the pipeline is being
    created with <<pipeline-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and the pname:renderPass has multiview
    enabled, then all shaders must: not include variables decorated with the
    code:Layer built-in decoration in their interfaces
endif::VK_VERSION_1_1,VK_KHR_multiview[]
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-00764]]
    pname:flags must: not contain the ename:VK_PIPELINE_CREATE_DISPATCH_BASE
    flag
endif::VK_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_VERSION_1_1,VK_KHR_maintenance2,VK_KHR_create_renderpass2[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-01565]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> and
    an input attachment was referenced by an pname:aspectMask at
    pname:renderPass creation time, the fragment shader must: only read from
    the aspects that were specified for that input attachment
endif::VK_VERSION_1_1,VK_KHR_maintenance2,VK_KHR_create_renderpass2[]
  * [[VUID-VkGraphicsPipelineCreateInfo-layout-01688]]
    The number of resources in pname:layout accessible to each shader stage
    that is used by the pipeline must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxPerStageResources
ifdef::VK_NV_clip_space_w_scaling[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01715]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and no element of the pname:pDynamicStates member of
    pname:pDynamicState is ename:VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV, and
    the pname:viewportWScalingEnable member of a
    slink:VkPipelineViewportWScalingStateCreateInfoNV structure, included in
    the pname:pNext chain of pname:pViewportState, is ename:VK_TRUE, the
    pname:pViewportWScalings member of the
    slink:VkPipelineViewportWScalingStateCreateInfoNV must: be a pointer to
    an array of
    slink:VkPipelineViewportWScalingStateCreateInfoNV::pname:viewportCount
    valid slink:VkViewportWScalingNV structures
endif::VK_NV_clip_space_w_scaling[]
ifdef::VK_NV_scissor_exclusive[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04056]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and no element of the pname:pDynamicStates member of
    pname:pDynamicState is ename:VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV, and
    if pname:pViewportState->pNext chain includes a
    slink:VkPipelineViewportExclusiveScissorStateCreateInfoNV structure, and
    if its pname:exclusiveScissorCount member is not `0`, then its
    pname:pExclusiveScissors member must: be a valid pointer to an array of
    pname:exclusiveScissorCount slink:VkRect2D structures
endif::VK_NV_scissor_exclusive[]
ifdef::VK_NV_shading_rate_image[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04057]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and no element of the pname:pDynamicStates member of
    pname:pDynamicState is
    ename:VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV, and if
    pname:pViewportState->pNext chain includes a
    slink:VkPipelineViewportShadingRateImageStateCreateInfoNV structure,
    then its pname:pShadingRatePalettes member must: be a valid pointer to
    an array of pname:viewportCount valid slink:VkShadingRatePaletteNV
    structures
endif::VK_NV_shading_rate_image[]
ifdef::VK_EXT_discard_rectangles[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04058]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and no element of the pname:pDynamicStates member of
    pname:pDynamicState is ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT, and
    if pname:pNext chain includes a
    slink:VkPipelineDiscardRectangleStateCreateInfoEXT structure, and if its
    pname:discardRectangleCount member is not `0`, then its
    pname:pDiscardRectangles member must: be a valid pointer to an array of
    pname:discardRectangleCount slink:VkRect2D structures
endif::VK_EXT_discard_rectangles[]
ifndef::VK_EXT_vertex_input_dynamic_state[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-02097]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-vertex-input, vertex input state>>,
    pname:pVertexInputState must: be a valid pointer to a valid
    slink:VkPipelineVertexInputStateCreateInfo structure
endif::VK_EXT_vertex_input_dynamic_state[]
ifdef::VK_EXT_vertex_input_dynamic_state[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pVertexInputState-04910]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-vertex-input, vertex input state>>, and
    ename:VK_DYNAMIC_STATE_VERTEX_INPUT_EXT is not set,
    pname:pVertexInputState must: be a valid pointer to a valid
    slink:VkPipelineVertexInputStateCreateInfo structure
endif::VK_EXT_vertex_input_dynamic_state[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-02098]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-vertex-input, vertex input state>>,
    pname:pInputAssemblyState must: be a valid pointer to a valid
    slink:VkPipelineInputAssemblyStateCreateInfo structure
ifdef::VK_EXT_transform_feedback[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-02317]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, the code:Xfb execution mode can: be specified by no more than
    one shader stage in pname:pStages
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-02318]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and any shader stage in pname:pStages specifies code:Xfb
    execution mode it must: be the last
    <<pipeline-graphics-subsets-pre-rasterization,pre-rasterization shader
    stage>>
  * [[VUID-VkGraphicsPipelineCreateInfo-rasterizationStream-02319]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and a
    slink:VkPipelineRasterizationStateStreamCreateInfoEXT::pname:rasterizationStream
    value other than zero is specified, all variables in the output
    interface of the entry point being compiled decorated with
    code:Position, code:PointSize, code:ClipDistance, or code:CullDistance
    must: be decorated with identical code:Stream values that match the
    pname:rasterizationStream
  * [[VUID-VkGraphicsPipelineCreateInfo-rasterizationStream-02320]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and
    slink:VkPipelineRasterizationStateStreamCreateInfoEXT::pname:rasterizationStream
    is zero, or not specified, all variables in the output interface of the
    entry point being compiled decorated with code:Position, code:PointSize,
    code:ClipDistance, or code:CullDistance must: be decorated with a
    code:Stream value of zero, or must: not specify the code:Stream
    decoration
  * [[VUID-VkGraphicsPipelineCreateInfo-geometryStreams-02321]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and the last
    <<pipeline-graphics-subsets-pre-rasterization,pre-rasterization shader
    stage>> is a geometry shader, and that geometry shader uses the
    code:GeometryStreams capability, then
    sname:VkPhysicalDeviceTransformFeedbackFeaturesEXT::pname:geometryStreams
    feature must: be enabled
ifdef::VK_NV_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-None-02322]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and there are any mesh shader stages in the pipeline there
    must: not be any shader stage in the pipeline with a code:Xfb execution
    mode
endif::VK_NV_mesh_shader[]
endif::VK_EXT_transform_feedback[]
ifdef::VK_EXT_line_rasterization[]
  * [[VUID-VkGraphicsPipelineCreateInfo-lineRasterizationMode-02766]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and at least one of <<pipeline-graphics-subsets-fragment-output,
    fragment output interface state>> or
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>,
    and pname:pMultisampleState is not `NULL`, the
    pname:lineRasterizationMode member of a
    slink:VkPipelineRasterizationLineStateCreateInfoEXT structure included
    in the pname:pNext chain of pname:pRasterizationState is
    ename:VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT or
    ename:VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the
    pname:alphaToCoverageEnable, pname:alphaToOneEnable, and
    pname:sampleShadingEnable members of pname:pMultisampleState must: all
    be ename:VK_FALSE
  * [[VUID-VkGraphicsPipelineCreateInfo-stippledLineEnable-02767]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, the pname:stippledLineEnable member of
    slink:VkPipelineRasterizationLineStateCreateInfoEXT is ename:VK_TRUE,
    and no element of the pname:pDynamicStates member of pname:pDynamicState
    is ename:VK_DYNAMIC_STATE_LINE_STIPPLE_EXT, then the
    pname:lineStippleFactor member of
    slink:VkPipelineRasterizationLineStateCreateInfoEXT must: be in the
    range [eq]#[1,256]#
endif::VK_EXT_line_rasterization[]
ifdef::VK_KHR_pipeline_library[]
ifndef::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03371]]
    pname:flags must: not include ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
endif::VK_EXT_graphics_pipeline_library[]
endif::VK_KHR_pipeline_library[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03372]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03373]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03374]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03375]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03376]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03377]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-03577]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_ray_tracing_motion_blur[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-04947]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
ifndef::VK_VERSION_1_3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03378]]
    If the <<features-extendedDynamicState, pname:extendedDynamicState>>
    feature is not enabled, there must: be no element of the
    pname:pDynamicStates member of pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_CULL_MODE, ename:VK_DYNAMIC_STATE_FRONT_FACE,
    ename:VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY,
    ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT,
    ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT,
    ename:VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE,
    ename:VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE,
    ename:VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE,
    ename:VK_DYNAMIC_STATE_DEPTH_COMPARE_OP,
    ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE,
    ename:VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE, or
    ename:VK_DYNAMIC_STATE_STENCIL_OP
endif::VK_VERSION_1_3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03379]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is included in
    the pname:pDynamicStates array then pname:viewportCount must: be zero
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03380]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT is included in
    the pname:pDynamicStates array then pname:scissorCount must: be zero
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04132]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is included in
    the pname:pDynamicStates array then ename:VK_DYNAMIC_STATE_VIEWPORT
    must: not be present
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04133]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT is included in
    the pname:pDynamicStates array then ename:VK_DYNAMIC_STATE_SCISSOR must:
    not be present
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
ifndef::VK_VERSION_1_3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04868]]
    If the <<features-extendedDynamicState2, pname:extendedDynamicState2>>
    feature is not enabled, there must: be no element of the
    pname:pDynamicStates member of pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE,
    ename:VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE, or
    ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE
endif::VK_VERSION_1_3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04869]]
    If the <<features-extendedDynamicState2LogicOp,
    pname:extendedDynamicState2LogicOp>> feature is not enabled, there must:
    be no element of the pname:pDynamicStates member of pname:pDynamicState
    set to ename:VK_DYNAMIC_STATE_LOGIC_OP_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04870]]
    If the <<features-extendedDynamicState2PatchControlPoints,
    pname:extendedDynamicState2PatchControlPoints>> feature is not enabled,
    there must: be no element of the pname:pDynamicStates member of
    pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
ifdef::VK_NV_device_generated_commands[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-02877]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV, then the
    <<features-deviceGeneratedCommands, pname:deviceGeneratedCommands>>
    feature must: be enabled
ifdef::VK_EXT_transform_feedback[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-02966]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and pname:flags includes
    ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV, then all stages must:
    not specify code:Xfb execution mode
endif::VK_EXT_transform_feedback[]
endif::VK_NV_device_generated_commands[]
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pipelineCreationCacheControl-02878]]
    If the <<features-pipelineCreationCacheControl,
    pname:pipelineCreationCacheControl>> feature is not enabled, pname:flags
    must: not include
    ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT or
    ename:VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifdef::VK_KHR_fragment_shading_rate[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04494]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> or <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>> and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not
    included in pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.width
    must: be greater than or equal to `1`
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04495]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> or <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>> and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not
    included in pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.height
    must: be greater than or equal to `1`
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04496]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> or <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>> and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not
    included in pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.width
    must: be a power-of-two value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04497]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> or <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>> and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not
    included in pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.height
    must: be a power-of-two value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04498]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> or <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>> and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not
    included in pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.width
    must: be less than or equal to `4`
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04499]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> or <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>> and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not
    included in pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.height
    must: be less than or equal to `4`
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04500]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> or <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>> and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not
    included in pname:pDynamicState->pDynamicStates, and the
    <<features-pipelineFragmentShadingRate,
    pname:pipelineFragmentShadingRate>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.width
    and
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:fragmentSize.height
    must: both be equal to `1`
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06567]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> or <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>> and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not
    included in pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:combinerOps[0]
    must: be a valid elink:VkFragmentShadingRateCombinerOpKHR value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06568]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> or <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>> and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not
    included in pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:combinerOps[1]
    must: be a valid elink:VkFragmentShadingRateCombinerOpKHR value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04501]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> or <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>> and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not
    included in pname:pDynamicState->pDynamicStates, and the
    <<features-primitiveFragmentShadingRate,
    pname:primitiveFragmentShadingRate>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:combinerOps[0]
    must: be ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04502]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> or <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>> and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not
    included in pname:pDynamicState->pDynamicStates, and the
    <<features-attachmentFragmentShadingRate,
    pname:attachmentFragmentShadingRate>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:combinerOps[1]
    must: be ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
  * [[VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04503]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and the
    <<limits-primitiveFragmentShadingRateWithMultipleViewports,
    pname:primitiveFragmentShadingRateWithMultipleViewports>> limit is not
    supported, ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is not included in
    pname:pDynamicState->pDynamicStates, and
    slink:VkPipelineViewportStateCreateInfo::pname:viewportCount is greater
    than `1`, entry points specified in pname:pStages must: not write to the
    code:PrimitiveShadingRateKHR built-in
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
  * [[VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04504]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and the
    <<limits-primitiveFragmentShadingRateWithMultipleViewports,
    pname:primitiveFragmentShadingRateWithMultipleViewports>> limit is not
    supported, and entry points specified in pname:pStages write to the
    code:ViewportIndex built-in, they must: not also write to the
    code:PrimitiveShadingRateKHR built-in
ifdef::VK_NV_viewport_array2[]
  * [[VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04505]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and the
    <<limits-primitiveFragmentShadingRateWithMultipleViewports,
    pname:primitiveFragmentShadingRateWithMultipleViewports>> limit is not
    supported, and entry points specified in pname:pStages write to the
    code:ViewportMaskNV built-in, they must: not also write to the
    code:PrimitiveShadingRateKHR built-in
endif::VK_NV_viewport_array2[]
  * [[VUID-VkGraphicsPipelineCreateInfo-fragmentShadingRateNonTrivialCombinerOps-04506]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> or <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>>, the <<limits-fragmentShadingRateNonTrivialCombinerOps,
    pname:fragmentShadingRateNonTrivialCombinerOps>> limit is not supported,
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, elements of
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR::pname:combinerOps
    must: be ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or
    ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_NV_fragment_shading_rate_enums[]
  * [[VUID-VkGraphicsPipelineCreateInfo-None-06569]]
     If the pipeline is being created with
     <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:shadingRateType
    must: be a valid elink:VkFragmentShadingRateTypeNV value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06570]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:shadingRate
    must: be a valid elink:VkFragmentShadingRateNV value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06571]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:combinerOps[0]
    must: be a valid elink:VkFragmentShadingRateCombinerOpKHR value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06572]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:combinerOps[1]
    must: be a valid elink:VkFragmentShadingRateCombinerOpKHR value
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04569]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, and the
    <<features-fragmentShadingRateEnums, pname:fragmentShadingRateEnums>>
    feature is not enabled,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:shadingRateType
    must: be equal to ename:VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04570]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, and the
    <<features-pipelineFragmentShadingRate,
    pname:pipelineFragmentShadingRate>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:shadingRate
    must: be equal to
    ename:VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04571]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, and the
    <<features-primitiveFragmentShadingRate,
    pname:primitiveFragmentShadingRate>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:combinerOps[0]
    must: be ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04572]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> and
    ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, and the
    <<features-attachmentFragmentShadingRate,
    pname:attachmentFragmentShadingRate>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:combinerOps[1]
    must: be ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-fragmentShadingRateNonTrivialCombinerOps-04573]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>,
    and the <<limits-fragmentShadingRateNonTrivialCombinerOps,
    pname:fragmentShadingRateNonTrivialCombinerOps>> limit is not supported
    and ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in
    pname:pDynamicState->pDynamicStates, elements of
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:combinerOps
    must: be ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or
    ename:VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-None-04574]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>,
    and the <<features-supersampleFragmentShadingRates,
    pname:supersampleFragmentShadingRates>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:shadingRate
    must: not be equal to
    ename:VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV,
    ename:VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV,
    ename:VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV, or
    ename:VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV
  * [[VUID-VkGraphicsPipelineCreateInfo-None-04575]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>,
    and the <<features-noInvocationFragmentShadingRates,
    pname:noInvocationFragmentShadingRates>> feature is not enabled,
    slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV::pname:shadingRate
    must: not be equal to ename:VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV
endif::VK_NV_fragment_shading_rate_enums[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03578]]
    All elements of the pname:pDynamicStates member of pname:pDynamicState
    must: not be ename:VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_EXT_vertex_input_dynamic_state[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04807]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> and the <<features-vertexInputDynamicState,
    pname:vertexInputDynamicState>> feature is not enabled, there must: be
    no element of the pname:pDynamicStates member of pname:pDynamicState set
    to ename:VK_DYNAMIC_STATE_VERTEX_INPUT_EXT
endif::VK_EXT_vertex_input_dynamic_state[]
ifndef::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkGraphicsPipelineCreateInfo-None-06573]]
    The pipeline must: be created with a
    <<pipeline-graphics-subsets-complete, complete set of state>>
endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_EXT_color_write_enable[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04800]]
    If the <<features-colorWriteEnable, pname:colorWriteEnable>> feature is
    not enabled, there must: be no element of the pname:pDynamicStates
    member of pname:pDynamicState set to
    ename:VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT
endif::VK_EXT_color_write_enable[]
ifdef::VK_QCOM_render_pass_shader_resolve[]
  * [[VUID-VkGraphicsPipelineCreateInfo-rasterizationSamples-04899]]
    If the pipeline is being created with fragment shader state, and the
    `apiext:VK_QCOM_render_pass_shader_resolve` extension is enabled, and if
    subpass has any input attachments, and if the subpass description
    contains ename:VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM, then the
    sample count of the input attachments must: equal
    pname:rasterizationSamples
  * [[VUID-VkGraphicsPipelineCreateInfo-sampleShadingEnable-04900]]
    If the pipeline is being created with fragment shader state, and the
    `apiext:VK_QCOM_render_pass_shader_resolve` extension is enabled, and if
    the subpass description contains
    ename:VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM, then
    pname:sampleShadingEnable must: be false
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-04901]]
    If pname:flags includes
    ename:VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM, then the subpass
    must: be the last subpass in a subpass dependency chain
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-04902]]
    If pname:flags includes
    ename:VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM, and if
    pname:pResolveAttachments is not `NULL`, then each resolve attachment
    must: be ename:VK_ATTACHMENT_UNUSED
endif::VK_QCOM_render_pass_shader_resolve[]
ifndef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06574]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>>, or <<pipeline-graphics-subsets-fragment-output, fragment output
    interface state>>, pname:renderPass must: be a valid render pass object
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06575]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>>, or <<pipeline-graphics-subsets-fragment-output, fragment output
    interface state>>, pname:renderPass must: be dlink:VK_NULL_HANDLE or a
    valid render pass object
  * [[VUID-VkGraphicsPipelineCreateInfo-dynamicRendering-06576]]
    If the <<features-dynamicRendering, pname:dynamicRendering>> feature is
    not enabled and the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>>, or <<pipeline-graphics-subsets-fragment-output, fragment output
    interface state>>, pname:renderPass must: not be dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-multiview-06577]]
    If the <<features-multiview, pname:multiview>> feature is not enabled,
    the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>>, or <<pipeline-graphics-subsets-fragment-output, fragment output
    interface state>>, and pname:renderPass is dlink:VK_NULL_HANDLE,
    slink:VkPipelineRenderingCreateInfo::pname:viewMask must: be `0`
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06578]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, <<pipeline-graphics-subsets-fragment-shader, fragment shader
    state>>, or <<pipeline-graphics-subsets-fragment-output, fragment output
    interface state>>, and pname:renderPass is dlink:VK_NULL_HANDLE, the
    index of the most significant bit in
    slink:VkPipelineRenderingCreateInfo::pname:viewMask must: be less than
    <<limits-maxMultiviewViewCount, pname:maxMultiviewViewCount>>
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06579]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, and pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkPipelineRenderingCreateInfo::pname:colorAttachmentCount is not
    0, slink:VkPipelineRenderingCreateInfo::pname:pColorAttachmentFormats
    must: be a valid pointer to an array of pname:colorAttachmentCount valid
    elink:VkFormat values
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06580]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, and pname:renderPass is dlink:VK_NULL_HANDLE, each element of
    slink:VkPipelineRenderingCreateInfo::pname:pColorAttachmentFormats must:
    be a valid elink:VkFormat value
ifndef::VK_NV_linear_color_attachment[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06581]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is dlink:VK_NULL_HANDLE, and any element of
    slink:VkPipelineRenderingCreateInfo::pname:pColorAttachmentFormats is
    not ename:VK_FORMAT_UNDEFINED, that format must: be a format with
    <<potential-format-features, potential format features>> that include
    ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT
endif::VK_NV_linear_color_attachment[]
ifdef::VK_NV_linear_color_attachment[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06582]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is dlink:VK_NULL_HANDLE, and any element of
    slink:VkPipelineRenderingCreateInfo::pname:pColorAttachmentFormats is
    not ename:VK_FORMAT_UNDEFINED, that format must: be a format with
    <<potential-format-features, potential format features>> that include
    ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or
    ename:VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV
endif::VK_NV_linear_color_attachment[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06583]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, and pname:renderPass is dlink:VK_NULL_HANDLE,
    slink:VkPipelineRenderingCreateInfo::pname:depthAttachmentFormat must:
    be a valid elink:VkFormat value
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06584]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, and pname:renderPass is dlink:VK_NULL_HANDLE,
    slink:VkPipelineRenderingCreateInfo::pname:stencilAttachmentFormat must:
    be a valid elink:VkFormat value
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06585]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkPipelineRenderingCreateInfo::pname:depthAttachmentFormat is not
    ename:VK_FORMAT_UNDEFINED, it must: be a format with
    <<potential-format-features, potential format features>> that include
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06586]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkPipelineRenderingCreateInfo::pname:stencilAttachmentFormat is
    not ename:VK_FORMAT_UNDEFINED, it must: be a format with
    <<potential-format-features, potential format features>> that include
    ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06587]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkPipelineRenderingCreateInfo::pname:depthAttachmentFormat is not
    ename:VK_FORMAT_UNDEFINED, it must: be a format that includes a depth
    aspect
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06588]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is dlink:VK_NULL_HANDLE, and
    slink:VkPipelineRenderingCreateInfo::pname:stencilAttachmentFormat is
    not ename:VK_FORMAT_UNDEFINED, it must: be a format that includes a
    stencil aspect
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06589]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>>, pname:renderPass is dlink:VK_NULL_HANDLE,
    slink:VkPipelineRenderingCreateInfo::pname:depthAttachmentFormat is not
    ename:VK_FORMAT_UNDEFINED, and
    slink:VkPipelineRenderingCreateInfo::pname:stencilAttachmentFormat is
    not ename:VK_FORMAT_UNDEFINED, pname:depthAttachmentFormat must: equal
    pname:stencilAttachmentFormat
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06053]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipeline-graphics-subsets-fragment-shader, fragment
    shader state>> and <<pipeline-graphics-subsets-fragment-output, fragment
    output interface state>>, and either of
    slink:VkPipelineRenderingCreateInfo::depthAttachmentFormat or
    slink:VkPipelineRenderingCreateInfo::stencilAttachmentFormat are not
    ename:VK_FORMAT_UNDEFINED, pname:pDepthStencilState must: be a valid
    pointer to a valid slink:VkPipelineDepthStencilStateCreateInfo structure
ifdef::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06590]]
    If pname:renderPass is dlink:VK_NULL_HANDLE and the pipeline is being
    created with <<pipeline-graphics-subsets-fragment-shader, fragment
    shader state>> but not <<pipeline-graphics-subsets-fragment-output,
    fragment output interface state>>, pname:pDepthStencilState must: be a
    valid pointer to a valid slink:VkPipelineDepthStencilStateCreateInfo
    structure
endif::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06054]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipeline-graphics-subsets-fragment-output, fragment
    output interface state>>, and
    slink:VkPipelineRenderingCreateInfo::colorAttachmentCount is not equal
    to `0`, pname:pColorBlendState must: be a valid pointer to a valid
    slink:VkPipelineColorBlendStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06055]]
    If pname:renderPass is dlink:VK_NULL_HANDLE and the pipeline is being
    created with <<pipeline-graphics-subsets-fragment-output, fragment
    output interface state>>, pname:pColorBlendState->attachmentCount must:
    be equal to slink:VkPipelineRenderingCreateInfo::colorAttachmentCount
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06056]]
    If pname:renderPass is dlink:VK_NULL_HANDLE and the pipeline is being
    created with <<pipeline-graphics-subsets-fragment-shader, fragment
    shader state>> the fragment shader must: not read from any input
    attachment
ifdef::VK_KHR_multiview,VK_VERSION_1_1[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06057]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipeline-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, the pname:viewMask member of a
    slink:VkPipelineRenderingCreateInfo structure included in the
    pname:pNext chain is not `0`, and the <<features-multiview-tess,
    pname:multiviewTessellationShader>> feature is not enabled, then
    pname:pStages must: not include tessellation shaders
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06058]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipeline-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, the pname:viewMask member of a
    slink:VkPipelineRenderingCreateInfo structure included in the
    pname:pNext chain is not `0`, and the <<features-multiview-gs,
    pname:multiviewGeometryShader>> feature is not enabled, then
    pname:pStages must: not include a geometry shader
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06059]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipeline-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>, and the pname:viewMask member of a
    slink:VkPipelineRenderingCreateInfo structure included in the
    pname:pNext chain is not `0`, shaders in pname:pStages must: not include
    variables decorated with the code:Layer built-in decoration in their
    interfaces
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06061]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> and
    pname:renderPass is dlink:VK_NULL_HANDLE, fragment shaders in
    pname:pStages must: not include the code:InputAttachment capability
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06062]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>> and pname:renderPass is dlink:VK_NULL_HANDLE, for each color
    attachment format defined by the pname:pColorAttachmentFormats member of
    slink:VkPipelineRenderingCreateInfo, if its
    <<potential-format-features,potential format features>> do not contain
    ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the
    pname:blendEnable member of the corresponding element of the
    pname:pAttachments member of pname:pColorBlendState must: be
    ename:VK_FALSE
endif::VK_KHR_multiview,VK_VERSION_1_1[]
ifdef::VK_AMD_mixed_attachment_samples,VK_NV_framebuffer_mixed_samples[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06063]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>> and pname:renderPass is dlink:VK_NULL_HANDLE, if the pname:pNext
    chain includes slink:VkAttachmentSampleCountInfoAMD or
    sname:VkAttachmentSampleCountInfoNV, the pname:colorAttachmentCount
    member of that structure must: be equal to the value of
    slink:VkPipelineRenderingCreateInfo::pname:colorAttachmentCount
endif::VK_AMD_mixed_attachment_samples,VK_NV_framebuffer_mixed_samples[]
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_ARM_rasterization_order_attachment_access[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06591]]
    If pname:pStages includes a fragment shader stage, and the fragment
    shader declares the code:EarlyFragmentTests execution mode, the
    pname:flags member of slink:VkPipelineDepthStencilStateCreateInfo must:
    not include
    ename:VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM
    or
    ename:VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06482]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>> and the pname:flags member of
    slink:VkPipelineColorBlendStateCreateInfo includes
    ename:VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM,
    pname:renderpass must: not be dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06483]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>> and the pname:flags member of
    slink:VkPipelineDepthStencilStateCreateInfo includes
    ename:VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM
    or
    ename:VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM,
    pname:renderpass must: not be dlink:VK_NULL_HANDLE
ifdef::VK_AMD_mixed_attachment_samples,VK_NV_framebuffer_mixed_samples[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pColorAttachmentSamples-06592]]
    If the <<pipeline-graphics-subsets-fragment-output, fragment output
    interface state>>, elements of the pname:pColorAttachmentSamples member
    of slink:VkAttachmentSampleCountInfoAMD or
    slink:VkAttachmentSampleCountInfoNV must: be valid
    elink:VkSampleCountFlagBits values
  * [[VUID-VkGraphicsPipelineCreateInfo-depthStencilAttachmentSamples-06593]]
    If the <<pipeline-graphics-subsets-fragment-output, fragment output
    interface state>> and the pname:depthStencilAttachmentSamples member of
    slink:VkAttachmentSampleCountInfoAMD or
    slink:VkAttachmentSampleCountInfoNV is not 0, it must: be a valid
    elink:VkSampleCountFlagBits value
endif::VK_AMD_mixed_attachment_samples,VK_NV_framebuffer_mixed_samples[]
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06484]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>> and the pname:flags member of
    slink:VkPipelineColorBlendStateCreateInfo includes
    ename:VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM
    pname:subpass must: have been created with
    ename:VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06485]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>> and the pname:flags member of
    slink:VkPipelineDepthStencilStateCreateInfo includes
    ename:VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM,
    pname:subpass must: have been created with
    ename:VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06486]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-output, fragment output interface
    state>> and the pname:flags member of
    slink:VkPipelineDepthStencilStateCreateInfo includes
    ename:VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM,
    pname:subpass must: have been created with
    ename:VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM
endif::VK_ARM_rasterization_order_attachment_access[]
ifdef::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pipelineStageCreationFeedbackCount-06594]]
    If
    slink:VkPipelineCreationFeedbackCreateInfo::pname:pipelineStageCreationFeedbackCount
    is not `0`, it must: be equal to pname:stageCount
endif::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
ifdef::VK_NVX_multiview_per_view_attributes[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06595]]
    If pname:renderPass is dlink:VK_NULL_HANDLE, the pipeline is being
    created with <<pipeline-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>> or
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>,
    and
    slink:VkMultiviewPerViewAttributesInfoNVX::pname:perViewAttributesPositionXOnly
    is ename:VK_TRUE then
    slink:VkMultiviewPerViewAttributesInfoNVX::pname:perViewAttributes must:
    also be ename:VK_TRUE
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06596]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes the other flag, the value of
    slink:VkMultiviewPerViewAttributesInfoNVX::pname:perViewAttributes
    specified in both this pipeline and the library must: be equal
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06597]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, the value of
    slink:VkMultiviewPerViewAttributesInfoNVX::pname:perViewAttributes
    specified in both libraries must: be equal
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06598]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes the other flag, the value of
    slink:VkMultiviewPerViewAttributesInfoNVX::pname:perViewAttributesPositionXOnly
    specified in both this pipeline and the library must: be equal
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06599]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, the value of
    slink:VkMultiviewPerViewAttributesInfoNVX::pname:perViewAttributesPositionXOnly
    specified in both libraries must: be equal
endif::VK_NVX_multiview_per_view_attributes[]
ifndef::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-06600]]
    pname:pStages must: be a valid pointer to an array of pname:stageCount
    valid slink:VkPipelineShaderStageCreateInfo structures
  * [[VUID-VkGraphicsPipelineCreateInfo-pRasterizationState-06601]]
    pname:pRasterizationState must: be a valid pointer to a valid
    slink:VkPipelineRasterizationStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-layout-06602]]
    pname:layout must: be a valid slink:VkPipelineLayout handle
  * [[VUID-VkGraphicsPipelineCreateInfo-renderPass-06603]]
    If pname:renderPass is not dlink:VK_NULL_HANDLE, pname:renderPass must:
    be a valid slink:VkRenderPass handle
  * [[VUID-VkGraphicsPipelineCreateInfo-stageCount-06604]]
    pname:stageCount must: be greater than `0`
ifdef::VK_NV_device_generated_commands[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pNext-06605]]
    If the pname:pNext chain includes an instance of
    slink:VkGraphicsPipelineShaderGroupsCreateInfoNV, its pname:groupCount
    member must: be greater than `0`
endif::VK_NV_device_generated_commands[]
endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_EXT_graphics_pipeline_library[]
  * [[VUID-VkGraphicsPipelineCreateInfo-graphicsPipelineLibrary-06606]]
    If the <<features-graphicsPipelineLibrary,
    pname:graphicsPipelineLibrary>> feature is not enabled, pname:flags
    must: not include ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-graphicsPipelineLibrary-06607]]
    If the <<features-graphicsPipelineLibrary,
    pname:graphicsPipelineLibrary>> feature is not enabled, the pipeline
    must: be created with a <<pipelines-graphics-subsets-complete, complete
    set of state>>
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06608]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-complete, all possible state subsets>>,
    pname:flags must: not include ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06609]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT, pipeline
    libraries included via slink:VkPipelineLibraryCreateInfoKHR must: have
    been created with
    ename:VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06610]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT,
    pipeline libraries included via slink:VkPipelineLibraryCreateInfoKHR
    must: have been created with
    ename:VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06611]]
    Any pipeline libraries included via
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries must: not include
    any <<pipeline-graphics-subsets, state subset>> already defined by this
    structure or defined by any other pipeline library in
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06612]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes the other flag, and pname:layout was not created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then the
    pname:layout used by this pipeline and the library must: be _identically
    defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06613]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and the
    pname:layout specified by either library was not created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then the
    pname:layout used by each library must: be _identically defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06614]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes the
    other subset, and pname:layout was created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then the
    pname:layout used by the library must: also have been created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06615]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and the
    pname:layout specified by either library was created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then the
    pname:layout used by both libraries must: have been created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06616]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes the
    other subset, and pname:layout was created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, elements of
    the pname:pSetLayouts array which pname:layout was created with that are
    not dlink:VK_NULL_HANDLE must: be _identically defined_ to the element
    at the same index of pname:pSetLayouts used to create the library's
    pname:layout
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06617]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and the
    pname:layout specified by either library was created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, elements of
    the pname:pSetLayouts array which either pname:layout was created with
    that are not dlink:VK_NULL_HANDLE must: be _identically defined_ to the
    element at the same index of pname:pSetLayouts used to create the other
    library's pname:layout
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06618]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes the other flag, any descriptor set layout _N_ specified by
    pname:layout in both this pipeline and the library which include
    bindings accessed by shader stages in each must: be _identically
    defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06619]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, any
    descriptor set layout _N_ specified by pname:layout in both libraries
    which include bindings accessed by shader stages in each must: be
    _identically defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06620]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes the other flag, push constants specified in pname:layout in
    both this pipeline and the library which are available to shader stages
    in each must: be _identically defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06621]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, push
    constants specified in pname:layout in both this pipeline and the
    library which are available to shader stages in each must: be
    _identically defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06679]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes the
    other subset, and any element of the pname:pSetLayouts array which
    pname:layout was created with was dlink:VK_NULL_HANDLE, then the
    corresponding element of the pname:pSetLayouts array used to create the
    library's pname:layout must: not be dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06680]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes the
    other subset, and any element of the pname:pSetLayouts array used to
    create the library's pname:layout was dlink:VK_NULL_HANDLE, then the
    corresponding element of the pname:pSetLayouts array used to create this
    pipeline's pname:layout must: not be dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06681]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and any
    element of the pname:pSetLayouts array used to create each library's
    pname:layout was dlink:VK_NULL_HANDLE, then the corresponding element of
    the pname:pSetLayouts array used to create the other library's
    pname:layout must: not be dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06756]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes the
    other subset, and any element of the pname:pSetLayouts array which
    pname:layout was created with was dlink:VK_NULL_HANDLE, then the
    corresponding element of the pname:pSetLayouts array used to create the
    library's pname:layout must: not have shader bindings for shaders in the
    other subset
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06757]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes the
    other subset, and any element of the pname:pSetLayouts array used to
    create the library's pname:layout was dlink:VK_NULL_HANDLE, then the
    corresponding element of the pname:pSetLayouts array used to create this
    pipeline's pname:layout must: not have shader bindings for shaders in
    the other subset
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06758]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and any
    element of the pname:pSetLayouts array used to create each library's
    pname:layout was dlink:VK_NULL_HANDLE, then the corresponding element of
    the pname:pSetLayouts array used to create the other library's
    pname:layout must: not have shader bindings for shaders in the other
    subset
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06682]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    both
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, pname:layout
    must: have been created with no elements of the pname:pSetLayouts array
    set to dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06683]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    pname:pRasterizationState\->pname:rasterizerDiscardEnable is
    ename:VK_TRUE, pname:layout must: have been created with no elements of
    the pname:pSetLayouts array set to dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06684]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes at
    least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    and an element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes one of the other flags, the value of pname:subpass must: be
    equal to that used to create the library
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06623]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes at least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    and another element of
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes one of
    the other flags, the value of pname:subpass used to create each library
    must: be identical
  * [[VUID-VkGraphicsPipelineCreateInfo-renderpass-06624]]
    If pname:renderpass is not dlink:VK_NULL_HANDLE,
    slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes at
    least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    and an element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes one of the other flags, pname:renderPass must: be compatible
    with that used to create the library
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderpass-06625]]
    If pname:renderpass is dlink:VK_NULL_HANDLE,
    slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes at
    least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    and an element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes one of the other flags, the value of pname:renderPass used to
    create that library must: also be dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06626]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes at
    least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes one of the other flags, and pname:renderPass is
    dlink:VK_NULL_HANDLE, the value of
    slink:VkPipelineRenderingCreateInfo::pname:viewMask used by this
    pipeline and that specified by the library must: be identical
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06627]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes at least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    another element of
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes one of
    the other flags, and pname:renderPass was dlink:VK_NULL_HANDLE for both
    libraries, the value of
    slink:VkPipelineRenderingCreateInfo::pname:viewMask set by each library
    must: be identical
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06628]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes at least one of and no more than two of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    and another element of
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes one of
    the other flags, the pname:renderPass objects used to create each
    library must: be compatible or all equal to dlink:VK_NULL_HANDLE
  * [[VUID-VkGraphicsPipelineCreateInfo-pMultisampleState-06629]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>
    pname:pMultisampleState must: be `NULL` or a valid pointer to a valid
    slink:VkPipelineMultisampleStateCreateInfo structure
ifndef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pMultisampleState-06630]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>
    pname:pMultisampleState must: not be `NULL`
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-renderpass-06631]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> and
    pname:renderpass is not dlink:VK_NULL_HANDLE, then
    pname:pMultisampleState must: not be `NULL`
  * [[VUID-VkGraphicsPipelineCreateInfo-Input-06632]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>
    with a fragment shader that either enables <<primsrast-sampleshading,
    sample shading>> or decorates any variable in the code:Input storage
    class with code:Sample, then pname:pMultisampleState must: not be `NULL`
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06633]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT with a
    pname:pMultisampleState that was not `NULL`, and an element of
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries was created with
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    pname:pMultisampleState must: be _identically defined_ to that used to
    create the library
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06634]]
    If an element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    was created with
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT with a
    pname:pMultisampleState that was not `NULL`, and if
    slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    pname:pMultisampleState must: be _identically defined_ to that used to
    create the library
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06635]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    was created with
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT with a
    pname:pMultisampleState that was not `NULL`, and if a different element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries was created
    with
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    the pname:pMultisampleState used to create each library must: be
    _identically defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06636]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    was created with
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT and
    a value of pname:pMultisampleState->sampleShading equal ename:VK_TRUE,
    and if a different element of
    slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries was created with
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, the
    pname:pMultisampleState used to create each library must: be
    _identically defined_
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06637]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    pname:pMultisampleState->sampleShading is ename:VK_TRUE, and an element
    of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries was created
    with ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, the
    pname:pMultisampleState used to create that library must: be
    _identically defined_ pname:pMultisampleState
ifdef::VK_KHR_fragment_shading_rate[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06638]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    only one of
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an
    element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes the other flag, values specified in
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR for both this
    pipeline and that library must: be identical
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06639]]
    If one element of slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries
    includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and
    another element includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, values
    specified in slink:VkPipelineFragmentShadingRateStateCreateInfoKHR for
    both this pipeline and that library must: be identical
endif::VK_KHR_fragment_shading_rate[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06640]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT,
    pname:pStages must: be a valid pointer to an array of pname:stageCount
    valid slink:VkPipelineShaderStageCreateInfo structures
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06641]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    pname:pRasterizationState must: be a valid pointer to a valid
    slink:VkPipelineRasterizationStateCreateInfo structure
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06642]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, pname:layout
    must: be a valid slink:VkPipelineLayout handle
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06643]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT,
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    and pname:renderPass is not dlink:VK_NULL_HANDLE, pname:renderPass must:
    be a valid slink:VkRenderPass handle
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06644]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags includes
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or
    ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT,
    pname:stageCount must: be greater than `0`
ifdef::VK_KHR_pipeline_executable_properties[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06645]]
    If slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags is
    non-zero, if pname:flags includes
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR, any
    libraries must: have also been created with
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06646]]
    If slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes more
    than one library, and any library was created with
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR, all
    libraries must: have also been created with
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
  * [[VUID-VkGraphicsPipelineCreateInfo-pLibraries-06647]]
    If slink:VkPipelineLibraryCreateInfoKHR::pname:pLibraries includes at
    least one library,
    slink:VkGraphicsPipelineLibraryCreateInfoEXT::pname:flags is non-zero,
    and any library was created with
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR,
    pname:flags must: include
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
endif::VK_KHR_pipeline_executable_properties[]
ifdef::VK_NV_device_generated_commands[]
  * [[VUID-VkGraphicsPipelineCreateInfo-libraryCount-06648]]
    If the pipeline is not created with a
    <<pipelines-graphics-subsets-complete, complete set of state>>, or
    slink:VkPipelineLibraryCreateInfoKHR::pname:libraryCount is not `0`,
    slink:VkGraphicsPipelineShaderGroupsCreateInfoNV::pname:groupCount and
    slink:VkGraphicsPipelineShaderGroupsCreateInfoNV::pname:pipelineCount
    must: be `0`
  * [[VUID-VkGraphicsPipelineCreateInfo-libraryCount-06649]]
    If the pipeline is created with a <<pipelines-graphics-subsets-complete,
    complete set of state>>,
    slink:VkPipelineLibraryCreateInfoKHR::pname:libraryCount is `0`, and the
    pname:pNext chain includes an instance of
    slink:VkGraphicsPipelineShaderGroupsCreateInfoNV,
    slink:VkGraphicsPipelineShaderGroupsCreateInfoNV::pname:groupCount must:
    be greater than `0`
endif::VK_NV_device_generated_commands[]
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06729]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT, the pipeline
    includes a <<pipelines-graphics-subsets-complete, complete set of
    state>> specified entirely by libraries, and each library was created
    with a slink:VkPipelineLayout created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then
    pname:layout must: be a valid slink:VkPipelineLayout that is
    <<descriptorsets-compatibility,compatible>> with the union of the
    libraries' pipeline layouts other than the inclusion/exclusion of
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-flags-06730]]
    If pname:flags does not include
    ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT, the pipeline
    includes a <<pipelines-graphics-subsets-complete, complete set of
    state>> specified entirely by libraries, and each library was created
    with a slink:VkPipelineLayout created with
    ename:VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then
    pname:layout must: be a valid slink:VkPipelineLayout that is
    <<descriptorsets-compatibility, compatible>> with the union of the
    libraries' pipeline layouts
endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_EXT_conservative_rasterization[]
  * [[VUID-VkGraphicsPipelineCreateInfo-conservativePointAndLineRasterization-06759]]
    If <<limits-conservativePointAndLineRasterization,
    pname:conservativePointAndLineRasterization>> is not supported; the
    pipeline is being created with <<pipeline-graphics-subsets-vertex-input,
    vertex input state>> and <<pipeline-graphics-subsets-pre-rasterization,
    pre-rasterization shader state>>; the pipeline does not include a
    geometry shader; and the value of
    slink:VkPipelineInputAssemblyStateCreateInfo::pname:topology is
    ename:VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_LIST, or
    ename:VK_PRIMITIVE_TOPOLOGY_LINE_STRIP, then
    slink:VkPipelineRasterizationConservativeStateCreateInfoEXT::pname:conservativeRasterizationMode
    must: be ename:VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
  * [[VUID-VkGraphicsPipelineCreateInfo-conservativePointAndLineRasterization-06760]]
    If <<limits-conservativePointAndLineRasterization,
    pname:conservativePointAndLineRasterization>> is not supported, the
    pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and the pipeline includes a geometry shader with either the
    code:OutputPoints or code:OutputLineStrip execution modes,
    slink:VkPipelineRasterizationConservativeStateCreateInfoEXT::pname:conservativeRasterizationMode
    must: be ename:VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
ifdef::VK_NV_mesh_shader[]
  * [[VUID-VkGraphicsPipelineCreateInfo-conservativePointAndLineRasterization-06761]]
    If <<limits-conservativePointAndLineRasterization,
    pname:conservativePointAndLineRasterization>> is not supported, the
    pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>, and the pipeline includes a mesh shader with either the
    code:OutputPoints or code:OutputLinesNV execution modes,
    slink:VkPipelineRasterizationConservativeStateCreateInfoEXT::pname:conservativeRasterizationMode
    must: be ename:VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT
endif::VK_NV_mesh_shader[]
endif::VK_EXT_conservative_rasterization[]
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-06894]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>> but not <<pipeline-graphics-subsets-fragment-shader, fragment
    shader state>>, elements of pname:pStages must: not have pname:stage set
    to ename:VK_SHADER_STAGE_FRAGMENT_BIT
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-06895]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> but
    not <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization
    shader state>>, elements of pname:pStages must: not have pname:stage set
    to a shader stage which participates in pre-rasterization
  * [[VUID-VkGraphicsPipelineCreateInfo-pStages-06896]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>
    and/or <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization
    shader state>>, all elements of pname:pStages must: have a pname:stage
    set to a shader stage which participates in
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>> or
    <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization shader
    state>>
  * [[VUID-VkGraphicsPipelineCreateInfo-stage-06897]]
    If the pipeline is being created with
    <<pipeline-graphics-subsets-fragment-shader, fragment shader state>>
    and/or <<pipeline-graphics-subsets-pre-rasterization, pre-rasterization
    shader state>>, any value of pname:stage must: not be set in more than
    one element of pname:pStages
****

include::{generated}/validity/structs/VkGraphicsPipelineCreateInfo.txt[]
--

ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
[open,refpage='VkPipelineRenderingCreateInfo',desc='Structure specifying attachment formats',type='structs',alias='VkPipelineRenderingCreateInfoKHR']
--
The sname:VkPipelineRenderingCreateInfo structure is defined as:

include::{generated}/api/structs/VkPipelineRenderingCreateInfo.txt[]

ifdef::VK_KHR_dynamic_rendering[]
or the equivalent

include::{generated}/api/structs/VkPipelineRenderingCreateInfoKHR.txt[]
endif::VK_KHR_dynamic_rendering[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:viewMask is the viewMask used for rendering.
  * pname:colorAttachmentCount is the number of entries in
    pname:pColorAttachmentFormats
  * pname:pColorAttachmentFormats is a pointer to an array of elink:VkFormat
    values defining the format of color attachments used in this pipeline.
  * pname:depthAttachmentFormat is a elink:VkFormat value defining the
    format of the depth attachment used in this pipeline.
  * pname:stencilAttachmentFormat is a elink:VkFormat value defining the
    format of the stencil attachment used in this pipeline.

When a pipeline is created without a slink:VkRenderPass, if this structure
is present in the pname:pNext chain of slink:VkGraphicsPipelineCreateInfo,
it specifies the view mask and format of attachments used for rendering.
If this structure is not specified, and the pipeline does not include a
slink:VkRenderPass, pname:viewMask and pname:colorAttachmentCount are `0`,
and pname:depthAttachmentFormat and pname:stencilAttachmentFormat are
ename:VK_FORMAT_UNDEFINED.
If a graphics pipeline is created with a valid slink:VkRenderPass,
parameters of this structure are ignored.

If pname:depthAttachmentFormat, pname:stencilAttachmentFormat, or any
element of pname:pColorAttachmentFormats is ename:VK_FORMAT_UNDEFINED, it
indicates that the corresponding attachment is unused within the render
pass.
Valid formats indicate that an attachment can: be used - but it is still
valid to set the attachment to `NULL` when beginning rendering.

include::{generated}/validity/structs/VkPipelineRenderingCreateInfo.txt[]
--
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]

[open,refpage='VkPipelineCreateFlagBits',desc='Bitmask controlling how a pipeline is created',type='enums']
--
Bits which can: be set in

  * slink:VkGraphicsPipelineCreateInfo::pname:flags
  * slink:VkComputePipelineCreateInfo::pname:flags
ifdef::VK_KHR_ray_tracing_pipeline[]
  * slink:VkRayTracingPipelineCreateInfoKHR::pname:flags
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_ray_tracing[]
  * slink:VkRayTracingPipelineCreateInfoNV::pname:flags
endif::VK_NV_ray_tracing[]

specify how a pipeline is created, and are:

include::{generated}/api/enums/VkPipelineCreateFlagBits.txt[]

  * ename:VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT specifies that the
    created pipeline will not be optimized.
    Using this flag may: reduce the time taken to create the pipeline.
  * ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT specifies that the
    pipeline to be created is allowed to be the parent of a pipeline that
    will be created in a subsequent pipeline creation call.
  * ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT specifies that the pipeline to
    be created will be a child of a previously created parent pipeline.
ifdef::VK_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * ename:VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT specifies that
    any shader input variables decorated as code:ViewIndex will be assigned
    values as if they were decorated as code:DeviceIndex.
endif::VK_VERSION_1_1,VK_KHR_multiview[]
  * ename:VK_PIPELINE_CREATE_DISPATCH_BASE specifies that a compute pipeline
    can: be used with flink:vkCmdDispatchBase with a non-zero base
    workgroup.
endif::VK_VERSION_1_1,VK_KHR_device_group[]
ifdef::VK_NV_ray_tracing[]
  * ename:VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV specifies that a pipeline
    is created with all shaders in the deferred state.
    Before using the pipeline the application must: call
    flink:vkCompileDeferredNV exactly once on each shader in the pipeline
    before using the pipeline.
endif::VK_NV_ray_tracing[]
ifdef::VK_KHR_pipeline_executable_properties[]
  * ename:VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR specifies that the
    shader compiler should capture statistics for the pipeline executables
    produced by the compile process which can: later be retrieved by calling
    flink:vkGetPipelineExecutableStatisticsKHR.
    Enabling this flag must: not affect the final compiled pipeline but may:
    disable pipeline caching or otherwise affect pipeline creation time.
  * ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
    specifies that the shader compiler should capture the internal
    representations of pipeline executables produced by the compile process
    which can: later be retrieved by calling
    flink:vkGetPipelineExecutableInternalRepresentationsKHR.
    Enabling this flag must: not affect the final compiled pipeline but may:
    disable pipeline caching or otherwise affect pipeline creation time.
ifdef::VK_KHR_pipeline_library[]
    When capturing IR from pipelines created with pipeline libraries, there
    is no guarantee that IR from libraries can: be retrieved from the linked
    pipeline.
    Applications should: retrieve IR from each library, and any linked
    pipelines, separately.
endif::VK_KHR_pipeline_library[]
endif::VK_KHR_pipeline_executable_properties[]
ifdef::VK_KHR_pipeline_library[]
  * ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR specifies that the pipeline
    cannot: be used directly, and instead defines a _pipeline library_ that
    can: be combined with other pipelines using the
    slink:VkPipelineLibraryCreateInfoKHR structure.
ifdef::VK_KHR_ray_tracing_pipeline,VK_EXT_graphics_pipeline_library[]
    This is available in
ifdef::VK_KHR_ray_tracing_pipeline[ray tracing]
ifdef::VK_KHR_ray_tracing_pipeline+VK_EXT_graphics_pipeline_library[and]
ifdef::VK_EXT_graphics_pipeline_library[graphics]
    pipelines.
endif::VK_KHR_ray_tracing_pipeline,VK_EXT_graphics_pipeline_library[]
endif::VK_KHR_pipeline_library[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR
    specifies that an any-hit shader will always be present when an any-hit
    shader would be executed.
    A NULL any-hit shader is an any-hit shader which is effectively
    ename:VK_SHADER_UNUSED_KHR, such as from a shader group consisting
    entirely of zeros.
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
    specifies that a closest hit shader will always be present when a
    closest hit shader would be executed.
    A NULL closest hit shader is a closest hit shader which is effectively
    ename:VK_SHADER_UNUSED_KHR, such as from a shader group consisting
    entirely of zeros.
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
    specifies that a miss shader will always be present when a miss shader
    would be executed.
    A NULL miss shader is a miss shader which is effectively
    ename:VK_SHADER_UNUSED_KHR, such as from a shader group consisting
    entirely of zeros.
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
    specifies that an intersection shader will always be present when an
    intersection shader would be executed.
    A NULL intersection shader is an intersection shader which is
    effectively ename:VK_SHADER_UNUSED_KHR, such as from a shader group
    consisting entirely of zeros.
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR specifies
    that triangle primitives will be skipped during traversal using
    code:OpTraceRayKHR.
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR specifies that
    AABB primitives will be skipped during traversal using
    code:OpTraceRayKHR.
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
    specifies that the shader group handles can: be saved and reused on a
    subsequent run (e.g. for trace capture and replay).
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_device_generated_commands[]
  * ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV specifies that the
    pipeline can be used in combination with <<device-generated-commands>>.
endif::VK_NV_device_generated_commands[]
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT specifies
    that pipeline creation will fail if a compile is required for creation
    of a valid slink:VkPipeline object; ename:VK_PIPELINE_COMPILE_REQUIRED
    will be returned by pipeline creation, and the slink:VkPipeline will be
    set to dlink:VK_NULL_HANDLE.
  * When creating multiple pipelines,
    ename:VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT specifies that
    control will be returned to the application on failure of the
    corresponding pipeline rather than continuing to create additional
    pipelines.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifdef::VK_NV_ray_tracing_motion_blur[]
  * ename:VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV specifies that
    the pipeline is allowed to use code:OpTraceRayMotionNV.
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_KHR_fragment_shading_rate[]
  * ename:VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
    specifies that the pipeline will be used with a fragment shading rate
    attachment.
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_EXT_fragment_density_map[]
  * ename:VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
    specifies that the pipeline will be used with a fragment density map
    attachment.
endif::VK_EXT_fragment_density_map[]
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_EXT_graphics_pipeline_library[]
  * ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT specifies that
    pipeline libraries being linked into this library should: have link time
    optimizations applied.
    If this bit is omitted, implementations should: instead perform linking
    as rapidly as possible.
  * ename:VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT
    specifies that pipeline libraries should retain any information
    necessary to later perform an optimal link with
    ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT.
endif::VK_EXT_graphics_pipeline_library[]
ifdef::VK_EXT_attachment_feedback_loop_layout[]
  * ename:VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
    specifies that the pipeline may: be used with an attachment feedback
    loop including color attachments.
  * ename:VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
    specifies that the pipeline may: be used with an attachment feedback
    loop including depth-stencil attachments.
endif::VK_EXT_attachment_feedback_loop_layout[]

It is valid to set both ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT and
ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT.
This allows a pipeline to be both a parent and possibly a child in a
pipeline hierarchy.
See <<pipelines-pipeline-derivatives,Pipeline Derivatives>> for more
information.

ifdef::VK_EXT_graphics_pipeline_library[]
When an implementation is looking up a pipeline in a
<<pipelines-cache,pipeline cache>>, if that pipeline is being created using
linked libraries, implementations should: always return an equivalent
pipeline created with
ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT if available,
whether or not that bit was specified.

[NOTE]
.Note
====
Using ename:VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT (or not) when
linking pipeline libraries is intended as a performance tradeoff between
host and device.
If the bit is omitted, linking should be faster and produce a pipeline more
rapidly, but performance of the pipeline on the target device may be
reduced.
If the bit is included, linking may be slower but should produce a pipeline
with device performance comparable to a monolithically created pipeline.
Using both options can allow latency-sensitive applications to generate a
suboptimal but usable pipeline quickly, and then perform an optimal link in
the background, substituting the result for the suboptimally linked pipeline
as soon as it is available.
====
endif::VK_EXT_graphics_pipeline_library[]
--

[open,refpage='VkPipelineCreateFlags',desc='Bitmask of VkPipelineCreateFlagBits',type='flags']
--
include::{generated}/api/flags/VkPipelineCreateFlags.txt[]

tname:VkPipelineCreateFlags is a bitmask type for setting a mask of zero or
more elink:VkPipelineCreateFlagBits.
--

ifdef::VK_EXT_graphics_pipeline_library[]
[open,refpage='VkGraphicsPipelineLibraryCreateInfoEXT',desc='Structure specifying the subsets of the graphics pipeline being compiled',type='structs']
--
The sname:VkGraphicsPipelineLibraryCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkGraphicsPipelineLibraryCreateInfoEXT.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkGraphicsPipelineLibraryFlagBitsEXT
    specifying the subsets of the graphics pipeline that are being compiled.

If a sname:VkGraphicsPipelineLibraryCreateInfoEXT structure is included in
the pname:pNext chain of slink:VkGraphicsPipelineCreateInfo, it specifies
the <<pipeline-graphics-subsets,subsets of the graphics pipeline>> being
created.

If this structure is omitted, and either
slink:VkGraphicsPipelineCreateInfo::pname:flags includes
ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR or the
slink:VkGraphicsPipelineCreateInfo::pname:pNext chain includes a
slink:VkPipelineLibraryCreateInfoKHR structure with a pname:libraryCount
greater than `0`, it is as if pname:flags is `0`.
Otherwise if this structure is omitted, it is as if pname:flags includes all
possible subsets of the graphics pipeline (i.e. a
<<pipeline-graphics-subsets-complete,complete graphics pipeline>>).

include::{generated}/validity/structs/VkGraphicsPipelineLibraryCreateInfoEXT.txt[]
--

[open,refpage='VkGraphicsPipelineLibraryFlagsEXT', desc='Bitmask of VkGraphicsPipelineLibraryFlagBitsEXT', type='flags']
--
include::{generated}/api/flags/VkGraphicsPipelineLibraryFlagsEXT.txt[]

tname:VkGraphicsPipelineLibraryFlagsEXT is a bitmask type for setting a mask
of zero or more elink:VkGraphicsPipelineLibraryFlagBitsEXT.
--

[open,refpage='VkGraphicsPipelineLibraryFlagBitsEXT',desc='Bitmask specifying the subset of a graphics pipeline to compile',type='enums']
--
Possible values of the pname:flags member of
slink:VkGraphicsPipelineLibraryCreateInfoEXT, specifying the subsets of a
graphics pipeline to compile are:

include::{generated}/api/enums/VkGraphicsPipelineLibraryFlagBitsEXT.txt[]

  * ename:VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT
    specifies that a pipeline will include
    <<pipeline-graphics-subsets-vertex-input,vertex input interface state>>.
  * ename:VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT
    specifies that a pipeline will include
    <<pipeline-graphics-subsets-pre-rasterization,pre-rasterization shader
    state>>.
  * ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT specifies
    that a pipeline will include
    <<pipeline-graphics-subsets-fragment-shader,fragment shader state>>.
  * ename:VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT
    specifies that a pipeline will include
    <<pipeline-graphics-subsets-fragment-output,fragment output interface
    state>>.
--
endif::VK_EXT_graphics_pipeline_library[]

[open,refpage='VkPipelineDynamicStateCreateInfo',desc='Structure specifying parameters of a newly created pipeline dynamic state',type='structs']
--
The sname:VkPipelineDynamicStateCreateInfo structure is defined as:

include::{generated}/api/structs/VkPipelineDynamicStateCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is reserved for future use.
  * pname:dynamicStateCount is the number of elements in the
    pname:pDynamicStates array.
  * pname:pDynamicStates is a pointer to an array of elink:VkDynamicState
    values specifying which pieces of pipeline state will use the values
    from dynamic state commands rather than from pipeline state creation
    information.

.Valid Usage
****
  * [[VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-01442]]
    Each element of pname:pDynamicStates must: be unique
****

include::{generated}/validity/structs/VkPipelineDynamicStateCreateInfo.txt[]
--

[open,refpage='VkPipelineDynamicStateCreateFlags',desc='Reserved for future use',type='flags']
--
include::{generated}/api/flags/VkPipelineDynamicStateCreateFlags.txt[]

tname:VkPipelineDynamicStateCreateFlags is a bitmask type for setting a
mask, but is currently reserved for future use.
--

[open,refpage='VkDynamicState',desc='Indicate which dynamic state is taken from dynamic state commands',type='enums']
--
The source of different pieces of dynamic state is specified by the
slink:VkPipelineDynamicStateCreateInfo::pname:pDynamicStates property of the
currently active pipeline, each of whose elements must: be one of the
values:

include::{generated}/api/enums/VkDynamicState.txt[]

  * ename:VK_DYNAMIC_STATE_VIEWPORT specifies that the pname:pViewports
    state in slink:VkPipelineViewportStateCreateInfo will be ignored and
    must: be set dynamically with flink:vkCmdSetViewport before any drawing
    commands.
    The number of viewports used by a pipeline is still specified by the
    pname:viewportCount member of slink:VkPipelineViewportStateCreateInfo.
  * ename:VK_DYNAMIC_STATE_SCISSOR specifies that the pname:pScissors state
    in slink:VkPipelineViewportStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetScissor before any drawing commands.
    The number of scissor rectangles used by a pipeline is still specified
    by the pname:scissorCount member of
    slink:VkPipelineViewportStateCreateInfo.
  * ename:VK_DYNAMIC_STATE_LINE_WIDTH specifies that the pname:lineWidth
    state in slink:VkPipelineRasterizationStateCreateInfo will be ignored
    and must: be set dynamically with flink:vkCmdSetLineWidth before any
    drawing commands that generate line primitives for the rasterizer.
  * ename:VK_DYNAMIC_STATE_DEPTH_BIAS specifies that the
    pname:depthBiasConstantFactor, pname:depthBiasClamp and
    pname:depthBiasSlopeFactor states in
    slink:VkPipelineRasterizationStateCreateInfo will be ignored and must:
    be set dynamically with flink:vkCmdSetDepthBias before any draws are
    performed with pname:depthBiasEnable in
    slink:VkPipelineRasterizationStateCreateInfo set to ename:VK_TRUE.
  * ename:VK_DYNAMIC_STATE_BLEND_CONSTANTS specifies that the
    pname:blendConstants state in slink:VkPipelineColorBlendStateCreateInfo
    will be ignored and must: be set dynamically with
    flink:vkCmdSetBlendConstants before any draws are performed with a
    pipeline state with sname:VkPipelineColorBlendAttachmentState member
    pname:blendEnable set to ename:VK_TRUE and any of the blend functions
    using a constant blend color.
  * ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS specifies that the
    pname:minDepthBounds and pname:maxDepthBounds states of
    slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetDepthBounds before any draws are
    performed with a pipeline state with
    slink:VkPipelineDepthStencilStateCreateInfo member
    pname:depthBoundsTestEnable set to ename:VK_TRUE.
  * ename:VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK specifies that the
    pname:compareMask state in slink:VkPipelineDepthStencilStateCreateInfo
    for both pname:front and pname:back will be ignored and must: be set
    dynamically with flink:vkCmdSetStencilCompareMask before any draws are
    performed with a pipeline state with
    slink:VkPipelineDepthStencilStateCreateInfo member
    pname:stencilTestEnable set to ename:VK_TRUE
  * ename:VK_DYNAMIC_STATE_STENCIL_WRITE_MASK specifies that the
    pname:writeMask state in slink:VkPipelineDepthStencilStateCreateInfo for
    both pname:front and pname:back will be ignored and must: be set
    dynamically with flink:vkCmdSetStencilWriteMask before any draws are
    performed with a pipeline state with
    slink:VkPipelineDepthStencilStateCreateInfo member
    pname:stencilTestEnable set to ename:VK_TRUE
  * ename:VK_DYNAMIC_STATE_STENCIL_REFERENCE specifies that the
    pname:reference state in slink:VkPipelineDepthStencilStateCreateInfo for
    both pname:front and pname:back will be ignored and must: be set
    dynamically with flink:vkCmdSetStencilReference before any draws are
    performed with a pipeline state with
    slink:VkPipelineDepthStencilStateCreateInfo member
    pname:stencilTestEnable set to ename:VK_TRUE
ifdef::VK_NV_clip_space_w_scaling[]
  * ename:VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV specifies that the
    pname:pViewportScalings state in
    slink:VkPipelineViewportWScalingStateCreateInfoNV will be ignored and
    must: be set dynamically with flink:vkCmdSetViewportWScalingNV before
    any draws are performed with a pipeline state with
    slink:VkPipelineViewportWScalingStateCreateInfoNV member
    pname:viewportScalingEnable set to ename:VK_TRUE
endif::VK_NV_clip_space_w_scaling[]
ifdef::VK_EXT_discard_rectangles[]
  * ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT specifies that the
    pname:pDiscardRectangles state in
    slink:VkPipelineDiscardRectangleStateCreateInfoEXT will be ignored and
    must: be set dynamically with flink:vkCmdSetDiscardRectangleEXT before
    any draw or clear commands.
    The elink:VkDiscardRectangleModeEXT and the number of active discard
    rectangles is still specified by the pname:discardRectangleMode and
    pname:discardRectangleCount members of
    slink:VkPipelineDiscardRectangleStateCreateInfoEXT.
endif::VK_EXT_discard_rectangles[]
ifdef::VK_EXT_sample_locations[]
  * ename:VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT specifies that the
    pname:sampleLocationsInfo state in
    slink:VkPipelineSampleLocationsStateCreateInfoEXT will be ignored and
    must: be set dynamically with flink:vkCmdSetSampleLocationsEXT before
    any draw or clear commands.
    Enabling custom sample locations is still indicated by the
    pname:sampleLocationsEnable member of
    slink:VkPipelineSampleLocationsStateCreateInfoEXT.
endif::VK_EXT_sample_locations[]
ifdef::VK_NV_scissor_exclusive[]
  * ename:VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV specifies that the
    pname:pExclusiveScissors state in
    slink:VkPipelineViewportExclusiveScissorStateCreateInfoNV will be
    ignored and must: be set dynamically with
    flink:vkCmdSetExclusiveScissorNV before any drawing commands.
    The number of exclusive scissor rectangles used by a pipeline is still
    specified by the pname:exclusiveScissorCount member of
    slink:VkPipelineViewportExclusiveScissorStateCreateInfoNV.
endif::VK_NV_scissor_exclusive[]
ifdef::VK_NV_shading_rate_image[]
  * ename:VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV specifies that
    the pname:pShadingRatePalettes state in
    slink:VkPipelineViewportShadingRateImageStateCreateInfoNV will be
    ignored and must: be set dynamically with
    flink:vkCmdSetViewportShadingRatePaletteNV before any drawing commands.
  * ename:VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV specifies that
    the coarse sample order state in
    slink:VkPipelineViewportCoarseSampleOrderStateCreateInfoNV will be
    ignored and must: be set dynamically with
    flink:vkCmdSetCoarseSampleOrderNV before any drawing commands.
endif::VK_NV_shading_rate_image[]
ifdef::VK_EXT_line_rasterization[]
  * ename:VK_DYNAMIC_STATE_LINE_STIPPLE_EXT specifies that the
    pname:lineStippleFactor and pname:lineStipplePattern state in
    slink:VkPipelineRasterizationLineStateCreateInfoEXT will be ignored and
    must: be set dynamically with flink:vkCmdSetLineStippleEXT before any
    draws are performed with a pipeline state with
    slink:VkPipelineRasterizationLineStateCreateInfoEXT member
    pname:stippledLineEnable set to ename:VK_TRUE.
endif::VK_EXT_line_rasterization[]
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
  * ename:VK_DYNAMIC_STATE_CULL_MODE specifies that the pname:cullMode state
    in slink:VkPipelineRasterizationStateCreateInfo will be ignored and
    must: be set dynamically with flink:vkCmdSetCullMode before any drawing
    commands.
  * ename:VK_DYNAMIC_STATE_FRONT_FACE specifies that the pname:frontFace
    state in slink:VkPipelineRasterizationStateCreateInfo will be ignored
    and must: be set dynamically with flink:vkCmdSetFrontFace before any
    drawing commands.
  * ename:VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY specifies that the
    pname:topology state in slink:VkPipelineInputAssemblyStateCreateInfo
    only specifies the <<drawing-primitive-topology-class, topology class>>,
    and the specific topology order and adjacency must: be set dynamically
    with flink:vkCmdSetPrimitiveTopology before any drawing commands.
  * ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT specifies that the
    pname:viewportCount and pname:pViewports state in
    slink:VkPipelineViewportStateCreateInfo will be ignored and must: be set
    dynamically with flink:vkCmdSetViewportWithCount before any draw call.
  * ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT specifies that the
    pname:scissorCount and pname:pScissors state in
    slink:VkPipelineViewportStateCreateInfo will be ignored and must: be set
    dynamically with flink:vkCmdSetScissorWithCount before any draw call.
  * ename:VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE specifies that the
    pname:stride state in slink:VkVertexInputBindingDescription will be
    ignored and must: be set dynamically with flink:vkCmdBindVertexBuffers2
    before any draw call.
  * ename:VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE specifies that the
    pname:depthTestEnable state in
    slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetDepthTestEnable before any draw call.
  * ename:VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE specifies that the
    pname:depthWriteEnable state in
    slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetDepthWriteEnable before any draw
    call.
  * ename:VK_DYNAMIC_STATE_DEPTH_COMPARE_OP specifies that the
    pname:depthCompareOp state in
    slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetDepthCompareOp before any draw call.
  * ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE specifies that the
    pname:depthBoundsTestEnable state in
    slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetDepthBoundsTestEnable before any draw
    call.
  * ename:VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE specifies that the
    pname:stencilTestEnable state in
    slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetStencilTestEnable before any draw
    call.
  * ename:VK_DYNAMIC_STATE_STENCIL_OP specifies that the pname:failOp,
    pname:passOp, pname:depthFailOp, and pname:compareOp states in
    sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and
    pname:back will be ignored and must: be set dynamically with
    flink:vkCmdSetStencilOp before any draws are performed with a pipeline
    state with sname:VkPipelineDepthStencilStateCreateInfo member
    pname:stencilTestEnable set to ename:VK_TRUE
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state[]
ifdef::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
  * ename:VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT specifies that the
    pname:patchControlPoints state in
    slink:VkPipelineTessellationStateCreateInfo will be ignored and must: be
    set dynamically with flink:vkCmdSetPatchControlPointsEXT before any
    drawing commands.
  * ename:VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE specifies that the
    pname:rasterizerDiscardEnable state in
    slink:VkPipelineRasterizationStateCreateInfo will be ignored and must:
    be set dynamically with flink:vkCmdSetRasterizerDiscardEnable before any
    drawing commands.
  * ename:VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE specifies that the
    pname:depthBiasEnable state in
    slink:VkPipelineRasterizationStateCreateInfo will be ignored and must:
    be set dynamically with flink:vkCmdSetDepthBiasEnable before any drawing
    commands.
  * ename:VK_DYNAMIC_STATE_LOGIC_OP_EXT specifies that the pname:logicOp
    state in slink:VkPipelineColorBlendStateCreateInfo will be ignored and
    must: be set dynamically with flink:vkCmdSetLogicOpEXT before any
    drawing commands.
  * ename:VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE specifies that the
    pname:primitiveRestartEnable state in
    slink:VkPipelineInputAssemblyStateCreateInfo will be ignored and must:
    be set dynamically with flink:vkCmdSetPrimitiveRestartEnable before any
    drawing commands.
endif::VK_VERSION_1_3,VK_EXT_extended_dynamic_state2[]
ifdef::VK_KHR_fragment_shading_rate[]
  * ename:VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR specifies that state in
    slink:VkPipelineFragmentShadingRateStateCreateInfoKHR
ifdef::VK_NV_fragment_shading_rate_enums[]
    and slink:VkPipelineFragmentShadingRateEnumStateCreateInfoNV
endif::VK_NV_fragment_shading_rate_enums[]
    will be ignored and must: be set dynamically with
    flink:vkCmdSetFragmentShadingRateKHR
ifdef::VK_NV_fragment_shading_rate_enums[]
    or flink:vkCmdSetFragmentShadingRateEnumNV
endif::VK_NV_fragment_shading_rate_enums[]
    before any drawing commands.
endif::VK_KHR_fragment_shading_rate[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * ename:VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR specifies
    that the default stack size computation for the pipeline will be ignored
    and must: be set dynamically with
    flink:vkCmdSetRayTracingPipelineStackSizeKHR before any ray tracing
    calls are performed.
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_EXT_vertex_input_dynamic_state[]
  * ename:VK_DYNAMIC_STATE_VERTEX_INPUT_EXT specifies that the
    pname:pVertexInputState state will be ignored and must: be set
    dynamically with flink:vkCmdSetVertexInputEXT before any drawing
    commands
endif::VK_EXT_vertex_input_dynamic_state[]
ifdef::VK_EXT_color_write_enable[]
  * ename:VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT specifies that the
    pname:pColorWriteEnables state in
    slink:VkPipelineColorWriteCreateInfoEXT will be ignored and must: be set
    dynamically with flink:vkCmdSetColorWriteEnableEXT before any draw call.
endif::VK_EXT_color_write_enable[]
--


ifdef::VK_NV_device_generated_commands[]
[[graphics-shadergroups]]
=== Graphics Pipeline Shader Groups

Graphics pipelines can contain multiple shader groups that can be bound
individually.
Each shader group behaves as if it was a pipeline using the shader group's
state.
When the pipeline is bound by regular means, it behaves as if the state of
group `0` is active, use flink:vkCmdBindPipelineShaderGroupNV to bind an
individual shader group.

The primary purpose of shader groups is allowing the device to bind
different pipeline state using <<device-generated-commands>>.

[open,refpage='VkGraphicsPipelineShaderGroupsCreateInfoNV',desc='Structure specifying parameters of a newly created multi shader group pipeline',type='structs']
--
The sname:VkGraphicsPipelineShaderGroupsCreateInfoNV structure is defined
as:

include::{generated}/api/structs/VkGraphicsPipelineShaderGroupsCreateInfoNV.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:groupCount is the number of elements in the pname:pGroups array.
  * pname:pGroups is a pointer to an array of
    slink:VkGraphicsShaderGroupCreateInfoNV structures specifying which
    state of the original slink:VkGraphicsPipelineCreateInfo each shader
    group overrides.
  * pname:pipelineCount is the number of elements in the pname:pPipelines
    array.
  * pname:pPipelines is a pointer to an array of graphics sname:VkPipeline
    structures which are referenced within the created pipeline, including
    all their shader groups.

When referencing shader groups by index, groups defined in the referenced
pipelines are treated as if they were defined as additional entries in
pname:pGroups.
They are appended in the order they appear in the pname:pPipelines array and
in the pname:pGroups array when those pipelines were defined.

The application must: maintain the lifetime of all such referenced pipelines
based on the pipelines that make use of them.

.Valid Usage
****
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-groupCount-02879]]
    pname:groupCount must: be at least `1` and as maximum
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:maxGraphicsShaderGroupCount
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-groupCount-02880]]
    The sum of pname:groupCount including those groups added from referenced
    pname:pPipelines must: also be as maximum
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:maxGraphicsShaderGroupCount
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02881]]
    The state of the first element of pname:pGroups must: match its
    equivalent within the parent's slink:VkGraphicsPipelineCreateInfo
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02882]]
    Each element of pname:pGroups must: in combination with the rest of the
    pipeline state yield a valid state configuration
ifndef::VK_NV_mesh_shader[]
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02883]]
    All elements of pname:pGroups must: use the same shader stage
    combinations
endif::VK_NV_mesh_shader[]
ifdef::VK_NV_mesh_shader[]
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02884]]
    All elements of pname:pGroups must: use the same shader stage
    combinations unless any mesh shader stage is used, then either
    combination of task and mesh or just mesh shader is valid
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02885]]
    Mesh and regular primitive shading stages cannot be mixed across
    pname:pGroups
endif::VK_NV_mesh_shader[]
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pPipelines-02886]]
    Each element of pname:pPipelines must: have been created with identical
    state to the pipeline currently created except the state that can be
    overridden by slink:VkGraphicsShaderGroupCreateInfoNV
  * [[VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-deviceGeneratedCommands-02887]]
    The <<features-deviceGeneratedCommands, pname:deviceGeneratedCommands>>
    feature must: be enabled
****

include::{generated}/validity/structs/VkGraphicsPipelineShaderGroupsCreateInfoNV.txt[]
--

[open,refpage='VkGraphicsShaderGroupCreateInfoNV',desc='Structure specifying override parameters for each shader group',type='structs']
--
The sname:VkGraphicsShaderGroupCreateInfoNV structure provides the state
overrides for each shader group.
Each shader group behaves like a pipeline that was created from its state as
well as the remaining parent's state.
It is defined as:

include::{generated}/api/structs/VkGraphicsShaderGroupCreateInfoNV.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:stageCount is the number of entries in the pname:pStages array.
  * pname:pStages is a pointer to an array
    slink:VkPipelineShaderStageCreateInfo structures specifying the set of
    the shader stages to be included in this shader group.
  * pname:pVertexInputState is a pointer to a
    slink:VkPipelineVertexInputStateCreateInfo structure.
  * pname:pTessellationState is a pointer to a
    slink:VkPipelineTessellationStateCreateInfo structure, and is ignored if
    the shader group does not include a tessellation control shader stage
    and tessellation evaluation shader stage.

.Valid Usage
****
  * [[VUID-VkGraphicsShaderGroupCreateInfoNV-stageCount-02888]]
    For pname:stageCount, the same restrictions as in
    slink:VkGraphicsPipelineCreateInfo::pname:stageCount apply
  * [[VUID-VkGraphicsShaderGroupCreateInfoNV-pStages-02889]]
    For pname:pStages, the same restrictions as in
    slink:VkGraphicsPipelineCreateInfo::pname:pStages apply
  * [[VUID-VkGraphicsShaderGroupCreateInfoNV-pVertexInputState-02890]]
    For pname:pVertexInputState, the same restrictions as in
    slink:VkGraphicsPipelineCreateInfo::pname:pVertexInputState apply
  * [[VUID-VkGraphicsShaderGroupCreateInfoNV-pTessellationState-02891]]
    For pname:pTessellationState, the same restrictions as in
    slink:VkGraphicsPipelineCreateInfo::pname:pTessellationState apply
****

include::{generated}/validity/structs/VkGraphicsShaderGroupCreateInfoNV.txt[]
--
endif::VK_NV_device_generated_commands[]


ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
[[pipelines-ray-tracing]]
== Ray Tracing Pipelines

Ray tracing pipelines consist of multiple shader stages, fixed-function
traversal stages, and a pipeline layout.

[open,refpage='VK_SHADER_UNUSED_KHR',desc='Sentinel for an unused shader index',type='consts',alias='VK_SHADER_UNUSED_NV']
--
ename:VK_SHADER_UNUSED_KHR is a special shader index used to indicate that a
ray generation, miss, or callable shader member is not used.

include::{generated}/api/enums/VK_SHADER_UNUSED_KHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/enums/VK_SHADER_UNUSED_NV.txt[]
endif::VK_NV_ray_tracing[]
--

ifdef::VK_NV_ray_tracing[]
[open,refpage='vkCreateRayTracingPipelinesNV',desc='Creates a new ray tracing pipeline object',type='protos']
--
:refpage: vkCreateRayTracingPipelinesNV

To create ray tracing pipelines, call:

include::{generated}/api/protos/vkCreateRayTracingPipelinesNV.txt[]

  * pname:device is the logical device that creates the ray tracing
    pipelines.
  * pname:pipelineCache is either dlink:VK_NULL_HANDLE, indicating that
    pipeline caching is disabled, or the handle of a valid
    <<pipelines-cache,pipeline cache>> object, in which case use of that
    cache is enabled for the duration of the command.
  * pname:createInfoCount is the length of the pname:pCreateInfos and
    pname:pPipelines arrays.
  * pname:pCreateInfos is a pointer to an array of
    slink:VkRayTracingPipelineCreateInfoNV structures.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pPipelines is a pointer to an array in which the resulting ray
    tracing pipeline objects are returned.

.Valid Usage
****
include::{chapters}/commonvalidity/create_ray_tracing_pipelines_common.txt[]
****

include::{generated}/validity/protos/vkCreateRayTracingPipelinesNV.txt[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='vkCreateRayTracingPipelinesKHR',desc='Creates a new ray tracing pipeline object',type='protos']
--
:refpage: vkCreateRayTracingPipelinesKHR

To create ray tracing pipelines, call:

include::{generated}/api/protos/vkCreateRayTracingPipelinesKHR.txt[]

  * pname:device is the logical device that creates the ray tracing
    pipelines.
  * pname:deferredOperation is dlink:VK_NULL_HANDLE or the handle of a valid
    slink:VkDeferredOperationKHR <<deferred-host-operations-requesting,
    request deferral>> object for this command.
  * pname:pipelineCache is either dlink:VK_NULL_HANDLE, indicating that
    pipeline caching is disabled, or the handle of a valid
    <<pipelines-cache,pipeline cache>> object, in which case use of that
    cache is enabled for the duration of the command.
  * pname:createInfoCount is the length of the pname:pCreateInfos and
    pname:pPipelines arrays.
  * pname:pCreateInfos is a pointer to an array of
    slink:VkRayTracingPipelineCreateInfoKHR structures.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pPipelines is a pointer to an array in which the resulting ray
    tracing pipeline objects are returned.

The ename:VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS error is returned if the
implementation is unable to re-use the shader group handles provided in
slink:VkRayTracingShaderGroupCreateInfoKHR::pname:pShaderGroupCaptureReplayHandle
when
slink:VkPhysicalDeviceRayTracingPipelineFeaturesKHR::pname:rayTracingPipelineShaderGroupHandleCaptureReplay
is enabled.

.Valid Usage
****
include::{chapters}/commonvalidity/create_ray_tracing_pipelines_common.txt[]
include::{chapters}/commonvalidity/deferred_operations_common.txt[]
  * [[VUID-vkCreateRayTracingPipelinesKHR-rayTracingPipeline-03586]]
    The <<features-rayTracingPipeline, pname:rayTracingPipeline>> feature
    must: be enabled
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifdef::VK_KHR_deferred_host_operations[]
  * [[VUID-vkCreateRayTracingPipelinesKHR-deferredOperation-03587]]
    If pname:deferredOperation is not dlink:VK_NULL_HANDLE, the pname:flags
    member of elements of pname:pCreateInfos must: not include
    ename:VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT
endif::VK_KHR_deferred_host_operations[]
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
****

include::{generated}/validity/protos/vkCreateRayTracingPipelinesKHR.txt[]
--
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_NV_ray_tracing[]
[open,refpage='VkRayTracingPipelineCreateInfoNV',desc='Structure specifying parameters of a newly created ray tracing pipeline',type='structs']
--
:refpage: VkRayTracingPipelineCreateInfoNV

The sname:VkRayTracingPipelineCreateInfoNV structure is defined as:

include::{generated}/api/structs/VkRayTracingPipelineCreateInfoNV.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkPipelineCreateFlagBits specifying
    how the pipeline will be generated.
  * pname:stageCount is the number of entries in the pname:pStages array.
  * pname:pStages is a pointer to an array of
    slink:VkPipelineShaderStageCreateInfo structures specifying the set of
    the shader stages to be included in the ray tracing pipeline.
  * pname:groupCount is the number of entries in the pname:pGroups array.
  * pname:pGroups is a pointer to an array of
    slink:VkRayTracingShaderGroupCreateInfoNV structures describing the set
    of the shader stages to be included in each shader group in the ray
    tracing pipeline.
  * pname:maxRecursionDepth is the <<ray-tracing-recursion-depth, maximum
    recursion depth>> of shaders executed by this pipeline.
  * pname:layout is the description of binding locations used by both the
    pipeline and descriptor sets used with the pipeline.
  * pname:basePipelineHandle is a pipeline to derive from.
  * pname:basePipelineIndex is an index into the pname:pCreateInfos
    parameter to use as a pipeline to derive from.

The parameters pname:basePipelineHandle and pname:basePipelineIndex are
described in more detail in <<pipelines-pipeline-derivatives,Pipeline
Derivatives>>.

.Valid Usage
****
include::{chapters}/commonvalidity/ray_tracing_pipeline_create_info_common.txt[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-stage-06232]]
    The pname:stage member of at least one element of pname:pStages must: be
    ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR
ifdef::VK_KHR_pipeline_library[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03456]]
    pname:flags must: not include ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
endif::VK_KHR_pipeline_library[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-maxRecursionDepth-03457]]
    pname:maxRecursionDepth must: be less than or equal to
    slink:VkPhysicalDeviceRayTracingPropertiesNV::pname:maxRecursionDepth
ifdef::VK_KHR_ray_tracing_pipeline[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03458]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03459]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03460]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03461]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03462]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03463]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-03588]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_NV_ray_tracing_motion_blur[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-04948]]
    pname:flags must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV
endif::VK_NV_ray_tracing_motion_blur[]
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-flags-02957]]
    pname:flags must: not include both
    ename:VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV and
    ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT at the
    same time
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifdef::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-pipelineStageCreationFeedbackCount-06651]]
    If
    slink:VkPipelineCreationFeedbackCreateInfo::pname:pipelineStageCreationFeedbackCount
    is not `0`, it must: be equal to pname:stageCount
endif::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
  * [[VUID-VkRayTracingPipelineCreateInfoNV-stage-06898]]
    The pname:stage value in all pname:pStages elements must: be one of
    ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR,
    ename:VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
    ename:VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
    ename:VK_SHADER_STAGE_MISS_BIT_KHR,
    ename:VK_SHADER_STAGE_INTERSECTION_BIT_KHR, or
    ename:VK_SHADER_STAGE_CALLABLE_BIT_KHR
****

include::{generated}/validity/structs/VkRayTracingPipelineCreateInfoNV.txt[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='VkRayTracingPipelineCreateInfoKHR',desc='Structure specifying parameters of a newly created ray tracing pipeline',type='structs']
--
:refpage: VkRayTracingPipelineCreateInfoKHR

The sname:VkRayTracingPipelineCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkRayTracingPipelineCreateInfoKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of elink:VkPipelineCreateFlagBits specifying
    how the pipeline will be generated.
  * pname:stageCount is the number of entries in the pname:pStages array.
  * pname:pStages is a pointer to an array of pname:stageCount
    slink:VkPipelineShaderStageCreateInfo structures describing the set of
    the shader stages to be included in the ray tracing pipeline.
  * pname:groupCount is the number of entries in the pname:pGroups array.
  * pname:pGroups is a pointer to an array of pname:groupCount
    slink:VkRayTracingShaderGroupCreateInfoKHR structures describing the set
    of the shader stages to be included in each shader group in the ray
    tracing pipeline.
  * pname:maxPipelineRayRecursionDepth is the <<ray-tracing-recursion-depth,
    maximum recursion depth>> of shaders executed by this pipeline.
  * pname:pLibraryInfo is a pointer to a
    slink:VkPipelineLibraryCreateInfoKHR structure defining pipeline
    libraries to include.
  * pname:pLibraryInterface is a pointer to a
    slink:VkRayTracingPipelineInterfaceCreateInfoKHR structure defining
    additional information when using pipeline libraries.
  * pname:pDynamicState is a pointer to a
    slink:VkPipelineDynamicStateCreateInfo structure, and is used to
    indicate which properties of the pipeline state object are dynamic and
    can: be changed independently of the pipeline state.
    This can: be `NULL`, which means no state in the pipeline is considered
    dynamic.
  * pname:layout is the description of binding locations used by both the
    pipeline and descriptor sets used with the pipeline.
  * pname:basePipelineHandle is a pipeline to derive from.
  * pname:basePipelineIndex is an index into the pname:pCreateInfos
    parameter to use as a pipeline to derive from.

The parameters pname:basePipelineHandle and pname:basePipelineIndex are
described in more detail in <<pipelines-pipeline-derivatives,Pipeline
Derivatives>>.

ifdef::VK_KHR_pipeline_library[]
When ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR is specified, this pipeline
defines a _pipeline library_ which cannot: be bound as a ray tracing
pipeline directly.
Instead, pipeline libraries define common shaders and shader groups which
can: be included in future pipeline creation.

If pipeline libraries are included in pname:pLibraryInfo, shaders defined in
those libraries are treated as if they were defined as additional entries in
pname:pStages, appended in the order they appear in the pname:pLibraries
array and in the pname:pStages array when those libraries were defined.

When referencing shader groups in order to obtain a shader group handle,
groups defined in those libraries are treated as if they were defined as
additional entries in pname:pGroups, appended in the order they appear in
the pname:pLibraries array and in the pname:pGroups array when those
libraries were defined.
The shaders these groups reference are set when the pipeline library is
created, referencing those specified in the pipeline library, not in the
pipeline that includes it.
endif::VK_KHR_pipeline_library[]

The default stack size for a pipeline if
ename:VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR is not provided
is computed as described in <<ray-tracing-pipeline-stack, Ray Tracing
Pipeline Stack>>.

.Valid Usage
****
include::{chapters}/commonvalidity/ray_tracing_pipeline_create_info_common.txt[]
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-stage-03425]]
    If pname:flags does not include
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, the pname:stage member of at
    least one element of pname:pStages, including those implicitly added by
    pname:pLibraryInfo, must: be ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-maxPipelineRayRecursionDepth-03589]]
    pname:maxPipelineRayRecursionDepth must: be less than or equal to
    slink:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:maxRayRecursionDepth
ifdef::VK_KHR_pipeline_library[]
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-03465]]
    If pname:flags includes ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR,
    pname:pLibraryInterface must: not be `NULL`
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03590]]
    If pname:pLibraryInfo is not `NULL` and its pname:libraryCount member is
    greater than `0`, its pname:pLibraryInterface member must: not be `NULL`
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pLibraries-03591]]
    Each element of pname:pLibraryInfo->pLibraries must: have been created
    with the value of pname:maxPipelineRayRecursionDepth equal to that in
    this pipeline
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03592]]
    If pname:pLibraryInfo is not `NULL`, each element of its
    pname:pLibraries member must: have been created with a pname:layout that
    is compatible with the pname:layout in this pipeline
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03593]]
    If pname:pLibraryInfo is not `NULL`, each element of its
    pname:pLibraries member must: have been created with values of the
    pname:maxPipelineRayPayloadSize and pname:maxPipelineRayHitAttributeSize
    members of pname:pLibraryInterface equal to those in this pipeline
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-03594]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR,
    each element of pname:pLibraryInfo->pLibraries must: have been created
    with the
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
    bit set
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-04718]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR, each element of
    pname:pLibraryInfo->pLibraries must: have been created with the
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR bit set
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-04719]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR, each
    element of pname:pLibraryInfo->pLibraries must: have been created with
    the ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR bit set
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-04720]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR,
    each element of pname:pLibraryInfo->pLibraries must: have been created
    with the
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR bit
    set
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-04721]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR,
    each element of pname:pLibraryInfo->pLibraries must: have been created
    with the
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
    bit set
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-04722]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR,
    each element of pname:pLibraryInfo->pLibraries must: have been created
    with the
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
    bit set
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-04723]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR, each
    element of pname:pLibraryInfo->pLibraries must: have been created with
    the ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
    bit set
endif::VK_KHR_pipeline_library[]
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03595]]
    If the `apiext:VK_KHR_pipeline_library` extension is not enabled,
    pname:pLibraryInfo and pname:pLibraryInterface must: be `NULL`
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-03470]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR,
    for any element of pname:pGroups with a pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, the
    pname:anyHitShader of that element must: not be
    ename:VK_SHADER_UNUSED_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-03471]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR,
    for any element of pname:pGroups with a pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, the
    pname:closestHitShader of that element must: not be
    ename:VK_SHADER_UNUSED_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-rayTraversalPrimitiveCulling-03596]]
    If the <<features-rayTraversalPrimitiveCulling,
    pname:rayTraversalPrimitiveCulling>> feature is not enabled, pname:flags
    must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-rayTraversalPrimitiveCulling-03597]]
    If the <<features-rayTraversalPrimitiveCulling,
    pname:rayTraversalPrimitiveCulling>> feature is not enabled, pname:flags
    must: not include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-06546]]
    pname:flags must: not include both
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR and
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-flags-03598]]
    If pname:flags includes
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR,
    <<features-rayTracingPipelineShaderGroupHandleCaptureReplay,
    pname:rayTracingPipelineShaderGroupHandleCaptureReplay>> must: be
    enabled
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-rayTracingPipelineShaderGroupHandleCaptureReplay-03599]]
    If
    slink:VkPhysicalDeviceRayTracingPipelineFeaturesKHR::pname:rayTracingPipelineShaderGroupHandleCaptureReplay
    is ename:VK_TRUE and the pname:pShaderGroupCaptureReplayHandle member of
    any element of pname:pGroups is not `NULL`, pname:flags must: include
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03600]]
    If pname:pLibraryInfo is not `NULL` and its pname:libraryCount is `0`,
    pname:stageCount must: not be `0`
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03601]]
    If pname:pLibraryInfo is not `NULL` and its pname:libraryCount is `0`,
    pname:groupCount must: not be `0`
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pDynamicStates-03602]]
    Any element of the pname:pDynamicStates member of pname:pDynamicState
    must: be ename:VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR
ifdef::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-pipelineStageCreationFeedbackCount-06652]]
    If
    slink:VkPipelineCreationFeedbackCreateInfo::pname:pipelineStageCreationFeedbackCount
    is not `0`, it must: be equal to pname:stageCount
endif::VK_EXT_pipeline_creation_feedback,VK_VERSION_1_3[]
  * [[VUID-VkRayTracingPipelineCreateInfoKHR-stage-06899]]
    The pname:stage value in all pname:pStages elements must: be one of
    ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR,
    ename:VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
    ename:VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
    ename:VK_SHADER_STAGE_MISS_BIT_KHR,
    ename:VK_SHADER_STAGE_INTERSECTION_BIT_KHR, or
    ename:VK_SHADER_STAGE_CALLABLE_BIT_KHR
****

include::{generated}/validity/structs/VkRayTracingPipelineCreateInfoKHR.txt[]
--
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_NV_ray_tracing[]
[open,refpage='VkRayTracingShaderGroupCreateInfoNV',desc='Structure specifying shaders in a shader group',type='structs']
--
:refpage: VkRayTracingShaderGroupCreateInfoNV

The sname:VkRayTracingShaderGroupCreateInfoNV structure is defined as:

include::{generated}/api/structs/VkRayTracingShaderGroupCreateInfoNV.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:type is the type of hit group specified in this structure.
  * pname:generalShader is the index of the ray generation, miss, or
    callable shader from
    slink:VkRayTracingPipelineCreateInfoNV::pname:pStages in the group if
    the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV, and
    ename:VK_SHADER_UNUSED_NV otherwise.
  * pname:closestHitShader is the optional index of the closest hit shader
    from slink:VkRayTracingPipelineCreateInfoNV::pname:pStages in the group
    if the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV or
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV, and
    ename:VK_SHADER_UNUSED_NV otherwise.
  * pname:anyHitShader is the optional index of the any-hit shader from
    slink:VkRayTracingPipelineCreateInfoNV::pname:pStages in the group if
    the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV or
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV, and
    ename:VK_SHADER_UNUSED_NV otherwise.
  * pname:intersectionShader is the index of the intersection shader from
    slink:VkRayTracingPipelineCreateInfoNV::pname:pStages in the group if
    the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV, and
    ename:VK_SHADER_UNUSED_NV otherwise.

.Valid Usage
****
  * [[VUID-VkRayTracingShaderGroupCreateInfoNV-type-02413]]
    If pname:type is ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV then
    pname:generalShader must: be a valid index into
    slink:VkRayTracingPipelineCreateInfoNV::pname:pStages referring to a
    shader of ename:VK_SHADER_STAGE_RAYGEN_BIT_NV,
    ename:VK_SHADER_STAGE_MISS_BIT_NV, or
    ename:VK_SHADER_STAGE_CALLABLE_BIT_NV
  * [[VUID-VkRayTracingShaderGroupCreateInfoNV-type-02414]]
    If pname:type is ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV then
    pname:closestHitShader, pname:anyHitShader, and pname:intersectionShader
    must: be ename:VK_SHADER_UNUSED_NV
  * [[VUID-VkRayTracingShaderGroupCreateInfoNV-type-02415]]
    If pname:type is
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV then
    pname:intersectionShader must: be a valid index into
    slink:VkRayTracingPipelineCreateInfoNV::pname:pStages referring to a
    shader of ename:VK_SHADER_STAGE_INTERSECTION_BIT_NV
  * [[VUID-VkRayTracingShaderGroupCreateInfoNV-type-02416]]
    If pname:type is
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV then
    pname:intersectionShader must: be ename:VK_SHADER_UNUSED_NV
  * [[VUID-VkRayTracingShaderGroupCreateInfoNV-closestHitShader-02417]]
    pname:closestHitShader must: be either ename:VK_SHADER_UNUSED_NV or a
    valid index into slink:VkRayTracingPipelineCreateInfoNV::pname:pStages
    referring to a shader of ename:VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV
  * [[VUID-VkRayTracingShaderGroupCreateInfoNV-anyHitShader-02418]]
    pname:anyHitShader must: be either ename:VK_SHADER_UNUSED_NV or a valid
    index into slink:VkRayTracingPipelineCreateInfoNV::pname:pStages
    referring to a shader of ename:VK_SHADER_STAGE_ANY_HIT_BIT_NV
****

include::{generated}/validity/structs/VkRayTracingShaderGroupCreateInfoNV.txt[]
--

endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='VkRayTracingShaderGroupCreateInfoKHR',desc='Structure specifying shaders in a shader group',type='structs']
--
:refpage: VkRayTracingShaderGroupCreateInfoKHR

The sname:VkRayTracingShaderGroupCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkRayTracingShaderGroupCreateInfoKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:type is the type of hit group specified in this structure.
  * pname:generalShader is the index of the ray generation, miss, or
    callable shader from
    slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages in the group if
    the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR, and
    ename:VK_SHADER_UNUSED_KHR otherwise.
  * pname:closestHitShader is the optional index of the closest hit shader
    from slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages in the group
    if the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, and
    ename:VK_SHADER_UNUSED_KHR otherwise.
  * pname:anyHitShader is the optional index of the any-hit shader from
    slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages in the group if
    the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, and
    ename:VK_SHADER_UNUSED_KHR otherwise.
  * pname:intersectionShader is the index of the intersection shader from
    slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages in the group if
    the shader group has pname:type of
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, and
    ename:VK_SHADER_UNUSED_KHR otherwise.
  * pname:pShaderGroupCaptureReplayHandle is `NULL` or a pointer to replay
    information for this shader group.
    Ignored if
    slink:VkPhysicalDeviceRayTracingPipelineFeaturesKHR::pname:rayTracingPipelineShaderGroupHandleCaptureReplay
    is ename:VK_FALSE.

.Valid Usage
****
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03474]]
    If pname:type is ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR then
    pname:generalShader must: be a valid index into
    slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages referring to a
    shader of ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR,
    ename:VK_SHADER_STAGE_MISS_BIT_KHR, or
    ename:VK_SHADER_STAGE_CALLABLE_BIT_KHR
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03475]]
    If pname:type is ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR then
    pname:closestHitShader, pname:anyHitShader, and pname:intersectionShader
    must: be ename:VK_SHADER_UNUSED_KHR
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03476]]
    If pname:type is
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR then
    pname:intersectionShader must: be a valid index into
    slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages referring to a
    shader of ename:VK_SHADER_STAGE_INTERSECTION_BIT_KHR
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03477]]
    If pname:type is
    ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR then
    pname:intersectionShader must: be ename:VK_SHADER_UNUSED_KHR
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-closestHitShader-03478]]
    pname:closestHitShader must: be either ename:VK_SHADER_UNUSED_KHR or a
    valid index into slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages
    referring to a shader of ename:VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-anyHitShader-03479]]
    pname:anyHitShader must: be either ename:VK_SHADER_UNUSED_KHR or a valid
    index into slink:VkRayTracingPipelineCreateInfoKHR::pname:pStages
    referring to a shader of ename:VK_SHADER_STAGE_ANY_HIT_BIT_KHR
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-rayTracingPipelineShaderGroupHandleCaptureReplayMixed-03603]]
    If
    slink:VkPhysicalDeviceRayTracingPipelineFeaturesKHR::pname:rayTracingPipelineShaderGroupHandleCaptureReplayMixed
    is ename:VK_FALSE then pname:pShaderGroupCaptureReplayHandle must: not
    be provided if it has not been provided on a previous call to ray
    tracing pipeline creation
  * [[VUID-VkRayTracingShaderGroupCreateInfoKHR-rayTracingPipelineShaderGroupHandleCaptureReplayMixed-03604]]
    If
    slink:VkPhysicalDeviceRayTracingPipelineFeaturesKHR::pname:rayTracingPipelineShaderGroupHandleCaptureReplayMixed
    is ename:VK_FALSE then the caller must: guarantee that no ray tracing
    pipeline creation commands with pname:pShaderGroupCaptureReplayHandle
    provided execute simultaneously with ray tracing pipeline creation
    commands without pname:pShaderGroupCaptureReplayHandle provided
****

include::{generated}/validity/structs/VkRayTracingShaderGroupCreateInfoKHR.txt[]
--
endif::VK_KHR_ray_tracing_pipeline[]

[open,refpage='VkRayTracingShaderGroupTypeKHR',desc='Shader group types',type='enums',alias='VkRayTracingShaderGroupTypeNV']
--
:refpage: VkRayTracingShaderGroupTypeKHR

Possible values of pname:type in sname:VkRayTracingShaderGroupCreateInfoKHR
are:

include::{generated}/api/enums/VkRayTracingShaderGroupTypeKHR.txt[]

ifdef::VK_NV_ray_tracing[]
or the equivalent

include::{generated}/api/enums/VkRayTracingShaderGroupTypeNV.txt[]
endif::VK_NV_ray_tracing[]

  * ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR indicates a shader
    group with a single ename:VK_SHADER_STAGE_RAYGEN_BIT_KHR,
    ename:VK_SHADER_STAGE_MISS_BIT_KHR, or
    ename:VK_SHADER_STAGE_CALLABLE_BIT_KHR shader in it.
  * ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR specifies
    a shader group that only hits triangles and must: not contain an
    intersection shader, only closest hit and any-hit shaders.
  * ename:VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR
    specifies a shader group that only intersects with custom geometry and
    must: contain an intersection shader and may: contain closest hit and
    any-hit shaders.

[NOTE]
.Note
====
For current group types, the hit group type could be inferred from the
presence or absence of the intersection shader, but we provide the type
explicitly for future hit groups that do not have that property.
====
--

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='VkRayTracingPipelineInterfaceCreateInfoKHR',desc='Structure specifying additional interface information when using libraries',type='structs']
--
:refpage: VkRayTracingPipelineInterfaceCreateInfoKHR

The sname:VkRayTracingPipelineInterfaceCreateInfoKHR structure is defined
as:

include::{generated}/api/structs/VkRayTracingPipelineInterfaceCreateInfoKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:maxPipelineRayPayloadSize is the maximum payload size in bytes
    used by any shader in the pipeline.
  * pname:maxPipelineRayHitAttributeSize is the maximum attribute structure
    size in bytes used by any shader in the pipeline.

pname:maxPipelineRayPayloadSize is calculated as the maximum number of bytes
used by any block declared in the code:RayPayloadKHR or
code:IncomingRayPayloadKHR storage classes.
pname:maxPipelineRayHitAttributeSize is calculated as the maximum number of
bytes used by any block declared in the code:HitAttributeKHR storage class.
As variables in these storage classes do not have explicit offsets, the size
should be calculated as if each variable has a
<<interfaces-alignment-requirements, scalar alignment>> equal to the largest
scalar alignment of any of the block's members.

[NOTE]
.Note
====
There is no explicit upper limit for pname:maxPipelineRayPayloadSize, but in
practice it should be kept as small as possible.
Similar to invocation local memory, it must be allocated for each shader
invocation and for devices which support many simultaneous invocations, this
storage can rapidly be exhausted, resulting in failure.
====

.Valid Usage
****
  * [[VUID-VkRayTracingPipelineInterfaceCreateInfoKHR-maxPipelineRayHitAttributeSize-03605]]
    pname:maxPipelineRayHitAttributeSize must: be less than or equal to
    slink:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:maxRayHitAttributeSize
****

include::{generated}/validity/structs/VkRayTracingPipelineInterfaceCreateInfoKHR.txt[]
--
endif::VK_KHR_ray_tracing_pipeline[]

[open,refpage='vkGetRayTracingShaderGroupHandlesKHR',desc='Query ray tracing pipeline shader group handles',type='protos',alias='vkGetRayTracingShaderGroupHandlesNV']
--
:refpage: vkGetRayTracingShaderGroupHandlesKHR

To query the opaque handles of shaders in the ray tracing pipeline, call:

ifdef::VK_KHR_ray_tracing_pipeline[]
include::{generated}/api/protos/vkGetRayTracingShaderGroupHandlesKHR.txt[]
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_KHR_ray_tracing_pipeline+VK_NV_ray_tracing[or the equivalent command]

ifdef::VK_NV_ray_tracing[]
include::{generated}/api/protos/vkGetRayTracingShaderGroupHandlesNV.txt[]
endif::VK_NV_ray_tracing[]

  * pname:device is the logical device containing the ray tracing pipeline.
  * pname:pipeline is the ray tracing pipeline object containing the
    shaders.
  * pname:firstGroup is the index of the first group to retrieve a handle
    for from the
ifdef::VK_KHR_ray_tracing_pipeline[]
slink:VkRayTracingPipelineCreateInfoKHR::pname:pGroups
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_KHR_ray_tracing_pipeline+VK_NV_ray_tracing[or]
ifdef::VK_NV_ray_tracing[]
slink:VkRayTracingPipelineCreateInfoNV::pname:pGroups
endif::VK_NV_ray_tracing[]
    array.
  * pname:groupCount is the number of shader handles to retrieve.
  * pname:dataSize is the size in bytes of the buffer pointed to by
    pname:pData.
  * pname:pData is a pointer to a user-allocated buffer where the results
    will be written.

.Valid Usage
****
  * [[VUID-vkGetRayTracingShaderGroupHandlesKHR-pipeline-04619]]
    pname:pipeline must: be a ray tracing pipeline
  * [[VUID-vkGetRayTracingShaderGroupHandlesKHR-firstGroup-04050]]
    pname:firstGroup must: be less than the number of shader groups in
    pname:pipeline
  * [[VUID-vkGetRayTracingShaderGroupHandlesKHR-firstGroup-02419]]
    The sum of pname:firstGroup and pname:groupCount must: be less than or
    equal to the number of shader groups in pname:pipeline
  * [[VUID-vkGetRayTracingShaderGroupHandlesKHR-dataSize-02420]]
    pname:dataSize must: be at least
    [eq]#slink:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:shaderGroupHandleSize
    {times} pname:groupCount#
ifdef::VK_KHR_pipeline_library[]
  * [[VUID-vkGetRayTracingShaderGroupHandlesKHR-pipeline-03482]]
    pname:pipeline must: not have been created with
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
endif::VK_KHR_pipeline_library[]
****

include::{generated}/validity/protos/vkGetRayTracingShaderGroupHandlesKHR.txt[]
--

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='vkGetRayTracingCaptureReplayShaderGroupHandlesKHR',desc='Query ray tracing capture replay pipeline shader group handles',type='protos']
--
:refpage: vkGetRayTracingCaptureReplayShaderGroupHandlesKHR

To query the optional capture handle information of shaders in the ray
tracing pipeline, call:

include::{generated}/api/protos/vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.txt[]

  * pname:device is the logical device containing the ray tracing pipeline.
  * pname:pipeline is the ray tracing pipeline object containing the
    shaders.
  * pname:firstGroup is the index of the first group to retrieve a handle
    for from the slink:VkRayTracingPipelineCreateInfoKHR::pname:pGroups
    array.
  * pname:groupCount is the number of shader handles to retrieve.
  * pname:dataSize is the size in bytes of the buffer pointed to by
    pname:pData.
  * pname:pData is a pointer to a user-allocated buffer where the results
    will be written.

.Valid Usage
****
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-04620]]
    pname:pipeline must: be a ray tracing pipeline
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-firstGroup-04051]]
    pname:firstGroup must: be less than the number of shader groups in
    pname:pipeline
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-firstGroup-03483]]
    The sum of pname:firstGroup and pname:groupCount must: be less than or
    equal to the number of shader groups in pname:pipeline
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-dataSize-03484]]
    pname:dataSize must: be at least
    [eq]#slink:VkPhysicalDeviceRayTracingPipelinePropertiesKHR::pname:shaderGroupHandleCaptureReplaySize
    {times} pname:groupCount#
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-rayTracingPipelineShaderGroupHandleCaptureReplay-03606]]
    sname:VkPhysicalDeviceRayTracingPipelineFeaturesKHR::pname:rayTracingPipelineShaderGroupHandleCaptureReplay
    must: be enabled to call this function
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-03607]]
    pname:pipeline must: have been created with a pname:flags that included
    ename:VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
ifdef::VK_KHR_pipeline_library[]
  * [[VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-06720]]
    pname:pipeline must: not have been created with
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
endif::VK_KHR_pipeline_library[]
****

include::{generated}/validity/protos/vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.txt[]
--
endif::VK_KHR_ray_tracing_pipeline[]

ifdef::VK_NV_ray_tracing[]
Ray tracing pipelines can: contain more shaders than a graphics or compute
pipeline, so to allow parallel compilation of shaders within a pipeline, an
application can: choose to defer compilation until a later point in time.

[open,refpage='vkCompileDeferredNV',desc='Deferred compilation of shaders',type='protos']
--
:refpage: vkCompileDeferredNV

To compile a deferred shader in a pipeline call:

include::{generated}/api/protos/vkCompileDeferredNV.txt[]

  * pname:device is the logical device containing the ray tracing pipeline.
  * pname:pipeline is the ray tracing pipeline object containing the
    shaders.
  * pname:shader is the index of the shader to compile.

.Valid Usage
****
  * [[VUID-vkCompileDeferredNV-pipeline-04621]]
    pname:pipeline must: be a ray tracing pipeline
  * [[VUID-vkCompileDeferredNV-pipeline-02237]]
    pname:pipeline must: have been created with
    ename:VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV
  * [[VUID-vkCompileDeferredNV-shader-02238]]
    pname:shader must: not have been called as a deferred compile before
****

include::{generated}/validity/protos/vkCompileDeferredNV.txt[]
--
endif::VK_NV_ray_tracing[]

ifdef::VK_KHR_ray_tracing_pipeline[]
[open,refpage='vkGetRayTracingShaderGroupStackSizeKHR',desc='Query ray tracing pipeline shader group shader stack size',type='protos']
--
To query the pipeline stack size of shaders in a shader group in the ray
tracing pipeline, call:

include::{generated}/api/protos/vkGetRayTracingShaderGroupStackSizeKHR.txt[]

  * pname:device is the logical device containing the ray tracing pipeline.
  * pname:pipeline is the ray tracing pipeline object containing the shaders
    groups.
  * pname:group is the index of the shader group to query.
  * pname:groupShader is the type of shader from the group to query.

The return value is the ray tracing pipeline stack size in bytes for the
specified shader as called from the specified shader group.

.Valid Usage
****
  * [[VUID-vkGetRayTracingShaderGroupStackSizeKHR-pipeline-04622]]
    pname:pipeline must: be a ray tracing pipeline
  * [[VUID-vkGetRayTracingShaderGroupStackSizeKHR-group-03608]]
    The value of pname:group must be less than the number of shader groups
    in pname:pipeline
  * [[VUID-vkGetRayTracingShaderGroupStackSizeKHR-groupShader-03609]]
    The shader identified by pname:groupShader in pname:group must: not be
    ename:VK_SHADER_UNUSED_KHR
****

include::{generated}/validity/protos/vkGetRayTracingShaderGroupStackSizeKHR.txt[]
--

[open,refpage='VkShaderGroupShaderKHR',desc='Shader group shaders',type='enums']
--
Possible values of pname:groupShader in
flink:vkGetRayTracingShaderGroupStackSizeKHR are:

include::{generated}/api/enums/VkShaderGroupShaderKHR.txt[]

  * ename:VK_SHADER_GROUP_SHADER_GENERAL_KHR uses the shader specified in
    the group with
    slink:VkRayTracingShaderGroupCreateInfoKHR::pname:generalShader
  * ename:VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR uses the shader specified
    in the group with
    slink:VkRayTracingShaderGroupCreateInfoKHR::pname:closestHitShader
  * ename:VK_SHADER_GROUP_SHADER_ANY_HIT_KHR uses the shader specified in
    the group with
    slink:VkRayTracingShaderGroupCreateInfoKHR::pname:anyHitShader
  * ename:VK_SHADER_GROUP_SHADER_INTERSECTION_KHR uses the shader specified
    in the group with
    slink:VkRayTracingShaderGroupCreateInfoKHR::pname:intersectionShader
--


[open,refpage='vkCmdSetRayTracingPipelineStackSizeKHR',desc='Set the stack size dynamically for a ray tracing pipeline',type='protos']
--
:refpage: vkCmdSetRayTracingPipelineStackSizeKHR

To <<pipelines-dynamic-state, dynamically set>> the stack size for a ray
tracing pipeline, call:

include::{generated}/api/protos/vkCmdSetRayTracingPipelineStackSizeKHR.txt[]

  * pname:commandBuffer is the command buffer into which the command will be
    recorded.
  * pname:pipelineStackSize is the stack size to use for subsequent ray
    tracing trace commands.

This command sets the stack size for subsequent ray tracing commands when
the ray tracing pipeline is created with
ename:VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR set in
slink:VkPipelineDynamicStateCreateInfo::pname:pDynamicStates.
Otherwise, the stack size is computed as described in
<<ray-tracing-pipeline-stack, Ray Tracing Pipeline Stack>>.

.Valid Usage
****
  * [[VUID-vkCmdSetRayTracingPipelineStackSizeKHR-pipelineStackSize-03610]]
    pname:pipelineStackSize must: be large enough for any dynamic execution
    through the shaders in the ray tracing pipeline used by a subsequent
    trace call
****
include::{generated}/validity/protos/vkCmdSetRayTracingPipelineStackSizeKHR.txt[]
--
endif::VK_KHR_ray_tracing_pipeline[]
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]


[[pipelines-destruction]]
== Pipeline Destruction

[open,refpage='vkDestroyPipeline',desc='Destroy a pipeline object',type='protos']
--
To destroy a pipeline, call:

include::{generated}/api/protos/vkDestroyPipeline.txt[]

  * pname:device is the logical device that destroys the pipeline.
  * pname:pipeline is the handle of the pipeline to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyPipeline-pipeline-00765]]
    All submitted commands that refer to pname:pipeline must: have completed
    execution
  * [[VUID-vkDestroyPipeline-pipeline-00766]]
    If sname:VkAllocationCallbacks were provided when pname:pipeline was
    created, a compatible set of callbacks must: be provided here
  * [[VUID-vkDestroyPipeline-pipeline-00767]]
    If no sname:VkAllocationCallbacks were provided when pname:pipeline was
    created, pname:pAllocator must: be `NULL`
****

include::{generated}/validity/protos/vkDestroyPipeline.txt[]
--


[[pipelines-multiple]]
== Multiple Pipeline Creation

Multiple pipelines can: be created simultaneously by passing an array of
slink:VkGraphicsPipelineCreateInfo,
ifdef::VK_KHR_ray_tracing_pipeline[slink:VkRayTracingPipelineCreateInfoKHR,]
ifdef::VK_NV_ray_tracing[slink:VkRayTracingPipelineCreateInfoNV,]
or slink:VkComputePipelineCreateInfo structures into the
flink:vkCreateGraphicsPipelines,
ifdef::VK_KHR_ray_tracing_pipeline[flink:vkCreateRayTracingPipelinesKHR,]
ifdef::VK_NV_ray_tracing[flink:vkCreateRayTracingPipelinesNV,]
and flink:vkCreateComputePipelines commands, respectively.
Applications can: group together similar pipelines to be created in a single
call, and implementations are encouraged to look for reuse opportunities
within a group-create.

When an application attempts to create many pipelines in a single command,
it is possible that some subset may: fail creation.
In that case, the corresponding entries in the pname:pPipelines output array
will be filled with dlink:VK_NULL_HANDLE values.
If any pipeline fails creation despite valid arguments (for example, due to
out of memory errors), the elink:VkResult code returned by
ftext:vkCreate*Pipelines will indicate why.
The implementation will attempt to create all pipelines, and only return
dlink:VK_NULL_HANDLE values for those that actually failed.

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
If creation fails for a pipeline that had
ename:VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT set, pipelines at an
index in the pname:pPipelines array greater than or equal to that of the
failing pipeline must: be set to dlink:VK_NULL_HANDLE.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]


[[pipelines-pipeline-derivatives]]
== Pipeline Derivatives

A pipeline derivative is a child pipeline created from a parent pipeline,
where the child and parent are expected to have much commonality.
The goal of derivative pipelines is that they be cheaper to create using the
parent as a starting point, and that it be more efficient (on either host or
device) to switch/bind between children of the same parent.

A derivative pipeline is created by setting the
ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT flag in the
stext:Vk*PipelineCreateInfo structure.
If this is set, then exactly one of pname:basePipelineHandle or
pname:basePipelineIndex members of the structure must: have a valid
handle/index, and specifies the parent pipeline.
If pname:basePipelineHandle is used, the parent pipeline must: have already
been created.
If pname:basePipelineIndex is used, then the parent is being created in the
same command.
dlink:VK_NULL_HANDLE acts as the invalid handle for
pname:basePipelineHandle, and -1 is the invalid index for
pname:basePipelineIndex.
If pname:basePipelineIndex is used, the base pipeline must: appear earlier
in the array.
The base pipeline must: have been created with the
ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set.


[[pipelines-cache]]
== Pipeline Cache

[open,refpage='VkPipelineCache',desc='Opaque handle to a pipeline cache object',type='handles']
--
Pipeline cache objects allow the result of pipeline construction to be
reused between pipelines and between runs of an application.
Reuse between pipelines is achieved by passing the same pipeline cache
object when creating multiple related pipelines.
Reuse across runs of an application is achieved by retrieving pipeline cache
contents in one run of an application, saving the contents, and using them
to preinitialize a pipeline cache on a subsequent run.
The contents of the pipeline cache objects are managed by the
implementation.
Applications can: manage the host memory consumed by a pipeline cache object
and control the amount of data retrieved from a pipeline cache object.

Pipeline cache objects are represented by sname:VkPipelineCache handles:

include::{generated}/api/handles/VkPipelineCache.txt[]
--

[[pipelines-cache-create]]
=== Creating a Pipeline Cache

[open,refpage='vkCreatePipelineCache',desc='Creates a new pipeline cache',type='protos']
--
To create pipeline cache objects, call:

include::{generated}/api/protos/vkCreatePipelineCache.txt[]

  * pname:device is the logical device that creates the pipeline cache
    object.
  * pname:pCreateInfo is a pointer to a slink:VkPipelineCacheCreateInfo
    structure containing initial parameters for the pipeline cache object.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pPipelineCache is a pointer to a slink:VkPipelineCache handle in
    which the resulting pipeline cache object is returned.

[NOTE]
.Note
====
Applications can: track and manage the total host memory size of a pipeline
cache object using the pname:pAllocator.
Applications can: limit the amount of data retrieved from a pipeline cache
object in fname:vkGetPipelineCacheData.
Implementations should: not internally limit the total number of entries
added to a pipeline cache object or the total host memory consumed.
====

Once created, a pipeline cache can: be passed to the
flink:vkCreateGraphicsPipelines
ifdef::VK_KHR_ray_tracing_pipeline[flink:vkCreateRayTracingPipelinesKHR,]
ifdef::VK_NV_ray_tracing[flink:vkCreateRayTracingPipelinesNV,]
and flink:vkCreateComputePipelines commands.
If the pipeline cache passed into these commands is not
dlink:VK_NULL_HANDLE, the implementation will query it for possible reuse
opportunities and update it with new content.
The use of the pipeline cache object in these commands is internally
synchronized, and the same pipeline cache object can: be used in multiple
threads simultaneously.

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
If pname:flags of pname:pCreateInfo includes
ename:VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT, all commands
that modify the returned pipeline cache object must: be
<<fundamentals-threadingbehavior,externally synchronized>>.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]

[NOTE]
.Note
====
Implementations should: make every effort to limit any critical sections to
the actual accesses to the cache, which is expected to be significantly
shorter than the duration of the ftext:vkCreate*Pipelines commands.
====

include::{generated}/validity/protos/vkCreatePipelineCache.txt[]
--

[open,refpage='VkPipelineCacheCreateInfo',desc='Structure specifying parameters of a newly created pipeline cache',type='structs']
--
The sname:VkPipelineCacheCreateInfo structure is defined as:

include::{generated}/api/structs/VkPipelineCacheCreateInfo.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * pname:flags is a bitmask of elink:VkPipelineCacheCreateFlagBits
    specifying the behavior of the pipeline cache.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifndef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * pname:flags is reserved for future use.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * pname:initialDataSize is the number of bytes in pname:pInitialData.
    If pname:initialDataSize is zero, the pipeline cache will initially be
    empty.
  * pname:pInitialData is a pointer to previously retrieved pipeline cache
    data.
    If the pipeline cache data is incompatible (as defined below) with the
    device, the pipeline cache will be initially empty.
    If pname:initialDataSize is zero, pname:pInitialData is ignored.

.Valid Usage
****
  * [[VUID-VkPipelineCacheCreateInfo-initialDataSize-00768]]
    If pname:initialDataSize is not `0`, it must: be equal to the size of
    pname:pInitialData, as returned by fname:vkGetPipelineCacheData when
    pname:pInitialData was originally retrieved
  * [[VUID-VkPipelineCacheCreateInfo-initialDataSize-00769]]
    If pname:initialDataSize is not `0`, pname:pInitialData must: have been
    retrieved from a previous call to fname:vkGetPipelineCacheData
ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
  * [[VUID-VkPipelineCacheCreateInfo-pipelineCreationCacheControl-02892]]
    If the <<features-pipelineCreationCacheControl,
    pname:pipelineCreationCacheControl>> feature is not enabled, pname:flags
    must: not include
    ename:VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
****

include::{generated}/validity/structs/VkPipelineCacheCreateInfo.txt[]
--

[open,refpage='VkPipelineCacheCreateFlags', desc='Bitmask of VkPipelineCreateFlagBits', type='flags']
--
include::{generated}/api/flags/VkPipelineCacheCreateFlags.txt[]

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
tname:VkPipelineCacheCreateFlags is a bitmask type for setting a mask of
zero or more elink:VkPipelineCacheCreateFlagBits.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
ifndef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
tname:VkPipelineCacheCreateFlags is a bitmask type for setting a mask, but
is currently reserved for future use.
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
--

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]
[open,refpage='VkPipelineCacheCreateFlagBits',desc='Bitmask specifying the behavior of the pipeline cache',type='enums']
--
Bits which can: be set in slink:VkPipelineCacheCreateInfo::pname:flags,
specifying behavior of the pipeline cache, are:

include::{generated}/api/enums/VkPipelineCacheCreateFlagBits.txt[]

  * ename:VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT specifies
    that all commands that modify the created slink:VkPipelineCache will be
    <<fundamentals-threadingbehavior,externally synchronized>>.
    When set, the implementation may: skip any unnecessary processing needed
    to support simultaneous modification from multiple threads where
    allowed.
--
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control[]



[[pipelines-cache-merge]]
=== Merging Pipeline Caches

[open,refpage='vkMergePipelineCaches',desc='Combine the data stores of pipeline caches',type='protos']
--
Pipeline cache objects can: be merged using the command:

include::{generated}/api/protos/vkMergePipelineCaches.txt[]

  * pname:device is the logical device that owns the pipeline cache objects.
  * pname:dstCache is the handle of the pipeline cache to merge results
    into.
  * pname:srcCacheCount is the length of the pname:pSrcCaches array.
  * pname:pSrcCaches is a pointer to an array of pipeline cache handles,
    which will be merged into pname:dstCache.
    The previous contents of pname:dstCache are included after the merge.

[NOTE]
.Note
====
The details of the merge operation are implementation-dependent, but
implementations should: merge the contents of the specified pipelines and
prune duplicate entries.
====

.Valid Usage
****
  * [[VUID-vkMergePipelineCaches-dstCache-00770]]
    pname:dstCache must: not appear in the list of source caches
****

include::{generated}/validity/protos/vkMergePipelineCaches.txt[]
--

[[pipelines-cache-retrieval]]
=== Retrieving Pipeline Cache Data

[open,refpage='vkGetPipelineCacheData',desc='Get the data store from a pipeline cache',type='protos']
--
Data can: be retrieved from a pipeline cache object using the command:

include::{generated}/api/protos/vkGetPipelineCacheData.txt[]

  * pname:device is the logical device that owns the pipeline cache.
  * pname:pipelineCache is the pipeline cache to retrieve data from.
  * pname:pDataSize is a pointer to a code:size_t value related to the
    amount of data in the pipeline cache, as described below.
  * pname:pData is either `NULL` or a pointer to a buffer.

If pname:pData is `NULL`, then the maximum size of the data that can: be
retrieved from the pipeline cache, in bytes, is returned in pname:pDataSize.
Otherwise, pname:pDataSize must: point to a variable set by the user to the
size of the buffer, in bytes, pointed to by pname:pData, and on return the
variable is overwritten with the amount of data actually written to
pname:pData.
If pname:pDataSize is less than the maximum size that can: be retrieved by
the pipeline cache, at most pname:pDataSize bytes will be written to
pname:pData, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all of the pipeline cache was
returned.

Any data written to pname:pData is valid and can: be provided as the
pname:pInitialData member of the slink:VkPipelineCacheCreateInfo structure
passed to fname:vkCreatePipelineCache.

Two calls to fname:vkGetPipelineCacheData with the same parameters must:
retrieve the same data unless a command that modifies the contents of the
cache is called between them.

The initial bytes written to pname:pData must: be a header as described in
the <<pipelines-cache-header, Pipeline Cache Header>> section.

If pname:pDataSize is less than what is necessary to store this header,
nothing will be written to pname:pData and zero will be written to
pname:pDataSize.

include::{generated}/validity/protos/vkGetPipelineCacheData.txt[]
--

[[pipelines-cache-header]]
=== Pipeline Cache Header

Applications can: store the data retrieved from the pipeline cache, and use
these data, possibly in a future run of the application, to populate new
pipeline cache objects.
The results of pipeline compiles, however, may: depend on the vendor ID,
device ID, driver version, and other details of the device.
To enable applications to detect when previously retrieved data is
incompatible with the device, the pipeline cache data must: begin with a
valid pipeline cache header.

[open,refpage='VkPipelineCacheHeaderVersionOne',desc='Structure describing the layout of the pipeline cache header',type='structs']
--
Version one of the pipeline cache header is defined as:

include::{generated}/api/structs/VkPipelineCacheHeaderVersionOne.txt[]

  * pname:headerSize is the length in bytes of the pipeline cache header.
  * pname:headerVersion is a elink:VkPipelineCacheHeaderVersion enum value
    specifying the version of the header.
    A consumer of the pipeline cache should: use the cache version to
    interpret the remainder of the cache header.
  * pname:vendorID is the sname:VkPhysicalDeviceProperties::pname:vendorID
    of the implementation.
  * pname:deviceID is the sname:VkPhysicalDeviceProperties::pname:deviceID
    of the implementation.
  * pname:pipelineCacheUUID is the
    sname:VkPhysicalDeviceProperties::pname:pipelineCacheUUID of the
    implementation.

Unlike most structures declared by the Vulkan API, all fields of this
structure are written with the least significant byte first, regardless of
host byte-order.

The C language specification does not define the packing of structure
members.
This layout assumes tight structure member packing, with members laid out in
the order listed in the structure, and the intended size of the structure is
32 bytes.
If a compiler produces code that diverges from that pattern, applications
must: employ another method to set values at the correct offsets.

.Valid Usage
****
  * [[VUID-VkPipelineCacheHeaderVersionOne-headerSize-04967]]
    pname:headerSize must: be 32
  * [[VUID-VkPipelineCacheHeaderVersionOne-headerVersion-04968]]
    pname:headerVersion must: be ename:VK_PIPELINE_CACHE_HEADER_VERSION_ONE
****

include::{generated}/validity/structs/VkPipelineCacheHeaderVersionOne.txt[]
--

[open,refpage='VkPipelineCacheHeaderVersion',desc='Encode pipeline cache version',type='enums',xrefs='vkCreatePipelineCache vkGetPipelineCacheData']
--
Possible values of the pname:headerVersion value of the pipeline cache
header are:

include::{generated}/api/enums/VkPipelineCacheHeaderVersion.txt[]

  * ename:VK_PIPELINE_CACHE_HEADER_VERSION_ONE specifies version one of the
    pipeline cache.
--


[[pipelines-cache-destroy]]
=== Destroying a Pipeline Cache

[open,refpage='vkDestroyPipelineCache',desc='Destroy a pipeline cache object',type='protos']
--
To destroy a pipeline cache, call:

include::{generated}/api/protos/vkDestroyPipelineCache.txt[]

  * pname:device is the logical device that destroys the pipeline cache
    object.
  * pname:pipelineCache is the handle of the pipeline cache to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyPipelineCache-pipelineCache-00771]]
    If sname:VkAllocationCallbacks were provided when pname:pipelineCache
    was created, a compatible set of callbacks must: be provided here
  * [[VUID-vkDestroyPipelineCache-pipelineCache-00772]]
    If no sname:VkAllocationCallbacks were provided when pname:pipelineCache
    was created, pname:pAllocator must: be `NULL`
****

include::{generated}/validity/protos/vkDestroyPipelineCache.txt[]
--


[[pipelines-specialization-constants]]
== Specialization Constants

Specialization constants are a mechanism whereby constants in a SPIR-V
module can: have their constant value specified at the time the
sname:VkPipeline is created.
This allows a SPIR-V module to have constants that can: be modified while
executing an application that uses the Vulkan API.

[NOTE]
.Note
====
Specialization constants are useful to allow a compute shader to have its
local workgroup size changed at runtime by the user, for example.
====

Each slink:VkPipelineShaderStageCreateInfo structure contains a
pname:pSpecializationInfo member, which can: be `NULL` to indicate no
specialization constants, or point to a sname:VkSpecializationInfo
structure.

[open,refpage='VkSpecializationInfo',desc='Structure specifying specialization information',type='structs']
--
The sname:VkSpecializationInfo structure is defined as:

include::{generated}/api/structs/VkSpecializationInfo.txt[]

  * pname:mapEntryCount is the number of entries in the pname:pMapEntries
    array.
  * pname:pMapEntries is a pointer to an array of
    sname:VkSpecializationMapEntry structures which map constant IDs to
    offsets in pname:pData.
  * pname:dataSize is the byte size of the pname:pData buffer.
  * pname:pData contains the actual constant values to specialize with.

.Valid Usage
****
  * [[VUID-VkSpecializationInfo-offset-00773]]
    The pname:offset member of each element of pname:pMapEntries must: be
    less than pname:dataSize
  * [[VUID-VkSpecializationInfo-pMapEntries-00774]]
    The pname:size member of each element of pname:pMapEntries must: be less
    than or equal to pname:dataSize minus pname:offset
  * [[VUID-VkSpecializationInfo-constantID-04911]]
    The pname:constantID value of each element of pname:pMapEntries must: be
    unique within pname:pMapEntries
****

include::{generated}/validity/structs/VkSpecializationInfo.txt[]
--

[open,refpage='VkSpecializationMapEntry',desc='Structure specifying a specialization map entry',type='structs']
--
The sname:VkSpecializationMapEntry structure is defined as:

include::{generated}/api/structs/VkSpecializationMapEntry.txt[]

  * pname:constantID is the ID of the specialization constant in SPIR-V.
  * pname:offset is the byte offset of the specialization constant value
    within the supplied data buffer.
  * pname:size is the byte size of the specialization constant value within
    the supplied data buffer.

If a pname:constantID value is not a specialization constant ID used in the
shader, that map entry does not affect the behavior of the pipeline.

.Valid Usage
****
  * [[VUID-VkSpecializationMapEntry-constantID-00776]]
    For a pname:constantID specialization constant declared in a shader,
    pname:size must: match the byte size of the pname:constantID.
    If the specialization constant is of type code:boolean, pname:size must:
    be the byte size of basetype:VkBool32
****

include::{generated}/validity/structs/VkSpecializationMapEntry.txt[]
--

In human readable SPIR-V:

[source,glsl]
---------------------------------------------------
OpDecorate %x SpecId 13 ; decorate .x component of WorkgroupSize with ID 13
OpDecorate %y SpecId 42 ; decorate .y component of WorkgroupSize with ID 42
OpDecorate %z SpecId 3  ; decorate .z component of WorkgroupSize with ID 3
OpDecorate %wgsize BuiltIn WorkgroupSize ; decorate WorkgroupSize onto constant
%i32 = OpTypeInt 32 0 ; declare an unsigned 32-bit type
%uvec3 = OpTypeVector %i32 3 ; declare a 3 element vector type of unsigned 32-bit
%x = OpSpecConstant %i32 1 ; declare the .x component of WorkgroupSize
%y = OpSpecConstant %i32 1 ; declare the .y component of WorkgroupSize
%z = OpSpecConstant %i32 1 ; declare the .z component of WorkgroupSize
%wgsize = OpSpecConstantComposite %uvec3 %x %y %z ; declare WorkgroupSize
---------------------------------------------------

From the above we have three specialization constants, one for each of the
x, y & z elements of the WorkgroupSize vector.

Now to specialize the above via the specialization constants mechanism:

[source,c++]
---------------------------------------------------
const VkSpecializationMapEntry entries[] =
{
    {
        13,                             // constantID
        0 * sizeof(uint32_t),           // offset
        sizeof(uint32_t)                // size
    },
    {
        42,                             // constantID
        1 * sizeof(uint32_t),           // offset
        sizeof(uint32_t)                // size
    },
    {
        3,                              // constantID
        2 * sizeof(uint32_t),           // offset
        sizeof(uint32_t)                // size
    }
};

const uint32_t data[] = { 16, 8, 4 }; // our workgroup size is 16x8x4

const VkSpecializationInfo info =
{
    3,                                  // mapEntryCount
    entries,                            // pMapEntries
    3 * sizeof(uint32_t),               // dataSize
    data,                               // pData
};
---------------------------------------------------

Then when calling flink:vkCreateComputePipelines, and passing the
sname:VkSpecializationInfo we defined as the pname:pSpecializationInfo
parameter of slink:VkPipelineShaderStageCreateInfo, we will create a compute
pipeline with the runtime specified local workgroup size.

Another example would be that an application has a SPIR-V module that has
some platform-dependent constants they wish to use.

In human readable SPIR-V:

// [source,glsl]
[source,glsl]
---------------------------------------------------
OpDecorate %1 SpecId 0  ; decorate our signed 32-bit integer constant
OpDecorate %2 SpecId 12 ; decorate our 32-bit floating-point constant
%i32 = OpTypeInt 32 1   ; declare a signed 32-bit type
%float = OpTypeFloat 32 ; declare a 32-bit floating-point type
%1 = OpSpecConstant %i32 -1 ; some signed 32-bit integer constant
%2 = OpSpecConstant %float 0.5 ; some 32-bit floating-point constant
---------------------------------------------------

From the above we have two specialization constants, one is a signed 32-bit
integer and the second is a 32-bit floating-point value.

Now to specialize the above via the specialization constants mechanism:

[source,c++]
---------------------------------------------------
struct SpecializationData {
    int32_t data0;
    float data1;
};

const VkSpecializationMapEntry entries[] =
{
    {
        0,                                    // constantID
        offsetof(SpecializationData, data0),  // offset
        sizeof(SpecializationData::data0)     // size
    },
    {
        12,                                   // constantID
        offsetof(SpecializationData, data1),  // offset
        sizeof(SpecializationData::data1)     // size
    }
};

SpecializationData data;
data.data0 = -42;    // set the data for the 32-bit integer
data.data1 = 42.0f;  // set the data for the 32-bit floating-point

const VkSpecializationInfo info =
{
    2,                                  // mapEntryCount
    entries,                            // pMapEntries
    sizeof(data),                       // dataSize
    &data,                              // pData
};
---------------------------------------------------

It is legal for a SPIR-V module with specializations to be compiled into a
pipeline where no specialization information was provided.
SPIR-V specialization constants contain default values such that if a
specialization is not provided, the default value will be used.
In the examples above, it would be valid for an application to only
specialize some of the specialization constants within the SPIR-V module,
and let the other constants use their default values encoded within the
OpSpecConstant declarations.


ifdef::VK_KHR_pipeline_library[]
[[pipeline-library]]
== Pipeline Libraries

A pipeline library is a special pipeline that was created using the
ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR and cannot be bound, instead it
defines a set of pipeline state which can be linked into other pipelines.
ifdef::VK_KHR_ray_tracing_pipeline[]
For ray tracing pipelines this includes shaders and shader groups.
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_EXT_graphics_pipeline_library[]
For graphics pipelines this includes distinct library types defined by
elink:VkGraphicsPipelineLibraryFlagBitsEXT.
endif::VK_EXT_graphics_pipeline_library[]
The application must: maintain the lifetime of a pipeline library based on
the pipelines that link with it.

This linkage is achieved by using the following structure within the
appropriate creation mechanisms:

[open,refpage='VkPipelineLibraryCreateInfoKHR',desc='Structure specifying pipeline libraries to use when creating a pipeline',type='structs']
--
The sname:VkPipelineLibraryCreateInfoKHR structure is defined as:

include::{generated}/api/structs/VkPipelineLibraryCreateInfoKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:libraryCount is the number of pipeline libraries in
    pname:pLibraries.
  * pname:pLibraries is a pointer to an array of slink:VkPipeline structures
    specifying pipeline libraries to use when creating a pipeline.

.Valid Usage
****
  * [[VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-03381]]
    Each element of pname:pLibraries must: have been created with
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
ifdef::VK_EXT_shader_module_identifier[]
  * [[VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-06855]]
    If any library in pname:pLibraries was created with a shader stage with
    slink:VkPipelineShaderStageModuleIdentifierCreateInfoEXT and
    pname:identifierSize not equal to 0, the pipeline must: be created with
    the ename:VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT flag
    set
endif::VK_EXT_shader_module_identifier[]
****

include::{generated}/validity/structs/VkPipelineLibraryCreateInfoKHR.txt[]
--

Pipelines created with ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR libraries
can: depend on other pipeline libraries in
slink:VkPipelineLibraryCreateInfoKHR.

A pipeline library is considered in-use, as long as one of the linking
pipelines is in-use.
This applies recursively if a pipeline library includes other pipeline
libraries.

endif::VK_KHR_pipeline_library[]


[[pipelines-binding]]
== Pipeline Binding

[open,refpage='vkCmdBindPipeline',desc='Bind a pipeline object to a command buffer',type='protos']
--
Once a pipeline has been created, it can: be bound to the command buffer
using the command:

include::{generated}/api/protos/vkCmdBindPipeline.txt[]

  * pname:commandBuffer is the command buffer that the pipeline will be
    bound to.
  * pname:pipelineBindPoint is a elink:VkPipelineBindPoint value specifying
    to which bind point the pipeline is bound.
    Binding one does not disturb the others.
  * pname:pipeline is the pipeline to be bound.

[[pipeline-bindpoint-commands]]
Once bound, a pipeline binding affects subsequent commands that interact
with the given pipeline type in the command buffer until a different
pipeline of the same type is bound to the bind point.
Commands that do not interact with the given pipeline type must: not be
affected by the pipeline state.

  * The pipeline bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE controls the
    behavior of all <<dispatch, dispatching commands>>.
  * The pipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS controls the
    behavior of all <<drawing, drawing commands>>.
ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
  * The pipeline bound to ename:VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR
    controls the behavior of flink:vkCmdTraceRaysKHR and
    flink:vkCmdTraceRaysIndirectKHR.
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
ifdef::VK_HUAWEI_subpass_shading[]
  * The pipeline bound to
    ename:VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI controls the
    behavior of flink:vkCmdSubpassShadingHUAWEI.
endif::VK_HUAWEI_subpass_shading[]

.Valid Usage
****
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-00777]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_COMPUTE, the
    sname:VkCommandPool that pname:commandBuffer was allocated from must:
    support compute operations
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-00778]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_GRAPHICS, the
    sname:VkCommandPool that pname:commandBuffer was allocated from must:
    support graphics operations
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-00779]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_COMPUTE,
    pname:pipeline must: be a compute pipeline
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-00780]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_GRAPHICS,
    pname:pipeline must: be a graphics pipeline
  * [[VUID-vkCmdBindPipeline-pipeline-00781]]
    If the <<features-variableMultisampleRate,
    pname:variableMultisampleRate>> feature is not supported, pname:pipeline
    is a graphics pipeline, the current subpass <<renderpass-noattachments,
    uses no attachments>>, and this is not the first call to this function
    with a graphics pipeline after transitioning to the current subpass,
    then the sample count specified by this pipeline must: match that set in
    the previous pipeline
ifdef::VK_EXT_sample_locations[]
  * [[VUID-vkCmdBindPipeline-variableSampleLocations-01525]]
    If
    slink:VkPhysicalDeviceSampleLocationsPropertiesEXT::pname:variableSampleLocations
    is ename:VK_FALSE, and pname:pipeline is a graphics pipeline created
    with a slink:VkPipelineSampleLocationsStateCreateInfoEXT structure
    having its pname:sampleLocationsEnable member set to ename:VK_TRUE but
    without ename:VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT enabled then the
    current render pass instance must: have been begun by specifying a
    slink:VkRenderPassSampleLocationsBeginInfoEXT structure whose
    pname:pPostSubpassSampleLocations member contains an element with a
    pname:subpassIndex matching the current subpass index and the
    pname:sampleLocationsInfo member of that element must: match the
    pname:sampleLocationsInfo specified in
    slink:VkPipelineSampleLocationsStateCreateInfoEXT when the pipeline was
    created
endif::VK_EXT_sample_locations[]
ifdef::VK_EXT_transform_feedback[]
  * [[VUID-vkCmdBindPipeline-None-02323]]
    This command must: not be recorded when transform feedback is active
endif::VK_EXT_transform_feedback[]
ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-02391]]
    If pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, the sname:VkCommandPool
    that pname:commandBuffer was allocated from must: support compute
    operations
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-02392]]
    If pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, pname:pipeline must: be a
    ray tracing pipeline
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-06721]]
    If pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, pname:commandBuffer must:
    not be a protected command buffer
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
ifdef::VK_KHR_pipeline_library[]
  * [[VUID-vkCmdBindPipeline-pipeline-03382]]
    pname:pipeline must: not have been created with
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR set
endif::VK_KHR_pipeline_library[]
ifdef::VK_NV_inherited_viewport_scissor[]
  * [[VUID-vkCmdBindPipeline-commandBuffer-04808]]
    If pname:commandBuffer is a secondary command buffer with
    slink:VkCommandBufferInheritanceViewportScissorInfoNV::pname:viewportScissor2D
    enabled and pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, then the pname:pipeline must:
    have been created with ename:VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT or
    ename:VK_DYNAMIC_STATE_VIEWPORT, and
    ename:VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT or
    ename:VK_DYNAMIC_STATE_SCISSOR enabled
endif::VK_NV_inherited_viewport_scissor[]
ifdef::VK_NV_inherited_viewport_scissor,VK_EXT_discard_rectangles[]
  * [[VUID-vkCmdBindPipeline-commandBuffer-04809]]
    If pname:commandBuffer is a secondary command buffer with
    slink:VkCommandBufferInheritanceViewportScissorInfoNV::pname:viewportScissor2D
    enabled and pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS and pname:pipeline was created
    with slink:VkPipelineDiscardRectangleStateCreateInfoEXT structure and
    its pname:discardRectangleCount member is not `0`, then the pipeline
    must: have been created with
    ename:VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT enabled
endif::VK_NV_inherited_viewport_scissor,VK_EXT_discard_rectangles[]
ifdef::VK_EXT_provoking_vertex[]
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-04881]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_GRAPHICS and
    the <<limits-provokingVertexModePerPipeline,
    pname:provokingVertexModePerPipeline>> limit is ename:VK_FALSE, then
    pipeline's
    slink:VkPipelineRasterizationProvokingVertexStateCreateInfoEXT::pname:provokingVertexMode
    must: be the same as that of any other pipelines previously bound to
    this bind point within the current render pass instance, including any
    pipeline already bound when beginning the render pass instance
endif::VK_EXT_provoking_vertex[]
ifdef::VK_HUAWEI_subpass_shading[]
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-04949]]
    If pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI, the
    sname:VkCommandPool that pname:commandBuffer was allocated from must:
    support compute operations
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-04950]]
    If pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI, pname:pipeline
    must: be a subpass shading pipeline
endif::VK_HUAWEI_subpass_shading[]
ifdef::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
  * [[VUID-vkCmdBindPipeline-pipeline-06195]]
    If pname:pipeline is a graphics pipeline, this command has been called
    inside a render pass instance started with flink:vkCmdBeginRendering,
    and commands using the previously bound graphics pipeline have been
    recorded within the render pass instance, then the value of
    slink:VkPipelineRenderingCreateInfo::pname:colorAttachmentCount
    specified by this pipeline must: match that set in the previous pipeline
  * [[VUID-vkCmdBindPipeline-pipeline-06196]]
    If pname:pipeline is a graphics pipeline, this command has been called
    inside a render pass instance started with flink:vkCmdBeginRendering,
    and commands using the previously bound graphics pipeline have been
    recorded within the render pass instance, then the elements of
    slink:VkPipelineRenderingCreateInfo::pname:pColorAttachmentFormats
    specified by this pipeline must: match that set in the previous pipeline
  * [[VUID-vkCmdBindPipeline-pipeline-06197]]
    If pname:pipeline is a graphics pipeline, this command has been called
    inside a render pass instance started with flink:vkCmdBeginRendering,
    and commands using the previously bound graphics pipeline have been
    recorded within the render pass instance, then the value of
    slink:VkPipelineRenderingCreateInfo::pname:depthAttachmentFormat
    specified by this pipeline must: match that set in the previous pipeline
  * [[VUID-vkCmdBindPipeline-pipeline-06194]]
    If pname:pipeline is a graphics pipeline, this command has been called
    inside a render pass instance started with flink:vkCmdBeginRendering,
    and commands using the previously bound graphics pipeline have been
    recorded within the render pass instance, then the value of
    slink:VkPipelineRenderingCreateInfo::pname:stencilAttachmentFormat
    specified by this pipeline must: match that set in the previous pipeline
ifdef::VK_EXT_multisampled_render_to_single_sampled[]
  * [[VUID-vkCmdBindPipeline-pipeline-06856]]
    If pname:pipeline is a graphics pipeline, this command has been called
    inside a render pass instance started with flink:vkCmdBeginRendering,
    and the pname:pNext chain of slink:VkRenderingInfo includes a
    slink:VkMultisampledRenderToSingleSampledInfoEXT structure with
    pname:multisampledRenderToSingleSampledEnable equal to ename:VK_TRUE,
    then the value of
    slink:VkGraphicsPipelineCreateInfo::pname:pMultisampleState::pname:rasterizationSamples
    must: be equal to
    slink:VkMultisampledRenderToSingleSampledInfoEXT::pname:rasterizationSamples.
endif::VK_EXT_multisampled_render_to_single_sampled[]
endif::VK_VERSION_1_3,VK_KHR_dynamic_rendering[]
ifdef::VK_EXT_graphics_pipeline_library[]
  * [[VUID-vkCmdBindPipeline-pipelineBindPoint-06653]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_GRAPHICS,
    pname:pipeline must: have been created without
    ename:VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
endif::VK_EXT_graphics_pipeline_library[]
****

include::{generated}/validity/protos/vkCmdBindPipeline.txt[]
--

[open,refpage='VkPipelineBindPoint',desc='Specify the bind point of a pipeline object to a command buffer',type='enums']
--
Possible values of flink:vkCmdBindPipeline::pname:pipelineBindPoint,
specifying the bind point of a pipeline object, are:

include::{generated}/api/enums/VkPipelineBindPoint.txt[]

  * ename:VK_PIPELINE_BIND_POINT_COMPUTE specifies binding as a compute
    pipeline.
  * ename:VK_PIPELINE_BIND_POINT_GRAPHICS specifies binding as a graphics
    pipeline.
ifdef::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
  * ename:VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR specifies binding as a ray
    tracing pipeline.
endif::VK_NV_ray_tracing,VK_KHR_ray_tracing_pipeline[]
ifdef::VK_HUAWEI_subpass_shading[]
  * ename:VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI specifies binding as
    a subpass shading pipeline.
endif::VK_HUAWEI_subpass_shading[]
--

ifdef::VK_NV_device_generated_commands[]
[open,refpage='vkCmdBindPipelineShaderGroupNV',desc='Bind a pipeline object's shader group to a command buffer',type='protos']
--
For pipelines that were created with the support of multiple shader groups
(see <<graphics-shadergroups,Graphics Pipeline Shader Groups>>), the regular
fname:vkCmdBindPipeline command will bind Shader Group `0`.
To explicitly bind a shader group use:

include::{generated}/api/protos/vkCmdBindPipelineShaderGroupNV.txt[]

  * pname:commandBuffer is the command buffer that the pipeline will be
    bound to.
  * pname:pipelineBindPoint is a elink:VkPipelineBindPoint value specifying
    the bind point to which the pipeline will be bound.
  * pname:pipeline is the pipeline to be bound.
  * pname:groupIndex is the shader group to be bound.


.Valid Usage
****
  * [[VUID-vkCmdBindPipelineShaderGroupNV-groupIndex-02893]]
    pname:groupIndex must: be `0` or less than the effective
    slink:VkGraphicsPipelineShaderGroupsCreateInfoNV::pname:groupCount
    including the referenced pipelines
  * [[VUID-vkCmdBindPipelineShaderGroupNV-pipelineBindPoint-02894]]
    The pname:pipelineBindPoint must: be
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS
  * [[VUID-vkCmdBindPipelineShaderGroupNV-groupIndex-02895]]
    The same restrictions as flink:vkCmdBindPipeline apply as if the bound
    pipeline was created only with the Shader Group from the
    pname:groupIndex information
  * [[VUID-vkCmdBindPipelineShaderGroupNV-deviceGeneratedCommands-02896]]
    The <<features-deviceGeneratedCommands, pname:deviceGeneratedCommands>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkCmdBindPipelineShaderGroupNV.txt[]
--
endif::VK_NV_device_generated_commands[]


[[pipelines-dynamic-state]]
== Dynamic State

When a pipeline object is bound, any pipeline object state that is not
specified as dynamic is applied to the command buffer state.
Pipeline object state that is specified as dynamic is not applied to the
command buffer state at this time.
Instead, dynamic state can: be modified at any time and persists for the
lifetime of the command buffer, or until modified by another dynamic state
setting command, or made invalid by another pipeline bind with that state
specified as static.

When a pipeline object is bound, the following applies to each state
parameter:

  * If the state is not specified as dynamic in the new pipeline object,
    then that command buffer state is overwritten by the state in the new
    pipeline object.
    Before any draw or dispatch call with this pipeline there must: not have
    been any calls to any of the corresponding dynamic state setting
    commands after this pipeline was bound.
  * If the state is specified as dynamic in the new pipeline object, then
    that command buffer state is not disturbed.
    Before any draw or dispatch call with this pipeline there must: have
    been at least one call to each of the corresponding dynamic state
    setting commands.
    The state-setting commands must: be recorded after command buffer
    recording was begun, or after the last command binding a pipeline object
    with that state specified as static, whichever was the latter.

Dynamic state that does not affect the result of operations can: be left
undefined:.

[NOTE]
.Note
====
For example, if blending is disabled by the pipeline object state then the
dynamic color blend constants do not need to be specified in the command
buffer, even if this state is specified as dynamic in the pipeline object.
====


ifdef::VK_AMD_shader_info,VK_KHR_pipeline_executable_properties,VK_EXT_pipeline_properties[]
[[pipelines-shader-information]]
== Pipeline Properties and Shader Information
endif::VK_AMD_shader_info,VK_KHR_pipeline_executable_properties,VK_EXT_pipeline_properties[]

ifdef::VK_KHR_pipeline_executable_properties[]
[open,refpage='vkGetPipelineExecutablePropertiesKHR',desc='Get the executables associated with a pipeline',type='protos']
--
When a pipeline is created, its state and shaders are compiled into zero or
more device-specific executables, which are used when executing commands
against that pipeline.
To query the properties of these pipeline executables, call:

include::{generated}/api/protos/vkGetPipelineExecutablePropertiesKHR.txt[]

  * pname:device is the device that created the pipeline.
  * pname:pPipelineInfo describes the pipeline being queried.
  * pname:pExecutableCount is a pointer to an integer related to the number
    of pipeline executables available or queried, as described below.
  * pname:pProperties is either `NULL` or a pointer to an array of
    slink:VkPipelineExecutablePropertiesKHR structures.

If pname:pProperties is `NULL`, then the number of pipeline executables
associated with the pipeline is returned in pname:pExecutableCount.
Otherwise, pname:pExecutableCount must: point to a variable set by the user
to the number of elements in the pname:pProperties array, and on return the
variable is overwritten with the number of structures actually written to
pname:pProperties.
If pname:pExecutableCount is less than the number of pipeline executables
associated with the pipeline, at most pname:pExecutableCount structures will
be written, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all the available properties were
returned.

.Valid Usage
****
  * [[VUID-vkGetPipelineExecutablePropertiesKHR-pipelineExecutableInfo-03270]]
    The <<features-pipelineExecutableInfo, pname:pipelineExecutableInfo>>
    feature must: be enabled
  * [[VUID-vkGetPipelineExecutablePropertiesKHR-pipeline-03271]]
    The pname:pipeline member of pname:pPipelineInfo must: have been created
    with pname:device
****

include::{generated}/validity/protos/vkGetPipelineExecutablePropertiesKHR.txt[]
--

[open,refpage='VkPipelineExecutablePropertiesKHR',desc='Structure describing a pipeline executable',type='structs']
--
The sname:VkPipelineExecutablePropertiesKHR structure is defined as:

include::{generated}/api/structs/VkPipelineExecutablePropertiesKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:stages is a bitmask of zero or more elink:VkShaderStageFlagBits
    indicating which shader stages (if any) were principally used as inputs
    to compile this pipeline executable.
  * pname:name is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a short human
    readable name for this pipeline executable.
  * pname:description is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a human readable
    description for this pipeline executable.
  * pname:subgroupSize is the subgroup size with which this pipeline
    executable is dispatched.

Not all implementations have a 1:1 mapping between shader stages and
pipeline executables and some implementations may: reduce a given shader
stage to fixed function hardware programming such that no pipeline
executable is available.
No guarantees are provided about the mapping between shader stages and
pipeline executables and pname:stages should: be considered a best effort
hint.
Because the application cannot: rely on the pname:stages field to provide an
exact description, pname:name and pname:description provide a human readable
name and description which more accurately describes the given pipeline
executable.

include::{generated}/validity/structs/VkPipelineExecutablePropertiesKHR.txt[]
--
endif::VK_KHR_pipeline_executable_properties[]

ifdef::VK_EXT_pipeline_properties[]
[open,refpage='vkGetPipelinePropertiesEXT',desc='Query pipeline properties',type='protos']
--
To query the pipeline properties call:

include::{generated}/api/protos/vkGetPipelinePropertiesEXT.txt[]

  * pname:device is the logical device that created the pipeline.
  * pname:pPipelineInfo is a pointer to a slink:VkPipelineInfoEXT structure
    which describes the pipeline being queried.
  * pname:pPipelineProperties is a pointer to a slink:VkBaseOutStructure
    structure in which the pipeline properties will be written.

To query a pipeline's pname:pipelineIdentifier pass a
slink:VkPipelinePropertiesIdentifierEXT structure in
pname:pPipelineProperties.
Each pipeline is associated with a pname:pipelineIdentifier and the
identifier is implementation specific.

.Valid Usage
****
  * [[VUID-vkGetPipelinePropertiesEXT-pipeline-06738]]
    The pname:pipeline member of pname:pPipelineInfo must have been created
    with pname:device
  * [[VUID-vkGetPipelinePropertiesEXT-pPipelineProperties-06739]]
    pname:pPipelineProperties must: be a valid pointer to a
    slink:VkPipelinePropertiesIdentifierEXT structure
  * [[VUID-vkGetPipelinePropertiesEXT-None-06766]]
    The <<features-pipelinePropertiesIdentifier,
    pname:pipelinePropertiesIdentifier>> feature must: be enabled
****

include::{generated}/validity/protos/vkGetPipelinePropertiesEXT.txt[]
--

[open,refpage='VkPipelinePropertiesIdentifierEXT',desc='Structure used to retrieve pipeline properties',type='structs']
--
The sname:VkPipelinePropertiesIdentifierEXT structure is defined as:

include::{generated}/api/structs/VkPipelinePropertiesIdentifierEXT.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to an extension-specific structure.
  * pname:pipelineIdentifier is an array of ename:VK_UUID_SIZE code:uint8_t
    values into which the pipeline identifier will be written.

include::{generated}/validity/structs/VkPipelinePropertiesIdentifierEXT.txt[]
--
endif::VK_EXT_pipeline_properties[]

// This structure is used by both vkGetPipelineExecutablePropertiesKHR and
// vkGetPipelinePropertiesEXT above, placing it in a nonstandard position.
ifdef::VK_KHR_pipeline_executable_properties,VK_EXT_pipeline_properties[]
[open,refpage='VkPipelineInfoKHR',desc='Structure describing a pipeline',type='structs',alias='VkPipelineInfoEXT']
--
The sname:VkPipelineInfoKHR structure is defined as:

include::{generated}/api/structs/VkPipelineInfoKHR.txt[]

ifdef::VK_EXT_pipeline_properties[]
or the equivalent

include::{generated}/api/structs/VkPipelineInfoEXT.txt[]
endif::VK_EXT_pipeline_properties[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipeline is a sname:VkPipeline handle.

include::{generated}/validity/structs/VkPipelineInfoKHR.txt[]
--
endif::VK_KHR_pipeline_executable_properties,VK_EXT_pipeline_properties[]

ifdef::VK_KHR_pipeline_executable_properties[]
[open,refpage='vkGetPipelineExecutableStatisticsKHR',desc='Get compile time statistics associated with a pipeline executable',type='protos']
--
Each pipeline executable may: have a set of statistics associated with it
that are generated by the pipeline compilation process.
These statistics may: include things such as instruction counts, amount of
spilling (if any), maximum number of simultaneous threads, or anything else
which may: aid developers in evaluating the expected performance of a
shader.
To query the compile-time statistics associated with a pipeline executable,
call:

include::{generated}/api/protos/vkGetPipelineExecutableStatisticsKHR.txt[]

  * pname:device is the device that created the pipeline.
  * pname:pExecutableInfo describes the pipeline executable being queried.
  * pname:pStatisticCount is a pointer to an integer related to the number
    of statistics available or queried, as described below.
  * pname:pStatistics is either `NULL` or a pointer to an array of
    slink:VkPipelineExecutableStatisticKHR structures.

If pname:pStatistics is `NULL`, then the number of statistics associated
with the pipeline executable is returned in pname:pStatisticCount.
Otherwise, pname:pStatisticCount must: point to a variable set by the user
to the number of elements in the pname:pStatistics array, and on return the
variable is overwritten with the number of structures actually written to
pname:pStatistics.
If pname:pStatisticCount is less than the number of statistics associated
with the pipeline executable, at most pname:pStatisticCount structures will
be written, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all the available statistics were
returned.

.Valid Usage
****
  * [[VUID-vkGetPipelineExecutableStatisticsKHR-pipelineExecutableInfo-03272]]
    The <<features-pipelineExecutableInfo, pname:pipelineExecutableInfo>>
    feature must: be enabled
  * [[VUID-vkGetPipelineExecutableStatisticsKHR-pipeline-03273]]
    The pname:pipeline member of pname:pExecutableInfo must: have been
    created with pname:device
  * [[VUID-vkGetPipelineExecutableStatisticsKHR-pipeline-03274]]
    The pname:pipeline member of pname:pExecutableInfo must: have been
    created with ename:VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR
****

include::{generated}/validity/protos/vkGetPipelineExecutableStatisticsKHR.txt[]
--

[open,refpage='VkPipelineExecutableInfoKHR',desc='Structure describing a pipeline executable to query for associated statistics or internal representations',type='structs']
--
The sname:VkPipelineExecutableInfoKHR structure is defined as:

include::{generated}/api/structs/VkPipelineExecutableInfoKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipeline is the pipeline to query.
  * pname:executableIndex is the index of the pipeline executable to query
    in the array of executable properties returned by
    flink:vkGetPipelineExecutablePropertiesKHR.

.Valid Usage
****
  * [[VUID-VkPipelineExecutableInfoKHR-executableIndex-03275]]
    pname:executableIndex must: be less than the number of pipeline
    executables associated with pname:pipeline as returned in the
    pname:pExecutableCount parameter of
    fname:vkGetPipelineExecutablePropertiesKHR
****

include::{generated}/validity/structs/VkPipelineExecutableInfoKHR.txt[]
--

[open,refpage='VkPipelineExecutableStatisticKHR',desc='Structure describing a compile-time pipeline executable statistic',type='structs']
--
The sname:VkPipelineExecutableStatisticKHR structure is defined as:

include::{generated}/api/structs/VkPipelineExecutableStatisticKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:name is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a short human
    readable name for this statistic.
  * pname:description is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a human readable
    description for this statistic.
  * pname:format is a elink:VkPipelineExecutableStatisticFormatKHR value
    specifying the format of the data found in pname:value.
  * pname:value is the value of this statistic.

include::{generated}/validity/structs/VkPipelineExecutableStatisticKHR.txt[]
--

[open,refpage='VkPipelineExecutableStatisticFormatKHR',desc='Enum describing a pipeline executable statistic's data format',type='enums']
--
The ename:VkPipelineExecutableStatisticFormatKHR enum is defined as:

include::{generated}/api/enums/VkPipelineExecutableStatisticFormatKHR.txt[]

  * ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR specifies that
    the statistic is returned as a 32-bit boolean value which must: be
    either ename:VK_TRUE or ename:VK_FALSE and should: be read from the
    fname:b32 field of sname:VkPipelineExecutableStatisticValueKHR.
  * ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR specifies that
    the statistic is returned as a signed 64-bit integer and should: be read
    from the fname:i64 field of sname:VkPipelineExecutableStatisticValueKHR.
  * ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR specifies that
    the statistic is returned as an unsigned 64-bit integer and should: be
    read from the fname:u64 field of
    sname:VkPipelineExecutableStatisticValueKHR.
  * ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR specifies that
    the statistic is returned as a 64-bit floating-point value and should:
    be read from the fname:f64 field of
    sname:VkPipelineExecutableStatisticValueKHR.
--

[open,refpage='VkPipelineExecutableStatisticValueKHR',desc='A union describing a pipeline executable statistic's value',type='structs']
--
The sname:VkPipelineExecutableStatisticValueKHR union is defined as:

include::{generated}/api/structs/VkPipelineExecutableStatisticValueKHR.txt[]

  * pname:b32 is the 32-bit boolean value if the
    ename:VkPipelineExecutableStatisticFormatKHR is
    ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR.
  * pname:i64 is the signed 64-bit integer value if the
    ename:VkPipelineExecutableStatisticFormatKHR is
    ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR.
  * pname:u64 is the unsigned 64-bit integer value if the
    ename:VkPipelineExecutableStatisticFormatKHR is
    ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR.
  * pname:f64 is the 64-bit floating-point value if the
    ename:VkPipelineExecutableStatisticFormatKHR is
    ename:VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR.

include::{generated}/validity/structs/VkPipelineExecutableStatisticValueKHR.txt[]
--

[open,refpage='vkGetPipelineExecutableInternalRepresentationsKHR',desc='Get internal representations of the pipeline executable',type='protos']
--
Each pipeline executable may: have one or more text or binary internal
representations associated with it which are generated as part of the
compile process.
These may: include the final shader assembly, a binary form of the compiled
shader, or the shader compiler's internal representation at any number of
intermediate compile steps.
To query the internal representations associated with a pipeline executable,
call:

include::{generated}/api/protos/vkGetPipelineExecutableInternalRepresentationsKHR.txt[]

  * pname:device is the device that created the pipeline.
  * pname:pExecutableInfo describes the pipeline executable being queried.
  * pname:pInternalRepresentationCount is a pointer to an integer related to
    the number of internal representations available or queried, as
    described below.
  * pname:pInternalRepresentations is either `NULL` or a pointer to an array
    of slink:VkPipelineExecutableInternalRepresentationKHR structures.

If pname:pInternalRepresentations is `NULL`, then the number of internal
representations associated with the pipeline executable is returned in
pname:pInternalRepresentationCount.
Otherwise, pname:pInternalRepresentationCount must: point to a variable set
by the user to the number of elements in the pname:pInternalRepresentations
array, and on return the variable is overwritten with the number of
structures actually written to pname:pInternalRepresentations.
If pname:pInternalRepresentationCount is less than the number of internal
representations associated with the pipeline executable, at most
pname:pInternalRepresentationCount structures will be written, and
ename:VK_INCOMPLETE will be returned instead of ename:VK_SUCCESS, to
indicate that not all the available representations were returned.

While the details of the internal representations remain
implementation-dependent, the implementation should: order the internal
representations in the order in which they occur in the compiled pipeline
with the final shader assembly (if any) last.

.Valid Usage
****
  * [[VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pipelineExecutableInfo-03276]]
    The <<features-pipelineExecutableInfo, pname:pipelineExecutableInfo>>
    feature must: be enabled
  * [[VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pipeline-03277]]
    The pname:pipeline member of pname:pExecutableInfo must: have been
    created with pname:device
  * [[VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pipeline-03278]]
    The pname:pipeline member of pname:pExecutableInfo must: have been
    created with
    ename:VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
****

include::{generated}/validity/protos/vkGetPipelineExecutableInternalRepresentationsKHR.txt[]
--

[open,refpage='VkPipelineExecutableInternalRepresentationKHR',desc='Structure describing the textual form of a pipeline executable internal representation',type='structs']
--
The sname:VkPipelineExecutableInternalRepresentationKHR structure is defined
as:

include::{generated}/api/structs/VkPipelineExecutableInternalRepresentationKHR.txt[]

  * pname:sType is the type of this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:name is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a short human
    readable name for this internal representation.
  * pname:description is an array of ename:VK_MAX_DESCRIPTION_SIZE code:char
    containing a null-terminated UTF-8 string which is a human readable
    description for this internal representation.
  * pname:isText specifies whether the returned data is text or opaque data.
    If pname:isText is ename:VK_TRUE then the data returned in pname:pData
    is text and is guaranteed to be a null-terminated UTF-8 string.
  * pname:dataSize is an integer related to the size, in bytes, of the
    internal representation's data, as described below.
  * pname:pData is either `NULL` or a pointer to a block of data into which
    the implementation will write the internal representation.

If pname:pData is `NULL`, then the size, in bytes, of the internal
representation data is returned in pname:dataSize.
Otherwise, pname:dataSize must be the size of the buffer, in bytes, pointed
to by pname:pData and on return pname:dataSize is overwritten with the
number of bytes of data actually written to pname:pData including any
trailing null character.
If pname:dataSize is less than the size, in bytes, of the internal
representation's data, at most pname:dataSize bytes of data will be written
to pname:pData, and ename:VK_INCOMPLETE will be returned instead of
ename:VK_SUCCESS, to indicate that not all the available representation was
returned.

If pname:isText is ename:VK_TRUE and pname:pData is not `NULL` and
pname:dataSize is not zero, the last byte written to pname:pData will be a
null character.

include::{generated}/validity/structs/VkPipelineExecutableInternalRepresentationKHR.txt[]
--
endif::VK_KHR_pipeline_executable_properties[]


ifdef::VK_AMD_shader_info[]
include::{chapters}/VK_AMD_shader_info.txt[]
endif::VK_AMD_shader_info[]


// These includes have their own section headers

ifdef::VK_AMD_pipeline_compiler_control[]
include::{chapters}/VK_AMD_pipeline_compiler_control.txt[]
endif::VK_AMD_pipeline_compiler_control[]

ifdef::VK_VERSION_1_3,VK_EXT_pipeline_creation_feedback[]
include::{chapters}/VK_EXT_pipeline_creation_feedback/pipelines.txt[]
endif::VK_VERSION_1_3,VK_EXT_pipeline_creation_feedback[]
