// Copyright (c) 2019-2020 NVIDIA Corporation
// Copyright (c) 2024 VALVE Corporation
// SPDX-License-Identifier: CC-BY-4.0

[[device-generated-commands]]
= Device-Generated Commands

This chapter discusses the generation of command buffer content on the
device, for which these principle steps are to be taken:

  * Define a layout describing the sequence of commands which should be
    generated.
  * Optionally set up device-bindable shaders.
  * Retrieve device addresses by flink:vkGetBufferDeviceAddressEXT for
    setting buffers on the device.
  * Fill one or more sname:VkBuffer with the appropriate content that gets
    interpreted by the command layout.
  * Create a `preprocess` sname:VkBuffer using the device-queried allocation
    information.
  * Optionally preprocess the input data in a separate action.
  * Generate and execute the actual commands.

The preprocessing step executes in a separate logical pipeline from either
graphics or compute.
When preprocessing commands in a separate step they must: be explicitly
synchronized against the command execution.
When not preprocessing in a separate step, the preprocessing is
automatically synchronized against the command execution.


[[indirectmdslayout]]
== Indirect Commands Layout

The device-side command generation happens through an iterative processing
of an atomic sequence comprised of command tokens, which are represented by:

ifdef::VK_EXT_device_generated_commands[]
[open,refpage='VkIndirectCommandsLayoutEXT',desc='Opaque handle to an indirect commands layout object',type='handles']
--
include::{generated}/api/handles/VkIndirectCommandsLayoutEXT.adoc[]
--
endif::VK_EXT_device_generated_commands[]

ifdef::VK_EXT_device_generated_commands+VK_NV_device_generated_commands[or:]

ifdef::VK_NV_device_generated_commands[]
[open,refpage='VkIndirectCommandsLayoutNV',desc='Opaque handle to an indirect commands layout object',type='handles']
--
include::{generated}/api/handles/VkIndirectCommandsLayoutNV.adoc[]
--
endif::VK_NV_device_generated_commands[]

Each indirect command layout must: have exactly one action command token and
it must: be the last token in the sequence.

[NOTE]
====
If the indirect commands layout contains only 1 token, it will be an action
command token, and the contents of the indirect buffer will be a sequence of
indirect command structures, similar to the ones used for indirect draws and
dispatches.
On some implementations, using indirect draws and dispatches for these cases
will result in increased performance compared to using device-generated
commands, due to the overhead that results from using the latter.
====


=== Creation and Deletion

ifdef::VK_EXT_device_generated_commands[]
[open,refpage='vkCreateIndirectCommandsLayoutEXT',desc='Create an indirect command layout object',type='protos']
--
Indirect command layouts for `apiext:VK_EXT_device_generated_commands` are
created by:

include::{generated}/api/protos/vkCreateIndirectCommandsLayoutEXT.adoc[]

  * pname:device is the logical device that creates the indirect command
    layout.
  * pname:pCreateInfo is a pointer to a
    slink:VkIndirectCommandsLayoutCreateInfoEXT structure containing
    parameters affecting creation of the indirect command layout.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pIndirectCommandsLayout is a pointer to a
    sname:VkIndirectCommandsLayoutEXT handle in which the resulting indirect
    command layout is returned.

.Valid Usage
****
  * [[VUID-vkCreateIndirectCommandsLayoutEXT-deviceGeneratedCommands-11089]]
    The <<features-deviceGeneratedCommands,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::pname:deviceGeneratedCommands>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkCreateIndirectCommandsLayoutEXT.adoc[]
--

[open,refpage='VkIndirectCommandsLayoutCreateInfoEXT',desc='Structure specifying the parameters of a newly created indirect commands layout object',type='structs']
--
The sname:VkIndirectCommandsLayoutCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkIndirectCommandsLayoutCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:flags is a bitmask of
    elink:VkIndirectCommandsLayoutUsageFlagBitsEXT specifying usage rules
    for this layout.
  * pname:shaderStages is the tlink:VkShaderStageFlags that this layout
    supports.
  * pname:indirectStride is the distance in bytes between sequences in the
    indirect buffer
  * pname:pipelineLayout is the optional slink:VkPipelineLayout that tokens
    in this layout use.
    If the <<features-dynamicGeneratedPipelineLayout,
    pname:dynamicGeneratedPipelineLayout>> feature is enabled,
    pname:pipelineLayout can: be dlink:VK_NULL_HANDLE and the layout must:
    be specified by chaining the slink:VkPipelineLayoutCreateInfo structure
    off the pname:pNext.
ifdef::VK_EXT_descriptor_heap[]
    If the <<features-descriptorHeap, pname:descriptorHeap>> feature is
    enabled, pname:pipelineLayout can: be dlink:VK_NULL_HANDLE without
    providing a slink:VkPipelineLayoutCreateInfo structure.
endif::VK_EXT_descriptor_heap[]
  * pname:tokenCount is the length of the individual command sequence.
  * pname:pTokens is a pointer to an array of
    slink:VkIndirectCommandsLayoutTokenEXT describing each command token in
    detail.

The following code illustrates some of the flags:

[source,c]
----
void cmdProcessAllSequences(cmd, indirectExecutionSet, indirectCommandsLayout, indirectAddress, sequencesCount)
{
  for (s = 0; s < sequencesCount; s++)
  {
    sUsed = s;

    if (indirectCommandsLayout.flags & VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT) {
      sUsed = incoherent_implementation_dependent_permutation[ sUsed ];
    }

    cmdProcessSequence( cmd, indirectExecutionSet, indirectCommandsLayout, indirectAddress, sUsed );
  }
}
----

When tokens are consumed, an offset is computed based on token offset and
stream stride.
The resulting offset is required to be aligned.
The alignment for a specific token is equal to the scalar alignment of the
data type as defined in <<interfaces-alignment-requirements,Alignment
Requirements>>, or `4`, whichever is lower.

.Valid Usage
****
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-indirectStride-11090]]
    pname:indirectStride must: be less than or equal to
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:maxIndirectCommandsIndirectStride
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-shaderStages-11091]]
    pname:shaderStages must: only contain stages supported by
    <<limits-supportedIndirectCommandsShaderStages,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:supportedIndirectCommandsShaderStages>>
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-tokenCount-11092]]
    pname:tokenCount must: be less than or equal to
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:maxIndirectCommandsTokenCount
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11093]]
    The number of tokens in the pname:pTokens array with pname:type equal to
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT must: be less
    than or equal to `1`
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11145]]
    The number of tokens in the pname:pTokens array with pname:type equal to
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT must: be less
    than or equal to `1`
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11094]]
    The number of tokens in the pname:pTokens array with pname:type equal to
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT
ifdef::VK_EXT_descriptor_heap[or ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT]
    must: be less than or equal to `1`
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11095]]
    If the action command token in the pname:pTokens array is not an indexed
    draw token, then pname:pTokens must: not contain a member with
    pname:type set to ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11096]]
    If the action command token in the pname:pTokens array is not a non-mesh
    draw token, then pname:pTokens must: not contain a member with
    pname:type set to
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11097]]
    If the pname:pTokens array contains multiple tokens with pname:type
    equal to ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT, then
    there must: be no duplicate
    slink:VkIndirectCommandsVertexBufferTokenEXT::pname:vertexBindingUnit
    values
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11099]]
    For all ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,
ifdef::VK_EXT_descriptor_heap[ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_EXT, ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT,]
    and ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT type tokens
    in pname:pTokens, there must: be no overlapping ranges between any
    specified push constant ranges
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11100]]
    The action command token must: be the last token in the pname:pTokens
    array
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11139]]
    If the pname:pTokens array contains a
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, then this
    token must: be the first token in the array
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11101]]
    For any element of pname:pTokens, if pname:type is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT or
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT and the
    <<features-dynamicGeneratedPipelineLayout,
    pname:dynamicGeneratedPipelineLayout>> feature is not enabled, then the
    pname:pipelineLayout must: not be dlink:VK_NULL_HANDLE
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11102]]
    For any element of pname:pTokens, if pname:type is either
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT or
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT and
    pname:pipelineLayout is dlink:VK_NULL_HANDLE, then the pname:pNext chain
    must: include a slink:VkPipelineLayoutCreateInfo struct
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11103]]
    For any element of pname:pTokens, the pname:offset must: be greater than
    or equal to the pname:offset member of the previous tokens
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11104]]
    For any element of pname:pTokens, if pname:type is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT,
ifdef::VK_EXT_mesh_shader[]
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT,
endif::VK_EXT_mesh_shader[]
ifdef::VK_NV_mesh_shader[]
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT,
endif::VK_NV_mesh_shader[]
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT, or
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT, then pname:shaderStages
    must: contain graphics stages
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11105]]
    For any element of pname:pTokens, if pname:type is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT, then
    pname:shaderStages must: be ename:VK_SHADER_STAGE_COMPUTE_BIT
ifdef::VK_EXT_mesh_shader[]
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11106]]
    For any element of pname:pTokens, if pname:type is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT or
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT, then
    pname:shaderStages must: contain ename:VK_SHADER_STAGE_MESH_BIT_EXT
endif::VK_EXT_mesh_shader[]
ifdef::VK_NV_mesh_shader[]
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11107]]
    For any element of pname:pTokens, if pname:type is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT or
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT, then
    the pname:shaderStages must: contain ename:VK_SHADER_STAGE_MESH_BIT_NV
endif::VK_NV_mesh_shader[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-11108]]
    For any element of pname:pTokens, if pname:type is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT, then
    pname:shaderStages must: contain ray tracing stages
endif::VK_KHR_ray_tracing_pipeline[]
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-shaderStages-11109]]
    If pname:shaderStages contains graphics stages then the state tokens in
    pname:pTokens must: not include
ifdef::VK_KHR_ray_tracing_maintenance1[ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT,]
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-shaderStages-11110]]
    If pname:shaderStages is ename:VK_SHADER_STAGE_COMPUTE_BIT then the
    state tokens in pname:pTokens must: only include
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,
ifdef::VK_EXT_descriptor_heap[ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_EXT, ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT,]
    or ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT
ifdef::VK_KHR_ray_tracing_maintenance1[]
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-shaderStages-11111]]
    If pname:shaderStages contains ray tracing stages then the state tokens
    in pname:pTokens must: only include
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,
ifdef::VK_EXT_descriptor_heap[ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_EXT, ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT,]
    or ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT
endif::VK_KHR_ray_tracing_maintenance1[]
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-shaderStages-11112]]
    The pname:shaderStages must: only contain stages from one of the
    following:
ifdef::VK_EXT_descriptor_heap[]
  ** ename:VK_SHADER_STAGE_ALL (if the <<features-descriptorHeap,
     pname:descriptorHeap>> feature is enabled)
endif::VK_EXT_descriptor_heap[]
  ** graphics stages
  ** ename:VK_SHADER_STAGE_COMPUTE_BIT
ifdef::VK_EXT_mesh_shader,VK_NV_mesh_shader[]
  ** mesh stages and ename:VK_SHADER_STAGE_FRAGMENT_BIT
endif::VK_EXT_mesh_shader,VK_NV_mesh_shader[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  ** ray tracing stages
endif::VK_KHR_ray_tracing_pipeline[]
  * [[VUID-VkIndirectCommandsLayoutCreateInfoEXT-shaderStages-11113]]
    If pname:shaderStages contains ename:VK_SHADER_STAGE_FRAGMENT_BIT, then
    pname:shaderStages must: also contain ename:VK_SHADER_STAGE_VERTEX_BIT
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
    or ename:VK_SHADER_STAGE_MESH_BIT_EXT
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
****

include::{generated}/validity/structs/VkIndirectCommandsLayoutCreateInfoEXT.adoc[]
--

[open,refpage='VkIndirectCommandsLayoutUsageFlagBitsEXT',desc='Bitmask specifying allowed usage of an indirect commands layout',type='enums']
--
Bits which can: be set in
slink:VkIndirectCommandsLayoutCreateInfoEXT::pname:flags, specifying usage
hints of an indirect command layout, are:

include::{generated}/api/enums/VkIndirectCommandsLayoutUsageFlagBitsEXT.adoc[]

  * ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT
    specifies that the layout is always used with the manual preprocessing
    step through calling flink:vkCmdPreprocessGeneratedCommandsEXT and
    executed by flink:vkCmdExecuteGeneratedCommandsEXT with
    pname:isPreprocessed set to ename:VK_TRUE.
  * ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT
    specifies that the processing of sequences will happen at an
    implementation-dependent order, which is not guaranteed to be
    deterministic using the same input data.
    This flag is ignored when the pname:shaderStages is
    ename:VK_SHADER_STAGE_COMPUTE_BIT as it is implied that the dispatch
    sequence is always unordered.
--

[open,refpage='VkIndirectCommandsLayoutUsageFlagsEXT',desc='Bitmask of VkIndirectCommandsLayoutUsageFlagBitsEXT',type='flags']
--
include::{generated}/api/flags/VkIndirectCommandsLayoutUsageFlagsEXT.adoc[]

tname:VkIndirectCommandsLayoutUsageFlagsEXT is a bitmask type for setting a
mask of zero or more elink:VkIndirectCommandsLayoutUsageFlagBitsEXT.
--

[open,refpage='vkDestroyIndirectCommandsLayoutEXT',desc='Destroy an indirect commands layout',type='protos']
--
Indirect command layouts for `apiext:VK_EXT_device_generated_commands` are
destroyed by:

include::{generated}/api/protos/vkDestroyIndirectCommandsLayoutEXT.adoc[]

  * pname:device is the logical device that destroys the layout.
  * pname:indirectCommandsLayout is the layout to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyIndirectCommandsLayoutEXT-indirectCommandsLayout-11114]]
    All submitted commands that refer to pname:indirectCommandsLayout must:
    have completed execution
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkDestroyIndirectCommandsLayoutEXT-indirectCommandsLayout-11115]]
    If sname:VkAllocationCallbacks were provided when
    pname:indirectCommandsLayout was created, a compatible set of callbacks
    must: be provided here
  * [[VUID-vkDestroyIndirectCommandsLayoutEXT-indirectCommandsLayout-11116]]
    If no sname:VkAllocationCallbacks were provided when
    pname:indirectCommandsLayout was created, pname:pAllocator must: be
    `NULL`
endif::VKSC_VERSION_1_0[]
****

include::{generated}/validity/protos/vkDestroyIndirectCommandsLayoutEXT.adoc[]
--
endif::VK_EXT_device_generated_commands[]

ifdef::VK_NV_device_generated_commands[]

[open,refpage='vkCreateIndirectCommandsLayoutNV',desc='Create an indirect command layout object',type='protos']
--
Indirect command layouts for `apiext:VK_NV_device_generated_commands` are
created by:

include::{generated}/api/protos/vkCreateIndirectCommandsLayoutNV.adoc[]

  * pname:device is the logical device that creates the indirect command
    layout.
  * pname:pCreateInfo is a pointer to a
    slink:VkIndirectCommandsLayoutCreateInfoNV structure containing
    parameters affecting creation of the indirect command layout.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pIndirectCommandsLayout is a pointer to a
    sname:VkIndirectCommandsLayoutNV handle in which the resulting indirect
    command layout is returned.

.Valid Usage
****
  * [[VUID-vkCreateIndirectCommandsLayoutNV-deviceGeneratedCommands-02929]]
    The <<features-deviceGeneratedCommandsNV,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::pname:deviceGeneratedCommands>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkCreateIndirectCommandsLayoutNV.adoc[]
--

[open,refpage='VkIndirectCommandsLayoutCreateInfoNV',desc='Structure specifying the parameters of a newly created indirect commands layout object',type='structs']
--
The sname:VkIndirectCommandsLayoutCreateInfoNV structure is defined as:

include::{generated}/api/structs/VkIndirectCommandsLayoutCreateInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipelineBindPoint is the elink:VkPipelineBindPoint that this
    layout targets.
  * pname:flags is a bitmask of
    elink:VkIndirectCommandsLayoutUsageFlagBitsNV specifying usage hints of
    this layout.
  * pname:tokenCount is the length of the individual command sequence.
  * pname:pTokens is an array describing each command token in detail.
    See elink:VkIndirectCommandsTokenTypeNV and
    slink:VkIndirectCommandsLayoutTokenNV below for details.
  * pname:streamCount is the number of streams used to provide the token
    inputs.
  * pname:pStreamStrides is an array defining the byte stride for each input
    stream.

The following code illustrates some of the flags:

[source,c]
----
void cmdProcessAllSequences(cmd, pipeline, indirectCommandsLayout, pIndirectCommandsTokens, sequencesCount, indexbuffer, indexbufferOffset)
{
  for (s = 0; s < sequencesCount; s++)
  {
    sUsed = s;

    if (indirectCommandsLayout.flags & VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV) {
      sUsed = indexbuffer.load_uint32( sUsed * sizeof(uint32_t) + indexbufferOffset);
    }

    if (indirectCommandsLayout.flags & VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV) {
      sUsed = incoherent_implementation_dependent_permutation[ sUsed ];
    }

    cmdProcessSequence( cmd, pipeline, indirectCommandsLayout, pIndirectCommandsTokens, sUsed );
  }
}
----

When tokens are consumed, an offset is computed based on token offset and
stream stride.
The resulting offset is required to be aligned.
The alignment for a specific token is equal to the scalar alignment of the
data type as defined in <<interfaces-alignment-requirements,Alignment
Requirements>>, or
sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:minIndirectCommandsBufferOffsetAlignment,
whichever is lower.

[NOTE]
====
A pname:minIndirectCommandsBufferOffsetAlignment of 4 allows
basetype:VkDeviceAddress to be packed as code:uvec2 with scalar layout
instead of code:uint64_t with 8 byte alignment.
This enables direct compatibility with D3D12 command signature layouts.
====

.Valid Usage
****
  * [[VUID-VkIndirectCommandsLayoutCreateInfoNV-pipelineBindPoint-02930]]
    The pname:pipelineBindPoint must: be
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS
ifdef::VK_NV_device_generated_commands_compute[]
    or ename:VK_PIPELINE_BIND_POINT_COMPUTE
endif::VK_NV_device_generated_commands_compute[]
  * [[VUID-VkIndirectCommandsLayoutCreateInfoNV-tokenCount-02931]]
    pname:tokenCount must: be greater than `0` and less than or equal to
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:maxIndirectCommandsTokenCount
  * [[VUID-VkIndirectCommandsLayoutCreateInfoNV-pTokens-02932]]
    If pname:pTokens contains an entry of
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV it must: be the
    first element of the array and there must: be only a single element of
    such token type
ifdef::VK_NV_device_generated_commands_compute[]
  * [[VUID-VkIndirectCommandsLayoutCreateInfoNV-pTokens-09585]]
    If pname:pTokens contains an entry of
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV it must: be the first
    element of the array and there must: be only a single element of such
    token type
endif::VK_NV_device_generated_commands_compute[]
  * [[VUID-VkIndirectCommandsLayoutCreateInfoNV-pTokens-02933]]
    If pname:pTokens contains an entry of
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV there must: be only
    a single element of such token type
  * [[VUID-VkIndirectCommandsLayoutCreateInfoNV-pTokens-02934]]
    All state tokens in pname:pTokens must: occur before any action command
    tokens (ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV
ifdef::VK_NV_device_generated_commands_compute[]
    , ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV
endif::VK_NV_device_generated_commands_compute[]
    )
  * [[VUID-VkIndirectCommandsLayoutCreateInfoNV-pTokens-02935]]
    The content of pname:pTokens must: include one single action command
    token that is compatible with the pname:pipelineBindPoint
  * [[VUID-VkIndirectCommandsLayoutCreateInfoNV-streamCount-02936]]
    pname:streamCount must: be greater than `0` and less or equal to
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:maxIndirectCommandsStreamCount
  * [[VUID-VkIndirectCommandsLayoutCreateInfoNV-pStreamStrides-02937]]
    each element of pname:pStreamStrides must: be greater than `0` and less
    than or equal to
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:maxIndirectCommandsStreamStride.
    Furthermore the alignment of each token input must: be ensured
ifdef::VK_NV_device_generated_commands_compute[]
  * [[VUID-VkIndirectCommandsLayoutCreateInfoNV-pipelineBindPoint-09088]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_COMPUTE then
    the <<features-deviceGeneratedCompute,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::pname:deviceGeneratedCompute>>
    feature must: be enabled
  * [[VUID-VkIndirectCommandsLayoutCreateInfoNV-pipelineBindPoint-09089]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_COMPUTE then
    the state tokens in pname:pTokens must: only include
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV,
ifdef::VK_EXT_descriptor_heap[]
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_NV,
endif::VK_EXT_descriptor_heap[]
    or ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV
  * [[VUID-VkIndirectCommandsLayoutCreateInfoNV-pipelineBindPoint-09090]]
    If pname:pipelineBindPoint is ename:VK_PIPELINE_BIND_POINT_COMPUTE and
    pname:pTokens includes
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV, then the
    <<features-deviceGeneratedComputePipelines,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::pname:deviceGeneratedComputePipelines>>
    feature must: be enabled
endif::VK_NV_device_generated_commands_compute[]
****

include::{generated}/validity/structs/VkIndirectCommandsLayoutCreateInfoNV.adoc[]
--

[open,refpage='VkIndirectCommandsLayoutUsageFlagBitsNV',desc='Bitmask specifying allowed usage of an indirect commands layout',type='enums']
--
Bits which can: be set in
slink:VkIndirectCommandsLayoutCreateInfoNV::pname:flags, specifying usage
hints of an indirect command layout, are:

include::{generated}/api/enums/VkIndirectCommandsLayoutUsageFlagBitsNV.adoc[]

  * ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV
    specifies that the layout is always used with the manual preprocessing
    step through calling flink:vkCmdPreprocessGeneratedCommandsNV and
    executed by flink:vkCmdExecuteGeneratedCommandsNV with
    pname:isPreprocessed set to ename:VK_TRUE.
  * ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV
    specifies that the input data for the sequences is not implicitly
    indexed from 0..sequencesUsed, but an application-provided
    sname:VkBuffer encoding the index is provided.
  * ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV
    specifies that the processing of sequences can: happen at an
    implementation-dependent order, which is not guaranteed to be coherent
    using the same input data.
ifdef::VK_NV_device_generated_commands_compute[]
    This flag is ignored when the pname:pipelineBindPoint is
    ename:VK_PIPELINE_BIND_POINT_COMPUTE as it is implied that the dispatch
    sequence is always unordered.
endif::VK_NV_device_generated_commands_compute[]
--

[open,refpage='VkIndirectCommandsLayoutUsageFlagsNV',desc='Bitmask of VkIndirectCommandsLayoutUsageFlagBitsNV',type='flags']
--
include::{generated}/api/flags/VkIndirectCommandsLayoutUsageFlagsNV.adoc[]

tname:VkIndirectCommandsLayoutUsageFlagsNV is a bitmask type for setting a
mask of zero or more elink:VkIndirectCommandsLayoutUsageFlagBitsNV.
--

[open,refpage='vkDestroyIndirectCommandsLayoutNV',desc='Destroy an indirect commands layout',type='protos']
--
Indirect command layouts for `apiext:VK_NV_device_generated_commands` are
destroyed by:

include::{generated}/api/protos/vkDestroyIndirectCommandsLayoutNV.adoc[]

  * pname:device is the logical device that destroys the layout.
  * pname:indirectCommandsLayout is the layout to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyIndirectCommandsLayoutNV-indirectCommandsLayout-02938]]
    All submitted commands that refer to pname:indirectCommandsLayout must:
    have completed execution
ifndef::VKSC_VERSION_1_0[]
  * [[VUID-vkDestroyIndirectCommandsLayoutNV-indirectCommandsLayout-02939]]
    If sname:VkAllocationCallbacks were provided when
    pname:indirectCommandsLayout was created, a compatible set of callbacks
    must: be provided here
  * [[VUID-vkDestroyIndirectCommandsLayoutNV-indirectCommandsLayout-02940]]
    If no sname:VkAllocationCallbacks were provided when
    pname:indirectCommandsLayout was created, pname:pAllocator must: be
    `NULL`
endif::VKSC_VERSION_1_0[]
  * [[VUID-vkDestroyIndirectCommandsLayoutNV-deviceGeneratedCommands-02941]]
    The <<features-deviceGeneratedCommandsNV,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::pname:deviceGeneratedCommands>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkDestroyIndirectCommandsLayoutNV.adoc[]
--
endif::VK_NV_device_generated_commands[]


=== Token Input Streams

ifdef::VK_EXT_device_generated_commands[]
For `apiext:VK_EXT_device_generated_commands`, the input streams can:
contain raw `uint32_t` values, existing indirect commands such as:

  * slink:VkDrawIndirectCommand
  * slink:VkDrawIndexedIndirectCommand
  * slink:VkDispatchIndirectCommand
ifdef::VK_NV_mesh_shader[]
  * slink:VkDrawMeshTasksIndirectCommandNV
endif::VK_NV_mesh_shader[]
ifdef::VK_EXT_mesh_shader[]
  * slink:VkDrawMeshTasksIndirectCommandEXT
endif::VK_EXT_mesh_shader[]
ifdef::VK_KHR_ray_tracing_pipeline[]
  * slink:VkTraceRaysIndirectCommandKHR
endif::VK_KHR_ray_tracing_pipeline[]
ifdef::VK_KHR_ray_tracing_maintenance1[]
  * slink:VkTraceRaysIndirectCommand2KHR
endif::VK_KHR_ray_tracing_maintenance1[]

or additional commands as listed below.
How the data is used is described in the next section.

[open,refpage='VkBindIndexBufferIndirectCommandEXT',desc='Structure specifying input data for a single index buffer command token',type='structs']
--
The sname:VkBindIndexBufferIndirectCommandEXT structure specifies the input
data for the ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT token.

include::{generated}/api/structs/VkBindIndexBufferIndirectCommandEXT.adoc[]

  * pname:bufferAddress specifies a physical address of the slink:VkBuffer
    used as index buffer.
  * pname:size is the byte size range which is available for this operation
    from the provided address.
  * pname:indexType is a elink:VkIndexType value specifying how indices are
    treated.

.Valid Usage
****
  * [[VUID-VkBindIndexBufferIndirectCommandEXT-None-11117]]
    The buffer's usage flags from which the address was acquired must: have
    the ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT bit set
  * [[VUID-VkBindIndexBufferIndirectCommandEXT-bufferAddress-11118]]
    The pname:bufferAddress must: be aligned to the elink:VkIndexType of the
    pname:indexType used
****

include::{generated}/validity/structs/VkBindIndexBufferIndirectCommandEXT.adoc[]
--

[open,refpage='VkBindVertexBufferIndirectCommandEXT',desc='Structure specifying input data for a single vertex buffer command token',type='structs']
--
The sname:VkBindVertexBufferIndirectCommandEXT structure specifies the input
data for the ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT token.

include::{generated}/api/structs/VkBindVertexBufferIndirectCommandEXT.adoc[]

  * pname:bufferAddress specifies a physical address of the slink:VkBuffer
    used as vertex input binding.
  * pname:size is the byte size range which is available for this operation
    from the provided address.
  * pname:stride is the byte size stride for this vertex input binding as in
    sname:VkVertexInputBindingDescription::pname:stride.

.Valid Usage
****
  * [[VUID-VkBindVertexBufferIndirectCommandEXT-None-11120]]
    The buffer's usage flag from which the address was acquired must: have
    the ename:VK_BUFFER_USAGE_VERTEX_BUFFER_BIT bit set
****

include::{generated}/validity/structs/VkBindVertexBufferIndirectCommandEXT.adoc[]
--

[open,refpage='VkDrawIndirectCountIndirectCommandEXT',desc='Structure specifying input data for a single draw-type command token',type='structs']
--
The sname:VkDrawIndirectCountIndirectCommandEXT structure specifies the
input data for all draw-type tokens.

include::{generated}/api/structs/VkDrawIndirectCountIndirectCommandEXT.adoc[]

  * pname:bufferAddress specifies a physical address of the slink:VkBuffer
    used for draw commands.
  * pname:stride is the byte size stride for the command arguments
  * pname:commandCount is the number of commands to execute

The corresponding indirect draw structure data will be read from the buffer
address.

.Valid Usage
****
  * [[VUID-VkDrawIndirectCountIndirectCommandEXT-None-11122]]
    The buffer's usage flag from which the address was acquired must: have
    the ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
****

include::{generated}/validity/structs/VkDrawIndirectCountIndirectCommandEXT.adoc[]
--

endif::VK_EXT_device_generated_commands[]
ifdef::VK_NV_device_generated_commands[]

[open,refpage='VkIndirectCommandsStreamNV',desc='Structure specifying input streams for generated command tokens',type='structs']
--
The sname:VkIndirectCommandsStreamNV structure specifies the input data for
one or more tokens at processing time.

include::{generated}/api/structs/VkIndirectCommandsStreamNV.adoc[]

  * pname:buffer specifies the slink:VkBuffer storing the functional
    arguments for each sequence.
    These arguments can: be written by the device.
  * pname:offset specified an offset into pname:buffer where the arguments
    start.

.Valid Usage
****
  * [[VUID-VkIndirectCommandsStreamNV-buffer-02942]]
    The pname:buffer's usage flag must: have the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-VkIndirectCommandsStreamNV-offset-02943]]
    The pname:offset must: be aligned to
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:minIndirectCommandsBufferOffsetAlignment
  * [[VUID-VkIndirectCommandsStreamNV-buffer-02975]]
    If pname:buffer is non-sparse then it must: be bound completely and
    contiguously to a single sname:VkDeviceMemory object
****

include::{generated}/validity/structs/VkIndirectCommandsStreamNV.adoc[]
--

For `apiext:VK_NV_device_generated_commands`, the input streams can: contain
raw `uint32_t` values, existing indirect commands such as:

  * slink:VkDrawIndirectCommand
  * slink:VkDrawIndexedIndirectCommand
ifdef::VK_NV_mesh_shader[]
  * slink:VkDrawMeshTasksIndirectCommandNV
endif::VK_NV_mesh_shader[]
ifdef::VK_EXT_mesh_shader[]
  * slink:VkDrawMeshTasksIndirectCommandEXT
endif::VK_EXT_mesh_shader[]
ifdef::VK_NV_device_generated_commands_compute[]
  * slink:VkDispatchIndirectCommand
endif::VK_NV_device_generated_commands_compute[]

or additional commands as listed below.
How the data is used is described in the next section.

[open,refpage='VkBindShaderGroupIndirectCommandNV',desc='Structure specifying input data for a single shader group command token',type='structs']
--
The sname:VkBindShaderGroupIndirectCommandNV structure specifies the input
data for the ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV token.

include::{generated}/api/structs/VkBindShaderGroupIndirectCommandNV.adoc[]

  * pname:groupIndex specifies which shader group of the current bound
    graphics pipeline is used.

.Valid Usage
****
  * [[VUID-VkBindShaderGroupIndirectCommandNV-None-02944]]
    The current bound graphics pipeline, as well as the pipelines it may
    reference, must: have been created with
    ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV
  * [[VUID-VkBindShaderGroupIndirectCommandNV-index-02945]]
    The pname:index must: be within range of the accessible shader groups of
    the current bound graphics pipeline.
    See flink:vkCmdBindPipelineShaderGroupNV for further details
****

include::{generated}/validity/structs/VkBindShaderGroupIndirectCommandNV.adoc[]
--

[open,refpage='VkBindIndexBufferIndirectCommandNV',desc='Structure specifying input data for a single index buffer command token',type='structs']
--
The sname:VkBindIndexBufferIndirectCommandNV structure specifies the input
data for the ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV token.

include::{generated}/api/structs/VkBindIndexBufferIndirectCommandNV.adoc[]

  * pname:bufferAddress specifies a physical address of the slink:VkBuffer
    used as index buffer.
  * pname:size is the byte size range which is available for this operation
    from the provided address.
  * pname:indexType is a elink:VkIndexType value specifying how indices are
    treated.
    Instead of the Vulkan enum values, a custom `uint32_t` value can: be
    mapped to elink:VkIndexType by specifying the
    sname:VkIndirectCommandsLayoutTokenNV::pname:pIndexTypes and
    sname:VkIndirectCommandsLayoutTokenNV::pname:pIndexTypeValues arrays.

.Valid Usage
****
  * [[VUID-VkBindIndexBufferIndirectCommandNV-None-02946]]
    The buffer's usage flag from which the address was acquired must: have
    the ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT bit set
  * [[VUID-VkBindIndexBufferIndirectCommandNV-bufferAddress-02947]]
    The pname:bufferAddress must: be aligned to the pname:indexType used
****

include::{generated}/validity/structs/VkBindIndexBufferIndirectCommandNV.adoc[]
--

[open,refpage='VkBindVertexBufferIndirectCommandNV',desc='Structure specifying input data for a single vertex buffer command token',type='structs']
--
The sname:VkBindVertexBufferIndirectCommandNV structure specifies the input
data for the ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV token.

include::{generated}/api/structs/VkBindVertexBufferIndirectCommandNV.adoc[]

  * pname:bufferAddress specifies a physical address of the slink:VkBuffer
    used as vertex input binding.
  * pname:size is the byte size range which is available for this operation
    from the provided address.
  * pname:stride is the byte size stride for this vertex input binding as in
    sname:VkVertexInputBindingDescription::pname:stride.
    It is only used if
    sname:VkIndirectCommandsLayoutTokenNV::pname:vertexDynamicStride was
    set, otherwise the stride is inherited from the current bound graphics
    pipeline.

.Valid Usage
****
  * [[VUID-VkBindVertexBufferIndirectCommandNV-None-02949]]
    The buffer's usage flag from which the address was acquired must: have
    the ename:VK_BUFFER_USAGE_VERTEX_BUFFER_BIT bit set
****

include::{generated}/validity/structs/VkBindVertexBufferIndirectCommandNV.adoc[]
--

[open,refpage='VkSetStateFlagsIndirectCommandNV',desc='Structure specifying input data for a single state flag command token',type='structs']
--
The sname:VkSetStateFlagsIndirectCommandNV structure specifies the input
data for the ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV token.
Which state is changed depends on the elink:VkIndirectStateFlagBitsNV
specified at sname:VkIndirectCommandsLayoutNV creation time.

include::{generated}/api/structs/VkSetStateFlagsIndirectCommandNV.adoc[]

  * pname:data encodes packed state that this command alters.
  ** Bit `0`: If set represents ename:VK_FRONT_FACE_CLOCKWISE, otherwise
     ename:VK_FRONT_FACE_COUNTER_CLOCKWISE

include::{generated}/validity/structs/VkSetStateFlagsIndirectCommandNV.adoc[]
--

[open,refpage='VkIndirectStateFlagBitsNV',desc='Bitmask specifying state that can be altered on the device',type='enums']
--
A subset of the graphics pipeline state can: be altered using indirect state
flags:

include::{generated}/api/enums/VkIndirectStateFlagBitsNV.adoc[]

  * ename:VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV allows to toggle the
    elink:VkFrontFace rasterization state for subsequent drawing commands.
--

[open,refpage='VkIndirectStateFlagsNV',desc='Bitmask of VkIndirectStateFlagBitsNV',type='flags']
--
include::{generated}/api/flags/VkIndirectStateFlagsNV.adoc[]

tname:VkIndirectStateFlagsNV is a bitmask type for setting a mask of zero or
more elink:VkIndirectStateFlagBitsNV.
--

ifdef::VK_NV_device_generated_commands_compute[]
[open,refpage='VkBindPipelineIndirectCommandNV',desc='Structure specifying input data for the compute pipeline dispatch token',type='structs']
--
The sname:VkBindPipelineIndirectCommandNV structure specifies the input data
for the ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV token.

include::{generated}/api/structs/VkBindPipelineIndirectCommandNV.adoc[]

  * pname:pipelineAddress specifies the pipeline address of the compute
    pipeline that will be used in device generated rendering.

.Valid Usage
****
  * [[VUID-VkBindPipelineIndirectCommandNV-deviceGeneratedComputePipelines-09091]]
    The <<features-deviceGeneratedComputePipelines,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::pname:deviceGeneratedComputePipelines>>
    feature must: be enabled
  * [[VUID-VkBindPipelineIndirectCommandNV-None-09092]]
    The referenced pipeline must: have been created with
    ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV
  * [[VUID-VkBindPipelineIndirectCommandNV-None-09093]]
    The referenced pipeline must: have been updated with
    flink:vkCmdUpdatePipelineIndirectBufferNV
  * [[VUID-VkBindPipelineIndirectCommandNV-None-09094]]
    The referenced pipeline's address must: have been queried with
    flink:vkGetPipelineIndirectDeviceAddressNV
****

include::{generated}/validity/structs/VkBindPipelineIndirectCommandNV.adoc[]
--
endif::VK_NV_device_generated_commands_compute[]

endif::VK_NV_device_generated_commands[]


=== Tokenized Command Processing

ifdef::VK_EXT_device_generated_commands[]
The processing for `apiext:VK_EXT_device_generated_commands` is in principle
illustrated below:

[source,c]
----
void cmdProcessSequence(cmd, indirectExecutionSet, indirectCommandsLayout, indirectAddress, s)
{
  for (t = 0; t < indirectCommandsLayout.tokenCount; t++)
  {
    uint32_t offset  = indirectCommandsLayout.pTokens[t].offset;
    uint32_t stride  = indirectCommandsLayout.indirectStride;
    VkDeviceAddress streamData = indirectAddress;
    const void* input = streamData + stride * s + offset;

    // further details later
    indirectCommandsLayout.pTokens[t].command (cmd, indirectExecutionSet, input, s);
  }
}

void cmdProcessAllSequences(cmd, indirectExecutionSet, indirectCommandsLayout, indirectAddress, sequencesCount)
{
  for (s = 0; s < sequencesCount; s++)
  {
    sUsed = s;

    if (indirectCommandsLayout.flags & VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT) {
      sUsed = incoherent_implementation_dependent_permutation[ sUsed ];
    }

    cmdProcessSequence( cmd, indirectExecutionSet, indirectCommandsLayout, indirectAddress, sUsed );
  }
}
----

The processing of each sequence is considered stateless, therefore all state
changes must: occur prior to action commands within the sequence.
A single sequence is strictly targeting the tlink:VkShaderStageFlags it was
created with.

The primary input data for each token is provided through sname:VkBuffer
content at preprocessing using flink:vkCmdPreprocessGeneratedCommandsEXT or
execution time using flink:vkCmdExecuteGeneratedCommandsEXT, however some
functional arguments, for example push constant layouts, are specified at
layout creation time.
The input size is different for each token.

[open,refpage='VkIndirectCommandsTokenTypeEXT',desc='Enum specifying token commands',type='enums']
--
Possible values of those elements of the
slink:VkIndirectCommandsLayoutCreateInfoEXT::pname:pTokens array specifying
command tokens (other elements of the array specify command parameters) are:

include::{generated}/api/enums/VkIndirectCommandsTokenTypeEXT.adoc[]

[[indirectmdslayout-command-tokens-ext]]
.Supported Indirect Command Tokens
[width="80%",cols="67%,33%",options="header",align="center"]
|===
|*Common Tokens* | *Command Data*
ifdef::VK_EXT_shader_object[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT            | `u32[]` array of indices into the indirect execution set
endif::VK_EXT_shader_object[]
ifndef::VK_EXT_shader_object[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT            | `u32` index into the indirect execution set
endif::VK_EXT_shader_object[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT            | `u32[]` raw data
ifdef::VK_EXT_descriptor_heap[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_EXT                | `u8[]` raw data
endif::VK_EXT_descriptor_heap[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT           | `u32` placeholder data (not accessed by shader)
ifdef::VK_EXT_descriptor_heap[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT | `u32` placeholder data (not accessed by shader)
endif::VK_EXT_descriptor_heap[]
|*Compute Tokens*|
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT                 | slink:VkDispatchIndirectCommand
ifdef::VK_KHR_ray_tracing_maintenance1[]
|*Ray Tracing Tokens*|
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT              | slink:VkTraceRaysIndirectCommand2KHR
endif::VK_KHR_ray_tracing_maintenance1[]
|*Graphics State Tokens*|
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT             | slink:VkBindIndexBufferIndirectCommandEXT
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT            | slink:VkBindVertexBufferIndirectCommandEXT
|*Graphics Draw Tokens*|
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT             | slink:VkDrawIndexedIndirectCommand
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT                     | slink:VkDrawIndirectCommand
ifdef::VK_EXT_mesh_shader[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT          | slink:VkDrawMeshTasksIndirectCommandEXT
endif::VK_EXT_mesh_shader[]
ifdef::VK_NV_mesh_shader[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT       | slink:VkDrawMeshTasksIndirectCommandNV
endif::VK_NV_mesh_shader[]
|*Graphics Draw Count Tokens*|
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT       | slink:VkDrawIndirectCountIndirectCommandEXT with VkDrawIndexedIndirectCommand
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT               | slink:VkDrawIndirectCountIndirectCommandEXT with VkDrawIndirectCommand
ifdef::VK_EXT_mesh_shader[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT    | slink:VkDrawIndirectCountIndirectCommandEXT with VkDrawMeshTasksIndirectCommandEXT
endif::VK_EXT_mesh_shader[]
ifdef::VK_NV_mesh_shader[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT | slink:VkDrawIndirectCountIndirectCommandEXT with VkDrawMeshTasksIndirectCommandNV
endif::VK_NV_mesh_shader[]
|===

--

[open,refpage='VkIndirectCommandsLayoutTokenEXT',desc='Struct specifying the details of an indirect command layout token',type='structs']
--
The sname:VkIndirectCommandsLayoutTokenEXT structure specifies details to
the function arguments that need to be known at layout creation time:

include::{generated}/api/structs/VkIndirectCommandsLayoutTokenEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:type specifies the elink:VkIndirectCommandsTokenTypeEXT for
    pname:data.
  * pname:data specifies a slink:VkIndirectCommandsTokenDataEXT containing
    token-specific details for command execution.
    It is ignored if pname:type does not match any member of the
    slink:VkIndirectCommandsTokenDataEXT union.
  * pname:offset is the relative byte offset for the token within one
    sequence of the indirect buffer.
    The data stored at that offset is the command data for the token, e.g.
    sname:VkDispatchIndirectCommand.

.Valid Usage
****
  * [[VUID-VkIndirectCommandsLayoutTokenEXT-offset-11124]]
    pname:offset must: be less than or equal to
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:maxIndirectCommandsTokenOffset
  * [[VUID-VkIndirectCommandsLayoutTokenEXT-offset-11125]]
    pname:offset must: be aligned to `4`
ifdef::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
  * [[VUID-VkIndirectCommandsLayoutTokenEXT-meshShader-11126]]
    If <<features-meshShader, pname:meshShader>> or <<features-taskShader,
    pname:taskShader>> are not enabled, pname:type must: not be
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT,
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT or
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT
endif::VK_NV_mesh_shader,VK_EXT_mesh_shader[]
ifdef::VK_KHR_ray_tracing_maintenance1[]
  * [[VUID-VkIndirectCommandsLayoutTokenEXT-rayTracingMaintenance1-11128]]
    If the <<features-rayTracingMaintenance1, pname:rayTracingMaintenance1>>
    feature is not enabled, pname:type must: not be
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT
endif::VK_KHR_ray_tracing_maintenance1[]
  * [[VUID-VkIndirectCommandsLayoutTokenEXT-deviceGeneratedCommandsMultiDrawIndirectCount-11129]]
    If <<limits-deviceGeneratedCommandsMultiDrawIndirectCount,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:deviceGeneratedCommandsMultiDrawIndirectCount>>
    is not supported, pname:type must: not be
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT or
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT
ifdef::VK_EXT_mesh_shader[]
  * [[VUID-VkIndirectCommandsLayoutTokenEXT-deviceGeneratedCommandsMultiDrawIndirectCount-11130]]
    If <<limits-deviceGeneratedCommandsMultiDrawIndirectCount,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:deviceGeneratedCommandsMultiDrawIndirectCount>>
    is not supported, pname:type must: not be
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT
endif::VK_EXT_mesh_shader[]
ifdef::VK_NV_mesh_shader[]
  * [[VUID-VkIndirectCommandsLayoutTokenEXT-deviceGeneratedCommandsMultiDrawIndirectCount-11131]]
    If <<limits-deviceGeneratedCommandsMultiDrawIndirectCount,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:deviceGeneratedCommandsMultiDrawIndirectCount>>
    is not supported, pname:type must: not be
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT
endif::VK_NV_mesh_shader[]
ifdef::VK_EXT_descriptor_heap[]
  * [[VUID-VkIndirectCommandsLayoutTokenEXT-descriptorHeap-11332]]
    If the <<features-descriptorHeap, pname:descriptorHeap>> feature is not
    enabled, pname:type must: not be
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_EXT or
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT
  * [[VUID-VkIndirectCommandsLayoutTokenEXT-type-11333]]
    If pname:type is ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_EXT or
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT
    slink:VkIndirectCommandsPushConstantTokenEXT::pname:updateRange.shaderStages
    must: be ename:VK_SHADER_STAGE_ALL
endif::VK_EXT_descriptor_heap[]
****

include::{generated}/validity/structs/VkIndirectCommandsLayoutTokenEXT.adoc[]
--

[open,refpage='VkIndirectCommandsTokenDataEXT',desc='Union specifying the token-specific details of an indirect command layout token',type='structs']
--
The sname:VkIndirectCommandsTokenDataEXT structure provides token-specific
details used to generate the indirect execution layout.

include::{generated}/api/structs/VkIndirectCommandsTokenDataEXT.adoc[]

  * pname:pPushConstant is a pointer to a
    slink:VkIndirectCommandsPushConstantTokenEXT structure needed for
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,
ifdef::VK_EXT_descriptor_heap[ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_EXT, ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT,]
    and ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT tokens
  * pname:pVertexBuffer is a pointer to a
    slink:VkIndirectCommandsVertexBufferTokenEXT structure needed for
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT tokens
  * pname:pIndexBuffer is a pointer to a
    slink:VkIndirectCommandsIndexBufferTokenEXT structure needed for
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT tokens
  * pname:pExecutionSet is a pointer to a
    slink:VkIndirectCommandsExecutionSetTokenEXT structure needed for
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT tokens

The appropriate member of the union must: be set for each token.

The following code provides detailed information on how an individual
sequence is processed.
For valid usage, all restrictions from the regular commands apply.

include::{generated}/validity/structs/VkIndirectCommandsTokenDataEXT.adoc[]
--

[source,c]
----

void cmdProcessSequence(cmd, indirectExecutionSet, indirectCommandsLayout, indirectAddress, s)
{
  for (uint32_t t = 0; t < indirectCommandsLayout.tokenCount; t++) {
    VkIndirectCommandsLayoutTokenEXT *token = &indirectCommandsLayout.pTokens[t];

    uint32_t offset  = token->offset;
    uint32_t stride  = indirectCommandsLayout.indirectStride;
    VkDeviceAddress streamData = indirectAddress;
    const void* input = streamData + stride * s + offset;

    switch (token->tokenType) {
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT:
      uint32_t *bind = input;
      VkIndirectCommandsExecutionSetTokenEXT *info = token->data.pExecutionSet;

      if (info->type == VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT) {
        vkCmdBindPipeline(cmd, indirectExecutionSet.pipelineBindPoint, indirectExecutionSet.pipelines[*bind]);
      } else {
        VkShaderStageFlagBits stages[];
        VkShaderEXT shaders[];
        uint32_t i = 0;
        IterateBitmaskLSBToMSB(iter, info->shaderStages) {
            stages[i] = iter;
            shaders[i] = indirectExecutionSet.shaders[bind[i]].shaderObject;
            i++;
        }
        vkCmdBindShadersEXT(cmd, i, stages, shaders);
      }
      break;

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT:
      uint32_t* data = input;
      VkPushConstantsInfoKHR info = {
        VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR,
        // this can also use `dynamicGeneratedPipelineLayout' to pass a VkPipelineLayoutCreateInfo from pNext
        indirectCommandsLayout.pipelineLayout,
        token->token.pushConstant.updateRange.shaderStages,
        token->token.pushConstant.updateRange.offset,
        token->token.pushConstant.updateRange.size,
        data
      };

      vkCmdPushConstants2KHR(cmd, &info);
      break;

ifdef::VK_EXT_descriptor_heap[]
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_EXT:

      VkHostAddressRangeConstEXT addressRange = {
        token->token.pushConstant.updateRange.data.size,
        input
      };

      VkPushDataInfoEXT info = {
        VK_STRUCTURE_TYPE_PUSH_DATA_INFO_EXT,
        NULL,
        token->token.pushConstant.updateRange.offset,
        addressRange
      };

      vkCmdPushDataEXT(cmd, &info);
      break;
endif::VK_EXT_descriptor_heap[]

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT:
      VkPushConstantsInfoKHR info = {
        VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR,
        // this can also use `dynamicGeneratedPipelineLayout' to pass a VkPipelineLayoutCreateInfo from pNext
        indirectCommandsLayout.pipelineLayout,
        token->token.pushConstant.updateRange.shaderStages,
        token->token.pushConstant.updateRange.offset,
        // this must be 4
        token->token.pushConstant.updateRange.size,
        // this just updates the sequence index
        &s
      };

      vkCmdPushConstants2KHR(cmd, &info);
      break;

ifdef::VK_EXT_descriptor_heap[]
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT:

      VkHostAddressRangeConstEXT addressRange = {
        // this must be 4
        token->token.pushConstant.updateRange.data.size,
        // this just updates the sequence index
        &s
      };

      VkPushDataInfoEXT info = {
        VK_STRUCTURE_TYPE_PUSH_DATA_INFO_EXT,
        NULL,
        token->token.pushConstant.updateRange.offset,
        addressRange
      };

      vkCmdPushDataEXT(cmd, &info);
      break;
endif::VK_EXT_descriptor_heap[]

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT:
      VkBindIndexBufferIndirectCommandEXT* data = input;

      vkCmdBindIndexBuffer(cmd, deriveBuffer(data->bufferAddress), deriveOffset(data->bufferAddress), data->indexType);
      break;

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT:
      VkBindVertexBufferIndirectCommandEXT* data = input;

      vkCmdBindVertexBuffers2(cmd, token->token.vertexBuffer->vertexBindingUnit, 1, &deriveBuffer(data->bufferAddress),
                              &deriveOffset(data->bufferAddress), data->size, data->stride);
      break;

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT:
      VkDrawIndexedIndirectCommand *data = input;

      vkCmdDrawIndexed(cmd, data->indexCount, data->instanceCount, data->firstIndex, data->vertexOffset, data->firstInstance);
      break;
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT:
      VkDrawIndirectCountIndirectCommandEXT* data = input;

      vkCmdDrawIndexedIndirect(cmd, deriveBuffer(data->bufferAddress),  deriveoffset(data->bufferAddress), min(data->commandCount, indirectCommandsLayout.maxDrawCount), data->stride);
      break;

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT:
      VkDrawIndirectCommand* data = input;

      vkCmdDraw(cmd, data->vertex_count, data->instanceCount, data->firstVertex, data->firstIndex);
      break;

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT:
      VkDrawIndirectCountIndirectCommandEXT* data = input;

      vkCmdDrawIndirect(cmd, deriveBuffer(data->bufferAddress), deriveoffset(data->bufferAddress), min(data->commandCount, indirectCommandsLayout.maxDrawCount), data->stride);
      break;

    // only available if VK_NV_mesh_shader is enabled
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT:
      VkDrawMeshTasksIndirectCommandNV *data = input;

      vkCmdDrawMeshTasksNV(cmd, data->taskCount, data->firstTask);
     break;

    // only available if VK_NV_mesh_shader is enabled
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT:
      VkDrawIndirectCountIndirectCommandEXT* data = input;

      vkCmdDrawMeshTasksIndirectCountNV(cmd, deriveBuffer(data->bufferAddress),  deriveoffset(data->bufferAddress), min(data->commandCount, indirectCommandsLayout.maxDrawCount), data->stride);
      break;

    // only available if VK_EXT_mesh_shader is enabled
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT:
      VkDrawMeshTasksIndirectCommandEXT *data = input;

      vkCmdDrawMeshTasksEXT(cmd, data->groupCountX, data->groupCountY, data->groupCountZ);
     break;

    // only available if VK_EXT_mesh_shader is enabled
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT:
      VkDrawIndirectCountIndirectCommandEXT* data = input;

      vkCmdDrawMeshTasksIndirectCountEXT(cmd, deriveBuffer(data->bufferAddress),  deriveoffset(data->bufferAddress), min(data->commandCount, indirectCommandsLayout.maxDrawCount), data->stride);
      break;

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT:
      VkDispatchIndirectCommand *data = input;

      vkCmdDispatch(cmd, data->x, data->y, data->z);
      break;

    // only available if VK_KHR_ray_tracing_maintenance1 is enabled
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT:
      vkCmdTraceRaysIndirect2KHR(cmd, deriveBuffer(input));
      break;
    }
  }
}
----
endif::VK_EXT_device_generated_commands[]

ifdef::VK_NV_device_generated_commands[]
The processing for `apiext:VK_NV_device_generated_commands` is in principle
illustrated below:

[source,c]
----
void cmdProcessSequence(cmd, pipeline, indirectCommandsLayout, pIndirectCommandsStreams, s)
{
  for (t = 0; t < indirectCommandsLayout.tokenCount; t++)
  {
    uint32_t stream  = indirectCommandsLayout.pTokens[t].stream;
    uint32_t offset  = indirectCommandsLayout.pTokens[t].offset;
    uint32_t stride  = indirectCommandsLayout.pStreamStrides[stream];
    stream            = pIndirectCommandsStreams[stream];
    const void* input = stream.buffer.pointer( stream.offset + stride * s + offset )

    // further details later
    indirectCommandsLayout.pTokens[t].command (cmd, pipeline, input, s);
  }
}

void cmdProcessAllSequences(cmd, pipeline, indirectCommandsLayout, pIndirectCommandsStreams, sequencesCount)
{
  for (s = 0; s < sequencesCount; s++)
  {
    cmdProcessSequence(cmd, pipeline, indirectCommandsLayout, pIndirectCommandsStreams, s);
  }
}
----

The processing of each sequence is considered stateless, therefore all state
changes must: occur before any action command tokens within the sequence.
A single sequence is strictly targeting the elink:VkPipelineBindPoint it was
created with.

The primary input data for each token is provided through sname:VkBuffer
content at preprocessing using flink:vkCmdPreprocessGeneratedCommandsNV or
execution time using flink:vkCmdExecuteGeneratedCommandsNV, however some
functional arguments, for example binding sets, are specified at layout
creation time.
The input size is different for each token.
endif::VK_NV_device_generated_commands[]

ifdef::VK_EXT_device_generated_commands[]
[open,refpage='VkIndirectCommandsPushConstantTokenEXT',desc='Structure specifying layout token info for a single push constant command token',type='structs']
--
The sname:VkIndirectCommandsPushConstantTokenEXT structure specifies the
layout token info for
ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,
ifdef::VK_EXT_descriptor_heap[]
ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_EXT,
ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT,
endif::VK_EXT_descriptor_heap[]
and ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT tokens.

include::{generated}/api/structs/VkIndirectCommandsPushConstantTokenEXT.adoc[]

  * pname:updateRange is the push constant range that will be updated by the
    token.

The pname:stageFlags member of pname:updateRange is ignored.

.Valid Usage
****
  * [[VUID-VkIndirectCommandsPushConstantTokenEXT-updateRange-11132]]
ifdef::VK_EXT_descriptor_heap[]
    If the token type is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT or
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT,
endif::VK_EXT_descriptor_heap[]
    pname:updateRange must: be contained within the push constant info used
    by slink:VkIndirectCommandsLayoutCreateInfoEXT
  * [[VUID-VkIndirectCommandsPushConstantTokenEXT-size-11133]]
    If the token type is
ifdef::VK_EXT_descriptor_heap[]
ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT or
endif::VK_EXT_descriptor_heap[]
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT, the pname:size
    member of pname:updateRange must: be 4
****

include::{generated}/validity/structs/VkIndirectCommandsPushConstantTokenEXT.adoc[]
--

[open,refpage='VkIndirectCommandsVertexBufferTokenEXT',desc='Structure specifying layout token info for a single index buffer command token',type='structs']
--
The sname:VkIndirectCommandsVertexBufferTokenEXT structure specifies the
layout token info for the
ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT token.

include::{generated}/api/structs/VkIndirectCommandsVertexBufferTokenEXT.adoc[]

  * pname:vertexBindingUnit is the vertex input binding number to be bound.

.Valid Usage
****
  * [[VUID-VkIndirectCommandsVertexBufferTokenEXT-vertexBindingUnit-11134]]
    pname:vertexBindingUnit must: be less than the total number of vertex
    input bindings in use by the current graphics state
****

include::{generated}/validity/structs/VkIndirectCommandsVertexBufferTokenEXT.adoc[]
--

[open,refpage='VkIndirectCommandsIndexBufferTokenEXT',desc='Structure specifying layout token info for a single index buffer command token',type='structs']
--
The sname:VkIndirectCommandsIndexBufferTokenEXT structure specifies the
layout token info for the
ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT token.

include::{generated}/api/structs/VkIndirectCommandsIndexBufferTokenEXT.adoc[]

  * pname:mode specifies the mode to use with this token.

This allows for easy layering of Vulkan atop other APIs.
When ename:VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT is
specified, the indirect buffer can contain a `D3D12_INDEX_BUFFER_VIEW`
instead of slink:VkBindIndexBufferIndirectCommandEXT as D3D's DXGI format
value is mapped to the elink:VkIndexType.
It works as both structs are otherwise binary compatible.

.Valid Usage
****
  * [[VUID-VkIndirectCommandsIndexBufferTokenEXT-mode-11135]]
    pname:mode must: be non-zero
  * [[VUID-VkIndirectCommandsIndexBufferTokenEXT-mode-11136]]
    pname:mode must: be one of the bits supported in
    <<limits-supportedIndirectCommandsInputModes,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:supportedIndirectCommandsInputModes>>
****

include::{generated}/validity/structs/VkIndirectCommandsIndexBufferTokenEXT.adoc[]
--

[open,refpage='VkIndirectCommandsInputModeFlagBitsEXT',desc='Bitmask specifying allowed usage of an indirect commands layout',type='enums']
--
Bits which are set in
slink:VkIndirectCommandsIndexBufferTokenEXT::pname:mode, specifying how an
index buffer is used, are:

include::{generated}/api/enums/VkIndirectCommandsInputModeFlagBitsEXT.adoc[]

  * ename:VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT specifies
    that the indirect buffer contains
    slink:VkBindIndexBufferIndirectCommandEXT.
  * ename:VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT specifies
    that the indirect buffer contains `D3D12_INDEX_BUFFER_VIEW`.
--

[open,refpage='VkIndirectCommandsInputModeFlagsEXT',desc='Bitmask of VkIndirectCommandsInputModeFlagBitsEXT',type='flags']
--
include::{generated}/api/flags/VkIndirectCommandsInputModeFlagsEXT.adoc[]

tname:VkIndirectCommandsInputModeFlagsEXT is a bitmask type for setting a
mask of zero or more elink:VkIndirectCommandsInputModeFlagBitsEXT.
--

[open,refpage='VkIndirectCommandsExecutionSetTokenEXT',desc='Structure specifying input data for a single execution set command token',type='structs']
--
The sname:VkIndirectCommandsExecutionSetTokenEXT structure specifies the
input data for the ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT
token.

include::{generated}/api/structs/VkIndirectCommandsExecutionSetTokenEXT.adoc[]

  * pname:type describes the type of indirect execution set in use.
  * pname:shaderStages specifies the shaders that will be changed by this
    token.

.Valid Usage
****
  * [[VUID-VkIndirectCommandsExecutionSetTokenEXT-shaderStages-11137]]
    Each bit in pname:shaderStages must: be supported by
    <<limits-supportedIndirectCommandsShaderStagesPipelineBinding,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:supportedIndirectCommandsShaderStagesPipelineBinding>>
ifdef::VK_EXT_shader_object[]
    or <<limits-supportedIndirectCommandsShaderStagesShaderBinding,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:supportedIndirectCommandsShaderStagesShaderBinding>>
endif::VK_EXT_shader_object[]
****

include::{generated}/validity/structs/VkIndirectCommandsExecutionSetTokenEXT.adoc[]
--
endif::VK_EXT_device_generated_commands[]

ifdef::VK_NV_device_generated_commands[]
[open,refpage='VkIndirectCommandsTokenTypeNV',desc='Enum specifying token commands',type='enums']
--
Possible values of those elements of the
slink:VkIndirectCommandsLayoutCreateInfoNV::pname:pTokens array specifying
command tokens (other elements of the array specify command parameters) are:

include::{generated}/api/enums/VkIndirectCommandsTokenTypeNV.adoc[]

[[indirectmdslayout-command-tokens-nv]]
.Supported Indirect Command Tokens
[width="80%",cols="67%,33%",options="header",align="center"]
|====
|Token type                                                 | Equivalent command
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV      | flink:vkCmdBindPipelineShaderGroupNV
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV       | -
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV      | flink:vkCmdBindIndexBuffer
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV     | flink:vkCmdBindVertexBuffers
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV     | flink:vkCmdPushConstants
ifdef::VK_EXT_descriptor_heap[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_NV         | flink:vkCmdPushDataEXT
endif::VK_EXT_descriptor_heap[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV      | flink:vkCmdDrawIndexedIndirect
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV              | flink:vkCmdDrawIndirect
ifdef::VK_NV_mesh_shader[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV        | flink:vkCmdDrawMeshTasksIndirectNV
endif::VK_NV_mesh_shader[]
ifdef::VK_EXT_mesh_shader[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV   | flink:vkCmdDrawMeshTasksIndirectEXT
endif::VK_EXT_mesh_shader[]
ifdef::VK_NV_device_generated_commands_compute[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV          | flink:vkCmdBindPipeline
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV          | flink:vkCmdDispatchIndirect
endif::VK_NV_device_generated_commands_compute[]
|====
--

[open,refpage='VkIndirectCommandsLayoutTokenNV',desc='Struct specifying the details of an indirect command layout token',type='structs']
--
The sname:VkIndirectCommandsLayoutTokenNV structure specifies details to the
function arguments that need to be known at layout creation time:

include::{generated}/api/structs/VkIndirectCommandsLayoutTokenNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:tokenType is a elink:VkIndirectCommandsTokenTypeNV specifying the
    token command type.
  * pname:stream is the index of the input stream containing the token
    argument data.
  * pname:offset is a relative starting offset within the input stream
    memory for the token argument data.
  * pname:vertexBindingUnit is used for the vertex buffer binding command.
  * pname:vertexDynamicStride sets if the vertex buffer stride is provided
    by the binding command rather than the current bound graphics pipeline
    state.
  * pname:pushconstantPipelineLayout is the sname:VkPipelineLayout used for
    the push constant command.
  * pname:pushconstantShaderStageFlags are the shader stage flags used for
    the push constant command.
  * pname:pushconstantOffset is the offset used for the push constant
    command.
  * pname:pushconstantSize is the size used for the push constant command.
  * pname:indirectStateFlags is a tlink:VkIndirectStateFlagsNV bitfield
    indicating the active states for the state flag command.
  * pname:indexTypeCount is the optional size of the pname:pIndexTypes and
    pname:pIndexTypeValues array pairings.
    If not zero, it allows to register a custom `uint32_t` value to be
    treated as specific elink:VkIndexType.
  * pname:pIndexTypes is the used elink:VkIndexType for the corresponding
    `uint32_t` value entry in pname:pIndexTypeValues.

.Valid Usage
****
  * [[VUID-VkIndirectCommandsLayoutTokenNV-stream-02951]]
    pname:stream must: be smaller than
    sname:VkIndirectCommandsLayoutCreateInfoNV::pname:streamCount
  * [[VUID-VkIndirectCommandsLayoutTokenNV-offset-02952]]
    pname:offset must: be less than or equal to
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:maxIndirectCommandsTokenOffset
  * [[VUID-VkIndirectCommandsLayoutTokenNV-offset-06888]]
    pname:offset must: be aligned to the scalar alignment of pname:tokenType
    or pname:minIndirectCommandsBufferOffsetAlignment, whichever is lower
  * [[VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02976]]
    If pname:tokenType is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV,
    pname:vertexBindingUnit must: stay within device supported limits for
    the appropriate commands
  * [[VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02977]]
    If pname:tokenType is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
    pname:pushconstantPipelineLayout must: be valid
  * [[VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02978]]
    If pname:tokenType is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
    pname:pushconstantOffset must: be a multiple of `4`
  * [[VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02979]]
    If pname:tokenType is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
    pname:pushconstantSize must: be a multiple of `4`
  * [[VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02980]]
    If pname:tokenType is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
    pname:pushconstantOffset must: be less than
    sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize
  * [[VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02981]]
    If pname:tokenType is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
    pname:pushconstantSize must: be less than or equal to
    sname:VkPhysicalDeviceLimits::pname:maxPushConstantsSize minus
    pname:pushconstantOffset
  * [[VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02982]]
    If pname:tokenType is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, for each byte in
    the range specified by pname:pushconstantOffset and
    pname:pushconstantSize and for each shader stage in
    pname:pushconstantShaderStageFlags, there must: be a push constant range
    in pname:pushconstantPipelineLayout that includes that byte and that
    stage
  * [[VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02983]]
    If pname:tokenType is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, for each byte in
    the range specified by pname:pushconstantOffset and
    pname:pushconstantSize and for each push constant range that overlaps
    that byte, pname:pushconstantShaderStageFlags must: include all stages
    in that push constant range's
    slink:VkPushConstantRange::pname:stageFlags
  * [[VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02984]]
    If pname:tokenType is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV,
    pname:indirectStateFlags must: not be `0`
ifdef::VK_EXT_descriptor_heap[]
  * [[VUID-VkIndirectCommandsLayoutTokenNV-tokenType-11334]]
    If pname:tokenType is
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_NV,
    slink:VkIndirectCommandsLayoutPushDataTokenNV::pname:pushDataSize must:
    be greater than `0`
endif::VK_EXT_descriptor_heap[]
****

include::{generated}/validity/structs/VkIndirectCommandsLayoutTokenNV.adoc[]
--


ifdef::VK_EXT_descriptor_heap[]
[open,refpage='VkIndirectCommandsLayoutPushDataTokenNV',desc='Struct specifying the details of an indirect push data command layout token',type='structs']
--
The sname:VkIndirectCommandsLayoutTokenNV structure specifies details to the
function arguments that need to be known at layout creation time:

include::{generated}/api/structs/VkIndirectCommandsLayoutPushDataTokenNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pushDataOffset is the offset used for the push data command.
  * pname:pushDataSize is the size used for the push data command.

If this structure is in the pname:pNext chain of
slink:VkIndirectCommandsLayoutTokenNV, and
slink:VkIndirectCommandsLayoutTokenNV::pname:tokenType is set to
ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_NV, this structure defines a
push data command layout token.

If this structure is not provided, it is equivalent to setting
pname:pushDataOffset and pname:pushDataSize to 0.

.Valid Usage
****
  * [[VUID-VkIndirectCommandsLayoutPushDataTokenNV-pushDataOffset-11335]]
    The sum of pname:pushDataOffset and pname:pushDataSize must: be less
    than <<limits-maxPushDataSize,pname:maxPushDataSize>>
  * [[VUID-VkIndirectCommandsLayoutPushDataTokenNV-pushDataOffset-11420]]
    pname:pushDataOffset must: be a multiple of 4
  * [[VUID-VkIndirectCommandsLayoutPushDataTokenNV-pushDataSize-11421]]
    pname:pushDataSize must: be a multiple of 4
****

include::{generated}/validity/structs/VkIndirectCommandsLayoutPushDataTokenNV.adoc[]
--
endif::VK_EXT_descriptor_heap[]

The following code provides detailed information on how an individual
sequence is processed.
For valid usage, all restrictions from the regular commands apply.

[source,c]
----
void cmdProcessSequence(cmd, pipeline, indirectCommandsLayout, pIndirectCommandsStreams, s)
{
  for (uint32_t t = 0; t < indirectCommandsLayout.tokenCount; t++){
    token = indirectCommandsLayout.pTokens[t];

    uint32_t stride   = indirectCommandsLayout.pStreamStrides[token.stream];
    stream            = pIndirectCommandsStreams[token.stream];
    uint32_t offset   = stream.offset + stride * s + token.offset;
    const void* input = stream.buffer.pointer( offset )

    switch(input.type){
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV:
      VkBindShaderGroupIndirectCommandNV* bind = input;

      vkCmdBindPipelineShaderGroupNV(cmd, indirectCommandsLayout.pipelineBindPoint,
        pipeline, bind->groupIndex);
    break;

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV:
      VkSetStateFlagsIndirectCommandNV* state = input;

      if (token.indirectStateFlags & VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV){
        if (state.data & (1 << 0)){
          set VK_FRONT_FACE_CLOCKWISE;
        } else {
          set VK_FRONT_FACE_COUNTER_CLOCKWISE;
        }
      }
    break;

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV:
      uint32_t* data = input;

      vkCmdPushConstants(cmd,
        token.pushconstantPipelineLayout
        token.pushconstantStageFlags,
        token.pushconstantOffset,
        token.pushconstantSize, data);
    break;

ifdef::VK_EXT_descriptor_heap[]
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_NV:
      void* data = input;

      VkPushDataInfoEXT pushDataInfo = {
        .sType = VK_STRUCTURE_TYPE_PUSH_DATA_INFO_EXT,
        .pNext = NULL,
        .offset = token.pushDataOffset,
        .size = token.pushDataSize,
        .pData = input};

      vkCmdPushDataEXT(cmd, &pushDataInfo);
    break;
endif::VK_EXT_descriptor_heap[]

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV:
      VkBindIndexBufferIndirectCommandNV* data = input;

      // the indexType may optionally be remapped
      // from a custom uint32_t value, via
      // VkIndirectCommandsLayoutTokenNV::pIndexTypeValues

      vkCmdBindIndexBuffer(cmd,
        deriveBuffer(data->bufferAddress),
        deriveOffset(data->bufferAddress),
        data->indexType);
    break;

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV:
      VkBindVertexBufferIndirectCommandNV* data = input;

      // if token.vertexDynamicStride is VK_TRUE
      // then the stride for this binding is set
      // using data->stride as well

      vkCmdBindVertexBuffers(cmd,
        token.vertexBindingUnit, 1,
        &deriveBuffer(data->bufferAddress),
        &deriveOffset(data->bufferAddress));
    break;

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV:
      vkCmdDrawIndexedIndirect(cmd,
        stream.buffer, offset, 1, 0);
    break;

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV:
      vkCmdDrawIndirect(cmd,
        stream.buffer,
        offset, 1, 0);
    break;

    // only available if VK_NV_mesh_shader is supported
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV:
      vkCmdDrawMeshTasksIndirectNV(cmd,
        stream.buffer, offset, 1, 0);
    break;

    // only available if VK_EXT_mesh_shader is supported
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV:
      vkCmdDrawMeshTasksIndirectEXT(cmd,
        stream.buffer, offset, 1, 0);
    break;

ifdef::VK_NV_device_generated_commands_compute[]
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV:
      VkBindPipelineIndirectCommandNV *data = input;
      VkPipeline computePipeline = deriveFromDeviceAddress(data->pipelineAddress);
      vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, computePipeline);
    break;

    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV:
      vkCmdDispatchIndirect(cmd, stream.buffer, offset);
    break;
endif::VK_NV_device_generated_commands_compute[]
    }
  }
}
----
endif::VK_NV_device_generated_commands[]


== Indirect Commands Generation and Execution

The generation of commands on the device requires a `preprocess` buffer.

ifdef::VK_EXT_device_generated_commands[]
[open,refpage='vkGetGeneratedCommandsMemoryRequirementsEXT',desc='Retrieve the buffer allocation requirements for generated commands',type='protos']
--
With `apiext:VK_EXT_device_generated_commands`, to retrieve the memory size
and alignment requirements of a particular execution state call:

include::{generated}/api/protos/vkGetGeneratedCommandsMemoryRequirementsEXT.adoc[]

  * pname:device is the logical device that owns the buffer.
  * pname:pInfo is a pointer to a
    slink:VkGeneratedCommandsMemoryRequirementsInfoEXT structure containing
    parameters required for the memory requirements query.
  * pname:pMemoryRequirements is a pointer to a slink:VkMemoryRequirements2
    structure in which the memory requirements of the buffer object are
    returned.

If the size returned is zero, the preprocessing step can be skipped for this
layout.

include::{generated}/validity/protos/vkGetGeneratedCommandsMemoryRequirementsEXT.adoc[]
--

[open,refpage='VkGeneratedCommandsMemoryRequirementsInfoEXT',desc='Structure specifying parameters for the reservation of preprocess buffer space',type='structs']
--
include::{generated}/api/structs/VkGeneratedCommandsMemoryRequirementsInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:indirectExecutionSet is the indirect execution set to be used for
    binding shaders.
  * pname:indirectCommandsLayout is the slink:VkIndirectCommandsLayoutEXT
    that this buffer memory is intended to be used with.
  * pname:maxSequenceCount is the maximum number of sequences that this
    buffer memory can be used with.
  * pname:maxDrawCount is the maximum number of indirect draws that can be
    executed by any COUNT-type multi-draw indirect tokens.
    The draw count in the indirect buffer is clamped to this value for these
    token types.

If the action command token for the layout is not a COUNT-type multi-draw
indirect token, pname:maxDrawCount is ignored.

.Valid Usage
****
  * [[VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-maxSequencesCount-11009]]
    pname:maxSequencesCount must: be less or equal to
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:maxIndirectSequenceCount
  * [[VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-indirectCommandsLayout-11010]]
    If pname:indirectCommandsLayout was created with a token sequence that
    contained the ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT
    token, pname:indirectExecutionSet must: not be dlink:VK_NULL_HANDLE
  * [[VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-indirectCommandsLayout-11151]]
    If pname:indirectCommandsLayout was created with a token sequence that
    contained the ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT
    token, the shader stages used to create the initial shader state of
    pname:indirectExecutionSet must: equal the
    slink:VkIndirectCommandsExecutionSetTokenEXT::pname:shaderStages used to
    create pname:indirectCommandsLayout
  * [[VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-indirectCommandsLayout-11011]]
    If pname:indirectCommandsLayout was not created with a token sequence
    that contained the
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token,
    pname:indirectExecutionSet must: be dlink:VK_NULL_HANDLE
  * [[VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-maxDrawCount-11146]]
    When not ignored, [eq]#pname:maxDrawCount {times}
    pname:maxSequenceCount# must: be less than [eq]#2^24#
  * [[VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-indirectExecutionSet-11012]]
    If pname:indirectExecutionSet is dlink:VK_NULL_HANDLE,
ifdef::VK_EXT_shader_object[either]
    a slink:VkGeneratedCommandsPipelineInfoEXT
ifdef::VK_EXT_shader_object[or a slink:VkGeneratedCommandsShaderInfoEXT]
    must: be included in the pname:pNext chain
****

include::{generated}/validity/structs/VkGeneratedCommandsMemoryRequirementsInfoEXT.adoc[]
--

[open,refpage='VkGeneratedCommandsPipelineInfoEXT',desc='Structure specifying a pipeline for use with indirect command preprocessing',type='structs']
--
include::{generated}/api/structs/VkGeneratedCommandsPipelineInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipeline is a valid pipeline object.

include::{generated}/validity/structs/VkGeneratedCommandsPipelineInfoEXT.adoc[]
--

ifdef::VK_EXT_shader_object[]
[open,refpage='VkGeneratedCommandsShaderInfoEXT',desc='Structure specifying shader objects for use with indirect command preprocessing',type='structs']
--
include::{generated}/api/structs/VkGeneratedCommandsShaderInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:shaderCount is the size of the pname:pShaders array.
  * pname:pShaders is a pointer to an array of shader objects.

.Valid Usage
****
  * [[VUID-VkGeneratedCommandsShaderInfoEXT-pShaders-11127]]
    pname:pShaders must: not contain more than one shader object for a given
    elink:VkShaderStageFlagBits stage
****

include::{generated}/validity/structs/VkGeneratedCommandsShaderInfoEXT.adoc[]
--
endif::VK_EXT_shader_object[]
endif::VK_EXT_device_generated_commands[]

ifdef::VK_NV_device_generated_commands[]
[open,refpage='vkGetGeneratedCommandsMemoryRequirementsNV',desc='Retrieve the buffer allocation requirements for generated commands',type='protos']
--
With `apiext:VK_NV_device_generated_commands`, to retrieve the memory size
and alignment requirements of a particular execution state call:

include::{generated}/api/protos/vkGetGeneratedCommandsMemoryRequirementsNV.adoc[]

  * pname:device is the logical device that owns the buffer.
  * pname:pInfo is a pointer to a
    slink:VkGeneratedCommandsMemoryRequirementsInfoNV structure containing
    parameters required for the memory requirements query.
  * pname:pMemoryRequirements is a pointer to a slink:VkMemoryRequirements2
    structure in which the memory requirements of the buffer object are
    returned.

.Valid Usage
****
  * [[VUID-vkGetGeneratedCommandsMemoryRequirementsNV-deviceGeneratedCommands-02906]]
    The <<features-deviceGeneratedCommandsNV,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::pname:deviceGeneratedCommands>>
    feature must: be enabled
ifdef::VK_NV_device_generated_commands_compute[]
  * [[VUID-vkGetGeneratedCommandsMemoryRequirementsNV-pInfo-09074]]
    If pname:pInfo->pipelineBindPoint is of type
    ename:VK_PIPELINE_BIND_POINT_COMPUTE, then the
    <<features-deviceGeneratedCompute,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::pname:deviceGeneratedCompute>>
    feature must: be enabled
endif::VK_NV_device_generated_commands_compute[]
****

include::{generated}/validity/protos/vkGetGeneratedCommandsMemoryRequirementsNV.adoc[]
--

[open,refpage='VkGeneratedCommandsMemoryRequirementsInfoNV',desc='Structure specifying parameters for the reservation of preprocess buffer space',type='structs']
--
include::{generated}/api/structs/VkGeneratedCommandsMemoryRequirementsInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipelineBindPoint is the elink:VkPipelineBindPoint of the
    pname:pipeline that this buffer memory is intended to be used with
    during the execution.
  * pname:pipeline is the slink:VkPipeline that this buffer memory is
    intended to be used with during the execution.
  * pname:indirectCommandsLayout is the slink:VkIndirectCommandsLayoutNV
    that this buffer memory is intended to be used with.
  * pname:maxSequencesCount is the maximum number of sequences that this
    buffer memory in combination with the other state provided can: be used
    with.

.Valid Usage
****
  * [[VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-maxSequencesCount-02907]]
    pname:maxSequencesCount must: be less or equal to
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:maxIndirectSequenceCount
  * [[VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pipelineBindPoint-09075]]
    If pname:pipelineBindPoint is of type
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS, then pname:pipeline must: be a
    valid slink:VkPipeline handle
ifdef::VK_NV_device_generated_commands_compute[]
  * [[VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pipelineBindPoint-09076]]
    If pname:pipelineBindPoint is of type
    ename:VK_PIPELINE_BIND_POINT_COMPUTE, and the
    pname:indirectCommandsLayout was not created with a
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV token, then the
    pname:pipeline must: be a valid slink:VkPipeline handle
  * [[VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pipelineBindPoint-09077]]
    If pname:pipelineBindPoint is of type
    ename:VK_PIPELINE_BIND_POINT_COMPUTE, and the
    pname:indirectCommandsLayout contains a
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV token, then the
    pname:pipeline must: be dlink:VK_NULL_HANDLE
endif::VK_NV_device_generated_commands_compute[]
****

include::{generated}/validity/structs/VkGeneratedCommandsMemoryRequirementsInfoNV.adoc[]
--

ifdef::VK_NV_device_generated_commands_compute[]

With `apiext:VK_NV_device_generated_commands`, to bind a compute pipeline in
<<device-generated-commands,Device-Generated Commands>>, an application
must: query the pipeline's device address.

[open,refpage='vkGetPipelineIndirectDeviceAddressNV',desc='Get pipeline\'s 64-bit device address',type='protos']
--
:refpage: vkGetPipelineIndirectDeviceAddressNV

To query a compute pipeline's 64-bit device address, call:

include::{generated}/api/protos/vkGetPipelineIndirectDeviceAddressNV.adoc[]

  * pname:device is the logical device on which the pipeline was created.
  * pname:pInfo is a pointer to a
    slink:VkPipelineIndirectDeviceAddressInfoNV structure specifying the
    pipeline to retrieve the address for.

.Valid Usage
****
  * [[VUID-vkGetPipelineIndirectDeviceAddressNV-deviceGeneratedComputePipelines-09078]]
    The <<features-deviceGeneratedComputePipelines,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::pname:deviceGeneratedComputePipelines>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkGetPipelineIndirectDeviceAddressNV.adoc[]
--

[open,refpage='VkPipelineIndirectDeviceAddressInfoNV',desc='Structure specifying the pipeline to query an address for',type='structs']
--
:refpage: VkPipelineIndirectDeviceAddressInfoNV

The sname:VkPipelineIndirectDeviceAddressInfoNV structure is defined as:

include::{generated}/api/structs/VkPipelineIndirectDeviceAddressInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipelineBindPoint is a elink:VkPipelineBindPoint value specifying
    the type of pipeline whose device address is being queried.
  * pname:pipeline specifies the pipeline whose device address is being
    queried.

.Valid Usage
****
  * [[VUID-VkPipelineIndirectDeviceAddressInfoNV-pipelineBindPoint-09079]]
    The provided pname:pipelineBindPoint must: be of type
    ename:VK_PIPELINE_BIND_POINT_COMPUTE
  * [[VUID-VkPipelineIndirectDeviceAddressInfoNV-pipeline-09080]]
    pname:pipeline must: have been created with flag
    ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV set
  * [[VUID-VkPipelineIndirectDeviceAddressInfoNV-pipeline-09081]]
    pname:pipeline must: have been created with a
    slink:VkComputePipelineIndirectBufferInfoNV structure specifying a valid
    address where its metadata will be saved
****
include::{generated}/validity/structs/VkPipelineIndirectDeviceAddressInfoNV.adoc[]
--

[open,refpage='vkGetPipelineIndirectMemoryRequirementsNV',desc='Get the memory requirements for the compute indirect pipeline',type='protos']
--
:refpage: vkGetPipelineIndirectMemoryRequirementsNV

To determine the memory requirements for a compute pipeline's metadata,
call:

include::{generated}/api/protos/vkGetPipelineIndirectMemoryRequirementsNV.adoc[]

  * pname:device is the logical device that owns the buffer.
  * pname:pCreateInfo is a slink:VkComputePipelineCreateInfo structure
    specifying the creation parameters of the compute pipeline whose memory
    requirements are being queried.
  * pname:pMemoryRequirements is a pointer to a slink:VkMemoryRequirements2
    structure in which the requested pipeline's memory requirements are
    returned.

If pname:pCreateInfo->pNext chain includes a pointer to a
slink:VkComputePipelineIndirectBufferInfoNV structure, then the contents of
that structure are ignored.

.Valid Usage
****
  * [[VUID-vkGetPipelineIndirectMemoryRequirementsNV-deviceGeneratedComputePipelines-09082]]
    The <<features-deviceGeneratedComputePipelines,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::pname:deviceGeneratedComputePipelines>>
    feature must: be enabled
  * [[VUID-vkGetPipelineIndirectMemoryRequirementsNV-pCreateInfo-09083]]
    pname:pCreateInfo->flags must: include
    ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV
****

include::{generated}/validity/protos/vkGetPipelineIndirectMemoryRequirementsNV.adoc[]
--
endif::VK_NV_device_generated_commands_compute[]
endif::VK_NV_device_generated_commands[]


ifdef::VK_EXT_device_generated_commands[]
[[device-generated-indirect-execution-sets]]
=== Indirect Execution Sets

[open,refpage='VkIndirectExecutionSetEXT',desc='Opaque handle to an indirect execution set object',type='handles']
--
Indirect Execution Sets contain sets of pipelines
ifdef::VK_EXT_shader_object[]
or shader objects
endif::VK_EXT_shader_object[]
which can be bound individually.

include::{generated}/api/handles/VkIndirectExecutionSetEXT.adoc[]

Indirect Execution Sets allow the device to bind different shaders and
pipeline states using <<device-generated-commands>>.

--

[open,refpage='vkCreateIndirectExecutionSetEXT',desc='Create an indirect execution set',type='protos']
--
:refpage: vkCreateIndirectExecutionSetEXT

Indirect Execution Sets are created by calling:

include::{generated}/api/protos/vkCreateIndirectExecutionSetEXT.adoc[]

  * pname:device is the logical device that creates the indirect execution
    set.
  * pname:pCreateInfo is a pointer to a
    slink:VkIndirectExecutionSetCreateInfoEXT structure containing
    parameters affecting creation of the indirect execution set.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.
  * pname:pIndirectExecutionSet is a pointer to a
    slink:VkIndirectExecutionSetEXT handle in which the resulting indirect
    execution set is returned.

.Valid Usage
****
  * [[VUID-vkCreateIndirectExecutionSetEXT-deviceGeneratedCommands-11013]]
    The <<features-deviceGeneratedCommands,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::pname:deviceGeneratedCommands>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkCreateIndirectExecutionSetEXT.adoc[]
--

[open,refpage='VkIndirectExecutionSetCreateInfoEXT',desc='Structure specifying parameters of a newly created indirect execution set',type='structs']
--
The sname:VkIndirectExecutionSetCreateInfoEXT structure is defined as:

include::{generated}/api/structs/VkIndirectExecutionSetCreateInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:type is a elink:VkIndirectExecutionSetInfoTypeEXT describing the
    type of set being created and determining which field of the pname:info
    union will be used.
  * pname:info is a slink:VkIndirectExecutionSetInfoEXT union containing
    layout information for the set.

.Valid Usage
****
  * [[VUID-VkIndirectExecutionSetCreateInfoEXT-maxIndirectShaderObjectCount-11014]]
    If
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:maxIndirectShaderObjectCount
    is zero
ifdef::VK_EXT_shader_object[]
    or the <<features-shaderObject, pname:shaderObject>> feature is not
    enabled
endif::VK_EXT_shader_object[]
    pname:type must: not be
    ename:VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT
****

include::{generated}/validity/structs/VkIndirectExecutionSetCreateInfoEXT.adoc[]
--

[open,refpage='VkIndirectExecutionSetInfoTypeEXT',desc='Enum specifying allowed usage of an indirect execution set',type='enums']
--

Values which can: be set in
slink:VkIndirectExecutionSetCreateInfoEXT::pname:type, specifying contents
of an indirect execution set, are:

include::{generated}/api/enums/VkIndirectExecutionSetInfoTypeEXT.adoc[]

  * ename:VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT specifies that
    the indirect execution set contains slink:VkPipeline objects.
ifdef::VK_EXT_shader_object[]
  * ename:VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT specifies
    that the indirect execution set contains slink:VkShaderEXT objects.
endif::VK_EXT_shader_object[]
ifndef::VK_EXT_shader_object[]
  * ename:VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT must: not
    be used.
endif::VK_EXT_shader_object[]
--

[open,refpage='VkIndirectExecutionSetInfoEXT',desc='Union specifying parameters of a newly created indirect execution set',type='structs']
--
The sname:VkIndirectExecutionSetInfoEXT union is defined as:

include::{generated}/api/structs/VkIndirectExecutionSetInfoEXT.adoc[]

  * pname:pPipelineInfo is a pointer to a
    slink:VkIndirectExecutionSetPipelineInfoEXT structure containing
    pipeline layout information for the set.
  * pname:pShaderInfo is a pointer to a
    slink:VkIndirectExecutionSetShaderInfoEXT structure containing shader
    object layout information for the set.

include::{generated}/validity/structs/VkIndirectExecutionSetInfoEXT.adoc[]
--

[open,refpage='VkIndirectExecutionSetPipelineInfoEXT',desc='Struct specifying parameters of a newly created indirect execution set containing only pipelines',type='structs']
--
The sname:VkIndirectExecutionSetPipelineInfoEXT structure is defined as:

include::{generated}/api/structs/VkIndirectExecutionSetPipelineInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:initialPipeline is the initial pipeline for the set.
    This pipeline will be automatically added to the set at index `0`.
  * pname:maxPipelineCount is the maximum number of pipelines stored in the
    set.

The characteristics of pname:initialPipeline will be used to validate all
pipelines added to the set even if they are removed from the set or
destroyed.

When an Indirect Execution Set created with pipelines is used,
pname:initialPipeline constitutes the initial shader state.

.Valid Usage
****
  * [[VUID-VkIndirectExecutionSetPipelineInfoEXT-supportedIndirectCommandsShaderStagesPipelineBinding-11015]]
    If <<limits-supportedIndirectCommandsShaderStagesPipelineBinding,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:supportedIndirectCommandsShaderStagesPipelineBinding>>
    does not contain ename:VK_SHADER_STAGE_COMPUTE_BIT, the
    ename:VkPipelineBindPoint of pname:initialPipeline must: not be
    ename:VK_PIPELINE_BIND_POINT_COMPUTE
  * [[VUID-VkIndirectExecutionSetPipelineInfoEXT-supportedIndirectCommandsShaderStagesPipelineBinding-11016]]
    If <<limits-supportedIndirectCommandsShaderStagesPipelineBinding,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:supportedIndirectCommandsShaderStagesPipelineBinding>>
    does not contain ename:VK_SHADER_STAGE_FRAGMENT_BIT, the
    ename:VkPipelineBindPoint of pname:initialPipeline must: not be
    ename:VK_PIPELINE_BIND_POINT_GRAPHICS
ifdef::VK_KHR_ray_tracing_pipeline[]
  * [[VUID-VkIndirectExecutionSetPipelineInfoEXT-supportedIndirectCommandsShaderStagesPipelineBinding-11017]]
    If <<limits-supportedIndirectCommandsShaderStagesPipelineBinding,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:supportedIndirectCommandsShaderStagesPipelineBinding>>
    does not contain ray tracing stages, the ename:VkPipelineBindPoint of
    pname:initialPipeline must: not be
    ename:VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR
endif::VK_KHR_ray_tracing_pipeline[]
  * [[VUID-VkIndirectExecutionSetPipelineInfoEXT-maxPipelineCount-11018]]
    pname:maxPipelineCount must: be between `1` and
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:maxIndirectPipelineCount
  * [[VUID-VkIndirectExecutionSetPipelineInfoEXT-initialPipeline-11019]]
    pname:initialPipeline must: not use descriptors of type
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC
  * [[VUID-VkIndirectExecutionSetPipelineInfoEXT-initialPipeline-11153]]
    pname:initialPipeline must: have been created with
    ename:VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT
****

include::{generated}/validity/structs/VkIndirectExecutionSetPipelineInfoEXT.adoc[]
--

[open,refpage='VkIndirectExecutionSetShaderInfoEXT',desc='Struct specifying parameters of a newly created indirect execution set containing only shader objects',type='structs']
--
The sname:VkIndirectExecutionSetShaderInfoEXT structure is defined as:

include::{generated}/api/structs/VkIndirectExecutionSetShaderInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:shaderCount is the number of members in the pname:pInitialShaders
    and pname:pSetLayoutInfos arrays.
  * pname:pInitialShaders is a pointer to an array containing a
    slink:VkShaderEXT object for each shader stage that will be used in the
    set.
    These shaders will be automatically added to the set beginning at index
    `0`.
  * pname:pSetLayoutInfos is NULL or a pointer to an array containing a
    slink:VkIndirectExecutionSetShaderLayoutInfoEXT used by each
    corresponding pname:pInitialShaders shader stage in the set.
  * pname:maxShaderCount is the maximum number of shader objects stored in
    the set.
  * pname:pushConstantRangeCount is the number of members in the
    pname:pPushConstantRanges array.
  * pname:pPushConstantRanges is a pointer to the array of
    slink:VkPushConstantRange ranges used by all shaders in the set.

The characteristics of pname:pInitialShaders will be used to validate all
shaders added to the set even if they are removed from the set or destroyed.

When an Indirect Execution Set created with shader objects is used,
pname:pInitialShaders constitutes the initial shader state.

If pname:pSetLayoutInfos is `NULL`, the descriptor layout parameters are
inherited from the shader object.

.Valid Usage
****
  * [[VUID-VkIndirectExecutionSetShaderInfoEXT-pInitialShaders-11020]]
    All members of pname:pInitialShaders must: have a pname:stage supported
    by <<limits-supportedIndirectCommandsShaderStagesShaderBinding,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:supportedIndirectCommandsShaderStagesShaderBinding>>
  * [[VUID-VkIndirectExecutionSetShaderInfoEXT-maxShaderCount-11021]]
    pname:maxShaderCount must: not be zero
  * [[VUID-VkIndirectExecutionSetShaderInfoEXT-maxShaderCount-11022]]
    pname:maxShaderCount must: be less than or equal to
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:maxIndirectShaderObjectCount
  * [[VUID-VkIndirectExecutionSetShaderInfoEXT-maxShaderCount-11036]]
    pname:maxShaderCount must: be greater than or equal to pname:shaderCount
  * [[VUID-VkIndirectExecutionSetShaderInfoEXT-stage-11023]]
    The pname:stage of each element in the pname:pInitialShaders array must:
    be unique
  * [[VUID-VkIndirectExecutionSetShaderInfoEXT-pInitialShaders-11154]]
    Each member of pname:pInitialShaders must: have been created with
    ename:VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT
  * [[VUID-VkIndirectExecutionSetShaderInfoEXT-pSetLayoutInfos-10929]]
    If pname:pSetLayoutInfos is not `NULL`, the descriptor layout values
    specified must: be compatible with the descriptor set layouts defined at
    the creation of the shader object
ifdef::VK_EXT_descriptor_heap[]
  * [[VUID-VkIndirectExecutionSetShaderInfoEXT-pInitialShaders-11321]]
    If any element of pname:pInitialShaders was created with
    ename:VK_SHADER_CREATE_DESCRIPTOR_HEAP_BIT_EXT, all elements of
    pname:pInitialShaders must: have been created with
    ename:VK_SHADER_CREATE_DESCRIPTOR_HEAP_BIT_EXT
  * [[VUID-VkIndirectExecutionSetShaderInfoEXT-pInitialShaders-11322]]
    If any element of pname:pInitialShaders was created without
    ename:VK_SHADER_CREATE_DESCRIPTOR_HEAP_BIT_EXT, all elements of
    pname:pInitialShaders must: have been created without
    ename:VK_SHADER_CREATE_DESCRIPTOR_HEAP_BIT_EXT
  * [[VUID-VkIndirectExecutionSetShaderInfoEXT-pInitialShaders-11323]]
    If elements of pname:pInitialShaders were created with
    ename:VK_SHADER_CREATE_DESCRIPTOR_HEAP_BIT_EXT, pname:pSetLayoutInfos
    must: be `NULL`
endif::VK_EXT_descriptor_heap[]

****

include::{generated}/validity/structs/VkIndirectExecutionSetShaderInfoEXT.adoc[]
--

[open,refpage='VkIndirectExecutionSetShaderLayoutInfoEXT',desc='Struct specifying descriptor layout parameters of a newly created indirect execution set containing only shader objects',type='structs']
--
The sname:VkIndirectExecutionSetShaderLayoutInfoEXT structure is defined as:

include::{generated}/api/structs/VkIndirectExecutionSetShaderLayoutInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:setLayoutCount is the number of members in the pname:pSetLayouts
    array
  * pname:pSetLayouts is a pointer to an array containing
    slink:VkDescriptorSetLayout objects used by the shader stage.
    The implementation must: not access these objects outside of the
    duration of the command this structure is passed to.

.Valid Usage
****
  * [[VUID-VkIndirectExecutionSetShaderLayoutInfoEXT-pSetLayouts-11024]]
    All members of pname:pSetLayouts must: not contain descriptors of type
    ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or
    ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC
****

include::{generated}/validity/structs/VkIndirectExecutionSetShaderLayoutInfoEXT.adoc[]
--

[open,refpage='vkDestroyIndirectExecutionSetEXT',desc='Destroy an indirect execution set',type='protos']
--
:refpage: vkDestroyIndirectExecutionSetEXT

Destroy an Indirect Execution Set by calling:

include::{generated}/api/protos/vkDestroyIndirectExecutionSetEXT.adoc[]

  * pname:device is the logical device that owns the indirect execution set.
  * pname:indirectExecutionSet is the indirect execution set to destroy.
  * pname:pAllocator controls host memory allocation as described in the
    <<memory-allocation, Memory Allocation>> chapter.

.Valid Usage
****
  * [[VUID-vkDestroyIndirectExecutionSetEXT-indirectExecutionSet-11025]]
    All submitted commands that refer to pname:indirectExecutionSet must:
    have completed execution
****

include::{generated}/validity/protos/vkDestroyIndirectExecutionSetEXT.adoc[]
--

[open,refpage='VkWriteIndirectExecutionSetPipelineEXT',desc='Struct specifying pipeline update information for an indirect execution set',type='structs']
--
The sname:VkWriteIndirectExecutionSetPipelineEXT structure is defined as:

include::{generated}/api/structs/VkWriteIndirectExecutionSetPipelineEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:index is the element of the set to update
  * pname:pipeline is the pipeline to store in the indirect execution set

.Valid Usage
****
  * [[VUID-VkWriteIndirectExecutionSetPipelineEXT-index-11026]]
    pname:index must: be less than the value of
    sname:VkIndirectExecutionSetPipelineInfoEXT::pname:maxPipelineCount used
    to create the set
  * [[VUID-VkWriteIndirectExecutionSetPipelineEXT-pipeline-11027]]
    pname:pipeline must: have been created with
    ename:VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT
  * [[VUID-VkWriteIndirectExecutionSetPipelineEXT-index-11029]]
    pname:index must: not be referenced by submitted command buffers
  * [[VUID-VkWriteIndirectExecutionSetPipelineEXT-pipeline-11030]]
    The shader stages contained in pname:pipeline must: be supported by
    <<limits-supportedIndirectCommandsShaderStagesPipelineBinding,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:supportedIndirectCommandsShaderStagesPipelineBinding>>
****

include::{generated}/validity/structs/VkWriteIndirectExecutionSetPipelineEXT.adoc[]
--

[open,refpage='VkWriteIndirectExecutionSetShaderEXT',desc='Struct specifying shader object update information for an indirect execution set',type='structs']
--
The sname:VkWriteIndirectExecutionSetShaderEXT structure is defined as:

include::{generated}/api/structs/VkWriteIndirectExecutionSetShaderEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:index is the element of the set to update
  * pname:shader is the shader to store in the indirect execution set

Shaders need not be stored in the Indirect Execution Set according to their
stage.
The only restriction for shader indices within a set is that the value of
the index must: be less than the maximum number of shaders in the set.

.Valid Usage
****
  * [[VUID-VkWriteIndirectExecutionSetShaderEXT-index-11031]]
    pname:index must: be less than
    sname:VkIndirectExecutionSetShaderInfoEXT::pname:maxShaderCount
  * [[VUID-VkWriteIndirectExecutionSetShaderEXT-shader-11032]]
    pname:shader must: have been created with
    ename:VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT
  * [[VUID-VkWriteIndirectExecutionSetShaderEXT-pInitialShaders-11033]]
    A shader created with the same elink:VkShaderStageFlagBits must: have
    been passed in the
    sname:VkIndirectExecutionSetShaderInfoEXT::pname:pInitialShaders array
  * [[VUID-VkWriteIndirectExecutionSetShaderEXT-index-11034]]
    pname:index must: not be in use by submitted command buffers
****

include::{generated}/validity/structs/VkWriteIndirectExecutionSetShaderEXT.adoc[]
--

[open,refpage='vkUpdateIndirectExecutionSetPipelineEXT',desc='Update the contents of an indirect execution set',type='protos']
--
:refpage: vkUpdateIndirectExecutionSetPipelineEXT

Pipeline elements in an Indirect Execution Set can be updated by calling:

include::{generated}/api/protos/vkUpdateIndirectExecutionSetPipelineEXT.adoc[]

  * pname:device is the logical device that owns the indirect execution set.
  * pname:indirectExecutionSet is the indirect execution set being updated.
  * pname:executionSetWriteCount is the number of elements in the
    pname:pExecutionSetWrites array.
  * pname:pExecutionSetWrites is a pointer to an array of
    slink:VkWriteIndirectExecutionSetPipelineEXT structures describing the
    elements to update.

.Valid Usage
****
  * [[VUID-vkUpdateIndirectExecutionSetPipelineEXT-indirectExecutionSet-11035]]
    pname:indirectExecutionSet must: have been created with type
    ename:VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT
  * [[VUID-vkUpdateIndirectExecutionSetPipelineEXT-executionSetWriteCount-11037]]
    pname:executionSetWriteCount must: be less than or equal to
    sname:VkIndirectExecutionSetPipelineInfoEXT::pname:maxPipelineCount
  * [[VUID-vkUpdateIndirectExecutionSetPipelineEXT-pExecutionSetWrites-11042]]
    Each element in the pname:pExecutionSetWrites array must have a unique
    sname:VkWriteIndirectExecutionSetPipelineEXT::pname:index
  * [[VUID-vkUpdateIndirectExecutionSetPipelineEXT-None-11038]]
    Each member of the Indirect Execution Set referenced by the update
    command must: not be in use by the device
ifdef::VK_EXT_descriptor_heap[]
  * [[VUID-vkUpdateIndirectExecutionSetPipelineEXT-initialPipeline-11324]]
    If pname:initialPipeline was created without
    ename:VK_PIPELINE_CREATE_2_DESCRIPTOR_HEAP_BIT_EXT, each pipeline in
    pname:pExecutionSetWrites must: also have been created without
    ename:VK_PIPELINE_CREATE_2_DESCRIPTOR_HEAP_BIT_EXT
  * [[VUID-vkUpdateIndirectExecutionSetPipelineEXT-initialPipeline-11325]]
    If pname:initialPipeline was created with
    ename:VK_PIPELINE_CREATE_2_DESCRIPTOR_HEAP_BIT_EXT, each pipeline in
    pname:pExecutionSetWrites must: also have been created with
    ename:VK_PIPELINE_CREATE_2_DESCRIPTOR_HEAP_BIT_EXT
endif::VK_EXT_descriptor_heap[]
  * [[VUID-vkUpdateIndirectExecutionSetPipelineEXT-None-11039]]
ifdef::VK_EXT_descriptor_heap[]
    If pname:initialPipeline was created without
    ename:VK_PIPELINE_CREATE_2_DESCRIPTOR_HEAP_BIT_EXT, the
endif::VK_EXT_descriptor_heap[]
ifndef::VK_EXT_descriptor_heap[]
    The
endif::VK_EXT_descriptor_heap[]
    layout of each pipeline in pname:pExecutionSetWrites must: be
    <<descriptorsets-compatibility,compatible>> with the
    pname:initialPipeline used to create the Indirect Execution Set
  * [[VUID-vkUpdateIndirectExecutionSetPipelineEXT-None-11040]]
    Each pipeline in the Indirect Execution Set must: have identically
    defined static and dynamic state values to the pname:initialPipeline
    used to create the Indirect Execution Set
  * [[VUID-vkUpdateIndirectExecutionSetPipelineEXT-initialPipeline-11147]]
    Each pipeline in the Indirect Execution Set must: have identically
    defined <<interfaces-fragmentoutput,fragment outputs interface>> to the
    pname:initialPipeline used to create the Indirect Execution Set
  * [[VUID-vkUpdateIndirectExecutionSetPipelineEXT-initialPipeline-11152]]
    Each pipeline in the Indirect Execution Set must: match the
    pname:initialPipeline used to create the Indirect Execution Set in its
    included shader stages
  * [[VUID-vkUpdateIndirectExecutionSetPipelineEXT-initialPipeline-11098]]
    Each pipeline in the Indirect Execution Set must: match the
    pname:initialPipeline used to create the Indirect Execution Set in its
    use of code:FragDepth
  * [[VUID-vkUpdateIndirectExecutionSetPipelineEXT-initialPipeline-11086]]
    Each pipeline in the Indirect Execution Set must: match the
    pname:initialPipeline used to create the Indirect Execution Set in its
    use of code:SampleMask
ifdef::VK_EXT_shader_stencil_export[]
  * [[VUID-vkUpdateIndirectExecutionSetPipelineEXT-initialPipeline-11085]]
    Each pipeline in the Indirect Execution Set must: match the
    pname:initialPipeline used to create the Indirect Execution Set in its
    use of code:StencilExportEXT
endif::VK_EXT_shader_stencil_export[]
****

include::{generated}/validity/protos/vkUpdateIndirectExecutionSetPipelineEXT.adoc[]
--

ifdef::VK_EXT_shader_object[]
[open,refpage='vkUpdateIndirectExecutionSetShaderEXT',desc='Update the contents of an indirect execution set',type='protos']
--
:refpage: vkUpdateIndirectExecutionSetShaderEXT

Shader object elements in an Indirect Execution Set can be updated by
calling:

include::{generated}/api/protos/vkUpdateIndirectExecutionSetShaderEXT.adoc[]

  * pname:device is the logical device that owns the indirect execution set.
  * pname:indirectExecutionSet is the indirect execution set being updated.
  * pname:executionSetWriteCount is the number of elements in the
    pname:pExecutionSetWrites array.
  * pname:pExecutionSetWrites is a pointer to an array of
    slink:VkWriteIndirectExecutionSetShaderEXT structures describing the
    elements to update.

.Valid Usage
****
  * [[VUID-vkUpdateIndirectExecutionSetShaderEXT-indirectExecutionSet-11041]]
    pname:indirectExecutionSet must: have been created with type
    ename:VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT
  * [[VUID-vkUpdateIndirectExecutionSetShaderEXT-pExecutionSetWrites-11043]]
    Each element in the pname:pExecutionSetWrites array must have a unique
    sname:VkWriteIndirectExecutionSetShaderEXT::pname:index
  * [[VUID-vkUpdateIndirectExecutionSetShaderEXT-None-11044]]
    Each member of the Indirect Execution Set referenced by the update
    command must: not be in use by the device
ifdef::VK_EXT_descriptor_heap[]
  * [[VUID-vkUpdateIndirectExecutionSetShaderEXT-pInitialShaders-11326]]
    If the shaders in pname:pInitialShaders were created without
    ename:VK_SHADER_CREATE_DESCRIPTOR_HEAP_BIT_EXT, each shader in
    pname:pExecutionSetWrites must: also have been created without
    ename:VK_SHADER_CREATE_DESCRIPTOR_HEAP_BIT_EXT
  * [[VUID-vkUpdateIndirectExecutionSetShaderEXT-pInitialShaders-11327]]
    If the shaders in pname:pInitialShaders were created with
    ename:VK_SHADER_CREATE_DESCRIPTOR_HEAP_BIT_EXT, each pipeline in
    pname:pExecutionSetWrites must: also have been created with
    ename:VK_SHADER_CREATE_DESCRIPTOR_HEAP_BIT_EXT
endif::VK_EXT_descriptor_heap[]
  * [[VUID-vkUpdateIndirectExecutionSetShaderEXT-pExecutionSetWrites-11140]]
ifdef::VK_EXT_descriptor_heap[]
    If the shaders in pname:pInitialShaders were created without
    ename:VK_SHADER_CREATE_DESCRIPTOR_HEAP_BIT_EXT, the
endif::VK_EXT_descriptor_heap[]
ifndef::VK_EXT_descriptor_heap[]
    The
endif::VK_EXT_descriptor_heap[]
    descriptor layout of each shader in pname:pExecutionSetWrites must: be
    <<descriptorsets-compatibility,compatible>> with the initial layout info
    used to create the Indirect Execution Set
  * [[VUID-vkUpdateIndirectExecutionSetShaderEXT-None-11148]]
    Each fragment shader element in the Indirect Execution Set must: have
    <<glossary-identically-defined,identically defined>>
    <<interfaces-fragmentoutput,fragment outputs interface>> to the initial
    shader state used to create the Indirect Execution Set
  * [[VUID-vkUpdateIndirectExecutionSetShaderEXT-FragDepth-11054]]
    Each fragment shader element in the Indirect Execution Set must: match
    the initial shader state used to create the Indirect Execution Set in
    its use of code:FragDepth
  * [[VUID-vkUpdateIndirectExecutionSetShaderEXT-SampleMask-11050]]
    Each fragment shader element in the Indirect Execution Set must: match
    the initial shader state used to create the Indirect Execution Set in
    its use of code:SampleMask
ifdef::VK_EXT_shader_stencil_export[]
  * [[VUID-vkUpdateIndirectExecutionSetShaderEXT-StencilExportEXT-11003]]
    Each fragment shader element in the Indirect Execution Set must: match
    the initial shader state used to create the Indirect Execution Set in
    its use of code:StencilExportEXT
endif::VK_EXT_shader_stencil_export[]
****

include::{generated}/validity/protos/vkUpdateIndirectExecutionSetShaderEXT.adoc[]
--
endif::VK_EXT_shader_object[]

It is legal to update an Indirect Execution Set that is in flight as long as
the element indices in pname:pExecutionSetWrites are not in use.
Any change to an indirect execution set requires recalculating memory
requirements by calling flink:vkGetGeneratedCommandsMemoryRequirementsEXT
for commands that use that modified state.
Commands that are in flight or those not using updated elements require no
changes.

The lifetimes of pipelines
ifdef::VK_EXT_shader_object[and shader objects]
contained in a set must: match or exceed the lifetime of the set.

endif::VK_EXT_device_generated_commands[]

ifdef::VK_NV_device_generated_commands[]
[open,refpage='vkCmdExecuteGeneratedCommandsNV',desc='Generate and execute commands on the device',type='protos']
--
:refpage: vkCmdExecuteGeneratedCommandsNV

With `apiext:VK_NV_device_generated_commands`, the actual generation of
commands as well as their execution on the device is handled as single
action with:

include::{generated}/api/protos/vkCmdExecuteGeneratedCommandsNV.adoc[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:isPreprocessed represents whether the input data has already been
    preprocessed on the device.
    If it is ename:VK_FALSE this command will implicitly trigger the
    preprocessing step, otherwise not.
  * pname:pGeneratedCommandsInfo is a pointer to a
    slink:VkGeneratedCommandsInfoNV structure containing parameters
    affecting the generation of commands.

If the ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV
flag was used to create the
slink:VkGeneratedCommandsInfoNV::pname:indirectCommandsLayout then the order
of execution of individual draws through this command may: execute in any
order, and may: not necessarily be in the same order as specified in
slink:VkGeneratedCommandsInfoNV::pname:pStreams.

ifdef::VK_NV_device_generated_commands_compute[]
The order of execution of individual dispatches through this command may:
execute in any order and may: not necessarily be in the same order as
specified in slink:VkGeneratedCommandsInfoNV::pname:pStreams.
endif::VK_NV_device_generated_commands_compute[]

.Valid Usage
****
include::{chapters}/commonvalidity/draw_common.adoc[]
include::{chapters}/commonvalidity/draw_vertex_binding.adoc[]
ifdef::VK_BASE_VERSION_1_1[]
  * [[VUID-vkCmdExecuteGeneratedCommandsNV-commandBuffer-02970]]
    pname:commandBuffer must: not be a protected command buffer
endif::VK_BASE_VERSION_1_1[]
  * [[VUID-vkCmdExecuteGeneratedCommandsNV-isPreprocessed-02908]]
    If pname:isPreprocessed is ename:VK_TRUE then
    flink:vkCmdPreprocessGeneratedCommandsNV must: have already been
    executed on the device, using the same pname:pGeneratedCommandsInfo
    content as well as the content of the input buffers it references (all
    except slink:VkGeneratedCommandsInfoNV::pname:preprocessBuffer).
    Furthermore, pname:pGeneratedCommandsInfo's pname:indirectCommandsLayout
    must: have been created with the
    ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV bit
    set
  * [[VUID-vkCmdExecuteGeneratedCommandsNV-pipeline-02909]]
    slink:VkGeneratedCommandsInfoNV::pname:pipeline must: match the current
    bound pipeline at
    slink:VkGeneratedCommandsInfoNV::pname:pipelineBindPoint
ifdef::VK_EXT_transform_feedback[]
  * [[VUID-vkCmdExecuteGeneratedCommandsNV-None-02910]]
    Transform feedback must: not be active
endif::VK_EXT_transform_feedback[]
  * [[VUID-vkCmdExecuteGeneratedCommandsNV-deviceGeneratedCommands-02911]]
    The <<features-deviceGeneratedCommandsNV,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::pname:deviceGeneratedCommands>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkCmdExecuteGeneratedCommandsNV.adoc[]
--

[open,refpage='VkGeneratedCommandsInfoNV',desc='Structure specifying parameters for the generation of commands',type='structs']
--
:refpage:

The sname:VkGeneratedCommandsInfoNV is defined as:

include::{generated}/api/structs/VkGeneratedCommandsInfoNV.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:pipelineBindPoint is the elink:VkPipelineBindPoint used for the
    pname:pipeline.
  * pname:pipeline is the slink:VkPipeline used in the generation and
    execution process.
  * pname:indirectCommandsLayout is the slink:VkIndirectCommandsLayoutNV
    that provides the command sequence to generate.
  * pname:streamCount defines the number of input streams
  * pname:pStreams is a pointer to an array of pname:streamCount
    slink:VkIndirectCommandsStreamNV structures providing the input data for
    the tokens used in pname:indirectCommandsLayout.
  * pname:sequencesCount is the maximum number of sequences to reserve.
    If pname:sequencesCountBuffer is dlink:VK_NULL_HANDLE, this is also the
    actual number of sequences generated.
  * pname:preprocessBuffer is the slink:VkBuffer that is used for
    preprocessing the input data for execution.
    If this structure is used with flink:vkCmdExecuteGeneratedCommandsNV
    with its pname:isPreprocessed set to ename:VK_TRUE, then the
    preprocessing step is skipped and data in this buffer will not be
    modified.
    The contents and the layout of this buffer are opaque to applications
    and must: not be modified outside functions related to device-generated
    commands or copied to another buffer for reuse.
  * pname:preprocessOffset is the byte offset into pname:preprocessBuffer
    where the preprocessed data is stored.
  * pname:preprocessSize is the maximum byte size within the
    pname:preprocessBuffer after the pname:preprocessOffset that is
    available for preprocessing.
  * pname:sequencesCountBuffer is a sname:VkBuffer in which the actual
    number of sequences is provided as single code:uint32_t value.
  * pname:sequencesCountOffset is the byte offset into
    pname:sequencesCountBuffer where the count value is stored.
  * pname:sequencesIndexBuffer is a sname:VkBuffer that encodes the used
    sequence indices as code:uint32_t array.
  * pname:sequencesIndexOffset is the byte offset into
    pname:sequencesIndexBuffer where the index values start.

.Valid Usage
****
  * [[VUID-VkGeneratedCommandsInfoNV-pipeline-02912]]
    The provided pname:pipeline must: match the pipeline bound at execution
    time
  * [[VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-02913]]
    If the pname:indirectCommandsLayout uses a token of
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV, then the
    pname:pipeline must: have been created with multiple shader groups
  * [[VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-02914]]
    If the pname:indirectCommandsLayout uses a token of
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV, then the
    pname:pipeline must: have been created with
    ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV set in
    sname:VkGraphicsPipelineCreateInfo::pname:flags
  * [[VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-02915]]
    If the pname:indirectCommandsLayout uses a token of
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, then the
    pname:pipeline's sname:VkPipelineLayout must: match the
    slink:VkIndirectCommandsLayoutTokenNV::pname:pushconstantPipelineLayout
  * [[VUID-VkGeneratedCommandsInfoNV-streamCount-02916]]
    pname:streamCount must: match the pname:indirectCommandsLayout's
    pname:streamCount
ifdef::VK_NV_device_generated_commands_compute[]
  * [[VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-09084]]
    If pname:pipelineBindPoint is of type
    ename:VK_PIPELINE_BIND_POINT_COMPUTE, then the pname:pipeline must: have
    been created with the flag
    ename:VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV
  * [[VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-09085]]
    If pname:pipelineBindPoint is of type
    ename:VK_PIPELINE_BIND_POINT_COMPUTE, then the pname:pipeline must: have
    been created with a slink:VkComputePipelineIndirectBufferInfoNV
    structure specifying a valid address where its metadata will be saved
  * [[VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-09086]]
    If pname:pipelineBindPoint is of type
    ename:VK_PIPELINE_BIND_POINT_COMPUTE, then
    flink:vkCmdUpdatePipelineIndirectBufferNV must: have been called on that
    pipeline to save its metadata to a device address
  * [[VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-09087]]
    If pname:pipelineBindPoint is of type
    ename:VK_PIPELINE_BIND_POINT_COMPUTE, and if
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV is used, then
    pname:pipeline must: be dlink:VK_NULL_HANDLE
endif::VK_NV_device_generated_commands_compute[]
  * [[VUID-VkGeneratedCommandsInfoNV-sequencesCount-02917]]
    pname:sequencesCount must: be less or equal to
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:maxIndirectSequenceCount
    and
    slink:VkGeneratedCommandsMemoryRequirementsInfoNV::pname:maxSequencesCount
    that was used to determine the pname:preprocessSize
  * [[VUID-VkGeneratedCommandsInfoNV-preprocessBuffer-02918]]
    pname:preprocessBuffer must: have the
    ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set in its usage flag
  * [[VUID-VkGeneratedCommandsInfoNV-preprocessOffset-02919]]
    pname:preprocessOffset must: be aligned to
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:minIndirectCommandsBufferOffsetAlignment
  * [[VUID-VkGeneratedCommandsInfoNV-preprocessBuffer-02971]]
    If pname:preprocessBuffer is non-sparse then it must: be bound
    completely and contiguously to a single sname:VkDeviceMemory object
  * [[VUID-VkGeneratedCommandsInfoNV-preprocessSize-02920]]
    pname:preprocessSize must: be at least equal to the memory requirement's
    size returned by flink:vkGetGeneratedCommandsMemoryRequirementsNV using
    the matching inputs (pname:indirectCommandsLayout, ...) as within this
    structure
  * [[VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-02921]]
    pname:sequencesCountBuffer can: be set if the actual used count of
    sequences is sourced from the provided buffer.
    In that case the pname:sequencesCount serves as upper bound
  * [[VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-02922]]
    If pname:sequencesCountBuffer is not dlink:VK_NULL_HANDLE, its usage
    flag must: have the ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-02923]]
    If pname:sequencesCountBuffer is not dlink:VK_NULL_HANDLE,
    pname:sequencesCountOffset must: be aligned to
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:minSequencesCountBufferOffsetAlignment
  * [[VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-02972]]
    If pname:sequencesCountBuffer is not dlink:VK_NULL_HANDLE and is
    non-sparse then it must: be bound completely and contiguously to a
    single sname:VkDeviceMemory object
  * [[VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-02924]]
    If pname:indirectCommandsLayout's
    ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV is set,
    pname:sequencesIndexBuffer must: be set otherwise it must: be
    dlink:VK_NULL_HANDLE
  * [[VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-02925]]
    If pname:sequencesIndexBuffer is not dlink:VK_NULL_HANDLE, its usage
    flag must: have the ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
  * [[VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-02926]]
    If pname:sequencesIndexBuffer is not dlink:VK_NULL_HANDLE,
    pname:sequencesIndexOffset must: be aligned to
    sname:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::pname:minSequencesIndexBufferOffsetAlignment
  * [[VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-02973]]
    If pname:sequencesIndexBuffer is not dlink:VK_NULL_HANDLE and is
    non-sparse then it must: be bound completely and contiguously to a
    single sname:VkDeviceMemory object
ifdef::VK_NV_mesh_shader[]
  * [[VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-07078]]
    If the pname:indirectCommandsLayout uses a token of
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV, then the
    pname:pipeline must: contain a shader stage using the code:MeshNV
    {ExecutionModel}
endif::VK_NV_mesh_shader[]
ifdef::VK_EXT_mesh_shader[]
  * [[VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-07079]]
    If the pname:indirectCommandsLayout uses a token of
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV, then the
    pname:pipeline must: contain a shader stage using the code:MeshEXT
    {ExecutionModel}
endif::VK_EXT_mesh_shader[]
****

include::{generated}/validity/structs/VkGeneratedCommandsInfoNV.adoc[]
--

Referencing the functions defined in <<indirectmdslayout>>,
fname:vkCmdExecuteGeneratedCommandsNV behaves as:

[source,c]
----
uint32_t sequencesCount = sequencesCountBuffer ?
      min(maxSequencesCount, sequencesCountBuffer.load_uint32(sequencesCountOffset) :
      maxSequencesCount;


cmdProcessAllSequences(commandBuffer, pipeline,
                       indirectCommandsLayout, pIndirectCommandsStreams,
                       sequencesCount,
                       sequencesIndexBuffer, sequencesIndexOffset);

// The stateful commands within indirectCommandsLayout will not
// affect the state of subsequent commands in the target
// command buffer (cmd)
----

[NOTE]
====
It is important to note that the values of all state related to the
pname:pipelineBindPoint used are undefined: after this command.
====

[open,refpage='vkCmdPreprocessGeneratedCommandsNV',desc='Performs preprocessing for generated commands',type='protos']
--
Commands can: be preprocessed prior execution using the following command:

include::{generated}/api/protos/vkCmdPreprocessGeneratedCommandsNV.adoc[]

  * pname:commandBuffer is the command buffer which does the preprocessing.
  * pname:pGeneratedCommandsInfo is a pointer to a
    slink:VkGeneratedCommandsInfoNV structure containing parameters
    affecting the preprocessing step.

.Valid Usage
****
ifdef::VK_BASE_VERSION_1_1[]
  * [[VUID-vkCmdPreprocessGeneratedCommandsNV-commandBuffer-02974]]
    pname:commandBuffer must: not be a protected command buffer
endif::VK_BASE_VERSION_1_1[]
  * [[VUID-vkCmdPreprocessGeneratedCommandsNV-pGeneratedCommandsInfo-02927]]
    pname:pGeneratedCommandsInfo->indirectCommandsLayout must: have been
    created with the
    ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV bit
    set
  * [[VUID-vkCmdPreprocessGeneratedCommandsNV-deviceGeneratedCommands-02928]]
    The <<features-deviceGeneratedCommandsNV,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::pname:deviceGeneratedCommands>>
    feature must: be enabled
****

include::{generated}/validity/protos/vkCmdPreprocessGeneratedCommandsNV.adoc[]
--

ifdef::VK_NV_device_generated_commands_compute[]
The bound descriptor sets and push constants that will be used with indirect
command generation for the compute pipelines must: already be specified at
the time of preprocessing commands with
flink:vkCmdPreprocessGeneratedCommandsNV.
They must: not change until the execution of indirect commands is submitted
with flink:vkCmdExecuteGeneratedCommandsNV.

If push constants for the compute pipeline are also specified in the
slink:VkGeneratedCommandsInfoNV::pname:indirectCommandsLayout with
ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV token, then those
values override the push constants that were previously pushed for the
compute pipeline.

endif::VK_NV_device_generated_commands_compute[]
endif::VK_NV_device_generated_commands[]

ifdef::VK_EXT_device_generated_commands[]
[open,refpage='vkCmdExecuteGeneratedCommandsEXT',desc='Generate and execute commands on the device',type='protos']
--
:refpage: vkCmdExecuteGeneratedCommandsEXT

With `apiext:VK_EXT_device_generated_commands`, the actual generation of
commands as well as their execution on the device is handled as single
action with:

include::{generated}/api/protos/vkCmdExecuteGeneratedCommandsEXT.adoc[]

  * pname:commandBuffer is the command buffer into which the command is
    recorded.
  * pname:isPreprocessed represents whether the input data has already been
    preprocessed on the device.
    If it is ename:VK_FALSE this command will implicitly trigger the
    preprocessing step, otherwise not.
  * pname:pGeneratedCommandsInfo is a pointer to a
    slink:VkGeneratedCommandsInfoEXT structure containing parameters
    affecting the generation of commands.

If the ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT
flag was used to create the
slink:VkGeneratedCommandsInfoEXT::pname:indirectCommandsLayout then the
execution of sequences through this command may: use implementation-defined
ordering which is not guaranteed to be coherent using the same input data.
It does not affect the order of token processing within a sequence.
This is the implied ordering with
ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT.

After a call to fname:vkCmdExecuteGeneratedCommandsEXT, command buffer state
will become undefined: according to the tokens executed.
This table specifies the relationship between tokens used and state
invalidation.

[[generatedcommands-indirect-execution-state-invalidation-table]]
.Indirect Execution State Invalidation
[width="80%",cols="67%,33%",options="header",align="center"]
|===
|*Common Tokens* | *States Invalidated*
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT            | Bound shaders and pipelines
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT            | Push constant data
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT           | Push constant data
ifdef::VK_EXT_descriptor_heap[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_EXT                | Push data
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_DATA_SEQUENCE_INDEX_EXT | Push data
endif::VK_EXT_descriptor_heap[]
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT             | Index buffer
|ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT            | Vertex buffer
|===

.Valid Usage
****
include::{chapters}/commonvalidity/draw_common.adoc[]
ifdef::VK_BASE_VERSION_1_1[]
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-commandBuffer-11045]]
    pname:commandBuffer must: not be a protected command buffer
endif::VK_BASE_VERSION_1_1[]
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11046]]
    If pname:isPreprocessed is ename:VK_TRUE and
    flink:vkGetGeneratedCommandsMemoryRequirementsEXT did not return a
    required size of zero then flink:vkCmdPreprocessGeneratedCommandsEXT
    must: have already been executed on the device before this command
    executes, and the preprocessing command must: have used the same
    pname:pGeneratedCommandsInfo content as well as the content of the input
    buffers it references (all except
    slink:VkGeneratedCommandsInfoEXT::pname:preprocessAddress)
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11047]]
    If pname:isPreprocessed is ename:VK_TRUE then the
    pname:indirectCommandsLayout member of pname:pGeneratedCommandsInfo
    must: have been created with the
    ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT bit
    set
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-indirectCommandsLayout-11141]]
    If the pname:indirectCommandsLayout member of
    pname:pGeneratedCommandsInfo was created with the
    ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT bit
    set, then pname:isPreprocessed must: be ename:VK_TRUE
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-preprocessAddress-11142]]
    The contents of the pname:preprocessAddress member of
    pname:pGeneratedCommandsInfo must: not have been previously used to
    record another flink:vkCmdExecuteGeneratedCommandsEXT
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11048]]
    If pname:isPreprocessed is ename:VK_TRUE then the bound descriptor sets
    and push constants must: match identically with those bound during
    recording of the corresponding call to
    flink:vkCmdPreprocessGeneratedCommandsEXT
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-10198]]
    If pname:isPreprocessed is ename:VK_TRUE then the conditional render
    state and its predicate value must: match identically with the state and
    value set during execution of the corresponding call to
    flink:vkCmdPreprocessGeneratedCommandsEXT
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11049]]
    If pname:isPreprocessed is ename:VK_TRUE and the
    pname:indirectCommandsLayout member of pname:pGeneratedCommandsInfo
    contains a draw token, then the graphics state bound on
    pname:commandBuffer must: match identically with the graphics state
    bound on the pname:stateCommandBuffer passed to
    flink:vkCmdPreprocessGeneratedCommandsEXT
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11149]]
    If pname:isPreprocessed is ename:VK_TRUE, then the queue family index of
    pname:commandBuffer must: be the same as the queue family index used to
    allocate the pname:stateCommandBuffer passed to
    flink:vkCmdPreprocessGeneratedCommandsEXT
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11051]]
    If pname:isPreprocessed is ename:VK_TRUE and the
    pname:indirectCommandsLayout member of pname:pGeneratedCommandsInfo
    contains a dispatch token, then the compute state bound on
    pname:commandBuffer must: match identically with the compute state bound
    on the pname:stateCommandBuffer passed to
    flink:vkCmdPreprocessGeneratedCommandsEXT
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11052]]
    If pname:isPreprocessed is ename:VK_TRUE and the
    pname:indirectCommandsLayout member of pname:pGeneratedCommandsInfo
    contains a ray tracing token, then the ray tracing state bound on
    pname:commandBuffer must: match identically with the ray tracing state
    bound on the pname:stateCommandBuffer passed to
    flink:vkCmdPreprocessGeneratedCommandsEXT
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11150]]
    If pname:isPreprocessed is ename:VK_TRUE and the
    pname:indirectCommandsLayout member of pname:pGeneratedCommandsInfo
    contains a ray tracing token, the queue family index pname:commandBuffer
    was allocated from must: be the same queue family index used to allocate
    the pname:stateCommandBuffer passed to
    flink:vkCmdPreprocessGeneratedCommandsEXT
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-indirectCommandsLayout-11053]]
    If the token sequence of the passed
    slink:VkGeneratedCommandsInfoEXT::pname:indirectCommandsLayout contains
    a ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, the
    initial shader state of
    slink:VkGeneratedCommandsInfoEXT::pname:indirectExecutionSet must: be
    bound on pname:commandBuffer
ifdef::VK_EXT_shader_object[]
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-indirectCommandsLayout-11004]]
    If pname:indirectCommandsLayout was created with a token sequence that
    contained the ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT
    token and pname:indirectExecutionSet was created using
    ename:VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT, every
    executed ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token
    must: bind all the shader stages set in the
    slink:VkIndirectCommandsExecutionSetTokenEXT::pname:shaderStages used to
    create pname:indirectCommandsLayout
endif::VK_EXT_shader_object[]
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11055]]
    If pname:isPreprocessed is ename:VK_TRUE and the token sequence of the
    passed slink:VkGeneratedCommandsInfoEXT::pname:indirectCommandsLayout
    contains a ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT
    token, the members of
    slink:VkGeneratedCommandsInfoEXT::pname:indirectExecutionSet accessed by
    this command must: not have been modified since the preprocess buffer
    was generated
ifdef::VK_EXT_fragment_density_map[]
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-indirectCommandsLayout-11056]]
    If the pname:indirectCommandsLayout member of
    pname:pGeneratedCommandsInfo contains a draw token, then the active
    render pass must: not have a specified fragment density map
endif::VK_EXT_fragment_density_map[]
ifdef::VK_EXT_transform_feedback[]
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-deviceGeneratedCommandsTransformFeedback-11057]]
    If
    <<limits-deviceGeneratedCommandsTransformFeedback,pname:deviceGeneratedCommandsTransformFeedback>>
    is not supported on device, transform feedback must: not be active
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-indirectExecutionSet-11058]]
    If transform feedback is active,
    slink:VkGeneratedCommandsInfoEXT::pname:indirectExecutionSet must: be
    dlink:VK_NULL_HANDLE
endif::VK_EXT_transform_feedback[]
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-deviceGeneratedCommands-11059]]
    The <<features-deviceGeneratedCommands,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::pname:deviceGeneratedCommands>>
    feature must: be enabled
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-supportedIndirectCommandsShaderStages-11060]]
    The bound shader stages must: be supported by
    <<limits-supportedIndirectCommandsShaderStages,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:supportedIndirectCommandsShaderStages>>
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-supportedIndirectCommandsShaderStages-11061]]
    Only stages specified in <<limits-supportedIndirectCommandsShaderStages,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:supportedIndirectCommandsShaderStages>>
    can: be set in pname:pGeneratedCommandsInfo->shaderStages
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-None-11062]]
    If a rendering pass is currently active, the view mask must: be `0`
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-commandBuffer-11143]]
    pname:commandBuffer must: not have been recorded with
    ename:VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-indirectCommandsLayout-10769]]
    If the pname:indirectCommandsLayout member of
    pname:pGeneratedCommandsInfo contains a draw token, this command must:
    not be called outside a render pass instance
  * [[VUID-vkCmdExecuteGeneratedCommandsEXT-indirectCommandsLayout-12202]]
    If the pname:indirectCommandsLayout member of
    pname:pGeneratedCommandsInfo does not contain a draw token, this command
    must: not be called inside a render pass instance
****

include::{generated}/validity/protos/vkCmdExecuteGeneratedCommandsEXT.adoc[]
--

[open,refpage='VkGeneratedCommandsInfoEXT',desc='Structure specifying parameters for the generation of commands',type='structs']
--
:refpage:

The sname:VkGeneratedCommandsInfoEXT is defined as:

include::{generated}/api/structs/VkGeneratedCommandsInfoEXT.adoc[]

  * pname:sType is a elink:VkStructureType value identifying this structure.
  * pname:pNext is `NULL` or a pointer to a structure extending this
    structure.
  * pname:shaderStages is the mask of shader stages used by the commands.
  * pname:indirectExecutionSet is the indirect execution set to be used for
    binding shaders.
  * pname:indirectCommandsLayout is the slink:VkIndirectCommandsLayoutEXT
    that specifies the command sequence data.
  * pname:indirectAddress is an address that holds the indirect buffer data.
  * pname:indirectAddressSize is the size in bytes of indirect buffer data
    starting at pname:indirectAddress.
  * pname:preprocessAddress specifies a physical address of the
    sname:VkBuffer used for preprocessing the input data for execution.
    If this structure is used with flink:vkCmdExecuteGeneratedCommandsEXT
    with its pname:isPreprocessed set to ename:VK_TRUE, then the
    preprocessing step is skipped but data in this address may: still be
    modified.
    The contents and the layout of this address are opaque to applications
    and must: not be modified outside functions related to device-generated
    commands or copied to another buffer for reuse.
  * pname:preprocessSize is the maximum byte size within
    pname:preprocessAddress that is available for preprocessing.
  * pname:maxSequenceCount is used to determine the number of sequences to
    execute.
  * pname:sequenceCountAddress specifies an optional physical address of a
    single code:uint32_t value containing the requested number of sequences
    to execute.
  * pname:maxDrawCount is the maximum number of indirect draws that can be
    executed by any COUNT-type multi-draw indirect tokens.
    The draw count in the indirect buffer is clamped to this value for these
    token types.

If pname:sequenceCountAddress is not `NULL`, then pname:maxSequenceCount is
the maximum number of sequences that can be executed.
The actual number is `min(maxSequenceCount, *sequenceCountAddress)`.
If pname:sequenceCountAddress is `NULL`, then pname:maxSequenceCount is the
exact number of sequences to execute.

If the action command token for the layout is not a COUNT-type multi-draw
indirect token, pname:maxDrawCount is ignored.

.Valid Usage
****
  * [[VUID-VkGeneratedCommandsInfoEXT-preprocessAddress-11063]]
    If flink:vkGetGeneratedCommandsMemoryRequirementsEXT returns a non-zero
    size, pname:preprocessAddress must: not be `0`
  * [[VUID-VkGeneratedCommandsInfoEXT-preprocessAddress-11064]]
    sname:VkDeviceMemory objects bound to the underlying buffer for
    pname:preprocessAddress must: have been allocated using one of the
    memory types allowed in the pname:memoryTypeBits member of the
    slink:VkMemoryRequirements structure returned by
    flink:vkGetGeneratedCommandsMemoryRequirementsEXT
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11065]]
    If the pname:indirectCommandsLayout uses a token of
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT, then the
    pname:indirectExecutionSet's push constant layout must: contain the
    pname:updateRange specified in
    slink:VkIndirectCommandsPushConstantTokenEXT
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11066]]
    If the pname:indirectCommandsLayout uses a token of
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT, then the
    pname:indirectExecutionSet's push constant layout must: contain the
    pname:updateRange specified in
    slink:VkIndirectCommandsPushConstantTokenEXT
  * [[VUID-VkGeneratedCommandsInfoEXT-maxSequenceCount-11067]]
    pname:maxSequenceCount must: be less or equal to
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:maxIndirectSequenceCount
    and
    slink:VkGeneratedCommandsMemoryRequirementsInfoEXT::pname:maxSequenceCount
    that was used to determine the pname:preprocessSize
  * [[VUID-VkGeneratedCommandsInfoEXT-sequenceCountAddress-11068]]
    If pname:sequenceCountAddress is not `NULL`, the value contained in the
    address must: be less or equal to
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:maxIndirectSequenceCount
    and
    slink:VkGeneratedCommandsMemoryRequirementsInfoEXT::pname:maxSequenceCount
    that was used to determine the pname:preprocessSize
  * [[VUID-VkGeneratedCommandsInfoEXT-maxSequenceCount-10246]]
    pname:maxSequenceCount must: not be zero
  * [[VUID-VkGeneratedCommandsInfoEXT-preprocessAddress-11069]]
    pname:preprocessAddress must: be a device address allocated to the
    application from a buffer created with the
    ename:VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT usage flag set
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11144]]
    If the pname:indirectCommandsLayout contains a
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, and there
    is a descriptor and push constant layout info provided either by
    pname:pipelineLayout or through a slink:VkPipelineLayoutCreateInfo in
    pname:pNext of the slink:VkIndirectCommandsLayoutCreateInfoEXT used to
    create pname:indirectCommandsLayout, the pipeline layout must: be
    <<descriptorsets-compatibility,compatible>> with the descriptor and push
    constant layout info used by pname:indirectExecutionSet
ifdef::VK_EXT_descriptor_heap[]
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11328]]
    If the pname:indirectCommandsLayout contains a
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, and there
    was no descriptor and push constant layout info provided either by
    pname:pipelineLayout or through a slink:VkPipelineLayoutCreateInfo in
    pname:pNext of the slink:VkIndirectCommandsLayoutCreateInfoEXT used to
    create pname:indirectCommandsLayout, pipelines in
    pname:indirectExecutionSet must: have been created with
    ename:VK_PIPELINE_CREATE_2_DESCRIPTOR_HEAP_BIT_EXT
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11329]]
    If the pname:indirectCommandsLayout contains a
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, and there
    was a descriptor and push constant layout info provided either by
    pname:pipelineLayout or through a slink:VkPipelineLayoutCreateInfo in
    pname:pNext of the slink:VkIndirectCommandsLayoutCreateInfoEXT used to
    create pname:indirectCommandsLayout, pipelines in
    pname:indirectExecutionSet must: have been created without
    ename:VK_PIPELINE_CREATE_2_DESCRIPTOR_HEAP_BIT_EXT
ifdef::VK_EXT_shader_object[]
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11330]]
    If the pname:indirectCommandsLayout contains a
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, and there
    was no descriptor and push constant layout info provided either by
    pname:pipelineLayout or through a slink:VkPipelineLayoutCreateInfo in
    pname:pNext of the slink:VkIndirectCommandsLayoutCreateInfoEXT used to
    create pname:indirectCommandsLayout, shaders in
    pname:indirectExecutionSet must: have been created with
    ename:VK_SHADER_CREATE_DESCRIPTOR_HEAP_BIT_EXT
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11331]]
    If the pname:indirectCommandsLayout contains a
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, and there
    was a descriptor and push constant layout info provided either by
    pname:pipelineLayout or through a slink:VkPipelineLayoutCreateInfo in
    pname:pNext of the slink:VkIndirectCommandsLayoutCreateInfoEXT used to
    create pname:indirectCommandsLayout, shaders in
    pname:indirectExecutionSet must: have been created without
    ename:VK_SHADER_CREATE_DESCRIPTOR_HEAP_BIT_EXT
endif::VK_EXT_shader_object[]
endif::VK_EXT_descriptor_heap[]
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11002]]
    If pname:indirectCommandsLayout was created with a token sequence that
    contained the ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT
    token, the shader stages used to create the initial shader state of
    pname:indirectExecutionSet must: equal the
    slink:VkIndirectCommandsExecutionSetTokenEXT::pname:shaderStages used to
    create pname:indirectCommandsLayout
  * [[VUID-VkGeneratedCommandsInfoEXT-preprocessSize-11071]]
    pname:preprocessSize must: be greater than or equal to the memory
    requirement's size returned by
    flink:vkGetGeneratedCommandsMemoryRequirementsEXT using the matching
    inputs (pname:indirectCommandsLayout, ...) as within this structure
  * [[VUID-VkGeneratedCommandsInfoEXT-sequenceCountAddress-11072]]
    The underlying buffer for pname:sequenceCountAddress must: have the
    ename:VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR bit set in its usage
    flag
  * [[VUID-VkGeneratedCommandsInfoEXT-sequenceCountAddress-11073]]
    If pname:sequenceCountAddress is not `NULL`, pname:sequenceCountAddress
    must: be aligned to `4`
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectAddress-11074]]
    pname:indirectAddress must: be aligned to `4`
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectAddressSize-11077]]
    pname:indirectAddressSize must: be greater than zero
  * [[VUID-VkGeneratedCommandsInfoEXT-maxDrawCount-11078]]
    When not ignored, [eq]#pname:maxDrawCount {times}
    pname:maxSequenceCount# must: be less than [eq]#2^24#
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11079]]
    If pname:indirectCommandsLayout was created using a
    ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT token
ifdef::VK_EXT_shader_object[and shader objects are not bound]
    then the bound graphics pipeline must: have been created with
    ename:VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE in
    pname:pDynamicStates
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11083]]
    If the token sequence of the passed pname:indirectCommandsLayout
    contains a ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT
    token, the pname:indirectExecutionSet must: not be dlink:VK_NULL_HANDLE
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-10241]]
    If the token sequence of the passed pname:indirectCommandsLayout does
    not contains a ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT
    token, the pname:indirectExecutionSet must: be dlink:VK_NULL_HANDLE
  * [[VUID-VkGeneratedCommandsInfoEXT-indirectExecutionSet-11080]]
    If pname:indirectExecutionSet is dlink:VK_NULL_HANDLE, a
    slink:VkGeneratedCommandsPipelineInfoEXT
ifdef::VK_EXT_shader_object[or slink:VkGeneratedCommandsShaderInfoEXT]
    must: be included in the pname:pNext chain
****

include::{generated}/validity/structs/VkGeneratedCommandsInfoEXT.adoc[]
--

Referencing the functions defined in <<indirectmdslayout>>,
fname:vkCmdExecuteGeneratedCommandsEXT behaves as:

[source,c]
----
uint32_t sequencesCount = sequenceCountAddress ?
      min(maxSequenceCount, sequenceCountAddress.load_uint32()) :
      maxSequenceCount;


cmdProcessAllSequences(commandBuffer, indirectExecutionSet,
                       indirectCommandsLayout, indirectAddress,
                       sequencesCount);

// The stateful commands within indirectCommandsLayout will not
// affect the state of subsequent commands in the target
// command buffer (cmd)
----

[NOTE]
====
It is important to note that the affected values of all state related to the
pname:shaderStages used are undefined: after this command.
This means that e.g., if this command indirectly alters push constants, the
push constant state becomes undefined:.
====

[open,refpage='vkCmdPreprocessGeneratedCommandsEXT',desc='Performs preprocessing for generated commands',type='protos']
--
Commands can: be preprocessed prior execution using the following command:

include::{generated}/api/protos/vkCmdPreprocessGeneratedCommandsEXT.adoc[]

  * pname:commandBuffer is the command buffer which does the preprocessing.
  * pname:pGeneratedCommandsInfo is a pointer to a
    slink:VkGeneratedCommandsInfoEXT structure containing parameters
    affecting the preprocessing step.
  * pname:stateCommandBuffer is a command buffer from which to snapshot
    current states affecting the preprocessing step.
    When a graphics command action token is used, graphics state is
    snapshotted.
    When a compute action command token is used, compute state is
    snapshotted.
    When a ray tracing action command token is used, ray tracing state is
    snapshotted.
    It can be deleted at any time after this command has been recorded.

[NOTE]
====
pname:stateCommandBuffer access is not synchronized by the driver, meaning
that this command buffer must: not be modified between threads in an unsafe
manner.
====

.Valid Usage
****
ifdef::VK_BASE_VERSION_1_1[]
  * [[VUID-vkCmdPreprocessGeneratedCommandsEXT-commandBuffer-11081]]
    pname:commandBuffer must: not be a protected command buffer
endif::VK_BASE_VERSION_1_1[]
  * [[VUID-vkCmdPreprocessGeneratedCommandsEXT-pGeneratedCommandsInfo-11082]]
    pname:pGeneratedCommandsInfo's pname:indirectCommandsLayout must: have
    been created with the
    ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT bit
    set
  * [[VUID-vkCmdPreprocessGeneratedCommandsEXT-indirectCommandsLayout-11084]]
    If the token sequence of the passed
    slink:VkGeneratedCommandsInfoEXT::pname:indirectCommandsLayout contains
    a ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, the
    initial shader state of
    slink:VkGeneratedCommandsInfoEXT::pname:indirectExecutionSet must: be
    bound on pname:stateCommandBuffer
  * [[VUID-vkCmdPreprocessGeneratedCommandsEXT-stateCommandBuffer-11138]]
    pname:stateCommandBuffer must: be in the recording state
  * [[VUID-vkCmdPreprocessGeneratedCommandsEXT-deviceGeneratedCommands-11087]]
    The <<features-deviceGeneratedCommands,
    sname:VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::pname:deviceGeneratedCommands>>
    feature must: be enabled
  * [[VUID-vkCmdPreprocessGeneratedCommandsEXT-supportedIndirectCommandsShaderStages-11088]]
    Only stages specified in <<limits-supportedIndirectCommandsShaderStages,
    slink:VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::pname:supportedIndirectCommandsShaderStages>>
    can: be set in pname:pGeneratedCommandsInfo->shaderStages
****

include::{generated}/validity/protos/vkCmdPreprocessGeneratedCommandsEXT.adoc[]
--

The bound descriptor sets and push constants that will be used with indirect
command generation must: already be specified on pname:stateCommandBuffer at
the time of preprocessing commands with
flink:vkCmdPreprocessGeneratedCommandsEXT.
They must: match the bound descriptor sets and push constants used in the
execution of indirect commands with flink:vkCmdExecuteGeneratedCommandsEXT.

If push constants for shader stages are also specified in the
slink:VkGeneratedCommandsInfoEXT::pname:indirectCommandsLayout with a
ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT or
ename:VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT token, then those
values override the push constants that were previously pushed.

All <<fundamentals-queueoperation-command-types, State-setting commands>>
that are bound on pname:stateCommandBuffer will be used.
Any parameters set by those commands must: be set identically in a command
buffer that flink:vkCmdExecuteGeneratedCommandsEXT is recorded into, at the
point flink:vkCmdExecuteGeneratedCommandsEXT is recorded.
ifdef::VK_EXT_conditional_rendering[]
If conditional rendering is used, the predicate value at preprocessing time
must: match the one at execution time.
endif::VK_EXT_conditional_rendering[]
The queue family index pname:stateCommandBuffer was allocated from must: be
the same as the queue family index of the command buffer used in
flink:vkCmdExecuteGeneratedCommandsEXT.

On some implementations, preprocessing may: have no effect on performance.

flink:vkCmdExecuteGeneratedCommandsEXT may: write to the preprocess buffer,
no matter the isPreprocess parameter.
In this case, the implementation must: insert appropriate synchronization
automatically, which corresponds to the following pseudocode:

* Barrier
** srcStageMask = DRAW_INDIRECT
** srcAccesMask = 0
** dstStageMask = COMMAND_PREPROCESS_BIT
** dstAccessMask = COMMAND_PREPROCESS_WRITE_BIT |
   COMMAND_PREPROCESS_READ_BIT
* Do internal writes
* Barrier
** srcStageMask = COMMAND_PREPROCESS_BIT
** srcAccesMask = COMMAND_PREPROCESS_WRITE_BIT
** dstStageMask = DRAW_INDIRECT
** dstAccessMask = INDIRECT_COMMAND_READ_BIT
* Execute

endif::VK_EXT_device_generated_commands[]
